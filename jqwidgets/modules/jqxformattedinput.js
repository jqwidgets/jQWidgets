
/* Release Date: Sep-17-2024 
Copyright (c) 2011-2024 jQWidgets. 
License: https://jqwidgets.com/license/ */


/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 2497:
/***/ ((module) => {

/* tslint:disable */
/* eslint-disable */
/* tslint:disable */
/* eslint-disable */
(function() {
	if (typeof document === 'undefined') { 
		return;
	}
/*!
 * Globalize
 *
 * http://github.com/jquery/globalize
 *
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */

(function( window, undefined ) {
if (document.Globalize) {
    return;
}

var Globalize,
	// private variables
	regexHex,
	regexInfinity,
	regexParseFloat,
	regexTrim,
	// private JavaScript utility functions
	arrayIndexOf,
	endsWith,
	extend,
	isArray,
	isFunction,
	isObject,
	startsWith,
	trim,
	truncate,
	zeroPad,
	// private Globalization utility functions
	appendPreOrPostMatch,
	expandFormat,
	formatDate,
	formatNumber,
	getTokenRegExp,
	getEra,
	getEraYear,
	parseExact,
	parseNegativePattern;

// Global variable (Globalize) or CommonJS module (globalize)
Globalize = function( cultureSelector ) {
	return new Globalize.prototype.init( cultureSelector );
};

if ( true ) {
	// Assume CommonJS
	module.exports = Globalize;
} else {}

Globalize.cultures = {};

Globalize.prototype = {
	constructor: Globalize,
	init: function( cultureSelector ) {
		this.cultures = Globalize.cultures;
		this.cultureSelector = cultureSelector;

		return this;
	}
};
Globalize.prototype.init.prototype = Globalize.prototype;

// 1. When defining a culture, all fields are required except the ones stated as optional.
// 2. Each culture should have a ".calendars" object with at least one calendar named "standard"
//    which serves as the default calendar in use by that culture.
// 3. Each culture should have a ".calendar" object which is the current calendar being used,
//    it may be dynamically changed at any time to one of the calendars in ".calendars".
Globalize.cultures[ "default" ] = {
	// A unique name for the culture in the form <language code>-<country/region code>
	name: "en",
	// the name of the culture in the english language
	englishName: "English",
	// the name of the culture in its own language
	nativeName: "English",
	// whether the culture uses right-to-left text
	isRTL: false,
	// "language" is used for so-called "specific" cultures.
	// For example, the culture "es-CL" means "Spanish, in Chili".
	// It represents the Spanish-speaking culture as it is in Chili,
	// which might have different formatting rules or even translations
	// than Spanish in Spain. A "neutral" culture is one that is not
	// specific to a region. For example, the culture "es" is the generic
	// Spanish culture, which may be a more generalized version of the language
	// that may or may not be what a specific culture expects.
	// For a specific culture like "es-CL", the "language" field refers to the
	// neutral, generic culture information for the language it is using.
	// This is not always a simple matter of the string before the dash.
	// For example, the "zh-Hans" culture is netural (Simplified Chinese).
	// And the "zh-SG" culture is Simplified Chinese in Singapore, whose lanugage
	// field is "zh-CHS", not "zh".
	// This field should be used to navigate from a specific culture to it's
	// more general, neutral culture. If a culture is already as general as it
	// can get, the language may refer to itself.
	language: "en",
	// numberFormat defines general number formatting rules, like the digits in
	// each grouping, the group separator, and how negative numbers are displayed.
	numberFormat: {
		// [negativePattern]
		// Note, numberFormat.pattern has no "positivePattern" unlike percent and currency,
		// but is still defined as an array for consistency with them.
		//   negativePattern: one of "(n)|-n|- n|n-|n -"
		pattern: [ "-n" ],
		// number of decimal places normally shown
		decimals: 2,
		// string that separates number groups, as in 1,000,000
		",": ",",
		// string that separates a number from the fractional portion, as in 1.99
		".": ".",
		// array of numbers indicating the size of each number group.
		// TODO: more detailed description and example
		groupSizes: [ 3 ],
		// symbol used for positive numbers
		"+": "+",
		// symbol used for negative numbers
		"-": "-",
		// symbol used for NaN (Not-A-Number)
		"NaN": "NaN",
		// symbol used for Negative Infinity
		negativeInfinity: "-Infinity",
		// symbol used for Positive Infinity
		positiveInfinity: "Infinity",
		percent: {
			// [negativePattern, positivePattern]
			//   negativePattern: one of "-n %|-n%|-%n|%-n|%n-|n-%|n%-|-% n|n %-|% n-|% -n|n- %"
			//   positivePattern: one of "n %|n%|%n|% n"
			pattern: [ "-n %", "n %" ],
			// number of decimal places normally shown
			decimals: 2,
			// array of numbers indicating the size of each number group.
			// TODO: more detailed description and example
			groupSizes: [ 3 ],
			// string that separates number groups, as in 1,000,000
			",": ",",
			// string that separates a number from the fractional portion, as in 1.99
			".": ".",
			// symbol used to represent a percentage
			symbol: "%"
		},
		currency: {
			// [negativePattern, positivePattern]
			//   negativePattern: one of "($n)|-$n|$-n|$n-|(n$)|-n$|n-$|n$-|-n $|-$ n|n $-|$ n-|$ -n|n- $|($ n)|(n $)"
			//   positivePattern: one of "$n|n$|$ n|n $"
			pattern: [ "($n)", "$n" ],
			// number of decimal places normally shown
			decimals: 2,
			// array of numbers indicating the size of each number group.
			// TODO: more detailed description and example
			groupSizes: [ 3 ],
			// string that separates number groups, as in 1,000,000
			",": ",",
			// string that separates a number from the fractional portion, as in 1.99
			".": ".",
			// symbol used to represent currency
			symbol: "$"
		}
	},
	// calendars defines all the possible calendars used by this culture.
	// There should be at least one defined with name "standard", and is the default
	// calendar used by the culture.
	// A calendar contains information about how dates are formatted, information about
	// the calendar's eras, a standard set of the date formats,
	// translations for day and month names, and if the calendar is not based on the Gregorian
	// calendar, conversion functions to and from the Gregorian calendar.
	calendars: {
		standard: {
			// name that identifies the type of calendar this is
			name: "Gregorian_USEnglish",
			// separator of parts of a date (e.g. "/" in 11/05/1955)
			"/": "/",
			// separator of parts of a time (e.g. ":" in 05:44 PM)
			":": ":",
			// the first day of the week (0 = Sunday, 1 = Monday, etc)
			firstDay: 0,
			days: {
				// full day names
				names: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
				// abbreviated day names
				namesAbbr: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
				// shortest day names
				namesShort: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ]
			},
			months: {
				// full month names (13 months for lunar calendards -- 13th month should be "" if not lunar)
				names: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", "" ],
				// abbreviated month names
				namesAbbr: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "" ]
			},
			// AM and PM designators in one of these forms:
			// The usual view, and the upper and lower case versions
			//   [ standard, lowercase, uppercase ]
			// The culture does not use AM or PM (likely all standard date formats use 24 hour time)
			//   null
			AM: [ "AM", "am", "AM" ],
			PM: [ "PM", "pm", "PM" ],
			eras: [
				// eras in reverse chronological order.
				// name: the name of the era in this culture (e.g. A.D., C.E.)
				// start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
				// offset: offset in years from gregorian calendar
				{
					"name": "A.D.",
					"start": null,
					"offset": 0
				}
			],
			// when a two digit year is given, it will never be parsed as a four digit
			// year greater than this year (in the appropriate era for the culture)
			// Set it as a full year (e.g. 2029) or use an offset format starting from
			// the current year: "+19" would correspond to 2029 if the current year 2010.
			twoDigitYearMax: 2029,
			// set of predefined date and time patterns used by the culture
			// these represent the format someone in this culture would expect
			// to see given the portions of the date that are shown.
			patterns: {
				// short date pattern
				d: "M/d/yyyy",
				// long date pattern
				D: "dddd, MMMM dd, yyyy",
				// short time pattern
				t: "h:mm tt",
				// long time pattern
				T: "h:mm:ss tt",
				// long date, short time pattern
				f: "dddd, MMMM dd, yyyy h:mm tt",
				// long date, long time pattern
				F: "dddd, MMMM dd, yyyy h:mm:ss tt",
				// month/day pattern
				M: "MMMM dd",
				// month/year pattern
				Y: "yyyy MMMM",
				// S is a sortable format that does not vary by culture
				S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss"
			}
			// optional fields for each calendar:
			/*
			monthsGenitive:
				Same as months but used when the day preceeds the month.
				Omit if the culture has no genitive distinction in month names.
				For an explaination of genitive months, see http://blogs.msdn.com/michkap/archive/2004/12/25/332259.aspx
			convert:
				Allows for the support of non-gregorian based calendars. This convert object is used to
				to convert a date to and from a gregorian calendar date to handle parsing and formatting.
				The two functions:
					fromGregorian( date )
						Given the date as a parameter, return an array with parts [ year, month, day ]
						corresponding to the non-gregorian based year, month, and day for the calendar.
					toGregorian( year, month, day )
						Given the non-gregorian year, month, and day, return a new Date() object
						set to the corresponding date in the gregorian calendar.
			*/
		}
	},
	// For localized strings
	messages: {}
};

Globalize.cultures[ "default" ].calendar = Globalize.cultures[ "default" ].calendars.standard;

Globalize.cultures.en = Globalize.cultures[ "default" ];

Globalize.cultureSelector = "en";

//
// private variables
//

regexHex = /^0x[a-f0-9]+$/i;
regexInfinity = /^[+\-]?infinity$/i;
regexParseFloat = /^[+\-]?\d*\.?\d*(e[+\-]?\d+)?$/;
regexTrim = /^\s+|\s+$/g;

//
// private JavaScript utility functions
//

arrayIndexOf = function( array, item ) {
	if ( array.indexOf ) {
		return array.indexOf( item );
	}
	for ( var i = 0, length = array.length; i < length; i++ ) {
		if ( array[i] === item ) {
			return i;
		}
	}
	return -1;
};

endsWith = function( value, pattern ) {
	return value.substr( value.length - pattern.length ) === pattern;
};

extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction(target) ) {
		target = {};
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( isObject(copy) || (copyIsArray = isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && isArray(src) ? src : [];

					} else {
						clone = src && isObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

isArray = Array.isArray || function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Array]";
};

isFunction = function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Function]";
};

isObject = function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Object]";
};

startsWith = function( value, pattern ) {
	return value.indexOf( pattern ) === 0;
};

trim = function( value ) {
	return ( value + "" ).replace( regexTrim, "" );
};

truncate = function( value ) {
	if ( isNaN( value ) ) {
		return NaN;
	}
	return Math[ value < 0 ? "ceil" : "floor" ]( value );
};

zeroPad = function( str, count, left ) {
	var l;
	for ( l = str.length; l < count; l += 1 ) {
		str = ( left ? ("0" + str) : (str + "0") );
	}
	return str;
};

//
// private Globalization utility functions
//

appendPreOrPostMatch = function( preMatch, strings ) {
	// appends pre- and post- token match strings while removing escaped characters.
	// Returns a single quote count which is used to determine if the token occurs
	// in a string literal.
	var quoteCount = 0,
		escaped = false;
	for ( var i = 0, il = preMatch.length; i < il; i++ ) {
		var c = preMatch.charAt( i );
		switch ( c ) {
			case "\'":
				if ( escaped ) {
					strings.push( "\'" );
				}
				else {
					quoteCount++;
				}
				escaped = false;
				break;
			case "\\":
				if ( escaped ) {
					strings.push( "\\" );
				}
				escaped = !escaped;
				break;
			default:
				strings.push( c );
				escaped = false;
				break;
		}
	}
	return quoteCount;
};

expandFormat = function( cal, format ) {
	// expands unspecified or single character date formats into the full pattern.
	format = format || "F";
	var pattern,
		patterns = cal.patterns,
		len = format.length;
	if ( len === 1 ) {
		pattern = patterns[ format ];
		if ( !pattern ) {
			throw "Invalid date format string \'" + format + "\'.";
		}
		format = pattern;
	}
	else if ( len === 2 && format.charAt(0) === "%" ) {
		// %X escape format -- intended as a custom format string that is only one character, not a built-in format.
		format = format.charAt( 1 );
	}
	return format;
};

formatDate = function( value, format, culture ) {
	var cal = culture.calendar,
		convert = cal.convert,
		ret;

	if ( !format || !format.length || format === "i" ) {
		if ( culture && culture.name.length ) {
			if ( convert ) {
				// non-gregorian calendar, so we cannot use built-in toLocaleString()
				ret = formatDate( value, cal.patterns.F, culture );
			}
			else {
				var eraDate = new Date( value.getTime() ),
					era = getEra( value, cal.eras );
				eraDate.setFullYear( getEraYear(value, cal, era) );
				ret = eraDate.toLocaleString();
			}
		}
		else {
			ret = value.toString();
		}
		return ret;
	}

	var eras = cal.eras,
		sortable = format === "s";
	format = expandFormat( cal, format );

	// Start with an empty string
	ret = [];
	var hour,
		zeros = [ "0", "00", "000" ],
		foundDay,
		checkedDay,
		dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,
		quoteCount = 0,
		tokenRegExp = getTokenRegExp(),
		converted;

	//function padZeros( num, c ) {
	//	var r, s = num + "";
	//	if ( c > 1 && s.length < c ) {
	//		r = ( zeros[c - 2] + s);
	//		return r.substr( r.length - c, c );
	//	}
	//	else {
	//		r = s;
	//	}
	//	return r;
	//}

	function padZeros(num, c) {
	    if (num < 0) {
	        return "-" + padZeros(-num, c);
	    }
	    var r, s = num + "";
	    if (c > 1 && s.length < c) {
	        r = (zeros[c - 2] + s);
	        return r.substr(r.length - c, c);
	    }
	    else {
	        r = s;
	    }
	    return r;
	}

	function hasDay() {
		if ( foundDay || checkedDay ) {
			return foundDay;
		}
		foundDay = dayPartRegExp.test( format );
		checkedDay = true;
		return foundDay;
	}

	function getPart( date, part ) {
		if ( converted ) {
			return converted[ part ];
		}
		switch ( part ) {
			case 0:
				return date.getFullYear();
			case 1:
				return date.getMonth();
			case 2:
				return date.getDate();
			default:
				throw "Invalid part value " + part;
		}
	}

	if ( !sortable && convert ) {
		converted = convert.fromGregorian( value );
	}

	for ( ; ; ) {
		// Save the current index
		var index = tokenRegExp.lastIndex,
			// Look for the next pattern
			ar = tokenRegExp.exec( format );

		// Append the text before the pattern (or the end of the string if not found)
		var preMatch = format.slice( index, ar ? ar.index : format.length );
		quoteCount += appendPreOrPostMatch( preMatch, ret );

		if ( !ar ) {
			break;
		}

		// do not replace any matches that occur inside a string literal.
		if ( quoteCount % 2 ) {
			ret.push( ar[0] );
			continue;
		}

		var current = ar[ 0 ],
			clength = current.length;

		switch ( current ) {
			case "ddd":
				//Day of the week, as a three-letter abbreviation
			case "dddd":
				// Day of the week, using the full name
				var names = ( clength === 3 ) ? cal.days.namesAbbr : cal.days.names;
				ret.push( names[value.getDay()] );
				break;
			case "d":
				// Day of month, without leading zero for single-digit days
			case "dd":
				// Day of month, with leading zero for single-digit days
				foundDay = true;
				ret.push(
					padZeros( getPart(value, 2), clength )
				);
				break;
			case "MMM":
				// Month, as a three-letter abbreviation
			case "MMMM":
				// Month, using the full name
				var part = getPart( value, 1 );
				ret.push(
					( cal.monthsGenitive && hasDay() ) ?
					( cal.monthsGenitive[ clength === 3 ? "namesAbbr" : "names" ][ part ] ) :
					( cal.months[ clength === 3 ? "namesAbbr" : "names" ][ part ] )
				);
				break;
			case "M":
				// Month, as digits, with no leading zero for single-digit months
			case "MM":
				// Month, as digits, with leading zero for single-digit months
				ret.push(
					padZeros( getPart(value, 1) + 1, clength )
				);
				break;
			case "y":
				// Year, as two digits, but with no leading zero for years less than 10
			case "yy":
				// Year, as two digits, with leading zero for years less than 10
			case "yyyy":
				// Year represented by four full digits
				part = converted ? converted[ 0 ] : getEraYear( value, cal, getEra(value, eras), sortable );
				if ( clength < 4 ) {
					part = part % 100;
				}
				ret.push(
					padZeros( part, clength )
				);
				break;
			case "h":
				// Hours with no leading zero for single-digit hours, using 12-hour clock
			case "hh":
				// Hours with leading zero for single-digit hours, using 12-hour clock
				hour = value.getHours() % 12;
				if ( hour === 0 ) hour = 12;
				ret.push(
					padZeros( hour, clength )
				);
				break;
			case "H":
				// Hours with no leading zero for single-digit hours, using 24-hour clock
			case "HH":
				// Hours with leading zero for single-digit hours, using 24-hour clock
				ret.push(
					padZeros( value.getHours(), clength )
				);
				break;
			case "m":
				// Minutes with no leading zero for single-digit minutes
			case "mm":
				// Minutes with leading zero for single-digit minutes
				ret.push(
					padZeros( value.getMinutes(), clength )
				);
				break;
			case "s":
				// Seconds with no leading zero for single-digit seconds
			case "ss":
				// Seconds with leading zero for single-digit seconds
				ret.push(
					padZeros( value.getSeconds(), clength )
				);
				break;
			case "t":
				// One character am/pm indicator ("a" or "p")
			case "tt":
				// Multicharacter am/pm indicator
				part = value.getHours() < 12 ? ( cal.AM ? cal.AM[0] : " " ) : ( cal.PM ? cal.PM[0] : " " );
				ret.push( clength === 1 ? part.charAt(0) : part );
				break;
			case "f":
				// Deciseconds
			case "ff":
				// Centiseconds
			case "fff":
				// Milliseconds
				ret.push(
					padZeros( value.getMilliseconds(), 3 ).substr( 0, clength )
				);
				break;
			case "z":
				// Time zone offset, no leading zero
			case "zz":
				// Time zone offset with leading zero
				hour = value.getTimezoneOffset() / 60;
				ret.push(
					( hour <= 0 ? "+" : "-" ) + padZeros( Math.floor(Math.abs(hour)), clength )
				);
				break;
			case "zzz":
				// Time zone offset with leading zero
				hour = value.getTimezoneOffset() / 60;
				ret.push(
					( hour <= 0 ? "+" : "-" ) + padZeros( Math.floor(Math.abs(hour)), 2 ) +
					// Hard coded ":" separator, rather than using cal.TimeSeparator
					// Repeated here for consistency, plus ":" was already assumed in date parsing.
					":" + padZeros( Math.abs(value.getTimezoneOffset() % 60), 2 )
				);
				break;
			case "g":
			case "gg":
				if ( cal.eras ) {
					ret.push(
						cal.eras[ getEra(value, eras) ].name
					);
				}
				break;
		case "/":
			ret.push( cal["/"] );
			break;
		default:
			throw "Invalid date format pattern \'" + current + "\'.";
		}
	}
	return ret.join( "" );
};

// formatNumber
(function() {
	var expandNumber;

	expandNumber = function( number, precision, formatInfo ) {
		var groupSizes = formatInfo.groupSizes,
			curSize = groupSizes[ 0 ],
			curGroupIndex = 1,
			factor = Math.pow( 10, precision ),
			rounded = Math.round( number * factor ) / factor;

		if ( !isFinite(rounded) ) {
			rounded = number;
		}
		number = rounded;

		var numberString = number+"",
			right = "",
			split = numberString.split( /e/i ),
			exponent = split.length > 1 ? parseInt( split[1], 10 ) : 0;
		numberString = split[ 0 ];
		split = numberString.split( "." );
		numberString = split[ 0 ];
		right = split.length > 1 ? split[ 1 ] : "";

		var l;
		if ( exponent > 0 ) {
			right = zeroPad( right, exponent, false );
			numberString += right.slice( 0, exponent );
			right = right.substr( exponent );
		}
		else if ( exponent < 0 ) {
			exponent = -exponent;
			numberString = zeroPad( numberString, exponent + 1, true );
			right = numberString.slice( -exponent, numberString.length ) + right;
			numberString = numberString.slice( 0, -exponent );
		}

		if ( precision > 0 ) {
			right = formatInfo[ "." ] +
				( (right.length > precision) ? right.slice(0, precision) : zeroPad(right, precision) );
		}
		else {
			right = "";
		}

		var stringIndex = numberString.length - 1,
			sep = formatInfo[ "," ],
			ret = "";

		while ( stringIndex >= 0 ) {
			if ( curSize === 0 || curSize > stringIndex ) {
				return numberString.slice( 0, stringIndex + 1 ) + ( ret.length ? (sep + ret + right) : right );
			}
			ret = numberString.slice( stringIndex - curSize + 1, stringIndex + 1 ) + ( ret.length ? (sep + ret) : "" );

			stringIndex -= curSize;

			if ( curGroupIndex < groupSizes.length ) {
				curSize = groupSizes[ curGroupIndex ];
				curGroupIndex++;
			}
		}

		return numberString.slice( 0, stringIndex + 1 ) + sep + ret + right;
	};

	formatNumber = function( value, format, culture ) {
		if ( !isFinite(value) ) {
			if ( value === Infinity ) {
				return culture.numberFormat.positiveInfinity;
			}
			if ( value === -Infinity ) {
				return culture.numberFormat.negativeInfinity;
			}
			return culture.numberFormat.NaN;
		}
		if ( !format || format === "i" ) {
			return culture.name.length ? value.toLocaleString() : value.toString();
		}
		format = format || "D";

		var nf = culture.numberFormat,
			number = Math.abs( value ),
			precision = -1,
			pattern;
		if ( format.length > 1 ) precision = parseInt( format.slice(1), 10 );

		var current = format.charAt( 0 ).toUpperCase(),
			formatInfo;

		switch ( current ) {
			case "D":
				pattern = "n";
				number = truncate( number );
				if ( precision !== -1 ) {
					number = zeroPad( "" + number, precision, true );
				}
				if ( value < 0 ) number = "-" + number;
				break;
			case "N":
				formatInfo = nf;
				/* falls through */
			case "C":
				formatInfo = formatInfo || nf.currency;
				/* falls through */
			case "P":
				formatInfo = formatInfo || nf.percent;
				pattern = value < 0 ? formatInfo.pattern[ 0 ] : ( formatInfo.pattern[1] || "n" );
				if ( precision === -1 ) precision = formatInfo.decimals;
				number = expandNumber( number * (current === "P" ? 100 : 1), precision, formatInfo );
				break;
			default:
				throw "Bad number format specifier: " + current;
		}

		var patternParts = /n|\$|-|%/g,
			ret = "";
		for ( ; ; ) {
			var index = patternParts.lastIndex,
				ar = patternParts.exec( pattern );

			ret += pattern.slice( index, ar ? ar.index : pattern.length );

			if ( !ar ) {
				break;
			}

			switch ( ar[0] ) {
				case "n":
					ret += number;
					break;
				case "$":
					ret += nf.currency.symbol;
					break;
				case "-":
					// don't make 0 negative
					if ( /[1-9]/.test(number) ) {
						ret += nf[ "-" ];
					}
					break;
				case "%":
					ret += nf.percent.symbol;
					break;
			}
		}

		return ret;
	};

}());

getTokenRegExp = function() {
	// regular expression for matching date and time tokens in format strings.
	return (/\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g);
};

getEra = function( date, eras ) {
	if ( !eras ) return 0;
	var start, ticks = date.getTime();
	for ( var i = 0, l = eras.length; i < l; i++ ) {
		start = eras[ i ].start;
		if ( start === null || ticks >= start ) {
			return i;
		}
	}
	return 0;
};

getEraYear = function( date, cal, era, sortable ) {
	var year = date.getFullYear();
	if ( !sortable && cal.eras ) {
		// convert normal gregorian year to era-shifted gregorian
		// year by subtracting the era offset
		year -= cal.eras[ era ].offset;
	}
	return year;
};

// parseExact
(function() {
	var expandYear,
		getDayIndex,
		getMonthIndex,
		getParseRegExp,
		outOfRange,
		toUpper,
		toUpperArray;

	expandYear = function( cal, year ) {
		// expands 2-digit year into 4 digits.
		if ( year < 100 ) {
			var now = new Date(),
				era = getEra( now ),
				curr = getEraYear( now, cal, era ),
				twoDigitYearMax = cal.twoDigitYearMax;
			twoDigitYearMax = typeof twoDigitYearMax === "string" ? new Date().getFullYear() % 100 + parseInt( twoDigitYearMax, 10 ) : twoDigitYearMax;
			year += curr - ( curr % 100 );
			if ( year > twoDigitYearMax ) {
				year -= 100;
			}
		}
		return year;
	};

	getDayIndex = function	( cal, value, abbr ) {
		var ret,
			days = cal.days,
			upperDays = cal._upperDays;
		if ( !upperDays ) {
			cal._upperDays = upperDays = [
				toUpperArray( days.names ),
				toUpperArray( days.namesAbbr ),
				toUpperArray( days.namesShort )
			];
		}
		value = toUpper( value );
		if ( abbr ) {
			ret = arrayIndexOf( upperDays[1], value );
			if ( ret === -1 ) {
				ret = arrayIndexOf( upperDays[2], value );
			}
		}
		else {
			ret = arrayIndexOf( upperDays[0], value );
		}
		return ret;
	};

	getMonthIndex = function( cal, value, abbr ) {
		var months = cal.months,
			monthsGen = cal.monthsGenitive || cal.months,
			upperMonths = cal._upperMonths,
			upperMonthsGen = cal._upperMonthsGen;
		if ( !upperMonths ) {
			cal._upperMonths = upperMonths = [
				toUpperArray( months.names ),
				toUpperArray( months.namesAbbr )
			];
			cal._upperMonthsGen = upperMonthsGen = [
				toUpperArray( monthsGen.names ),
				toUpperArray( monthsGen.namesAbbr )
			];
		}
		value = toUpper( value );
		var i = arrayIndexOf( abbr ? upperMonths[1] : upperMonths[0], value );
		if ( i < 0 ) {
			i = arrayIndexOf( abbr ? upperMonthsGen[1] : upperMonthsGen[0], value );
		}
		return i;
	};

	getParseRegExp = function( cal, format ) {
		// converts a format string into a regular expression with groups that
		// can be used to extract date fields from a date string.
		// check for a cached parse regex.
		var re = cal._parseRegExp;
		if ( !re ) {
			cal._parseRegExp = re = {};
		}
		else {
			var reFormat = re[ format ];
			if ( reFormat ) {
				return reFormat;
			}
		}

		// expand single digit formats, then escape regular expression characters.
		var expFormat = expandFormat( cal, format ).replace( /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\\\$1" ),
			regexp = [ "^" ],
			groups = [],
			index = 0,
			quoteCount = 0,
			tokenRegExp = getTokenRegExp(),
			match;

		// iterate through each date token found.
		while ( (match = tokenRegExp.exec(expFormat)) !== null ) {
			var preMatch = expFormat.slice( index, match.index );
			index = tokenRegExp.lastIndex;

			// don't replace any matches that occur inside a string literal.
			quoteCount += appendPreOrPostMatch( preMatch, regexp );
			if ( quoteCount % 2 ) {
				regexp.push( match[0] );
				continue;
			}

			// add a regex group for the token.
			var m = match[ 0 ],
				len = m.length,
				add;
			switch ( m ) {
				case "dddd": case "ddd":
				case "MMMM": case "MMM":
				case "gg": case "g":
					add = "(\\D+)";
					break;
				case "tt": case "t":
					add = "(\\D*)";
					break;
				case "yyyy":
				case "fff":
				case "ff":
				case "f":
					add = "(\\d{" + len + "})";
					break;
				case "dd": case "d":
				case "MM": case "M":
				case "yy": case "y":
				case "HH": case "H":
				case "hh": case "h":
				case "mm": case "m":
				case "ss": case "s":
					add = "(\\d\\d?)";
					break;
				case "zzz":
					add = "([+-]?\\d\\d?:\\d{2})";
					break;
				case "zz": case "z":
					add = "([+-]?\\d\\d?)";
					break;
				case "/":
					add = "(\\/)";
					break;
				default:
					throw "Invalid date format pattern \'" + m + "\'.";
			}
			if ( add ) {
				regexp.push( add );
			}
			groups.push( match[0] );
		}
		appendPreOrPostMatch( expFormat.slice(index), regexp );
		regexp.push( "$" );

		// allow whitespace to differ when matching formats.
		var regexpStr = regexp.join( "" ).replace( /\s+/g, "\\s+" ),
			parseRegExp = { "regExp": regexpStr, "groups": groups };

		// cache the regex for this format.
		return re[ format ] = parseRegExp;
	};

	outOfRange = function( value, low, high ) {
		return value < low || value > high;
	};

	toUpper = function( value ) {
		// "he-IL" has non-breaking space in weekday names.
		return value.split( "\u00A0" ).join( " " ).toUpperCase();
	};

	toUpperArray = function( arr ) {
		var results = [];
		for ( var i = 0, l = arr.length; i < l; i++ ) {
			results[ i ] = toUpper( arr[i] );
		}
		return results;
	};

	parseExact = function( value, format, culture ) {
		// try to parse the date string by matching against the format string
		// while using the specified culture for date field names.
		value = trim( value );
		var cal = culture.calendar,
			// convert date formats into regular expressions with groupings.
			// use the regexp to determine the input format and extract the date fields.
			parseInfo = getParseRegExp( cal, format ),
			match = new RegExp( parseInfo.regExp ).exec( value );
		if ( match === null ) {
			return null;
		}
		// found a date format that matches the input.
		var groups = parseInfo.groups,
			era = null, year = null, month = null, date = null, weekDay = null,
			hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,
			pmHour = false;
		// iterate the format groups to extract and set the date fields.
		for ( var j = 0, jl = groups.length; j < jl; j++ ) {
			var matchGroup = match[ j + 1 ];
			if ( matchGroup ) {
				var current = groups[ j ],
					clength = current.length,
					matchInt = parseInt( matchGroup, 10 );
				switch ( current ) {
					case "dd": case "d":
						// Day of month.
						date = matchInt;
						// check that date is generally in valid range, also checking overflow below.
						if ( outOfRange(date, 1, 31) ) return null;
						break;
					case "MMM": case "MMMM":
						month = getMonthIndex( cal, matchGroup, clength === 3 );
						if ( outOfRange(month, 0, 11) ) return null;
						break;
					case "M": case "MM":
						// Month.
						month = matchInt - 1;
						if ( outOfRange(month, 0, 11) ) return null;
						break;
					case "y": case "yy":
					case "yyyy":
						year = clength < 4 ? expandYear( cal, matchInt ) : matchInt;
						if ( outOfRange(year, 0, 9999) ) return null;
						break;
					case "h": case "hh":
						// Hours (12-hour clock).
						hour = matchInt;
						if ( hour === 12 ) hour = 0;
						if ( outOfRange(hour, 0, 11) ) return null;
						break;
					case "H": case "HH":
						// Hours (24-hour clock).
						hour = matchInt;
						if ( outOfRange(hour, 0, 23) ) return null;
						break;
					case "m": case "mm":
						// Minutes.
						min = matchInt;
						if ( outOfRange(min, 0, 59) ) return null;
						break;
					case "s": case "ss":
						// Seconds.
						sec = matchInt;
						if ( outOfRange(sec, 0, 59) ) return null;
						break;
					case "tt": case "t":
						// AM/PM designator.
						// see if it is standard, upper, or lower case PM. If not, ensure it is at least one of
						// the AM tokens. If not, fail the parse for this format.
						pmHour = cal.PM && ( matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2] );
						if (
							!pmHour && (
								!cal.AM || ( matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2] )
							)
						) return null;
						break;
					case "f":
						// Deciseconds.
					case "ff":
						// Centiseconds.
					case "fff":
						// Milliseconds.
						msec = matchInt * Math.pow( 10, 3 - clength );
						if ( outOfRange(msec, 0, 999) ) return null;
						break;
					case "ddd":
						// Day of week.
					case "dddd":
						// Day of week.
						weekDay = getDayIndex( cal, matchGroup, clength === 3 );
						if ( outOfRange(weekDay, 0, 6) ) return null;
						break;
					case "zzz":
						// Time zone offset in +/- hours:min.
						var offsets = matchGroup.split( /:/ );
						if ( offsets.length !== 2 ) return null;
						hourOffset = parseInt( offsets[0], 10 );
						if ( outOfRange(hourOffset, -12, 13) ) return null;
						var minOffset = parseInt( offsets[1], 10 );
						if ( outOfRange(minOffset, 0, 59) ) return null;
						tzMinOffset = ( hourOffset * 60 ) + ( startsWith(matchGroup, "-") ? -minOffset : minOffset );
						break;
					case "z": case "zz":
						// Time zone offset in +/- hours.
						hourOffset = matchInt;
						if ( outOfRange(hourOffset, -12, 13) ) return null;
						tzMinOffset = hourOffset * 60;
						break;
					case "g": case "gg":
						var eraName = matchGroup;
						if ( !eraName || !cal.eras ) return null;
						eraName = trim( eraName.toLowerCase() );
						for ( var i = 0, l = cal.eras.length; i < l; i++ ) {
							if ( eraName === cal.eras[i].name.toLowerCase() ) {
								era = i;
								break;
							}
						}
						// could not find an era with that name
						if ( era === null ) return null;
						break;
				}
			}
		}
		var result = new Date(), defaultYear, convert = cal.convert;
		defaultYear = convert ? convert.fromGregorian( result )[ 0 ] : result.getFullYear();
		if ( year === null ) {
			year = defaultYear;
		}
		else if ( cal.eras ) {
			// year must be shifted to normal gregorian year
			// but not if year was not specified, its already normal gregorian
			// per the main if clause above.
			year += cal.eras[( era || 0 )].offset;
		}
		// set default day and month to 1 and January, so if unspecified, these are the defaults
		// instead of the current day/month.
		if ( month === null ) {
			month = 0;
		}
		if ( date === null ) {
			date = 1;
		}
		// now have year, month, and date, but in the culture's calendar.
		// convert to gregorian if necessary
		if ( convert ) {
			result = convert.toGregorian( year, month, date );
			// conversion failed, must be an invalid match
			if ( result === null ) return null;
		}
		else {
			// have to set year, month and date together to avoid overflow based on current date.
			result.setFullYear( year, month, date );
			// check to see if date overflowed for specified month (only checked 1-31 above).
			if ( result.getDate() !== date ) return null;
			// invalid day of week.
			if ( weekDay !== null && result.getDay() !== weekDay ) {
				return null;
			}
		}
		// if pm designator token was found make sure the hours fit the 24-hour clock.
		if ( pmHour && hour < 12 ) {
			hour += 12;
		}
		result.setHours( hour, min, sec, msec );
		if ( tzMinOffset !== null ) {
			// adjust timezone to utc before applying local offset.
			var adjustedMin = result.getMinutes() - ( tzMinOffset + result.getTimezoneOffset() );
			// Safari limits hours and minutes to the range of -127 to 127.  We need to use setHours
			// to ensure both these fields will not exceed this range.	adjustedMin will range
			// somewhere between -1440 and 1500, so we only need to split this into hours.
			result.setHours( result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60 );
		}
		return result;
	};
}());

parseNegativePattern = function( value, nf, negativePattern ) {
	var neg = nf[ "-" ],
		pos = nf[ "+" ],
		ret;
	switch ( negativePattern ) {
		case "n -":
			neg = " " + neg;
			pos = " " + pos;
			/* falls through */
		case "n-":
			if ( endsWith(value, neg) ) {
				ret = [ "-", value.substr(0, value.length - neg.length) ];
			}
			else if ( endsWith(value, pos) ) {
				ret = [ "+", value.substr(0, value.length - pos.length) ];
			}
			break;
		case "- n":
			neg += " ";
			pos += " ";
			/* falls through */
		case "-n":
			if ( startsWith(value, neg) ) {
				ret = [ "-", value.substr(neg.length) ];
			}
			else if ( startsWith(value, pos) ) {
				ret = [ "+", value.substr(pos.length) ];
			}
			break;
		case "(n)":
			if ( startsWith(value, "(") && endsWith(value, ")") ) {
				ret = [ "-", value.substr(1, value.length - 2) ];
			}
			break;
	}
	return ret || [ "", value ];
};

//
// public instance functions
//

Globalize.prototype.findClosestCulture = function( cultureSelector ) {
	return Globalize.findClosestCulture.call( this, cultureSelector );
};

Globalize.prototype.format = function( value, format, cultureSelector ) {
	return Globalize.format.call( this, value, format, cultureSelector );
};

Globalize.prototype.localize = function( key, cultureSelector ) {
	return Globalize.localize.call( this, key, cultureSelector );
};

Globalize.prototype.parseInt = function( value, radix, cultureSelector ) {
	return Globalize.parseInt.call( this, value, radix, cultureSelector );
};

Globalize.prototype.parseFloat = function( value, radix, cultureSelector ) {
	return Globalize.parseFloat.call( this, value, radix, cultureSelector );
};

Globalize.prototype.culture = function( cultureSelector ) {
	return Globalize.culture.call( this, cultureSelector );
};

//
// public singleton functions
//

Globalize.addCultureInfo = function( cultureName, baseCultureName, info ) {

	var base = {},
		isNew = false;

	if ( typeof cultureName !== "string" ) {
		// cultureName argument is optional string. If not specified, assume info is first
		// and only argument. Specified info deep-extends current culture.
		info = cultureName;
		cultureName = this.culture().name;
		base = this.cultures[ cultureName ];
	} else if ( typeof baseCultureName !== "string" ) {
		// baseCultureName argument is optional string. If not specified, assume info is second
		// argument. Specified info deep-extends specified culture.
		// If specified culture does not exist, create by deep-extending default
		info = baseCultureName;
		isNew = ( this.cultures[ cultureName ] == null );
		base = this.cultures[ cultureName ] || this.cultures[ "default" ];
	} else {
		// cultureName and baseCultureName specified. Assume a new culture is being created
		// by deep-extending an specified base culture
		isNew = true;
		base = this.cultures[ baseCultureName ];
	}

	this.cultures[ cultureName ] = extend(true, {},
		base,
		info
	);
	// Make the standard calendar the current culture if it's a new culture
	if ( isNew ) {
		this.cultures[ cultureName ].calendar = this.cultures[ cultureName ].calendars.standard;
	}
};

Globalize.findClosestCulture = function( name ) {
	var match;
	if ( !name ) {
		return this.findClosestCulture( this.cultureSelector ) || this.cultures[ "default" ];
	}
	if ( typeof name === "string" ) {
		name = name.split( "," );
	}
	if ( isArray(name) ) {
		var lang,
			cultures = this.cultures,
			list = name,
			i, l = list.length,
			prioritized = [];
		for ( i = 0; i < l; i++ ) {
			name = trim( list[i] );
			var pri, parts = name.split( ";" );
			lang = trim( parts[0] );
			if ( parts.length === 1 ) {
				pri = 1;
			}
			else {
				name = trim( parts[1] );
				if ( name.indexOf("q=") === 0 ) {
					name = name.substr( 2 );
					pri = parseFloat( name );
					pri = isNaN( pri ) ? 0 : pri;
				}
				else {
					pri = 1;
				}
			}
			prioritized.push({ lang: lang, pri: pri });
		}
		prioritized.sort(function( a, b ) {
			if ( a.pri < b.pri ) {
				return 1;
			} else if ( a.pri > b.pri ) {
				return -1;
			}
			return 0;
		});
		// exact match
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			match = cultures[ lang ];
			if ( match ) {
				return match;
			}
		}

		// neutral language match
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			do {
				var index = lang.lastIndexOf( "-" );
				if ( index === -1 ) {
					break;
				}
				// strip off the last part. e.g. en-US => en
				lang = lang.substr( 0, index );
				match = cultures[ lang ];
				if ( match ) {
					return match;
				}
			}
			while ( 1 );
		}

		// last resort: match first culture using that language
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			for ( var cultureKey in cultures ) {
				var culture = cultures[ cultureKey ];
				if ( culture.language == lang ) {
					return culture;
				}
			}
		}
	}
	else if ( typeof name === "object" ) {
		return name;
	}
	return match || null;
};

Globalize.format = function( value, format, cultureSelector ) {
	var culture = this.findClosestCulture( cultureSelector );
	if ( value instanceof Date ) {
		value = formatDate( value, format, culture );
	}
	else if ( typeof value === "number" ) {
		value = formatNumber( value, format, culture );
	}
	return value;
};

Globalize.localize = function( key, cultureSelector ) {
	return this.findClosestCulture( cultureSelector ).messages[ key ] ||
		this.cultures[ "default" ].messages[ key ];
};

Globalize.parseDate = function( value, formats, culture ) {
	culture = this.findClosestCulture( culture );

	var date, prop, patterns;
	if ( formats ) {
		if ( typeof formats === "string" ) {
			formats = [ formats ];
		}
		if ( formats.length ) {
			for ( var i = 0, l = formats.length; i < l; i++ ) {
				var format = formats[ i ];
				if ( format ) {
					date = parseExact( value, format, culture );
					if ( date ) {
						break;
					}
				}
			}
		}
	} else {
		patterns = culture.calendar.patterns;
		for ( prop in patterns ) {
			date = parseExact( value, patterns[prop], culture );
			if ( date ) {
				break;
			}
		}
	}

	return date || null;
};

Globalize.parseInt = function( value, radix, cultureSelector ) {
	return truncate( Globalize.parseFloat(value, radix, cultureSelector) );
};

Globalize.parseFloat = function( value, radix, cultureSelector ) {
	// radix argument is optional
	if ( typeof radix !== "number" ) {
		cultureSelector = radix;
		radix = 10;
	}

	var culture = this.findClosestCulture( cultureSelector );
	var ret = NaN,
		nf = culture.numberFormat;

	if ( value.indexOf(culture.numberFormat.currency.symbol) > -1 ) {
		// remove currency symbol
		value = value.replace( culture.numberFormat.currency.symbol, "" );
		// replace decimal seperator
		value = value.replace( culture.numberFormat.currency["."], culture.numberFormat["."] );
	}

	//Remove percentage character from number string before parsing
	if ( value.indexOf(culture.numberFormat.percent.symbol) > -1){
		value = value.replace( culture.numberFormat.percent.symbol, "" );
	}

	// remove spaces: leading, trailing and between - and number. Used for negative currency pt-BR
	value = value.replace( / /g, "" );

	// allow infinity or hexidecimal
	if ( regexInfinity.test(value) ) {
		ret = parseFloat( value );
	}
	else if ( !radix && regexHex.test(value) ) {
		ret = parseInt( value, 16 );
	}
	else {

		// determine sign and number
		var signInfo = parseNegativePattern( value, nf, nf.pattern[0] ),
			sign = signInfo[ 0 ],
			num = signInfo[ 1 ];

		// #44 - try parsing as "(n)"
		if ( sign === "" && nf.pattern[0] !== "(n)" ) {
			signInfo = parseNegativePattern( value, nf, "(n)" );
			sign = signInfo[ 0 ];
			num = signInfo[ 1 ];
		}

		// try parsing as "-n"
		if ( sign === "" && nf.pattern[0] !== "-n" ) {
			signInfo = parseNegativePattern( value, nf, "-n" );
			sign = signInfo[ 0 ];
			num = signInfo[ 1 ];
		}

		sign = sign || "+";

		// determine exponent and number
		var exponent,
			intAndFraction,
			exponentPos = num.indexOf( "e" );
		if ( exponentPos < 0 ) exponentPos = num.indexOf( "E" );
		if ( exponentPos < 0 ) {
			intAndFraction = num;
			exponent = null;
		}
		else {
			intAndFraction = num.substr( 0, exponentPos );
			exponent = num.substr( exponentPos + 1 );
		}
		// determine decimal position
		var integer,
			fraction,
			decSep = nf[ "." ],
			decimalPos = intAndFraction.indexOf( decSep );
		if ( decimalPos < 0 ) {
			integer = intAndFraction;
			fraction = null;
		}
		else {
			integer = intAndFraction.substr( 0, decimalPos );
			fraction = intAndFraction.substr( decimalPos + decSep.length );
		}
		// handle groups (e.g. 1,000,000)
		var groupSep = nf[ "," ];
		integer = integer.split( groupSep ).join( "" );
		var altGroupSep = groupSep.replace( /\u00A0/g, " " );
		if ( groupSep !== altGroupSep ) {
			integer = integer.split( altGroupSep ).join( "" );
		}
		// build a natively parsable number string
		var p = sign + integer;
		if ( fraction !== null ) {
			p += "." + fraction;
		}
		if ( exponent !== null ) {
			// exponent itself may have a number patternd
			var expSignInfo = parseNegativePattern( exponent, nf, "-n" );
			p += "e" + ( expSignInfo[0] || "+" ) + expSignInfo[ 1 ];
		}
		if ( regexParseFloat.test(p) ) {
			ret = parseFloat( p );
		}
	}
	return ret;
};

Globalize.culture = function( cultureSelector ) {
	// setter
	if ( typeof cultureSelector !== "undefined" ) {
		this.cultureSelector = cultureSelector;
	}
	// getter
	return this.findClosestCulture( cultureSelector ) || this.cultures[ "default" ];
};

document.Globalize = Globalize;
}(this));
})();

/***/ }),

/***/ 7196:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {

    $.jqx.jqxWidget("jqxButtonGroup", "", {});

    $.extend($.jqx._jqxButtonGroup.prototype, {
        defineInstance: function () {
            var settings =
            {
                //Possible values: checkbox, radio, default
                mode: 'default',
                roundedCorners: true,
                disabled: false,
                enableHover: false,
                orientation: 'horizontal',
                width: null,
                height: null,
                _eventsMap: {
                    'mousedown': $.jqx.mobile.getTouchEventName('touchstart'),
                    'mouseup': $.jqx.mobile.getTouchEventName('touchend')
                },
                _events: ['selected', 'unselected', 'buttonclick'],
                _buttonId: {},
                _selected: null,
                _pressed: null,
                rtl: false,
                template: "",
                _baseId: 'group_button',
                aria:
                {
                    "aria-disabled": { name: "disabled", type: "boolean" }
                }
            };
            if (this === $.jqx._jqxButtonGroup.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        createInstance: function (args) {
            var that = this;
            that._isTouchDevice = $.jqx.mobile.isTouchDevice();
            $.jqx.aria(that);
            that._baseId = that._baseId + that.element.id;
            that.addHandler(that.host, 'selectstart', function (event) {
                if (!that.disabled) {
                    event.preventDefault();
                }
            });
        },

        refresh: function () {
            var that = this;
            if (that.width) {
                if (that.width.toString() && that.width.toString().indexOf('%') >= 0) {
                    that.element.style.width = that.width;
                }
                else {
                    that.host.width(that.width);
                }
            }
            if (that.height) that.host.height(that.height);
            that._refreshButtons();
        },

        render: function () {
            this.refresh();
        },

        resize: function () {
            this.refresh();
        },

        _getEvent: function (event) {
            var that = this;
            if (that._isTouchDevice) {
                var e = that._eventsMap[event] || event;
                e += "." + that.element.id;
                return e;
            }
            event += "." + that.element.id;
            return event;
        },

        _refreshButtons: function () {
            var that = this;
            if (that.lastElement)
                that.lastElement.remove();

            that.lastElement = $("<div style='clear: both;'></div>");
            var children = that.host.children(),
                count = children.length,
                current;

            switch (that.mode) {
                case "radio":
                    that.host.attr('role', 'radiogroup');
                    break;
                case "checkbox":
                case "default":
                    that.host.attr('role', 'group');
                    break;
            }

            var width = new Number(100 / count).toFixed(2);
            for (var i = 0; i < count; i += 1) {
                current = $(children[i]);
                if (that.width) {
                    if (that.orientation === "horizontal") {
                        current.css('width', width + '%');
                        current.css('box-sizing', 'border-box');
                        current.css('-moz-box-sizing', 'border-box');
                        current.css('white-space', 'nowrap');
                        current.css('text-overflow', 'ellipsis');
                        current.css('overflow', 'hidden');
                    }
                    else {
                        current.css('box-sizing', 'border-box');
                        current.css('-moz-box-sizing', 'border-box');
                        current.css('width', '100%');
                    }
                }

                that._refreshButton(current, i, count);
            }
            that.lastElement.appendTo(that.host);
        },

        _refreshButton: function (btn, counter, count) {
            (function (btn) {
                var that = this;
                btn = that._render(btn);
                that._removeStyles(btn);
                that._addStyles(btn, counter, count);
                that._performLayout(btn);
                that._removeButtonListeners(btn);
                that._addButtonListeners(btn);
                that._handleButtonId(btn, counter);

                if (that.mode === "radio") {
                    btn.attr('role', 'radio');
                }
                else {
                    btn.attr('role', 'button');
                }
                btn.attr('disabled', that.disabled);
                if (that.disabled) {
                    btn.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
                }
                else {
                    btn.removeClass(that.toThemeProperty('jqx-fill-state-disabled'));
                }
            }).apply(this, [btn]);
        },

        destroy: function (removeFromDom) {
            var that = this;
            var children = that.host.children(),
            count = children.length,
            current;

            for (var i = 0; i < count; i += 1) {
                current = $(children[i]);
                that._removeStyles(current);
                that._removeButtonListeners(current);
            }

            if (removeFromDom !== false) {
                that.host.remove();
            }
        },

        _render: function (btn) {
            var that = this;
            if (btn[0].tagName.toLowerCase() === 'button') {
                return that._renderFromButton(btn);
            } else {
                return that._renderButton(btn);
            }
        },

        _renderButton: function (btn) {
            var content;
            btn.wrapInner('<div/>');
            return btn;
        },

        _removeStyles: function (btn) {
            var that = this;
            var tp = that.toThemeProperty;
            that.host.removeClass('jqx-widget');
            that.host.removeClass('jqx-rc-all');
            btn.removeClass(tp.call(this, 'jqx-fill-state-normal'));
            btn.removeClass(tp.call(this, 'jqx-group-button-normal'));
            btn.removeClass(tp.call(this, 'jqx-rc-tl'));
            btn.removeClass(tp.call(this, 'jqx-rc-bl'));
            btn.removeClass(tp.call(this, 'jqx-rc-tr'));
            btn.removeClass(tp.call(this, 'jqx-rc-br'));
            btn.css('margin-left', 0);
        },

        _addStyles: function (btn, counter, count) {
            var that = this;
            var tp = this.toThemeProperty;
            that.host.addClass(tp.call(this, 'jqx-widget'));
            that.host.addClass(tp.call(this, 'jqx-rc-all'));
            that.host.addClass(tp.call(this, 'jqx-buttongroup'));
            btn.addClass(tp.call(this, 'jqx-button'));
            btn.addClass(tp.call(this, 'jqx-group-button-normal'));
            btn.addClass(tp.call(this, 'jqx-fill-state-normal'));
            if (that.template) {
                btn.addClass(tp.call(this, 'jqx-' + that.template));
            }
            if (that.roundedCorners) {
                if (counter === 0) {
                    that._addRoundedCorners(btn, true);
                } else if (counter === count - 1) {
                    that._addRoundedCorners(btn, false);
                }
            }
            if (that.orientation === 'horizontal') {
                btn.css('margin-left', -parseInt(btn.css('border-left-width'), 10));
            }
            else {
                btn.css('margin-top', -parseInt(btn.css('border-left-width'), 10));
            }
        },

        _addRoundedCorners: function (button, left) {
            var that = this;
            var tp = that.toThemeProperty;
            if (that.orientation === 'horizontal') {
                if (left) {
                    button.addClass(tp.call(this, 'jqx-rc-tl'));
                    button.addClass(tp.call(this, 'jqx-rc-bl'));
                } else {
                    button.addClass(tp.call(this, 'jqx-rc-tr'));
                    button.addClass(tp.call(this, 'jqx-rc-br'));
                }
            }
            else {
                if (left) {
                    button.addClass(tp.call(this, 'jqx-rc-tl'));
                    button.addClass(tp.call(this, 'jqx-rc-tr'));
                } else {
                    button.addClass(tp.call(this, 'jqx-rc-bl'));
                    button.addClass(tp.call(this, 'jqx-rc-br'));
                }
            }
        },

        _centerContent: function (content, parent) {
            content.css({
                'margin-top': (parent.height() - content.height()) / 2,
                'margin-left': (parent.width() - content.width()) / 2
            });
            return content;
        },

        _renderFromButton: function (btn) {
            var content = btn.val();
            if (content === "") {
                content = btn.html();
            }

            var div;
            var id = btn[0].id;
            btn.wrap('<div/>');
            div = btn.parent();
            div.attr('style', btn.attr('style'));
            btn.remove();
            $.jqx.utilities.html(div, content);
            div[0].id = id;
            return div;
        },

        _performLayout: function (btn) {
            if (this.orientation === 'horizontal') {
                if (this.rtl) {
                    btn.css('float', 'right');
                }
                else {
                    btn.css('float', 'left');
                }
            }
            else {
                btn.css('float', 'none');
            }

            this._centerContent($(btn.children()), btn);
        },

        _mouseEnterHandler: function (e) {
            var self = e.data.self,
                btn = $(e.currentTarget);
            if (self._isDisabled(btn) || !self.enableHover) {
                return;
            }
            var tp = self.toThemeProperty;
            btn.addClass(tp.call(self, 'jqx-group-button-hover'));
            btn.addClass(tp.call(self, 'jqx-fill-state-hover'));
        },

        _mouseLeaveHandler: function (e) {
            var self = e.data.self,
                btn = $(e.currentTarget);
            if (self._isDisabled(btn) || !self.enableHover) {
                return;
            }
            var tp = self.toThemeProperty;
            btn.removeClass(tp.call(self, 'jqx-group-button-hover'));
            btn.removeClass(tp.call(self, 'jqx-fill-state-hover'));
        },

        _mouseDownHandler: function (e) {
            var self = e.data.self,
                btn = $(e.currentTarget);
            if (self._isDisabled(btn)) {
                return;
            }
            self._pressed = btn;
            var tp = self.toThemeProperty;
            btn.addClass(tp.call(self, 'jqx-group-button-pressed'));
            btn.addClass(tp.call(self, 'jqx-fill-state-pressed'));
        },

        _mouseUpHandler: function (e) {
            var self = e.data.self,
                btn = $(e.currentTarget);
            if (self._isDisabled(btn)) {
                return;
            }
            self._handleSelection(btn);
            self._pressed = null;
            btn = self._buttonId[btn[0].id];
            self._raiseEvent(2, { index: btn.num, button: btn.btn });
        },

        _isDisabled: function (btn) {
            if (!btn || !btn[0]) {
                return false;
            }
            return this._buttonId[btn[0].id].disabled;
        },

        _documentUpHandler: function (e) {
            var self = e.data.self,
                pressedButton = self._pressed;
            if (pressedButton && !self._buttonId[pressedButton[0].id].selected) {
                pressedButton.removeClass(self.toThemeProperty('jqx-fill-state-pressed'));
                self._pressed = null;
            }
        },

        _addButtonListeners: function (btn) {
            var that = this;
            var ah = that.addHandler;
            var ge = that._getEvent;

            ah(btn, ge.call(that, 'mouseenter'), that._mouseEnterHandler, { self: that });
            ah(btn, ge.call(that, 'mouseleave'), that._mouseLeaveHandler, { self: that });
            ah(btn, ge.call(that, 'mousedown'), that._mouseDownHandler, { self: that });
            ah(btn, ge.call(that, 'mouseup'), that._mouseUpHandler, { self: that });
            ah($(document), ge.call(that, 'mouseup'), that._documentUpHandler, { self: that });
        },

        _removeButtonListeners: function (btn) {
            var that = this;
            var rh = that.removeHandler;
            var ge = that._getEvent;
            rh(btn, ge.call(that, 'mouseenter'), that._mouseEnterHandler);
            rh(btn, ge.call(that, 'mouseleave'), that._mouseLeaveHandler);
            rh(btn, ge.call(that, 'mousedown'), that._mouseDownHandler);
            rh(btn, ge.call(that, 'mouseup'), that._mouseUpHandler);
            rh($(document), ge.call(that, 'mouseup'), that._documentUpHandler);
        },

        _handleSelection: function (btn) {
            var that = this;
            if (that.mode === 'radio') {
                that._handleRadio(btn);
            } else if (that.mode === 'checkbox') {
                that._handleCheckbox(btn);
            } else {
                that._handleDefault(btn);
            }
        },

        _handleRadio: function (btn) {
            var that = this;
            var selected = that._getSelectedButton();
            if (selected && selected.btn[0].id !== btn[0].id) {
                that._unselectButton(selected.btn, true);
            }
            for (var data in that._buttonId) {
                that._buttonId[data].selected = true;
                that._unselectButton(that._buttonId[data].btn, false);
            }

            that._selectButton(btn, true);
        },

        _handleCheckbox: function (btn) {
            var that = this;
            var btnInfo = that._buttonId[btn[0].id];
            if (btnInfo.selected) {
                that._unselectButton(btnInfo.btn, true);
            } else {
                that._selectButton(btn, true);
            }
        },

        _handleDefault: function (btn) {
            var that = this;
            that._selectButton(btn, false);
            for (var data in that._buttonId) {
                that._buttonId[data].selected = true;
                that._unselectButton(that._buttonId[data].btn, false);
            }
        },

        _getSelectedButton: function () {
            var that = this;
            for (var data in that._buttonId) {
                if (that._buttonId[data].selected) {
                    return that._buttonId[data];
                }
            }
            return null;
        },

        _getSelectedButtons: function () {
            var that = this;
            var selected = [];
            for (var data in that._buttonId) {
                if (that._buttonId[data].selected) {
                    selected.push(that._buttonId[data].num);
                }
            }
            return selected;
        },

        _getButtonByIndex: function (index) {
            var that = this;
            var current;
            for (var data in that._buttonId) {
                if (that._buttonId[data].num === index) {
                    return that._buttonId[data];
                }
            }
            return null;
        },

        _selectButton: function (btn, raiseEvent) {
            var that = this;
            var btnInfo = that._buttonId[btn[0].id];
            if (btnInfo.selected) {
                return;
            }
            var tp = that.toThemeProperty;
            btnInfo.btn.addClass(tp.call(this, 'jqx-group-button-pressed'));
            btnInfo.btn.addClass(tp.call(this, 'jqx-fill-state-pressed'));
            btnInfo.selected = true;
            if (raiseEvent) {
                that._raiseEvent(0, { index: btnInfo.num, button: btnInfo.btn });
            }
            $.jqx.aria(btnInfo.btn, 'aria-checked', true);
        },

        _unselectButton: function (btn, raiseEvent) {
            var that = this;
            var btnInfo = that._buttonId[btn[0].id];
            if (!btnInfo.selected) {
                return;
            }
            var tp = that.toThemeProperty;
            btnInfo.btn.removeClass(tp.call(this, 'jqx-group-button-pressed'));
            btnInfo.btn.removeClass(tp.call(this, 'jqx-fill-state-pressed'));
            btnInfo.selected = false;
            if (raiseEvent) {
                that._raiseEvent(1, { index: btnInfo.num, button: btnInfo.btn });
            }
            $.jqx.aria(btnInfo.btn, 'aria-checked', false);
        },

        setSelection: function (index) {
            var that = this;
            if (index === -1) {
                that.clearSelection();
                return;
            }

            if (that.mode === 'checkbox') {
                if (typeof index === 'number') {
                    that._setSelection(index);
                } else {
                    for (var i = 0; i < index.length; i += 1) {
                        that._setSelection(index[i]);
                    }
                }
            } else if (typeof index === 'number' && that.mode === 'radio') {
                that._setSelection(index);
            }
        },

        _setSelection: function (index) {
            var that = this;
            var btn = that._getButtonByIndex(index);
            if (btn) {
                that._handleSelection(btn.btn);
            }
        },

        getSelection: function () {
            var that = this;
            if (that.mode === 'radio') {
                if (that._getSelectedButton()) {
                    return that._getSelectedButton().num;
                }
            } else if (that.mode === 'checkbox') {
                return that._getSelectedButtons();
            }
            return undefined;
        },

        disable: function () {
            var that = this;
            that.disabled = true;
            var current;
            for (var btn in that._buttonId) {
                current = that._buttonId[btn];
                that.disableAt(current.num);
            }
            $.jqx.aria(that, "aria-disabled", true);
        },

        enable: function () {
            var that = this;
            that.disabled = false;
            var current;
            for (var btn in that._buttonId) {
                current = that._buttonId[btn];
                that.enableAt(current.num);
            }
            $.jqx.aria(that, "aria-disabled", false);
        },

        disableAt: function (index) {
            var that = this;
            var btn = that._getButtonByIndex(index);
            if (!btn.disabled) {
                btn.disabled = true;
                btn.btn.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
            }
        },

        enableAt: function (index) {
            var that = this;
            var btn = that._getButtonByIndex(index);
            if (btn.disabled) {
                btn.disabled = false;
                btn.btn.removeClass(that.toThemeProperty('jqx-fill-state-disabled'));
            }
        },

        _handleButtonId: function (btn, number) {
            var id = btn[0].id,
                btnId = { btn: btn, num: number, selected: false },
                widgetId;
            if (!id) {
                id = this._baseId + btn.index();
            }
            btn[0].id = id;
            this._buttonId[id] = btnId;
            return id;
        },

        _raiseEvent: function (id, data) {
            var event = $.Event(this._events[id]);
            event.args = data;
            return this.host.trigger(event);
        },

        _unselectAll: function () {
            for (var data in this._buttonId) {
                this._unselectButton(this._buttonId[data].btn, false);
            }
        },

        clearSelection: function () {
            this._unselectAll();
        },

        propertyChangedHandler: function (object, key, oldvalue, value) {
            if (key === 'theme' && value !== null) {
                $.jqx.utilities.setTheme(oldvalue, value, object.host);
            }

            if (key === 'rtl') {
                object.refresh();
            }
            if (key === "template") {
                object.refresh();
            }
            if (key === 'mode') {
                object._unselectAll();
                object.refresh();
                return;
            } else if (key === 'disabled') {
                if (value) {
                    object.disable();
                } else {
                    object.enable();
                }
            } else {
                object.refresh();
            }
        }
    });
})(jqxBaseFramework);
})();



/***/ }),

/***/ 7351:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {
        $.jqx.cssroundedcorners = function (value) {
            var cssMap = {
                'all': 'jqx-rc-all',
                'top': 'jqx-rc-t',
                'bottom': 'jqx-rc-b',
                'left': 'jqx-rc-l',
                'right': 'jqx-rc-r',
                'top-right': 'jqx-rc-tr',
                'top-left': 'jqx-rc-tl',
                'bottom-right': 'jqx-rc-br',
                'bottom-left': 'jqx-rc-bl'
            };

            for (var prop in cssMap) {
                if (!cssMap.hasOwnProperty(prop))
                    continue;

                if (value == prop)
                    return cssMap[prop];
            }
        }

        $.jqx.jqxWidget("jqxButton", "", {});

        $.extend($.jqx._jqxButton.prototype, {
            defineInstance: function () {
                var settings = {
                    type: '',
                    cursor: 'arrow',
                    // rounds the button corners.
                    roundedCorners: 'all',
                    // enables / disables the button
                    disabled: false,
                    // sets height to the button.
                    height: null,
                    // sets width to the button.
                    width: null,
                    overrideTheme: false,
                    enableHover: true,
                    enableDefault: true,
                    enablePressed: true,
                    imgPosition: "center",
                    imgSrc: "",
                    imgWidth: 16,
                    imgHeight: 16,
                    value: null,
                    textPosition: "",
                    textImageRelation: "overlay",
                    rtl: false,
                    _ariaDisabled: false,
                    _scrollAreaButton: false,
                    // "primary", "inverse", "danger", "info", "success", "warning", "link"
                    template: "default",
                    aria:
                    {
                        "aria-disabled": { name: "disabled", type: "boolean" }
                    }
                }
                if (this === $.jqx._jqxButton.prototype) {
                    return settings;
                }
                $.extend(true, this, settings);
                return settings;
            },

            _addImage: function (name) {
                var that = this;
                if (that.element.nodeName.toLowerCase() == "input" || that.element.nodeName.toLowerCase() == "button" || that.element.nodeName.toLowerCase() == "div") {
                    if (!that._img) {
                        that.field = that.element;
                        if (that.field.className) {
                            that._className = that.field.className;
                        }

                        var properties = {
                            'title': that.field.title
                        };

                        var value = null;
                        if (that.field.getAttribute('value')) {
                            var value = that.field.getAttribute('value');
                        }
                        else if (that.element.nodeName.toLowerCase() != "input") {
                            var value = that.element.innerHTML;
                        }
                        if (that.value) {
                            value = that.value;
                        }
                        if (that.field.id.length) {
                            properties.id = that.field.id.replace(/[^\w]/g, '_') + "_" + name;
                        }
                        else {
                            properties.id = $.jqx.utilities.createId() + "_" + name;
                        }


                        var wrapper = document.createElement('div');
                        wrapper.id = properties.id;
                        wrapper.title = properties.title;
                        wrapper.style.cssText = that.field.style.cssText;
                        wrapper.style.boxSizing = 'border-box';

                        var img = document.createElement("img");
                        img.setAttribute('src', that.imgSrc);
                        img.setAttribute('width', that.imgWidth);
                        img.setAttribute('height', that.imgHeight);
                        wrapper.appendChild(img);
                        that._img = img;

                        var text = document.createElement('span');
                        if (value) {
                            text.innerHTML = value;
                            that.value = value;
                        }
                        wrapper.appendChild(text);
                        that._text = text;

                        that.field.style.display = "none";
                        if (that.field.parentNode) {
                            that.field.parentNode.insertBefore(wrapper, that.field.nextSibling);
                        }

                        var data = that.host.data();
                        that.host = $(wrapper);
                        that.host.data(data);
                        that.element = wrapper;
                        that.element.id = that.field.id;
                        that.field.id = properties.id;
                        var elementObj = new $(that.element);
                        var fieldObj = new $(that.field);
                        if (that._className) {
                            elementObj.addClass(that._className);
                            fieldObj.removeClass(that._className);
                        }

                        if (that.field.tabIndex) {
                            var tabIndex = that.field.tabIndex;
                            that.field.tabIndex = -1;
                            that.element.tabIndex = tabIndex;
                        }
                    }
                    else {
                        that._img.setAttribute('src', that.imgSrc);
                        that._img.setAttribute('width', that.imgWidth);
                        that._img.setAttribute('height', that.imgHeight);
                        that._text.innerHTML = that.value;
                    }
                    if (!that.imgSrc) {
                        that._img.style.display = "none";
                    }
                    else {
                        that._img.style.display = "inline";
                    }

                    if (!that.value) {
                        that._text.style.display = "none";
                    }
                    else {
                        that._text.style.display = "inline";
                    }

                    that._positionTextAndImage();
                }
            },

            _positionTextAndImage: function () {
                var that = this;
                var width = that.element.offsetWidth;
                var height = that.element.offsetHeight;

                var imgWidth = that.imgWidth;
                var imgHeight = that.imgHeight;
                if (that.imgSrc == "") {
                    imgWidth = 0;
                    imgHeight = 0;
                }

                var textWidth = that._text.offsetWidth;
                var textHeight = that._text.offsetHeight;
                var offset = 4;
                var edgeOffset = 4;
                var factorIncrease = 4;
                var w = 0;
                var h = 0;
                switch (that.textImageRelation) {
                    case "imageBeforeText":
                    case "textBeforeImage":
                        w = imgWidth + textWidth + 2 * factorIncrease + offset + 2 * edgeOffset;
                        h = Math.max(imgHeight, textHeight) + 2 * factorIncrease + offset + 2 * edgeOffset;
                        break;
                    case "imageAboveText":
                    case "textAboveImage":
                        w = Math.max(imgWidth, textWidth) + 2 * factorIncrease;
                        h = imgHeight + textHeight + offset + 2 * factorIncrease + 2 * edgeOffset;
                        break;
                    case "overlay":
                        w = Math.max(imgWidth, textWidth) + 2 * factorIncrease;
                        h = Math.max(imgHeight, textHeight) + 2 * factorIncrease;
                        break;
                }

                if (!that.width) {
                    that.element.style.width = w + "px";
                    width = w;
                }

                if (!that.height) {
                    that.element.style.height = h + "px";
                    height = h;
                }

                that._img.style.position = 'absolute';
                that._text.style.position = 'absolute';
                that.element.style.position = 'relative';
                that.element.style.overflow = 'hidden';

                var textRect = {};
                var imageRect = {};

                var drawElement = function (element, drawArea, pos, w, h) {
                    if (drawArea.width < w) drawArea.width = w;
                    if (drawArea.height < h) drawArea.height = h;

                    switch (pos) {
                        case "left":
                            element.style.left = drawArea.left + "px";
                            element.style.top = drawArea.top + drawArea.height / 2 - h / 2 + "px";;
                            break;
                        case "topLeft":
                            element.style.left = drawArea.left + "px";
                            element.style.top = drawArea.top + "px";
                            break;
                        case "bottomLeft":
                            element.style.left = drawArea.left + "px";
                            element.style.top = drawArea.top + drawArea.height - h + "px";
                            break;
                        default:
                        case "center":
                            element.style.left = drawArea.left + drawArea.width / 2 - w / 2 + "px";
                            element.style.top = drawArea.top + drawArea.height / 2 - h / 2 + "px";
                            break;
                        case "top":
                            element.style.left = drawArea.left + drawArea.width / 2 - w / 2 + "px";
                            element.style.top = drawArea.top + "px";
                            break;
                        case "bottom":
                            element.style.left = drawArea.left + drawArea.width / 2 - w / 2 + "px";
                            element.style.top = drawArea.top + drawArea.height - h + "px";
                            break;
                        case "right":
                            element.style.left = drawArea.left + drawArea.width - w + "px";
                            element.style.top = drawArea.top + drawArea.height / 2 - h / 2 + "px";;
                            break;
                        case "topRight":
                            element.style.left = drawArea.left + drawArea.width - w + "px";
                            element.style.top = drawArea.top + "px";
                            break;
                        case "bottomRight":
                            element.style.left = drawArea.left + drawArea.width - w + "px";
                            element.style.top = drawArea.top + drawArea.height - h + "px";
                            break;
                    }
                }

                var left = 0;
                var top = 0;
                var right = width;
                var bottom = height;
                var middle = (right - left) / 2;
                var center = (bottom - top) / 2;
                var img = that._img;
                var text = that._text;
                var rectHeight = bottom - top;
                var rectWidth = right - left;
                left += edgeOffset;
                top += edgeOffset;
                right = right - edgeOffset - 2;
                rectWidth = rectWidth - 2 * edgeOffset - 2;
                rectHeight = rectHeight - 2 * edgeOffset - 2;

                switch (that.textImageRelation) {
                    case "imageBeforeText":

                        switch (that.imgPosition) {
                            case "left":
                            case "topLeft":
                            case "bottomLeft":
                                imageRect = { left: left, top: top, width: left + imgWidth, height: rectHeight };
                                textRect = { left: left + imgWidth + offset, top: top, width: rectWidth - imgWidth - offset, height: rectHeight };
                                break;
                            case "center":
                            case "top":
                            case "bottom":
                                imageRect = { left: middle - textWidth / 2 - imgWidth / 2 - offset / 2, top: top, width: imgWidth, height: rectHeight };
                                textRect = { left: imageRect.left + imgWidth + offset, top: top, width: right - imageRect.left - imgWidth - offset, height: rectHeight };
                                break;
                            case "right":
                            case "topRight":
                            case "bottomRight":
                                imageRect = { left: right - textWidth - imgWidth - offset, top: top, width: imgWidth, height: rectHeight };
                                textRect = { left: imageRect.left + imgWidth + offset, top: top, width: right - imageRect.left - imgWidth - offset, height: rectHeight };
                                break;

                        }
                        drawElement(img, imageRect, that.imgPosition, imgWidth, imgHeight);
                        drawElement(text, textRect, that.textPosition, textWidth, textHeight);

                        break;
                    case "textBeforeImage":

                        switch (that.textPosition) {
                            case "left":
                            case "topLeft":
                            case "bottomLeft":
                                textRect = { left: left, top: top, width: left + textWidth, height: rectHeight };
                                imageRect = { left: left + textWidth + offset, top: top, width: rectWidth - textWidth - offset, height: rectHeight };
                                break;
                            case "center":
                            case "top":
                            case "bottom":
                                textRect = { left: middle - textWidth / 2 - imgWidth / 2 - offset / 2, top: top, width: textWidth, height: rectHeight };
                                imageRect = { left: textRect.left + textWidth + offset, top: top, width: right - textRect.left - textWidth - offset, height: rectHeight };
                                break;
                            case "right":
                            case "topRight":
                            case "bottomRight":
                                textRect = { left: right - textWidth - imgWidth - offset, top: top, width: textWidth, height: rectHeight };
                                imageRect = { left: textRect.left + textWidth + offset, top: top, width: right - textRect.left - textWidth - offset, height: rectHeight };
                                break;

                        }
                        drawElement(img, imageRect, that.imgPosition, imgWidth, imgHeight);
                        drawElement(text, textRect, that.textPosition, textWidth, textHeight);

                        break;
                    case "imageAboveText":

                        switch (that.imgPosition) {
                            case "topRight":
                            case "top":
                            case "topLeft":
                                imageRect = { left: left, top: top, width: rectWidth, height: imgHeight };
                                textRect = { left: left, top: top + imgHeight + offset, width: rectWidth, height: rectHeight - imgHeight - offset };
                                break;
                            case "left":
                            case "center":
                            case "right":
                                imageRect = { left: left, top: center - imgHeight / 2 - textHeight / 2 - offset / 2, width: rectWidth, height: imgHeight };
                                textRect = { left: left, top: imageRect.top + offset + imgHeight, width: rectWidth, height: rectHeight - imageRect.top - offset - imgHeight };
                                break;
                            case "bottomLeft":
                            case "bottom":
                            case "bottomRight":
                                imageRect = { left: left, top: bottom - imgHeight - textHeight - offset, width: rectWidth, height: imgHeight };
                                textRect = { left: left, top: imageRect.top + offset + imgHeight, width: rectWidth, height: textHeight };
                                break;

                        }
                        drawElement(img, imageRect, that.imgPosition, imgWidth, imgHeight);
                        drawElement(text, textRect, that.textPosition, textWidth, textHeight);
                        break;
                    case "textAboveImage":
                        switch (that.textPosition) {
                            case "topRight":
                            case "top":
                            case "topLeft":
                                textRect = { left: left, top: top, width: rectWidth, height: textHeight };
                                imageRect = { left: left, top: top + textHeight + offset, width: rectWidth, height: rectHeight - textHeight - offset };
                                break;
                            case "left":
                            case "center":
                            case "right":
                                textRect = { left: left, top: center - imgHeight / 2 - textHeight / 2 - offset / 2, width: rectWidth, height: textHeight };
                                imageRect = { left: left, top: textRect.top + offset + textHeight, width: rectWidth, height: rectHeight - textRect.top - offset - textHeight };
                                break;
                            case "bottomLeft":
                            case "bottom":
                            case "bottomRight":
                                textRect = { left: left, top: bottom - imgHeight - textHeight - offset, width: rectWidth, height: textHeight };
                                imageRect = { left: left, top: textRect.top + offset + textHeight, width: rectWidth, height: imgHeight };
                                break;

                        }
                        drawElement(img, imageRect, that.imgPosition, imgWidth, imgHeight);
                        drawElement(text, textRect, that.textPosition, textWidth, textHeight);

                        break;
                    case "overlay":
                    default:
                        textRect = { left: left, top: top, width: rectWidth, height: rectHeight };
                        imageRect = { left: left, top: top, width: rectWidth, height: rectHeight };

                        drawElement(img, imageRect, that.imgPosition, imgWidth, imgHeight);
                        drawElement(text, textRect, that.textPosition, textWidth, textHeight);

                        break;
                }
            },

            createInstance: function (args) {
                var that = this;
                that._setSize();

                var isMaterial = that.isMaterialized();

                that.buttonObj = new $(that.element);

                if (that.imgSrc != "" || that.textPosition != "" || (that.element.value && that.element.value.indexOf("<") >= 0) || that.value != null) {
                    that.refresh();
                    that._addImage("jqxButton");
                    that.buttonObj = new $(that.element);
                }

                if (!that._ariaDisabled) {
                    that.element.setAttribute('role', 'button');
                }
                if (that.type !== '') {
                    that.element.setAttribute('type', that.type);
                }
                if (!that.overrideTheme) {
                    that.buttonObj.addClass(that.toThemeProperty($.jqx.cssroundedcorners(that.roundedCorners)));
                    if (that.enableDefault) {
                        that.buttonObj.addClass(that.toThemeProperty('jqx-button'));
                    }
                    that.buttonObj.addClass(that.toThemeProperty('jqx-widget'));
                }

                that.isTouchDevice = $.jqx.mobile.isTouchDevice();
                if (!that._ariaDisabled) {
                    $.jqx.aria(this);
                }

                if (that.cursor != 'arrow') {
                    if (!that.disabled) {
                        that.element.style.cursor = that.cursor;
                    }
                    else {
                        that.element.style.cursor = "arrow";
                    }
                }

                var eventNames = 'mouseenter mouseleave mousedown focus blur';
                if (that._scrollAreaButton) {
                    var eventNames = 'mousedown';
                }

                if (that.isTouchDevice) {
                    that.addHandler(that.host, $.jqx.mobile.getTouchEventName('touchstart'), function (event) {
                        that.isPressed = true;
                        that.refresh();
                    });
                    that.addHandler($(document), $.jqx.mobile.getTouchEventName('touchend') + "." + that.element.id, function (event) {
                        that.isPressed = false;
                        that.refresh();
                    });
                }

                that.addHandler(that.host, eventNames, function (event) {
                    switch (event.type) {
                        case 'mouseenter':
                            if (!that.isTouchDevice) {
                                if (!that.disabled && that.enableHover) {
                                    that.isMouseOver = true;
                                    that.refresh();
                                }
                            }
                            break;
                        case 'mouseleave':
                            if (!that.isTouchDevice) {
                                if (!that.disabled && that.enableHover) {
                                    that.isMouseOver = false;
                                    that.refresh();
                                }
                            }
                            break;
                        case 'mousedown':
                            if (!that.disabled) {
                                that.isPressed = true;
                                that.refresh();
                            }
                            break;
                        case 'focus':
                            if (!that.disabled) {
                                that.isFocused = true;
                                that.refresh();
                            }
                            break;
                        case 'blur':
                            if (!that.disabled) {
                                that.isFocused = false;
                                that.refresh();
                            }
                            break;
                    }
                });

                that.mouseupfunc = function (event) {
                    if (!that.disabled) {
                        if (that.isPressed || that.isMouseOver) {
                            that.isPressed = false;
                            that.refresh();
                        }
                    }
                }

                that.addHandler(document, 'mouseup.button' + that.element.id, that.mouseupfunc);

                try {
                    if (document.referrer != "" || window.frameElement) {
                        if (window.top != null && window.top != window.that) {
                            var parentLocation = '';
                            if (window.parent && document.referrer) {
                                parentLocation = document.referrer;
                            }

                            if (parentLocation.indexOf(document.location.host) != -1) {
                                if (window.top.document) {
                                    window.top.document.addEventListener('mouseup', that._topDocumentMouseupHandler);
                                }
                            }
                        }
                    }
                }
                catch (error) {
                }

                that.propertyChangeMap['roundedCorners'] = function (instance, key, oldVal, value) {
                    instance.buttonObj.removeClass(instance.toThemeProperty($.jqx.cssroundedcorners(oldVal)));
                    instance.buttonObj.addClass(instance.toThemeProperty($.jqx.cssroundedcorners(value)));
                };
                that.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    if (oldVal != value) {
                        instance.refresh();
                        instance.element.setAttribute('disabled', value);
                        instance.element.disabled = value;
                        if (!value) {
                            instance.element.style.cursor = instance.cursor;
                        }
                        else {
                            instance.element.style.cursor = 'default';
                        }

                        $.jqx.aria(instance, "aria-disabled", instance.disabled);
                    }
                };
                that.propertyChangeMap['rtl'] = function (instance, key, oldVal, value) {
                    if (oldVal != value) {
                        instance.refresh();
                    }
                };
                that.propertyChangeMap['template'] = function (instance, key, oldVal, value) {
                    if (oldVal != value) {
                        instance.buttonObj.removeClass(instance.toThemeProperty("jqx-" + oldVal));
                        instance.refresh();
                    }
                };
                that.propertyChangeMap['theme'] = function (instance, key, oldVal, value) {
                    instance.buttonObj.removeClass(instance.element);

                    if (oldVal) {
                        instance.buttonObj.removeClass('jqx-button-' + oldVal);
                        instance.buttonObj.removeClass('jqx-widget-' + oldVal);
                        instance.buttonObj.removeClass('jqx-fill-state-normal-' + oldVal);
                        instance.buttonObj.removeClass(instance.toThemeProperty($.jqx.cssroundedcorners(instance.roundedCorners)) + '-' + oldVal);
                    }

                    if (instance.enableDefault) {
                        instance.buttonObj.addClass(instance.toThemeProperty('jqx-button'));
                    }
                    instance.buttonObj.addClass(instance.toThemeProperty('jqx-widget'));
                    if (!instance.overrideTheme) {
                        instance.buttonObj.addClass(instance.toThemeProperty($.jqx.cssroundedcorners(instance.roundedCorners)));
                    }
                    instance._oldCSSCurrent = null;
                    instance.refresh();
                };

                if (that.disabled) {
                    that.element.disabled = true;
                    that.element.setAttribute('disabled', 'true');
                }

                if (that.textPosition) {
                    $.jqx.utilities.resize(this.host, function () {
                        that._positionTextAndImage();
                    });
                }
            }, // createInstance

            resize: function (width, height) {
                this.width = width;
                this.height = height;
                this._setSize();
            },

            val: function (value) {
                var that = this;
                var input = that.host.find('input');
                if (input.length > 0) {
                    if (arguments.length == 0 || typeof (value) == "object") {
                        return input.val();
                    }
                    input.val(value);
                    that.refresh();
                    return input.val();
                }

                if (arguments.length == 0 || typeof (value) == "object") {
                    if (that.element.nodeName.toLowerCase() == "button") {
                        return $(that.element).text();
                    }
                    return that.element.value;
                }

                if (arguments.length > 0 && that._text) {
                    that._text.innerHTML = arguments[0];
                    that.refresh();

                    return;
                }
                else if (arguments.length > 0 && that.element.nodeName === 'DIV') {
                    that.element.innerHTML = arguments[0];
                    that.refresh();
                }

                that.element.value = arguments[0];
                if (that.element.nodeName.toLowerCase() == "button") {
                    $(that.element).html(arguments[0]);
                }

                that.refresh();
            },

            _setSize: function () {
                var that = this;
                var height = that.height;
                var width = that.width;

                if (height) {
                    if (!isNaN(height)) {
                        height = height + "px";
                    }
                    that.element.style.height = height;
                }

                if (width) {
                    if (!isNaN(width)) {
                        width = width + "px";
                    }
                    that.element.style.width = width;
                }
            },

            _removeHandlers: function () {
                var that = this;
                that.removeHandler(that.host, 'selectstart');
                that.removeHandler(that.host, 'click');
                that.removeHandler(that.host, 'focus');
                that.removeHandler(that.host, 'blur');
                that.removeHandler(that.host, 'mouseenter');
                that.removeHandler(that.host, 'mouseleave');
                that.removeHandler(that.host, 'mousedown');
                that.removeHandler($(document), 'mouseup.button' + that.element.id, that.mouseupfunc);
                if (that.isTouchDevice) {
                    that.removeHandler(that.host, $.jqx.mobile.getTouchEventName('touchstart'));
                    that.removeHandler($(document), $.jqx.mobile.getTouchEventName('touchend') + "." + that.element.id);
                }
                that.mouseupfunc = null;
                delete that.mouseupfunc;
            },

            focus: function () {
                this.host.focus();
            },

            destroy: function () {
                var that = this;
                that._removeHandlers();
                var vars = $.data(that.element, "jqxButton");
                if (vars) {
                    delete vars.instance;
                }
                that.host.removeClass();
                that.host.removeData();
                that.host.remove();
                delete that.set;
                delete that.get;
                delete that.call;
                delete that.element;
                delete that.host;
            },

            render: function () {
                this.refresh();
            },

            propertiesChangedHandler: function (object, oldValues, newValues) {
                if (newValues && newValues.width && newValues.height && Object.keys(newValues).length == 2) {
                    object._setSize();
                    object.refresh();
                }
            },

            propertyChangedHandler: function (object, key, oldvalue, value) {
                if (this.isInitialized == undefined || this.isInitialized == false)
                    return;

                if (value == oldvalue) {
                    return;
                }

                if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                    return;
                }

                if (key === "type") {
                    object.element.setAttribute('type', value);
                }
                if (key == "textImageRelation" || key == "textPosition" || key == "imgPosition") {
                    if (object._img) {
                        object._positionTextAndImage();
                    }
                    else object._addImage("jqxButton");
                }
                if (key == "imgSrc" || key == "imgWidth" || key == "imgHeight") {
                    object._addImage("jqxButton");
                }

                if (key === "value") {
                    object.val(value);
                }

                if (key == "width" || key == "height") {
                    object._setSize();
                    object.refresh();
                }
            },

            refresh: function () {
                var that = this;
                if (that.overrideTheme)
                    return;

                var cssFocused = that.toThemeProperty('jqx-fill-state-focus');
                var cssDisabled = that.toThemeProperty('jqx-fill-state-disabled');
                var cssNormal = that.toThemeProperty('jqx-fill-state-normal');

                if (!that.enableDefault) {
                    cssNormal = "";
                }

                var cssHover = that.toThemeProperty('jqx-fill-state-hover');
                var cssPressed = that.toThemeProperty('jqx-fill-state-pressed');
                var cssPressedHover = that.toThemeProperty('jqx-fill-state-pressed');
                if (!that.enablePressed) {
                    cssPressed = "";
                }
                var cssCurrent = '';

                if (!that.host) {
                    return;
                }

                that.element.disabled = that.disabled;

                if (that.disabled) {
                    if (that._oldCSSCurrent) {
                        that.buttonObj.removeClass(that._oldCSSCurrent);
                    }
                    cssCurrent = cssNormal + " " + cssDisabled;
                    if (that.template !== "default" && that.template !== "") {
                        cssCurrent += " " + "jqx-" + that.template;
                        if (that.theme != "") {
                            cssCurrent += " " + "jqx-" + that.template + "-" + that.theme;
                        }
                    }
                    that.buttonObj.addClass(cssCurrent);
                    that._oldCSSCurrent = cssCurrent;
                    return;
                }
                else {
                    if (that.isMouseOver && !that.isTouchDevice) {
                        if (that.isPressed)
                            cssCurrent = cssPressedHover;
                        else
                            cssCurrent = cssHover;
                    }
                    else {
                        if (that.isPressed)
                            cssCurrent = cssPressed;
                        else
                            cssCurrent = cssNormal;
                    }
                }

                if (that.isFocused) {
                    cssCurrent += " " + cssFocused;
                }

                if (that.template !== "default" && that.template !== "") {
                    cssCurrent += " " + "jqx-" + that.template;
                    if (that.theme != "") {
                        cssCurrent += " " + "jqx-" + that.template + "-" + that.theme;
                    }
                }

                if (cssCurrent != that._oldCSSCurrent) {
                    if (that._oldCSSCurrent) {
                        that.buttonObj.removeClass(that._oldCSSCurrent);
                    }
                    that.buttonObj.addClass(cssCurrent);
                    that._oldCSSCurrent = cssCurrent;
                }
                if (that.rtl) {
                    that.buttonObj.addClass(that.toThemeProperty('jqx-rtl'));
                    that.element.style.direction = 'rtl';
                }


                if (that.isMaterialized()) {
                    that.host.addClass('buttonRipple');
                }
            }
        });

        //// LinkButton
        $.jqx.jqxWidget("jqxLinkButton", "", {});

        $.extend($.jqx._jqxLinkButton.prototype, {
            defineInstance: function () {
                // enables / disables the button
                this.disabled = false;
                // sets height to the button.
                this.height = null;
                // sets width to the button.
                this.width = null;
                this.rtl = false;
                this.href = null;
            },

            createInstance: function (args) {
                var that = this;
                this.host.onselectstart = function () { return false; };
                this.host.attr('role', 'button');

                var height = this.height || this.element.offsetHeight;
                var width = this.width || this.element.offsetWidth;
                this.href = this.element.getAttribute('href');
                this.target = this.element.getAttribute('target');
                this.content = this.host.text();
                this.element.innerHTML = "";
                var wrapElement = document.createElement('input');
                wrapElement.type = "button";
                wrapElement.className = "jqx-wrapper " + this.toThemeProperty('jqx-reset');

                this._setSize(wrapElement, width, height);

                wrapElement.value = this.content;
                var helper = new $(this.element);
                helper.addClass(this.toThemeProperty('jqx-link'));
                this.element.style.color = 'inherit';
                this.element.appendChild(wrapElement);
                this._setSize(wrapElement, width, height);

                var param = args == undefined ? {} : args[0] || {};
                $(wrapElement).jqxButton(param);
                this.wrapElement = wrapElement;
                if (this.disabled) {
                    this.element.disabled = true;
                }

                this.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    instance.element.disabled = value;
                    instance.wrapElement.jqxButton({ disabled: value });
                }

                this.addHandler($(wrapElement), 'click', function (event) {
                    if (!this.disabled) {
                        that.onclick(event);
                    }
                    return false;
                });
            },

            _setSize: function (element, width, height) {
                var that = this;

                if (height) {
                    if (!isNaN(height)) {
                        height = height + "px";
                    }
                    element.style.height = height;
                }

                if (width) {
                    if (!isNaN(width)) {
                        width = width + "px";
                    }
                    element.style.width = width;
                }
            },


            onclick: function (event) {
                if (this.target != null) {
                    window.open(this.href, this.target);
                }
                else {
                    window.location = this.href;
                }
            }
        });
        //// End of LinkButton

        //// RepeatButton
        $.jqx.jqxWidget("jqxRepeatButton", "jqxButton", {});

        $.extend($.jqx._jqxRepeatButton.prototype, {
            defineInstance: function () {
                this.delay = 50;
            },

            createInstance: function (args) {
                var that = this;

                var isTouchDevice = $.jqx.mobile.isTouchDevice();

                var up = !isTouchDevice ? 'mouseup.' + this.base.element.id : 'touchend.' + this.base.element.id;
                var down = !isTouchDevice ? 'mousedown.' + this.base.element.id : 'touchstart.' + this.base.element.id;

                this.addHandler($(document), up, function (event) {
                    if (that.timeout != null) {
                        clearTimeout(that.timeout);
                        that.timeout = null;
                        that.refresh();
                    }
                    if (that.timer != undefined) {
                        clearInterval(that.timer);
                        that.timer = null;
                        that.refresh();
                    }
                });

                this.addHandler(this.base.host, down, function (event) {
                    if (that.timer != null) {
                        clearInterval(that.timer);
                    }

                    that.timeout = setTimeout(function () {
                        clearInterval(that.timer);
                        that.timer = setInterval(function (event) { that.ontimer(event); }, that.delay);
                    }, 150);
                });

                this.mousemovefunc = function (event) {
                    if (!isTouchDevice) {
                        if (event.which == 0) {
                            if (that.timer != null) {
                                clearInterval(that.timer);
                                that.timer = null;
                            }
                        }
                    }
                }

                this.addHandler(this.base.host, 'mousemove', this.mousemovefunc);
            },

            destroy: function () {
                var isTouchDevice = $.jqx.mobile.isTouchDevice();
                var up = !isTouchDevice ? 'mouseup.' + this.base.element.id : 'touchend.' + this.base.element.id;
                var down = !isTouchDevice ? 'mousedown.' + this.base.element.id : 'touchstart.' + this.base.element.id;
                this.removeHandler(this.base.host, 'mousemove', this.mousemovefunc);
                this.removeHandler(this.base.host, down);
                this.removeHandler($(document), up);
                this.timer = null;
                delete this.mousemovefunc;
                delete this.timer;
                var vars = $.data(this.base.element, "jqxRepeatButton");
                if (vars) {
                    delete vars.instance;
                }
                $(this.base.element).removeData();
                this.base.destroy();
                delete this.base;

            },

            stop: function () {
                clearInterval(this.timer);
                this.timer = null;
            },

            ontimer: function (event) {
                var event = new $.Event('click');
                if (this.base != null && this.base.host != null) {
                    this.base.host.trigger(event);
                }
            }
        });
        //// End of RepeatButton
        //// ToggleButton
        $.jqx.jqxWidget("jqxToggleButton", "jqxButton", {});

        $.extend($.jqx._jqxToggleButton.prototype, {
            defineInstance: function () {
                this.toggled = false;
                this.uiToggle = true;
                this.aria =
                {
                    "aria-checked": { name: "toggled", type: "boolean" },
                    "aria-disabled": { name: "disabled", type: "boolean" }
                };
            },

            createInstance: function (args) {
                var that = this;
                that.base.overrideTheme = true;
                that.isTouchDevice = $.jqx.mobile.isTouchDevice();
                $.jqx.aria(this);
                that.base.host.attr('role', 'checkbox');

                that.propertyChangeMap['roundedCorners'] = function (instance, key, oldVal, value) {
                    instance.base.buttonObj.removeClass(instance.toThemeProperty($.jqx.cssroundedcorners(oldVal)));
                    instance.base.buttonObj.addClass(instance.toThemeProperty($.jqx.cssroundedcorners(value)));
                };

                that.propertyChangeMap['toggled'] = function (instance, key, oldVal, value) {
                    instance.refresh();
                };
                that.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    instance.base.disabled = value;
                    instance.refresh();
                };

                that.addHandler(that.base.host, 'click', function (event) {
                    if (!that.base.disabled && that.uiToggle) {
                        that.toggle();
                    }
                });

                if (!that.isTouchDevice) {
                    that.addHandler(that.base.host, 'mouseenter', function (event) {
                        if (!that.base.disabled) {
                            that.refresh();
                        }
                    });

                    that.addHandler(that.base.host, 'mouseleave', function (event) {
                        if (!that.base.disabled) {
                            that.refresh();
                        }
                    });
                }

                that.addHandler(that.base.host, 'mousedown', function (event) {
                    if (!that.base.disabled) {
                        that.refresh();
                    }
                });

                that.addHandler($(document), 'mouseup.togglebutton' + that.base.element.id, function (event) {
                    if (!that.base.disabled) {
                        that.refresh();
                    }
                });
            },

            destroy: function () {
                this._removeHandlers();
                this.base.destroy();
            },

            _removeHandlers: function () {
                this.removeHandler(this.base.host, 'click');
                this.removeHandler(this.base.host, 'mouseenter');
                this.removeHandler(this.base.host, 'mouseleave');
                this.removeHandler(this.base.host, 'mousedown');
                this.removeHandler($(document), 'mouseup.togglebutton' + this.base.element.id);
            },

            toggle: function () {
                this.toggled = !this.toggled;
                this.refresh();
                $.jqx.aria(this, "aria-checked", this.toggled);
            },

            unCheck: function () {
                this.toggled = false;
                this.refresh();
            },

            check: function () {
                this.toggled = true;
                this.refresh();
            },

            refresh: function () {
                var that = this;
                var cssDisabled = that.base.toThemeProperty('jqx-fill-state-disabled');
                var cssNormal = that.base.toThemeProperty('jqx-fill-state-normal');
                if (!that.base.enableDefault) {
                    cssNormal = "";
                }
                var cssHover = that.base.toThemeProperty('jqx-fill-state-hover');
                var cssPressed = that.base.toThemeProperty('jqx-fill-state-pressed');
                var cssPressedHover = that.base.toThemeProperty('jqx-fill-state-pressed');
                var cssCurrent = '';
                that.base.element.disabled = that.base.disabled;

                if (that.base.disabled) {
                    cssCurrent = cssNormal + " " + cssDisabled;
                    that.base.buttonObj.addClass(cssCurrent);
                    return;
                }
                else {
                    if (that.base.isMouseOver && !that.isTouchDevice) {
                        if (that.base.isPressed || that.toggled)
                            cssCurrent = cssPressedHover;
                        else
                            cssCurrent = cssHover;
                    }
                    else {
                        if (that.base.isPressed || that.toggled)
                            cssCurrent = cssPressed;
                        else
                            cssCurrent = cssNormal;
                    }
                }

                if (that.base.template !== "default" && that.base.template !== "") {
                    cssCurrent += " " + "jqx-" + that.base.template;
                    if (that.base.theme != "") {
                        cssCurrent += " " + "jqx-" + that.template + "-" + that.base.theme;
                    }
                }

                if (that.base.buttonObj.hasClass(cssDisabled) && cssDisabled != cssCurrent) {
                    that.base.buttonObj.removeClass(cssDisabled);
                }

                if (that.base.buttonObj.hasClass(cssNormal) && cssNormal != cssCurrent) {
                    that.base.buttonObj.removeClass(cssNormal);
                }

                if (that.base.buttonObj.hasClass(cssHover) && cssHover != cssCurrent) {
                    that.base.buttonObj.removeClass(cssHover);
                }

                if (that.base.buttonObj.hasClass(cssPressed) && cssPressed != cssCurrent) {
                    that.base.buttonObj.removeClass(cssPressed);
                }

                if (that.base.buttonObj.hasClass(cssPressedHover) && cssPressedHover != cssCurrent) {
                    that.base.buttonObj.removeClass(cssPressedHover);
                }

                if (!that.base.buttonObj.hasClass(cssCurrent)) {
                    that.base.buttonObj.addClass(cssCurrent);
                }
            },

            _topDocumentMouseupHandler: function (event) {
                var that = this;
                that.isPressed = false;
                that.refresh();
            }
        });
        //// End of ToggleButton

    })(jqxBaseFramework);
})();



/***/ }),

/***/ 4720:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }
    (function ($) {

        $.jqx.jqxWidget("jqxComboBox", "", {});

        $.extend($.jqx._jqxComboBox.prototype, {
            defineInstance: function () {
                var settings = {
                    // enables/disables the combobox.
                    disabled: false,
                    // gets or sets the listbox width.
                    width: 200,
                    // gets or sets the listbox height.
                    height: 25,
                    // Represents the collection of list items.
                    items: new Array(),
                    // Gets or sets the selected index.
                    selectedIndex: -1,
                    selectedItems: new Array(),
                    _selectedItems: new Array(),
                    // data source.
                    source: null,
                    autoItemsHeight: false,
                    // gets or sets the scrollbars size.
                    scrollBarSize: $.jqx.utilities.scrollBarSize,
                    // gets or sets the scrollbars size.
                    arrowSize: 17,
                    // enables/disables the hover state.
                    enableHover: true,
                    // enables/disables the selection.
                    enableSelection: true,
                    // gets the visible items. // this property is internal for the combobox.
                    visualItems: new Array(),
                    // gets the groups. // this property is internal for the combobox.
                    groups: new Array(),
                    // gets or sets whether the items width should be equal to the combobox's width.
                    equalItemsWidth: true,
                    // gets or sets the height of the ListBox Items. When the itemHeight:= - 1, each item's height is equal to its desired height.
                    itemHeight: -1,
                    // represents the combobox's events.
                    visibleItems: new Array(),
                    // emptry group's text.
                    hint: true,
                    emptyGroupText: 'Group',
                    emptyString: "",
                    ready: null,
                    // Type: Number
                    // Default: 100
                    // Showing Popup Animation's delay.
                    openDelay: 250,
                    // Type: Number
                    // Default: 200
                    // Hiding Popup Animation's delay.
                    closeDelay: 300,
                    // default, none
                    // Type: String.
                    // enables or disables the animation.
                    animationType: 'default',
                    // Type: String
                    // Default: auto ( the drop down takes the combobox's width.)
                    // Sets the popup's width.
                    dropDownWidth: 'auto',
                    // Type: String
                    // Default: 200px ( the height is 200px )
                    // Sets the popup's height.
                    dropDownHeight: '200px',
                    // Type: Boolean
                    // Default: false
                    // Sets the popup's height to be equal to the items summary height,
                    autoDropDownHeight: false,
                    // Type: Boolean
                    // Default: false
                    // Enables or disables the browser detection.
                    enableBrowserBoundsDetection: false,
                    dropDownHorizontalAlignment: 'left',
                    dropDownVerticalAlignment: 'bottom',
                    dropDownContainer: "default",
                    // Type: String
                    // Default: startswithignorecase
                    // Possible Values: 'none, 'contains', 'containsignorecase', 'equals', 'equalsignorecase', 'startswithignorecase', 'startswith', 'endswithignorecase', 'endswith'
                    searchMode: 'startswithignorecase',
                    autoComplete: false,
                    remoteAutoComplete: false,
                    remoteAutoCompleteDelay: 500,
                    selectionMode: "default",
                    minLength: 2,
                    displayMember: "",
                    valueMember: "",
                    groupMember: "",
                    searchMember: "",
                    keyboardSelection: true,
                    renderer: null,
                    autoOpen: false,
                    template: "",
                    checkboxes: false,
                    promptText: "",
                    placeHolder: "",
                    rtl: false,
                    listBox: null,
                    validateSelection: null,
                    showCloseButtons: true,
                    renderSelectedItem: null,
                    search: null,
                    popupZIndex: 2000,
                    searchString: null,
                    multiSelect: false,
                    showArrow: true,
                    _disabledItems: new Array(),
                    touchMode: 'auto',
                    autoBind: true,
                    aria:
                    {
                        "aria-disabled": { name: "disabled", type: "boolean" }
                    },
                    events:
                        [
                            // occurs when the combobox is opened.
                            'open',
                            // occurs when the combobox is closed.
                            'close',
                            // occurs when an item is selected.
                            'select',
                            // occurs when an item is unselected.
                            'unselect',
                            // occurs when the selection is changed.
                            'change',
                            // triggered when the user checks or unchecks an item.
                            'checkChange',
                            // triggered when the binding is completed.
                            'bindingComplete',
                            // triggered when a new item is added.
                            'itemAdd',
                            // triggered when a new item is removed.
                            'itemRemove',
                            // triggered when a new item is updated.
                            'itemUpdate'
                        ]
                };
                if (this === $.jqx._jqxComboBox.prototype) {
                    return settings;
                }
                $.extend(true, this, settings);
                return settings;
            },

            createInstance: function (args) {
                var that = this;
                this.host.attr('role', 'combobox');
                this.host.attr('aria-expanded', 'false');
                $.jqx.aria(this, "aria-autocomplete", "both");

                if ($.jqx._jqxListBox == null || $.jqx._jqxListBox == undefined) {
                    throw new Error("jqxComboBox: Missing reference to jqxlistbox.js.");
                }
                $.jqx.aria(this);

                if (that.isMaterialized()) {
                    var elementStyle = window.getComputedStyle(this.element);
                    var animation = elementStyle.getPropertyValue('--jqx-dropdown-animation');
                    var rowHeight = elementStyle.getPropertyValue('--jqx-list-item-height');
                    var arrowSize = elementStyle.getPropertyValue('--jqx-action-button-size');

                    if (arrowSize) {
                        this.arrowSize = parseInt(arrowSize);
                    }
                    else {
                        this.arrowSize = 25;
                    }

                    if (animation && this.animationType == "default") {
                        this.animationType = animation.trim();
                    }

                    if (rowHeight && this.itemHeight === -1) {
                        this.itemHeight = parseInt(rowHeight);
                    }
                }

                // prompt text is deprecated.
                if (this.promptText != "") {
                    this.placeHolder = this.promptText;
                }

                this.render();
            },

            render: function () {
                var that = this;
                var nodeName = that.element.nodeName.toLowerCase();
                if (nodeName == "select" || nodeName == "ul" || nodeName == "ol") {
                    that.field = that.element;
                    if (that.field.className) {
                        that._className = that.field.className;
                    }

                    var properties = {
                        'title': that.field.title
                    };

                    if (that.field.id.length) {
                        properties.id = that.field.id.replace(/[^\w]/g, '_') + "_jqxComboBox";
                    }
                    else {
                        properties.id = $.jqx.utilities.createId() + "_jqxComboBox";
                    }

                    var wrapper = $("<div></div>", properties);
                    if (!that.width) {
                        that.width = $(that.field).width();
                    }
                    if (!that.height) {
                        that.height = $(that.field).outerHeight();
                    }

                    that.element.style.cssText = that.field.style.cssText;
                    $(that.field).hide().after(wrapper);
                    var data = that.host.data();
                    that.host = wrapper;
                    that.host.data(data);
                    that.element = wrapper[0];
                    that.element.id = that.field.id;
                    that.field.id = properties.id;
                    if (that._className) {
                        that.host.addClass(that._className);
                        $(that.field).removeClass(that._className);
                    }

                    if (that.field.tabIndex) {
                        var tabIndex = that.field.tabIndex;
                        that.field.tabIndex = -1;
                        that.element.tabIndex = tabIndex;
                    }
                    if (that.field.innerHTML != "") {
                        var result = $.jqx.parseSourceTag(that.field);
                        that.source = result.items;
                        if (that.selectedIndex == -1)
                            that.selectedIndex = result.index;
                    }
                }
                else {
                    if (that.host.find('li').length > 0 || that.host.find('option').length > 0) {
                        var result = $.jqx.parseSourceTag(that.element);
                        that.source = result.items;
                    }
                }
                that.removeHandlers();
                that.isanimating = false;
                that.id = $.jqx.utilities.createId();
                that.element.innerHTML = "";
                var comboStructure = $("<div style='background-color: transparent; -webkit-appearance: none; outline: none; width:100%; height: 100%; padding: 0px; margin: 0px; border: 0px; position: relative;'>" +
                    "<div id='dropdownlistWrapper' style='padding: 0; margin: 0; border: none; background-color: transparent; float: left; width:100%; height: 100%; position: relative;'>" +
                    "<div id='dropdownlistContent' style='padding: 0; margin: 0; border-top: none; border-bottom: none; float: left; position: absolute;'></div>" +
                    "<div id='dropdownlistArrow' role='button' style='padding: 0; margin: 0; border-left-width: 1px; border-bottom-width: 0px; border-top-width: 0px; border-right-width: 0px; float: right; position: absolute;'></div>" +
                    "</div>" +
                    "</div>");
                that.comboStructure = comboStructure;
                if ($.jqx._jqxListBox == null || $.jqx._jqxListBox == undefined) {
                    throw "jqxComboBox: Missing reference to jqxlistbox.js.";
                }

                that.touch = $.jqx.mobile.isTouchDevice();
                if (that.touchMode === true) {
                    that.touch = true;
                }

                that.host.append(comboStructure);

                that.dropdownlistWrapper = that.host.find('#dropdownlistWrapper');
                that.dropdownlistArrow = that.host.find('#dropdownlistArrow');
                that.dropdownlistContent = that.host.find('#dropdownlistContent');
                that.dropdownlistContent.addClass(that.toThemeProperty('jqx-combobox-content'));
                that.dropdownlistContent.addClass(that.toThemeProperty('jqx-widget-content'));
                that.dropdownlistWrapper[0].id = "dropdownlistWrapper" + that.element.id;
                that.dropdownlistArrow[0].id = "dropdownlistArrow" + that.element.id;
                that.dropdownlistContent[0].id = "dropdownlistContent" + that.element.id;
                if (that.template) {
                    that.dropdownlistArrow.addClass(that.toThemeProperty("jqx-" + that.template + ""));
                }
                that.dropdownlistContent.append($('<input autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="box-sizing: border-box; margin: 0; padding: 0; padding-left: 3px; padding-right: 3px; border: 0;" type="textarea"/>'));
                that.input = that.dropdownlistContent.find('input');
                that.input.addClass(that.toThemeProperty('jqx-combobox-input'));
                that.input.addClass(that.toThemeProperty('jqx-widget-content'));
                that.input[0].setAttribute('aria-label', 'input');

                if (that.host.attr('tabindex')) {
                    that.input.attr('tabindex', that.host.attr('tabindex'));
                    that.host.removeAttr('tabindex');
                }


                var label = $("<label></label>");
                if (this.hint) {
                    label[0].innerHTML = this.placeHolder;
                }

                label.addClass(that.toThemeProperty('jqx-input-label'));
                that.dropdownlistWrapper.append(label);
                that.label = label;

                var bar = $("<span></span>");
                that.dropdownlistWrapper.append(bar);
                bar.addClass(that.toThemeProperty('jqx-input-bar'));
                that.bar = bar;

                var that = this;

                if (that.template) {
                    that.bar.addClass(that.toThemeProperty("jqx-" + that.template));
                    that.label.addClass(that.toThemeProperty("jqx-" + that.template));
                }

                that._addInput();
                if (that.rtl) {
                    that.input.css({ direction: "rtl" });
                    that.dropdownlistContent.addClass(that.toThemeProperty('jqx-combobox-content-rtl'));
                }

                try {
                    var listBoxID = 'listBox' + that.id;
                    var oldContainer = $($.find('#' + listBoxID));
                    if (oldContainer.length > 0) {
                        oldContainer.remove();
                    }
                    $.jqx.aria(this, "aria-owns", listBoxID);
                    $.jqx.aria(this, "aria-haspopup", true);
                    if (that.listBoxContainer) that.listBoxContainer.jqxListBox('destroy');
                    if (that.container) that.container.remove();
                    var container = $("<div style='overflow: hidden; border: none; background-color: transparent; position: absolute;' id='listBox" + that.id + "'><div id='innerListBox" + that.id + "'></div></div>");
                    container.hide();
                    if (that.dropDownContainer == "element") {
                        container.appendTo(that.host);
                    }
                    else {
                        container.appendTo(document.body);
                    }
                    container.addClass(that.toThemeProperty('jqx-listbox-container'));

                    that.container = container;
                    that.listBoxContainer = $($.find('#innerListBox' + that.id));

                    var width = that.width;
                    if (that.dropDownWidth != 'auto') {
                        width = that.dropDownWidth;
                    }

                    if (that.dropDownHeight == null) {
                        that.dropDownHeight = 200;
                    }

                    that.container.width(parseInt(width) + 25);
                    that.container.height(parseInt(that.dropDownHeight) + 25);
                    that._ready = false;

                    that.addHandler(that.listBoxContainer, 'bindingComplete', function (event) {
                        if (!that.listBox) {
                            that.listBox = $.data(that.listBoxContainer[0], "jqxListBox").instance;
                        }
                        if (!that._ready) {
                            if (that.ready) {
                                that.ready();
                            }
                            that._ready = true;
                        }
                        that._raiseEvent('6');
                    });
                    that.addHandler(that.listBoxContainer, 'itemAdd', function (event) {
                        that._raiseEvent('7', event.args);
                    });
                    that.addHandler(that.listBoxContainer, 'itemRemove', function (event) {
                        that._raiseEvent('8', event.args);
                    });
                    that.addHandler(that.listBoxContainer, 'itemUpdate', function (event) {
                        that._raiseEvent('9', event.args);
                    });

                    var initializing = true;
                    that.listBoxContainer.jqxListBox({
                        autoItemsHeight: that.autoItemsHeight,
                        _checkForHiddenParent: false, allowDrop: false, allowDrag: false,
                        checkboxes: that.checkboxes, emptyString: that.emptyString, autoBind: !that.remoteAutoComplete && that.autoBind,
                        renderer: that.renderer, rtl: that.rtl, itemHeight: that.itemHeight, selectedIndex: that.selectedIndex, incrementalSearch: false, width: width, scrollBarSize: that.scrollBarSize, autoHeight: that.autoDropDownHeight, height: that.dropDownHeight, groupMember: that.groupMember, searchMember: that.searchMember, displayMember: that.displayMember, valueMember: that.valueMember, source: that.source, theme: that.theme,
                        rendered: function () {
                            that.listBox = $.data(that.listBoxContainer[0], "jqxListBox").instance;
                            if (that.remoteAutoComplete) {
                                if (that.autoDropDownHeight) {
                                    that.container.height(that.listBox.virtualSize.height + 25);
                                    that.listBoxContainer.height(that.listBox.virtualSize.height);
                                    that.listBox._arrange();
                                }
                                else {
                                    that.listBox._arrange();
                                    that.listBox.ensureVisible(0);
                                    that.listBox._renderItems();
                                    that.container.height(that.listBoxContainer.height() + 25);
                                }

                                if (that.searchString != undefined && that.searchString.length >= that.minLength) {
                                    var items = that.listBoxContainer.jqxListBox('items');
                                    if (items) {
                                        if (items.length > 0) {
                                            if (!that.isOpened()) {
                                                that.open();
                                            }
                                        }
                                        else that.close();
                                    } else that.close();
                                }
                                else {
                                    that.close();
                                }
                            }
                            else {
                                that.renderSelection('mouse');
                                if (that.multiSelect) {
                                    that.doMultiSelect(false);
                                }
                            }

                            if (that.rendered) {
                                that.rendered();
                            }
                        }
                    });

                    if (that.dropDownContainer == "element") {
                        that.listBoxContainer.css({ position: 'absolute', top: 0, left: 0 });
                    }
                    else {
                        that.listBoxContainer.css({ position: 'absolute', zIndex: that.popupZIndex, top: 0, left: 0 });
                    }
                    that.listBoxContainer.css('border-top-width', '1px');
                    that.listBoxContainer.addClass(that.toThemeProperty('jqx-popup'));
                    if ($.jqx.browser.msie) {
                        that.listBoxContainer.addClass(that.toThemeProperty('jqx-noshadow'));
                    }
                    if (that.template) {
                        that.listBoxContainer.addClass(that.toThemeProperty("jqx-" + that.template + "-item"));
                    }

                    that.listBox = $.data(that.listBoxContainer[0], "jqxListBox").instance;
                    that.listBox.enableSelection = that.enableSelection;
                    that.listBox.enableHover = that.enableHover;
                    that.listBox.equalItemsWidth = that.equalItemsWidth;
                    that.listBox._arrange();
                    that.addHandler(that.listBoxContainer, 'unselect', function (event) {
                        if (!that.multiSelect) {
                            that._raiseEvent('3', { index: event.args.index, type: event.args.type, item: event.args.item });
                        }
                    });

                    that.addHandler(that.listBoxContainer, 'change', function (event) {
                        if (!that.multiSelect) {
                            that.selectedIndex = that.listBox.selectedIndex;
                            that._raiseEvent('4', { index: event.args.index, type: event.args.type, item: event.args.item });
                        }
                    });

                    if (that.animationType == 'none') {
                        that.container.css('display', 'none');
                    }
                    else {
                        that.container.hide();
                    }
                    initializing = false;
                }
                catch (e) {
                    throw e;
                }


                var that = this;
                that.input.attr('disabled', that.disabled);
                var ie7 = $.jqx.browser.msie && $.jqx.browser.version < 8;
                if (!ie7) {
                    if (that.isMaterialized() && that.hint) {
                        that.label[0].innerHTML = that.placeHolder;
                    }
                    else {
                        that.input.attr('placeholder', that.placeHolder);
                    }
                }

                that.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    if (value) {
                        instance.host.addClass(that.toThemeProperty('jqx-combobox-state-disabled'));
                        instance.host.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
                        instance.dropdownlistContent.addClass(that.toThemeProperty('jqx-combobox-content-disabled'));
                    }
                    else {
                        instance.host.removeClass(that.toThemeProperty('jqx-combobox-state-disabled'));
                        instance.host.removeClass(that.toThemeProperty('jqx-fill-state-disabled'));
                        instance.dropdownlistContent.removeClass(that.toThemeProperty('jqx-combobox-content-disabled'));
                    }
                    instance.input.attr('disabled', instance.disabled);
                    $.jqx.aria(instance, "aria-disabled", instance.disabled);
                    instance.input.attr('disabled', instance.disabled);
                }

                if (that.disabled) {
                    that.host.addClass(that.toThemeProperty('jqx-combobox-state-disabled'));
                    that.host.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
                    that.dropdownlistContent.addClass(that.toThemeProperty('jqx-combobox-content-disabled'));
                }

                that.host.addClass(that.toThemeProperty('jqx-combobox-state-normal'));
                that.host.addClass(that.toThemeProperty('jqx-combobox'));
                that.host.addClass(that.toThemeProperty('jqx-rc-all'));
                that.host.addClass(that.toThemeProperty('jqx-widget'));
                that.host.addClass(that.toThemeProperty('jqx-widget-content'));
                that.dropdownlistArrowIcon = $("<div></div>");
                if (that.dropDownVerticalAlignment == "top") {
                    that.dropdownlistArrowIcon.addClass(that.toThemeProperty('jqx-icon-arrow-up'));
                }
                else {
                    that.dropdownlistArrowIcon.addClass(that.toThemeProperty('jqx-icon-arrow-down'));
                }
                that.dropdownlistArrowIcon.addClass(that.toThemeProperty('jqx-icon'));
                that.dropdownlistArrow.append(that.dropdownlistArrowIcon);
                that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-combobox-arrow-normal'));
                that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-fill-state-normal'));
                that.dropdownlistArrow[0].setAttribute('aria-label', 'expand');

                if (!that.rtl) {
                    that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-rc-r'));
                }
                else {
                    that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-rc-l'));
                }

                that._setSize();
                that._updateHandlers();

                that.addHandler(that.input, 'paste.textchange', function (event) {
                    if (that._writeTimer) clearTimeout(that._writeTimer);
                    that._writeTimer = setTimeout(function () {
                        that.ctrlKey = false;

                        var foundMatch = that._search(event);
                        if (that.cinput && that.input) {
                            if (!that.displayMember) {
                                that.cinput[0].value = that.input[0].value;
                            }
                            else {
                                that._updateInputSelection();
                            }
                        }
                    }, 50);
                });

                that.addHandler(that.input, 'keyup.textchange', function (event) {
                    if (that._writeTimer) clearTimeout(that._writeTimer);
                    that._writeTimer = setTimeout(function () {
                        var foundMatch = that._search(event);
                        if (that.cinput && that.input) {
                            if (!that.displayMember) {
                                that.cinput[0].value = that.input[0].value;
                            }
                            else {
                                that._updateInputSelection();
                            }
                        }
                    }, 50);
                });

                // fix for IE7
                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                    if (that.host.parents('.jqx-window').length > 0) {
                        var zIndex = that.host.parents('.jqx-window').css('z-index');
                        container.css('z-index', zIndex + 10);
                        that.listBoxContainer.css('z-index', zIndex + 10);
                    }
                }

                if (that.checkboxes) {
                    that.input.attr('readonly', true);
                    $.jqx.aria(this, "aria-readonly", true);
                }
                else {
                    $.jqx.aria(this, "aria-readonly", false);
                }
                if (!that.remoteAutoComplete) {
                    that.searchString = "";
                }

                this.bar.css('top', this.host.height());
            },

            _addInput: function () {
                var name = this.host.attr('name');
                this.cinput = $("<input type='hidden'/>");
                this.host.append(this.cinput);
                if (name) {
                    this.cinput.attr('name', name);
                }
            },

            _updateInputSelection: function () {
                if (this.cinput) {
                    var selectedValues = new Array();
                    if (this.selectedIndex == -1) {
                        this.cinput.val("");
                    }
                    else {
                        var selectedItem = this.getSelectedItem();
                        if (selectedItem != null) {
                            this.cinput.val(selectedItem.value);
                            selectedValues.push(selectedItem.value);
                        }
                        else {
                            this.cinput.val(this.dropdownlistContent.text());
                        }
                    }

                    if (this.checkboxes || this.multiSelect) {
                        if (!this.multiSelect) {
                            var items = this.getCheckedItems();
                        }
                        else {
                            var items = this.getSelectedItems();
                        }

                        var str = "";
                        if (items != null) {
                            for (var i = 0; i < items.length; i++) {
                                if (i == items.length - 1) {
                                    str += items[i].value;
                                }
                                else {
                                    str += items[i].value + ",";
                                }
                                selectedValues.push(items[i].value);
                            }
                        }
                        this.cinput.val(str);
                    }
                    if (this.field && this.cinput) {
                        if (this.field.nodeName.toLowerCase() == "select") {
                            $.each(this.field, function (index, value) {
                                $(this).removeAttr('selected');
                                this.selected = selectedValues.indexOf(this.value) >= 0;
                                if (this.selected) {
                                    $(this).attr('selected', true);
                                }
                            });
                        }
                        else {
                            $.each(this.items, function (index, value) {
                                $(this.originalItem.originalItem).removeAttr('data-selected');
                                this.selected = selectedValues.indexOf(this.value) >= 0;
                                if (this.selected) {
                                    $(this.originalItem.originalItem).attr('data-selected', true);
                                }
                            });
                        }
                    }
                }
            },

            _search: function (event) {
                var that = this;

                if (event.keyCode == 9)
                    return;

                if (that.searchMode == 'none' || that.searchMode == null || that.searchMode == 'undefined') {
                    return;
                }

                if (event.keyCode == 16 || event.keyCode == 17 || event.keyCode == 20)
                    return;

                if (that.checkboxes) {
                    return;
                }

                if (that.multiSelect) {
                    var span = $("<span style='visibility: hidden; white-space: nowrap;'>" + document.createTextNode(that.input.val()) + "</span>");
                    span.addClass(that.toThemeProperty('jqx-widget'));
                    $(document.body).append(span);
                    var width = span.width() + 15;
                    span.remove();

                    if (width > that.host.width()) {
                        width = that.host.width();
                    }
                    if (width < 25) {
                        width = 25;
                    }

                    that.input.css('width', width + 'px');
                    if (that.selectedItems.length == 0) {
                        that.input.css('width', '100%');

                        if (!that.isMaterialized()) {
                            that.input.attr('placeholder', that.placeHolder);
                        }
                    }
                    else {
                        if (!that.isMaterialized()) {
                            that.input.attr('placeholder', "");
                        }
                    }

                    var top = parseInt(this._findPos(that.host[0])[1]) + parseInt(that.host.outerHeight()) - 1 + 'px';
                    var isMobileBrowser = false;// $.jqx.mobile.isSafariMobileBrowser() || $.jqx.mobile.isWindowsPhone();
                    if ((isMobileBrowser != null && isMobileBrowser)) {
                        top = $.jqx.mobile.getTopPos(this.element) + parseInt(that.host.outerHeight());
                        if ($('body').css('border-top-width') != '0px') {
                            top = parseInt(top) - this._getBodyOffset().top + 'px';
                        }
                    }

                    that.container.css('top', top);
                    var height = parseInt(that.host.height());
                    that.dropdownlistArrow.height(height);
                }

                if (!that.isanimating) {
                    if (event.altKey && event.keyCode == 38) {
                        that.hideListBox('altKey');
                        return false;
                    }

                    if (event.altKey && event.keyCode == 40) {
                        if (!that.isOpened()) {
                            that.showListBox('altKey');
                        }
                        return false;
                    }
                }

                if (event.keyCode == 37 || event.keyCode == 39)
                    return false;

                if (event.altKey || event.keyCode == 18)
                    return;

                if (event.keyCode >= 33 && event.keyCode <= 40) {
                    return;
                }

                if (event.ctrlKey || that.ctrlKey) {
                    if (event.keyCode != 88 && event.keyCode != 86) {
                        return;
                    }
                }

                var value = that.input.val();
                if (value.length == 0 && !that.autoComplete) {
                    that.listBox.searchString = that.input.val();
                    that.listBox.clearSelection();
                    that.hideListBox('search');
                    that.searchString = that.input.val();
                    return;
                }

                if (that.remoteAutoComplete) {
                    var that = this;
                    var clearListSelection = function () {
                        that.listBox.vScrollInstance.value = 0;
                    }

                    if (value.length >= that.minLength) {
                        if (!event.ctrlKey && !event.altKey) {
                            if (that.searchString != value) {
                                var source = that.listBoxContainer.jqxListBox('source');
                                if (source == null) {
                                    that.listBoxContainer.jqxListBox({ source: that.source });
                                }
                                if (that._searchTimer) {
                                    clearTimeout(that._searchTimer);
                                }
                                if (event.keyCode != 13 && event.keyCode != 27) {
                                    that._searchTimer = setTimeout(function () {
                                        clearListSelection();
                                        if (that.autoDropDownHeight) {
                                            that.listBox.autoHeight = true;
                                        }
                                        that.searchString = that.input.val();
                                        if (that.search != null) {
                                            that.search(that.input.val());
                                        }
                                        else {
                                            throw "'search' function is not defined";
                                        }

                                    }, that.remoteAutoCompleteDelay);
                                }
                            }
                            that.searchString = value;
                        }
                    }
                    else {
                        if (that._searchTimer) clearTimeout(that._searchTimer);
                        clearListSelection();
                        that.searchString = "";
                        that.search("");
                        that.listBoxContainer.jqxListBox({ source: null });
                    }
                    return;
                }

                var that = this;
                if (value === that.searchString) {
                    return;
                }

                if (!(event.keyCode == '27' || event.keyCode == '13')) {
                    var currentValue = that.input[0].value;
                    var matches = that._updateItemsVisibility(value);
                    var matchItems = matches.matchItems;
                    if (that.autoComplete && that.autoItemsHeight) {
                        that.input[0].value = currentValue;
                    }
                    var index = matches.index;
                    if (!that.autoComplete && !that.remoteAutoComplete) {
                        if (!that.multiSelect || (that.multiSelect && index >= 0)) {
                            that.listBox.selectIndex(index);
                            var isInView = that.listBox.isIndexInView(index);
                            if (!isInView) {
                                that.listBox.ensureVisible(index);
                            }
                            else {
                                that.listBox._renderItems();
                            }
                        }
                    }

                    if (that.autoComplete && matchItems.length === 0) {
                        that.hideListBox('search');
                    }
                }

                if (event.keyCode == '13') {
                    var isOpen = that.container.css('display') == 'block';
                    if (isOpen && !that.isanimating) {
                        that.hideListBox('keyboard');
                        that._oldvalue = that.listBox.selectedValue;
                        return;
                    }
                }
                else if (event.keyCode == '27') {
                    var isOpen = that.container.css('display') == 'block';
                    if (isOpen && !that.isanimating) {
                        if (!that.multiSelect) {
                            var item = that.listBox.getVisibleItem(that._oldvalue);
                            if (item) {
                                var that = this;
                                setTimeout(
                                    function () {
                                        if (that.autoComplete) {
                                            that._updateItemsVisibility("");
                                        }
                                        that.listBox.selectIndex(item.index);
                                        that.renderSelection('api');
                                    }, that.closeDelay);
                            }
                            else {
                                that.clearSelection();
                            }
                        }
                        else {
                            that.input.val("");
                            that.listBox.selectedValue = null;
                        }

                        that.hideListBox('keyboard');
                        that.renderSelection('api');
                        event.preventDefault();
                        return false;
                    }
                }
                else {
                    if (!that.isOpened() && !that.opening && !event.ctrlKey) {
                        if (that.listBox.visibleItems && that.listBox.visibleItems.length > 0) {
                            if (that.input.val() != that.searchString && that.searchString != undefined && index != -1) {
                                that.showListBox('search');
                            }
                        }
                    }
                    that.searchString = that.input.val();

                    if (that.searchString == "") {
                        if (!that.listBox.itemsByValue[""]) {
                            index = -1;
                            if (!that.multiSelect) {
                                that.clearSelection();
                            }
                        }
                    }

                    var item = that.listBox.getVisibleItem(index);

                    if (item != undefined) {
                        that._updateInputSelection();
                    }
                }
            },

            val: function (value) {
                if (!this.input) return "";
                var isEmpty = function (obj) {
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key))
                            return false;
                    }

                    if (typeof value == "number")
                        return false;
                    if (typeof value == "date")
                        return false;
                    if (typeof value == "boolean")
                        return false;
                    if (typeof value == "string")
                        return false;

                    return true;
                }

                if (isEmpty(value) || arguments.length == 0) {
                    var item = this.getSelectedItem();
                    if (item) {
                        return item.value;
                    }


                    return this.input.val();
                }
                else {
                    var item = this.getItemByValue(value);
                    if (item != null) {
                        this.selectItem(item);
                    }
                    else {
                        this.input.val(value);
                    }
                    return this.input.val();
                }
            },

            focus: function () {
                var that = this;
                var doFocus = function () {
                    that.input.focus();
                    var val = that.input.val();
                    that._setSelection(0, val.length);
                }
                doFocus();
                setTimeout(function () {
                    doFocus();
                }, 10);
            },

            _setSelection: function (start, end) {
                try {
                    if ('selectionStart' in this.input[0]) {
                        this.input[0].focus();
                        this.input[0].setSelectionRange(start, end);
                    }
                    else {
                        var range = this.input[0].createTextRange();
                        range.collapse(true);
                        range.moveEnd('character', end);
                        range.moveStart('character', start);
                        range.select();
                    }
                }
                catch (error) {
                }
            },

            setContent: function (value) {
                this.input.val(value);
            },

            // get all matches of a searched value.
            _updateItemsVisibility: function (value) {
                var items = this.getItems();
                if (items == undefined) {
                    return { index: -1, matchItem: new Array() }
                }

                var that = this;
                var index = -1;
                var matchItems = new Array();
                var newItemsIndex = 0;

                $.each(items, function (i) {
                    var itemValue = '';
                    if (!this.isGroup) {
                        if (this.searchLabel) {
                            itemValue = this.searchLabel;
                        }
                        else if (this.label) {
                            itemValue = this.label;
                        }
                        else if (this.value) {
                            itemValue = this.value;
                        }
                        else if (this.title) {
                            itemValue = this.title;
                        }
                        else itemValue = 'jqxItem';
                        itemValue = itemValue.toString();
                        var matches = false;
                        switch (that.searchMode) {
                            case 'containsignorecase':
                                matches = $.jqx.string.containsIgnoreCase(itemValue, value);
                                break;
                            case 'contains':
                                matches = $.jqx.string.contains(itemValue, value);
                                break;
                            case 'equals':
                                matches = $.jqx.string.equals(itemValue, value);
                                break;
                            case 'equalsignorecase':
                                matches = $.jqx.string.equalsIgnoreCase(itemValue, value);
                                break;
                            case 'startswith':
                                matches = $.jqx.string.startsWith(itemValue, value);
                                break;
                            case 'startswithignorecase':
                                matches = $.jqx.string.startsWithIgnoreCase(itemValue, value);
                                break;
                            case 'endswith':
                                matches = $.jqx.string.endsWith(itemValue, value);
                                break;
                            case 'endswithignorecase':
                                matches = $.jqx.string.endsWithIgnoreCase(itemValue, value);
                                break;
                        }

                        if (that.autoComplete && !matches) {
                            this.visible = false;
                        }

                        if (matches && that.autoComplete) {
                            matchItems[newItemsIndex++] = this;
                            this.visible = true;
                            index = this.visibleIndex;
                        }

                        if (value == '' && that.autoComplete) {
                            this.visible = true;
                            matches = false;
                        }

                        if (that.multiSelect) {
                            this.disabled = false;
                            if (that.selectedItems.indexOf(this.value) >= 0 || that._disabledItems.indexOf(this.value) >= 0) {
                                this.disabled = true;
                                matches = false;
                            }
                        }

                        if (!that.multiSelect) {
                            if (matches && !that.autoComplete) {
                                index = this.visibleIndex;
                                return false;
                            }
                        }
                        else {
                            if (matches && !that.autoComplete) {
                                if (index === -1) {
                                    index = this.visibleIndex;
                                }
                                return true;
                            }
                        }
                    }
                });
                this.listBox.searchString = value;
                var that = this;
                var selectFirstItem = function () {
                    if (that.multiSelect) return;
                    var nonDisabledIndex = 0;
                    var foundIndex = false;
                    var item = null;
                    for (var indx = 0; indx < that.listBox.items.length; indx++) {
                        that.listBox.selectedIndexes[indx] = -1;
                        if (!that.listBox.items[indx].disabled) {
                            if (foundIndex == false) {
                                item = that.listBox.items[indx];
                                nonDisabledIndex = item.visibleIndex;
                                foundIndex = true;
                            }
                        }
                    }
                    that.listBox.selectedIndex = -1;
                    that.listBox.selectedIndex = nonDisabledIndex;
                    that.listBox.selectedIndexes[nonDisabledIndex] = nonDisabledIndex;
                    if (that.listBox.visibleItems.length > 0) {
                        if (item) {
                            that.listBox.selectedValue = item.value;
                        }
                        else {
                            that.listBox.selectedValue = null;
                        }
                    }
                    else {
                        that.listBox.selectedValue = null;
                    }
                    that.listBox.ensureVisible(0);
                }

                if (!this.autoComplete) {
                    selectFirstItem();
                    return { index: index, matchItems: matchItems };
                }

                this.listBox.renderedVisibleItems = new Array();
                var vScrollValue = this.listBox.vScrollInstance.value;
                this.listBox.vScrollInstance.value = 0;
                this.listBox.visibleItems = new Array();
                this.listBox._renderItems();
                var selectedValue = this.listBox.selectedValue;
                var item = this.listBox.getItemByValue(selectedValue);
                if (!this.multiSelect) {
                    if (item) {
                        if (item.visible) {
                            this.listBox.selectedIndex = item.visibleIndex;
                            for (var indx = 0; indx < this.listBox.items.length; indx++) {
                                this.listBox.selectedIndexes[indx] = -1;
                            }
                            this.listBox.selectedIndexes[item.visibleIndex] = item.visibleIndex;
                        }
                        else {
                            for (var indx = 0; indx < this.listBox.items.length; indx++) {
                                this.listBox.selectedIndexes[indx] = -1;
                            }
                            this.listBox.selectedIndex = -1;
                        }
                    }
                }
                else {
                    selectFirstItem();
                }

                this.listBox._renderItems();
                var height = this.listBox._calculateVirtualSize().height;
                if (height < vScrollValue) {
                    vScrollValue = 0;
                    this.listBox.vScrollInstance.refresh();
                }
                if (this.autoDropDownHeight) {
                    this._disableSelection = true;
                    if (this.listBox.autoHeight != this.autoDropDownHeight) {
                        this.listBoxContainer.jqxListBox({ autoHeight: this.autoDropDownHeight });
                    }
                    this.container.height(height + 25);
                    this.listBox.invalidate();
                    this._disableSelection = false;
                }
                else {
                    if (height < parseInt(this.dropDownHeight)) {
                        var scrollOffset = this.listBox.hScrollBar[0].style.visibility == "hidden" ? 0 : 20;
                        this.listBox.height = scrollOffset + height;
                        this.container.height(height + 25 + scrollOffset);
                        this.listBox.invalidate();
                    }
                    else {
                        this.listBox.height = parseInt(this.dropDownHeight);
                        this.container.height(parseInt(this.dropDownHeight) + 25);
                        this.listBox.invalidate();
                    }
                }

                this.listBox.vScrollInstance.setPosition(vScrollValue);
                return { index: index, matchItems: matchItems };
            },

            // gets all items that match to a search value.
            findItems: function (value) {
                var items = this.getItems();
                var that = this;
                var index = 0;
                var matchItems = new Array();

                $.each(items, function (i) {
                    var itemValue = '';
                    if (!this.isGroup) {
                        if (this.label) {
                            itemValue = this.label;
                        }
                        else if (this.value) {
                            itemValue = this.value;
                        }
                        else if (this.title) {
                            itemValue = this.title;
                        }
                        else itemValue = 'jqxItem';

                        var matches = false;
                        switch (that.searchMode) {
                            case 'containsignorecase':
                                matches = $.jqx.string.containsIgnoreCase(itemValue, value);
                                break;
                            case 'contains':
                                matches = $.jqx.string.contains(itemValue, value);
                                break;
                            case 'equals':
                                matches = $.jqx.string.equals(itemValue, value);
                                break;
                            case 'equalsignorecase':
                                matches = $.jqx.string.equalsIgnoreCase(itemValue, value);
                                break;
                            case 'startswith':
                                matches = $.jqx.string.startsWith(itemValue, value);
                                break;
                            case 'startswithignorecase':
                                matches = $.jqx.string.startsWithIgnoreCase(itemValue, value);
                                break;
                            case 'endswith':
                                matches = $.jqx.string.endsWith(itemValue, value);
                                break;
                            case 'endswithignorecase':
                                matches = $.jqx.string.endsWithIgnoreCase(itemValue, value);
                                break;
                        }

                        if (matches) {
                            matchItems[index++] = this;
                        }
                    }
                });

                return matchItems;
            },

            //[optimize]
            _resetautocomplete: function () {
                $.each(this.listBox.items, function (i) {
                    this.visible = true;
                });
                this.listBox.vScrollInstance.value = 0;
                this.listBox._addItems();
                this.listBox.autoHeight = false;

                this.listBox.height = this.dropDownHeight;
                this.container.height(parseInt(this.dropDownHeight) + 25);
                this.listBoxContainer.height(parseInt(this.dropDownHeight));
                this.listBox._arrange();

                this.listBox._addItems();
                this.listBox._renderItems();
            },

            // gets all items.
            getItems: function () {
                var item = this.listBox.items;
                return item;
            },

            getVisibleItems: function () {
                return this.listBox.getVisibleItems();
            },

            _setSize: function () {
                var computedStyle = window.getComputedStyle(this.element);
                var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
                var boxSizing = computedStyle.boxSizing;

                if (boxSizing === 'border-box' || isNaN(borderSize)) {
                    borderSize = 0;
                }

                if (this.width != null && this.width.toString().indexOf("px") != -1) {
                    this.element.style.width = parseInt(this.width) - borderSize + 'px';
                }
                else if (this.width != undefined && !isNaN(this.width)) {
                    this.element.style.width = parseInt(this.width) - borderSize + 'px';
                }

                if (this.height != null && this.height.toString().indexOf("px") != -1) {
                    this.element.style.height = parseInt(this.height) - borderSize + 'px';
                }
                else if (this.height != undefined && !isNaN(this.height)) {
                    this.element.style.height = parseInt(this.height) - borderSize + 'px';
                };

                var isPercentage = false;
                if (this.width != null && this.width.toString().indexOf("%") != -1) {
                    isPercentage = true;
                    this.element.style.width = this.width;

                    if (borderSize > 0) {
                        this.host.css('box-sizing', 'border-box');
                    }
                }

                if (this.height != null && this.height.toString().indexOf("%") != -1) {
                    isPercentage = true;
                    this.element.style.height = this.height;
                }

                if (isPercentage) {
                    var that = this;
                    var width = this.host.width();
                    if (this.dropDownWidth != 'auto') {
                        width = this.dropDownWidth;
                    }
                    this.listBoxContainer.jqxListBox({ width: width });
                    this.container.width(parseInt(width) + 25);
                    this._arrange();
                }
                var that = this;

                var resizeFunc = function () {
                    if (that.multiSelect) {
                        that.host.height(that.height);
                    }

                    that._arrange();
                    if (that.multiSelect) {
                        that.host.height('auto');
                    }
                }

                that.oldWidth = that.host.width();
                that.oldHeight = that.host.height();
                $.jqx.utilities.resize(this.host, function () {
                    var w = that.host.width();
                    var h = that.host.height();

                    if (w != that.oldWidth || h != that.oldHeight) {
                        resizeFunc();
                        that.hideListBox('api');
                    }

                    that.oldWidth = w;
                    that.oldHeight = h;
                });
            },

            // returns true when the listbox is opened, otherwise returns false.
            isOpened: function () {
                var that = this;
                var openedListBox = $.data(document.body, "openedCombojqxListBox" + this.element.id);

                if (this.container.css('display') != 'block')
                    return false;

                if (openedListBox != null && openedListBox == that.listBoxContainer) {
                    return true;
                }

                return false;
            },

            _updateHandlers: function () {
                var that = this;
                var hovered = false;
                this.removeHandlers();

                if (this.multiSelect) {
                    this.addHandler(this.dropdownlistContent, 'click', function (event) {
                        if (event.target.href) return false;

                        that.input.focus();
                        setTimeout(function () {
                            that.input.focus();
                        }, 10);
                    });
                    this.addHandler(this.dropdownlistContent, 'focus', function (event) {
                        if (event.target.href) return false;

                        that.input.focus();
                        setTimeout(function () {
                            that.input.focus();
                        }, 10);
                    });
                }

                if (!this.touch) {
                    if (this.host.parents()) {
                        this.addHandler(this.host.parents(), 'scroll.combobox' + this.element.id, function (event) {
                            var opened = that.isOpened();
                            if (opened) {
                                that.close();
                            }
                        });
                    }

                    this.addHandler(this.host, 'mouseenter', function () {
                        if (!that.disabled && that.enableHover) {
                            hovered = true;
                            that.host.addClass(that.toThemeProperty('jqx-combobox-state-hover'));
                            if (that.dropDownVerticalAlignment == "top") {
                                that.dropdownlistArrowIcon.addClass(that.toThemeProperty('jqx-icon-arrow-up'));
                            }
                            else {
                                that.dropdownlistArrowIcon.addClass(that.toThemeProperty('jqx-icon-arrow-down-hover'));
                            }
                            that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-combobox-arrow-hover'));
                            that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-fill-state-hover'));
                        }
                    });
                    this.addHandler(this.host, 'mouseleave', function () {
                        if (!that.disabled && that.enableHover) {
                            that.host.removeClass(that.toThemeProperty('jqx-combobox-state-hover'));
                            that.dropdownlistArrowIcon.removeClass(that.toThemeProperty('jqx-icon-arrow-down-hover'));
                            that.dropdownlistArrowIcon.removeClass(that.toThemeProperty('jqx-icon-arrow-up-hover'));
                            that.dropdownlistArrow.removeClass(that.toThemeProperty('jqx-combobox-arrow-hover'));
                            that.dropdownlistArrow.removeClass(that.toThemeProperty('jqx-fill-state-hover'));
                            hovered = false;
                        }
                    });
                }

                if (that.autoOpen) {
                    this.addHandler(this.host, 'mouseenter', function () {
                        var isOpened = that.isOpened();
                        if (!isOpened && that.autoOpen) {
                            that.open();
                            that.host.focus();
                        }
                    });

                    this.addHandler($(document), 'mousemove.' + that.id, function (event) {
                        var isOpened = that.isOpened();
                        if (isOpened && that.autoOpen) {
                            var offset = that.host.coord();
                            var top = offset.top;
                            var left = offset.left;
                            var popupOffset = that.container.coord();
                            var popupLeft = popupOffset.left;
                            var popupTop = popupOffset.top;

                            var canClose = true;

                            if (event.pageY >= top && event.pageY <= top + that.host.height() + 2) {
                                if (event.pageX >= left && event.pageX < left + that.host.width())
                                    canClose = false;
                            }
                            if (event.pageY >= popupTop && event.pageY <= popupTop + that.container.height() - 20) {
                                if (event.pageX >= popupLeft && event.pageX < popupLeft + that.container.width())
                                    canClose = false;
                            }

                            if (canClose) {
                                that.close();
                            }
                        }
                    });
                }

                var eventName = 'mousedown';
                if (this.touch) eventName = $.jqx.mobile.getTouchEventName('touchstart');

                var dropDownButtonClicked = function (event) {
                    if (!that.disabled) {
                        var isOpen = that.container.css('display') == 'block';
                        if (!that.isanimating) {
                            if (isOpen) {
                                that.hideListBox('api');
                                if (!$.jqx.mobile.isTouchDevice()) {
                                    that.input.focus();
                                    setTimeout(function () {
                                        that.input.focus();
                                    }, 10);
                                }
                                return true;
                            }
                            else {
                                if (that.autoDropDownHeight) {
                                    that.container.height(that.listBoxContainer.height() + 25);
                                    var autoheight = that.listBoxContainer.jqxListBox('autoHeight');
                                    if (!autoheight) {
                                        that.listBoxContainer.jqxListBox({ autoHeight: that.autoDropDownHeight })
                                        that.listBox._arrange();
                                        that.listBox.ensureVisible(0);
                                        that.listBox._renderItems();
                                        that.container.height(that.listBoxContainer.height() + 25);
                                    }
                                }
                                that.showListBox('api');
                                if (!$.jqx.mobile.isTouchDevice()) {
                                    setTimeout(function () {
                                        that.input.focus();
                                    }, 10);
                                }
                                else {
                                    return true;
                                }
                            }
                        }
                    }
                }

                this.addHandler(this.dropdownlistArrow, eventName,
                    function (event) {
                        dropDownButtonClicked(event);
                        //       return false;
                    });
                this.addHandler(this.dropdownlistArrowIcon, eventName,
                    function (event) {

                        //   dropDownButtonClicked(event);
                        //     return false;
                    });

                this.addHandler(this.host, 'focus', function () {
                    that.focus();
                });

                this.addHandler(this.input, 'focus', function (event) {
                    that.focused = true;
                    that.host.addClass(that.toThemeProperty('jqx-combobox-state-focus'));
                    that.host.addClass(that.toThemeProperty('jqx-fill-state-focus'));
                    that.bar.addClass('focused');
                    that.label.addClass('focused');

                    that.dropdownlistContent.addClass(that.toThemeProperty('jqx-combobox-content-focus'));
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }

                });
                this.addHandler(this.input, 'blur', function () {
                    that.focused = false;
                    that.bar.removeClass('focused');
                    that.label.removeClass('focused');

                    if (!that.isOpened() && !that.opening) {
                        if (that.selectionMode == "dropDownList") {
                            that._selectOldValue();
                        }

                        that.host.removeClass(that.toThemeProperty('jqx-combobox-state-focus'));
                        that.host.removeClass(that.toThemeProperty('jqx-fill-state-focus'));
                        that.dropdownlistContent.removeClass(that.toThemeProperty('jqx-combobox-content-focus'));
                    }
                    if (that._searchTimer) clearTimeout(that._searchTimer);
                });
                this.addHandler($(document), 'mousedown.' + this.id, that.closeOpenedListBox, { that: this, listbox: this.listBox, id: this.id });
                if (this.touch) {
                    this.addHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.' + this.id, that.closeOpenedListBox, { that: this, listbox: this.listBox, id: this.id });
                }

                this.addHandler(this.host, 'keydown', function (event) {
                    var isOpen = that.container.css('display') == 'block';
                    that.ctrlKey = event.ctrlKey;
                    if (that.host.css('display') == 'none') {
                        return true;
                    }

                    if (event.keyCode == '13' || event.keyCode == '9') {
                        if (isOpen && !that.isanimating) {
                            if (that.listBox.selectedIndex != -1) {
                                that.renderSelection('mouse');
                                var index = that.listBox.selectedIndex;
                                var item = that.listBox.getVisibleItem(index);
                                if (item) {
                                    that.listBox.selectedValue = item.value;
                                }
                                that._setSelection(that.input.val().length, that.input.val().length);
                                that.hideListBox('keyboard');
                            }
                            if (event.keyCode == '13') {
                                that._oldvalue = that.listBox.selectedValue;
                            }
                            if (!that.keyboardSelection) {
                                that._raiseEvent('2', { index: that.selectedIndex, type: 'keyboard', item: that.getItem(that.selectedIndex) });
                            }

                            if (event.keyCode == '9') return true;
                            return false;
                        }
                    }

                    if (event.keyCode == 115) {
                        if (!that.isanimating) {
                            if (!that.isOpened()) {
                                that.showListBox('keyboard');
                            }
                            else if (that.isOpened()) {
                                that.hideListBox('keyboard');
                            }
                        }
                        return false;
                    }

                    if (event.altKey) {
                        if (that.host.css('display') == 'block') {
                            if (!that.isanimating) {
                                if (event.keyCode == 38) {
                                    if (that.isOpened()) {
                                        that.hideListBox('altKey');
                                    }
                                }
                                else if (event.keyCode == 40) {
                                    if (!that.isOpened()) {
                                        that.showListBox('altKey');
                                    }
                                }
                            }
                        }
                    }

                    if (event.keyCode == '27' || event.keyCode == '9') {
                        if (that.isOpened() && !that.isanimating) {

                            if (event.keyCode == '27') {
                                if (!that.multiSelect) {
                                    var item = that.listBox.getItemByValue(that._oldvalue);
                                    if (item) {
                                        setTimeout(
                                            function () {
                                                if (that.autoComplete) {
                                                    that._updateItemsVisibility("");
                                                }
                                                that.listBox.selectIndex(item.index);
                                                that.renderSelection('api');
                                            }, that.closeDelay);
                                    }
                                    else {
                                        that.clearSelection();
                                    }
                                }
                                else {
                                    that.listBox.selectedValue = null;
                                    that.input.val("");
                                }
                            }
                            that.hideListBox('keyboard');


                            if (event.keyCode == '9')
                                return true;

                            that.renderSelection('api');
                            event.preventDefault();

                            return false;
                        }
                    }

                    var key = event.keyCode;

                    if (isOpen && !that.disabled && key != 8) {
                        return that.listBox._handleKeyDown(event);
                    }
                    else if (!that.disabled && !isOpen) {
                        var key = event.keyCode;
                        // arrow keys.
                        if (key == 33 || key == 34 || key == 35 || key == 36 || key == 38 || key == 40) {
                            return that.listBox._handleKeyDown(event);
                        }
                    }
                    if (key === 8 && that.multiSelect) {
                        if (that.input.val().length === 0) {
                            var lastItem = that.selectedItems[that.selectedItems.length - 1];
                            that.selectedItems.pop();
                            that._selectedItems.pop();
                            if (lastItem) {
                                that._raiseEvent('3', { index: lastItem.index, type: 'keyboard', item: lastItem });
                                that._raiseEvent('4', { index: lastItem.index, type: 'keyboard', item: lastItem });
                            }

                            that.listBox.selectedValue = null;
                            that.doMultiSelect();
                            return false;
                        }
                    }


                    if (that.isMaterialized() && that.hint) {
                        setTimeout(function () {
                            if (that.input[0].value.length === 0) {
                                that.element.removeAttribute('hint');
                                that.label[0].innerHTML = that.placeHolder;
                            }
                            else if (that.hint) {
                                that.element.setAttribute('hint', true);
                            }
                        });
                    }
                });

                this.addHandler(this.listBoxContainer, 'checkChange', function (event) {
                    that.renderSelection('mouse');
                    that._updateInputSelection();
                    that._raiseEvent(5, { label: event.args.label, value: event.args.value, checked: event.args.checked, item: event.args.item });
                });

                this.addHandler(this.listBoxContainer, 'select', function (event) {
                    if (!that.disabled) {
                        if (event.args.type != 'keyboard' || that.keyboardSelection) {
                            that.renderSelection(event.args.type);
                            if (!that.multiSelect) {
                                that._raiseEvent('2', { index: event.args.index, type: event.args.type, item: event.args.item });
                            }
                            if (event.args.type == 'mouse') {
                                that._oldvalue = that.listBox.selectedValue;

                                if (!that.checkboxes) {
                                    that.hideListBox('mouse');
                                    if (!that.touch) {
                                        that.input.focus();
                                    }
                                    else {
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                });
                if (this.listBox != null && this.listBox.content != null) {
                    this.addHandler(this.listBox.content, 'click', function (event) {
                        if (!that.disabled) {
                            if (that.listBox.itemswrapper) {
                                if (event.target === that.listBox.itemswrapper[0])
                                    return true;
                            }

                            if (event.target && event.target.className) {
                                if (event.target.className.indexOf('jqx-fill-state-disabled') >= 0) {
                                    return true;
                                }
                            }

                            that.renderSelection('mouse');
                            that._oldvalue = that.listBox.selectedValue;
                            if (!that.touch && !that.ishiding) {
                                if (!that.checkboxes) {
                                    that.hideListBox('mouse');
                                    that.input.focus();
                                }
                            }
                            if (that.touch === true) {
                                if (!that.checkboxes) {
                                    that.hideListBox('mouse');
                                }
                            }
                        }
                    });
                }
            },

            _selectOldValue: function () {
                var that = this;
                if (that.listBox.selectedIndex == -1) {
                    if (!that.multiSelect) {
                        var item = that.listBox.getItemByValue(that._oldvalue);
                        if (item) {
                            setTimeout(
                                function () {
                                    if (that.autoComplete) {
                                        that._updateItemsVisibility("");
                                    }
                                    that.listBox.selectIndex(item.index);
                                    that.renderSelection('api');
                                }, that.closeDelay);
                        }
                        else {
                            that.clearSelection();
                            that.listBox.selectIndex(0);
                            that.renderSelection('api');
                        }
                    }
                    else {
                        that.listBox.selectedValue = null;
                        that.input.val("");
                    }
                }
                else {
                    that.renderSelection('api');
                }
            },

            removeHandlers: function () {
                var that = this;
                if (this.dropdownlistWrapper != null) {
                    this.removeHandler(this.dropdownlistWrapper, 'mousedown');
                }

                if (this.dropdownlistContent) {
                    this.removeHandler(this.dropdownlistContent, 'click');
                    this.removeHandler(this.dropdownlistContent, 'focus');
                }
                this.removeHandler(this.host, 'keydown');
                this.removeHandler(this.host, 'focus');
                if (this.input != null) {
                    this.removeHandler(this.input, 'focus');
                    this.removeHandler(this.input, 'blur');
                }
                this.removeHandler(this.host, 'mouseenter');
                this.removeHandler(this.host, 'mouseleave');
                this.removeHandler($(document), 'mousemove.' + that.id);
                if (this.listBoxContainer) {
                    this.removeHandler(this.listBoxContainer, 'checkChange');
                    this.removeHandler(this.listBoxContainer, 'select');
                }
                if (this.host.parents()) {
                    this.removeHandler(this.host.parents(), 'scroll.combobox' + this.element.id);
                }
                if (this.dropdownlistArrowIcon && this.dropdownlistArrow) {
                    var eventName = 'mousedown';
                    if (this.touch) eventName = $.jqx.mobile.getTouchEventName('touchstart');
                    this.removeHandler(this.dropdownlistArrowIcon, eventName);
                    this.removeHandler(this.dropdownlistArrow, eventName);
                }
            },

            // gets an item by index.
            getItem: function (index) {
                var item = this.listBox.getItem(index);
                return item;
            },

            getItemByValue: function (value) {
                var item = this.listBox.getItemByValue(value);
                return item;
            },

            getVisibleItem: function (index) {
                var item = this.listBox.getVisibleItem(index);
                return item;
            },

            // renders the selection.
            renderSelection: function (type) {
                if (type == undefined || type == 'none') {
                    return;
                }

                if (this._disableSelection === true)
                    return;

                if (this.listBox == null)
                    return;

                if (this.multiSelect) {
                    return;
                }
                var item = this.listBox.visibleItems[this.listBox.selectedIndex];

                if (this.autoComplete && !this.checkboxes) {
                    if (this.listBox.selectedValue !== undefined) {
                        var item = this.getItemByValue(this.listBox.selectedValue);
                    }
                }

                if (this.checkboxes) {
                    var checkedItems = this.getCheckedItems();
                    if (checkedItems != null && checkedItems.length > 0) {
                        item = checkedItems[0];
                    }
                    else item = null;
                }

                if (this.hint) {
                    this.label[0].innerHTML = this.placeHolder;
                }

                if (item != null) {
                    if (this.hint) {
                        this.element.setAttribute('hint', true);
                    }
                }
                else {
                    this.element.removeAttribute('hint');
                }

                this.bar.css('top', this.host.height());

                if (item == null) {
                    var ie7 = $.jqx.browser.msie && $.jqx.browser.version < 8;
                    this.input.val("");
                    this.input.attr('value', '');
                    if (!ie7) {
                        if (this.isMaterialized()) {
                            this.label[0].innerHTML = this.placeHolder;
                            this.input.removeAttr('placeholder');
                        }
                        else {
                            this.input.attr('placeholder', this.placeHolder);
                        }
                    }
                    this._updateInputSelection();
                    return;
                }

                this.selectedIndex = this.listBox.selectedIndex;
                var spanElement = $('<span></span>');

                if (item.label != undefined && item.label != null && item.label.toString().length > 0) {
                    $.jqx.utilities.html(spanElement, item.label);
                }
                else if (item.value != undefined && item.value != null && item.value.toString().length > 0) {
                    $.jqx.utilities.html(spanElement, item.value);
                }
                else if (item.title != undefined && item.title != null && item.title.toString().length > 0) {
                    $.jqx.utilities.html(spanElement, item.title);
                }
                else {
                    $.jqx.utilities.html(spanElement, this.emptyString);
                }
                var spanHeight = spanElement.outerHeight();
                if (this.checkboxes) {
                    var items = this.getCheckedItems();
                    var str = "";
                    for (var i = 0; i < items.length; i++) {
                        if (i == items.length - 1) {
                            str += items[i].label;
                        }
                        else {
                            str += items[i].label + ", ";
                        }
                    }
                    this.input.val(str);
                }
                else {
                    this.input.val(spanElement.text());
                }
                spanElement.remove();
                this._updateInputSelection();
                if (this.renderSelectedItem) {
                    var result = this.renderSelectedItem(this.listBox.selectedIndex, item);
                    if (result != undefined) {
                        this.input[0].value = result;
                    }
                }
                this.input.attr('value', this.input.val());
                if (this.listBox && this.listBox._activeElement) {
                    $.jqx.aria(this, "aria-activedescendant", this.listBox._activeElement.id);
                }
            },

            dataBind: function () {
                this.listBoxContainer.jqxListBox({ source: this.source });
                this.renderSelection('mouse');
                if (this.source == null) {
                    this.clearSelection();
                }
            },

            clear: function () {
                this.listBoxContainer.jqxListBox({ source: null });
                this.clearSelection();
            },

            // clears the selection.
            clearSelection: function (render) {
                this.selectedIndex = -1;
                this.listBox.clearSelection();
                this.input.val("");
                if (this.multiSelect) {
                    this.listBox.selectedValue = "";
                    this.selectedItems = new Array();
                    this._selectedItems = new Array();
                    this.doMultiSelect(false);
                }
            },

            // unselects an item at specific index.
            // @param Number
            unselectIndex: function (index, render) {
                if (isNaN(index))
                    return;

                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                this.listBox.unselectIndex(index, render);
                this.renderSelection('mouse');
                if (this.multiSelect) {
                    if (index >= 0) {
                        var multiItem = this.getItem(index);

                        var indx = this.selectedItems.indexOf(multiItem.value);
                        if (indx >= 0) {
                            if (multiItem.value === this.listBox.selectedValue) {
                                this.listBox.selectedValue = null;
                            }

                            this.selectedItems.splice(indx, 1);
                            this._selectedItems.splice(indx, 1);
                        }
                    }
                    this.doMultiSelect(false);
                }
            },

            // selects an item at specific index.
            // @param Number
            selectIndex: function (index, ensureVisible, render, forceSelect) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                this.listBox.selectIndex(index, ensureVisible, render, forceSelect);
                this.renderSelection('mouse');
                this.selectedIndex = index;
                if (this.multiSelect) {
                    this.doMultiSelect();
                }
            },

            selectItem: function (item) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                if (this.listBox != undefined) {
                    this.listBox.selectedIndex = -1;
                    this.listBox.selectItem(item);
                    this.selectedIndex = this.listBox.selectedIndex;
                    this.renderSelection('mouse');
                    if (this.multiSelect) {
                        this.doMultiSelect(false);
                    }
                }
            },

            unselectItem: function (item) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                if (this.listBox != undefined) {
                    this.listBox.unselectItem(item);
                    this.renderSelection('mouse');
                    if (this.multiSelect) {
                        var multiItem = this.getItemByValue(item);
                        if (multiItem) {
                            var index = this.selectedItems.indexOf(multiItem.value);
                            if (index >= 0) {
                                if (multiItem.value === this.listBox.selectedValue) {
                                    this.listBox.selectedValue = null;
                                }

                                this.selectedItems.splice(index, 1);
                                this._selectedItems.splice(index, 1);
                            }
                        }

                        this.doMultiSelect(false);
                    }
                }
            },

            checkItem: function (item) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                if (this.listBox != undefined) {
                    this.listBox.checkItem(item);
                }
            },

            uncheckItem: function (item) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                if (this.listBox != undefined) {
                    this.listBox.uncheckItem(item);
                }
            },

            indeterminateItem: function (item) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                if (this.listBox != undefined) {
                    this.listBox.indeterminateItem(item);
                }
            },

            getSelectedValue: function () {
                return this.listBox.selectedValue;
            },

            // gets the selected index.
            getSelectedIndex: function () {
                if (!this.multiSelect) {
                    return this.listBox.selectedIndex;
                }
                else {
                    if (this.remoteAutoComplete && this.multiSelect && this._selectedItems.length > 0)
                        return this.getSelectedItems()[0].index;

                    if (this._selectedItems && this._selectedItems.length > 0) {
                        return this.getSelectedItems()[0].index;
                    }
                }
            },

            // gets the selected item.
            getSelectedItem: function () {
                if (!this.multiSelect) {
                    return this.getVisibleItem(this.listBox.selectedIndex);
                }
                else {
                    if (this.remoteAutoComplete && this.multiSelect && this._selectedItems.length > 0)
                        return this.getSelectedItems()[0];

                    if (this._selectedItems && this._selectedItems.length > 0) {
                        return this.getSelectedItems()[0];
                    }
                    return null;
                }
            },

            // gets the selected items when multiselect is enabled.
            getSelectedItems: function () {
                if (this.remoteAutoComplete && this.multiSelect)
                    return this._selectedItems;

                var array = new Array();
                var that = this;
                $.each(this.selectedItems, function () {
                    var item = that.getItemByValue(this);
                    if (item) {
                        array.push(item);
                    }
                    else {
                        var item = that._selectedItems[this];
                        if (item) {
                            array.push(item);
                        }
                    }
                });
                return array;
            },

            getCheckedItems: function () {
                return this.listBox.getCheckedItems();
            },

            checkIndex: function (index) {
                this.listBox.checkIndex(index);
            },

            uncheckIndex: function (index) {
                this.listBox.uncheckIndex(index);
            },

            indeterminateIndex: function (index) {
                this.listBox.indeterminateIndex(index);
            },
            checkAll: function () {
                this.listBox.checkAll();
                this.renderSelection("mouse");
            },

            uncheckAll: function () {
                this.listBox.uncheckAll();
                this.renderSelection("mouse");
            },

            insertAt: function (item, index) {
                if (item == null)
                    return false;

                return this.listBox.insertAt(item, index);
            },

            addItem: function (item) {
                return this.listBox.addItem(item);
            },

            removeAt: function (index) {
                var result = this.listBox.removeAt(index);
                this.renderSelection('mouse');
                return result;
            },

            removeItem: function (item) {
                var result = this.listBox.removeItem(item);
                this.renderSelection('mouse');
                return result;
            },

            updateItem: function (item, oldItem) {
                var result = this.listBox.updateItem(item, oldItem);
                this.renderSelection('mouse');
                return result;
            },

            updateAt: function (item, index) {
                var result = this.listBox.updateAt(item, index);
                this.renderSelection('mouse');
                return result;
            },

            ensureVisible: function (index) {
                return this.listBox.ensureVisible(index);
            },

            disableAt: function (index) {
                var item = this.getVisibleItem(index);
                if (item) {
                    this._disabledItems.push(item.value);
                }
                return this.listBox.disableAt(index);
            },

            enableAt: function (index) {
                var item = this.getVisibleItem(index);
                if (item) {
                    this._disabledItems.splice(this._disabledItems.indexOf(item.value), 1);
                }
                return this.listBox.enableAt(index);
            },

            disableItem: function (item) {
                var item = this.getVisibleItem(item);
                if (item) {
                    this._disabledItems.push(item.value);
                }
                return this.listBox.disableItem(item);
            },

            enableItem: function (item) {
                var item = this.getVisibleItem(item);
                if (item) {
                    this._disabledItems.splice(this._disabledItems.indexOf(item.value), 1);
                }
                return this.listBox.enableItem(item);
            },

            _findPos: function (obj) {
                while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
                    obj = obj['nextSibling'];
                }
                if (obj) {
                    var position = $(obj).coord(true);
                    return [position.left, position.top];
                }
            },

            testOffset: function (element, offset, inputHeight) {
                var dpWidth = element.outerWidth();
                var dpHeight = element.outerHeight();
                var viewWidth = $(window).width() + $(window).scrollLeft();
                var viewHeight = $(window).height() + $(window).scrollTop();

                if (offset.left + dpWidth > viewWidth) {
                    if (dpWidth > this.host.width()) {
                        var hostLeft = this.host.coord().left;
                        var hOffset = dpWidth - this.host.width();
                        offset.left = hostLeft - hOffset + 2;
                    }
                }
                if (offset.left < 0) {
                    offset.left = parseInt(this.host.coord().left) + 'px'
                }

                offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                    Math.abs(dpHeight + inputHeight + 23) : 0);

                return offset;
            },

            open: function () {
                if (!this.isOpened() && !this.opening) {
                    this.showListBox('api');
                }
            },

            close: function () {
                if (this.isOpened()) {
                    this.hideListBox('api');
                }
            },

            _getBodyOffset: function () {
                var top = 0;
                var left = 0;
                if ($('body').css('border-top-width') != '0px') {
                    top = parseInt($('body').css('border-top-width'));
                    if (isNaN(top)) top = 0;
                }
                if ($('body').css('border-left-width') != '0px') {
                    left = parseInt($('body').css('border-left-width'));
                    if (isNaN(left)) left = 0;
                }
                return { left: left, top: top };
            },

            // shows the listbox.
            showListBox: function (mode) {
                if (this.listBox.items && this.listBox.items.length == 0)
                    return;

                if (mode == "search" && !this.autoComplete && !this.remoteAutoComplete) {
                    if (this.autoDropDownHeight) {
                        this.container.height(this.listBoxContainer.height() + 25);
                    }
                }
                this.element.setAttribute('opened', true);

                if (this.autoComplete || this.multiSelect && !this.remoteAutoComplete) {
                    if (mode != 'search') {
                        this._updateItemsVisibility("");

                        if (this.multiSelect) {
                            var visibleItems = this.getVisibleItems();
                            for (var i = 0; i < visibleItems.length; i++) {
                                if (!visibleItems[i].disabled) {
                                    this.ensureVisible(i);
                                    break;
                                }
                            }
                        }
                    }
                }
                if (this.remoteAutoComplete) {
                    this.listBox.clearSelection();
                }

                if (mode != 'search') {
                    this._oldvalue = this.listBox.selectedValue;
                }

                $.jqx.aria(this, "aria-expanded", true);

                if (this.dropDownWidth == 'auto' && this.width != null && this.width.indexOf && this.width.indexOf('%') != -1) {
                    if (this.listBox.host.width() != this.host.width()) {
                        var width = this.element.offsetWidth;
                        this.listBoxContainer.jqxListBox({ width: width });
                        this.listBoxContainer[0].style.width = width + "px";
                        this.container.width(parseInt(width) + 25);
                    }
                }
                if (this.dropDownWidth == 'auto' && this.host.css('border-left-width') === "0px") {
                    var width = this.element.offsetWidth;
                    this.listBoxContainer.jqxListBox({ width: width + 1 });
                    this.container.width(parseInt(width) + 25);
                }


                var that = this;
                var listBox = this.listBoxContainer;
                var listBoxInstance = this.listBox;
                var scrollPosition = $(window).scrollTop();
                var scrollLeftPosition = $(window).scrollLeft();
                var top = parseInt(this._findPos(this.host[0])[1]) + parseInt(this.host.outerHeight()) - 1 + 'px';
                var left, leftPos = parseInt(Math.round(this.host.coord(true).left));
                left = leftPos + 'px';
                if (this.dropDownContainer === 'element') {
                    top = parseInt(this.host.outerHeight()) - 1 + 'px';
                    left = 0;
                }
                var isMobileBrowser = $.jqx.mobile.isSafariMobileBrowser() || $.jqx.mobile.isWindowsPhone();
                this.ishiding = false;

                var hasTransform = $.jqx.utilities.hasTransform(this.host);

                if (hasTransform || (isMobileBrowser != null && isMobileBrowser)) {
                    left = $.jqx.mobile.getLeftPos(this.element);
                    top = $.jqx.mobile.getTopPos(this.element) + parseInt(this.host.outerHeight());
                    if ($('body').css('border-top-width') != '0px') {
                        top = parseInt(top) - this._getBodyOffset().top + 'px';
                    }
                    if ($('body').css('border-left-width') != '0px') {
                        left = parseInt(left) - this._getBodyOffset().left + 'px';
                    }
                }

                this.host.addClass(this.toThemeProperty('jqx-combobox-state-selected'));
                if (this.dropDownVerticalAlignment == "top") {
                    this.dropdownlistArrowIcon.addClass(this.toThemeProperty('jqx-icon-arrow-up-selected'));
                }
                else {
                    this.dropdownlistArrowIcon.addClass(this.toThemeProperty('jqx-icon-arrow-down-selected'));
                }
                this.dropdownlistArrow.addClass(this.toThemeProperty('jqx-combobox-arrow-selected'));
                this.dropdownlistArrow.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this.host.addClass(this.toThemeProperty('jqx-combobox-state-focus'));
                this.host.addClass(this.toThemeProperty('jqx-fill-state-focus'));
                this.dropdownlistContent.addClass(this.toThemeProperty('jqx-combobox-content-focus'));

                this.container.css('left', left);
                this.container.css('top', top);
                listBoxInstance._arrange();

                var closeAfterSelection = true;

                var positionChanged = false;

                if (this.dropDownHorizontalAlignment == 'right' || this.rtl) {
                    var containerWidth = this.container.outerWidth();
                    var containerLeftOffset = Math.abs(containerWidth - this.host.width());

                    if (containerWidth > this.host.width()) {
                        this.container.css('left', 25 + parseInt(Math.round(leftPos)) - containerLeftOffset + "px");
                    }
                    else this.container.css('left', 25 + parseInt(Math.round(leftPos)) + containerLeftOffset + "px");
                }

                if (this.dropDownVerticalAlignment == "top") {
                    var dpHeight = listBox.height();
                    positionChanged = true;

                    listBox.css('top', 23);
                    listBox.addClass(this.toThemeProperty('jqx-popup-up'));
                    var inputHeight = parseInt(this.host.outerHeight());
                    var t = parseInt(top) - Math.abs(dpHeight + inputHeight + 23);

                    this.container.css('top', t);
                }

                if (this.enableBrowserBoundsDetection) {
                    var newOffset = this.testOffset(listBox, { left: parseInt(this.container.css('left')), top: parseInt(top) }, parseInt(this.host.outerHeight()));
                    if (parseInt(this.container.css('top')) != newOffset.top) {
                        positionChanged = true;
                        listBox.css('top', 23);
                        listBox.addClass(this.toThemeProperty('jqx-popup-up'));
                    }
                    else listBox.css('top', 0);

                    this.container.css('top', newOffset.top);
                    this.container.css('top', newOffset.top);
                    if (parseInt(this.container.css('left')) != newOffset.left) {
                        this.container.css('left', newOffset.left);
                    }
                }

                if (this.animationType == 'none' || this.animationType === 'transform') {
                    this.container.css('display', 'block');
                    $.data(document.body, "openedCombojqxListBoxParent", that);
                    $.data(document.body, "openedCombojqxListBox" + that.element.id, listBox);
                    listBox.css('margin-top', 0);
                    listBox.css('opacity', 1);
                }
                else {
                    this.container.css('display', 'block');
                    var height = listBox.outerHeight();
                    listBox.stop();
                    if (this.animationType == 'fade') {
                        listBox.css('margin-top', 0);
                        listBox.css('opacity', 0);
                        listBox.animate({ 'opacity': 1 }, this.openDelay, function () {
                            that.isanimating = false;
                            that.opening = false;
                            $.data(document.body, "openedCombojqxListBoxParent", that);
                            $.data(document.body, "openedCombojqxListBox" + that.element.id, listBox);
                        });
                    }
                    else {
                        listBox.css('opacity', 1);
                        if (positionChanged) {
                            listBox.css('margin-top', height);
                        }
                        else {
                            listBox.css('margin-top', -height);
                        }
                        this.isanimating = true;
                        this.opening = true;
                        listBox.animate({ 'margin-top': 0 }, this.openDelay, function () {
                            that.isanimating = false;
                            that.opening = false;
                            $.data(document.body, "openedCombojqxListBoxParent", that);
                            $.data(document.body, "openedCombojqxListBox" + that.element.id, listBox);
                        });
                    }
                }
                listBoxInstance._renderItems();
                if (!positionChanged) {
                    this.host.addClass(this.toThemeProperty('jqx-rc-b-expanded'));
                    listBox.addClass(this.toThemeProperty('jqx-rc-t-expanded'));
                    this.dropdownlistArrow.addClass(this.toThemeProperty('jqx-rc-b-expanded'));
                }
                else {
                    this.host.addClass(this.toThemeProperty('jqx-rc-t-expanded'));
                    listBox.addClass(this.toThemeProperty('jqx-rc-b-expanded'));
                    this.dropdownlistArrow.addClass(this.toThemeProperty('jqx-rc-t-expanded'));
                }
                listBox.addClass(this.toThemeProperty('jqx-fill-state-focus'));

                this._raiseEvent('0', listBoxInstance);
                listBox.addClass(this.toThemeProperty('jqx-popup-show'));
            },

            doMultiSelect: function (setFocus) {
                if (this.checkboxes) {
                    this.multiSelect = false;
                }

                var that = this;
                if (!this.multiSelect) {
                    var buttons = that.dropdownlistContent.find('.jqx-button');
                    var eventName = 'mousedown';
                    if (this.touch) {
                        eventName = $.jqx.mobile.getTouchEventName('touchstart');
                    }
                    this.removeHandler(buttons, eventName);
                    this.removeHandler(buttons.find('.jqx-icon-close'), eventName);
                    buttons.remove();
                    var items = this.listBox.items;
                    if (!items) return;
                    for (var i = 0; i < items.length; i++) {
                        items[i].disabled = false;
                    }
                    this.listBox._renderItems();

                    this.selectedItems = new Array();
                    this._selectedItems = new Array();
                    return;
                }

                if (this.validateSelection) {
                    var result = this.validateSelection(this.listBox.selectedValue);
                    if (!result) {
                        return;
                    }
                }

                var oldItems = this.selectedItems;
                if (this.listBox.selectedValue) {
                    if (this.selectedItems.indexOf(this.listBox.selectedValue) === -1) {
                        var item = this.getItemByValue(this.listBox.selectedValue);
                        if (item && item.visible) {
                            this.selectedItems.push(this.listBox.selectedValue);
                            this._selectedItems.push(item);
                            this._raiseEvent('2', { index: item.index, item: item });
                            this._raiseEvent('4', { index: item.index, item: item });
                        }
                    }
                    this.listBox.selectedIndex = -1;
                }

                var items = this.listBox.items;
                if (!items) return;
                for (var i = 0; i < items.length; i++) {
                    items[i].disabled = false;
                    if (this.selectedItems.indexOf(items[i].value) >= 0 || this._disabledItems.indexOf(this.value) >= 0) {
                        items[i].disabled = true;
                    }
                }
                this.listBox._renderItems();

                this.searchString = "";
                this.input.val("");
                var items = "";
                var eventName = 'mousedown';

                var buttons = that.dropdownlistContent.find('.jqx-button');
                if (this.touch) {
                    eventName = $.jqx.mobile.getTouchEventName('touchstart');
                }
                this.removeHandler(buttons, eventName);
                this.removeHandler(buttons.find('.jqx-icon-close'), eventName);
                buttons.remove();

                that.input.detach();
                if (this.selectedItems.length > 0) {
                    that.input.css('width', '25px');
                    if (this.isMaterialized() && that.hint) {
                        that.label[0].innerHTML = this.placeHolder;
                    }
                    else {
                        that.input.attr('placeholder', "");
                    }
                }
                else {
                    that.input.css('width', '100%');
                    if (that.isMaterialized() && that.hint) {
                        that.label[0].innerHTML = this.placeHolder;
                    }
                    else {
                        that.input.attr('placeholder', this.placeHolder);
                    }
                }

                if (that.isMaterialized()) {
                    if (that.hint) {
                        setTimeout(function () {
                            if (that.selectedItems.length === 0) {
                                that.element.removeAttribute('hint');
                                that.label[0].innerHTML = that.placeHolder;
                            }
                            else {
                                if (that.hint) {
                                    that.element.setAttribute('hint', true);
                                }
                            }
                        });
                    }
                }

                $.each(this.selectedItems, function (index) {
                    var item = that.getItemByValue(this);
                    if (!item || that.remoteAutoComplete) {
                        item = that._selectedItems[index];
                    }

                    var group = $('<div style="overflow: hidden; float: left;"></div>');
                    group.addClass(that.toThemeProperty('jqx-button'));
                    group.addClass(that.toThemeProperty('jqx-combobox-multi-item'));
                    group.addClass(that.toThemeProperty('jqx-fill-state-normal'));
                    group.addClass(that.toThemeProperty('jqx-rc-all'));
                    if (item) {
                        var text = item.label;
                        if (that.renderSelectedItem) {
                            var result = that.renderSelectedItem(index, item);
                            if (result) text = result;
                        }

                        if (group[0].innerHTML == '') {
                            group[0].innerHTML = '<a data-value="' + item.value + '" style="float: left;" href="#">' + text + '</a>';
                        }
                        if (that.rtl) {
                            group[0].innerHTML = '<a data-value="' + item.value + '" style="float: right;" href="#">' + text + '</a>';
                        }
                        var fl = !that.rtl ? 'right' : 'left';

                        if (that.showCloseButtons) {
                            var closebutton = '<div style="position: relative; overflow: hidden; float: ' + fl + '; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 100%; top: 50%; margin-left: -18px; margin-top: -7px; float: none; width: 16px; height: 16px;" class="' + that.toThemeProperty('jqx-icon-close') + '"></div></div>';
                            if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                                closebutton = '<div style="position: relative; overflow: hidden; float: left; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 100%; top: 50%; margin-left: -18px; margin-top: -7px; float: none; width: 16px; height: 16px;" class="' + that.toThemeProperty('jqx-icon-close') + '"></div></div>';
                            }
                            if (that.rtl) {
                                var closebutton = '<div style="position: relative; overflow: hidden; float: ' + fl + '; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 0px; top: 50%; margin-top: -7px; float: none; width: 16px; height: 16px;" class="' + that.toThemeProperty('jqx-icon-close') + '"></div></div>';
                                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                                    closebutton = '<div style="position: relative; overflow: hidden; float: left; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 0px; top: 50%; margin-top: -7px; float: none; width: 16px; height: 16px;" class="' + that.toThemeProperty('jqx-icon-close') + '"></div></div>';
                                }
                            }

                            group[0].innerHTML += closebutton;
                        }
                    }
                    else {
                        if (group[0].innerHTML == '') {
                            group[0].innerHTML = '<a href="#"></a>';
                        }
                    }
                    that.dropdownlistContent.append(group);
                });
                that.dropdownlistContent.append(that.input);
                that.input.val("");
                if (setFocus !== false) {
                    that.input.focus();
                    setTimeout(function () {
                        that.input.focus();
                    }, 10);
                }
                var buttons = that.dropdownlistContent.find('.jqx-button');

                if (this.touchMode === true) eventName = "mousedown";
                this.addHandler(buttons, eventName, function (event) {
                    if (event.target.className.indexOf('jqx-icon-close') >= 0)
                        return true;

                    if (that.disabled) {
                        return true;
                    }

                    var text = $(event.target).attr('data-value');
                    var item = that.getItemByValue(text);
                    if (item) {
                        that.listBox.selectedValue = null;
                        that.listBox.clearSelection();
                    }
                    that.listBox.scrollTo(0, 0);
                    that.open();
                    if (event.preventDefault) {
                        event.preventDefault();
                    }
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    return false;
                });
                this.addHandler(buttons.find('.jqx-icon-close'), eventName, function (event) {
                    if (that.disabled) {
                        return;
                    }

                    var text = $(event.target).parent().parent().find('a').attr('data-value');
                    var item = that.getItemByValue(text);
                    if (item || (that.remoteAutoComplete && !item && that.selectedItems.indexOf(text) >= 0)) {
                        that.listBox.selectedValue = null;
                        var index = that.selectedItems.indexOf(text);
                        var indx = item && item.index >= 0 ? item.index : index;
                        if (index >= 0) {
                            that.selectedItems.splice(index, 1);
                            var selectedItem = that._selectedItems[index];
                            if (!selectedItem) {
                                selectedItem = item;
                            }
                            that._selectedItems.splice(index, 1);

                            that._raiseEvent('3', { index: indx, type: 'mouse', item: selectedItem });
                            that._raiseEvent('4', { index: indx, type: 'mouse', item: selectedItem });
                            that.doMultiSelect();
                        }
                        else {
                            for (var i = 0; i < that.selectedItems.length; i++) {
                                var selectedItem = that.selectedItems[i];
                                if (selectedItem == text) {
                                    that.selectedItems.splice(i, 1);
                                    that._selectedItems.splice(i, 1);
                                    that._raiseEvent('3', { index: indx, type: 'mouse', item: item });
                                    that._raiseEvent('4', { index: indx, type: 'mouse', item: item });
                                    that.doMultiSelect();
                                    break;
                                }
                            }
                        }
                    }
                });

                if (this.isMaterialized()) {
                    this.host.height(this.dropdownlistContent.height());
                }

                this.bar.css('top', this.host.height());
                that.dropdownlistArrow.height(this.host.height());
                that._updateInputSelection();
            },

            // hides the listbox.
            hideListBox: function (mode) {
                var listBox = this.listBoxContainer;
                var listBoxInstance = this.listBox;
                var container = this.container;
                if (this.container[0].style.display == 'none')
                    return;

                this.element.setAttribute('opened', false);

                $.jqx.aria(this, "aria-expanded", false);

                if (mode == "keyboard" || mode == "mouse") {
                    this.listBox.searchString = "";
                }
                listBox.removeClass('jqx-popup-show');

                if (mode == "keyboard" || mode == "mouse" && this.multiSelect) {
                    this.doMultiSelect();
                }

                var that = this;
                $.data(document.body, "openedCombojqxListBox" + this.element.id, null);
                if (this.animationType == 'none') {
                    this.opening = false;
                    this.container.css('display', 'none');
                }
                else if (this.animationType === 'transform') {
                    setTimeout(function () {
                        container.css('display', 'none');
                    }, this.closeDelay);
                }
                else {
                    if (!this.ishiding) {
                        var height = listBox.outerHeight();
                        listBox.css('margin-top', 0);
                        listBox.stop();
                        this.opening = false;
                        this.isanimating = true;
                        var animationValue = -height;
                        if (parseInt(this.container.coord().top) < parseInt(this.host.coord().top)) {
                            animationValue = height;
                        }
                        if (this.animationType == 'fade') {
                            listBox.css({ 'opacity': 1 });
                            listBox.animate({ 'opacity': 0 }, this.closeDelay, function () {
                                that.isanimating = false;
                                container.css('display', 'none');
                                that.ishiding = false;
                            });
                        }
                        else {
                            listBox.animate({ 'margin-top': animationValue }, this.closeDelay, function () {
                                that.isanimating = false;
                                container.css('display', 'none'); that.ishiding = false;
                            });
                        }
                    }
                }

                this.ishiding = true;
                this.host.removeClass(this.toThemeProperty('jqx-combobox-state-selected'));
                this.dropdownlistArrowIcon.removeClass(this.toThemeProperty('jqx-icon-arrow-down-selected'));
                this.dropdownlistArrowIcon.removeClass(this.toThemeProperty('jqx-icon-arrow-up-selected'));
                this.dropdownlistArrow.removeClass(this.toThemeProperty('jqx-combobox-arrow-selected'));
                this.dropdownlistArrow.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                if (!this.focused) {
                    this.host.removeClass(this.toThemeProperty('jqx-combobox-state-focus'));
                    this.host.removeClass(this.toThemeProperty('jqx-fill-state-focus'));
                    this.dropdownlistContent.removeClass(this.toThemeProperty('jqx-combobox-content-focus'));
                }
                this.host.removeClass(this.toThemeProperty('jqx-rc-b-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-rc-t-expanded'));
                this.host.removeClass(this.toThemeProperty('jqx-rc-t-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-rc-b-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-fill-state-focus'));
                this.dropdownlistArrow.removeClass(this.toThemeProperty('jqx-rc-t-expanded'));
                this.dropdownlistArrow.removeClass(this.toThemeProperty('jqx-rc-b-expanded'));

                this._raiseEvent('1', listBoxInstance);
            },

            /* Close popup if clicked elsewhere. */
            closeOpenedListBox: function (event) {
                var that = event.data.that;
                var $target = $(event.target);
                var openedListBox = event.data.listbox;
                if (openedListBox == null)
                    return true;

                if ($(event.target).ischildof(that.host)) {
                    return;
                }

                var dropdownlistInstance = that;

                var isListBox = false;
                $.each($target.parents(), function () {
                    if (this.className != 'undefined') {
                        if (this.className.indexOf) {
                            if (this.className.indexOf('jqx-listbox') != -1) {
                                isListBox = true;
                                return false;
                            }
                            if (this.className.indexOf('jqx-combobox') != -1) {
                                if (that.element.id == this.id) {
                                    isListBox = true;
                                }
                                return false;
                            }
                        }
                    }
                });

                if (openedListBox != null && !isListBox) {
                    if (that.isOpened()) {
                        that.hideListBox('api');
                        that.input.blur();
                    }
                }

                return true;
            },

            loadFromSelect: function (id) {
                this.listBox.loadFromSelect(id);
                this.clearSelection();
            },

            refresh: function (initialRefresh) {
                this._setSize();
                this._arrange();
                if (this.listBox) {
                    this.renderSelection();
                }
            },

            resize: function () {
                this._setSize();
                this._arrange();
            },

            _arrange: function () {
                var width = parseInt(this.host.width());
                var height = parseInt(this.host.height());

                var arrowHeight = this.arrowSize;
                var arrowWidth = this.arrowSize;

                var rightOffset = 1;
                if (!this.showArrow) {
                    arrowWidth = 0;
                    arrowHeight = 0;
                    this.dropdownlistArrow.hide();
                    rightOffset = 0;
                    this.host.css('cursor', 'arrow');
                    if (this.theme === "fluent") {
                        rightOffset = 1;
                    }
                }
                else {
                    if (this.dropdownlistArrow[0].style.display === "none") {
                        this.dropdownlistArrow.show();
                    }
                }
                var contentWidth = width - arrowWidth - 1 * rightOffset;
                if (contentWidth > 0) {
                    this.dropdownlistContent[0].style.width = contentWidth + 'px';
                }
                if (this.rtl) {
                    this.dropdownlistContent[0].style.width = (-1 + contentWidth + 'px');
                }

                this.dropdownlistContent[0].style.height = height + 'px';
                this.dropdownlistContent[0].style.left = '0px';
                this.dropdownlistContent[0].style.top = '0px';
                this.dropdownlistArrow[0].style.width = arrowWidth + 'px';
                this.dropdownlistArrow[0].style.height = height + 'px';
                this.dropdownlistArrow[0].style.left = 1 + contentWidth + 'px';

                this.input[0].style.width = '100%';

                if (!this.multiSelect) {
                    this.input.height(height);
                }

                var inputHeight = this.input.height();
                if (inputHeight == 0) {
                    inputHeight = parseInt(this.input.css('font-size')) + 3;
                }

                if (this.input[0].className.indexOf('jqx-rc-all') == -1) {
                    this.input.addClass(this.toThemeProperty('jqx-rc-all'));
                }

                var top = parseInt(height) / 2 - parseInt(inputHeight) / 2;
                if (top > 0) {
                    //      this.input[0].style.marginTop = parseInt(top) + "px";
                }

                if (this.rtl) {
                    this.dropdownlistArrow.css('left', '0px');
                    this.dropdownlistContent.css('left', this.dropdownlistArrow.width());
                    if ($.jqx.browser.msie && $.jqx.browser.version <= 8) {
                        this.dropdownlistContent.css('left', 1 + this.dropdownlistArrow.width());
                    }
                }
                if (this.multiSelect) {
                    this.input.css('float', 'left');
                    this.input.width(25);
                    this.dropdownlistWrapper.parent().css('height', 'auto');
                    this.dropdownlistContent.css('height', 'auto');
                    this.dropdownlistWrapper.css('height', 'auto');
                    this.dropdownlistContent.css('position', 'relative');
                    this.dropdownlistContent.css('cursor', 'text');
                    this.host.css('height', 'auto');
                    this.host.css('min-height', this.height);
                    this.dropdownlistContent.css('min-height', this.height);
                    var height = parseInt(this.host.height());
                    this.dropdownlistArrow.height(height);
                    var initialHeight = parseInt(this.host.css('min-height'));
                    var top = parseInt(initialHeight) / 2 - parseInt(inputHeight) / 2;
                    if (top > 0) {
                        this.input.css('margin-top', top);
                    }


                    if (this.isMaterialized()) {
                        this.host.height(this.dropdownlistContent.height());
                    }

                    this.bar.css('top', this.host.height());
                    this.dropdownlistArrow.height(this.host.height());
                }
            },

            destroy: function () {
                if (this.source && this.source.unbindBindingUpdate) {
                    this.source.unbindBindingUpdate(this.element.id);
                    this.source.unbindBindingUpdate(this.listBoxContainer[0].id);
                    this.source.unbindDownloadComplete(this.element.id);
                    this.source.unbindDownloadComplete(this.listBoxContainer[0].id);
                }
                $.jqx.utilities.resize(this.host, null, true);
                this.removeHandler(this.listBoxContainer, 'select');
                this.removeHandler(this.listBoxContainer, 'unselect');
                this.removeHandler(this.listBoxContainer, 'change');
                this.removeHandler(this.listBoxContainer, 'bindingComplete');
                this.removeHandler(this.dropdownlistWrapper, 'selectstart');
                this.removeHandler(this.dropdownlistWrapper, 'mousedown');
                this.removeHandler(this.host, 'keydown');
                this.removeHandler(this.listBoxContainer, 'select');
                this.removeHandler(this.listBox.content, 'click');
                this.removeHandlers();
                this.removeHandler(this.input, 'keyup.textchange');

                this.listBoxContainer.jqxListBox('destroy');
                this.listBoxContainer.remove();
                this.host.removeClass();
                this.removeHandler($(document), 'mousedown.' + this.id, this.closeOpenedListBox);
                if (this.touch) {
                    this.removeHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.' + this.id);
                }
                this.cinput.remove();
                delete this.cinput;
                this.dropdownlistArrow.remove();
                delete this.dropdownlistArrow;
                this.dropdownlistArrowIcon.remove();
                delete this.dropdownlistArrowIcon;
                delete this.dropdownlistWrapper;
                delete this.listBoxContainer;
                delete this.input;
                delete this.dropdownlistContent;
                delete this.comboStructure;
                this.container.remove();
                delete this.listBox;
                delete this.container;
                var vars = $.data(this.element, "jqxComboBox");
                if (vars) {
                    delete vars.instance;
                }
                this.host.removeData();
                this.host.remove();
                delete this.host;
                delete this.set;
                delete this.get;
                delete this.call;
                delete this.element;
            },

            //[optimize]
            _raiseEvent: function (id, arg) {
                if (arg == undefined)
                    arg = { owner: null };

                var evt = this.events[id];
                var args = arg;
                args.owner = this;

                var event = new $.Event(evt);
                event.owner = this;
                if (id == 2 || id == 3 || id == 4 || id == 5 || id == 6 || id == 7 || id == 8 || id == 9) {
                    event.args = arg;
                }

                var result = this.host.trigger(event);
                return result;
            },

            propertiesChangedHandler: function (object, key, value) {
                if (value.width && value.height && Object.keys(value).length == 2) {
                    object._setSize();
                    if (key == 'width') {
                        if (object.dropDownWidth == 'auto') {
                            var width = object.host.width();
                            object.listBoxContainer.jqxListBox({ width: width });
                            object.container.width(parseInt(width) + 25);
                        }
                    }
                    object._arrange();
                    object.close();
                }
            },

            propertyChangedHandler: function (object, key, oldvalue, value) {
                if (object.isInitialized == undefined || object.isInitialized == false)
                    return;

                if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                    return;
                }

                if (key == "template") {
                    object.listBoxContainer.removeClass(object.toThemeProperty("jqx-" + oldvalue + "-item"));
                    object.listBoxContainer.addClass(object.toThemeProperty("jqx-" + object.template + "-item"));
                    object.dropDownListArrow.removeClass(object.toThemeProperty("jqx-" + oldvalue + ""));
                    object.dropDownListArrow.addClass(object.toThemeProperty("jqx-" + object.template + ""));

                    var that = this;

                    that.bar.removeClass(that.toThemeProperty("jqx-" + oldvalue));
                    that.label.removeClass(that.toThemeProperty("jqx-" + oldvalue));
                    that.bar.addClass(that.toThemeProperty("jqx-" + that.template));
                    that.label.addClass(that.toThemeProperty("jqx-" + that.template));

                }

                if (key == "dropDownVerticalAlignment") {
                    object.close();
                    object.dropdownlistArrowIcon.removeClass(object.toThemeProperty('jqx-icon-arrow-up'));
                    object.dropdownlistArrowIcon.removeClass(object.toThemeProperty('jqx-icon-arrow-down'));
                    if (object.dropDownVerticalAlignment == "top") {
                        object.dropdownlistArrowIcon.addClass(object.toThemeProperty('jqx-icon-arrow-up'));
                    }
                    else {
                        object.dropdownlistArrowIcon.addClass(object.toThemeProperty('jqx-icon-arrow-down'));
                    }
                    object.listBoxContainer.css('top', 0);
                    object.listBoxContainer.removeClass(this.toThemeProperty('jqx-popup-up'));
                }

                if (key == "autoItemsHeight") {
                    object.listBoxContainer.jqxListBox({ autoItemsHeight: value });
                }

                if (key == "itemHeight") {
                    object.listBoxContainer.jqxListBox({ itemHeight: value });
                }

                if (key == "renderSelectedItem") {
                    object.renderSelection('mouse');
                }

                if (key == "renderer") {
                    object.listBoxContainer.jqxListBox({ renderer: value });
                }

                if (key == "enableSelection") {
                    object.listBoxContainer.jqxListBox({ enableSelection: value });
                }
                if (key == "enableHover") {
                    object.listBoxContainer.jqxListBox({ enableHover: value });
                }

                if (key === "touchMode") {
                    object.listBoxContainer.jqxListBox({ touchMode: value });
                    object.touch = $.jqx.mobile.isTouchDevice();
                    if (object.touchMode === true) {
                        object.touch = true;
                    }
                    object._updateHandlers();
                }

                if (key == "multiSelect") {
                    if (value) {
                        object.doMultiSelect(false);
                    }
                    else {
                        var items = object.listBox.items;
                        var selectedIndex = -1;
                        for (var i = 0; i < items.length; i++) {
                            items[i].disabled = false;
                            if (object.selectedItems.indexOf(items[i].value) >= 0 || object._disabledItems.indexOf(object.value) >= 0) {
                                items[i].disabled = true;
                                selectedIndex = items[i].index;
                            }
                        }
                        object.doMultiSelect(false);
                        object.listBox._renderItems();
                        if (!items) return;
                        object.listBox.selectedIndex = selectedIndex;
                        object.renderSelection('mouse');
                        object.dropdownlistWrapper.parent().css('height', '100%');
                        object.dropdownlistContent.css('height', '100');
                        object.dropdownlistWrapper.css('height', '100');
                        object.dropdownlistContent.css('position', 'relative');
                        object.host.css('min-height', null);
                        object._setSize();
                        object._arrange();
                    }
                }

                if (key == "showArrow") {
                    object._arrange();
                    if (object.multiSelect) {
                        object.doMultiSelect(false);
                    }
                }

                if (key == "placeHolder") {
                    if (object.isMaterialized()) {
                        object.label.innerHTML = object.placeHolder;
                    }
                    else {
                        object.input.attr('placeholder', object.placeHolder);
                    }
                }

                if (key == 'popupZIndex') {
                    object.listBoxContainer.css({ zIndex: object.popupZIndex });
                }

                if (key == 'promptText') {
                    object.placeHolder = value;
                }

                if (key == 'autoOpen') {
                    object._updateHandlers();
                }

                if (key == 'renderer') {
                    object.listBox.renderer = object.renderer;
                }
                if (key == 'itemHeight') {
                    object.listBox.itemHeight = value;
                }

                if (key == 'source') {
                    object.input.val("");
                    object.listBoxContainer.jqxListBox({ source: object.source });
                    object.renderSelection('mouse');
                    if (object.source == null) {
                        object.clearSelection();
                    }
                    if (object.multiSelect) {
                        object.selectedItems = new Array();
                        object._selectedItems = new Array();
                        object.doMultiSelect(false);
                    }
                }
                if (key == "rtl") {
                    if (value) {
                        object.dropdownlistArrow.css('float', 'left');
                        object.dropdownlistContent.css('float', 'right');
                    }
                    else {
                        object.dropdownlistArrow.css('float', 'right');
                        object.dropdownlistContent.css('float', 'left');
                    }
                    object.listBoxContainer.jqxListBox({ rtl: object.rtl });
                }
                if (key == "displayMember" || key == "valueMember") {
                    object.listBoxContainer.jqxListBox({ displayMember: object.displayMember, valueMember: object.valueMember });
                    object.renderSelection('mouse');
                }

                if (key == "autoDropDownHeight") {
                    object.listBoxContainer.jqxListBox({ autoHeight: object.autoDropDownHeight });
                    if (object.autoDropDownHeight) {
                        object.container.height(object.listBoxContainer.height() + 25);
                    }
                    else {
                        object.listBoxContainer.jqxListBox({ height: object.dropDownHeight });
                        object.container.height(parseInt(object.dropDownHeight) + 25);
                    }

                    object.listBox._arrange();
                    object.listBox._updatescrollbars();
                }

                if (key == "dropDownHeight") {
                    if (!object.autoDropDownHeight) {
                        object.listBoxContainer.jqxListBox({ height: object.dropDownHeight });
                        object.container.height(parseInt(object.dropDownHeight) + 25);
                    }
                }

                if (key == "dropDownWidth" || key == "scrollBarSize") {
                    var width = object.width;
                    if (object.dropDownWidth != 'auto') {
                        width = object.dropDownWidth;
                    }

                    object.listBoxContainer.jqxListBox({ width: width, scrollBarSize: object.scrollBarSize });
                    object.container.width(parseInt(width) + 25);
                }

                if (key == 'autoComplete') {
                    object._resetautocomplete();
                }

                if (key == "checkboxes") {
                    object.listBoxContainer.jqxListBox({ checkboxes: object.checkboxes });
                    if (object.checkboxes) {
                        object.input.attr('readonly', true);
                        $.jqx.aria(object, "aria-readonly", true);
                    }
                    else {
                        $.jqx.aria(object, "aria-readonly", false);
                    }
                }

                if (key == 'theme' && value != null) {
                    object.listBoxContainer.jqxListBox({ theme: value });
                    object.listBoxContainer.addClass(object.toThemeProperty('jqx-popup'));
                    if ($.jqx.browser.msie) {
                        object.listBoxContainer.addClass(object.toThemeProperty('jqx-noshadow'));
                    }
                    $.jqx.utilities.setTheme(oldvalue, value, object.host);
                }

                if (key == 'rtl') {
                    object.render();
                    object.refresh();
                }

                if (key == 'width' || key == 'height') {
                    object._setSize();
                    if (key == 'width') {
                        if (object.dropDownWidth == 'auto') {
                            var width = object.host.width();
                            object.listBoxContainer.jqxListBox({ width: width });
                            object.container.width(parseInt(width) + 25);
                        }
                    }
                    object._arrange();
                    object.close();
                }

                if (key == 'selectedIndex') {
                    object.listBox.selectIndex(value);
                    object.renderSelection('mouse');
                }
            }
        });
    })(jqxBaseFramework);
})();



/***/ }),

/***/ 5459:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* tslint:disable */
/* eslint-disable */
(function () {
	if (typeof document === 'undefined') {
		return;
	}

	var oldBrowser = document.all && !document.addEventListener;
	if (!oldBrowser) {
		(function (window, undefined) {
			var
				rootJQXLite,
				readyList,
				document = window.document,
				location = window.location,
				navigator = window.navigator,
				_JQXLite = window.JQXLite,
				_$ = window.$,

				// Save a reference to some core methods
				core_push = Array.prototype.push,
				core_slice = Array.prototype.slice,
				core_indexOf = Array.prototype.indexOf,
				core_toString = Object.prototype.toString,
				core_hasOwn = Object.prototype.hasOwnProperty,
				core_trim = String.prototype.trim,

				// Define a local copy of JQXLite
				JQXLite = function (selector, context) {
					// The JQXLite object is actually just the init constructor 'enhanced'
					return new JQXLite.fn.init(selector, context, rootJQXLite);
				},

				// Used for matching numbers
				core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

				// Used for detecting and trimming whitespace
				core_rnotwhite = /\S/,
				core_rspace = /\s+/,

				// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
				rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

				// A simple way to check for HTML strings
				// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
				rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

				// Match a standalone tag
				rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

				// JSON RegExp
				rvalidchars = /^[\],:{}\s]*$/,
				rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
				rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
				rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

				// Matches dashed string for camelizing
				rmsPrefix = /^-ms-/,
				rdashAlpha = /-([\da-z])/gi,

				// Used by JQXLite.camelCase as callback to replace()
				fcamelCase = function (all, letter) {
					return (letter + "").toUpperCase();
				},

				// The ready event handler and self cleanup method
				DOMContentLoaded = function () {
					if (document.addEventListener) {
						document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
						JQXLite.ready();
					} else if (document.readyState === "complete") {
						// we're here because readyState === "complete" in oldIE
						// which is good enough for us to call the dom ready!
						document.detachEvent("onreadystatechange", DOMContentLoaded);
						JQXLite.ready();
					}
				},

				// [[Class]] -> type pairs
				class2type = {};

			JQXLite.fn = JQXLite.prototype = {
				constructor: JQXLite,
				init: function (selector, context, rootJQXLite) {
					var match, elem, ret, doc;

					// Handle $(""), $(null), $(undefined), $(false)
					if (!selector) {
						return this;
					}

					// Handle $(DOMElement)
					if (selector.nodeType) {
						this.context = this[0] = selector;
						this.length = 1;
						return this;
					}

					// Handle HTML strings
					if (typeof selector === "string") {
						if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
							// Assume that strings that start and end with <> are HTML and skip the regex check
							match = [null, selector, null];

						} else {
							match = rquickExpr.exec(selector);
						}

						// Match html or make sure no context is specified for #id
						if (match && (match[1] || !context)) {

							// HANDLE: $(html) -> $(array)
							if (match[1]) {
								context = context instanceof JQXLite ? context[0] : context;
								doc = (context && context.nodeType ? context.ownerDocument || context : document);

								// scripts is true for back-compat
								selector = JQXLite.parseHTML(match[1], doc, true);
								if (rsingleTag.test(match[1]) && JQXLite.isPlainObject(context)) {
									this.attr.call(selector, context, true);
								}

								return JQXLite.merge(this, selector);

								// HANDLE: $(#id)
							} else {
								elem = document.getElementById(match[2]);

								// Check parentNode to catch when Blackberry 4.6 returns
								// nodes that are no longer in the document #6963
								if (elem && elem.parentNode) {
									// Handle the case where IE and Opera return items
									// by name instead of ID
									if (elem.id !== match[2]) {
										return rootJQXLite.find(selector);
									}

									// Otherwise, we inject the element directly into the JQXLite object
									this.length = 1;
									this[0] = elem;
								}

								this.context = document;
								this.selector = selector;
								return this;
							}

							// HANDLE: $(expr, $(...))
						} else if (!context || context.jqx) {
							return (context || rootJQXLite).find(selector);

							// HANDLE: $(expr, context)
							// (which is just equivalent to: $(context).find(expr)
						} else {
							return this.constructor(context).find(selector);
						}

						// HANDLE: $(function)
						// Shortcut for document ready
					} else if (JQXLite.isFunction(selector)) {
						return rootJQXLite.ready(selector);
					}

					if (selector.selector !== undefined) {
						this.selector = selector.selector;
						this.context = selector.context;
					}

					return JQXLite.makeArray(selector, this);
				},

				// Start with an empty selector
				selector: "",

				// The current version of JQXLite being used
				jqx: "4.5.0",

				// The default length of a JQXLite object is 0
				length: 0,

				// The number of elements contained in the matched element set
				size: function () {
					return this.length;
				},

				toArray: function () {
					return core_slice.call(this);
				},

				// Get the Nth element in the matched element set OR
				// Get the whole matched element set as a clean array
				get: function (num) {
					return num == null ?

						// Return a 'clean' array
						this.toArray() :

						// Return just the object
						(num < 0 ? this[this.length + num] : this[num]);
				},

				// Take an array of elements and push it onto the stack
				// (returning the new matched element set)
				pushStack: function (elems, name, selector) {

					// Build a new JQXLite matched element set
					var ret = JQXLite.merge(this.constructor(), elems);

					// Add the old object onto the stack (as a reference)
					ret.prevObject = this;

					ret.context = this.context;

					if (name === "find") {
						ret.selector = this.selector + (this.selector ? " " : "") + selector;
					} else if (name) {
						ret.selector = this.selector + "." + name + "(" + selector + ")";
					}

					// Return the newly-formed element set
					return ret;
				},

				// Execute a callback for every element in the matched set.
				// (You can seed the arguments with an array of args, but this is
				// only used internally.)
				each: function (callback, args) {
					return JQXLite.each(this, callback, args);
				},

				ready: function (fn) {
					// Add the callback
					JQXLite.ready.promise().done(fn);

					return this;
				},

				eq: function (i) {
					i = +i;
					return i === -1 ?
						this.slice(i) :
						this.slice(i, i + 1);
				},

				first: function () {
					return this.eq(0);
				},

				last: function () {
					return this.eq(-1);
				},

				slice: function () {
					return this.pushStack(core_slice.apply(this, arguments),
						"slice", core_slice.call(arguments).join(","));
				},

				map: function (callback) {
					return this.pushStack(JQXLite.map(this, function (elem, i) {
						return callback.call(elem, i, elem);
					}));
				},

				end: function () {
					return this.prevObject || this.constructor(null);
				},

				// For internal use only.
				// Behaves like an Array's method, not like a JQXLite method.
				push: core_push,
				sort: [].sort,
				splice: [].splice
			};

			// Give the init function the JQXLite prototype for later instantiation
			JQXLite.fn.init.prototype = JQXLite.fn;

			JQXLite.extend = JQXLite.fn.extend = function () {
				var options, name, src, copy, copyIsArray, clone,
					target = arguments[0] || {},
					i = 1,
					length = arguments.length,
					deep = false;

				// Handle a deep copy situation
				if (typeof target === "boolean") {
					deep = target;
					target = arguments[1] || {};
					// skip the boolean and the target
					i = 2;
				}

				// Handle case when target is a string or something (possible in deep copy)
				if (typeof target !== "object" && !JQXLite.isFunction(target)) {
					target = {};
				}

				// extend JQXLite itself if only one argument is passed
				if (length === i) {
					target = this;
					--i;
				}

				for (; i < length; i++) {
					// Only deal with non-null/undefined values
					if ((options = arguments[i]) != null) {
						// Extend the base object
						for (name in options) {
							src = target[name];
							copy = options[name];

							// Prevent never-ending loop
							if (target === copy) {
								continue;
							}

							// Recurse if we're merging plain objects or arrays
							if (deep && copy && (JQXLite.isPlainObject(copy) || (copyIsArray = JQXLite.isArray(copy)))) {
								if (copyIsArray) {
									copyIsArray = false;
									clone = src && JQXLite.isArray(src) ? src : [];

								} else {
									clone = src && JQXLite.isPlainObject(src) ? src : {};
								}

								// Never move original objects, clone them
								target[name] = JQXLite.extend(deep, clone, copy);

								// Don't bring in undefined values
							} else if (copy !== undefined) {
								target[name] = copy;
							}
						}
					}
				}

				// Return the modified object
				return target;
			};

			JQXLite.extend({
				noConflict: function (deep) {
					if (window.$ === JQXLite) {
						window.$ = _$;
					}

					if (deep && window.JQXLite === JQXLite) {
						window.JQXLite = _JQXLite;
					}

					return JQXLite;
				},

				// Is the DOM ready to be used? Set to true once it occurs.
				isReady: false,

				// A counter to track how many items to wait for before
				// the ready event fires. See #6781
				readyWait: 1,

				// Hold (or release) the ready event
				holdReady: function (hold) {
					if (hold) {
						JQXLite.readyWait++;
					} else {
						JQXLite.ready(true);
					}
				},

				// Handle when the DOM is ready
				ready: function (wait) {

					// Abort if there are pending holds or we're already ready
					if (wait === true ? --JQXLite.readyWait : JQXLite.isReady) {
						return;
					}

					// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
					if (!document.body) {
						return setTimeout(JQXLite.ready, 1);
					}

					// Remember that the DOM is ready
					JQXLite.isReady = true;

					// If a normal DOM Ready event fired, decrement, and wait if need be
					if (wait !== true && --JQXLite.readyWait > 0) {
						return;
					}

					// If there are functions bound, to execute
					readyList.resolveWith(document, [JQXLite]);

					// Trigger any bound ready events
					if (JQXLite.fn.trigger) {
						JQXLite(document).trigger("ready").off("ready");
					}
				},

				// See test/unit/core.js for details concerning isFunction.
				// Since version 1.3, DOM methods and functions like alert
				// aren't supported. They return false on IE (#2968).
				isFunction: function (obj) {
					return JQXLite.type(obj) === "function";
				},

				isArray: Array.isArray || function (obj) {
					return JQXLite.type(obj) === "array";
				},

				isWindow: function (obj) {
					return obj != null && obj == obj.window;
				},

				isNumeric: function (obj) {
					return !isNaN(parseFloat(obj)) && isFinite(obj);
				},

				type: function (obj) {
					return obj == null ?
						String(obj) :
						class2type[core_toString.call(obj)] || "object";
				},

				isPlainObject: function (obj) {
					// Must be an Object.
					// Because of IE, we also have to check the presence of the constructor property.
					// Make sure that DOM nodes and window objects don't pass through, as well
					if (!obj || JQXLite.type(obj) !== "object" || obj.nodeType || JQXLite.isWindow(obj)) {
						return false;
					}

					try {
						// Not own constructor property must be Object
						if (obj.constructor &&
							!core_hasOwn.call(obj, "constructor") &&
							!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
							return false;
						}
					} catch (e) {
						// IE8,9 Will throw exceptions on certain host objects #9897
						return false;
					}

					// Own properties are enumerated firstly, so to speed up,
					// if last one is own, then all properties are own.

					var key;
					for (key in obj) { }

					return key === undefined || core_hasOwn.call(obj, key);
				},

				isEmptyObject: function (obj) {
					var name;
					for (name in obj) {
						return false;
					}
					return true;
				},

				error: function (msg) {
					throw new Error(msg);
				},

				// data: string of html
				// context (optional): If specified, the fragment will be created in this context, defaults to document
				// scripts (optional): If true, will include scripts passed in the html string
				parseHTML: function (data, context, scripts) {
					var parsed;
					if (!data || typeof data !== "string") {
						return null;
					}
					if (typeof context === "boolean") {
						scripts = context;
						context = 0;
					}
					context = context || document;

					// Single tag
					if ((parsed = rsingleTag.exec(data))) {
						return [context.createElement(parsed[1])];
					}

					parsed = JQXLite.buildFragment([data], context, scripts ? null : []);
					return JQXLite.merge([],
						(parsed.cacheable ? JQXLite.clone(parsed.fragment) : parsed.fragment).childNodes);
				},

				parseJSON: function (data) {
					if (!data || typeof data !== "string") {
						return null;
					}

					// Make sure leading/trailing whitespace is removed (IE can't handle it)
					data = JQXLite.trim(data);

					// Attempt to parse using the native JSON parser first
					if (window.JSON && window.JSON.parse) {
						return window.JSON.parse(data);
					}

					// Make sure the incoming data is actual JSON
					// Logic borrowed from http://json.org/json2.js
					if (rvalidchars.test(data.replace(rvalidescape, "@")
						.replace(rvalidtokens, "]")
						.replace(rvalidbraces, ""))) {

						return (new Function("return " + data))();

					}
					JQXLite.error("Invalid JSON: " + data);
				},

				// Cross-browser xml parsing
				parseXML: function (data) {
					var xml, tmp;
					if (!data || typeof data !== "string") {
						return null;
					}
					try {
						if (window.DOMParser) { // Standard
							tmp = new DOMParser();
							xml = tmp.parseFromString(data, "text/xml");
						} else { // IE
							xml = new ActiveXObject("Microsoft.XMLDOM");
							xml.async = "false";
							xml.loadXML(data);
						}
					} catch (e) {
						xml = undefined;
					}
					if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
						JQXLite.error("Invalid XML: " + data);
					}
					return xml;
				},

				noop: function () { },

				// Evaluates a script in a global context
				// Workarounds based on findings by Jim Driscoll
				// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
				globalEval: function (data) {
					if (data && core_rnotwhite.test(data)) {
						// We use execScript on Internet Explorer
						// We use an anonymous function so that context is window
						// rather than JQXLite in Firefox
						(window.execScript || function (data) {
							window["eval"].call(window, data);
						})(data);
					}
				},

				// Convert dashed to camelCase; used by the css and data modules
				// Microsoft forgot to hump their vendor prefix (#9572)
				camelCase: function (string) {
					return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
				},

				nodeName: function (elem, name) {
					return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
				},

				// args is for internal usage only
				each: function (obj, callback, args) {
					var name,
						i = 0,
						length = obj.length,
						isObj = length === undefined || JQXLite.isFunction(obj);

					if (args) {
						if (isObj) {
							for (name in obj) {
								if (callback.apply(obj[name], args) === false) {
									break;
								}
							}
						} else {
							for (; i < length;) {
								if (callback.apply(obj[i++], args) === false) {
									break;
								}
							}
						}

						// A special, fast, case for the most common use of each
					} else {
						if (isObj) {
							for (name in obj) {
								if (callback.call(obj[name], name, obj[name]) === false) {
									break;
								}
							}
						} else {
							for (; i < length;) {
								if (callback.call(obj[i], i, obj[i++]) === false) {
									break;
								}
							}
						}
					}

					return obj;
				},

				// Use native String.trim function wherever possible
				trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
					function (text) {
						return text == null ?
							"" :
							core_trim.call(text);
					} :

					// Otherwise use our own trimming functionality
					function (text) {
						return text == null ?
							"" :
							(text + "").replace(rtrim, "");
					},

				// results is for internal usage only
				makeArray: function (arr, results) {
					var type,
						ret = results || [];

					if (arr != null) {
						// The window, strings (and functions) also have 'length'
						// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
						type = JQXLite.type(arr);

						if (arr.length == null || type === "string" || type === "function" || type === "regexp" || JQXLite.isWindow(arr)) {
							core_push.call(ret, arr);
						} else {
							JQXLite.merge(ret, arr);
						}
					}

					return ret;
				},

				inArray: function (elem, arr, i) {
					var len;

					if (arr) {
						if (core_indexOf) {
							return core_indexOf.call(arr, elem, i);
						}

						len = arr.length;
						i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

						for (; i < len; i++) {
							// Skip accessing in sparse arrays
							if (i in arr && arr[i] === elem) {
								return i;
							}
						}
					}

					return -1;
				},

				merge: function (first, second) {
					var l = second.length,
						i = first.length,
						j = 0;

					if (typeof l === "number") {
						for (; j < l; j++) {
							first[i++] = second[j];
						}

					} else {
						while (second[j] !== undefined) {
							first[i++] = second[j++];
						}
					}

					first.length = i;

					return first;
				},

				grep: function (elems, callback, inv) {
					var retVal,
						ret = [],
						i = 0,
						length = elems.length;
					inv = !!inv;

					// Go through the array, only saving the items
					// that pass the validator function
					for (; i < length; i++) {
						retVal = !!callback(elems[i], i);
						if (inv !== retVal) {
							ret.push(elems[i]);
						}
					}

					return ret;
				},

				// arg is for internal usage only
				map: function (elems, callback, arg) {
					var value, key,
						ret = [],
						i = 0,
						length = elems.length,
						// jqx objects are treated as arrays
						isArray = elems instanceof JQXLite || length !== undefined && typeof length === "number" && ((length > 0 && elems[0] && elems[length - 1]) || length === 0 || JQXLite.isArray(elems));

					// Go through the array, translating each of the items to their
					if (isArray) {
						for (; i < length; i++) {
							value = callback(elems[i], i, arg);

							if (value != null) {
								ret[ret.length] = value;
							}
						}

						// Go through every key on the object,
					} else {
						for (key in elems) {
							value = callback(elems[key], key, arg);

							if (value != null) {
								ret[ret.length] = value;
							}
						}
					}

					// Flatten any nested arrays
					return ret.concat.apply([], ret);
				},

				// A global GUID counter for objects
				guid: 1,

				// Bind a function to a context, optionally partially applying any
				// arguments.
				proxy: function (fn, context) {
					var tmp, args, proxy;

					if (typeof context === "string") {
						tmp = fn[context];
						context = fn;
						fn = tmp;
					}

					// Quick check to determine if target is callable, in the spec
					// this throws a TypeError, but we will just return undefined.
					if (!JQXLite.isFunction(fn)) {
						return undefined;
					}

					// Simulated bind
					args = core_slice.call(arguments, 2);
					proxy = function () {
						return fn.apply(context, args.concat(core_slice.call(arguments)));
					};

					// Set the guid of unique handler to the same of original handler, so it can be removed
					proxy.guid = fn.guid = fn.guid || JQXLite.guid++;

					return proxy;
				},

				// Multifunctional method to get and set values of a collection
				// The value/s can optionally be executed if it's a function
				access: function (elems, fn, key, value, chainable, emptyGet, pass) {
					var exec,
						bulk = key == null,
						i = 0,
						length = elems.length;

					// Sets many values
					if (key && typeof key === "object") {
						for (i in key) {
							JQXLite.access(elems, fn, i, key[i], 1, emptyGet, value);
						}
						chainable = 1;

						// Sets one value
					} else if (value !== undefined) {
						// Optionally, function values get executed if exec is true
						exec = pass === undefined && JQXLite.isFunction(value);

						if (bulk) {
							// Bulk operations only iterate when executing function values
							if (exec) {
								exec = fn;
								fn = function (elem, key, value) {
									return exec.call(JQXLite(elem), value);
								};

								// Otherwise they run against the entire set
							} else {
								fn.call(elems, value);
								fn = null;
							}
						}

						if (fn) {
							for (; i < length; i++) {
								fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
							}
						}

						chainable = 1;
					}

					return chainable ?
						elems :

						// Gets
						bulk ?
							fn.call(elems) :
							length ? fn(elems[0], key) : emptyGet;
				},

				now: function () {
					return (new Date()).getTime();
				}
			});

			JQXLite.ready.promise = function (obj) {
				if (!readyList) {

					readyList = JQXLite.Deferred();

					// Catch cases where $(document).ready() is called after the browser event has already occurred.
					// we once tried to use readyState "interactive" here, but it caused issues like the one
					// discovered by ChrisS here: http://bugs.jqx.com/ticket/12282#comment:15
					if (document.readyState === "complete") {
						// Handle it asynchronously to allow scripts the opportunity to delay ready
						setTimeout(JQXLite.ready, 1);

						// Standards-based browsers support DOMContentLoaded
					} else if (document.addEventListener) {
						// Use the handy event callback
						document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);

						// A fallback to window.onload, that will always work
						window.addEventListener("load", JQXLite.ready, false);

						// If IE event model is used
					} else {
						// Ensure firing before onload, maybe late but safe also for iframes
						document.attachEvent("onreadystatechange", DOMContentLoaded);

						// A fallback to window.onload, that will always work
						window.attachEvent("onload", JQXLite.ready);

						// If IE and not a frame
						// continually check to see if the document is ready
						var top = false;

						try {
							top = window.frameElement == null && document.documentElement;
						} catch (e) { }

						if (top && top.doScroll) {
							(function doScrollCheck() {
								if (!JQXLite.isReady) {

									try {
										// Use the trick by Diego Perini
										// http://javascript.nwbox.com/IEContentLoaded/
										top.doScroll("left");
									} catch (e) {
										return setTimeout(doScrollCheck, 50);
									}

									// and execute any waiting functions
									JQXLite.ready();
								}
							})();
						}
					}
				}
				return readyList.promise(obj);
			};

			// Populate the class2type map
			JQXLite.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (i, name) {
				class2type["[object " + name + "]"] = name.toLowerCase();
			});

			// All JQXLite objects should point back to these
			rootJQXLite = JQXLite(document);
			// String to Object options format cache
			var optionsCache = {};

			// Convert String-formatted options into Object-formatted ones and store in cache
			function createOptions(options) {
				var object = optionsCache[options] = {};
				JQXLite.each(options.split(core_rspace), function (_, flag) {
					object[flag] = true;
				});
				return object;
			}

			/*
			 * Create a callback list using the following parameters:
			 *
			 *	options: an optional list of space-separated options that will change how
			 *			the callback list behaves or a more traditional option object
			 *
			 * By default a callback list will act like an event callback list and can be
			 * "fired" multiple times.
			 *
			 * Possible options:
			 *
			 *	once:			will ensure the callback list can only be fired once (like a Deferred)
			 *
			 *	memory:			will keep track of previous values and will call any callback added
			 *					after the list has been fired right away with the latest "memorized"
			 *					values (like a Deferred)
			 *
			 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
			 *
			 *	stopOnFalse:	interrupt callings when a callback returns false
			 *
			 */
			JQXLite.Callbacks = function (options) {

				// Convert options from String-formatted to Object-formatted if needed
				// (we check in cache first)
				options = typeof options === "string" ?
					(optionsCache[options] || createOptions(options)) :
					JQXLite.extend({}, options);

				var // Last fire value (for non-forgettable lists)
					memory,
					// Flag to know if list was already fired
					fired,
					// Flag to know if list is currently firing
					firing,
					// First callback to fire (used internally by add and fireWith)
					firingStart,
					// End of the loop when firing
					firingLength,
					// Index of currently firing callback (modified by remove if needed)
					firingIndex,
					// Actual callback list
					list = [],
					// Stack of fire calls for repeatable lists
					stack = !options.once && [],
					// Fire callbacks
					fire = function (data) {
						memory = options.memory && data;
						fired = true;
						firingIndex = firingStart || 0;
						firingStart = 0;
						firingLength = list.length;
						firing = true;
						for (; list && firingIndex < firingLength; firingIndex++) {
							if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
								memory = false; // To prevent further calls using add
								break;
							}
						}
						firing = false;
						if (list) {
							if (stack) {
								if (stack.length) {
									fire(stack.shift());
								}
							} else if (memory) {
								list = [];
							} else {
								self.disable();
							}
						}
					},
					// Actual Callbacks object
					self = {
						// Add a callback or a collection of callbacks to the list
						add: function () {
							if (list) {
								// First, we save the current length
								var start = list.length;
								(function add(args) {
									JQXLite.each(args, function (_, arg) {
										var type = JQXLite.type(arg);
										if (type === "function") {
											if (!options.unique || !self.has(arg)) {
												list.push(arg);
											}
										} else if (arg && arg.length && type !== "string") {
											// Inspect recursively
											add(arg);
										}
									});
								})(arguments);
								// Do we need to add the callbacks to the
								// current firing batch?
								if (firing) {
									firingLength = list.length;
									// With memory, if we're not firing then
									// we should call right away
								} else if (memory) {
									firingStart = start;
									fire(memory);
								}
							}
							return this;
						},
						// Remove a callback from the list
						remove: function () {
							if (list) {
								JQXLite.each(arguments, function (_, arg) {
									var index;
									while ((index = JQXLite.inArray(arg, list, index)) > -1) {
										list.splice(index, 1);
										// Handle firing indexes
										if (firing) {
											if (index <= firingLength) {
												firingLength--;
											}
											if (index <= firingIndex) {
												firingIndex--;
											}
										}
									}
								});
							}
							return this;
						},
						// Control if a given callback is in the list
						has: function (fn) {
							return JQXLite.inArray(fn, list) > -1;
						},
						// Remove all callbacks from the list
						empty: function () {
							list = [];
							return this;
						},
						// Have the list do nothing anymore
						disable: function () {
							list = stack = memory = undefined;
							return this;
						},
						// Is it disabled?
						disabled: function () {
							return !list;
						},
						// Lock the list in its current state
						lock: function () {
							stack = undefined;
							if (!memory) {
								self.disable();
							}
							return this;
						},
						// Is it locked?
						locked: function () {
							return !stack;
						},
						// Call all callbacks with the given context and arguments
						fireWith: function (context, args) {
							args = args || [];
							args = [context, args.slice ? args.slice() : args];
							if (list && (!fired || stack)) {
								if (firing) {
									stack.push(args);
								} else {
									fire(args);
								}
							}
							return this;
						},
						// Call all the callbacks with the given arguments
						fire: function () {
							self.fireWith(this, arguments);
							return this;
						},
						// To know if the callbacks have already been called at least once
						fired: function () {
							return !!fired;
						}
					};

				return self;
			};
			JQXLite.extend({

				Deferred: function (func) {
					var tuples = [
						// action, add listener, listener list, final state
						["resolve", "done", JQXLite.Callbacks("once memory"), "resolved"],
						["reject", "fail", JQXLite.Callbacks("once memory"), "rejected"],
						["notify", "progress", JQXLite.Callbacks("memory")]
					],
						state = "pending",
						promise = {
							state: function () {
								return state;
							},
							always: function () {
								deferred.done(arguments).fail(arguments);
								return this;
							},
							then: function ( /* fnDone, fnFail, fnProgress */) {
								var fns = arguments;
								return JQXLite.Deferred(function (newDefer) {
									JQXLite.each(tuples, function (i, tuple) {
										var action = tuple[0],
											fn = fns[i];
										// deferred[ done | fail | progress ] for forwarding actions to newDefer
										deferred[tuple[1]](JQXLite.isFunction(fn) ?
											function () {
												var returned = fn.apply(this, arguments);
												if (returned && JQXLite.isFunction(returned.promise)) {
													returned.promise()
														.done(newDefer.resolve)
														.fail(newDefer.reject)
														.progress(newDefer.notify);
												} else {
													newDefer[action + "With"](this === deferred ? newDefer : this, [returned]);
												}
											} :
											newDefer[action]
										);
									});
									fns = null;
								}).promise();
							},
							// Get a promise for this deferred
							// If obj is provided, the promise aspect is added to the object
							promise: function (obj) {
								return obj != null ? JQXLite.extend(obj, promise) : promise;
							}
						},
						deferred = {};

					// Keep pipe for back-compat
					promise.pipe = promise.then;

					// Add list-specific methods
					JQXLite.each(tuples, function (i, tuple) {
						var list = tuple[2],
							stateString = tuple[3];

						// promise[ done | fail | progress ] = list.add
						promise[tuple[1]] = list.add;

						// Handle state
						if (stateString) {
							list.add(function () {
								// state = [ resolved | rejected ]
								state = stateString;

								// [ reject_list | resolve_list ].disable; progress_list.lock
							}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
						}

						// deferred[ resolve | reject | notify ] = list.fire
						deferred[tuple[0]] = list.fire;
						deferred[tuple[0] + "With"] = list.fireWith;
					});

					// Make the deferred a promise
					promise.promise(deferred);

					// Call given func if any
					if (func) {
						func.call(deferred, deferred);
					}

					// All done!
					return deferred;
				},

				// Deferred helper
				when: function (subordinate /* , ..., subordinateN */) {
					var i = 0,
						resolveValues = core_slice.call(arguments),
						length = resolveValues.length,

						// the count of uncompleted subordinates
						remaining = length !== 1 || (subordinate && JQXLite.isFunction(subordinate.promise)) ? length : 0,

						// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
						deferred = remaining === 1 ? subordinate : JQXLite.Deferred(),

						// Update function for both resolve and progress values
						updateFunc = function (i, contexts, values) {
							return function (value) {
								contexts[i] = this;
								values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
								if (values === progressValues) {
									deferred.notifyWith(contexts, values);
								} else if (!(--remaining)) {
									deferred.resolveWith(contexts, values);
								}
							};
						},

						progressValues, progressContexts, resolveContexts;

					// add listeners to Deferred subordinates; treat others as resolved
					if (length > 1) {
						progressValues = new Array(length);
						progressContexts = new Array(length);
						resolveContexts = new Array(length);
						for (; i < length; i++) {
							if (resolveValues[i] && JQXLite.isFunction(resolveValues[i].promise)) {
								resolveValues[i].promise()
									.done(updateFunc(i, resolveContexts, resolveValues))
									.fail(deferred.reject)
									.progress(updateFunc(i, progressContexts, progressValues));
							} else {
								--remaining;
							}
						}
					}

					// if we're not waiting on anything, resolve the master
					if (!remaining) {
						deferred.resolveWith(resolveContexts, resolveValues);
					}

					return deferred.promise();
				}
			});
			JQXLite.support = (function () {

				var support,
					all,
					a,
					select,
					opt,
					input,
					fragment,
					eventName,
					i,
					isSupported,
					clickFn,
					div = document.createElement("div");

				// Setup
				div.setAttribute("className", "t");
				div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

				// Support tests won't run in some limited or non-browser environments
				all = div.getElementsByTagName("*");
				a = div.getElementsByTagName("a")[0];
				if (!all || !a || !all.length) {
					return {};
				}

				// First batch of tests
				select = document.createElement("select");
				opt = select.appendChild(document.createElement("option"));
				input = div.getElementsByTagName("input")[0];

				a.style.cssText = "top:1px;float:left;opacity:.5";
				support = {
					// IE strips leading whitespace when .innerHTML is used
					leadingWhitespace: (div.firstChild.nodeType === 3),

					// Make sure that tbody elements aren't automatically inserted
					// IE will insert them into empty tables
					tbody: !div.getElementsByTagName("tbody").length,

					// Make sure that link elements get serialized correctly by innerHTML
					// This requires a wrapper element in IE
					htmlSerialize: !!div.getElementsByTagName("link").length,

					// Get the style information from getAttribute
					// (IE uses .cssText instead)
					style: /top/.test(a.getAttribute("style")),

					// Make sure that URLs aren't manipulated
					// (IE normalizes it by default)
					hrefNormalized: (a.getAttribute("href") === "/a"),

					// Make sure that element opacity exists
					// (IE uses filter instead)
					// Use a regex to work around a WebKit issue. See #5145
					opacity: /^0.5/.test(a.style.opacity),

					// Verify style float existence
					// (IE uses styleFloat instead of cssFloat)
					cssFloat: !!a.style.cssFloat,

					// Make sure that if no value is specified for a checkbox
					// that it defaults to "on".
					// (WebKit defaults to "" instead)
					checkOn: (input.value === "on"),

					// Make sure that a selected-by-default option has a working selected property.
					// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
					optSelected: opt.selected,

					// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
					getSetAttribute: div.className !== "t",

					// Tests for enctype support on a form (#6743)
					enctype: !!document.createElement("form").enctype,

					// Makes sure cloning an html5 element does not cause problems
					// Where outerHTML is undefined, this still works
					html5Clone: document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>",

					// JQXLite.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
					boxModel: (document.compatMode === "CSS1Compat"),

					// Will be defined later
					submitBubbles: true,
					changeBubbles: true,
					focusinBubbles: false,
					deleteExpando: true,
					noCloneEvent: true,
					inlineBlockNeedsLayout: false,
					shrinkWrapBlocks: false,
					reliableMarginRight: true,
					boxSizingReliable: true,
					pixelPosition: false
				};

				// Make sure checked status is properly cloned
				input.checked = true;
				support.noCloneChecked = input.cloneNode(true).checked;

				// Make sure that the options inside disabled selects aren't marked as disabled
				// (WebKit marks them as disabled)
				select.disabled = true;
				support.optDisabled = !opt.disabled;

				// Test to see if it's possible to delete an expando from an element
				// Fails in Internet Explorer
				try {
					delete div.test;
				} catch (e) {
					support.deleteExpando = false;
				}

				if (!div.addEventListener && div.attachEvent && div.fireEvent) {
					div.attachEvent("onclick", clickFn = function () {
						// Cloning a node shouldn't copy over any
						// bound event handlers (IE does this)
						support.noCloneEvent = false;
					});
					div.cloneNode(true).fireEvent("onclick");
					div.detachEvent("onclick", clickFn);
				}

				// Check if a radio maintains its value
				// after being appended to the DOM
				input = document.createElement("input");
				input.value = "t";
				input.setAttribute("type", "radio");
				support.radioValue = input.value === "t";

				input.setAttribute("checked", "checked");

				// #11217 - WebKit loses check when the name is after the checked attribute
				input.setAttribute("name", "t");

				div.appendChild(input);
				fragment = document.createDocumentFragment();
				fragment.appendChild(div.lastChild);

				// WebKit doesn't clone checked state correctly in fragments
				support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

				// Check if a disconnected checkbox will retain its checked
				// value of true after appended to the DOM (IE6/7)
				support.appendChecked = input.checked;

				fragment.removeChild(input);
				fragment.appendChild(div);

				// Technique from Juriy Zaytsev
				// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
				// We only care about the case where non-standard event systems
				// are used, namely in IE. Short-circuiting here helps us to
				// avoid an eval call (in setAttribute) which can cause CSP
				// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
				if (div.attachEvent) {
					for (i in {
						submit: true,
						change: true,
						focusin: true
					}) {
						eventName = "on" + i;
						isSupported = (eventName in div);
						if (!isSupported) {
							div.setAttribute(eventName, "return;");
							isSupported = (typeof div[eventName] === "function");
						}
						support[i + "Bubbles"] = isSupported;
					}
				}

				// Run tests that need a body at doc ready
				JQXLite(function () {
					var container, div, tds, marginDiv,
						divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
						body = document.getElementsByTagName("body")[0];

					if (!body) {
						// Return for frameset docs that don't have a body
						return;
					}

					container = document.createElement("div");
					container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
					body.insertBefore(container, body.firstChild);

					// Construct the test element
					div = document.createElement("div");
					container.appendChild(div);

					// Check if table cells still have offsetWidth/Height when they are set
					// to display:none and there are still other visible table cells in a
					// table row; if so, offsetWidth/Height are not reliable for use when
					// determining if an element has been hidden directly using
					// display:none (it is still safe to use offsets if a parent element is
					// hidden; don safety goggles and see bug #4512 for more information).
					// (only IE 8 fails this test)
					div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
					tds = div.getElementsByTagName("td");
					tds[0].style.cssText = "padding:0;margin:0;border:0;display:none";
					isSupported = (tds[0].offsetHeight === 0);

					tds[0].style.display = "";
					tds[1].style.display = "none";

					// Check if empty table cells still have offsetWidth/Height
					// (IE <= 8 fail this test)
					support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0);

					// Check box-sizing and margin behavior
					div.innerHTML = "";
					div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
					support.boxSizing = (div.offsetWidth === 4);
					support.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== 1);

					// NOTE: To any future maintainer, we've window.getComputedStyle
					// because jsdom on node.js will break without it.
					if (window.getComputedStyle) {
						support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== "1%";
						support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: "4px" }).width === "4px";

						// Check if div with explicit width and no margin-right incorrectly
						// gets computed margin-right based on width of container. For more
						// info see bug #3333
						// Fails in WebKit before Feb 2011 nightlies
						// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
						marginDiv = document.createElement("div");
						marginDiv.style.cssText = div.style.cssText = divReset;
						marginDiv.style.marginRight = marginDiv.style.width = "0";
						div.style.width = "1px";
						div.appendChild(marginDiv);
						support.reliableMarginRight =
							!parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
					}

					if (typeof div.style.zoom !== "undefined") {
						// Check if natively block-level elements act like inline-block
						// elements when setting their display to 'inline' and giving
						// them layout
						// (IE < 8 does this)
						div.innerHTML = "";
						div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
						support.inlineBlockNeedsLayout = (div.offsetWidth === 3);

						// Check if elements with layout shrink-wrap their children
						// (IE 6 does this)
						div.style.display = "block";
						div.style.overflow = "visible";
						div.innerHTML = "<div></div>";
						div.firstChild.style.width = "5px";
						support.shrinkWrapBlocks = (div.offsetWidth !== 3);

						container.style.zoom = 1;
					}

					// Null elements to avoid leaks in IE
					body.removeChild(container);
					container = div = tds = marginDiv = null;
				});

				// Null elements to avoid leaks in IE
				fragment.removeChild(div);
				all = a = select = opt = input = fragment = div = null;

				return support;
			})();
			var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
				rmultiDash = /([A-Z])/g;

			JQXLite.extend({
				cache: {},

				deletedIds: [],

				// Remove at next major release (1.9/2.0)
				uuid: 0,

				// Unique for each copy of JQXLite on the page
				// Non-digits removed to match rinlinejQuery
				expando: "JQXLite" + (JQXLite.fn.jqx + Math.random()).replace(/\D/g, ""),

				// The following elements throw uncatchable exceptions if you
				// attempt to add expando properties to them.
				noData: {
					"embed": true,
					// Ban all objects except for Flash (which handle expandos)
					"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
					"applet": true
				},

				hasData: function (elem) {
					elem = elem.nodeType ? JQXLite.cache[elem[JQXLite.expando]] : elem[JQXLite.expando];
					return !!elem && !isEmptyDataObject(elem);
				},

				data: function (elem, name, data, pvt /* Internal Use Only */) {
					if (!JQXLite.acceptData(elem)) {
						return;
					}

					var thisCache, ret,
						internalKey = JQXLite.expando,
						getByName = typeof name === "string",

						// We have to handle DOM nodes and JS objects differently because IE6-7
						// can't GC object references properly across the DOM-JS boundary
						isNode = elem.nodeType,

						// Only DOM nodes need the global JQXLite cache; JS object data is
						// attached directly to the object so GC can occur automatically
						cache = isNode ? JQXLite.cache : elem,

						// Only defining an ID for JS objects if its cache already exists allows
						// the code to shortcut on the same path as a DOM node with no cache
						id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;

					// Avoid doing any more work than we need to when trying to get data on an
					// object that has no data at all
					if ((!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined) {
						return;
					}

					if (!id) {
						// Only DOM nodes need a new unique ID for each element since their data
						// ends up in the global cache
						if (isNode) {
							elem[internalKey] = id = JQXLite.deletedIds.pop() || JQXLite.guid++;
						} else {
							id = internalKey;
						}
					}

					if (!cache[id]) {
						cache[id] = {};

						// Avoids exposing JQXLite metadata on plain JS objects when the object
						// is serialized using JSON.stringify
						if (!isNode) {
							cache[id].toJSON = JQXLite.noop;
						}
					}

					// An object can be passed to JQXLite.data instead of a key/value pair; this gets
					// shallow copied over onto the existing cache
					if (typeof name === "object" || typeof name === "function") {
						if (pvt) {
							cache[id] = JQXLite.extend(cache[id], name);
						} else {
							cache[id].data = JQXLite.extend(cache[id].data, name);
						}
					}

					thisCache = cache[id];

					// JQXLite data() is stored in a separate object inside the object's internal data
					// cache in order to avoid key collisions between internal data and user-defined
					// data.
					if (!pvt) {
						if (!thisCache.data) {
							thisCache.data = {};
						}

						thisCache = thisCache.data;
					}

					if (data !== undefined) {
						thisCache[JQXLite.camelCase(name)] = data;
					}

					// Check for both converted-to-camel and non-converted data property names
					// If a data property was specified
					if (getByName) {

						// First Try to find as-is property data
						ret = thisCache[name];

						// Test for null|undefined property data
						if (ret == null) {

							// Try to find the camelCased property
							ret = thisCache[JQXLite.camelCase(name)];
						}
					} else {
						ret = thisCache;
					}

					return ret;
				},

				removeData: function (elem, name, pvt /* Internal Use Only */) {
					if (!JQXLite.acceptData(elem)) {
						return;
					}

					var thisCache, i, l,

						isNode = elem.nodeType,

						// See JQXLite.data for more information
						cache = isNode ? JQXLite.cache : elem,
						id = isNode ? elem[JQXLite.expando] : JQXLite.expando;

					// If there is already no cache entry for this object, there is no
					// purpose in continuing
					if (!cache[id]) {
						return;
					}

					if (name) {

						thisCache = pvt ? cache[id] : cache[id].data;

						if (thisCache) {

							// Support array or space separated string names for data keys
							if (!JQXLite.isArray(name)) {

								// try the string as a key before any manipulation
								if (name in thisCache) {
									name = [name];
								} else {

									// split the camel cased version by spaces unless a key with the spaces exists
									name = JQXLite.camelCase(name);
									if (name in thisCache) {
										name = [name];
									} else {
										name = name.split(" ");
									}
								}
							}

							for (i = 0, l = name.length; i < l; i++) {
								delete thisCache[name[i]];
							}

							// If there is no data left in the cache, we want to continue
							// and let the cache object itself get destroyed
							if (!(pvt ? isEmptyDataObject : JQXLite.isEmptyObject)(thisCache)) {
								return;
							}
						}
					}

					// See JQXLite.data for more information
					if (!pvt) {
						delete cache[id].data;

						// Don't destroy the parent cache unless the internal data object
						// had been the only thing left in it
						if (!isEmptyDataObject(cache[id])) {
							return;
						}
					}

					// Destroy the cache
					if (isNode) {
						JQXLite.cleanData([elem], true);

						// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
					} else if (JQXLite.support.deleteExpando || cache != cache.window) {
						delete cache[id];

						// When all else fails, null
					} else {
						cache[id] = null;
					}
				},

				// For internal use only.
				_data: function (elem, name, data) {
					return JQXLite.data(elem, name, data, true);
				},

				// A method for determining if a DOM node can handle the data expando
				acceptData: function (elem) {
					var noData = elem.nodeName && JQXLite.noData[elem.nodeName.toLowerCase()];

					// nodes accept data unless otherwise specified; rejection can be conditional
					return !noData || noData !== true && elem.getAttribute("classid") === noData;
				}
			});

			JQXLite.fn.extend({
				data: function (key, value) {
					var parts, part, attr, name, l,
						elem = this[0],
						i = 0,
						data = null;

					// Gets all values
					if (key === undefined) {
						if (this.length) {
							data = JQXLite.data(elem);

							if (elem.nodeType === 1 && !JQXLite._data(elem, "parsedAttrs")) {
								attr = elem.attributes;
								for (l = attr.length; i < l; i++) {
									name = attr[i].name;

									if (!name.indexOf("data-")) {
										name = JQXLite.camelCase(name.substring(5));

										dataAttr(elem, name, data[name]);
									}
								}
								JQXLite._data(elem, "parsedAttrs", true);
							}
						}

						return data;
					}

					// Sets multiple values
					if (typeof key === "object") {
						return this.each(function () {
							JQXLite.data(this, key);
						});
					}

					parts = key.split(".", 2);
					parts[1] = parts[1] ? "." + parts[1] : "";
					part = parts[1] + "!";

					return JQXLite.access(this, function (value) {

						if (value === undefined) {
							data = this.triggerHandler("getData" + part, [parts[0]]);

							// Try to fetch any internally stored data first
							if (data === undefined && elem) {
								data = JQXLite.data(elem, key);
								data = dataAttr(elem, key, data);
							}

							return data === undefined && parts[1] ?
								this.data(parts[0]) :
								data;
						}

						parts[1] = value;
						this.each(function () {
							var self = JQXLite(this);

							self.triggerHandler("setData" + part, parts);
							JQXLite.data(this, key, value);
							self.triggerHandler("changeData" + part, parts);
						});
					}, null, value, arguments.length > 1, null, false);
				},

				removeData: function (key) {
					return this.each(function () {
						JQXLite.removeData(this, key);
					});
				}
			});

			function dataAttr(elem, key, data) {
				// If nothing was found internally, try to fetch any
				// data from the HTML5 data-* attribute
				if (data === undefined && elem.nodeType === 1) {

					var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();

					data = elem.getAttribute(name);

					if (typeof data === "string") {
						try {
							data = data === "true" ? true :
								data === "false" ? false :
									data === "null" ? null :
										// Only convert to a number if it doesn't change the string
										+data + "" === data ? +data :
											rbrace.test(data) ? JQXLite.parseJSON(data) :
												data;
						} catch (e) { }

						// Make sure we set the data so it isn't changed later
						JQXLite.data(elem, key, data);

					} else {
						data = undefined;
					}
				}

				return data;
			}

			// checks a cache object for emptiness
			function isEmptyDataObject(obj) {
				var name;
				for (name in obj) {

					// if the public data object is empty, the private is still empty
					if (name === "data" && JQXLite.isEmptyObject(obj[name])) {
						continue;
					}
					if (name !== "toJSON") {
						return false;
					}
				}

				return true;
			}
			JQXLite.extend({
				queue: function (elem, type, data) {
					var queue;

					if (elem) {
						type = (type || "fx") + "queue";
						queue = JQXLite._data(elem, type);

						// Speed up dequeue by getting out quickly if this is just a lookup
						if (data) {
							if (!queue || JQXLite.isArray(data)) {
								queue = JQXLite._data(elem, type, JQXLite.makeArray(data));
							} else {
								queue.push(data);
							}
						}
						return queue || [];
					}
				},

				dequeue: function (elem, type) {
					type = type || "fx";

					var queue = JQXLite.queue(elem, type),
						startLength = queue.length,
						fn = queue.shift(),
						hooks = JQXLite._queueHooks(elem, type),
						next = function () {
							JQXLite.dequeue(elem, type);
						};

					// If the fx queue is dequeued, always remove the progress sentinel
					if (fn === "inprogress") {
						fn = queue.shift();
						startLength--;
					}

					if (fn) {

						// Add a progress sentinel to prevent the fx queue from being
						// automatically dequeued
						if (type === "fx") {
							queue.unshift("inprogress");
						}

						// clear up the last queue stop function
						delete hooks.stop;
						fn.call(elem, next, hooks);
					}

					if (!startLength && hooks) {
						hooks.empty.fire();
					}
				},

				// not intended for public consumption - generates a queueHooks object, or returns the current one
				_queueHooks: function (elem, type) {
					var key = type + "queueHooks";
					return JQXLite._data(elem, key) || JQXLite._data(elem, key, {
						empty: JQXLite.Callbacks("once memory").add(function () {
							JQXLite.removeData(elem, type + "queue", true);
							JQXLite.removeData(elem, key, true);
						})
					});
				}
			});

			JQXLite.fn.extend({
				queue: function (type, data) {
					var setter = 2;

					if (typeof type !== "string") {
						data = type;
						type = "fx";
						setter--;
					}

					if (arguments.length < setter) {
						return JQXLite.queue(this[0], type);
					}

					return data === undefined ?
						this :
						this.each(function () {
							var queue = JQXLite.queue(this, type, data);

							// ensure a hooks for this queue
							JQXLite._queueHooks(this, type);

							if (type === "fx" && queue[0] !== "inprogress") {
								JQXLite.dequeue(this, type);
							}
						});
				},
				dequeue: function (type) {
					return this.each(function () {
						JQXLite.dequeue(this, type);
					});
				},
				// Based off of the plugin by Clint Helfers, with permission.
				// http://blindsignals.com/index.php/2009/07/jqx-delay/
				delay: function (time, type) {
					time = JQXLite.fx ? JQXLite.fx.speeds[time] || time : time;
					type = type || "fx";

					return this.queue(type, function (next, hooks) {
						var timeout = setTimeout(next, time);
						hooks.stop = function () {
							clearTimeout(timeout);
						};
					});
				},
				clearQueue: function (type) {
					return this.queue(type || "fx", []);
				},
				// Get a promise resolved when queues of a certain type
				// are emptied (fx is the type by default)
				promise: function (type, obj) {
					var tmp,
						count = 1,
						defer = JQXLite.Deferred(),
						elements = this,
						i = this.length,
						resolve = function () {
							if (!(--count)) {
								defer.resolveWith(elements, [elements]);
							}
						};

					if (typeof type !== "string") {
						obj = type;
						type = undefined;
					}
					type = type || "fx";

					while (i--) {
						tmp = JQXLite._data(elements[i], type + "queueHooks");
						if (tmp && tmp.empty) {
							count++;
							tmp.empty.add(resolve);
						}
					}
					resolve();
					return defer.promise(obj);
				}
			});
			var nodeHook, boolHook, fixSpecified,
				rclass = /[\t\r\n]/g,
				rreturn = /\r/g,
				rtype = /^(?:button|input)$/i,
				rfocusable = /^(?:button|input|object|select|textarea)$/i,
				rclickable = /^a(?:rea|)$/i,
				rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
				getSetAttribute = JQXLite.support.getSetAttribute;

			JQXLite.fn.extend({
				attr: function (name, value) {
					return JQXLite.access(this, JQXLite.attr, name, value, arguments.length > 1);
				},

				removeAttr: function (name) {
					return this.each(function () {
						JQXLite.removeAttr(this, name);
					});
				},

				prop: function (name, value) {
					return JQXLite.access(this, JQXLite.prop, name, value, arguments.length > 1);
				},

				removeProp: function (name) {
					name = JQXLite.propFix[name] || name;
					return this.each(function () {
						// try/catch handles cases where IE balks (such as removing a property on window)
						try {
							this[name] = undefined;
							delete this[name];
						} catch (e) { }
					});
				},

				addClass: function (value) {
					var classNames, i, l, elem,
						setClass, c, cl;

					if (JQXLite.isFunction(value)) {
						return this.each(function (j) {
							JQXLite(this).addClass(value.call(this, j, this.className));
						});
					}

					if (value && typeof value === "string") {
						classNames = value.split(core_rspace);

						for (i = 0, l = this.length; i < l; i++) {
							elem = this[i];

							if (elem.nodeType === 1) {
								if (!elem.className && classNames.length === 1) {
									elem.className = value;

								} else {
									setClass = " " + elem.className + " ";

									for (c = 0, cl = classNames.length; c < cl; c++) {
										if (setClass.indexOf(" " + classNames[c] + " ") < 0) {
											setClass += classNames[c] + " ";
										}
									}
									elem.className = JQXLite.trim(setClass);
								}
							}
						}
					}

					return this;
				},

				removeClass: function (value) {
					var removes, className, elem, c, cl, i, l;

					if (JQXLite.isFunction(value)) {
						return this.each(function (j) {
							JQXLite(this).removeClass(value.call(this, j, this.className));
						});
					}
					if ((value && typeof value === "string") || value === undefined) {
						removes = (value || "").split(core_rspace);

						for (i = 0, l = this.length; i < l; i++) {
							elem = this[i];
							if (elem.nodeType === 1 && elem.className) {

								className = (" " + elem.className + " ").replace(rclass, " ");

								// loop over each item in the removal list
								for (c = 0, cl = removes.length; c < cl; c++) {
									// Remove until there is nothing to remove,
									while (className.indexOf(" " + removes[c] + " ") >= 0) {
										className = className.replace(" " + removes[c] + " ", " ");
									}
								}
								elem.className = value ? JQXLite.trim(className) : "";
							}
						}
					}

					return this;
				},

				toggleClass: function (value, stateVal) {
					var type = typeof value,
						isBool = typeof stateVal === "boolean";

					if (JQXLite.isFunction(value)) {
						return this.each(function (i) {
							JQXLite(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
						});
					}

					return this.each(function () {
						if (type === "string") {
							// toggle individual class names
							var className,
								i = 0,
								self = JQXLite(this),
								state = stateVal,
								classNames = value.split(core_rspace);

							while ((className = classNames[i++])) {
								// check each className given, space separated list
								state = isBool ? state : !self.hasClass(className);
								self[state ? "addClass" : "removeClass"](className);
							}

						} else if (type === "undefined" || type === "boolean") {
							if (this.className) {
								// store className if set
								JQXLite._data(this, "__className__", this.className);
							}

							// toggle whole className
							this.className = this.className || value === false ? "" : JQXLite._data(this, "__className__") || "";
						}
					});
				},

				hasClass: function (selector) {
					var className = " " + selector + " ",
						i = 0,
						l = this.length;
					for (; i < l; i++) {
						if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
							return true;
						}
					}

					return false;
				},

				val: function (value) {
					var hooks, ret, isFunction,
						elem = this[0];

					if (!arguments.length) {
						if (elem) {
							hooks = JQXLite.valHooks[elem.type] || JQXLite.valHooks[elem.nodeName.toLowerCase()];

							if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
								return ret;
							}

							ret = elem.value;

							return typeof ret === "string" ?
								// handle most common string cases
								ret.replace(rreturn, "") :
								// handle cases where value is null/undef or number
								ret == null ? "" : ret;
						}

						return;
					}

					isFunction = JQXLite.isFunction(value);

					return this.each(function (i) {
						var val,
							self = JQXLite(this);

						if (this.nodeType !== 1) {
							return;
						}

						if (isFunction) {
							val = value.call(this, i, self.val());
						} else {
							val = value;
						}

						// Treat null/undefined as ""; convert numbers to string
						if (val == null) {
							val = "";
						} else if (typeof val === "number") {
							val += "";
						} else if (JQXLite.isArray(val)) {
							val = JQXLite.map(val, function (value) {
								return value == null ? "" : value + "";
							});
						}

						hooks = JQXLite.valHooks[this.type] || JQXLite.valHooks[this.nodeName.toLowerCase()];

						// If set returns undefined, fall back to normal setting
						if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
							this.value = val;
						}
					});
				}
			});

			JQXLite.extend({
				valHooks: {
					option: {
						get: function (elem) {
							// attributes.value is undefined in Blackberry 4.7 but
							// uses .value. See #6932
							var val = elem.attributes.value;
							return !val || val.specified ? elem.value : elem.text;
						}
					},
					select: {
						get: function (elem) {
							var value, option,
								options = elem.options,
								index = elem.selectedIndex,
								one = elem.type === "select-one" || index < 0,
								values = one ? null : [],
								max = one ? index + 1 : options.length,
								i = index < 0 ?
									max :
									one ? index : 0;

							// Loop through all the selected options
							for (; i < max; i++) {
								option = options[i];

								// oldIE doesn't update selected after form reset (#2551)
								if ((option.selected || i === index) &&
									// Don't return options that are disabled or in a disabled optgroup
									(JQXLite.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
									(!option.parentNode.disabled || !JQXLite.nodeName(option.parentNode, "optgroup"))) {

									// Get the specific value for the option
									value = JQXLite(option).val();

									// We don't need an array for one selects
									if (one) {
										return value;
									}

									// Multi-Selects return an array
									values.push(value);
								}
							}

							return values;
						},

						set: function (elem, value) {
							var values = JQXLite.makeArray(value);

							JQXLite(elem).find("option").each(function () {
								this.selected = JQXLite.inArray(JQXLite(this).val(), values) >= 0;
							});

							if (!values.length) {
								elem.selectedIndex = -1;
							}
							return values;
						}
					}
				},

				// Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
				attrFn: {},

				attr: function (elem, name, value, pass) {
					var ret, hooks, notxml,
						nType = elem.nodeType;

					// don't get/set attributes on text, comment and attribute nodes
					if (!elem || nType === 3 || nType === 8 || nType === 2) {
						return;
					}

					if (pass && JQXLite.isFunction(JQXLite.fn[name])) {
						return JQXLite(elem)[name](value);
					}

					// Fallback to prop when attributes are not supported
					if (typeof elem.getAttribute === "undefined") {
						return JQXLite.prop(elem, name, value);
					}

					notxml = nType !== 1 || !JQXLite.isXMLDoc(elem);

					// All attributes are lowercase
					// Grab necessary hook if one is defined
					if (notxml) {
						name = name.toLowerCase();
						hooks = JQXLite.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook);
					}

					if (value !== undefined) {

						if (value === null) {
							JQXLite.removeAttr(elem, name);
							return;

						} else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
							return ret;

						} else {
							elem.setAttribute(name, value + "");
							return value;
						}

					} else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
						return ret;

					} else {

						ret = elem.getAttribute(name);

						// Non-existent attributes return null, we normalize to undefined
						return ret === null ?
							undefined :
							ret;
					}
				},

				removeAttr: function (elem, value) {
					var propName, attrNames, name, isBool,
						i = 0;

					if (value && elem.nodeType === 1) {

						attrNames = value.split(core_rspace);

						for (; i < attrNames.length; i++) {
							name = attrNames[i];

							if (name) {
								propName = JQXLite.propFix[name] || name;
								isBool = rboolean.test(name);

								// See #9699 for explanation of this approach (setting first, then removal)
								// Do not do this for boolean attributes (see #10870)
								if (!isBool) {
									JQXLite.attr(elem, name, "");
								}
								elem.removeAttribute(getSetAttribute ? name : propName);

								// Set corresponding property to false for boolean attributes
								if (isBool && propName in elem) {
									elem[propName] = false;
								}
							}
						}
					}
				},

				attrHooks: {
					type: {
						set: function (elem, value) {
							// We can't allow the type property to be changed (since it causes problems in IE)
							if (rtype.test(elem.nodeName) && elem.parentNode) {
								JQXLite.error("type property can't be changed");
							} else if (!JQXLite.support.radioValue && value === "radio" && JQXLite.nodeName(elem, "input")) {
								// Setting the type on a radio button after the value resets the value in IE6-9
								// Reset value to it's default in case type is set after value
								// This is for element creation
								var val = elem.value;
								elem.setAttribute("type", value);
								if (val) {
									elem.value = val;
								}
								return value;
							}
						}
					},
					// Use the value property for back compat
					// Use the nodeHook for button elements in IE6/7 (#1954)
					value: {
						get: function (elem, name) {
							if (nodeHook && JQXLite.nodeName(elem, "button")) {
								return nodeHook.get(elem, name);
							}
							return name in elem ?
								elem.value :
								null;
						},
						set: function (elem, value, name) {
							if (nodeHook && JQXLite.nodeName(elem, "button")) {
								return nodeHook.set(elem, value, name);
							}
							// Does not return so that setAttribute is also used
							elem.value = value;
						}
					}
				},

				propFix: {
					tabindex: "tabIndex",
					readonly: "readOnly",
					"for": "htmlFor",
					"class": "className",
					maxlength: "maxLength",
					cellspacing: "cellSpacing",
					cellpadding: "cellPadding",
					rowspan: "rowSpan",
					colspan: "colSpan",
					usemap: "useMap",
					frameborder: "frameBorder",
					contenteditable: "contentEditable"
				},

				prop: function (elem, name, value) {
					var ret, hooks, notxml,
						nType = elem.nodeType;

					// don't get/set properties on text, comment and attribute nodes
					if (!elem || nType === 3 || nType === 8 || nType === 2) {
						return;
					}

					notxml = nType !== 1 || !JQXLite.isXMLDoc(elem);

					if (notxml) {
						// Fix name and attach hooks
						name = JQXLite.propFix[name] || name;
						hooks = JQXLite.propHooks[name];
					}

					if (value !== undefined) {
						if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
							return ret;

						} else {
							return (elem[name] = value);
						}

					} else {
						if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
							return ret;

						} else {
							return elem[name];
						}
					}
				},

				propHooks: {
					tabIndex: {
						get: function (elem) {
							// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
							// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
							var attributeNode = elem.getAttributeNode("tabindex");

							return attributeNode && attributeNode.specified ?
								parseInt(attributeNode.value, 10) :
								rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
									0 :
									undefined;
						}
					}
				}
			});

			// Hook for boolean attributes
			boolHook = {
				get: function (elem, name) {
					// Align boolean attributes with corresponding properties
					// Fall back to attribute presence where some booleans are not supported
					var attrNode,
						property = JQXLite.prop(elem, name);
					return property === true || typeof property !== "boolean" && (attrNode = elem.getAttributeNode(name)) && attrNode.nodeValue !== false ?
						name.toLowerCase() :
						undefined;
				},
				set: function (elem, value, name) {
					var propName;
					if (value === false) {
						// Remove boolean attributes when set to false
						JQXLite.removeAttr(elem, name);
					} else {
						// value is true since we know at this point it's type boolean and not false
						// Set boolean attributes to the same name and set the DOM property
						propName = JQXLite.propFix[name] || name;
						if (propName in elem) {
							// Only set the IDL specifically if it already exists on the element
							elem[propName] = true;
						}

						elem.setAttribute(name, name.toLowerCase());
					}
					return name;
				}
			};

			// IE6/7 call enctype encoding
			if (!JQXLite.support.enctype) {
				JQXLite.propFix.enctype = "encoding";
			}

			var rformElems = /^(?:textarea|input|select)$/i,
				rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
				rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
				rkeyEvent = /^key/,
				rmouseEvent = /^(?:mouse|contextmenu)|click/,
				rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
				hoverHack = function (events) {
					return JQXLite.event.special.hover ? events : events.replace(rhoverHack, "mouseenter$1 mouseleave$1");
				};

			/*
			 * Helper functions for managing events -- not part of the public interface.
			 * Props to Dean Edwards' addEvent library for many of the ideas.
			 */
			JQXLite.event = {

				add: function (elem, types, handler, data, selector) {

					var elemData, eventHandle, events,
						t, tns, type, namespaces, handleObj,
						handleObjIn, handlers, special;

					// Don't attach events to noData or text/comment nodes (allow plain objects tho)
					if (elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = JQXLite._data(elem))) {
						return;
					}

					// Caller can pass in an object of custom data in lieu of the handler
					if (handler.handler) {
						handleObjIn = handler;
						handler = handleObjIn.handler;
						selector = handleObjIn.selector;
					}

					// Make sure that the handler has a unique ID, used to find/remove it later
					if (!handler.guid) {
						handler.guid = JQXLite.guid++;
					}

					// Init the element's event structure and main handler, if this is the first
					events = elemData.events;
					if (!events) {
						elemData.events = events = {};
					}
					eventHandle = elemData.handle;
					if (!eventHandle) {
						elemData.handle = eventHandle = function (e) {
							// Discard the second event of a JQXLite.event.trigger() and
							// when an event is called after a page has unloaded
							return typeof JQXLite !== "undefined" && (!e || JQXLite.event.triggered !== e.type) ?
								JQXLite.event.dispatch.apply(eventHandle.elem, arguments) :
								undefined;
						};
						// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
						eventHandle.elem = elem;
					}

					// Handle multiple events separated by a space
					// JQXLite(...).bind("mouseover mouseout", fn);
					types = JQXLite.trim(hoverHack(types)).split(" ");
					for (t = 0; t < types.length; t++) {

						tns = rtypenamespace.exec(types[t]) || [];
						type = tns[1];
						namespaces = (tns[2] || "").split(".").sort();

						// If event changes its type, use the special event handlers for the changed type
						special = JQXLite.event.special[type] || {};

						// If selector defined, determine special event api type, otherwise given type
						type = (selector ? special.delegateType : special.bindType) || type;

						// Update special based on newly reset type
						special = JQXLite.event.special[type] || {};

						// handleObj is passed to all event handlers
						handleObj = JQXLite.extend({
							type: type,
							origType: tns[1],
							data: data,
							handler: handler,
							guid: handler.guid,
							selector: selector,
							needsContext: selector && JQXLite.expr.match.needsContext.test(selector),
							namespace: namespaces.join(".")
						}, handleObjIn);

						// Init the event handler queue if we're the first
						handlers = events[type];
						if (!handlers) {
							handlers = events[type] = [];
							handlers.delegateCount = 0;

							// Only use addEventListener/attachEvent if the special events handler returns false
							if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
								// Bind the global event handler to the element
								if (elem.addEventListener) {
									if (data && data.passive !== undefined) {
										elem.addEventListener(type, eventHandle, data);
									}
									else {
										elem.addEventListener(type, eventHandle, false);
									}
								} else if (elem.attachEvent) {
									elem.attachEvent("on" + type, eventHandle);
								}
							}
						}

						if (special.add) {
							special.add.call(elem, handleObj);

							if (!handleObj.handler.guid) {
								handleObj.handler.guid = handler.guid;
							}
						}

						// Add to the element's handler list, delegates in front
						if (selector) {
							handlers.splice(handlers.delegateCount++, 0, handleObj);
						} else {
							handlers.push(handleObj);
						}

						// Keep track of which events have ever been used, for event optimization
						JQXLite.event.global[type] = true;
					}

					// Nullify elem to prevent memory leaks in IE
					elem = null;
				},

				global: {},

				// Detach an event or set of events from an element
				remove: function (elem, types, handler, selector, mappedTypes) {

					var t, tns, type, origType, namespaces, origCount,
						j, events, special, eventType, handleObj,
						elemData = JQXLite.hasData(elem) && JQXLite._data(elem);

					if (!elemData || !(events = elemData.events)) {
						return;
					}

					// Once for each type.namespace in types; type may be omitted
					types = JQXLite.trim(hoverHack(types || "")).split(" ");
					for (t = 0; t < types.length; t++) {
						tns = rtypenamespace.exec(types[t]) || [];
						type = origType = tns[1];
						namespaces = tns[2];

						// Unbind all events (on this namespace, if provided) for the element
						if (!type) {
							for (type in events) {
								JQXLite.event.remove(elem, type + types[t], handler, selector, true);
							}
							continue;
						}

						special = JQXLite.event.special[type] || {};
						type = (selector ? special.delegateType : special.bindType) || type;
						eventType = events[type] || [];
						origCount = eventType.length;
						namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

						// Remove matching events
						for (j = 0; j < eventType.length; j++) {
							handleObj = eventType[j];

							if ((mappedTypes || origType === handleObj.origType) &&
								(!handler || handler.guid === handleObj.guid) &&
								(!namespaces || namespaces.test(handleObj.namespace)) &&
								(!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
								eventType.splice(j--, 1);

								if (handleObj.selector) {
									eventType.delegateCount--;
								}
								if (special.remove) {
									special.remove.call(elem, handleObj);
								}
							}
						}

						// Remove generic event handler if we removed something and no more handlers exist
						// (avoids potential for endless recursion during removal of special event handlers)
						if (eventType.length === 0 && origCount !== eventType.length) {
							if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
								JQXLite.removeEvent(elem, type, elemData.handle);
							}

							delete events[type];
						}
					}

					// Remove the expando if it's no longer used
					if (JQXLite.isEmptyObject(events)) {
						delete elemData.handle;

						// removeData also checks for emptiness and clears the expando if empty
						// so use it instead of delete
						JQXLite.removeData(elem, "events", true);
					}
				},

				// Events that are safe to short-circuit if no handlers are attached.
				// Native DOM events should not be added, they may have inline handlers.
				customEvent: {
					"getData": true,
					"setData": true,
					"changeData": true
				},

				trigger: function (event, data, elem, onlyHandlers) {
					// Don't do events on text and comment nodes
					if (elem && (elem.nodeType === 3 || elem.nodeType === 8)) {
						return;
					}

					// Event object or event type
					var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
						type = event.type || event,
						namespaces = [];

					// focus/blur morphs to focusin/out; ensure we're not firing them right now
					if (rfocusMorph.test(type + JQXLite.event.triggered)) {
						return;
					}

					if (type.indexOf("!") >= 0) {
						// Exclusive events trigger only for the exact event (no namespaces)
						type = type.slice(0, -1);
						exclusive = true;
					}

					if (type.indexOf(".") >= 0) {
						// Namespaced trigger; create a regexp to match event type in handle()
						namespaces = type.split(".");
						type = namespaces.shift();
						namespaces.sort();
					}

					if ((!elem || JQXLite.event.customEvent[type]) && !JQXLite.event.global[type]) {
						// No JQXLite handlers for this event type, and it can't have inline handlers
						return;
					}

					// Caller can pass in an Event, Object, or just an event type string
					event = typeof event === "object" ?
						// JQXLite.Event object
						event[JQXLite.expando] ? event :
							// Object literal
							new JQXLite.Event(type, event) :
						// Just the event type (string)
						new JQXLite.Event(type);

					event.type = type;
					event.isTrigger = true;
					event.exclusive = exclusive;
					event.namespace = namespaces.join(".");
					event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
					ontype = type.indexOf(":") < 0 ? "on" + type : "";

					// Handle a global trigger
					if (!elem) {

						// TODO: Stop taunting the data cache; remove global events and always attach to document
						cache = JQXLite.cache;
						for (i in cache) {
							if (cache[i].events && cache[i].events[type]) {
								JQXLite.event.trigger(event, data, cache[i].handle.elem, true);
							}
						}
						return;
					}

					// Clean up the event in case it is being reused
					event.result = undefined;
					if (!event.target) {
						event.target = elem;
					}

					// Clone any incoming data and prepend the event, creating the handler arg list
					data = data != null ? JQXLite.makeArray(data) : [];
					data.unshift(event);

					// Allow special events to draw outside the lines
					special = JQXLite.event.special[type] || {};
					if (special.trigger && special.trigger.apply(elem, data) === false) {
						return;
					}

					// Determine event propagation path in advance, per W3C events spec (#9951)
					// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
					eventPath = [[elem, special.bindType || type]];
					if (!onlyHandlers && !special.noBubble && !JQXLite.isWindow(elem)) {

						bubbleType = special.delegateType || type;
						cur = rfocusMorph.test(bubbleType + type) ? elem : elem.parentNode;
						for (old = elem; cur; cur = cur.parentNode) {
							eventPath.push([cur, bubbleType]);
							old = cur;
						}

						// Only add window if we got to document (e.g., not plain obj or detached DOM)
						if (old === (elem.ownerDocument || document)) {
							eventPath.push([old.defaultView || old.parentWindow || window, bubbleType]);
						}
					}

					// Fire handlers on the event path
					for (i = 0; i < eventPath.length && !event.isPropagationStopped(); i++) {

						cur = eventPath[i][0];
						event.type = eventPath[i][1];

						handle = (JQXLite._data(cur, "events") || {})[event.type] && JQXLite._data(cur, "handle");
						if (handle) {
							handle.apply(cur, data);
						}
						// Note that this is a bare JS function and not a JQXLite handler
						handle = ontype && cur[ontype];
						if (handle && JQXLite.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
							event.preventDefault();
						}
					}
					event.type = type;

					// If nobody prevented the default action, do it now
					if (!onlyHandlers && !event.isDefaultPrevented()) {

						if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) &&
							!(type === "click" && JQXLite.nodeName(elem, "a")) && JQXLite.acceptData(elem)) {

							// Call a native DOM method on the target with the same name name as the event.
							// Can't use an .isFunction() check here because IE6/7 fails that test.
							// Don't do default actions on window, that's where global variables be (#6170)
							// IE<9 dies on focus/blur to hidden element (#1486)
							if (ontype && elem[type] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !JQXLite.isWindow(elem)) {

								// Don't re-trigger an onFOO event when we call its FOO() method
								old = elem[ontype];

								if (old) {
									elem[ontype] = null;
								}

								// Prevent re-triggering of the same event, since we already bubbled it above
								JQXLite.event.triggered = type;
								elem[type]();
								JQXLite.event.triggered = undefined;

								if (old) {
									elem[ontype] = old;
								}
							}
						}
					}

					return event.result;
				},

				dispatch: function (event) {

					// Make a writable JQXLite.Event from the native event object
					event = JQXLite.event.fix(event || window.event);

					var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
						handlers = ((JQXLite._data(this, "events") || {})[event.type] || []),
						delegateCount = handlers.delegateCount,
						args = core_slice.call(arguments),
						run_all = !event.exclusive && !event.namespace,
						special = JQXLite.event.special[event.type] || {},
						handlerQueue = [];

					// Use the fix-ed JQXLite.Event rather than the (read-only) native event
					args[0] = event;
					event.delegateTarget = this;

					// Call the preDispatch hook for the mapped type, and let it bail if desired
					if (special.preDispatch && special.preDispatch.call(this, event) === false) {
						return;
					}

					// Determine handlers that should run if there are delegated events
					// Avoid non-left-click bubbling in Firefox (#3861)
					if (delegateCount && !(event.button && event.type === "click")) {

						for (cur = event.target; cur != this; cur = cur.parentNode || this) {

							// Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
							if (cur.disabled !== true || event.type !== "click") {
								selMatch = {};
								matches = [];
								for (i = 0; i < delegateCount; i++) {
									handleObj = handlers[i];
									sel = handleObj.selector;

									if (selMatch[sel] === undefined) {
										selMatch[sel] = handleObj.needsContext ?
											JQXLite(sel, this).index(cur) >= 0 :
											JQXLite.find(sel, this, null, [cur]).length;
									}
									if (selMatch[sel]) {
										matches.push(handleObj);
									}
								}
								if (matches.length) {
									handlerQueue.push({ elem: cur, matches: matches });
								}
							}
						}
					}

					// Add the remaining (directly-bound) handlers
					if (handlers.length > delegateCount) {
						handlerQueue.push({ elem: this, matches: handlers.slice(delegateCount) });
					}

					// Run delegates first; they may want to stop propagation beneath us
					for (i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++) {
						matched = handlerQueue[i];
						event.currentTarget = matched.elem;

						for (j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++) {
							handleObj = matched.matches[j];

							// Triggered event must either 1) be non-exclusive and have no namespace, or
							// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
							if (run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test(handleObj.namespace)) {

								event.data = handleObj.data;
								event.handleObj = handleObj;

								ret = ((JQXLite.event.special[handleObj.origType] || {}).handle || handleObj.handler)
									.apply(matched.elem, args);

								if (ret !== undefined) {
									event.result = ret;
									if (ret === false) {
										event.preventDefault();
										event.stopPropagation();
									}
								}
							}
						}
					}

					// Call the postDispatch hook for the mapped type
					if (special.postDispatch) {
						special.postDispatch.call(this, event);
					}

					return event.result;
				},

				// Includes some event props shared by KeyEvent and MouseEvent
				// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
				props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

				fixHooks: {},

				keyHooks: {
					props: "char charCode key keyCode".split(" "),
					filter: function (event, original) {

						// Add which for key events
						if (event.which == null) {
							event.which = original.charCode != null ? original.charCode : original.keyCode;
						}

						return event;
					}
				},

				mouseHooks: {
					props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
					filter: function (event, original) {
						var eventDoc, doc, body,
							button = original.button,
							fromElement = original.fromElement;

						// Calculate pageX/Y if missing and clientX/Y available
						if (event.pageX == null && original.clientX != null) {
							eventDoc = event.target.ownerDocument || document;
							doc = eventDoc.documentElement;
							body = eventDoc.body;

							event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
							event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
						}

						// Add relatedTarget, if necessary
						if (!event.relatedTarget && fromElement) {
							event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
						}

						// Add which for click: 1 === left; 2 === middle; 3 === right
						// Note: button is not normalized, so don't use it
						if (!event.which && button !== undefined) {
							event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
						}

						return event;
					}
				},

				fix: function (event) {
					if (event[JQXLite.expando]) {
						return event;
					}

					// Create a writable copy of the event object and normalize some properties
					var i, prop,
						originalEvent = event,
						fixHook = JQXLite.event.fixHooks[event.type] || {},
						copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

					event = JQXLite.Event(originalEvent);

					for (i = copy.length; i;) {
						prop = copy[--i];
						event[prop] = originalEvent[prop];
					}

					// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
					if (!event.target) {
						event.target = originalEvent.srcElement || document;
					}

					// Target should not be a text node (#504, Safari)
					if (event.target.nodeType === 3) {
						event.target = event.target.parentNode;
					}

					// For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
					event.metaKey = !!event.metaKey;

					return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
				},

				special: {
					load: {
						// Prevent triggered image.load events from bubbling to window.load
						noBubble: true
					},

					focus: {
						delegateType: "focusin"
					},
					blur: {
						delegateType: "focusout"
					},

					beforeunload: {
						setup: function (data, namespaces, eventHandle) {
							// We only want to do this special case on windows
							if (JQXLite.isWindow(this)) {
								this.onbeforeunload = eventHandle;
							}
						},

						teardown: function (namespaces, eventHandle) {
							if (this.onbeforeunload === eventHandle) {
								this.onbeforeunload = null;
							}
						}
					}
				},

				simulate: function (type, elem, event, bubble) {
					// Piggyback on a donor event to simulate a different one.
					// Fake originalEvent to avoid donor's stopPropagation, but if the
					// simulated event prevents default then we do the same on the donor.
					var e = JQXLite.extend(
						new JQXLite.Event(),
						event,
						{
							type: type,
							isSimulated: true,
							originalEvent: {}
						}
					);
					if (bubble) {
						JQXLite.event.trigger(e, null, elem);
					} else {
						JQXLite.event.dispatch.call(elem, e);
					}
					if (e.isDefaultPrevented()) {
						event.preventDefault();
					}
				}
			};

			// Some plugins are using, but it's undocumented/deprecated and will be removed.
			// The 1.7 special event interface should provide all the hooks needed now.
			JQXLite.event.handle = JQXLite.event.dispatch;

			JQXLite.removeEvent = document.removeEventListener ?
				function (elem, type, handle) {
					if (elem.removeEventListener) {
						elem.removeEventListener(type, handle, false);
					}
				} :
				function (elem, type, handle) {
					var name = "on" + type;

					if (elem.detachEvent) {

						// #8545, #7054, preventing memory leaks for custom events in IE6-8
						// detachEvent needed property on element, by name of that event, to properly expose it to GC
						if (typeof elem[name] === "undefined") {
							elem[name] = null;
						}

						elem.detachEvent(name, handle);
					}
				};

			JQXLite.Event = function (src, props) {
				// Allow instantiation without the 'new' keyword
				if (!(this instanceof JQXLite.Event)) {
					return new JQXLite.Event(src, props);
				}

				// Event object
				if (src && src.type) {
					this.originalEvent = src;
					this.type = src.type;

					// Events bubbling up the document may have been marked as prevented
					// by a handler lower down the tree; reflect the correct value.
					this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
						src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

					// Event type
				} else {
					this.type = src;
				}

				// Put explicitly provided properties onto the event object
				if (props) {
					JQXLite.extend(this, props);
				}

				// Create a timestamp if incoming event doesn't have one
				this.timeStamp = src && src.timeStamp || JQXLite.now();

				// Mark it as fixed
				this[JQXLite.expando] = true;
			};

			function returnFalse() {
				return false;
			}
			function returnTrue() {
				return true;
			}

			// JQXLite.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
			// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
			JQXLite.Event.prototype = {
				preventDefault: function () {
					this.isDefaultPrevented = returnTrue;

					var e = this.originalEvent;
					if (!e) {
						return;
					}

					// if preventDefault exists run it on the original event
					if (e.preventDefault) {
						e.preventDefault();

						// otherwise set the returnValue property of the original event to false (IE)
					} else {
						e.returnValue = false;
					}
				},
				stopPropagation: function () {
					this.isPropagationStopped = returnTrue;

					var e = this.originalEvent;
					if (!e) {
						return;
					}
					// if stopPropagation exists run it on the original event
					if (e.stopPropagation) {
						e.stopPropagation();
					}
					// otherwise set the cancelBubble property of the original event to true (IE)
					e.cancelBubble = true;
				},
				stopImmediatePropagation: function () {
					this.isImmediatePropagationStopped = returnTrue;
					this.stopPropagation();
				},
				isDefaultPrevented: returnFalse,
				isPropagationStopped: returnFalse,
				isImmediatePropagationStopped: returnFalse
			};

			// Create mouseenter/leave events using mouseover/out and event-time checks
			JQXLite.each({
				mouseenter: "mouseover",
				mouseleave: "mouseout"
			}, function (orig, fix) {
				JQXLite.event.special[orig] = {
					delegateType: fix,
					bindType: fix,

					handle: function (event) {
						var ret,
							target = this,
							related = event.relatedTarget,
							handleObj = event.handleObj,
							selector = handleObj.selector;

						// For mousenter/leave call the handler if related is outside the target.
						// NB: No relatedTarget if the mouse left/entered the browser window
						if (!related || (related !== target && !JQXLite.contains(target, related))) {
							event.type = handleObj.origType;
							ret = handleObj.handler.apply(this, arguments);
							event.type = fix;
						}
						return ret;
					}
				};
			});

			JQXLite.fn.extend({

				on: function (types, selector, data, fn, /*INTERNAL*/ one) {
					var origFn, type;

					// Types can be a map of types/handlers
					if (typeof types === "object") {
						// ( types-Object, selector, data )
						if (typeof selector !== "string") { // && selector != null
							// ( types-Object, data )
							data = data || selector;
							selector = undefined;
						}
						for (type in types) {
							this.on(type, selector, data, types[type], one);
						}
						return this;
					}

					if (data == null && fn == null) {
						// ( types, fn )
						fn = selector;
						data = selector = undefined;
					} else if (fn == null) {
						if (typeof selector === "string") {
							// ( types, selector, fn )
							fn = data;
							data = undefined;
						} else {
							// ( types, data, fn )
							fn = data;
							data = selector;
							selector = undefined;
						}
					}
					if (fn === false) {
						fn = returnFalse;
					} else if (!fn) {
						return this;
					}

					if (one === 1) {
						origFn = fn;
						fn = function (event) {
							// Can use an empty set, since event contains the info
							JQXLite().off(event);
							return origFn.apply(this, arguments);
						};
						// Use same guid so caller can remove using origFn
						fn.guid = origFn.guid || (origFn.guid = JQXLite.guid++);
					}
					return this.each(function () {
						JQXLite.event.add(this, types, fn, data, selector);
					});
				},

				off: function (types, selector, fn) {
					var handleObj, type;
					if (types && types.preventDefault && types.handleObj) {
						// ( event )  dispatched JQXLite.Event
						handleObj = types.handleObj;
						JQXLite(types.delegateTarget).off(
							handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
							handleObj.selector,
							handleObj.handler
						);
						return this;
					}
					if (typeof types === "object") {
						// ( types-object [, selector] )
						for (type in types) {
							this.off(type, selector, types[type]);
						}
						return this;
					}
					if (selector === false || typeof selector === "function") {
						// ( types [, fn] )
						fn = selector;
						selector = undefined;
					}
					if (fn === false) {
						fn = returnFalse;
					}
					return this.each(function () {
						JQXLite.event.remove(this, types, fn, selector);
					});
				},

				delegate: function (selector, types, data, fn) {
					return this.on(types, selector, data, fn);
				},
				undelegate: function (selector, types, fn) {
					// ( namespace ) or ( selector, types [, fn] )
					return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
				},

				trigger: function (type, data) {
					return this.each(function () {
						JQXLite.event.trigger(type, data, this);
					});
				},
				triggerHandler: function (type, data) {
					if (this[0]) {
						return JQXLite.event.trigger(type, data, this[0], true);
					}
				},

				toggle: function (fn) {
					// Save reference to arguments for access in closure
					var args = arguments,
						guid = fn.guid || JQXLite.guid++,
						i = 0,
						toggler = function (event) {
							// Figure out which function to execute
							var lastToggle = (JQXLite._data(this, "lastToggle" + fn.guid) || 0) % i;
							JQXLite._data(this, "lastToggle" + fn.guid, lastToggle + 1);

							// Make sure that clicks stop
							event.preventDefault();

							// and execute the function
							return args[lastToggle].apply(this, arguments) || false;
						};

					// link all the functions, so any of them can unbind this click handler
					toggler.guid = guid;
					while (i < args.length) {
						args[i++].guid = guid;
					}

					return this.click(toggler);
				},

				hover: function (fnOver, fnOut) {
					return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
				}
			});

			JQXLite.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
				"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
				"change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

					// Handle event binding
					JQXLite.fn[name] = function (data, fn) {
						if (fn == null) {
							fn = data;
							data = null;
						}

						return arguments.length > 0 ?
							this.on(name, null, data, fn) :
							this.trigger(name);
					};

					if (rkeyEvent.test(name)) {
						JQXLite.event.fixHooks[name] = JQXLite.event.keyHooks;
					}

					if (rmouseEvent.test(name)) {
						JQXLite.event.fixHooks[name] = JQXLite.event.mouseHooks;
					}
				});
			/*!
			 * Sizzle CSS Selector Engine
			 * Copyright 2012 JQXLite Foundation and other contributors
			 * Released under the MIT license
			 * http://sizzlejs.com/
			 */
			(function (window, undefined) {

				var cachedruns,
					assertGetIdNotName,
					Expr,
					getText,
					isXML,
					contains,
					compile,
					sortOrder,
					hasDuplicate,
					outermostContext,

					baseHasDuplicate = true,
					strundefined = "undefined",

					expando = ("sizcache" + Math.random()).replace(".", ""),

					Token = String,
					document = window.document,
					docElem = document.documentElement,
					dirruns = 0,
					done = 0,
					pop = [].pop,
					push = [].push,
					slice = [].slice,
					// Use a stripped-down indexOf if a native one is unavailable
					indexOf = [].indexOf || function (elem) {
						var i = 0,
							len = this.length;
						for (; i < len; i++) {
							if (this[i] === elem) {
								return i;
							}
						}
						return -1;
					},

					// Augment a function for special use by Sizzle
					markFunction = function (fn, value) {
						fn[expando] = value == null || value;
						return fn;
					},

					createCache = function () {
						var cache = {},
							keys = [];

						return markFunction(function (key, value) {
							// Only keep the most recent entries
							if (keys.push(key) > Expr.cacheLength) {
								delete cache[keys.shift()];
							}

							// Retrieve with (key + " ") to avoid collision with native Object.prototype properties (see Issue #157)
							return (cache[key + " "] = value);
						}, cache);
					},

					classCache = createCache(),
					tokenCache = createCache(),
					compilerCache = createCache(),

					// Regex

					// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
					whitespace = "[\\x20\\t\\r\\n\\f]",
					// http://www.w3.org/TR/css3-syntax/#characters
					characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

					// Loosely modeled on CSS identifier characters
					// An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
					// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
					identifier = characterEncoding.replace("w", "w#"),

					// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
					operators = "([*^$|!~]?=)",
					attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
						"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

					// Prefer arguments not in parens/brackets,
					//   then attribute selectors and non-pseudos (denoted by :),
					//   then anything else
					// These preferences are here to reduce the number of selectors
					//   needing tokenize in the PSEUDO preFilter
					pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

					// For matchExpr.POS and matchExpr.needsContext
					pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
						"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",

					// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
					rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

					rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
					rcombinators = new RegExp("^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*"),
					rpseudo = new RegExp(pseudos),

					// Easily-parseable/retrievable ID or TAG or CLASS selectors
					rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

					rnot = /^:not/,
					rsibling = /[\x20\t\r\n\f]*[+~]/,
					rendsWithNot = /:not\($/,

					rheader = /h\d/i,
					rinputs = /input|select|textarea|button/i,

					rbackslash = /\\(?!\\)/g,

					matchExpr = {
						"ID": new RegExp("^#(" + characterEncoding + ")"),
						"CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
						"NAME": new RegExp("^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]"),
						"TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
						"ATTR": new RegExp("^" + attributes),
						"PSEUDO": new RegExp("^" + pseudos),
						"POS": new RegExp(pos, "i"),
						"CHILD": new RegExp("^:(only|nth|first|last)-child(?:\\(" + whitespace +
							"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
							"*(\\d+)|))" + whitespace + "*\\)|)", "i"),
						// For use in libraries implementing .is()
						"needsContext": new RegExp("^" + whitespace + "*[>+~]|" + pos, "i")
					},

					// Support

					// Used for testing something on an element
					assert = function (fn) {
						var div = document.createElement("div");

						try {
							return fn(div);
						} catch (e) {
							return false;
						} finally {
							// release memory in IE
							div = null;
						}
					},

					// Check if getElementsByTagName("*") returns only elements
					assertTagNameNoComments = assert(function (div) {
						div.appendChild(document.createComment(""));
						return !div.getElementsByTagName("*").length;
					}),

					// Check if getAttribute returns normalized href attributes
					assertHrefNotNormalized = assert(function (div) {
						div.innerHTML = "<a href='#'></a>";
						return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
							div.firstChild.getAttribute("href") === "#";
					}),

					// Check if attributes should be retrieved by attribute nodes
					assertAttributes = assert(function (div) {
						div.innerHTML = "<select></select>";
						var type = typeof div.lastChild.getAttribute("multiple");
						// IE8 returns a string for some attributes even when not present
						return type !== "boolean" && type !== "string";
					}),

					// Check if getElementsByClassName can be trusted
					assertUsableClassName = assert(function (div) {
						// Opera can't find a second classname (in 9.6)
						div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
						if (!div.getElementsByClassName || !div.getElementsByClassName("e").length) {
							return false;
						}

						// Safari 3.2 caches class attributes and doesn't catch changes
						div.lastChild.className = "e";
						return div.getElementsByClassName("e").length === 2;
					}),

					// Check if getElementById returns elements by name
					// Check if getElementsByName privileges form controls or returns elements by ID
					assertUsableName = assert(function (div) {
						// Inject content
						div.id = expando + 0;
						div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
						docElem.insertBefore(div, docElem.firstChild);

						// Test
						var pass = document.getElementsByName &&
							// buggy browsers will return fewer than the correct 2
							document.getElementsByName(expando).length === 2 +
							// buggy browsers will return more than the correct 0
							document.getElementsByName(expando + 0).length;
						assertGetIdNotName = !document.getElementById(expando);

						// Cleanup
						docElem.removeChild(div);

						return pass;
					});

				// If slice is not available, provide a backup
				try {
					slice.call(docElem.childNodes, 0)[0].nodeType;
				} catch (e) {
					slice = function (i) {
						var elem,
							results = [];
						for (; (elem = this[i]); i++) {
							results.push(elem);
						}
						return results;
					};
				}

				function Sizzle(selector, context, results, seed) {
					results = results || [];
					context = context || document;
					var match, elem, xml, m,
						nodeType = context.nodeType;

					if (!selector || typeof selector !== "string") {
						return results;
					}

					if (nodeType !== 1 && nodeType !== 9) {
						return [];
					}

					xml = isXML(context);

					if (!xml && !seed) {
						if ((match = rquickExpr.exec(selector))) {
							// Speed-up: Sizzle("#ID")
							if ((m = match[1])) {
								if (nodeType === 9) {
									elem = context.getElementById(m);
									// Check parentNode to catch when Blackberry 4.6 returns
									// nodes that are no longer in the document #6963
									if (elem && elem.parentNode) {
										// Handle the case where IE, Opera, and Webkit return items
										// by name instead of ID
										if (elem.id === m) {
											results.push(elem);
											return results;
										}
									} else {
										return results;
									}
								} else {
									// Context is not a document
									if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
										contains(context, elem) && elem.id === m) {
										results.push(elem);
										return results;
									}
								}

								// Speed-up: Sizzle("TAG")
							} else if (match[2]) {
								push.apply(results, slice.call(context.getElementsByTagName(selector), 0));
								return results;

								// Speed-up: Sizzle(".CLASS")
							} else if ((m = match[3]) && assertUsableClassName && context.getElementsByClassName) {
								push.apply(results, slice.call(context.getElementsByClassName(m), 0));
								return results;
							}
						}
					}

					// All others
					return select(selector.replace(rtrim, "$1"), context, results, seed, xml);
				}

				Sizzle.matches = function (expr, elements) {
					return Sizzle(expr, null, null, elements);
				};

				Sizzle.matchesSelector = function (elem, expr) {
					return Sizzle(expr, null, null, [elem]).length > 0;
				};

				// Returns a function to use in pseudos for input types
				function createInputPseudo(type) {
					return function (elem) {
						var name = elem.nodeName.toLowerCase();
						return name === "input" && elem.type === type;
					};
				}

				// Returns a function to use in pseudos for buttons
				function createButtonPseudo(type) {
					return function (elem) {
						var name = elem.nodeName.toLowerCase();
						return (name === "input" || name === "button") && elem.type === type;
					};
				}

				// Returns a function to use in pseudos for positionals
				function createPositionalPseudo(fn) {
					return markFunction(function (argument) {
						argument = +argument;
						return markFunction(function (seed, matches) {
							var j,
								matchIndexes = fn([], seed.length, argument),
								i = matchIndexes.length;

							// Match elements found at the specified indexes
							while (i--) {
								if (seed[(j = matchIndexes[i])]) {
									seed[j] = !(matches[j] = seed[j]);
								}
							}
						});
					});
				}

				/**
				 * Utility function for retrieving the text value of an array of DOM nodes
				 * @param {Array|Element} elem
				 */
				getText = Sizzle.getText = function (elem) {
					var node,
						ret = "",
						i = 0,
						nodeType = elem.nodeType;

					if (nodeType) {
						if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
							// Use textContent for elements
							// innerText usage removed for consistency of new lines (see #11153)
							if (typeof elem.textContent === "string") {
								return elem.textContent;
							} else {
								// Traverse its children
								for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
									ret += getText(elem);
								}
							}
						} else if (nodeType === 3 || nodeType === 4) {
							return elem.nodeValue;
						}
						// Do not include comment or processing instruction nodes
					} else {

						// If no nodeType, this is expected to be an array
						for (; (node = elem[i]); i++) {
							// Do not traverse comment nodes
							ret += getText(node);
						}
					}
					return ret;
				};

				isXML = Sizzle.isXML = function (elem) {
					// documentElement is verified for cases where it doesn't yet exist
					// (such as loading iframes in IE - #4833)
					var documentElement = elem && (elem.ownerDocument || elem).documentElement;
					return documentElement ? documentElement.nodeName !== "HTML" : false;
				};

				// Element contains another
				contains = Sizzle.contains = docElem.contains ?
					function (a, b) {
						var adown = a.nodeType === 9 ? a.documentElement : a,
							bup = b && b.parentNode;
						return a === bup || !!(bup && bup.nodeType === 1 && adown.contains && adown.contains(bup));
					} :
					docElem.compareDocumentPosition ?
						function (a, b) {
							return b && !!(a.compareDocumentPosition(b) & 16);
						} :
						function (a, b) {
							while ((b = b.parentNode)) {
								if (b === a) {
									return true;
								}
							}
							return false;
						};

				Sizzle.attr = function (elem, name) {
					var val,
						xml = isXML(elem);

					if (!xml) {
						name = name.toLowerCase();
					}
					if ((val = Expr.attrHandle[name])) {
						return val(elem);
					}
					if (xml || assertAttributes) {
						return elem.getAttribute(name);
					}
					val = elem.getAttributeNode(name);
					return val ?
						typeof elem[name] === "boolean" ?
							elem[name] ? name : null :
							val.specified ? val.value : null :
						null;
				};

				Expr = Sizzle.selectors = {

					// Can be adjusted by the user
					cacheLength: 50,

					createPseudo: markFunction,

					match: matchExpr,

					// IE6/7 return a modified href
					attrHandle: assertHrefNotNormalized ?
						{} :
						{
							"href": function (elem) {
								return elem.getAttribute("href", 2);
							},
							"type": function (elem) {
								return elem.getAttribute("type");
							}
						},

					find: {
						"ID": assertGetIdNotName ?
							function (id, context, xml) {
								if (typeof context.getElementById !== strundefined && !xml) {
									var m = context.getElementById(id);
									// Check parentNode to catch when Blackberry 4.6 returns
									// nodes that are no longer in the document #6963
									return m && m.parentNode ? [m] : [];
								}
							} :
							function (id, context, xml) {
								if (typeof context.getElementById !== strundefined && !xml) {
									var m = context.getElementById(id);

									return m ?
										m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
											[m] :
											undefined :
										[];
								}
							},

						"TAG": assertTagNameNoComments ?
							function (tag, context) {
								if (typeof context.getElementsByTagName !== strundefined) {
									return context.getElementsByTagName(tag);
								}
							} :
							function (tag, context) {
								var results = context.getElementsByTagName(tag);

								// Filter out possible comments
								if (tag === "*") {
									var elem,
										tmp = [],
										i = 0;

									for (; (elem = results[i]); i++) {
										if (elem.nodeType === 1) {
											tmp.push(elem);
										}
									}

									return tmp;
								}
								return results;
							},

						"NAME": assertUsableName && function (tag, context) {
							if (typeof context.getElementsByName !== strundefined) {
								return context.getElementsByName(name);
							}
						},

						"CLASS": assertUsableClassName && function (className, context, xml) {
							if (typeof context.getElementsByClassName !== strundefined && !xml) {
								return context.getElementsByClassName(className);
							}
						}
					},

					relative: {
						">": { dir: "parentNode", first: true },
						" ": { dir: "parentNode" },
						"+": { dir: "previousSibling", first: true },
						"~": { dir: "previousSibling" }
					},

					preFilter: {
						"ATTR": function (match) {
							match[1] = match[1].replace(rbackslash, "");

							// Move the given value to match[3] whether quoted or unquoted
							match[3] = (match[4] || match[5] || "").replace(rbackslash, "");

							if (match[2] === "~=") {
								match[3] = " " + match[3] + " ";
							}

							return match.slice(0, 4);
						},

						"CHILD": function (match) {
							/* matches from matchExpr["CHILD"]
								1 type (only|nth|...)
								2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
								3 xn-component of xn+y argument ([+-]?\d*n|)
								4 sign of xn-component
								5 x of xn-component
								6 sign of y-component
								7 y of y-component
							*/
							match[1] = match[1].toLowerCase();

							if (match[1] === "nth") {
								// nth-child requires argument
								if (!match[2]) {
									Sizzle.error(match[0]);
								}

								// numeric x and y parameters for Expr.filter.CHILD
								// remember that false/true cast respectively to 0/1
								match[3] = +(match[3] ? match[4] + (match[5] || 1) : 2 * (match[2] === "even" || match[2] === "odd"));
								match[4] = +((match[6] + match[7]) || match[2] === "odd");

								// other types prohibit arguments
							} else if (match[2]) {
								Sizzle.error(match[0]);
							}

							return match;
						},

						"PSEUDO": function (match) {
							var unquoted, excess;
							if (matchExpr["CHILD"].test(match[0])) {
								return null;
							}

							if (match[3]) {
								match[2] = match[3];
							} else if ((unquoted = match[4])) {
								// Only check arguments that contain a pseudo
								if (rpseudo.test(unquoted) &&
									// Get excess from tokenize (recursively)
									(excess = tokenize(unquoted, true)) &&
									// advance to the next closing parenthesis
									(excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

									// excess is a negative index
									unquoted = unquoted.slice(0, excess);
									match[0] = match[0].slice(0, excess);
								}
								match[2] = unquoted;
							}

							// Return only captures needed by the pseudo filter method (type and argument)
							return match.slice(0, 3);
						}
					},

					filter: {
						"ID": assertGetIdNotName ?
							function (id) {
								id = id.replace(rbackslash, "");
								return function (elem) {
									return elem.getAttribute("id") === id;
								};
							} :
							function (id) {
								id = id.replace(rbackslash, "");
								return function (elem) {
									var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
									return node && node.value === id;
								};
							},

						"TAG": function (nodeName) {
							if (nodeName === "*") {
								return function () { return true; };
							}
							nodeName = nodeName.replace(rbackslash, "").toLowerCase();

							return function (elem) {
								return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
							};
						},

						"CLASS": function (className) {
							var pattern = classCache[expando][className + " "];

							return pattern ||
								(pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
								classCache(className, function (elem) {
									return pattern.test(elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "");
								});
						},

						"ATTR": function (name, operator, check) {
							return function (elem, context) {
								var result = Sizzle.attr(elem, name);

								if (result == null) {
									return operator === "!=";
								}
								if (!operator) {
									return true;
								}

								result += "";

								return operator === "=" ? result === check :
									operator === "!=" ? result !== check :
										operator === "^=" ? check && result.indexOf(check) === 0 :
											operator === "*=" ? check && result.indexOf(check) > -1 :
												operator === "$=" ? check && result.substr(result.length - check.length) === check :
													operator === "~=" ? (" " + result + " ").indexOf(check) > -1 :
														operator === "|=" ? result === check || result.substr(0, check.length + 1) === check + "-" :
															false;
							};
						},

						"CHILD": function (type, argument, first, last) {

							if (type === "nth") {
								return function (elem) {
									var node, diff,
										parent = elem.parentNode;

									if (first === 1 && last === 0) {
										return true;
									}

									if (parent) {
										diff = 0;
										for (node = parent.firstChild; node; node = node.nextSibling) {
											if (node.nodeType === 1) {
												diff++;
												if (elem === node) {
													break;
												}
											}
										}
									}

									// Incorporate the offset (or cast to NaN), then check against cycle size
									diff -= last;
									return diff === first || (diff % first === 0 && diff / first >= 0);
								};
							}

							return function (elem) {
								var node = elem;

								switch (type) {
									case "only":
									case "first":
										while ((node = node.previousSibling)) {
											if (node.nodeType === 1) {
												return false;
											}
										}

										if (type === "first") {
											return true;
										}

										node = elem;

									/* falls through */
									case "last":
										while ((node = node.nextSibling)) {
											if (node.nodeType === 1) {
												return false;
											}
										}

										return true;
								}
							};
						},

						"PSEUDO": function (pseudo, argument) {
							// pseudo-class names are case-insensitive
							// http://www.w3.org/TR/selectors/#pseudo-classes
							// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
							// Remember that setFilters inherits from pseudos
							var args,
								fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
									Sizzle.error("unsupported pseudo: " + pseudo);

							// The user may use createPseudo to indicate that
							// arguments are needed to create the filter function
							// just as Sizzle does
							if (fn[expando]) {
								return fn(argument);
							}

							// But maintain support for old signatures
							if (fn.length > 1) {
								args = [pseudo, pseudo, "", argument];
								return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
									markFunction(function (seed, matches) {
										var idx,
											matched = fn(seed, argument),
											i = matched.length;
										while (i--) {
											idx = indexOf.call(seed, matched[i]);
											seed[idx] = !(matches[idx] = matched[i]);
										}
									}) :
									function (elem) {
										return fn(elem, 0, args);
									};
							}

							return fn;
						}
					},

					pseudos: {
						"not": markFunction(function (selector) {
							// Trim the selector passed to compile
							// to avoid treating leading and trailing
							// spaces as combinators
							var input = [],
								results = [],
								matcher = compile(selector.replace(rtrim, "$1"));

							return matcher[expando] ?
								markFunction(function (seed, matches, context, xml) {
									var elem,
										unmatched = matcher(seed, null, xml, []),
										i = seed.length;

									// Match elements unmatched by `matcher`
									while (i--) {
										if ((elem = unmatched[i])) {
											seed[i] = !(matches[i] = elem);
										}
									}
								}) :
								function (elem, context, xml) {
									input[0] = elem;
									matcher(input, null, xml, results);
									return !results.pop();
								};
						}),

						"has": markFunction(function (selector) {
							return function (elem) {
								return Sizzle(selector, elem).length > 0;
							};
						}),

						"contains": markFunction(function (text) {
							return function (elem) {
								return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
							};
						}),

						"enabled": function (elem) {
							return elem.disabled === false;
						},

						"disabled": function (elem) {
							return elem.disabled === true;
						},

						"checked": function (elem) {
							// In CSS3, :checked should return both checked and selected elements
							// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
							var nodeName = elem.nodeName.toLowerCase();
							return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
						},

						"selected": function (elem) {
							// Accessing this property makes selected-by-default
							// options in Safari work properly
							if (elem.parentNode) {
								elem.parentNode.selectedIndex;
							}

							return elem.selected === true;
						},

						"parent": function (elem) {
							return !Expr.pseudos["empty"](elem);
						},

						"empty": function (elem) {
							// http://www.w3.org/TR/selectors/#empty-pseudo
							// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
							//   not comment, processing instructions, or others
							// Thanks to Diego Perini for the nodeName shortcut
							//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
							var nodeType;
							elem = elem.firstChild;
							while (elem) {
								if (elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4) {
									return false;
								}
								elem = elem.nextSibling;
							}
							return true;
						},

						"header": function (elem) {
							return rheader.test(elem.nodeName);
						},

						"text": function (elem) {
							var type, attr;
							// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
							// use getAttribute instead to test this case
							return elem.nodeName.toLowerCase() === "input" &&
								(type = elem.type) === "text" &&
								((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type);
						},

						// Input types
						"radio": createInputPseudo("radio"),
						"checkbox": createInputPseudo("checkbox"),
						"file": createInputPseudo("file"),
						"password": createInputPseudo("password"),
						"image": createInputPseudo("image"),

						"submit": createButtonPseudo("submit"),
						"reset": createButtonPseudo("reset"),

						"button": function (elem) {
							var name = elem.nodeName.toLowerCase();
							return name === "input" && elem.type === "button" || name === "button";
						},

						"input": function (elem) {
							return rinputs.test(elem.nodeName);
						},

						"focus": function (elem) {
							var doc = elem.ownerDocument;
							return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
						},

						"active": function (elem) {
							return elem === elem.ownerDocument.activeElement;
						},

						// Positional types
						"first": createPositionalPseudo(function () {
							return [0];
						}),

						"last": createPositionalPseudo(function (matchIndexes, length) {
							return [length - 1];
						}),

						"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
							return [argument < 0 ? argument + length : argument];
						}),

						"even": createPositionalPseudo(function (matchIndexes, length) {
							for (var i = 0; i < length; i += 2) {
								matchIndexes.push(i);
							}
							return matchIndexes;
						}),

						"odd": createPositionalPseudo(function (matchIndexes, length) {
							for (var i = 1; i < length; i += 2) {
								matchIndexes.push(i);
							}
							return matchIndexes;
						}),

						"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
							for (var i = argument < 0 ? argument + length : argument; --i >= 0;) {
								matchIndexes.push(i);
							}
							return matchIndexes;
						}),

						"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
							for (var i = argument < 0 ? argument + length : argument; ++i < length;) {
								matchIndexes.push(i);
							}
							return matchIndexes;
						})
					}
				};

				function siblingCheck(a, b, ret) {
					if (a === b) {
						return ret;
					}

					var cur = a.nextSibling;

					while (cur) {
						if (cur === b) {
							return -1;
						}

						cur = cur.nextSibling;
					}

					return 1;
				}

				sortOrder = docElem.compareDocumentPosition ?
					function (a, b) {
						if (a === b) {
							hasDuplicate = true;
							return 0;
						}

						return (!a.compareDocumentPosition || !b.compareDocumentPosition ?
							a.compareDocumentPosition :
							a.compareDocumentPosition(b) & 4
						) ? -1 : 1;
					} :
					function (a, b) {
						// The nodes are identical, we can exit early
						if (a === b) {
							hasDuplicate = true;
							return 0;

							// Fallback to using sourceIndex (in IE) if it's available on both nodes
						} else if (a.sourceIndex && b.sourceIndex) {
							return a.sourceIndex - b.sourceIndex;
						}

						var al, bl,
							ap = [],
							bp = [],
							aup = a.parentNode,
							bup = b.parentNode,
							cur = aup;

						// If the nodes are siblings (or identical) we can do a quick check
						if (aup === bup) {
							return siblingCheck(a, b);

							// If no parents were found then the nodes are disconnected
						} else if (!aup) {
							return -1;

						} else if (!bup) {
							return 1;
						}

						// Otherwise they're somewhere else in the tree so we need
						// to build up a full list of the parentNodes for comparison
						while (cur) {
							ap.unshift(cur);
							cur = cur.parentNode;
						}

						cur = bup;

						while (cur) {
							bp.unshift(cur);
							cur = cur.parentNode;
						}

						al = ap.length;
						bl = bp.length;

						// Start walking down the tree looking for a discrepancy
						for (var i = 0; i < al && i < bl; i++) {
							if (ap[i] !== bp[i]) {
								return siblingCheck(ap[i], bp[i]);
							}
						}

						// We ended someplace up the tree so do a sibling check
						return i === al ?
							siblingCheck(a, bp[i], -1) :
							siblingCheck(ap[i], b, 1);
					};

				// Always assume the presence of duplicates if sort doesn't
				// pass them to our comparison function (as in Google Chrome).
				[0, 0].sort(sortOrder);
				baseHasDuplicate = !hasDuplicate;

				// Document sorting and removing duplicates
				Sizzle.uniqueSort = function (results) {
					var elem,
						duplicates = [],
						i = 1,
						j = 0;

					hasDuplicate = baseHasDuplicate;
					results.sort(sortOrder);

					if (hasDuplicate) {
						for (; (elem = results[i]); i++) {
							if (elem === results[i - 1]) {
								j = duplicates.push(i);
							}
						}
						while (j--) {
							results.splice(duplicates[j], 1);
						}
					}

					return results;
				};

				Sizzle.error = function (msg) {
					throw new Error("Syntax error, unrecognized expression: " + msg);
				};

				function tokenize(selector, parseOnly) {
					var matched, match, tokens, type,
						soFar, groups, preFilters,
						cached = tokenCache[expando][selector + " "];

					if (cached) {
						return parseOnly ? 0 : cached.slice(0);
					}

					soFar = selector;
					groups = [];
					preFilters = Expr.preFilter;

					while (soFar) {

						// Comma and first run
						if (!matched || (match = rcomma.exec(soFar))) {
							if (match) {
								// Don't consume trailing commas as valid
								soFar = soFar.slice(match[0].length) || soFar;
							}
							groups.push(tokens = []);
						}

						matched = false;

						// Combinators
						if ((match = rcombinators.exec(soFar))) {
							tokens.push(matched = new Token(match.shift()));
							soFar = soFar.slice(matched.length);

							// Cast descendant combinators to space
							matched.type = match[0].replace(rtrim, " ");
						}

						// Filters
						for (type in Expr.filter) {
							if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
								(match = preFilters[type](match)))) {

								tokens.push(matched = new Token(match.shift()));
								soFar = soFar.slice(matched.length);
								matched.type = type;
								matched.matches = match;
							}
						}

						if (!matched) {
							break;
						}
					}

					// Return the length of the invalid excess
					// if we're just parsing
					// Otherwise, throw an error or return tokens
					return parseOnly ?
						soFar.length :
						soFar ?
							Sizzle.error(selector) :
							// Cache the tokens
							tokenCache(selector, groups).slice(0);
				}

				function addCombinator(matcher, combinator, base) {
					var dir = combinator.dir,
						checkNonElements = base && combinator.dir === "parentNode",
						doneName = done++;

					return combinator.first ?
						// Check against closest ancestor/preceding element
						function (elem, context, xml) {
							while ((elem = elem[dir])) {
								if (checkNonElements || elem.nodeType === 1) {
									return matcher(elem, context, xml);
								}
							}
						} :

						// Check against all ancestor/preceding elements
						function (elem, context, xml) {
							// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
							if (!xml) {
								var cache,
									dirkey = dirruns + " " + doneName + " ",
									cachedkey = dirkey + cachedruns;
								while ((elem = elem[dir])) {
									if (checkNonElements || elem.nodeType === 1) {
										if ((cache = elem[expando]) === cachedkey) {
											return elem.sizset;
										} else if (typeof cache === "string" && cache.indexOf(dirkey) === 0) {
											if (elem.sizset) {
												return elem;
											}
										} else {
											elem[expando] = cachedkey;
											if (matcher(elem, context, xml)) {
												elem.sizset = true;
												return elem;
											}
											elem.sizset = false;
										}
									}
								}
							} else {
								while ((elem = elem[dir])) {
									if (checkNonElements || elem.nodeType === 1) {
										if (matcher(elem, context, xml)) {
											return elem;
										}
									}
								}
							}
						};
				}

				function elementMatcher(matchers) {
					return matchers.length > 1 ?
						function (elem, context, xml) {
							var i = matchers.length;
							while (i--) {
								if (!matchers[i](elem, context, xml)) {
									return false;
								}
							}
							return true;
						} :
						matchers[0];
				}

				function condense(unmatched, map, filter, context, xml) {
					var elem,
						newUnmatched = [],
						i = 0,
						len = unmatched.length,
						mapped = map != null;

					for (; i < len; i++) {
						if ((elem = unmatched[i])) {
							if (!filter || filter(elem, context, xml)) {
								newUnmatched.push(elem);
								if (mapped) {
									map.push(i);
								}
							}
						}
					}

					return newUnmatched;
				}

				function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
					if (postFilter && !postFilter[expando]) {
						postFilter = setMatcher(postFilter);
					}
					if (postFinder && !postFinder[expando]) {
						postFinder = setMatcher(postFinder, postSelector);
					}
					return markFunction(function (seed, results, context, xml) {
						var temp, i, elem,
							preMap = [],
							postMap = [],
							preexisting = results.length,

							// Get initial elements from seed or context
							elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

							// Prefilter to get matcher input, preserving a map for seed-results synchronization
							matcherIn = preFilter && (seed || !selector) ?
								condense(elems, preMap, preFilter, context, xml) :
								elems,

							matcherOut = matcher ?
								// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
								postFinder || (seed ? preFilter : preexisting || postFilter) ?

									// ...intermediate processing is necessary
									[] :

									// ...otherwise use results directly
									results :
								matcherIn;

						// Find primary matches
						if (matcher) {
							matcher(matcherIn, matcherOut, context, xml);
						}

						// Apply postFilter
						if (postFilter) {
							temp = condense(matcherOut, postMap);
							postFilter(temp, [], context, xml);

							// Un-match failing elements by moving them back to matcherIn
							i = temp.length;
							while (i--) {
								if ((elem = temp[i])) {
									matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
								}
							}
						}

						if (seed) {
							if (postFinder || preFilter) {
								if (postFinder) {
									// Get the final matcherOut by condensing this intermediate into postFinder contexts
									temp = [];
									i = matcherOut.length;
									while (i--) {
										if ((elem = matcherOut[i])) {
											// Restore matcherIn since elem is not yet a final match
											temp.push((matcherIn[i] = elem));
										}
									}
									postFinder(null, (matcherOut = []), temp, xml);
								}

								// Move matched elements from seed to results to keep them synchronized
								i = matcherOut.length;
								while (i--) {
									if ((elem = matcherOut[i]) &&
										(temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {

										seed[temp] = !(results[temp] = elem);
									}
								}
							}

							// Add elements to results, through postFinder if defined
						} else {
							matcherOut = condense(
								matcherOut === results ?
									matcherOut.splice(preexisting, matcherOut.length) :
									matcherOut
							);
							if (postFinder) {
								postFinder(null, results, matcherOut, xml);
							} else {
								push.apply(results, matcherOut);
							}
						}
					});
				}

				function matcherFromTokens(tokens) {
					var checkContext, matcher, j,
						len = tokens.length,
						leadingRelative = Expr.relative[tokens[0].type],
						implicitRelative = leadingRelative || Expr.relative[" "],
						i = leadingRelative ? 1 : 0,

						// The foundational matcher ensures that elements are reachable from top-level context(s)
						matchContext = addCombinator(function (elem) {
							return elem === checkContext;
						}, implicitRelative, true),
						matchAnyContext = addCombinator(function (elem) {
							return indexOf.call(checkContext, elem) > -1;
						}, implicitRelative, true),
						matchers = [function (elem, context, xml) {
							return (!leadingRelative && (xml || context !== outermostContext)) || (
								(checkContext = context).nodeType ?
									matchContext(elem, context, xml) :
									matchAnyContext(elem, context, xml));
						}];

					for (; i < len; i++) {
						if ((matcher = Expr.relative[tokens[i].type])) {
							matchers = [addCombinator(elementMatcher(matchers), matcher)];
						} else {
							matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

							// Return special upon seeing a positional matcher
							if (matcher[expando]) {
								// Find the next relative operator (if any) for proper handling
								j = ++i;
								for (; j < len; j++) {
									if (Expr.relative[tokens[j].type]) {
										break;
									}
								}
								return setMatcher(
									i > 1 && elementMatcher(matchers),
									i > 1 && tokens.slice(0, i - 1).join("").replace(rtrim, "$1"),
									matcher,
									i < j && matcherFromTokens(tokens.slice(i, j)),
									j < len && matcherFromTokens((tokens = tokens.slice(j))),
									j < len && tokens.join("")
								);
							}
							matchers.push(matcher);
						}
					}

					return elementMatcher(matchers);
				}

				function matcherFromGroupMatchers(elementMatchers, setMatchers) {
					var bySet = setMatchers.length > 0,
						byElement = elementMatchers.length > 0,
						superMatcher = function (seed, context, xml, results, expandContext) {
							var elem, j, matcher,
								setMatched = [],
								matchedCount = 0,
								i = "0",
								unmatched = seed && [],
								outermost = expandContext != null,
								contextBackup = outermostContext,
								// We must always have either seed elements or context
								elems = seed || byElement && Expr.find["TAG"]("*", expandContext && context.parentNode || context),
								// Nested matchers should use non-integer dirruns
								dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

							if (outermost) {
								outermostContext = context !== document && context;
								cachedruns = superMatcher.el;
							}

							// Add elements passing elementMatchers directly to results
							for (; (elem = elems[i]) != null; i++) {
								if (byElement && elem) {
									for (j = 0; (matcher = elementMatchers[j]); j++) {
										if (matcher(elem, context, xml)) {
											results.push(elem);
											break;
										}
									}
									if (outermost) {
										dirruns = dirrunsUnique;
										cachedruns = ++superMatcher.el;
									}
								}

								// Track unmatched elements for set filters
								if (bySet) {
									// They will have gone through all possible matchers
									if ((elem = !matcher && elem)) {
										matchedCount--;
									}

									// Lengthen the array for every element, matched or not
									if (seed) {
										unmatched.push(elem);
									}
								}
							}

							// Apply set filters to unmatched elements
							matchedCount += i;
							if (bySet && i !== matchedCount) {
								for (j = 0; (matcher = setMatchers[j]); j++) {
									matcher(unmatched, setMatched, context, xml);
								}

								if (seed) {
									// Reintegrate element matches to eliminate the need for sorting
									if (matchedCount > 0) {
										while (i--) {
											if (!(unmatched[i] || setMatched[i])) {
												setMatched[i] = pop.call(results);
											}
										}
									}

									// Discard index placeholder values to get only actual matches
									setMatched = condense(setMatched);
								}

								// Add matches to results
								push.apply(results, setMatched);

								// Seedless set matches succeeding multiple successful matchers stipulate sorting
								if (outermost && !seed && setMatched.length > 0 &&
									(matchedCount + setMatchers.length) > 1) {

									Sizzle.uniqueSort(results);
								}
							}

							// Override manipulation of globals by nested matchers
							if (outermost) {
								dirruns = dirrunsUnique;
								outermostContext = contextBackup;
							}

							return unmatched;
						};

					superMatcher.el = 0;
					return bySet ?
						markFunction(superMatcher) :
						superMatcher;
				}

				compile = Sizzle.compile = function (selector, group /* Internal Use Only */) {
					var i,
						setMatchers = [],
						elementMatchers = [],
						cached = compilerCache[expando][selector + " "];

					if (!cached) {
						// Generate a function of recursive functions that can be used to check each element
						if (!group) {
							group = tokenize(selector);
						}
						i = group.length;
						while (i--) {
							cached = matcherFromTokens(group[i]);
							if (cached[expando]) {
								setMatchers.push(cached);
							} else {
								elementMatchers.push(cached);
							}
						}

						// Cache the compiled function
						cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
					}
					return cached;
				};

				function multipleContexts(selector, contexts, results) {
					var i = 0,
						len = contexts.length;
					for (; i < len; i++) {
						Sizzle(selector, contexts[i], results);
					}
					return results;
				}

				function select(selector, context, results, seed, xml) {
					var i, tokens, token, type, find,
						match = tokenize(selector),
						j = match.length;

					if (!seed) {
						// Try to minimize operations if there is only one group
						if (match.length === 1) {

							// Take a shortcut and set the context if the root selector is an ID
							tokens = match[0] = match[0].slice(0);
							if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
								context.nodeType === 9 && !xml &&
								Expr.relative[tokens[1].type]) {

								context = Expr.find["ID"](token.matches[0].replace(rbackslash, ""), context, xml)[0];
								if (!context) {
									return results;
								}

								selector = selector.slice(tokens.shift().length);
							}

							// Fetch a seed set for right-to-left matching
							for (i = matchExpr["POS"].test(selector) ? -1 : tokens.length - 1; i >= 0; i--) {
								token = tokens[i];

								// Abort if we hit a combinator
								if (Expr.relative[(type = token.type)]) {
									break;
								}
								if ((find = Expr.find[type])) {
									// Search, expanding context for leading sibling combinators
									if ((seed = find(
										token.matches[0].replace(rbackslash, ""),
										rsibling.test(tokens[0].type) && context.parentNode || context,
										xml
									))) {

										// If seed is empty or no tokens remain, we can return early
										tokens.splice(i, 1);
										selector = seed.length && tokens.join("");
										if (!selector) {
											push.apply(results, slice.call(seed, 0));
											return results;
										}

										break;
									}
								}
							}
						}
					}

					// Compile and execute a filtering function
					// Provide `match` to avoid retokenization if we modified the selector above
					compile(selector, match)(
						seed,
						context,
						xml,
						results,
						rsibling.test(selector)
					);
					return results;
				}

				if (document.querySelectorAll) {
					(function () {
						var disconnectedMatch,
							oldSelect = select,
							rescape = /'|\\/g,
							rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

							// qSa(:focus) reports false when true (Chrome 21), no need to also add to buggyMatches since matches checks buggyQSA
							// A support test would require too much code (would include document ready)
							rbuggyQSA = [":focus"],

							// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
							// A support test would require too much code (would include document ready)
							// just skip matchesSelector for :active
							rbuggyMatches = [":active"],
							matches = docElem.matchesSelector ||
								docElem.mozMatchesSelector ||
								docElem.webkitMatchesSelector ||
								docElem.oMatchesSelector ||
								docElem.msMatchesSelector;

						// Build QSA regex
						// Regex strategy adopted from Diego Perini
						assert(function (div) {
							// Select is set to empty string on purpose
							// This is to test IE's treatment of not explictly
							// setting a boolean content attribute,
							// since its presence should be enough
							// http://bugs.jqx.com/ticket/12359
							div.innerHTML = "<select><option selected=''></option></select>";

							// IE8 - Some boolean attributes are not treated correctly
							if (!div.querySelectorAll("[selected]").length) {
								rbuggyQSA.push("\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)");
							}

							// Webkit/Opera - :checked should return selected option elements
							// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
							// IE8 throws error here (do not put tests after this one)
							if (!div.querySelectorAll(":checked").length) {
								rbuggyQSA.push(":checked");
							}
						});

						assert(function (div) {

							// Opera 10-12/IE9 - ^= $= *= and empty values
							// Should not select anything
							div.innerHTML = "<p test=''></p>";
							if (div.querySelectorAll("[test^='']").length) {
								rbuggyQSA.push("[*^$]=" + whitespace + "*(?:\"\"|'')");
							}

							// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
							// IE8 throws error here (do not put tests after this one)
							div.innerHTML = "<input type='hidden'/>";
							if (!div.querySelectorAll(":enabled").length) {
								rbuggyQSA.push(":enabled", ":disabled");
							}
						});

						// rbuggyQSA always contains :focus, so no need for a length check
						rbuggyQSA = /* rbuggyQSA.length && */ new RegExp(rbuggyQSA.join("|"));

						select = function (selector, context, results, seed, xml) {
							// Only use querySelectorAll when not filtering,
							// when this is not xml,
							// and when no QSA bugs apply
							if (!seed && !xml && !rbuggyQSA.test(selector)) {
								var groups, i,
									old = true,
									nid = expando,
									newContext = context,
									newSelector = context.nodeType === 9 && selector;

								// qSA works strangely on Element-rooted queries
								// We can work around this by specifying an extra ID on the root
								// and working up from there (Thanks to Andrew Dupont for the technique)
								// IE 8 doesn't work on object elements
								if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
									groups = tokenize(selector);

									if ((old = context.getAttribute("id"))) {
										nid = old.replace(rescape, "\\$&");
									} else {
										context.setAttribute("id", nid);
									}
									nid = "[id='" + nid + "'] ";

									i = groups.length;
									while (i--) {
										groups[i] = nid + groups[i].join("");
									}
									newContext = rsibling.test(selector) && context.parentNode || context;
									newSelector = groups.join(",");
								}

								if (newSelector) {
									try {
										push.apply(results, slice.call(newContext.querySelectorAll(
											newSelector
										), 0));
										return results;
									} catch (qsaError) {
									} finally {
										if (!old) {
											context.removeAttribute("id");
										}
									}
								}
							}

							return oldSelect(selector, context, results, seed, xml);
						};

						if (matches) {
							assert(function (div) {
								// Check to see if it's possible to do matchesSelector
								// on a disconnected node (IE 9)
								disconnectedMatch = matches.call(div, "div");

								// This should fail with an exception
								// Gecko does not error, returns false instead
								try {
									matches.call(div, "[test!='']:sizzle");
									rbuggyMatches.push("!=", pseudos);
								} catch (e) { }
							});

							// rbuggyMatches always contains :active and :focus, so no need for a length check
							rbuggyMatches = /* rbuggyMatches.length && */ new RegExp(rbuggyMatches.join("|"));

							Sizzle.matchesSelector = function (elem, expr) {
								// Make sure that attribute selectors are quoted
								expr = expr.replace(rattributeQuotes, "='$1']");

								// rbuggyMatches always contains :active, so no need for an existence check
								if (!isXML(elem) && !rbuggyMatches.test(expr) && !rbuggyQSA.test(expr)) {
									try {
										var ret = matches.call(elem, expr);

										// IE 9's matchesSelector returns false on disconnected nodes
										if (ret || disconnectedMatch ||
											// As well, disconnected nodes are said to be in a document
											// fragment in IE 9
											elem.document && elem.document.nodeType !== 11) {
											return ret;
										}
									} catch (e) { }
								}

								return Sizzle(expr, null, null, [elem]).length > 0;
							};
						}
					})();
				}

				// Deprecated
				Expr.pseudos["nth"] = Expr.pseudos["eq"];

				// Back-compat
				function setFilters() { }
				Expr.filters = setFilters.prototype = Expr.pseudos;
				Expr.setFilters = new setFilters();

				// Override sizzle attribute retrieval
				Sizzle.attr = JQXLite.attr;
				JQXLite.find = Sizzle;
				JQXLite.expr = Sizzle.selectors;
				JQXLite.expr[":"] = JQXLite.expr.pseudos;
				JQXLite.unique = Sizzle.uniqueSort;
				JQXLite.text = Sizzle.getText;
				JQXLite.isXMLDoc = Sizzle.isXML;
				JQXLite.contains = Sizzle.contains;


			})(window);
			var runtil = /Until$/,
				rparentsprev = /^(?:parents|prev(?:Until|All))/,
				isSimple = /^.[^:#\[\.,]*$/,
				rneedsContext = JQXLite.expr.match.needsContext,
				// methods guaranteed to produce a unique set when starting from a unique set
				guaranteedUnique = {
					children: true,
					contents: true,
					next: true,
					prev: true
				};

			JQXLite.fn.extend({
				find: function (selector) {
					var i, l, length, n, r, ret,
						self = this;

					if (typeof selector !== "string") {
						return JQXLite(selector).filter(function () {
							for (i = 0, l = self.length; i < l; i++) {
								if (JQXLite.contains(self[i], this)) {
									return true;
								}
							}
						});
					}

					ret = this.pushStack("", "find", selector);

					for (i = 0, l = this.length; i < l; i++) {
						length = ret.length;
						JQXLite.find(selector, this[i], ret);

						if (i > 0) {
							// Make sure that the results are unique
							for (n = length; n < ret.length; n++) {
								for (r = 0; r < length; r++) {
									if (ret[r] === ret[n]) {
										ret.splice(n--, 1);
										break;
									}
								}
							}
						}
					}

					return ret;
				},

				has: function (target) {
					var i,
						targets = JQXLite(target, this),
						len = targets.length;

					return this.filter(function () {
						for (i = 0; i < len; i++) {
							if (JQXLite.contains(this, targets[i])) {
								return true;
							}
						}
					});
				},

				not: function (selector) {
					return this.pushStack(winnow(this, selector, false), "not", selector);
				},

				filter: function (selector) {
					return this.pushStack(winnow(this, selector, true), "filter", selector);
				},

				is: function (selector) {
					return !!selector && (
						typeof selector === "string" ?
							// If this is a positional/relative selector, check membership in the returned set
							// so $("p:first").is("p:last") won't return true for a doc with two "p".
							rneedsContext.test(selector) ?
								JQXLite(selector, this.context).index(this[0]) >= 0 :
								JQXLite.filter(selector, this).length > 0 :
							this.filter(selector).length > 0);
				},

				closest: function (selectors, context) {
					var cur,
						i = 0,
						l = this.length,
						ret = [],
						pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
							JQXLite(selectors, context || this.context) :
							0;

					for (; i < l; i++) {
						cur = this[i];

						while (cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11) {
							if (pos ? pos.index(cur) > -1 : JQXLite.find.matchesSelector(cur, selectors)) {
								ret.push(cur);
								break;
							}
							cur = cur.parentNode;
						}
					}

					ret = ret.length > 1 ? JQXLite.unique(ret) : ret;

					return this.pushStack(ret, "closest", selectors);
				},

				// Determine the position of an element within
				// the matched set of elements
				index: function (elem) {

					// No argument, return index in parent
					if (!elem) {
						return (this[0] && this[0].parentNode) ? this.prevAll().length : -1;
					}

					// index in selector
					if (typeof elem === "string") {
						return JQXLite.inArray(this[0], JQXLite(elem));
					}

					// Locate the position of the desired element
					return JQXLite.inArray(
						// If it receives a JQXLite object, the first element is used
						elem.jqx ? elem[0] : elem, this);
				},

				add: function (selector, context) {
					var set = typeof selector === "string" ?
						JQXLite(selector, context) :
						JQXLite.makeArray(selector && selector.nodeType ? [selector] : selector),
						all = JQXLite.merge(this.get(), set);

					return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ?
						all :
						JQXLite.unique(all));
				},

				addBack: function (selector) {
					return this.add(selector == null ?
						this.prevObject : this.prevObject.filter(selector)
					);
				}
			});

			JQXLite.fn.andSelf = JQXLite.fn.addBack;

			// A painfully simple check to see if an element is disconnected
			// from a document (should be improved, where feasible).
			function isDisconnected(node) {
				return !node || !node.parentNode || node.parentNode.nodeType === 11;
			}

			function sibling(cur, dir) {
				do {
					cur = cur[dir];
				} while (cur && cur.nodeType !== 1);

				return cur;
			}

			JQXLite.each({
				parent: function (elem) {
					var parent = elem.parentNode;
					return parent && parent.nodeType !== 11 ? parent : null;
				},
				parents: function (elem) {
					return JQXLite.dir(elem, "parentNode");
				},
				parentsUntil: function (elem, i, until) {
					return JQXLite.dir(elem, "parentNode", until);
				},
				next: function (elem) {
					return sibling(elem, "nextSibling");
				},
				prev: function (elem) {
					return sibling(elem, "previousSibling");
				},
				nextAll: function (elem) {
					return JQXLite.dir(elem, "nextSibling");
				},
				prevAll: function (elem) {
					return JQXLite.dir(elem, "previousSibling");
				},
				nextUntil: function (elem, i, until) {
					return JQXLite.dir(elem, "nextSibling", until);
				},
				prevUntil: function (elem, i, until) {
					return JQXLite.dir(elem, "previousSibling", until);
				},
				siblings: function (elem) {
					return JQXLite.sibling((elem.parentNode || {}).firstChild, elem);
				},
				children: function (elem) {
					return JQXLite.sibling(elem.firstChild);
				},
				contents: function (elem) {
					return JQXLite.nodeName(elem, "iframe") ?
						elem.contentDocument || elem.contentWindow.document :
						JQXLite.merge([], elem.childNodes);
				}
			}, function (name, fn) {
				JQXLite.fn[name] = function (until, selector) {
					var ret = JQXLite.map(this, fn, until);

					if (!runtil.test(name)) {
						selector = until;
					}

					if (selector && typeof selector === "string") {
						ret = JQXLite.filter(selector, ret);
					}

					ret = this.length > 1 && !guaranteedUnique[name] ? JQXLite.unique(ret) : ret;

					if (this.length > 1 && rparentsprev.test(name)) {
						ret = ret.reverse();
					}

					return this.pushStack(ret, name, core_slice.call(arguments).join(","));
				};
			});

			JQXLite.extend({
				filter: function (expr, elems, not) {
					if (not) {
						expr = ":not(" + expr + ")";
					}

					return elems.length === 1 ?
						JQXLite.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] :
						JQXLite.find.matches(expr, elems);
				},

				dir: function (elem, dir, until) {
					var matched = [],
						cur = elem[dir];

					while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !JQXLite(cur).is(until))) {
						if (cur.nodeType === 1) {
							matched.push(cur);
						}
						cur = cur[dir];
					}
					return matched;
				},

				sibling: function (n, elem) {
					var r = [];

					for (; n; n = n.nextSibling) {
						if (n.nodeType === 1 && n !== elem) {
							r.push(n);
						}
					}

					return r;
				}
			});

			// Implement the identical functionality for filter and not
			function winnow(elements, qualifier, keep) {

				// Can't pass null or undefined to indexOf in Firefox 4
				// Set to 0 to skip string check
				qualifier = qualifier || 0;

				if (JQXLite.isFunction(qualifier)) {
					return JQXLite.grep(elements, function (elem, i) {
						var retVal = !!qualifier.call(elem, i, elem);
						return retVal === keep;
					});

				} else if (qualifier.nodeType) {
					return JQXLite.grep(elements, function (elem, i) {
						return (elem === qualifier) === keep;
					});

				} else if (typeof qualifier === "string") {
					var filtered = JQXLite.grep(elements, function (elem) {
						return elem.nodeType === 1;
					});

					if (isSimple.test(qualifier)) {
						return JQXLite.filter(qualifier, filtered, !keep);
					} else {
						qualifier = JQXLite.filter(qualifier, filtered);
					}
				}

				return JQXLite.grep(elements, function (elem, i) {
					return (JQXLite.inArray(elem, qualifier) >= 0) === keep;
				});
			}
			function createSafeFragment(document) {
				var list = nodeNames.split("|"),
					safeFrag = document.createDocumentFragment();

				if (safeFrag.createElement) {
					while (list.length) {
						safeFrag.createElement(
							list.pop()
						);
					}
				}
				return safeFrag;
			}

			var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
				"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
				rinlinejQuery = / JQXLite\d+="(?:null|\d+)"/g,
				rleadingWhitespace = /^\s+/,
				rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
				rtagName = /<([\w:]+)/,
				rtbody = /<tbody/i,
				rhtml = /<|&#?\w+;/,
				rnoInnerhtml = /<(?:script|style|link)/i,
				rnocache = /<(?:script|object|embed|option|style)/i,
				rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
				rcheckableType = /^(?:checkbox|radio)$/,
				// checked="checked" or checked
				rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
				rscriptType = /\/(java|ecma)script/i,
				rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
				wrapMap = {
					option: [1, "<select multiple='multiple'>", "</select>"],
					legend: [1, "<fieldset>", "</fieldset>"],
					thead: [1, "<table>", "</table>"],
					tr: [2, "<table><tbody>", "</tbody></table>"],
					td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
					col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
					area: [1, "<map>", "</map>"],
					_default: [0, "", ""]
				},
				safeFragment = createSafeFragment(document),
				fragmentDiv = safeFragment.appendChild(document.createElement("div"));

			wrapMap.optgroup = wrapMap.option;
			wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
			wrapMap.th = wrapMap.td;

			// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
			// unless wrapped in a div with non-breaking characters in front of it.
			if (!JQXLite.support.htmlSerialize) {
				wrapMap._default = [1, "X<div>", "</div>"];
			}

			JQXLite.fn.extend({
				text: function (value) {
					return JQXLite.access(this, function (value) {
						return value === undefined ?
							JQXLite.text(this) :
							this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
					}, null, value, arguments.length);
				},

				wrapAll: function (html) {
					if (JQXLite.isFunction(html)) {
						return this.each(function (i) {
							JQXLite(this).wrapAll(html.call(this, i));
						});
					}

					if (this[0]) {
						// The elements to wrap the target around
						var wrap = JQXLite(html, this[0].ownerDocument).eq(0).clone(true);

						if (this[0].parentNode) {
							wrap.insertBefore(this[0]);
						}

						wrap.map(function () {
							var elem = this;

							while (elem.firstChild && elem.firstChild.nodeType === 1) {
								elem = elem.firstChild;
							}

							return elem;
						}).append(this);
					}

					return this;
				},

				wrapInner: function (html) {
					if (JQXLite.isFunction(html)) {
						return this.each(function (i) {
							JQXLite(this).wrapInner(html.call(this, i));
						});
					}

					return this.each(function () {
						var self = JQXLite(this),
							contents = self.contents();

						if (contents.length) {
							contents.wrapAll(html);

						} else {
							self.append(html);
						}
					});
				},

				wrap: function (html) {
					var isFunction = JQXLite.isFunction(html);

					return this.each(function (i) {
						JQXLite(this).wrapAll(isFunction ? html.call(this, i) : html);
					});
				},

				unwrap: function () {
					return this.parent().each(function () {
						if (!JQXLite.nodeName(this, "body")) {
							JQXLite(this).replaceWith(this.childNodes);
						}
					}).end();
				},

				append: function () {
					return this.domManip(arguments, true, function (elem) {
						if (this.nodeType === 1 || this.nodeType === 11) {
							this.appendChild(elem);
						}
					});
				},

				prepend: function () {
					return this.domManip(arguments, true, function (elem) {
						if (this.nodeType === 1 || this.nodeType === 11) {
							this.insertBefore(elem, this.firstChild);
						}
					});
				},

				before: function () {
					if (!isDisconnected(this[0])) {
						return this.domManip(arguments, false, function (elem) {
							this.parentNode.insertBefore(elem, this);
						});
					}

					if (arguments.length) {
						var set = JQXLite.clean(arguments);
						return this.pushStack(JQXLite.merge(set, this), "before", this.selector);
					}
				},

				after: function () {
					if (!isDisconnected(this[0])) {
						return this.domManip(arguments, false, function (elem) {
							this.parentNode.insertBefore(elem, this.nextSibling);
						});
					}

					if (arguments.length) {
						var set = JQXLite.clean(arguments);
						return this.pushStack(JQXLite.merge(this, set), "after", this.selector);
					}
				},

				// keepData is for internal use only--do not document
				remove: function (selector, keepData) {
					var elem,
						i = 0;

					for (; (elem = this[i]) != null; i++) {
						if (!selector || JQXLite.filter(selector, [elem]).length) {
							if (!keepData && elem.nodeType === 1) {
								JQXLite.cleanData(elem.getElementsByTagName("*"));
								JQXLite.cleanData([elem]);
							}

							if (elem.parentNode) {
								elem.parentNode.removeChild(elem);
							}
						}
					}

					return this;
				},

				empty: function () {
					var elem,
						i = 0;

					for (; (elem = this[i]) != null; i++) {
						// Remove element nodes and prevent memory leaks
						if (elem.nodeType === 1) {
							JQXLite.cleanData(elem.getElementsByTagName("*"));
						}

						// Remove any remaining nodes
						while (elem.firstChild) {
							elem.removeChild(elem.firstChild);
						}
					}

					return this;
				},

				clone: function (dataAndEvents, deepDataAndEvents) {
					dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
					deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

					return this.map(function () {
						return JQXLite.clone(this, dataAndEvents, deepDataAndEvents);
					});
				},

				html: function (value) {
					return JQXLite.access(this, function (value) {
						var elem = this[0] || {},
							i = 0,
							l = this.length;

						if (value === undefined) {
							return elem.nodeType === 1 ?
								elem.innerHTML.replace(rinlinejQuery, "") :
								undefined;
						}

						// See if we can take a shortcut and just use innerHTML
						if (typeof value === "string" && !rnoInnerhtml.test(value) &&
							(JQXLite.support.htmlSerialize || !rnoshimcache.test(value)) &&
							(JQXLite.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
							!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

							value = value.replace(rxhtmlTag, "<$1></$2>");

							try {
								for (; i < l; i++) {
									// Remove element nodes and prevent memory leaks
									elem = this[i] || {};
									if (elem.nodeType === 1) {
										JQXLite.cleanData(elem.getElementsByTagName("*"));
										elem.innerHTML = value;
									}
								}

								elem = 0;

								// If using innerHTML throws an exception, use the fallback method
							} catch (e) { }
						}

						if (elem) {
							this.empty().append(value);
						}
					}, null, value, arguments.length);
				},

				replaceWith: function (value) {
					if (!isDisconnected(this[0])) {
						// Make sure that the elements are removed from the DOM before they are inserted
						// this can help fix replacing a parent with child elements
						if (JQXLite.isFunction(value)) {
							return this.each(function (i) {
								var self = JQXLite(this), old = self.html();
								self.replaceWith(value.call(this, i, old));
							});
						}

						if (typeof value !== "string") {
							value = JQXLite(value).detach();
						}

						return this.each(function () {
							var next = this.nextSibling,
								parent = this.parentNode;

							JQXLite(this).remove();

							if (next) {
								JQXLite(next).before(value);
							} else {
								JQXLite(parent).append(value);
							}
						});
					}

					return this.length ?
						this.pushStack(JQXLite(JQXLite.isFunction(value) ? value() : value), "replaceWith", value) :
						this;
				},

				detach: function (selector) {
					return this.remove(selector, true);
				},

				domManip: function (args, table, callback) {

					// Flatten any nested arrays
					args = [].concat.apply([], args);

					var results, first, fragment, iNoClone,
						i = 0,
						value = args[0],
						scripts = [],
						l = this.length;

					// We can't cloneNode fragments that contain checked, in WebKit
					if (!JQXLite.support.checkClone && l > 1 && typeof value === "string" && rchecked.test(value)) {
						return this.each(function () {
							JQXLite(this).domManip(args, table, callback);
						});
					}

					if (JQXLite.isFunction(value)) {
						return this.each(function (i) {
							var self = JQXLite(this);
							args[0] = value.call(this, i, table ? self.html() : undefined);
							self.domManip(args, table, callback);
						});
					}

					if (this[0]) {
						results = JQXLite.buildFragment(args, this, scripts);
						fragment = results.fragment;
						first = fragment.firstChild;

						if (fragment.childNodes.length === 1) {
							fragment = first;
						}

						if (first) {
							table = table && JQXLite.nodeName(first, "tr");

							// Use the original fragment for the last item instead of the first because it can end up
							// being emptied incorrectly in certain situations (#8070).
							// Fragments from the fragment cache must always be cloned and never used in place.
							for (iNoClone = results.cacheable || l - 1; i < l; i++) {
								callback.call(
									table && JQXLite.nodeName(this[i], "table") ?
										findOrAppend(this[i], "tbody") :
										this[i],
									i === iNoClone ?
										fragment :
										JQXLite.clone(fragment, true, true)
								);
							}
						}

						// Fix #11809: Avoid leaking memory
						fragment = first = null;

						if (scripts.length) {
							JQXLite.each(scripts, function (i, elem) {
								if (elem.src) {
									if (JQXLite.ajax) {
										JQXLite.ajax({
											url: elem.src,
											type: "GET",
											dataType: "script",
											async: false,
											global: false,
											"throws": true
										});
									} else {
										JQXLite.error("no ajax");
									}
								} else {
									JQXLite.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, ""));
								}

								if (elem.parentNode) {
									elem.parentNode.removeChild(elem);
								}
							});
						}
					}

					return this;
				}
			});

			function findOrAppend(elem, tag) {
				return elem.getElementsByTagName(tag)[0] || elem.appendChild(elem.ownerDocument.createElement(tag));
			}

			function cloneCopyEvent(src, dest) {

				if (dest.nodeType !== 1 || !JQXLite.hasData(src)) {
					return;
				}

				var type, i, l,
					oldData = JQXLite._data(src),
					curData = JQXLite._data(dest, oldData),
					events = oldData.events;

				if (events) {
					delete curData.handle;
					curData.events = {};

					for (type in events) {
						for (i = 0, l = events[type].length; i < l; i++) {
							JQXLite.event.add(dest, type, events[type][i]);
						}
					}
				}

				// make the cloned public data object a copy from the original
				if (curData.data) {
					curData.data = JQXLite.extend({}, curData.data);
				}
			}

			function cloneFixAttributes(src, dest) {
				var nodeName;

				// We do not need to do anything for non-Elements
				if (dest.nodeType !== 1) {
					return;
				}

				// clearAttributes removes the attributes, which we don't want,
				// but also removes the attachEvent events, which we *do* want
				if (dest.clearAttributes) {
					dest.clearAttributes();
				}

				// mergeAttributes, in contrast, only merges back on the
				// original attributes, not the events
				if (dest.mergeAttributes) {
					dest.mergeAttributes(src);
				}

				nodeName = dest.nodeName.toLowerCase();

				if (nodeName === "object") {
					// IE6-10 improperly clones children of object elements using classid.
					// IE10 throws NoModificationAllowedError if parent is null, #12132.
					if (dest.parentNode) {
						dest.outerHTML = src.outerHTML;
					}

					// This path appears unavoidable for IE9. When cloning an object
					// element in IE9, the outerHTML strategy above is not sufficient.
					// If the src has innerHTML and the destination does not,
					// copy the src.innerHTML into the dest.innerHTML. #10324
					if (JQXLite.support.html5Clone && (src.innerHTML && !JQXLite.trim(dest.innerHTML))) {
						dest.innerHTML = src.innerHTML;
					}

				} else if (nodeName === "input" && rcheckableType.test(src.type)) {
					// IE6-8 fails to persist the checked state of a cloned checkbox
					// or radio button. Worse, IE6-7 fail to give the cloned element
					// a checked appearance if the defaultChecked value isn't also set

					dest.defaultChecked = dest.checked = src.checked;

					// IE6-7 get confused and end up setting the value of a cloned
					// checkbox/radio button to an empty string instead of "on"
					if (dest.value !== src.value) {
						dest.value = src.value;
					}

					// IE6-8 fails to return the selected option to the default selected
					// state when cloning options
				} else if (nodeName === "option") {
					dest.selected = src.defaultSelected;

					// IE6-8 fails to set the defaultValue to the correct value when
					// cloning other types of input fields
				} else if (nodeName === "input" || nodeName === "textarea") {
					dest.defaultValue = src.defaultValue;

					// IE blanks contents when cloning scripts
				} else if (nodeName === "script" && dest.text !== src.text) {
					dest.text = src.text;
				}

				// Event data gets referenced instead of copied if the expando
				// gets copied too
				dest.removeAttribute(JQXLite.expando);
			}

			JQXLite.buildFragment = function (args, context, scripts) {
				var fragment, cacheable, cachehit,
					first = args[0];

				// Set context from what may come in as undefined or a JQXLite collection or a node
				// Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
				// also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
				context = context || document;
				context = !context.nodeType && context[0] || context;
				context = context.ownerDocument || context;

				// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
				// Cloning options loses the selected state, so don't cache them
				// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
				// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
				// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
				if (args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
					first.charAt(0) === "<" && !rnocache.test(first) &&
					(JQXLite.support.checkClone || !rchecked.test(first)) &&
					(JQXLite.support.html5Clone || !rnoshimcache.test(first))) {

					// Mark cacheable and look for a hit
					cacheable = true;
					fragment = JQXLite.fragments[first];
					cachehit = fragment !== undefined;
				}

				if (!fragment) {
					fragment = context.createDocumentFragment();
					JQXLite.clean(args, context, fragment, scripts);

					// Update the cache, but only store false
					// unless this is a second parsing of the same content
					if (cacheable) {
						JQXLite.fragments[first] = cachehit && fragment;
					}
				}

				return { fragment: fragment, cacheable: cacheable };
			};

			JQXLite.fragments = {};

			JQXLite.each({
				appendTo: "append",
				prependTo: "prepend",
				insertBefore: "before",
				insertAfter: "after",
				replaceAll: "replaceWith"
			}, function (name, original) {
				JQXLite.fn[name] = function (selector) {
					var elems,
						i = 0,
						ret = [],
						insert = JQXLite(selector),
						l = insert.length,
						parent = this.length === 1 && this[0].parentNode;

					if ((parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1) {
						insert[original](this[0]);
						return this;
					} else {
						for (; i < l; i++) {
							elems = (i > 0 ? this.clone(true) : this).get();
							JQXLite(insert[i])[original](elems);
							ret = ret.concat(elems);
						}

						return this.pushStack(ret, name, insert.selector);
					}
				};
			});

			function getAll(elem) {
				if (typeof elem.getElementsByTagName !== "undefined") {
					return elem.getElementsByTagName("*");

				} else if (typeof elem.querySelectorAll !== "undefined") {
					return elem.querySelectorAll("*");

				} else {
					return [];
				}
			}

			// Used in clean, fixes the defaultChecked property
			function fixDefaultChecked(elem) {
				if (rcheckableType.test(elem.type)) {
					elem.defaultChecked = elem.checked;
				}
			}

			JQXLite.extend({
				clone: function (elem, dataAndEvents, deepDataAndEvents) {
					var srcElements,
						destElements,
						i,
						clone;

					if (JQXLite.support.html5Clone || JQXLite.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) {
						clone = elem.cloneNode(true);

						// IE<=8 does not properly clone detached, unknown element nodes
					} else {
						fragmentDiv.innerHTML = elem.outerHTML;
						fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
					}

					if ((!JQXLite.support.noCloneEvent || !JQXLite.support.noCloneChecked) &&
						(elem.nodeType === 1 || elem.nodeType === 11) && !JQXLite.isXMLDoc(elem)) {
						// IE copies events bound via attachEvent when using cloneNode.
						// Calling detachEvent on the clone will also remove the events
						// from the original. In order to get around this, we use some
						// proprietary methods to clear the events. Thanks to MooTools
						// guys for this hotness.

						cloneFixAttributes(elem, clone);

						// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
						srcElements = getAll(elem);
						destElements = getAll(clone);

						// Weird iteration because IE will replace the length property
						// with an element if you are cloning the body and one of the
						// elements on the page has a name or id of "length"
						for (i = 0; srcElements[i]; ++i) {
							// Ensure that the destination node is not null; Fixes #9587
							if (destElements[i]) {
								cloneFixAttributes(srcElements[i], destElements[i]);
							}
						}
					}

					// Copy the events from the original to the clone
					if (dataAndEvents) {
						cloneCopyEvent(elem, clone);

						if (deepDataAndEvents) {
							srcElements = getAll(elem);
							destElements = getAll(clone);

							for (i = 0; srcElements[i]; ++i) {
								cloneCopyEvent(srcElements[i], destElements[i]);
							}
						}
					}

					srcElements = destElements = null;

					// Return the cloned set
					return clone;
				},

				clean: function (elems, context, fragment, scripts) {
					var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
						safe = context === document && safeFragment,
						ret = [];

					// Ensure that context is a document
					if (!context || typeof context.createDocumentFragment === "undefined") {
						context = document;
					}

					// Use the already-created safe fragment if context permits
					for (i = 0; (elem = elems[i]) != null; i++) {
						if (typeof elem === "number") {
							elem += "";
						}

						if (!elem) {
							continue;
						}

						// Convert html string into DOM nodes
						if (typeof elem === "string") {
							if (!rhtml.test(elem)) {
								elem = context.createTextNode(elem);
							} else {
								// Ensure a safe container in which to render the html
								safe = safe || createSafeFragment(context);
								div = context.createElement("div");
								safe.appendChild(div);

								// Fix "XHTML"-style tags in all browsers
								elem = elem.replace(rxhtmlTag, "<$1></$2>");

								// Go to html and back, then peel off extra wrappers
								tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
								wrap = wrapMap[tag] || wrapMap._default;
								depth = wrap[0];
								div.innerHTML = wrap[1] + elem + wrap[2];

								// Move to the right depth
								while (depth--) {
									div = div.lastChild;
								}

								// Remove IE's autoinserted <tbody> from table fragments
								if (!JQXLite.support.tbody) {

									// String was a <table>, *may* have spurious <tbody>
									hasBody = rtbody.test(elem);
									tbody = tag === "table" && !hasBody ?
										div.firstChild && div.firstChild.childNodes :

										// String was a bare <thead> or <tfoot>
										wrap[1] === "<table>" && !hasBody ?
											div.childNodes :
											[];

									for (j = tbody.length - 1; j >= 0; --j) {
										if (JQXLite.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
											tbody[j].parentNode.removeChild(tbody[j]);
										}
									}
								}

								// IE completely kills leading whitespace when innerHTML is used
								if (!JQXLite.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
									div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
								}

								elem = div.childNodes;

								// Take out of fragment container (we need a fresh div each time)
								div.parentNode.removeChild(div);
							}
						}

						if (elem.nodeType) {
							ret.push(elem);
						} else {
							JQXLite.merge(ret, elem);
						}
					}

					// Fix #11356: Clear elements from safeFragment
					if (div) {
						elem = div = safe = null;
					}

					// Reset defaultChecked for any radios and checkboxes
					// about to be appended to the DOM in IE 6/7 (#8060)
					if (!JQXLite.support.appendChecked) {
						for (i = 0; (elem = ret[i]) != null; i++) {
							if (JQXLite.nodeName(elem, "input")) {
								fixDefaultChecked(elem);
							} else if (typeof elem.getElementsByTagName !== "undefined") {
								JQXLite.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
							}
						}
					}

					// Append elements to a provided document fragment
					if (fragment) {
						// Special handling of each script element
						handleScript = function (elem) {
							// Check if we consider it executable
							if (!elem.type || rscriptType.test(elem.type)) {
								// Detach the script and store it in the scripts array (if provided) or the fragment
								// Return truthy to indicate that it has been handled
								return scripts ?
									scripts.push(elem.parentNode ? elem.parentNode.removeChild(elem) : elem) :
									fragment.appendChild(elem);
							}
						};

						for (i = 0; (elem = ret[i]) != null; i++) {
							// Check if we're done after handling an executable script
							if (!(JQXLite.nodeName(elem, "script") && handleScript(elem))) {
								// Append to fragment and handle embedded scripts
								fragment.appendChild(elem);
								if (typeof elem.getElementsByTagName !== "undefined") {
									// handleScript alters the DOM, so use JQXLite.merge to ensure snapshot iteration
									jsTags = JQXLite.grep(JQXLite.merge([], elem.getElementsByTagName("script")), handleScript);

									// Splice the scripts into ret after their former ancestor and advance our index beyond them
									ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
									i += jsTags.length;
								}
							}
						}
					}

					return ret;
				},

				cleanData: function (elems, /* internal */ acceptData) {
					var data, id, elem, type,
						i = 0,
						internalKey = JQXLite.expando,
						cache = JQXLite.cache,
						deleteExpando = JQXLite.support.deleteExpando,
						special = JQXLite.event.special;

					for (; (elem = elems[i]) != null; i++) {

						if (acceptData || JQXLite.acceptData(elem)) {

							id = elem[internalKey];
							data = id && cache[id];

							if (data) {
								if (data.events) {
									for (type in data.events) {
										if (special[type]) {
											JQXLite.event.remove(elem, type);

											// This is a shortcut to avoid JQXLite.event.remove's overhead
										} else {
											JQXLite.removeEvent(elem, type, data.handle);
										}
									}
								}

								// Remove cache only if it was not already removed by JQXLite.event.remove
								if (cache[id]) {

									delete cache[id];

									// IE does not allow us to delete expando properties from nodes,
									// nor does it have a removeAttribute function on Document nodes;
									// we must handle all of these cases
									if (deleteExpando) {
										delete elem[internalKey];

									} else if (elem.removeAttribute) {
										elem.removeAttribute(internalKey);

									} else {
										elem[internalKey] = null;
									}

									JQXLite.deletedIds.push(id);
								}
							}
						}
					}
				}
			});
			// Limit scope pollution from any deprecated API
			(function () {

				var matched, browser;

				// Use of JQXLite.browser is frowned upon.
				// More details: http://api.jqx.com/JQXLite.browser
				// JQXLite.uaMatch maintained for back-compat
				JQXLite.uaMatch = function (ua) {
					ua = ua.toLowerCase();

					var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
						/(webkit)[ \/]([\w.]+)/.exec(ua) ||
						/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
						/(msie) ([\w.]+)/.exec(ua) ||
						ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
						[];

					return {
						browser: match[1] || "",
						version: match[2] || "0"
					};
				};

				matched = JQXLite.uaMatch(navigator.userAgent);
				browser = {};

				if (matched.browser) {
					browser[matched.browser] = true;
					browser.version = matched.version;
				}

				// Chrome is Webkit, but Webkit is also Safari.
				if (browser.chrome) {
					browser.webkit = true;
				} else if (browser.webkit) {
					browser.safari = true;
				}

				JQXLite.browser = browser;

				JQXLite.sub = function () {
					function jQuerySub(selector, context) {
						return new jQuerySub.fn.init(selector, context);
					}
					JQXLite.extend(true, jQuerySub, this);
					jQuerySub.superclass = this;
					jQuerySub.fn = jQuerySub.prototype = this();
					jQuerySub.fn.constructor = jQuerySub;
					jQuerySub.sub = this.sub;
					jQuerySub.fn.init = function init(selector, context) {
						if (context && context instanceof JQXLite && !(context instanceof jQuerySub)) {
							context = jQuerySub(context);
						}

						return JQXLite.fn.init.call(this, selector, context, rootJQXLiteSub);
					};
					jQuerySub.fn.init.prototype = jQuerySub.fn;
					var rootJQXLiteSub = jQuerySub(document);
					return jQuerySub;
				};

			})();
			var curCSS, iframe, iframeDoc,
				ralpha = /alpha\([^)]*\)/i,
				ropacity = /opacity=([^)]*)/,
				rposition = /^(top|right|bottom|left)$/,
				// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
				// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
				rdisplayswap = /^(none|table(?!-c[ea]).+)/,
				rmargin = /^margin/,
				rnumsplit = new RegExp("^(" + core_pnum + ")(.*)$", "i"),
				rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"),
				rrelNum = new RegExp("^([-+])=(" + core_pnum + ")", "i"),
				elemdisplay = { BODY: "block" },

				cssShow = { position: "absolute", visibility: "hidden", display: "block" },
				cssNormalTransform = {
					letterSpacing: 0,
					fontWeight: 400
				},

				cssExpand = ["Top", "Right", "Bottom", "Left"],
				cssPrefixes = ["Webkit", "O", "Moz", "ms"],

				eventsToggle = JQXLite.fn.toggle;

			// return a css property mapped to a potentially vendor prefixed property
			function vendorPropName(style, name) {

				// shortcut for names that are not vendor prefixed
				if (name in style) {
					return name;
				}

				// check for vendor prefixed names
				var capName = name.charAt(0).toUpperCase() + name.slice(1),
					origName = name,
					i = cssPrefixes.length;

				while (i--) {
					name = cssPrefixes[i] + capName;
					if (name in style) {
						return name;
					}
				}

				return origName;
			}

			function isHidden(elem, el) {
				elem = el || elem;
				return JQXLite.css(elem, "display") === "none" || !JQXLite.contains(elem.ownerDocument, elem);
			}

			function showHide(elements, show) {
				var elem, display,
					values = [],
					index = 0,
					length = elements.length;

				for (; index < length; index++) {
					elem = elements[index];
					if (!elem.style) {
						continue;
					}
					values[index] = JQXLite._data(elem, "olddisplay");
					if (show) {
						// Reset the inline display of this element to learn if it is
						// being hidden by cascaded rules or not
						if (!values[index] && elem.style.display === "none") {
							elem.style.display = "";
						}

						// Set elements which have been overridden with display: none
						// in a stylesheet to whatever the default browser style is
						// for such an element
						if (elem.style.display === "" && isHidden(elem)) {
							values[index] = JQXLite._data(elem, "olddisplay", css_defaultDisplay(elem.nodeName));
						}
					} else {
						display = curCSS(elem, "display");

						if (!values[index] && display !== "none") {
							JQXLite._data(elem, "olddisplay", display);
						}
					}
				}

				// Set the display of most of the elements in a second loop
				// to avoid the constant reflow
				for (index = 0; index < length; index++) {
					elem = elements[index];
					if (!elem.style) {
						continue;
					}
					if (!show || elem.style.display === "none" || elem.style.display === "") {
						elem.style.display = show ? values[index] || "" : "none";
					}
				}

				return elements;
			}

			JQXLite.fn.extend({
				css: function (name, value) {
					return JQXLite.access(this, function (elem, name, value) {
						return value !== undefined ?
							JQXLite.style(elem, name, value) :
							JQXLite.css(elem, name);
					}, name, value, arguments.length > 1);
				},
				show: function () {
					return showHide(this, true);
				},
				hide: function () {
					return showHide(this);
				},
				toggle: function (state, fn2) {
					var bool = typeof state === "boolean";

					if (JQXLite.isFunction(state) && JQXLite.isFunction(fn2)) {
						return eventsToggle.apply(this, arguments);
					}

					return this.each(function () {
						if (bool ? state : isHidden(this)) {
							JQXLite(this).show();
						} else {
							JQXLite(this).hide();
						}
					});
				}
			});

			JQXLite.extend({
				// Add in style property hooks for overriding the default
				// behavior of getting and setting a style property
				cssHooks: {
					opacity: {
						get: function (elem, computed) {
							if (computed) {
								// We should always get a number back from opacity
								var ret = curCSS(elem, "opacity");
								return ret === "" ? "1" : ret;

							}
						}
					}
				},

				// Exclude the following css properties to add px
				cssNumber: {
					"fillOpacity": true,
					"fontWeight": true,
					"lineHeight": true,
					"opacity": true,
					"orphans": true,
					"widows": true,
					"zIndex": true,
					"zoom": true
				},

				// Add in properties whose names you wish to fix before
				// setting or getting the value
				cssProps: {
					// normalize float css property
					"float": JQXLite.support.cssFloat ? "cssFloat" : "styleFloat"
				},

				// Get and set the style property on a DOM Node
				style: function (elem, name, value, extra) {
					// Don't set styles on text and comment nodes
					if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
						return;
					}

					// Make sure that we're working with the right name
					var ret, type, hooks,
						origName = JQXLite.camelCase(name),
						style = elem.style;

					name = JQXLite.cssProps[origName] || (JQXLite.cssProps[origName] = vendorPropName(style, origName));

					// gets hook for the prefixed version
					// followed by the unprefixed version
					hooks = JQXLite.cssHooks[name] || JQXLite.cssHooks[origName];

					// Check if we're setting a value
					if (value !== undefined) {
						type = typeof value;

						// convert relative number strings (+= or -=) to relative numbers. #7345
						if (type === "string" && (ret = rrelNum.exec(value))) {
							value = (ret[1] + 1) * ret[2] + parseFloat(JQXLite.css(elem, name));
							// Fixes bug #9237
							type = "number";
						}

						// Make sure that NaN and null values aren't set. See: #7116
						if (value == null || type === "number" && isNaN(value)) {
							return;
						}

						// If a number was passed in, add 'px' to the (except for certain CSS properties)
						if (type === "number" && !JQXLite.cssNumber[origName]) {
							value += "px";
						}

						// If a hook was provided, use that value, otherwise just set the specified value
						if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
							// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
							// Fixes bug #5509
							try {
								style[name] = value;
							} catch (e) { }
						}

					} else {
						// If a hook was provided get the non-computed value from there
						if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
							return ret;
						}

						// Otherwise just get the value from the style object
						return style[name];
					}
				},

				css: function (elem, name, numeric, extra) {
					var val, num, hooks,
						origName = JQXLite.camelCase(name);

					// Make sure that we're working with the right name
					name = JQXLite.cssProps[origName] || (JQXLite.cssProps[origName] = vendorPropName(elem.style, origName));

					// gets hook for the prefixed version
					// followed by the unprefixed version
					hooks = JQXLite.cssHooks[name] || JQXLite.cssHooks[origName];

					// If a hook was provided get the computed value from there
					if (hooks && "get" in hooks) {
						val = hooks.get(elem, true, extra);
					}

					// Otherwise, if a way to get the computed value exists, use that
					if (val === undefined) {
						val = curCSS(elem, name);
					}

					//convert "normal" to computed value
					if (val === "normal" && name in cssNormalTransform) {
						val = cssNormalTransform[name];
					}

					// Return, converting to number if forced or a qualifier was provided and val looks numeric
					if (numeric || extra !== undefined) {
						num = parseFloat(val);
						return numeric || JQXLite.isNumeric(num) ? num || 0 : val;
					}
					return val;
				},

				// A method for quickly swapping in/out CSS properties to get correct calculations
				swap: function (elem, options, callback) {
					var ret, name,
						old = {};

					// Remember the old values, and insert the new ones
					for (name in options) {
						old[name] = elem.style[name];
						elem.style[name] = options[name];
					}

					ret = callback.call(elem);

					// Revert the old values
					for (name in options) {
						elem.style[name] = old[name];
					}

					return ret;
				}
			});

			// NOTE: To any future maintainer, we've window.getComputedStyle
			// because jsdom on node.js will break without it.
			if (window.getComputedStyle) {
				curCSS = function (elem, name) {
					var ret, width, minWidth, maxWidth,
						computed = window.getComputedStyle(elem, null),
						style = elem.style;

					if (computed) {

						// getPropertyValue is only needed for .css('filter') in IE9, see #12537
						ret = computed.getPropertyValue(name) || computed[name];

						if (ret === "" && !JQXLite.contains(elem.ownerDocument, elem)) {
							ret = JQXLite.style(elem, name);
						}

						// A tribute to the "awesome hack by Dean Edwards"
						// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
						// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
						// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
						if (rnumnonpx.test(ret) && rmargin.test(name)) {
							width = style.width;
							minWidth = style.minWidth;
							maxWidth = style.maxWidth;

							style.minWidth = style.maxWidth = style.width = ret;
							ret = computed.width;

							style.width = width;
							style.minWidth = minWidth;
							style.maxWidth = maxWidth;
						}
					}

					return ret;
				};
			} else if (document.documentElement.currentStyle) {
				curCSS = function (elem, name) {
					var left, rsLeft,
						ret = elem.currentStyle && elem.currentStyle[name],
						style = elem.style;

					// Avoid setting ret to empty string here
					// so we don't default to auto
					if (ret == null && style && style[name]) {
						ret = style[name];
					}

					// From the awesome hack by Dean Edwards
					// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

					// If we're not dealing with a regular pixel number
					// but a number that has a weird ending, we need to convert it to pixels
					// but not position css attributes, as those are proportional to the parent element instead
					// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
					if (rnumnonpx.test(ret) && !rposition.test(name)) {

						// Remember the original values
						left = style.left;
						rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

						// Put in the new values to get a computed value out
						if (rsLeft) {
							elem.runtimeStyle.left = elem.currentStyle.left;
						}
						style.left = name === "fontSize" ? "1em" : ret;
						ret = style.pixelLeft + "px";

						// Revert the changed values
						style.left = left;
						if (rsLeft) {
							elem.runtimeStyle.left = rsLeft;
						}
					}

					return ret === "" ? "auto" : ret;
				};
			}

			function setPositiveNumber(elem, value, subtract) {
				var matches = rnumsplit.exec(value);
				return matches ?
					Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") :
					value;
			}

			function augmentWidthOrHeight(elem, name, extra, isBorderBox) {
				var i = extra === (isBorderBox ? "border" : "content") ?
					// If we already have the right measurement, avoid augmentation
					4 :
					// Otherwise initialize for horizontal or vertical properties
					name === "width" ? 1 : 0,

					val = 0;

				for (; i < 4; i += 2) {
					// both box models exclude margin, so add it if we want it
					if (extra === "margin") {
						// we use JQXLite.css instead of curCSS here
						// because of the reliableMarginRight CSS hook!
						val += JQXLite.css(elem, extra + cssExpand[i], true);
					}

					// From this point on we use curCSS for maximum performance (relevant in animations)
					if (isBorderBox) {
						// border-box includes padding, so remove it if we want content
						if (extra === "content") {
							val -= parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0;
						}

						// at this point, extra isn't border nor margin, so remove border
						if (extra !== "margin") {
							val -= parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
						}
					} else {
						// at this point, extra isn't content, so add padding
						val += parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0;

						// at this point, extra isn't content nor padding, so add border
						if (extra !== "padding") {
							val += parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
						}
					}
				}

				return val;
			}

			function getWidthOrHeight(elem, name, extra) {

				// Start with offset property, which is equivalent to the border-box value
				var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
					valueIsBorderBox = true,
					isBorderBox = JQXLite.support.boxSizing && JQXLite.css(elem, "boxSizing") === "border-box";

				// some non-html elements return undefined for offsetWidth, so check for null/undefined
				// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
				// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
				if (val <= 0 || val == null) {
					// Fall back to computed then uncomputed css if necessary
					val = curCSS(elem, name);
					if (val < 0 || val == null) {
						val = elem.style[name];
					}

					// Computed unit is not pixels. Stop here and return.
					if (rnumnonpx.test(val)) {
						return val;
					}

					// we need the check for style in case a browser which returns unreliable values
					// for getComputedStyle silently falls back to the reliable elem.style
					valueIsBorderBox = isBorderBox && (JQXLite.support.boxSizingReliable || val === elem.style[name]);

					// Normalize "", auto, and prepare for extra
					val = parseFloat(val) || 0;
				}

				// use the active box-sizing model to add/subtract irrelevant styles
				return (val +
					augmentWidthOrHeight(
						elem,
						name,
						extra || (isBorderBox ? "border" : "content"),
						valueIsBorderBox
					)
				) + "px";
			}


			// Try to determine the default display value of an element
			function css_defaultDisplay(nodeName) {
				if (elemdisplay[nodeName]) {
					return elemdisplay[nodeName];
				}

				var elem = JQXLite("<" + nodeName + ">").appendTo(document.body),
					display = elem.css("display");
				elem.remove();

				// If the simple way fails,
				// get element's real default display by attaching it to a temp iframe
				if (display === "none" || display === "") {
					// Use the already-created iframe if possible
					iframe = document.body.appendChild(
						iframe || JQXLite.extend(document.createElement("iframe"), {
							frameBorder: 0,
							width: 0,
							height: 0
						})
					);

					// Create a cacheable copy of the iframe document on first call.
					// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
					// document to it; WebKit & Firefox won't allow reusing the iframe document.
					if (!iframeDoc || !iframe.createElement) {
						iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
						iframeDoc.write("<!doctype html><html><body>");
						iframeDoc.close();
					}

					elem = iframeDoc.body.appendChild(iframeDoc.createElement(nodeName));

					display = curCSS(elem, "display");
					document.body.removeChild(iframe);
				}

				// Store the correct default display
				elemdisplay[nodeName] = display;

				return display;
			}

			JQXLite.each(["height", "width"], function (i, name) {
				JQXLite.cssHooks[name] = {
					get: function (elem, computed, extra) {
						if (computed) {
							// certain elements can have dimension info if we invisibly show them
							// however, it must have a current display style that would benefit from this
							if (elem.offsetWidth === 0 && rdisplayswap.test(curCSS(elem, "display"))) {
								return JQXLite.swap(elem, cssShow, function () {
									return getWidthOrHeight(elem, name, extra);
								});
							} else {
								return getWidthOrHeight(elem, name, extra);
							}
						}
					},

					set: function (elem, value, extra) {
						return setPositiveNumber(elem, value, extra ?
							augmentWidthOrHeight(
								elem,
								name,
								extra,
								JQXLite.support.boxSizing && JQXLite.css(elem, "boxSizing") === "border-box"
							) : 0
						);
					}
				};
			});

			if (!JQXLite.support.opacity) {
				JQXLite.cssHooks.opacity = {
					get: function (elem, computed) {
						// IE uses filters for opacity
						return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
							(0.01 * parseFloat(RegExp.$1)) + "" :
							computed ? "1" : "";
					},

					set: function (elem, value) {
						var style = elem.style,
							currentStyle = elem.currentStyle,
							opacity = JQXLite.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
							filter = currentStyle && currentStyle.filter || style.filter || "";

						// IE has trouble with opacity if it does not have layout
						// Force it by setting the zoom level
						style.zoom = 1;

						// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
						if (value >= 1 && JQXLite.trim(filter.replace(ralpha, "")) === "" &&
							style.removeAttribute) {

							// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
							// if "filter:" is present at all, clearType is disabled, we want to avoid this
							// style.removeAttribute is IE Only, but so apparently is this code path...
							style.removeAttribute("filter");

							// if there there is no filter style applied in a css rule, we are done
							if (currentStyle && !currentStyle.filter) {
								return;
							}
						}

						// otherwise, set new filter values
						style.filter = ralpha.test(filter) ?
							filter.replace(ralpha, opacity) :
							filter + " " + opacity;
					}
				};
			}

			// These hooks cannot be added until DOM ready because the support test
			// for it is not run until after DOM ready
			JQXLite(function () {
				if (!JQXLite.support.reliableMarginRight) {
					JQXLite.cssHooks.marginRight = {
						get: function (elem, computed) {
							// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
							// Work around by temporarily setting element display to inline-block
							return JQXLite.swap(elem, { "display": "inline-block" }, function () {
								if (computed) {
									return curCSS(elem, "marginRight");
								}
							});
						}
					};
				}

				// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
				// getComputedStyle returns percent when specified for top/left/bottom/right
				// rather than make the css module depend on the offset module, we just check for it here
				if (!JQXLite.support.pixelPosition && JQXLite.fn.position) {
					JQXLite.each(["top", "left"], function (i, prop) {
						JQXLite.cssHooks[prop] = {
							get: function (elem, computed) {
								if (computed) {
									var ret = curCSS(elem, prop);
									// if curCSS returns percentage, fallback to offset
									return rnumnonpx.test(ret) ? JQXLite(elem).position()[prop] + "px" : ret;
								}
							}
						};
					});
				}

			});

			if (JQXLite.expr && JQXLite.expr.filters) {
				JQXLite.expr.filters.hidden = function (elem) {
					return (elem.offsetWidth === 0 && elem.offsetHeight === 0) || (!JQXLite.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS(elem, "display")) === "none");
				};

				JQXLite.expr.filters.visible = function (elem) {
					return !JQXLite.expr.filters.hidden(elem);
				};
			}

			// These hooks are used by animate to expand properties
			JQXLite.each({
				margin: "",
				padding: "",
				border: "Width"
			}, function (prefix, suffix) {
				JQXLite.cssHooks[prefix + suffix] = {
					expand: function (value) {
						var i,

							// assumes a single number if not a string
							parts = typeof value === "string" ? value.split(" ") : [value],
							expanded = {};

						for (i = 0; i < 4; i++) {
							expanded[prefix + cssExpand[i] + suffix] =
								parts[i] || parts[i - 2] || parts[0];
						}

						return expanded;
					}
				};

				if (!rmargin.test(prefix)) {
					JQXLite.cssHooks[prefix + suffix].set = setPositiveNumber;
				}
			});
			var r20 = /%20/g,
				rbracket = /\[\]$/,
				rCRLF = /\r?\n/g,
				rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
				rselectTextarea = /^(?:select|textarea)/i;

			JQXLite.fn.extend({
				serialize: function () {
					return JQXLite.param(this.serializeArray());
				},
				serializeArray: function () {
					return this.map(function () {
						return this.elements ? JQXLite.makeArray(this.elements) : this;
					})
						.filter(function () {
							return this.name && !this.disabled &&
								(this.checked || rselectTextarea.test(this.nodeName) ||
									rinput.test(this.type));
						})
						.map(function (i, elem) {
							var val = JQXLite(this).val();

							return val == null ?
								null :
								JQXLite.isArray(val) ?
									JQXLite.map(val, function (val, i) {
										return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
									}) :
									{ name: elem.name, value: val.replace(rCRLF, "\r\n") };
						}).get();
				}
			});

			//Serialize an array of form elements or a set of
			//key/values into a query string
			JQXLite.param = function (a, traditional) {
				var prefix,
					s = [],
					add = function (key, value) {
						// If value is a function, invoke it and return its value
						value = JQXLite.isFunction(value) ? value() : (value == null ? "" : value);
						s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
					};

				// Set traditional to true for JQXLite <= 1.3.2 behavior.
				if (traditional === undefined) {
					traditional = JQXLite.ajaxSettings && JQXLite.ajaxSettings.traditional;
				}

				// If an array was passed in, assume that it is an array of form elements.
				if (JQXLite.isArray(a) || (a.jqx && !JQXLite.isPlainObject(a))) {
					// Serialize the form elements
					JQXLite.each(a, function () {
						add(this.name, this.value);
					});

				} else {
					// If traditional, encode the "old" way (the way 1.3.2 or older
					// did it), otherwise encode params recursively.
					for (prefix in a) {
						buildParams(prefix, a[prefix], traditional, add);
					}
				}

				// Return the resulting serialization
				return s.join("&").replace(r20, "+");
			};

			function buildParams(prefix, obj, traditional, add) {
				var name;

				if (JQXLite.isArray(obj)) {
					// Serialize array item.
					JQXLite.each(obj, function (i, v) {
						if (traditional || rbracket.test(prefix)) {
							// Treat each array item as a scalar.
							add(prefix, v);

						} else {
							// If array item is non-scalar (array or object), encode its
							// numeric index to resolve deserialization ambiguity issues.
							// Note that rack (as of 1.0.0) can't currently deserialize
							// nested arrays properly, and attempting to do so may cause
							// a server error. Possible fixes are to modify rack's
							// deserialization algorithm or to provide an option or flag
							// to force array serialization to be shallow.
							buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
						}
					});

				} else if (!traditional && JQXLite.type(obj) === "object") {
					// Serialize object item.
					for (name in obj) {
						buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
					}

				} else {
					// Serialize scalar item.
					add(prefix, obj);
				}
			}


			// Create transport if the browser can provide an xhr
			if (JQXLite.support.ajax) {

				JQXLite.ajaxTransport(function (s) {
					// Cross domain only allowed if supported through XMLHttpRequest
					if (!s.crossDomain || JQXLite.support.cors) {

						var callback;

						return {
							send: function (headers, complete) {

								// Get a new xhr
								var handle, i,
									xhr = s.xhr();

								// Open the socket
								// Passing null username, generates a login popup on Opera (#2865)
								if (s.username) {
									xhr.open(s.type, s.url, s.async, s.username, s.password);
								} else {
									xhr.open(s.type, s.url, s.async);
								}

								// Apply custom fields if provided
								if (s.xhrFields) {
									for (i in s.xhrFields) {
										xhr[i] = s.xhrFields[i];
									}
								}

								// Override mime type if needed
								if (s.mimeType && xhr.overrideMimeType) {
									xhr.overrideMimeType(s.mimeType);
								}

								// X-Requested-With header
								// For cross-domain requests, seeing as conditions for a preflight are
								// akin to a jigsaw puzzle, we simply never set it to be sure.
								// (it can always be set on a per-request basis or even using ajaxSetup)
								// For same-domain requests, won't change header if already provided.
								if (!s.crossDomain && !headers["X-Requested-With"]) {
									headers["X-Requested-With"] = "XMLHttpRequest";
								}

								// Need an extra try/catch for cross domain requests in Firefox 3
								try {
									for (i in headers) {
										xhr.setRequestHeader(i, headers[i]);
									}
								} catch (_) { }

								// Do send the request
								// This may raise an exception which is actually
								// handled in JQXLite.ajax (so no try/catch here)
								xhr.send((s.hasContent && s.data) || null);

								// Listener
								callback = function (_, isAbort) {

									var status,
										statusText,
										responseHeaders,
										responses,
										xml;

									// Firefox throws exceptions when accessing properties
									// of an xhr when a network error occurred
									// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
									try {

										// Was never called and is aborted or complete
										if (callback && (isAbort || xhr.readyState === 4)) {

											// Only called once
											callback = undefined;

											// Do not keep as active anymore
											if (handle) {
												xhr.onreadystatechange = JQXLite.noop;
												if (xhrOnUnloadAbort) {
													delete xhrCallbacks[handle];
												}
											}

											// If it's an abort
											if (isAbort) {
												// Abort it manually if needed
												if (xhr.readyState !== 4) {
													xhr.abort();
												}
											} else {
												status = xhr.status;
												responseHeaders = xhr.getAllResponseHeaders();
												responses = {};
												xml = xhr.responseXML;

												// Construct response list
												if (xml && xml.documentElement /* #4958 */) {
													responses.xml = xml;
												}

												// When requesting binary data, IE6-9 will throw an exception
												// on any attempt to access responseText (#11426)
												try {
													responses.text = xhr.responseText;
												} catch (e) {
												}

												// Firefox throws an exception when accessing
												// statusText for faulty cross-domain requests
												try {
													statusText = xhr.statusText;
												} catch (e) {
													// We normalize with Webkit giving an empty statusText
													statusText = "";
												}

												// Filter status for non standard behaviors

												// If the request is local and we have data: assume a success
												// (success with no data won't get notified, that's the best we
												// can do given current implementations)
												if (!status && s.isLocal && !s.crossDomain) {
													status = responses.text ? 200 : 404;
													// IE - #1450: sometimes returns 1223 when it should be 204
												} else if (status === 1223) {
													status = 204;
												}
											}
										}
									} catch (firefoxAccessException) {
										if (!isAbort) {
											complete(-1, firefoxAccessException);
										}
									}

									// Call complete if needed
									if (responses) {
										complete(status, statusText, responses, responseHeaders);
									}
								};

								if (!s.async) {
									// if we're in sync mode we fire the callback
									callback();
								} else if (xhr.readyState === 4) {
									// (IE6 & IE7) if it's in cache and has been
									// retrieved directly we need to fire the callback
									setTimeout(callback, 0);
								} else {
									handle = ++xhrId;
									if (xhrOnUnloadAbort) {
										// Create the active xhrs callbacks list if needed
										// and attach the unload handler
										if (!xhrCallbacks) {
											xhrCallbacks = {};
											JQXLite(window).unload(xhrOnUnloadAbort);
										}
										// Add to list of active xhrs callbacks
										xhrCallbacks[handle] = callback;
									}
									xhr.onreadystatechange = callback;
								}
							},

							abort: function () {
								if (callback) {
									callback(0, 1);
								}
							}
						};
					}
				});
			}
			var fxNow, timerId,
				rfxtypes = /^(?:toggle|show|hide)$/,
				rfxnum = new RegExp("^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i"),
				rrun = /queueHooks$/,
				animationPrefilters = [defaultPrefilter],
				tweeners = {
					"*": [function (prop, value) {
						var end, unit,
							tween = this.createTween(prop, value),
							parts = rfxnum.exec(value),
							target = tween.cur(),
							start = +target || 0,
							scale = 1,
							maxIterations = 20;

						if (parts) {
							end = +parts[2];
							unit = parts[3] || (JQXLite.cssNumber[prop] ? "" : "px");

							// We need to compute starting value
							if (unit !== "px" && start) {
								// Iteratively approximate from a nonzero starting point
								// Prefer the current property, because this process will be trivial if it uses the same units
								// Fallback to end or a simple constant
								start = JQXLite.css(tween.elem, prop, true) || end || 1;

								do {
									// If previous iteration zeroed out, double until we get *something*
									// Use a string for doubling factor so we don't accidentally see scale as unchanged below
									scale = scale || ".5";

									// Adjust and apply
									start = start / scale;
									JQXLite.style(tween.elem, prop, start + unit);

									// Update scale, tolerating zero or NaN from tween.cur()
									// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
								} while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
							}

							tween.unit = unit;
							tween.start = start;
							// If a +=/-= token was provided, we're doing a relative animation
							tween.end = parts[1] ? start + (parts[1] + 1) * end : end;
						}
						return tween;
					}]
				};

			// Animations created synchronously will run synchronously
			function createFxNow() {
				setTimeout(function () {
					fxNow = undefined;
				}, 0);
				return (fxNow = JQXLite.now());
			}

			function createTweens(animation, props) {
				JQXLite.each(props, function (prop, value) {
					var collection = (tweeners[prop] || []).concat(tweeners["*"]),
						index = 0,
						length = collection.length;
					for (; index < length; index++) {
						if (collection[index].call(animation, prop, value)) {

							// we're done with this property
							return;
						}
					}
				});
			}

			function Animation(elem, properties, options) {
				var result,
					index = 0,
					tweenerIndex = 0,
					length = animationPrefilters.length,
					deferred = JQXLite.Deferred().always(function () {
						// don't match elem in the :animated selector
						delete tick.elem;
					}),
					tick = function () {
						var currentTime = fxNow || createFxNow(),
							remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
							// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
							temp = remaining / animation.duration || 0,
							percent = 1 - temp,
							index = 0,
							length = animation.tweens.length;

						for (; index < length; index++) {
							animation.tweens[index].run(percent);
						}

						deferred.notifyWith(elem, [animation, percent, remaining]);

						if (percent < 1 && length) {
							return remaining;
						} else {
							deferred.resolveWith(elem, [animation]);
							return false;
						}
					},
					animation = deferred.promise({
						elem: elem,
						props: JQXLite.extend({}, properties),
						opts: JQXLite.extend(true, { specialEasing: {} }, options),
						originalProperties: properties,
						originalOptions: options,
						startTime: fxNow || createFxNow(),
						duration: options.duration,
						tweens: [],
						createTween: function (prop, end, easing) {
							var tween = JQXLite.Tween(elem, animation.opts, prop, end,
								animation.opts.specialEasing[prop] || animation.opts.easing);
							animation.tweens.push(tween);
							return tween;
						},
						stop: function (gotoEnd) {
							var index = 0,
								// if we are going to the end, we want to run all the tweens
								// otherwise we skip this part
								length = gotoEnd ? animation.tweens.length : 0;

							for (; index < length; index++) {
								animation.tweens[index].run(1);
							}

							// resolve when we played the last frame
							// otherwise, reject
							if (gotoEnd) {
								deferred.resolveWith(elem, [animation, gotoEnd]);
							} else {
								deferred.rejectWith(elem, [animation, gotoEnd]);
							}
							return this;
						}
					}),
					props = animation.props;

				propFilter(props, animation.opts.specialEasing);

				for (; index < length; index++) {
					result = animationPrefilters[index].call(animation, elem, props, animation.opts);
					if (result) {
						return result;
					}
				}

				createTweens(animation, props);

				if (JQXLite.isFunction(animation.opts.start)) {
					animation.opts.start.call(elem, animation);
				}

				JQXLite.fx.timer(
					JQXLite.extend(tick, {
						anim: animation,
						queue: animation.opts.queue,
						elem: elem
					})
				);

				// attach callbacks from options
				return animation.progress(animation.opts.progress)
					.done(animation.opts.done, animation.opts.complete)
					.fail(animation.opts.fail)
					.always(animation.opts.always);
			}

			function propFilter(props, specialEasing) {
				var index, name, easing, value, hooks;

				// camelCase, specialEasing and expand cssHook pass
				for (index in props) {
					name = JQXLite.camelCase(index);
					easing = specialEasing[name];
					value = props[index];
					if (JQXLite.isArray(value)) {
						easing = value[1];
						value = props[index] = value[0];
					}

					if (index !== name) {
						props[name] = value;
						delete props[index];
					}

					hooks = JQXLite.cssHooks[name];
					if (hooks && "expand" in hooks) {
						value = hooks.expand(value);
						delete props[name];

						// not quite $.extend, this wont overwrite keys already present.
						// also - reusing 'index' from above because we have the correct "name"
						for (index in value) {
							if (!(index in props)) {
								props[index] = value[index];
								specialEasing[index] = easing;
							}
						}
					} else {
						specialEasing[name] = easing;
					}
				}
			}

			JQXLite.Animation = JQXLite.extend(Animation, {

				tweener: function (props, callback) {
					if (JQXLite.isFunction(props)) {
						callback = props;
						props = ["*"];
					} else {
						props = props.split(" ");
					}

					var prop,
						index = 0,
						length = props.length;

					for (; index < length; index++) {
						prop = props[index];
						tweeners[prop] = tweeners[prop] || [];
						tweeners[prop].unshift(callback);
					}
				},

				prefilter: function (callback, prepend) {
					if (prepend) {
						animationPrefilters.unshift(callback);
					} else {
						animationPrefilters.push(callback);
					}
				}
			});

			function defaultPrefilter(elem, props, opts) {
				var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
					anim = this,
					style = elem.style,
					orig = {},
					handled = [],
					hidden = elem.nodeType && isHidden(elem);

				// handle queue: false promises
				if (!opts.queue) {
					hooks = JQXLite._queueHooks(elem, "fx");
					if (hooks.unqueued == null) {
						hooks.unqueued = 0;
						oldfire = hooks.empty.fire;
						hooks.empty.fire = function () {
							if (!hooks.unqueued) {
								oldfire();
							}
						};
					}
					hooks.unqueued++;

					anim.always(function () {
						// doing this makes sure that the complete handler will be called
						// before this completes
						anim.always(function () {
							hooks.unqueued--;
							if (!JQXLite.queue(elem, "fx").length) {
								hooks.empty.fire();
							}
						});
					});
				}

				// height/width overflow pass
				if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opts.overflow = [style.overflow, style.overflowX, style.overflowY];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if (JQXLite.css(elem, "display") === "inline" &&
						JQXLite.css(elem, "float") === "none") {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if (!JQXLite.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName) === "inline") {
							style.display = "inline-block";

						} else {
							style.zoom = 1;
						}
					}
				}

				if (opts.overflow) {
					style.overflow = "hidden";
					if (!JQXLite.support.shrinkWrapBlocks) {
						anim.done(function () {
							style.overflow = opts.overflow[0];
							style.overflowX = opts.overflow[1];
							style.overflowY = opts.overflow[2];
						});
					}
				}


				// show/hide pass
				for (index in props) {
					value = props[index];
					if (rfxtypes.exec(value)) {
						delete props[index];
						toggle = toggle || value === "toggle";
						if (value === (hidden ? "hide" : "show")) {
							continue;
						}
						handled.push(index);
					}
				}

				length = handled.length;
				if (length) {
					dataShow = JQXLite._data(elem, "fxshow") || JQXLite._data(elem, "fxshow", {});
					if ("hidden" in dataShow) {
						hidden = dataShow.hidden;
					}

					// store state if its toggle - enables .stop().toggle() to "reverse"
					if (toggle) {
						dataShow.hidden = !hidden;
					}
					if (hidden) {
						JQXLite(elem).show();
					} else {
						anim.done(function () {
							JQXLite(elem).hide();
						});
					}
					anim.done(function () {
						var prop;
						JQXLite.removeData(elem, "fxshow", true);
						for (prop in orig) {
							JQXLite.style(elem, prop, orig[prop]);
						}
					});
					for (index = 0; index < length; index++) {
						prop = handled[index];
						tween = anim.createTween(prop, hidden ? dataShow[prop] : 0);
						orig[prop] = dataShow[prop] || JQXLite.style(elem, prop);

						if (!(prop in dataShow)) {
							dataShow[prop] = tween.start;
							if (hidden) {
								tween.end = tween.start;
								tween.start = prop === "width" || prop === "height" ? 1 : 0;
							}
						}
					}
				}
			}

			function Tween(elem, options, prop, end, easing) {
				return new Tween.prototype.init(elem, options, prop, end, easing);
			}
			JQXLite.Tween = Tween;

			Tween.prototype = {
				constructor: Tween,
				init: function (elem, options, prop, end, easing, unit) {
					this.elem = elem;
					this.prop = prop;
					this.easing = easing || "swing";
					this.options = options;
					this.start = this.now = this.cur();
					this.end = end;
					this.unit = unit || (JQXLite.cssNumber[prop] ? "" : "px");
				},
				cur: function () {
					var hooks = Tween.propHooks[this.prop];

					return hooks && hooks.get ?
						hooks.get(this) :
						Tween.propHooks._default.get(this);
				},
				run: function (percent) {
					var eased,
						hooks = Tween.propHooks[this.prop];

					if (this.options.duration) {
						this.pos = eased = JQXLite.easing[this.easing](
							percent, this.options.duration * percent, 0, 1, this.options.duration
						);
					} else {
						this.pos = eased = percent;
					}
					this.now = (this.end - this.start) * eased + this.start;

					if (this.options.step) {
						this.options.step.call(this.elem, this.now, this);
					}

					if (hooks && hooks.set) {
						hooks.set(this);
					} else {
						Tween.propHooks._default.set(this);
					}
					return this;
				}
			};

			Tween.prototype.init.prototype = Tween.prototype;

			Tween.propHooks = {
				_default: {
					get: function (tween) {
						var result;

						if (tween.elem[tween.prop] != null &&
							(!tween.elem.style || tween.elem.style[tween.prop] == null)) {
							return tween.elem[tween.prop];
						}

						// passing any value as a 4th parameter to .css will automatically
						// attempt a parseFloat and fallback to a string if the parse fails
						// so, simple values such as "10px" are parsed to Float.
						// complex values such as "rotate(1rad)" are returned as is.
						result = JQXLite.css(tween.elem, tween.prop, false, "");
						// Empty strings, null, undefined and "auto" are converted to 0.
						return !result || result === "auto" ? 0 : result;
					},
					set: function (tween) {
						// use step hook for back compat - use cssHook if its there - use .style if its
						// available and use plain properties where available
						if (JQXLite.fx.step[tween.prop]) {
							JQXLite.fx.step[tween.prop](tween);
						} else if (tween.elem.style && (tween.elem.style[JQXLite.cssProps[tween.prop]] != null || JQXLite.cssHooks[tween.prop])) {
							JQXLite.style(tween.elem, tween.prop, tween.now + tween.unit);
						} else {
							tween.elem[tween.prop] = tween.now;
						}
					}
				}
			};

			// Remove in 2.0 - this supports IE8's panic based approach
			// to setting things on disconnected nodes

			Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
				set: function (tween) {
					if (tween.elem.nodeType && tween.elem.parentNode) {
						tween.elem[tween.prop] = tween.now;
					}
				}
			};

			JQXLite.each(["toggle", "show", "hide"], function (i, name) {
				var cssFn = JQXLite.fn[name];
				JQXLite.fn[name] = function (speed, easing, callback) {
					return speed == null || typeof speed === "boolean" ||
						// special check for .toggle( handler, handler, ... )
						(!i && JQXLite.isFunction(speed) && JQXLite.isFunction(easing)) ?
						cssFn.apply(this, arguments) :
						this.animate(genFx(name, true), speed, easing, callback);
				};
			});

			JQXLite.fn.extend({
				fadeTo: function (speed, to, easing, callback) {

					// show any hidden elements after setting opacity to 0
					return this.filter(isHidden).css("opacity", 0).show()

						// animate to the value specified
						.end().animate({ opacity: to }, speed, easing, callback);
				},
				animate: function (prop, speed, easing, callback) {
					var empty = JQXLite.isEmptyObject(prop),
						optall = JQXLite.speed(speed, easing, callback),
						doAnimation = function () {
							// Operate on a copy of prop so per-property easing won't be lost
							var anim = Animation(this, JQXLite.extend({}, prop), optall);

							// Empty animations resolve immediately
							if (empty) {
								anim.stop(true);
							}
						};

					return empty || optall.queue === false ?
						this.each(doAnimation) :
						this.queue(optall.queue, doAnimation);
				},
				stop: function (type, clearQueue, gotoEnd) {
					var stopQueue = function (hooks) {
						var stop = hooks.stop;
						delete hooks.stop;
						stop(gotoEnd);
					};

					if (typeof type !== "string") {
						gotoEnd = clearQueue;
						clearQueue = type;
						type = undefined;
					}
					if (clearQueue && type !== false) {
						this.queue(type || "fx", []);
					}

					return this.each(function () {
						var dequeue = true,
							index = type != null && type + "queueHooks",
							timers = JQXLite.timers,
							data = JQXLite._data(this);

						if (index) {
							if (data[index] && data[index].stop) {
								stopQueue(data[index]);
							}
						} else {
							for (index in data) {
								if (data[index] && data[index].stop && rrun.test(index)) {
									stopQueue(data[index]);
								}
							}
						}

						for (index = timers.length; index--;) {
							if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
								timers[index].anim.stop(gotoEnd);
								dequeue = false;
								timers.splice(index, 1);
							}
						}

						// start the next in the queue if the last step wasn't forced
						// timers currently will call their complete callbacks, which will dequeue
						// but only if they were gotoEnd
						if (dequeue || !gotoEnd) {
							JQXLite.dequeue(this, type);
						}
					});
				}
			});

			// Generate parameters to create a standard animation
			function genFx(type, includeWidth) {
				var which,
					attrs = { height: type },
					i = 0;

				// if we include width, step value is 1 to do all cssExpand values,
				// if we don't include width, step value is 2 to skip over Left and Right
				includeWidth = includeWidth ? 1 : 0;
				for (; i < 4; i += 2 - includeWidth) {
					which = cssExpand[i];
					attrs["margin" + which] = attrs["padding" + which] = type;
				}

				if (includeWidth) {
					attrs.opacity = attrs.width = type;
				}

				return attrs;
			}

			// Generate shortcuts for custom animations
			JQXLite.each({
				slideDown: genFx("show"),
				slideUp: genFx("hide"),
				slideToggle: genFx("toggle"),
				fadeIn: { opacity: "show" },
				fadeOut: { opacity: "hide" },
				fadeToggle: { opacity: "toggle" }
			}, function (name, props) {
				JQXLite.fn[name] = function (speed, easing, callback) {
					return this.animate(props, speed, easing, callback);
				};
			});

			JQXLite.speed = function (speed, easing, fn) {
				var opt = speed && typeof speed === "object" ? JQXLite.extend({}, speed) : {
					complete: fn || !fn && easing ||
						JQXLite.isFunction(speed) && speed,
					duration: speed,
					easing: fn && easing || easing && !JQXLite.isFunction(easing) && easing
				};

				opt.duration = JQXLite.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
					opt.duration in JQXLite.fx.speeds ? JQXLite.fx.speeds[opt.duration] : JQXLite.fx.speeds._default;

				// normalize opt.queue - true/undefined/null -> "fx"
				if (opt.queue == null || opt.queue === true) {
					opt.queue = "fx";
				}

				// Queueing
				opt.old = opt.complete;

				opt.complete = function () {
					if (JQXLite.isFunction(opt.old)) {
						opt.old.call(this);
					}

					if (opt.queue) {
						JQXLite.dequeue(this, opt.queue);
					}
				};

				return opt;
			};

			JQXLite.easing = {
				linear: function (p) {
					return p;
				},
				swing: function (p) {
					return 0.5 - Math.cos(p * Math.PI) / 2;
				}
			};

			JQXLite.timers = [];
			JQXLite.fx = Tween.prototype.init;
			JQXLite.fx.tick = function () {
				var timer,
					timers = JQXLite.timers,
					i = 0;

				fxNow = JQXLite.now();

				for (; i < timers.length; i++) {
					timer = timers[i];
					// Checks the timer has not already been removed
					if (!timer() && timers[i] === timer) {
						timers.splice(i--, 1);
					}
				}

				if (!timers.length) {
					JQXLite.fx.stop();
				}
				fxNow = undefined;
			};

			JQXLite.fx.timer = function (timer) {
				if (timer() && JQXLite.timers.push(timer) && !timerId) {
					timerId = setInterval(JQXLite.fx.tick, JQXLite.fx.interval);
				}
			};

			JQXLite.fx.interval = 13;

			JQXLite.fx.stop = function () {
				clearInterval(timerId);
				timerId = null;
			};

			JQXLite.fx.speeds = {
				slow: 600,
				fast: 200,
				// Default speed
				_default: 400
			};

			// Back Compat <1.8 extension point
			JQXLite.fx.step = {};

			if (JQXLite.expr && JQXLite.expr.filters) {
				JQXLite.expr.filters.animated = function (elem) {
					return JQXLite.grep(JQXLite.timers, function (fn) {
						return elem === fn.elem;
					}).length;
				};
			}
			var rroot = /^(?:body|html)$/i;

			JQXLite.fn.offset = function (options) {
				if (arguments.length) {
					return options === undefined ?
						this :
						this.each(function (i) {
							JQXLite.offset.setOffset(this, options, i);
						});
				}

				var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
					box = { top: 0, left: 0 },
					elem = this[0],
					doc = elem && elem.ownerDocument;

				if (!doc) {
					return;
				}

				if ((body = doc.body) === elem) {
					return JQXLite.offset.bodyOffset(elem);
				}

				docElem = doc.documentElement;

				// Make sure it's not a disconnected DOM node
				if (!JQXLite.contains(docElem, elem)) {
					return box;
				}

				// If we don't have gBCR, just use 0,0 rather than error
				// BlackBerry 5, iOS 3 (original iPhone)
				if (typeof elem.getBoundingClientRect !== "undefined") {
					box = elem.getBoundingClientRect();
				}
				win = getWindow(doc);
				clientTop = docElem.clientTop || body.clientTop || 0;
				clientLeft = docElem.clientLeft || body.clientLeft || 0;
				scrollTop = win.pageYOffset || docElem.scrollTop;
				scrollLeft = win.pageXOffset || docElem.scrollLeft;
				return {
					top: box.top + scrollTop - clientTop,
					left: box.left + scrollLeft - clientLeft
				};
			};

			JQXLite.offset = {

				bodyOffset: function (body) {
					var top = body.offsetTop,
						left = body.offsetLeft;

					if (JQXLite.support.doesNotIncludeMarginInBodyOffset) {
						top += parseFloat(JQXLite.css(body, "marginTop")) || 0;
						left += parseFloat(JQXLite.css(body, "marginLeft")) || 0;
					}

					return { top: top, left: left };
				},

				setOffset: function (elem, options, i) {
					var position = JQXLite.css(elem, "position");

					// set position first, in-case top/left are set even on static elem
					if (position === "static") {
						elem.style.position = "relative";
					}

					var curElem = JQXLite(elem),
						curOffset = curElem.offset(),
						curCSSTop = JQXLite.css(elem, "top"),
						curCSSLeft = JQXLite.css(elem, "left"),
						calculatePosition = (position === "absolute" || position === "fixed") && JQXLite.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
						props = {}, curPosition = {}, curTop, curLeft;

					// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
					if (calculatePosition) {
						curPosition = curElem.position();
						curTop = curPosition.top;
						curLeft = curPosition.left;
					} else {
						curTop = parseFloat(curCSSTop) || 0;
						curLeft = parseFloat(curCSSLeft) || 0;
					}

					if (JQXLite.isFunction(options)) {
						options = options.call(elem, i, curOffset);
					}

					if (options.top != null) {
						props.top = (options.top - curOffset.top) + curTop;
					}
					if (options.left != null) {
						props.left = (options.left - curOffset.left) + curLeft;
					}

					if ("using" in options) {
						options.using.call(elem, props);
					} else {
						curElem.css(props);
					}
				}
			};


			JQXLite.fn.extend({
				isRendered: function () {
					var that = this;
					var element = this[0];
					if (element.parentNode == null || (element.offsetWidth === 0 || element.offsetHeight === 0)) {
						return false;
					}

					return true;
				},

				getSizeFromStyle: function () {
					var that = this;
					var width = null;
					var height = null;
					var element = this[0];
					var computedStyle;

					if (element.style.width) {
						width = element.style.width;
					}
					if (element.style.height) {
						height = element.style.height;
					}

					if (window.getComputedStyle) {
						computedStyle = getComputedStyle(element, null);
					}
					else {
						computedStyle = element.currentStyle;
					}

					if (computedStyle) {
						if (computedStyle.width) {
							width = computedStyle.width;
						}
						if (computedStyle.height) {
							height = computedStyle.height;
						}
					}
					if (width === '0px') width = 0;
					if (height === '0px') height = 0;
					if (width === null) width = 0;
					if (height === null) height = 0;

					return { width: width, height: height };
				},

				initAnimate: function () {

				},

				sizeStyleChanged: function (resizeFn) {
					var that = this;

					var watchedElementData;

					var checkForChanges = function (mutations) {
						var data = watchedElementData;
						if (mutations && mutations[0] && mutations[0].attributeName === 'style' && mutations[0].type === 'attributes') {
							if (data.element.offsetWidth !== data.offsetWidth ||
								data.element.offsetHeight !== data.offsetHeight) {
								data.offsetWidth = data.element.offsetWidth;
								data.offsetHeight = data.element.offsetHeight;
								if (that.isRendered()) {
									data.callback();
								}
							}
						}
					}

					watchedElementData = {
						element: that[0],
						offsetWidth: that[0].offsetWidth,
						offsetHeight: that[0].offsetHeight,
						callback: resizeFn
					};

					try {
						if (!that.elementStyleObserver) {
							that.elementStyleObserver = new MutationObserver(checkForChanges);
							that.elementStyleObserver.observe(that[0], {
								attributes: true,
								childList: false,
								characterData: false
							});

						}
					}
					catch (error) { }
				},

				position: function () {
					if (!this[0]) {
						return;
					}

					var elem = this[0],

						// Get *real* offsetParent
						offsetParent = this.offsetParent(),

						// Get correct offsets
						offset = this.offset(),
						parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

					// Subtract element margins
					// note: when an element has margin: auto the offsetLeft and marginLeft
					// are the same in Safari causing offset.left to incorrectly be 0
					offset.top -= parseFloat(JQXLite.css(elem, "marginTop")) || 0;
					offset.left -= parseFloat(JQXLite.css(elem, "marginLeft")) || 0;

					// Add offsetParent borders
					parentOffset.top += parseFloat(JQXLite.css(offsetParent[0], "borderTopWidth")) || 0;
					parentOffset.left += parseFloat(JQXLite.css(offsetParent[0], "borderLeftWidth")) || 0;

					// Subtract the two offsets
					return {
						top: offset.top - parentOffset.top,
						left: offset.left - parentOffset.left
					};
				},

				offsetParent: function () {
					return this.map(function () {
						var offsetParent = this.offsetParent || document.body;
						while (offsetParent && (!rroot.test(offsetParent.nodeName) && JQXLite.css(offsetParent, "position") === "static")) {
							offsetParent = offsetParent.offsetParent;
						}
						return offsetParent || document.body;
					});
				}
			});
			// Create scrollLeft and scrollTop methods
			JQXLite.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
				var top = /Y/.test(prop);

				JQXLite.fn[method] = function (val) {
					return JQXLite.access(this, function (elem, method, val) {
						var win = getWindow(elem);

						if (val === undefined) {
							return win ? (prop in win) ? win[prop] :
								win.document.documentElement[method] :
								elem[method];
						}

						if (win) {
							win.scrollTo(
								!top ? val : JQXLite(win).scrollLeft(),
								top ? val : JQXLite(win).scrollTop()
							);

						} else {
							elem[method] = val;
						}
					}, method, val, arguments.length, null);
				};
			});

			function getWindow(elem) {
				return JQXLite.isWindow(elem) ?
					elem :
					elem.nodeType === 9 ?
						elem.defaultView || elem.parentWindow :
						false;
			}
			// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
			JQXLite.each({ Height: "height", Width: "width" }, function (name, type) {
				JQXLite.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {
					// margin is only for outerHeight, outerWidth
					JQXLite.fn[funcName] = function (margin, value) {
						var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
							extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

						return JQXLite.access(this, function (elem, type, value) {
							var doc;

							if (JQXLite.isWindow(elem)) {
								// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
								// isn't a whole lot we can do. See pull request at this URL for discussion:
								// https://github.com/jqx/jqx/pull/764
								return elem.document.documentElement["client" + name];
							}

							// Get document width or height
							if (elem.nodeType === 9) {
								doc = elem.documentElement;

								// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
								// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
								return Math.max(
									elem.body["scroll" + name], doc["scroll" + name],
									elem.body["offset" + name], doc["offset" + name],
									doc["client" + name]
								);
							}

							return value === undefined ?
								// Get width or height on the element, requesting but not forcing parseFloat
								JQXLite.css(elem, type, value, extra) :

								// Set width or height on the element
								JQXLite.style(elem, type, value, extra);
						}, type, chainable ? margin : undefined, chainable, null);
					};
				});
			});
			// Expose JQXLite to the global object
			window.JQXLite = window.jqxHelper = JQXLite;

			// Expose JQXLite as an AMD module, but only for AMD loaders that
			// understand the issues with loading multiple versions of JQXLite
			// in a page that all might call define(). The loader will indicate
			// they have special allowances for multiple JQXLite versions by
			// specifying define.amd.JQXLite = true. Register as a named module,
			// since JQXLite can be concatenated with other files that may use define,
			// but not use a proper concatenation script that understands anonymous
			// AMD modules. A named AMD is safest and most robust way to register.
			// Lowercase jqx is used because AMD module names are derived from
			// file names, and JQXLite is normally delivered in a lowercase file name.
			// Do this after creating the global so that if an AMD module wants to call
			// noConflict to hide this version of JQXLite, it will work.
			if ( true && __webpack_require__.amdO.JQXLite) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () { return JQXLite; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			}

		})(window);
	}

	// jqxHelper
	(function (window) {
		if (window.jqxCore) {
			window.$$ = window.minQuery = window.JQXLite;

			if (!window.$) {
				window.$ = window.minQuery;
			}

			return;
		}

		if (window.jQuery) {
			if (window.jQuery.fn.extend) {
				window.jQuery.fn.stop = window.JQXLite.fn.stop;
				window.jQuery.fn.animate = window.JQXLite.fn.animate;

				var keys = Object.keys(window.JQXLite.fn);
				for (var index in keys) {
					var key = keys[index];
					if (window.jQuery.fn[key] == undefined) {
						window.jQuery.fn[key] = window.JQXLite.fn[key];
					}
				}
			}

			window.minQuery = window.JQXLite = window.jQuery;
			return;
		}

		if (!window.$) {
			window.$ = window.minQuery = window.JQXLite;
		}
		else {
			window.minQuery = window.JQXLite = window.$;
		}
	})(window);
	// End of jqxHelper

	JQXLite.generateID = function () {
		var S4 = function () {
			return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
		};

		var id = "";
		do {
			id = "jqx" + S4() + S4() + S4();
		} while ($('#' + id).length > 0);

		return id;
	}

	var jqxBaseFramework = window.jqxBaseFramework = window.minQuery || window.jQuery;

	(function ($) {

		$.jqx = $.jqx || {}
		window.jqx = $.jqx;

		var jqwidgets = {
			createInstance: function (selector, widgetName, params) {
				if (widgetName == 'jqxDataAdapter') {
					var source = params[0];
					var settings = params[1] || {};
					return new $.jqx.dataAdapter(source, settings);
				}

				$(selector)[widgetName](params || {});
				return $(selector)[widgetName]('getInstance');
			}
		};

		window.jqwidgets = jqwidgets;

		$.jqx.define = function (namespace, classname, baseclass) {
			namespace[classname] = function () {
				if (this.baseType) {
					this.base = new namespace[this.baseType]();
					this.base.defineInstance();
				}
				this.defineInstance();
				this.metaInfo();
			}

			namespace[classname].prototype.defineInstance = function () { };
			namespace[classname].prototype.metaInfo = function () { };
			namespace[classname].prototype.base = null;
			namespace[classname].prototype.baseType = undefined;

			if (baseclass && namespace[baseclass])
				namespace[classname].prototype.baseType = baseclass;
		}

		// method call
		$.jqx.invoke = function (object, args) {
			if (args.length == 0)
				return;

			var method = typeof (args) == Array || args.length > 0 ? args[0] : args;
			var methodArg = typeof (args) == Array || args.length > 1 ? Array.prototype.slice.call(args, 1) : $({}).toArray();

			while (object[method] == undefined && object.base != null) {
				if (object[method] != undefined && $.isFunction(object[method]))
					return object[method].apply(object, methodArg);

				if (typeof method == 'string') {
					var methodLowerCase = method.toLowerCase();
					if (object[methodLowerCase] != undefined && $.isFunction(object[methodLowerCase])) {
						return object[methodLowerCase].apply(object, methodArg);
					}
				}
				object = object.base;
			}

			if (object[method] != undefined && $.isFunction(object[method]))
				return object[method].apply(object, methodArg);

			if (typeof method == 'string') {
				var methodLowerCase = method.toLowerCase();
				if (object[methodLowerCase] != undefined && $.isFunction(object[methodLowerCase])) {
					return object[methodLowerCase].apply(object, methodArg);
				}
			}

			return;
		}

		$.jqx.getByPriority = function (arr) {
			var value = undefined;
			for (var i = 0; i < arr.length && value == undefined; i++) {
				if (value == undefined && arr[i] != undefined)
					value = arr[i];
			}

			return value;
		}

		$.jqx.hasProperty = function (obj, property) {
			if (typeof (property) == 'object') {
				for (var prop in property) {
					var o = obj;
					while (o) {
						if (o.hasOwnProperty(prop))
							return true;
						if (o.hasOwnProperty(prop.toLowerCase()))
							return true;
						o = o.base;
					}
					return false;
				}
			}
			else {
				while (obj) {
					if (obj.hasOwnProperty(property))
						return true;
					if (obj.hasOwnProperty(property.toLowerCase()))
						return true;
					obj = obj.base;
				}
			}

			return false;
		}

		$.jqx.hasFunction = function (object, args) {
			if (args.length == 0)
				return false;

			if (object == undefined)
				return false;

			var method = typeof (args) == Array || args.length > 0 ? args[0] : args;
			var methodArg = typeof (args) == Array || args.length > 1 ? Array.prototype.slice.call(args, 1) : {};

			while (object[method] == undefined && object.base != null) {
				if (object[method] && $.isFunction(object[method]))
					return true;

				if (typeof method == 'string') {
					var methodLowerCase = method.toLowerCase();
					if (object[methodLowerCase] && $.isFunction(object[methodLowerCase]))
						return true;
				}
				object = object.base;
			}

			if (object[method] && $.isFunction(object[method]))
				return true;

			if (typeof method == 'string') {
				var methodLowerCase = method.toLowerCase();
				if (object[methodLowerCase] && $.isFunction(object[methodLowerCase]))
					return true;
			}

			return false;
		}

		$.jqx.isPropertySetter = function (obj, args) {
			if (args.length == 1 && typeof (args[0]) == 'object')
				return true;

			if (args.length == 2 &&
				typeof (args[0]) == 'string' &&
				!$.jqx.hasFunction(obj, args)) {
				return true;
			}

			return false;
		}

		$.jqx.validatePropertySetter = function (obj, args, suppressException) {
			if (!$.jqx.propertySetterValidation)
				return true;

			if (args.length == 1 && typeof (args[0]) == 'object') {
				for (var i in args[0]) {
					var o = obj;
					while (!o.hasOwnProperty(i) && o.base)
						o = o.base;

					if (!o || !o.hasOwnProperty(i)) {
						if (!suppressException) {
							var hasLowerCase = o.hasOwnProperty(i.toString().toLowerCase());
							if (!hasLowerCase) {
								throw 'Invalid property: ' + i;
							}
							else return true;
						}
						return false;
					}
				}

				return true;
			}

			if (args.length != 2) {
				if (!suppressException)
					throw 'Invalid property: ' + args.length >= 0 ? args[0] : '';

				return false;
			}

			while (!obj.hasOwnProperty(args[0]) && obj.base)
				obj = obj.base;

			if (!obj || !obj.hasOwnProperty(args[0])) {
				if (!suppressException)
					throw 'Invalid property: ' + args[0];

				return false;
			}

			return true;
		}

		if (!Object.keys) {
			Object.keys = (function () {
				'use strict';
				var hasOwnProperty = Object.prototype.hasOwnProperty,
					hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),
					dontEnums = [
						'toString',
						'toLocaleString',
						'valueOf',
						'hasOwnProperty',
						'isPrototypeOf',
						'propertyIsEnumerable',
						'constructor'
					],
					dontEnumsLength = dontEnums.length;

				return function (obj) {
					if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
						throw new TypeError('Object.keys called on non-object');
					}

					var result = [], prop, i;

					for (prop in obj) {
						if (hasOwnProperty.call(obj, prop)) {
							result.push(prop);
						}
					}

					if (hasDontEnumBug) {
						for (i = 0; i < dontEnumsLength; i++) {
							if (hasOwnProperty.call(obj, dontEnums[i])) {
								result.push(dontEnums[i]);
							}
						}
					}
					return result;
				};
			}());
		}

		$.jqx.set = function (object, args) {
			var newValuesLength = 0;
			if (args.length == 1 && typeof (args[0]) == 'object') {
				if (object.isInitialized && Object.keys && Object.keys(args[0]).length > 1) {
					var element = !object.base ? object.element : object.base.element;
					var initArgs = $.data(element, object.widgetName).initArgs;
					if (initArgs && JSON && JSON.stringify && args[0] && initArgs[0]) {
						try {
							if (JSON.stringify(args[0]) == JSON.stringify(initArgs[0])) {
								var toReturn = true;
								$.each(args[0], function (key, value) {
									if (object[key] != value) {
										toReturn = false;
										return false;
									}
								});
								if (toReturn) {
									return;
								}
							}
						}
						catch (err) {
						}
					}
					object.batchUpdate = args[0];
					var oldValues = {};
					var newValues = {};
					$.each(args[0], function (key, value) {
						var obj = object;
						while (!obj.hasOwnProperty(key) && obj.base != null)
							obj = obj.base;

						if (obj.hasOwnProperty(key)) {
							if (object[key] != value) {
								oldValues[key] = object[key];
								newValues[key] = value;
								newValuesLength++;
							}
						}
						else if (obj.hasOwnProperty(key.toLowerCase())) {
							if (object[key.toLowerCase()] != value) {
								oldValues[key.toLowerCase()] = object[key.toLowerCase()];
								newValues[key.toLowerCase()] = value;
								newValuesLength++;
							}
						}
					});
					if (newValuesLength < 2) {
						object.batchUpdate = null;
					}
				}

				$.each(args[0], function (key, value) {
					var obj = object;
					while (!obj.hasOwnProperty(key) && obj.base != null)
						obj = obj.base;

					if (obj.hasOwnProperty(key)) {
						$.jqx.setvalueraiseevent(obj, key, value);
					}
					else if (obj.hasOwnProperty(key.toLowerCase())) {
						$.jqx.setvalueraiseevent(obj, key.toLowerCase(), value);
					}
					else if ($.jqx.propertySetterValidation)
						throw "jqxCore: invalid property '" + key + "'";
				});

				if (object.batchUpdate != null) {
					object.batchUpdate = null;
					if (object.propertiesChangedHandler && newValuesLength > 1) {
						object.propertiesChangedHandler(object, oldValues, newValues);
					}
				}
			}
			else if (args.length == 2) {
				while (!object.hasOwnProperty(args[0]) && object.base)
					object = object.base;

				if (object.hasOwnProperty(args[0])) {
					$.jqx.setvalueraiseevent(object, args[0], args[1]);
				}
				else if (object.hasOwnProperty(args[0].toLowerCase())) {
					$.jqx.setvalueraiseevent(object, args[0].toLowerCase(), args[1]);
				}
				else if ($.jqx.propertySetterValidation)
					throw "jqxCore: invalid property '" + args[0] + "'";
			}
		}

		$.jqx.setvalueraiseevent = function (object, key, value) {
			var oldVal = object[key];

			object[key] = value;

			if (!object.isInitialized)
				return;

			if (object.propertyChangedHandler != undefined)
				object.propertyChangedHandler(object, key, oldVal, value);

			if (object.propertyChangeMap != undefined && object.propertyChangeMap[key] != undefined)
				object.propertyChangeMap[key](object, key, oldVal, value);
		};

		$.jqx.get = function (object, args) {
			if (args == undefined || args == null)
				return undefined;

			if (object.propertyMap) {
				var newVal = object.propertyMap(args);
				if (newVal != null)
					return newVal;
			}

			if (object.hasOwnProperty(args))
				return object[args];

			if (object.hasOwnProperty(args.toLowerCase()))
				return object[args.toLowerCase()];

			var arg = undefined;
			if (typeof (args) == Array) {
				if (args.length != 1)
					return undefined;
				arg = args[0];
			}
			else if (typeof (args) == 'string')
				arg = args;

			while (!object.hasOwnProperty(arg) && object.base)
				object = object.base;

			if (object)
				return object[arg];

			return undefined;
		}

		$.jqx.serialize = function (obj) {
			var txt = '';
			if ($.isArray(obj)) {
				txt = '['
				for (var i = 0; i < obj.length; i++) {
					if (i > 0)
						txt += ', ';
					txt += $.jqx.serialize(obj[i]);
				}
				txt += ']';
			}
			else if (typeof (obj) == 'object') {
				txt = '{';
				var j = 0;
				for (var i in obj) {
					if (j++ > 0)
						txt += ', ';
					txt += i + ': ' + $.jqx.serialize(obj[i]);
				}
				txt += '}';
			}
			else
				txt = obj.toString();

			return txt;
		}

		$.jqx.propertySetterValidation = true;

		$.jqx.jqxWidgetProxy = function (controlName, element, args) {
			var host = $(element);
			var vars = $.data(element, controlName);
			if (vars == undefined) {
				return undefined;
			}

			var obj = vars.instance;

			if ($.jqx.hasFunction(obj, args))
				return $.jqx.invoke(obj, args);

			if ($.jqx.isPropertySetter(obj, args)) {
				if ($.jqx.validatePropertySetter(obj, args)) {
					$.jqx.set(obj, args);
					return undefined;
				}
			} else {
				if (typeof (args) == 'object' && args.length == 0)
					return;
				else if (typeof (args) == 'object' && args.length == 1 && $.jqx.hasProperty(obj, args[0]))
					return $.jqx.get(obj, args[0]);
				else if (typeof (args) == 'string' && $.jqx.hasProperty(obj, args[0]))
					return $.jqx.get(obj, args);
			}

			throw "jqxCore: Invalid parameter '" + $.jqx.serialize(args) + "' does not exist.";
			//      return undefined;
		}

		$.jqx.applyWidget = function (element, controlName, args, instance) {
			var WinJS = false;
			try {
				WinJS = window.MSApp != undefined;
			}
			catch (e) {
			}

			var host = $(element);
			if (!instance) {
				instance = new $.jqx['_' + controlName]();
			}
			else {
				instance.host = host;
				instance.element = element;
			}
			if (element.id == "") {
				element.id = $.jqx.utilities.createId();
			}

			var vars = { host: host, element: element, instance: instance, initArgs: args };

			instance.widgetName = controlName;
			$.data(element, controlName, vars);
			$.data(element, 'jqxWidget', vars.instance);

			var inits = new Array();
			var instance = vars.instance;
			while (instance) {
				instance.isInitialized = false;
				inits.push(instance);
				instance = instance.base;
			}
			inits.reverse();
			inits[0].theme = $.jqx.theme || '';

			$.jqx.jqxWidgetProxy(controlName, element, args);

			for (var i in inits) {
				instance = inits[i];
				if (i == 0) {
					instance.host = host;
					instance.element = element;
					instance.WinJS = WinJS;
				}
				if (instance != undefined) {
					if (instance.definedInstance) {
						instance.definedInstance();
					}
					if (instance.createInstance != null) {
						if (WinJS) {
							MSApp.execUnsafeLocalFunction(function () {
								instance.createInstance(args);
							});
						}
						else {
							instance.createInstance(args);
						}
					}
				}
			}

			for (var i in inits) {
				if (inits[i] != undefined) {
					inits[i].isInitialized = true;
				}
			}

			if (WinJS) {
				MSApp.execUnsafeLocalFunction(function () {
					vars.instance.refresh(true);
				});
			}
			else {
				vars.instance.refresh(true);
			}

		}

		$.jqx.jqxWidget = function (name, base, params) {

			var WinJS = false;
			try {
				var jqxArgs = Array.prototype.slice.call(params, 0);
			}
			catch (e) {
				var jqxArgs = '';
			}

			try {
				WinJS = window.MSApp != undefined;
			}
			catch (e) {
			}

			var controlName = name;

			var baseControl = '';
			if (base)
				baseControl = '_' + base;
			$.jqx.define($.jqx, '_' + controlName, baseControl);

			var widgets = new Array();

			if (!window[controlName]) {
				var serializeObject = function (data) {
					if (data == null) return "";
					var dataType = $.type(data);
					switch (dataType) {
						case "string":
						case "number":
						case "date":
						case "boolean":
						case "bool":
							if (data === null)
								return "";
							return data.toString()
					}

					var str = "";
					$.each(data, function (index, value) {
						var val = value;
						if (index > 0) str += ', ';
						str += "[";
						var m = 0;

						if ($.type(val) == "object") {
							for (var obj in val) {
								if (m > 0) str += ', ';
								str += '{' + obj + ":" + val[obj] + '}';
								m++;
							}
						}
						else {
							if (m > 0) str += ', ';
							str += '{' + index + ":" + val + '}';
							m++;
						}

						str += "]";
					});
					return str;
				}

				jqwidgets[controlName] = window[controlName] = function (selector, params) {
					var args = [];
					if (!params) {
						params = {};
					}
					args.push(params);

					var uid = selector;
					if ($.type(uid) === "object" && selector[0]) {
						uid = selector[0].id;
						if (uid === "") {
							uid = selector[0].id = $.jqx.utilities.createId();
						}
					} else if ($.type(selector) === "object" && selector && selector.nodeName) {
						uid = selector.id;
						if (uid === "") {
							uid = selector.id = $.jqx.utilities.createId();
						}
					}

					if (window.jqxWidgets && window.jqxWidgets[uid]) {
						if (params) {
							$.each(window.jqxWidgets[uid], function (index) {
								var data = $(this.element).data();
								if (data && data.jqxWidget) {
									$(this.element)[controlName](params);
								}
							});
						}
						if (window.jqxWidgets[uid].length == 1) {
							var data = $(window.jqxWidgets[uid][0].widgetInstance.element).data();
							if (data && data.jqxWidget) {
								return window.jqxWidgets[uid][0];
							}
						}

						var data = $(window.jqxWidgets[uid][0].widgetInstance.element).data();
						if (data && data.jqxWidget) {
							return window.jqxWidgets[uid];
						}
					}

					var elements = $(selector);
					if (elements.length === 0) {
						elements = $("<div></div>");
						if (controlName === "jqxInput" || controlName === "jqxPasswordInput" || controlName === "jqxMaskedInput") {
							elements = $("<input/>");
						}
						if (controlName === "jqxTextArea") {
							elements = $("<textarea></textarea>");
						}
						if (controlName === "jqxButton" || controlName === "jqxRepeatButton" || controlName === "jqxToggleButton") {
							elements = $("<button/>");
						}
						if (controlName === "jqxSplitter") {
							elements = $("<div><div>Panel 1</div><div>Panel 2</div></div>");
						}
						if (controlName === "jqxTabs") {
							elements = $("<div><ul><li>Tab 1</li><li>Tab 2</li></ul><div>Content 1</div><div>Content 2</div></div>");
						}
						if (controlName === "jqxRibbon") {
							elements = $("<div><ul><li>Tab 1</li><li>Tab 2</li></ul><div><div>Content 1</div><div>Content 2</div></div></div>");
						}
						if (controlName === "jqxDocking") {
							elements = $("<div><div><div><div>Title 1</div><div>Content 1</div></div></div></div>");
						}
						if (controlName === "jqxWindow") {
							elements = $("<div><div>Title 1</div><div>Content 1</div></div>");
						}
					}
					var instances = [];


					$.each(elements, function (index) {
						var element = elements[index];
						$.jqx.applyWidget(element, controlName, args, undefined);
						if (!widgets[controlName]) {
							var instance = $.data(element, 'jqxWidget');
							var properties = $.jqx["_" + controlName].prototype.defineInstance();
							var metaInfo = {};

							if ($.jqx["_" + controlName].prototype.metaInfo) {
								metaInfo = $.jqx["_" + controlName].prototype.metaInfo();
							}

							if (controlName == "jqxDockingLayout") {
								properties = $.extend(properties, $.jqx["_jqxLayout"].prototype.defineInstance());
							}
							if (controlName == "jqxToggleButton" || controlName == "jqxRepeatButton") {
								properties = $.extend(properties, $.jqx["_jqxButton"].prototype.defineInstance());
							}
							if (controlName == "jqxTreeGrid") {
								properties = $.extend(properties, $.jqx["_jqxDataTable"].prototype.defineInstance());
							}

							var widgetConstructor = function (element) {
								var instance = $.data(element, 'jqxWidget');
								this.widgetInstance = instance;
								var widget = $.extend(this, instance);
								widget.on = widget.addEventListener = function (eventName, callback) {
									widget.addHandler(!widget.base ? widget.host : widget.base.host, eventName, callback);
								}
								widget.off = widget.removeEventListener = function (eventName) {
									widget.removeHandler(!widget.base ? widget.host : widget.base.host, eventName);
								}

								for (var obj in instance) {
									if ($.type(instance[obj]) == "function") {
										widget[obj] = $.proxy(instance[obj], instance);
									}
								}
								return widget;
							}
							widgets[controlName] = widgetConstructor;

							// widget properties
							$.each(properties, function (property, currentValue) {
								Object.defineProperty(widgetConstructor.prototype, property, {
									get: function () {
										if (this.widgetInstance) {
											return this.widgetInstance[property];
										}
										return currentValue;
									},
									set: function (newValue) {
										if (this.widgetInstance && (this.widgetInstance[property] != newValue || property === "width" || property === "height")) {
											var key1 = this.widgetInstance[property];
											var key2 = newValue;
											var dataType1 = $.type(key1);
											var dataType2 = $.type(key2);
											var differentTypes = false;
											if (dataType1 != dataType2 || property === "source" || property === "width" || property === "height") {
												differentTypes = true;
											}
											if (differentTypes || (serializeObject(key1) != serializeObject(key2))) {
												var settings = {};
												settings[property] = newValue;
												if (this.widgetInstance.host) {
													this.widgetInstance.host[controlName](settings);
												}
												else {
													this.widgetInstance.base.host[controlName](settings);
												}
												this.widgetInstance[property] = newValue;
												if (this.widgetInstance.propertyUpdated) {
													this.widgetInstance.propertyUpdated(property, key1, newValue);
												}
											}
										}
									}
								});
							});
						}
						var instance = new widgets[controlName](element);

						instances.push(instance);
						if (!window.jqxWidgets) {
							window.jqxWidgets = new Array();
						}
						if (!window.jqxWidgets[uid]) {
							window.jqxWidgets[uid] = new Array();
						}
						window.jqxWidgets[uid].push(instance);
					});

					if (instances.length === 1)
						return instances[0];

					return instances;

				}
			}

			$.fn[controlName] = function () {
				var args = Array.prototype.slice.call(arguments, 0);

				if (args.length == 0 || (args.length == 1 && typeof (args[0]) == 'object')) {
					if (this.length == 0) {
						if (this.selector) {
							throw new Error('Invalid Selector - ' + this.selector + '! Please, check whether the used ID or CSS Class name is correct.');
						}
						else {
							throw new Error('Invalid Selector! Please, check whether the used ID or CSS Class name is correct.');
						}
					}

					return this.each(function () {
						var host = $(this);
						var element = this; // element == this == host[0]
						var vars = $.data(element, controlName);

						if (vars == null) {
							$.jqx.applyWidget(element, controlName, args, undefined);
						}
						else {
							$.jqx.jqxWidgetProxy(controlName, this, args);
						}
					}); // each
				}
				else {
					if (this.length == 0) {
						if (this.selector) {
							throw new Error('Invalid Selector - ' + this.selector + '! Please, check whether the used ID or CSS Class name is correct.');
						}
						else {
							throw new Error('Invalid Selector! Please, check whether the used ID or CSS Class name is correct.');
						}
					}

					var returnVal = null;

					var cnt = 0;
					this.each(function () {
						var result = $.jqx.jqxWidgetProxy(controlName, this, args);

						if (cnt == 0) {
							returnVal = result;
							cnt++;
						}
						else {
							if (cnt == 1) {
								var tmp = [];
								tmp.push(returnVal);
								returnVal = tmp;
							}
							returnVal.push(result);
						}
					}); // each
				}

				return returnVal;
			}

			try {
				$.extend($.jqx['_' + controlName].prototype, Array.prototype.slice.call(params, 0)[0]);
			}
			catch (e) {
			}

			$.extend($.jqx['_' + controlName].prototype, {
				toThemeProperty: function (propertyName, override) {
					return $.jqx.toThemeProperty(this, propertyName, override);
				},

				isMaterialized: function () {
					if (!this.theme) {
						return false;
					}

					if (this.theme === "fluent") {
						return true;
					}

					if (this.theme === "light") {
						return true;
					}


					if (this.theme === "dark") {
						return true;
					}

					if (this.theme === "deepblue") {
						return true;
					}

					if (this.theme.indexOf("material") >= 0) {
						return true;
					}
				},

				isModern: function () {
					if (!this.theme) {
						return false;
					}

					if (this.theme.indexOf("light") >= 0) {
						return true;
					}

					if (this.theme === "dark") {
						return true;
					}
				},

				_addBarAndLabel: function (host) {
					var that = this;

					var label = $("<label></label");
					label[0].innerHTML = this.placeHolder;
					label.addClass(that.toThemeProperty('jqx-input-label'));
					host.after(label);
					that.label = label;

					var bar = $("<span></span>");
					host.after(bar);
					bar.addClass(that.toThemeProperty('jqx-input-bar'));
					that.bar = bar;
					that.bar.css('top', this.host.height());
				}
			});

			$.jqx['_' + controlName].prototype.refresh = function () {
				if (this.base)
					this.base.refresh(true);
			}
			$.jqx['_' + controlName].prototype.createInstance = function () {
			}

			$.jqx.isPassiveSupported = function () {
				var that = this;

				if (that.supportsPassive !== undefined) {
					return that.supportsPassive;
				}

				that.supportsPassive = false;
				try {
					var opts = Object.defineProperty({
					}, 'passive', {
						// eslint-disable-next-line getter-return
						get: function () {
							that.supportsPassive = true;
						}
					});
					window.addEventListener('testPassive', null, opts);
					window.removeEventListener('testPassive', null, opts);
				}
				catch (e) {
					//
				}

				return that.supportsPassive;
			}

			$.jqx['_' + controlName].prototype.addEventHandler = function (event, fnHandler) {
				if (this.base) {
					this.base.host.on(event, fnHandler);
				}
				else {
					this.host.on(event, fnHandler);
				}
			}

			$.jqx['_' + controlName].prototype.removeEventHandler = function (event, fnHandler) {
				if (this.base) {
					this.base.host.off(event);
				}
				else {
					this.host.off(event);
				}
			}

			$.jqx['_' + controlName].prototype.applyTo = function (element, args) {
				if (!(args instanceof Array)) {
					var a = [];
					a.push(args);
					args = a;
				}

				$.jqx.applyWidget(element, controlName, args, this);
			}

			$.jqx['_' + controlName].prototype.getInstance = function () {
				return this;
			}
			$.jqx['_' + controlName].prototype.propertyChangeMap = {};

			$.jqx['_' + controlName].prototype.addHandler = function (source, events, func, data) {
				$.jqx.addHandler($(source), events, func, data);
			};

			$.jqx['_' + controlName].prototype.removeHandler = function (source, events, func) {
				$.jqx.removeHandler($(source), events, func);
			};

			$.jqx['_' + controlName].prototype.setOptions = function () {
				if (!this.host || !this.host.length || this.host.length != 1)
					return;

				return $.jqx.jqxWidgetProxy(controlName, this.host[0], arguments);
			};
		} // jqxWidget

		$.jqx.toThemeProperty = function (instance, propertyName, override) {
			if (instance.theme == '')
				return propertyName;

			var split = propertyName.split(' ');
			var result = '';
			for (var i = 0; i < split.length; i++) {
				if (i > 0)
					result += ' ';

				var key = split[i];

				if (override != null && override)
					result += key + '-' + instance.theme;
				else
					result += key + ' ' + key + '-' + instance.theme;
			}

			return result;
		}

		$.jqx.addHandler = function (source, eventsList, func, data) {
			var events = eventsList.split(' ');

			for (var i = 0; i < events.length; i++) {
				var event = events[i];

				if (window.addEventListener && source[0]) {
					switch (event) {
						case 'mousewheel':
							if ($.jqx.browser.mozilla) {
								source[0].addEventListener('DOMMouseScroll', func, $.jqx.isPassiveSupported() ? { passive: false } : false);
							}
							else {
								source[0].addEventListener('mousewheel', func, $.jqx.isPassiveSupported() ? { passive: false } : false);
							}
							continue;
						case 'mousemove':
							if (!data) {
								source[0].addEventListener('mousemove', func, false);
								continue;
							}
							break;
						case 'touchmove':
							if (!data) {
								source[0].addEventListener('touchmove', func, false);
								continue;
							}
							else if (data && data.passive) {
								source[0].addEventListener('touchmove', func, data);
								continue;
							}

							break;
					}
				}

				if (data == undefined || data == null) {
					if (source.on)
						source.on(event, func);
					else
						source.bind(event, func);
				}
				else {
					if (source.on)
						source.on(event, data, func);
					else
						source.bind(event, data, func);
				}
			} // for
		};

		$.jqx.removeHandler = function (source, eventsList, func) {
			if (!eventsList) {
				if (source.off)
					source.off();
				else
					source.unbind();
				return;
			}
			var events = eventsList.split(' ');

			for (var i = 0; i < events.length; i++) {
				var event = events[i];

				if (window.removeEventListener) {
					switch (event) {
						case 'mousewheel':
							if ($.jqx.browser.mozilla) {
								source[0].removeEventListener('DOMMouseScroll', func, false);
							}
							else {
								source[0].removeEventListener('mousewheel', func, false);
							}
							continue;
						case 'mousemove':
							if (func) {
								source[0].removeEventListener('mousemove', func, false);
								continue;
							}
							break;
						case 'touchmove':
							if (func) {
								source[0].removeEventListener('touchmove', func, false);
								continue;
							}
							break;
					}
				}

				if (event == undefined) {
					if (source.off)
						source.off();
					else
						source.unbind();
					continue;
				}

				if (func == undefined) {
					if (source.off)
						source.off(event);
					else
						source.unbind(event);
				}
				else {
					if (source.off)
						source.off(event, func);
					else
						source.unbind(event, func);
				}
			}
		};

		$.jqx.credits = $.jqx.credits || "";
		$.jqx.theme = $.jqx.theme || "";
		$.jqx.scrollAnimation = $.jqx.scrollAnimation || false;
		$.jqx.resizeDelay = $.jqx.resizeDelay || 10;

		$.jqx.ready = function () {
			$(window).trigger('jqxReady');
		}
		$.jqx.init = function () {
			$.each(arguments[0], function (index, value) {
				if (index == "theme") {
					$.jqx.theme = value;
				}
				if (index == "scrollBarSize") {
					$.jqx.utilities.scrollBarSize = value;
				}
				if (index == "touchScrollBarSize") {
					$.jqx.utilities.touchScrollBarSize = value;
				}
				if (index == "scrollBarButtonsVisibility") {
					$.jqx.utilities.scrollBarButtonsVisibility = value;
				}
			});
		}

		// Utilities
		$.jqx.utilities = $.jqx.utilities || {};
		$.extend($.jqx.utilities,
			{
				scrollBarSize: 13,
				touchScrollBarSize: 8,
				scrollBarButtonsVisibility: "visible",
				createId: function () {
					var S4 = function () {
						return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
					};
					return "jqxWidget" + S4() + S4() + S4();
				},

				setTheme: function (oldTheme, theme, element) {
					if (typeof element === 'undefined') {
						return;
					}

					if (!element[0].className.split) {
						return;
					}

					if (oldTheme === undefined) {
						oldTheme = '';
					}

					if (theme === undefined) {
						theme = '';
					}

					var classNames = element[0].className.split(' '),
						oldClasses = [], newClasses = [],
						children = element.children();
					for (var i = 0; i < classNames.length; i += 1) {
						if (classNames[i].indexOf(oldTheme) >= 0) {
							if (oldTheme.length > 0) {
								oldClasses.push(classNames[i]);
								newClasses.push(classNames[i].replace(oldTheme, theme));
							}
							else {
								newClasses.push(classNames[i].replace("-" + theme, "") + '-' + theme);
							}
						}
					}
					this._removeOldClasses(oldClasses, element);
					this._addNewClasses(newClasses, element);
					for (var i = 0; i < children.length; i += 1) {
						this.setTheme(oldTheme, theme, $(children[i]));
					}
				},

				_removeOldClasses: function (classes, element) {
					for (var i = 0; i < classes.length; i += 1) {
						element.removeClass(classes[i]);
					}
				},

				_addNewClasses: function (classes, element) {
					for (var i = 0; i < classes.length; i += 1) {
						element.addClass(classes[i]);
					}
				},

				getOffset: function (el) {
					var left = $.jqx.mobile.getLeftPos(el[0]);
					var top = $.jqx.mobile.getTopPos(el[0]);
					return { top: top, left: left };
				},

				resize: function (element, callback, destroy, checkForHidden) {
					if (checkForHidden === undefined) {
						checkForHidden = true;
					}

					var index = -1;
					var that = this;
					var getHiddenIndex = function (element) {
						if (!that.hiddenWidgets) {
							return -1;
						}

						var hiddenIndex = -1;
						for (var i = 0; i < that.hiddenWidgets.length; i++) {
							if (element.id) {
								if (that.hiddenWidgets[i].id == element.id) {
									hiddenIndex = i;
									break;
								}
							}
							else {
								if (that.hiddenWidgets[i].id == element[0].id) {
									hiddenIndex = i;
									break;
								}
							}
						}
						return hiddenIndex;
					}


					if (this.resizeHandlers) {
						for (var i = 0; i < this.resizeHandlers.length; i++) {
							if (element.id) {
								if (this.resizeHandlers[i].id == element.id) {
									index = i;
									break;
								}
							}
							else {
								if (this.resizeHandlers[i].id == element[0].id) {
									index = i;
									break;
								}
							}
						}

						if (destroy === true) {
							if (index != -1) {
								this.resizeHandlers.splice(index, 1);
								if (this.watchedElementData && this.watchedElementData.length > 0) {
									this.watchedElementData.splice(index, 1);
								}
							}

							if (this.resizeHandlers.length == 0) {
								var w = $(window);
								if (w.off) {
									w.off('resize.jqx');
									w.off('orientationchange.jqx');
									w.off('orientationchanged.jqx');
								}
								else {
									w.unbind('resize.jqx');
									w.unbind('orientationchange.jqx');
									w.unbind('orientationchanged.jqx');
								}
								this.resizeHandlers = null;
							}
							var hiddenIndex = getHiddenIndex(element);
							if (hiddenIndex != -1 && this.hiddenWidgets) {
								this.hiddenWidgets.splice(hiddenIndex, 1);
							}
							return;
						}
					}
					else if (destroy === true) {
						var hiddenIndex = getHiddenIndex(element);
						if (hiddenIndex != -1 && this.hiddenWidgets) {
							this.hiddenWidgets.splice(hiddenIndex, 1);
						}
						return;
					}
					var that = this;
					var doResize = function (isHidden, type) {
						if (!that.resizeHandlers)
							return;

						var getParentsCount = function (element) {
							var index = -1;
							var parent = element.parentNode;
							while (parent) {
								index++;
								parent = parent.parentNode;
							}
							return index;
						}

						var compare = function (value1, value2) {
							if (!value1.widget || !value2.widget)
								return 0;

							var parents1 = getParentsCount(value1.widget[0]);
							var parents2 = getParentsCount(value2.widget[0]);

							try {
								if (parents1 < parents2) { return -1; }
								if (parents1 > parents2) { return 1; }
							}
							catch (error) {
								var er = error;
							}

							return 0;
						};
						var handleHiddenWidgets = function (delay) {
							if (that.hiddenWidgets.length > 0) {
								that.hiddenWidgets.sort(compare);
								var updateHiddenWidgets = function () {
									var hasHiddenWidget = false;
									var currentHiddenWidgets = new Array();
									for (var p = 0; p < that.hiddenWidgets.length; p++) {
										var handler = that.hiddenWidgets[p];
										if ($.jqx.isHidden(handler.widget)) {
											hasHiddenWidget = true;
											currentHiddenWidgets.push(handler);
										}
										else {
											if (handler.callback) {
												handler.callback(type);
											}
										}
									}
									that.hiddenWidgets = currentHiddenWidgets;
									if (!hasHiddenWidget) {
										clearInterval(that.__resizeInterval);
									}
								}
								if (delay == false) {
									updateHiddenWidgets();
									if (that.__resizeInterval) clearInterval(that.__resizeInterval);
									return;
								}
								if (that.__resizeInterval) clearInterval(that.__resizeInterval);
								that.__resizeInterval = setInterval(function () {
									updateHiddenWidgets();
								}, 100);
							}
						}

						if (that.hiddenWidgets && that.hiddenWidgets.length > 0) {
							handleHiddenWidgets(false);
						}
						that.hiddenWidgets = new Array();
						that.resizeHandlers.sort(compare);
						for (var i = 0; i < that.resizeHandlers.length; i++) {
							var handler = that.resizeHandlers[i];
							var widget = handler.widget;
							var data = handler.data;
							if (!data) continue;
							if (!data.jqxWidget) continue;

							var width = data.jqxWidget.width;
							var height = data.jqxWidget.height;

							if (data.jqxWidget.base) {
								if (width == undefined) {
									width = data.jqxWidget.base.width;
								}
								if (height == undefined) {
									height = data.jqxWidget.base.height;
								}
							}

							if (width === undefined && height === undefined) {
								width = data.jqxWidget.element.style.width;
								height = data.jqxWidget.element.style.height;
							}

							var percentageSize = false;
							if (width != null && width.toString().indexOf("%") != -1) {
								percentageSize = true;
							}

							if (height != null && height.toString().indexOf("%") != -1) {
								percentageSize = true;
							}

							if ($.jqx.isHidden(widget)) {
								if (getHiddenIndex(widget) === -1) {
									if (percentageSize || isHidden === true) {
										if (handler.data.nestedWidget !== true) {
											that.hiddenWidgets.push(handler);
										}
									}
								}
							}
							else if (isHidden === undefined || isHidden !== true) {
								if (percentageSize) {
									handler.callback(type);
									if (that.watchedElementData) {
										for (var m = 0; m < that.watchedElementData.length; m++) {
											if (that.watchedElementData[m].element == data.jqxWidget.element) {
												that.watchedElementData[m].offsetWidth = data.jqxWidget.element.offsetWidth;
												that.watchedElementData[m].offsetHeight = data.jqxWidget.element.offsetHeight;
												break;
											}
										}
									}
									if (that.hiddenWidgets.indexOf(handler) >= 0) {
										that.hiddenWidgets.splice(that.hiddenWidgets.indexOf(handler), 1);
									}
								}
								if (data.jqxWidget.element) {
									var widgetClass = data.jqxWidget.element.className;
									if (widgetClass.indexOf('dropdownlist') >= 0 || widgetClass.indexOf('datetimeinput') >= 0 || widgetClass.indexOf('combobox') >= 0 || widgetClass.indexOf('menu') >= 0) {
										if (data.jqxWidget.isOpened) {
											var opened = data.jqxWidget.isOpened();
											if (opened) {
												if (type && type == "resize" && $.jqx.mobile.isTouchDevice())
													continue;

												data.jqxWidget.close();
											}
										}
									}
								}
							}
						};

						handleHiddenWidgets();
					}

					if (!this.resizeHandlers) {
						this.resizeHandlers = new Array();

						var w = $(window);
						if (w.on) {
							this._resizeTimer = null;
							this._initResize = null;
							w.on('resize.jqx', function (event) {
								if (that._resizeTimer != undefined) {
									clearTimeout(that._resizeTimer);
								}
								if (!that._initResize) {
									that._initResize = true;
									doResize(null, 'resize');
								}
								else {
									that._resizeTimer = setTimeout(function () {
										doResize(null, 'resize');
									}, $.jqx.resizeDelay);
								}
							});
							w.on('orientationchange.jqx', function (event) {
								doResize(null, 'orientationchange');
							});
							w.on('orientationchanged.jqx', function (event) {
								doResize(null, 'orientationchange');
							});
						}
						else {
							w.bind('resize.jqx', function (event) {
								doResize(null, 'orientationchange');
							});
							w.bind('orientationchange.jqx', function (event) {
								doResize(null, 'orientationchange');
							});
							w.bind('orientationchanged.jqx', function (event) {
								doResize(null, 'orientationchange');
							});
						}
					}
					var elementData = element.data();
					if (checkForHidden) {
						if (index === -1) {
							this.resizeHandlers.push({ id: element[0].id, widget: element, callback: callback, data: elementData });
						}
					}
					try {
						var width = elementData.jqxWidget.width;
						var height = elementData.jqxWidget.height;

						if (elementData.jqxWidget.base) {
							if (width == undefined) {
								width = elementData.jqxWidget.base.width;
							}
							if (height == undefined) {
								height = elementData.jqxWidget.base.height;
							}
						}

						if (width === undefined && height === undefined) {
							width = elementData.jqxWidget.element.style.width;
							height = elementData.jqxWidget.element.style.height;
						}

						var percentageSize = false;
						if (width != null && width.toString().indexOf("%") != -1) {
							percentageSize = true;
						}

						if (height != null && height.toString().indexOf("%") != -1) {
							percentageSize = true;
						}
						if (percentageSize) {
							if (!this.watchedElementData) {
								this.watchedElementData = [];
							}
							var that = this;
							var checkForChanges = function (mutations) {
								if (that.watchedElementData.forEach) {
									that.watchedElementData.forEach(function (data) {
										if (data.element.offsetWidth !== data.offsetWidth ||
											data.element.offsetHeight !== data.offsetHeight) {
											data.offsetWidth = data.element.offsetWidth;
											data.offsetHeight = data.element.offsetHeight;
											if (data.timer) {
												clearTimeout(data.timer);
											}
											data.timer = setTimeout(function () {
												if (!$.jqx.isHidden($(data.element))) {
													data.callback();
												}
												else {
													data.timer = setInterval(function () {
														if (!$.jqx.isHidden($(data.element))) {
															clearInterval(data.timer);
															data.callback();
														}
													}, 100);
												}
											});
										}
									});
								}
							};

							that.watchedElementData.push({
								element: element[0],
								offsetWidth: element[0].offsetWidth,
								offsetHeight: element[0].offsetHeight,
								callback: callback
							});
							if (!that.observer) {
								that.observer = new MutationObserver(checkForChanges);
								that.observer.observe(document.body, {
									attributes: true,
									childList: true,
									characterData: true
								});
							}
						}
					}
					catch (er) {
					}
					if ($.jqx.isHidden(element) && checkForHidden === true) {
						doResize(true);
					}
					$.jqx.resize = function () {
						doResize(null, 'resize');
					}
				},

				parseJSON: function (data) {
					if (!data || typeof data !== "string") {
						return null;
					}
					var rvalidchars = /^[\],:{}\s]*$/,
						rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
						rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
						rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g;

					// Make sure leading/trailing whitespace is removed (IE can't handle it)
					data = $.trim(data);

					// Attempt to parse using the native JSON parser first
					if (window.JSON && window.JSON.parse) {
						return window.JSON.parse(data);
					}

					// Make sure the incoming data is actual JSON
					// Logic borrowed from http://json.org/json2.js
					if (rvalidchars.test(data.replace(rvalidescape, "@")
						.replace(rvalidtokens, "]")
						.replace(rvalidbraces, ""))) {

						return (new Function("return " + data))();

					}
					throw new Error("Invalid JSON: " + data);
				},

				html: function (element, value) {
					if (!$(element).on || !$.access) {
						return $(element).html(value);
					}
					try {
						return $.access(element, function (value) {
							var elem = element[0] || {},
								i = 0,
								l = element.length;

							if (value === undefined) {
								return elem.nodeType === 1 ?
									elem.innerHTML.replace(rinlinejQuery, "") :
									undefined;
							}

							var rnoInnerhtml = /<(?:script|style|link)/i,
								nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
									"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
								rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
								rtagName = /<([\w:]+)/,
								rnocache = /<(?:script|object|embed|option|style)/i,
								rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
								rleadingWhitespace = /^\s+/,
								wrapMap = {
									option: [1, "<select multiple='multiple'>", "</select>"],
									legend: [1, "<fieldset>", "</fieldset>"],
									thead: [1, "<table>", "</table>"],
									tr: [2, "<table><tbody>", "</tbody></table>"],
									td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
									col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
									area: [1, "<map>", "</map>"],
									_default: [0, "", ""]
								};

							if (typeof value === "string" && !rnoInnerhtml.test(value) &&
								($.support.htmlSerialize || !rnoshimcache.test(value)) &&
								($.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
								!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

								value = value.replace(rxhtmlTag, "<$1></$2>");

								try {
									for (; i < l; i++) {
										elem = this[i] || {};
										if (elem.nodeType === 1) {
											$.cleanData(elem.getElementsByTagName("*"));
											elem.innerHTML = value;
										}
									}

									elem = 0;
								} catch (e) { }
							}

							if (elem) {
								element.empty().append(value);
							}
						}, null, value, arguments.length);
					}
					catch (error) {
						return $(element).html(value);
					}
				},

				hasTransform: function (el) {
					var transform = "";
					transform = el.css('transform');

					if (transform == "" || transform == 'none') {
						transform = el.parents().css('transform');
						if (transform == "" || transform == 'none') {
							var browserInfo = $.jqx.utilities.getBrowser();
							if (browserInfo.browser == 'msie') {
								transform = el.css('-ms-transform');
								if (transform == "" || transform == 'none') {
									transform = el.parents().css('-ms-transform');
								}
							}
							else if (browserInfo.browser == 'chrome') {
								transform = el.css('-webkit-transform');
								if (transform == "" || transform == 'none') {
									transform = el.parents().css('-webkit-transform');
								}
							}
							else if (browserInfo.browser == 'opera') {
								transform = el.css('-o-transform');
								if (transform == "" || transform == 'none') {
									transform = el.parents().css('-o-transform');
								}
							}
							else if (browserInfo.browser == 'mozilla') {
								transform = el.css('-moz-transform');
								if (transform == "" || transform == 'none') {
									transform = el.parents().css('-moz-transform');
								}
							}
						} else {
							return transform != "" && transform != 'none';
						}
					}
					if (transform == "" || transform == 'none') {
						transform = $(document.body).css('transform');
					}
					return transform != "" && transform != 'none' && transform != null;
				},

				getBrowser: function () {
					var ua = navigator.userAgent.toLowerCase();

					var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
						/(webkit)[ \/]([\w.]+)/.exec(ua) ||
						/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
						/(msie) ([\w.]+)/.exec(ua) ||
						ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
						[];

					var obj = {
						browser: match[1] || "",
						version: match[2] || "0"
					};
					if (ua.indexOf("rv:11.0") >= 0 && ua.indexOf(".net4.0c") >= 0) {
						obj.browser = "msie";
						obj.version = "11";
						match[1] = "msie";
					}
					if (ua.indexOf("edge") >= 0) {
						obj.browser = "msie";
						obj.version = "12";
						match[1] = "msie";
					}
					obj[match[1]] = match[1];
					return obj;
				}
			});
		$.jqx.browser = $.jqx.utilities.getBrowser();
		$.jqx.isHidden = function (element) {
			if (!element || !element[0])
				return false;

			var w = element[0].offsetWidth, h = element[0].offsetHeight;
			if (w === 0 || h === 0)
				return true;
			else {
				return false;
			}
		};

		$.jqx.ariaEnabled = true;
		$.jqx.aria = function (that, property, value) {
			if (!$.jqx.ariaEnabled)
				return;

			if (property == undefined) {
				$.each(that.aria, function (index, value) {
					var attrValue = !that.base ? that.host.attr(index) : that.base.host.attr(index);
					if (attrValue != undefined && !$.isFunction(attrValue)) {
						var newValue = attrValue;
						switch (value.type) {
							case "number":
								newValue = new Number(attrValue);
								if (isNaN(newValue)) newValue = attrValue;
								break;
							case "boolean":
								newValue = attrValue == "true" ? true : false;
								break;
							case "date":
								newValue = new Date(attrValue);
								if (newValue == "Invalid Date" || isNaN(newValue)) newValue = attrValue;
								break;
						}

						that[value.name] = newValue;
					}
					else {
						var attrValue = that[value.name];
						if ($.isFunction(attrValue)) attrValue = that[value.name]();
						if (attrValue == undefined) attrValue = "";
						try {
							!that.base ? that.host.attr(index, attrValue.toString()) : that.base.host.attr(index, attrValue.toString());
						}
						catch (error) {
						}
					}
				});
			}
			else {
				try {
					if (that.host) {
						if (!that.base) {
							if (that.host) {
								if (that.element.setAttribute) {
									that.element.setAttribute(property, value.toString());
								}
								else {
									that.host.attr(property, value.toString());
								}
							}
							else {
								that.attr(property, value.toString());
							}
						}
						else {
							if (that.base.host) {
								that.base.host.attr(property, value.toString());
							}
							else {
								that.attr(property, value.toString());
							}
						}
					}
					else if (that.setAttribute) {
						that.setAttribute(property, value.toString());
					}
				}
				catch (error) {
				}
			}
		};

		if (!Array.prototype.indexOf) {
			Array.prototype.indexOf = function (elt /*, from*/) {
				var len = this.length;

				var from = Number(arguments[1]) || 0;
				from = (from < 0)
					? Math.ceil(from)
					: Math.floor(from);
				if (from < 0)
					from += len;

				for (; from < len; from++) {
					if (from in this &&
						this[from] === elt)
						return from;
				}
				return -1;
			};
		}

		$.jqx.mobile = $.jqx.mobile || {};
		$.jqx.position = function (event) {
			var left = parseInt(event.pageX);
			var top = parseInt(event.pageY);

			if ($.jqx.mobile.isTouchDevice()) {
				var touches = $.jqx.mobile.getTouches(event);
				var touch = touches[0];
				left = parseInt(touch.pageX);
				top = parseInt(touch.pageY);
			}
			return { left: left, top: top }
		}

		$.extend($.jqx.mobile,
			{
				_touchListener: function (e, me) {
					var createTouchEvent = function (name, e) {
						var event = document.createEvent('MouseEvents');

						event.initMouseEvent(
							name,
							e.bubbles,
							e.cancelable,
							e.view,
							e.detail,
							e.screenX,
							e.screenY,
							e.clientX,
							e.clientY,
							e.ctrlKey,
							e.altKey,
							e.shiftKey,
							e.metaKey,
							e.button,
							e.relatedTarget
						);
						event._pageX = e.pageX;
						event._pageY = e.pageY;

						return event;
					}

					var eventMap = { 'mousedown': 'touchstart', 'mouseup': 'touchend', 'mousemove': 'touchmove' };
					var event = createTouchEvent(eventMap[e.type], e);
					e.target.dispatchEvent(event);

					var fn = e.target['on' + eventMap[e.type]];
					if (typeof fn === 'function') fn(e);
				},

				setMobileSimulator: function (element, value) {
					if (this.isTouchDevice()) {
						return;
					}

					this.simulatetouches = true;
					if (value == false) {
						this.simulatetouches = false;
					}

					var eventMap = { 'mousedown': 'touchstart', 'mouseup': 'touchend', 'mousemove': 'touchmove' };

					var self = this;
					if (window.addEventListener) {
						var subscribeToEvents = function () {
							for (var key in eventMap) {
								if (element.addEventListener) {
									element.removeEventListener(key, self._touchListener);
									element.addEventListener(key, self._touchListener, false);
								}

								//  document.removeEventListener(key, self._touchListener);
								//  document.addEventListener(key, self._touchListener, false);
							}
						}

						if ($.jqx.browser.msie) {
							subscribeToEvents();
						}
						else {
							subscribeToEvents();
						}
					}
				},

				isTouchDevice: function () {
					if (this.touchDevice != undefined)
						return this.touchDevice;

					var txt = "Browser CodeName: " + navigator.appCodeName + "";
					txt += "Browser Name: " + navigator.appName + "";
					txt += "Browser Version: " + navigator.appVersion + "";
					txt += "Platform: " + navigator.platform + "";
					txt += "User-agent header: " + navigator.userAgent + "";

					if (navigator.maxTouchPoints > 1) {
						//return true;
					}

					if (txt.indexOf('Android') != -1)
						return true;

					if (txt.indexOf('IEMobile') != -1)
						return true;

					if (txt.indexOf('Windows Phone') != -1)
						return true;

					if (txt.indexOf('WPDesktop') != -1)
						return true;

					if (txt.indexOf('ZuneWP7') != -1)
						return true;

					if (txt.indexOf('BlackBerry') != -1 && txt.indexOf('Mobile Safari') != -1)
						return true;

					if (txt.indexOf('ipod') != -1)
						return true;

					if (txt.indexOf('nokia') != -1 || txt.indexOf('Nokia') != -1)
						return true;

					if (txt.indexOf('Chrome/17') != -1)
						return false;

					if (txt.indexOf('CrOS') != -1)
						return false;

					if (txt.indexOf('Opera') != -1 && txt.indexOf('Mobi') == -1 && txt.indexOf('Mini') == -1 && txt.indexOf('Platform: Win') != -1) {
						return false;
					}

					if (txt.indexOf("HybridDeviceTouch") != -1) {
						return true
					}

					if (txt.indexOf("HybridDeviceMouse") != -1) {
						return false
					}

					if (txt.indexOf('Opera') != -1 && txt.indexOf('Mobi') != -1 && txt.indexOf('Opera Mobi') != -1) {
						return true;
					}

					if (txt.indexOf('Mozilla/5.0 (X11; Linux x86_64)') != -1) {
						return false;
					}

					var deviceTypes = {
						ios: 'i(?:Pad|Phone|Pod)(?:.*)CPU(?: iPhone)? OS ',
						android: '(Android |HTC_|Silk/)',
						blackberry: 'BlackBerry(?:.*)Version\/',
						rimTablet: 'RIM Tablet OS ',
						webos: '(?:webOS|hpwOS)\/',
						bada: 'Bada\/'
					}

					// check for IPad, IPhone, IE and Chrome
					try {
						if (this.touchDevice != undefined)
							return this.touchDevice;

						this.touchDevice = false;
						for (var i in deviceTypes) {
							if (deviceTypes.hasOwnProperty(i)) {
								var prefix = deviceTypes[i];
								var match = txt.match(new RegExp('(?:' + prefix + ')([^\\s;]+)'));
								if (match) {
									if (i.toString() == "blackberry") {
										// handle touches through mouse pointer.
										this.touchDevice = false;
										return false;
									}

									this.touchDevice = true;
									return true;
								}
							}
						}

						var userAgent = navigator.userAgent;
						if (navigator.platform.toLowerCase().indexOf('win') != -1) {
							if (userAgent.indexOf('Windows Phone') >= 0 || userAgent.indexOf('WPDesktop') >= 0 || userAgent.indexOf('IEMobile') >= 0 || userAgent.indexOf('ZuneWP7') >= 0) {
								this.touchDevice = true;
								return true;
							}
							else {
								if (userAgent.indexOf('Touch') >= 0) {
									var supported = ('MSPointerDown' in window) || ('pointerdown' in window);
									if (supported) {
										this.touchDevice = true;
										return true;
									}
									if (userAgent.indexOf('ARM') >= 0) {
										this.touchDevice = true;
										return true;
									}

									this.touchDevice = false;
									return false;
								}
							}
						}

						if (navigator.platform.toLowerCase().indexOf('win') != -1) {
							this.touchDevice = false;
							return false;
						}
						if (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
							this.touchDevice = true;
						}
						return this.touchDevice;
					} catch (e) {
						this.touchDevice = false;
						return false;
					}
				},

				getLeftPos: function (inputObj) {
					var returnValue = inputObj.offsetLeft;
					while ((inputObj = inputObj.offsetParent) != null) {
						if (inputObj.tagName != 'HTML') {
							returnValue += inputObj.offsetLeft;
							if (document.all) returnValue += inputObj.clientLeft;
						}
					}
					return returnValue;
				},

				getTopPos: function (inputObj) {
					var returnValue = inputObj.offsetTop;
					var initialOffset = $(inputObj).coord();
					while ((inputObj = inputObj.offsetParent) != null) {
						if (inputObj.tagName != 'HTML') {
							returnValue += (inputObj.offsetTop - inputObj.scrollTop);
							if (document.all) returnValue += inputObj.clientTop;
						}
					}
					var agent = navigator.userAgent.toLowerCase();
					var wp8 = (agent.indexOf('windows phone') != -1 || agent.indexOf('WPDesktop') != -1 || agent.indexOf('ZuneWP7') != -1 || agent.indexOf('msie 9') != -1 || agent.indexOf('msie 11') != -1 || agent.indexOf('msie 10') != -1) && agent.indexOf('touch') != -1;
					if (wp8) {
						return initialOffset.top;
					}

					if (this.isSafariMobileBrowser()) {
						if (this.isSafari4MobileBrowser() && this.isIPadSafariMobileBrowser()) {
							return returnValue;
						}
						if (agent.indexOf('version/7') != -1) {
							return initialOffset.top;
						}
						if (agent.indexOf('version/6') != -1 || agent.indexOf('version/5') != -1) {
							returnValue = returnValue + $(window).scrollTop();
						}
						if (/(Android.*Chrome\/[.0-9]* (!?Mobile))/.exec(navigator.userAgent)) {
							return returnValue;
							//       return returnValue + $(window).scrollTop();
						}
						if (/(Android.*Chrome\/[.0-9]* Mobile)/.exec(navigator.userAgent)) {
							return returnValue;
							//        return returnValue + $(window).scrollTop();
						}

						return initialOffset.top;
					}

					return returnValue;
				},

				isChromeMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('android') != -1;
					return result;
				},

				isOperaMiniMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('opera mini') != -1 || agent.indexOf('opera mobi') != -1;
					return result;
				},

				isOperaMiniBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('opera mini') != -1;
					return result;
				},

				isNewSafariMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('ipad') != -1 || agent.indexOf('iphone') != -1 || agent.indexOf('ipod') != -1;
					result = result && (agent.indexOf('version/5') != -1);
					return result;
				},

				isSafari4MobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('ipad') != -1 || agent.indexOf('iphone') != -1 || agent.indexOf('ipod') != -1;
					result = result && (agent.indexOf('version/4') != -1);
					return result;
				},

				isWindowsPhone: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = (agent.indexOf('windows phone') != -1 || agent.indexOf('WPDesktop') != -1 || agent.indexOf('ZuneWP7') != -1 || agent.indexOf('msie 9') != -1 || agent.indexOf('msie 11') != -1 || agent.indexOf('msie 10') != -1 && agent.indexOf('touch') != -1);
					return result;
				},

				isSafariMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					if (/(Android.*Chrome\/[.0-9]* (!?Mobile))/.exec(navigator.userAgent)) {
						return true;
					}
					if (/(Android.*Chrome\/[.0-9]* Mobile)/.exec(navigator.userAgent)) {
						return true;
					}

					var result = agent.indexOf('ipad') != -1 || agent.indexOf('iphone') != -1 || agent.indexOf('ipod') != -1 || agent.indexOf('mobile safari') != -1;
					return result;
				},

				isIPadSafariMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('ipad') != -1;
					return result;
				},

				isMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('ipad') != -1 || agent.indexOf('iphone') != -1 || agent.indexOf('android') != -1;
					return result;
				},

				// Get the touch points from this event
				getTouches: function (e) {
					if (e.originalEvent) {
						if (e.originalEvent.touches && e.originalEvent.touches.length) {
							return e.originalEvent.touches;
						} else if (e.originalEvent.changedTouches && e.originalEvent.changedTouches.length) {
							return e.originalEvent.changedTouches;
						}
					}

					if (!e.touches) {
						e.touches = new Array();
						e.touches[0] = e.originalEvent != undefined ? e.originalEvent : e;

						if (e.originalEvent != undefined && e.pageX)
							e.touches[0] = e;
						if (e.type == 'mousemove') e.touches[0] = e;
					}

					return e.touches;
				},

				getTouchEventName: function (name) {
					if (this.isWindowsPhone()) {

						var agent = navigator.userAgent.toLowerCase();
						if (agent.indexOf('windows phone 7') != -1) {
							if (name.toLowerCase().indexOf('start') != -1) return 'MSPointerDown';
							if (name.toLowerCase().indexOf('move') != -1) return 'MSPointerMove';
							if (name.toLowerCase().indexOf('end') != -1) return 'MSPointerUp';
						}
						if (name.toLowerCase().indexOf('start') != -1) return 'pointerdown';
						if (name.toLowerCase().indexOf('move') != -1) return 'pointermove';
						if (name.toLowerCase().indexOf('end') != -1) return 'pointerup';
					}
					else {
						return name;
					}
				},

				// Dispatches a fake mouse event from a touch event
				dispatchMouseEvent: function (name, touch, target) {
					if (this.simulatetouches)
						return;

					var e = document.createEvent('MouseEvent');
					e.initMouseEvent(name, true, true, touch.view, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
					if (target != null) {
						target.dispatchEvent(e);
					}
				},

				// Find the root node of this target
				getRootNode: function (target) {
					while (target.nodeType !== 1) {
						target = target.parentNode;
					}
					return target;
				},

				setTouchScroll: function (enable, key) {
					if (!this.enableScrolling) this.enableScrolling = [];
					this.enableScrolling[key] = enable;
				},

				touchScroll: function (element, scrollHeight, callback, key, horizontalScroll, verticalScroll) {
					if (element == null)
						return;

					var me = this;
					var scrollY = 0;
					var touchY = 0;
					var movedY = 0;
					var scrollX = 0;
					var touchX = 0;
					var movedX = 0;
					if (!this.scrolling) this.scrolling = [];
					this.scrolling[key] = false;
					var moved = false;
					var $element = $(element);
					var touchTags = ['select', 'input', 'textarea'];
					var touchStart = 0;
					var touchEnd = 0;
					if (!this.enableScrolling) this.enableScrolling = [];
					this.enableScrolling[key] = true;
					var key = key;
					var touchStartName = this.getTouchEventName('touchstart') + ".touchScroll";
					var touchEndName = this.getTouchEventName('touchend') + ".touchScroll";
					var touchMoveName = this.getTouchEventName('touchmove') + ".touchScroll";

					//            horizontalScroll.fadeOut(0);
					//            verticalScroll.fadeOut(0);

					var view, indicator, relative, xframe, xdelta,
						xmax, min, max, offset, reference, pressed, xform,
						jqxAnimations, xjqxAnimations, frame, timestamp, ticker,
						amplitude, target, xtarget, xreference, timeConstant;
					max = scrollHeight;
					var min = 0;
					var offset = 0;
					var xoffset = 0;
					var initialOffset = 0;
					var initialXOffset = 0;
					var xmax = horizontalScroll.jqxScrollBar('max');
					var timeConstant = 325; // ms

					function ypos(e) {
						// touch event
						if (e.targetTouches && (e.targetTouches.length >= 1)) {
							return e.targetTouches[0].clientY;
						}
						else if (e.originalEvent && e.originalEvent.clientY !== undefined) {
							return e.originalEvent.clientY;
						}
						else {
							var touches = me.getTouches(e);
							return touches[0].clientY;
						}

						// mouse event
						//    return e.clientY;
					}

					function xpos(e) {
						// touch event
						if (e.targetTouches && (e.targetTouches.length >= 1)) {
							return e.targetTouches[0].clientX;
						}
						else if (e.originalEvent && e.originalEvent.clientX !== undefined) {
							return e.originalEvent.clientX;
						}
						else {
							var touches = me.getTouches(e);
							return touches[0].clientX;
						}

						// mouse event
						//   return e.clientX;
					}

					var track = function () {
						var now, elapsed, delta, v;

						now = Date.now();
						elapsed = now - timestamp;
						timestamp = now;
						delta = offset - frame;
						var xdelta = xoffset - xframe;
						frame = offset;
						xframe = xoffset;
						pressed = true;
						v = 1000 * delta / (1 + elapsed);
						var xv = 1000 * xdelta / (1 + elapsed);
						jqxAnimations = 0.8 * v + 0.2 * jqxAnimations;
						xjqxAnimations = 0.8 * xv + 0.2 * xjqxAnimations;
					}

					var tapped = false;

					var touchStart = function (event) {
						if (!me.enableScrolling[key])
							return true;

						// Allow certain HTML tags to receive touch events
						if ($.inArray(event.target.tagName.toLowerCase(), touchTags) !== -1) {
							return;
						}
						offset = verticalScroll.jqxScrollBar('value');
						xoffset = horizontalScroll.jqxScrollBar('value');

						var touches = me.getTouches(event);
						var touch = touches[0];
						if (touches.length == 1) {
							me.dispatchMouseEvent('mousedown', touch, me.getRootNode(touch.target));
						}
						xmax = horizontalScroll.jqxScrollBar('max');
						max = verticalScroll.jqxScrollBar('max');
						function tap(e) {
							tapped = false;
							pressed = true;
							reference = ypos(e);
							xreference = xpos(e);
							jqxAnimations = amplitude = xjqxAnimations = 0;
							frame = offset;
							xframe = xoffset;
							timestamp = Date.now();
							clearInterval(ticker);
							ticker = setInterval(track, 100);
							initialOffset = offset;
							initialXOffset = xoffset;

							if (offset > 0 && offset < max && verticalScroll[0].style.visibility != "hidden") {
								//      e.preventDefault();
							}
							//    if (xoffset > 0 && xoffset < xmax && horizontalScroll[0].style.visibility != "hidden") {
							//        e.preventDefault();

							//      e.stopPropagation();
							//   e.stopPropagation();
							// return false;
						}

						tap(event);
						moved = false;
						touchY = touch.pageY;
						touchX = touch.pageX;
						if (me.simulatetouches) {
							if (touch._pageY != undefined) {
								touchY = touch._pageY;
								touchX = touch._pageX;
							}
						}
						me.scrolling[key] = true;
						scrollY = 0;
						scrollX = 0;
						return true;
					}

					if ($element.on) {
						$element.on(touchStartName, touchStart);
					}
					else {
						$element.bind(touchStartName, touchStart);
					}

					var scroll = function (top, event) {
						offset = (top > max) ? max : (top < min) ? min : top;
						callback(null, top, 0, 0, event);

						return (top > max) ? "max" : (top < min) ? "min" : "value";
					}

					var hscroll = function (left, event) {
						xoffset = (left > xmax) ? xmax : (left < min) ? min : left;
						callback(left, null, 0, 0, event);

						return (left > xmax) ? "max" : (left < min) ? "min" : "value";
					}

					function autoScroll() {
						var elapsed, delta;
						if (amplitude) {
							elapsed = Date.now() - timestamp;
							delta = -amplitude * Math.exp(-elapsed / timeConstant);
							if (delta > 0.5 || delta < -0.5) {
								scroll(target + delta);
								requestAnimationFrame(autoScroll);
							} else {
								scroll(target);
								//     verticalScroll.fadeOut('fast');
							}
						}
					}
					function hAutoScroll() {
						var elapsed, delta;
						if (amplitude) {
							elapsed = Date.now() - timestamp;
							delta = -amplitude * Math.exp(-elapsed / timeConstant);
							if (delta > 0.5 || delta < -0.5) {
								hscroll(xtarget + delta);
								requestAnimationFrame(hAutoScroll);
							} else {
								hscroll(xtarget);
								//        horizontalScroll.fadeOut('fast');
							}

						}
					}
					var touchMove = function (event) {
						if (!me.enableScrolling[key])
							return true;

						if (!me.scrolling[key]) {
							return true;
						}

						if (tapped) {
							event.preventDefault();
							event.stopPropagation();
						}

						var touches = me.getTouches(event);
						if (touches.length > 1) {
							return true;
						}

						var pageY = touches[0].pageY;
						var pageX = touches[0].pageX;

						if (me.simulatetouches) {
							if (touches[0]._pageY != undefined) {
								pageY = touches[0]._pageY;
								pageX = touches[0]._pageX;
							}
						}


						var dy = pageY - touchY;
						var dx = pageX - touchX;
						touchEnd = pageY;
						var touchHorizontalEnd = pageX;
						movedY = dy - scrollY;
						movedX = dx - scrollX;
						moved = true;
						scrollY = dy;
						scrollX = dx;

						var hScrollVisible = horizontalScroll != null ? horizontalScroll[0].style.visibility != 'hidden' : true;
						var vScrollVisible = verticalScroll != null ? verticalScroll[0].style.visibility != 'hidden' : true;


						function drag(e) {
							var y, delta, x;
							if (pressed) {
								y = ypos(e);
								x = xpos(e);
								delta = reference - y;
								xdelta = xreference - x;
								var dragged = "value";
								if (delta > 2 || delta < -2) {
									reference = y;
									dragged = scroll(offset + delta, e);
									track();

									if (dragged == "min" && initialOffset === 0) {
										return true;
									}
									if (dragged == "max" && initialOffset === max) {
										return true;
									}

									if (!vScrollVisible) {
										return true;
									}
									e.preventDefault();
									e.stopPropagation();
									tapped = true;

									return false;
								}
								else {
									if (xdelta > 2 || xdelta < -2) {
										xreference = x;
										dragged = hscroll(xoffset + xdelta, e);
										track();

										if (dragged == "min" && initialXOffset === 0) {
											return true;
										}
										if (dragged == "max" && initialXOffset === xmax) {
											return true;
										}

										if (!hScrollVisible) {
											return true;
										}
										tapped = true;
										e.preventDefault();
										e.stopPropagation();
										return false;
									}
								}
								e.preventDefault();
							}
						}

						if (hScrollVisible || vScrollVisible) {
							if ((hScrollVisible) || (vScrollVisible)) {
								drag(event);

								//      callback(-movedX * 1, -movedY * 1, dx, dy, event);
								//event.preventDefault();
								//event.stopPropagation();
								//if (event.preventManipulation) {
								//    event.preventManipulation();
								//}
								//return false;
							}
						}
					}

					if ($element.on) {
						$element.on(touchMoveName, touchMove);
					}
					else $element.bind(touchMoveName, touchMove);



					var touchCancel = function (event) {
						if (!me.enableScrolling[key])
							return true;

						var touch = me.getTouches(event)[0];
						if (!me.scrolling[key]) {
							return true;
						}

						pressed = false;
						clearInterval(ticker);
						if (jqxAnimations > 10 || jqxAnimations < -10) {
							amplitude = 0.8 * jqxAnimations;
							target = Math.round(offset + amplitude);
							timestamp = Date.now();
							requestAnimationFrame(autoScroll);
							//             verticalScroll.fadeIn(100);
						}
						else if (xjqxAnimations > 10 || xjqxAnimations < -10) {
							amplitude = 0.8 * xjqxAnimations;
							xtarget = Math.round(xoffset + amplitude);
							timestamp = Date.now();
							requestAnimationFrame(hAutoScroll);
							//          horizontalScroll.fadeIn(100);
						}
						else {
							//        horizontalScroll.fadeOut(100);
							//        verticalScroll.fadeOut(100);
						}

						me.scrolling[key] = false;
						if (moved) {
							me.dispatchMouseEvent('mouseup', touch, event.target);
						} else {
							var touch = me.getTouches(event)[0],
								t = me.getRootNode(touch.target);

							//        event.preventDefault();
							//         event.stopPropagation();
							// Dispatch fake mouse up and click events if this touch event did not move
							me.dispatchMouseEvent('mouseup', touch, t);
							me.dispatchMouseEvent('click', touch, t);
							return true;
						}
					}

					if (this.simulatetouches) {
						var windowBindFunc = $(window).on != undefined || $(window).bind;
						var windowMouseUp = function (event) {
							try {
								touchCancel(event);
							}
							catch (er) {
							}
							me.scrolling[key] = false;
						};
						$(window).on != undefined ? $(document).on('mouseup.touchScroll', windowMouseUp) : $(document).bind('mouseup.touchScroll', windowMouseUp);

						if (window.frameElement) {
							if (window.top != null) {
								var eventHandle = function (event) {
									try {
										touchCancel(event);
									}
									catch (er) {
									}
									me.scrolling[key] = false;
								};

								if (window.top.document) {
									$(window.top.document).on ? $(window.top.document).on('mouseup', eventHandle) : $(window.top.document).bind('mouseup', eventHandle);
								}
							}
						}

						var docBindFunc = $(document).on != undefined || $(document).bind;
						var touchEndFunc = function (event) {
							if (!me.scrolling[key]) {
								return true;
							}

							me.scrolling[key] = false;
							var touch = me.getTouches(event)[0],
								target = me.getRootNode(touch.target);

							// Dispatch fake mouse up and click events if this touch event did not move
							me.dispatchMouseEvent('mouseup', touch, target);
							me.dispatchMouseEvent('click', touch, target);
						};

						$(document).on != undefined ? $(document).on('touchend', touchEndFunc) : $(document).bind('touchend', touchEndFunc);
					}

					if ($element.on) {
						$element.on('dragstart', function (event) {
							event.preventDefault();
						});
						$element.on('selectstart', function (event) {
							event.preventDefault();
						});
					}
					$element.on ? $element.on(touchEndName + ' touchcancel.touchScroll', touchCancel) : $element.bind(touchEndName + ' touchcancel.touchScroll', touchCancel);
				}

			});

		$.jqx.cookie = $.jqx.cookie || {};
		$.extend($.jqx.cookie,
			{
				cookie: function (key, value, options) {
					// set cookie.
					if (arguments.length > 1 && String(value) !== "[object Object]") {
						options = $.extend({}, options);

						if (value === null || value === undefined) {
							options.expires = -1;
						}

						if (typeof options.expires === 'number') {
							var days = options.expires, t = options.expires = new Date();
							t.setDate(t.getDate() + days);
						}

						value = String(value);

						return (document.cookie = [
							encodeURIComponent(key), '=',
							options.raw ? value : encodeURIComponent(value),
							options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
							options.path ? '; path=' + options.path : '',
							options.domain ? '; domain=' + options.domain : '',
							options.secure ? '; secure' : ''
						].join(''));
					}
					// get cookie...
					options = value || {};
					var result, decode = options.raw ? function (s) { return s; } : decodeURIComponent;
					return (result = new RegExp('(?:^|; )' + encodeURIComponent(key) + '=([^;]*)').exec(document.cookie)) ? decode(result[1]) : null;
				}
			});

		// stringutilities
		$.jqx.string = $.jqx.string || {};
		$.extend($.jqx.string,
			{
				replace: function (text, stringToFind, stringToReplace) {
					if (stringToFind === stringToReplace) return this;
					var temp = text;
					var index = temp.indexOf(stringToFind);
					while (index != -1) {
						temp = temp.replace(stringToFind, stringToReplace);
						index = temp.indexOf(stringToFind);
					}
					return temp;
				},

				contains: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					return fullString.indexOf(value) != -1;
				},

				containsIgnoreCase: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					return fullString.toString().toUpperCase().indexOf(value.toString().toUpperCase()) != -1;
				},

				equals: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					fullString = this.normalize(fullString);

					if (value.length == fullString.length) {
						return fullString.slice(0, value.length) == value;
					}

					return false;
				},

				equalsIgnoreCase: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					fullString = this.normalize(fullString);

					if (value.length == fullString.length) {
						return fullString.toUpperCase().slice(0, value.length) == value.toUpperCase();
					}

					return false;
				},

				startsWith: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					return fullString.slice(0, value.length) == value;
				},

				startsWithIgnoreCase: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					return fullString.toUpperCase().slice(0, value.length) == value.toUpperCase();
				},

				normalize: function (fullString) {
					if (fullString.charCodeAt(fullString.length - 1) == 65279) {
						fullString = fullString.substring(0, fullString.length - 1);
					}

					return fullString;
				},

				endsWith: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					fullString = this.normalize(fullString);
					return fullString.slice(-value.length) == value;
				},

				endsWithIgnoreCase: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					fullString = this.normalize(fullString);

					return fullString.toUpperCase().slice(-value.length) == value.toUpperCase();
				}
			});

		if (!$.easing) {
			$.easing = {};
		}
		$.extend($.easing, {
			easeOutBack: function (x, t, b, c, d, s) {
				if (s == undefined) s = 1.70158;
				return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
			},
			easeInQuad: function (x, t, b, c, d) {
				return c * (t /= d) * t + b;
			},
			easeInOutCirc: function (x, t, b, c, d) {
				if ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
				return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
			},
			easeInOutSine: function (x, t, b, c, d) {
				return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
			},
			easeInCubic: function (x, t, b, c, d) {
				return c * (t /= d) * t * t + b;
			},
			easeOutCubic: function (x, t, b, c, d) {
				return c * ((t = t / d - 1) * t * t + 1) + b;
			},
			easeInOutCubic: function (x, t, b, c, d) {
				if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;
				return c / 2 * ((t -= 2) * t * t + 2) + b;
			},
			easeInSine: function (x, t, b, c, d) {
				return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
			},
			easeOutSine: function (x, t, b, c, d) {
				return c * Math.sin(t / d * (Math.PI / 2)) + b;
			},
			easeInOutSine: function (x, t, b, c, d) {
				return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
			}
		});
	})(jqxBaseFramework);

	(function ($) {
		if ($.event && $.event.special) {
			$.extend($.event.special,
				{
					"close": { noBubble: true },
					"open": { noBubble: true },
					"cellclick": { noBubble: true },
					"rowclick": { noBubble: true },
					"tabclick": { noBubble: true },
					"selected": { noBubble: true },
					"expanded": { noBubble: true },
					"collapsed": { noBubble: true },
					"valuechanged": { noBubble: true },
					"expandedItem": { noBubble: true },
					"collapsedItem": { noBubble: true },
					"expandingItem": { noBubble: true },
					"collapsingItem": { noBubble: true }
				});
		}
		if ($.fn.extend) {
			$.fn.extend({
				ischildof: function (filter_string) {
					if (!$(this).parents) {
						var result = filter_string.element.contains(this.element)
						return result;
					}

					var parents = $(this).parents().get();

					for (var j = 0; j < parents.length; j++) {
						if (typeof filter_string != "string") {
							var parent = parents[j];
							if (filter_string !== undefined) {
								if (parent == filter_string[0])
									return true;
							}
						}
						else {
							if (filter_string !== undefined) {
								if ($(parents[j]).is(filter_string)) {
									return true;
								}
							}
						}
					}

					return false;
				}
			});
		}

		$.fn.jqxProxy = function () {
			var widget = $(this).data().jqxWidget;
			var args = Array.prototype.slice.call(arguments, 0);
			var element = widget.element;
			if (!element) element = widget.base.element;
			return $.jqx.jqxWidgetProxy(widget.widgetName, element, args);
		}

		var originalVal = $.originalVal = $.fn.val;
		$.fn.val = function (value) {
			if (typeof value == 'undefined') {
				if ($(this).hasClass('jqx-widget') || $(this).hasClass('jqx-input-group')) {
					var widget = $(this).data().jqxWidget;
					if (widget && widget.val) {
						return widget.val();
					}
				}
				if (this[0] && this[0].tagName.toLowerCase().indexOf('angular') >= 0) {
					var widget = $(this).find('.jqx-widget').data().jqxWidget;
					if (widget && widget.val) {
						return widget.val();
					}

				}
				return originalVal.call(this);
			}
			else {
				if ($(this).hasClass('jqx-widget') || $(this).hasClass('jqx-input-group')) {
					var widget = $(this).data().jqxWidget;
					if (widget && widget.val) {
						if (arguments.length != 2) {
							return widget.val(value);
						}
						else {
							return widget.val(value, arguments[1]);
						}
					}
				}
				if (this[0] && this[0].tagName.toLowerCase().indexOf('angular') >= 0) {
					var widget = $(this).find('.jqx-widget').data().jqxWidget;
					if (widget && widget.val) {
						if (arguments.length != 2) {
							return widget.val(value);
						}
						else {
							return widget.val(value, arguments[1]);
						}
					}

				}

				return originalVal.call(this, value);
			}
		};

		if ($.fn.modal && $.fn.modal.Constructor) {
			$.fn.modal.Constructor.prototype.enforceFocus = function () {
				$(document)
					.off('focusin.bs.modal') // guard against infinite focus loop
					.on('focusin.bs.modal', $.proxy(function (e) {
						if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
							if ($(e.target).parents().hasClass('jqx-popup'))
								return true;
							this.$element.trigger('focus')
						}
					}, this));
			}
		}

		$.fn.coord = function (options) {
			var docElem, win,
				box = { top: 0, left: 0 },
				elem = this[0],
				doc = elem && elem.ownerDocument;
			if (!doc) {
				return;
			}
			docElem = doc.documentElement;
			if (!$.contains(docElem, elem)) {
				return box;
			}
			if (typeof elem.getBoundingClientRect !== undefined) {
				box = elem.getBoundingClientRect();
			}
			var getWindow = function (elem) {
				return $.isWindow(elem) ?
					elem :
					elem.nodeType === 9 ?
						elem.defaultView || elem.parentWindow :
						false;
			};

			win = getWindow(doc);
			var additionalLeftOffset = 0;
			var additionalTopOffset = 0;
			var agent = navigator.userAgent.toLowerCase();
			var result = agent.indexOf('ipad') != -1 || agent.indexOf('iphone') != -1;
			if (result) {
				// fix for iphone/ipad left offsets.
				additionalLeftOffset = 2;
			}
			if (true == options) {
				if (document.body.style.position != 'static' && document.body.style.position != '') {
					var coords = $(document.body).coord();
					additionalLeftOffset = -coords.left;
					additionalTopOffset = -coords.top;
				}
			}

			return {
				top: additionalTopOffset + box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
				left: additionalLeftOffset + box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
			};
		};

		$.jqx.ripplers = [];
		$.jqx.ripple = function (element, hostElement, hostElementType) {
			if (!hostElement) {
				hostElement = element;
			}

			var rippler = $(element);
			var mouseCaptured = false;

			rippler.append("<span class='ink'></span>");
			var ink = rippler.find('.ink');


			var hasRippler = false;

			for (var i = 0; i < $.jqx.ripplers.length; i++) {
				var ripplerItem = $.jqx.ripplers[i];

				if (ripplerItem.element[0] === element[0]) {
					hasRippler = true;
					break;
				}
			}

			if (!hasRippler) {
				$.jqx.ripplers.push({ ink: ink, element: element, hostElement: hostElement, hostElementType: hostElementType });
			}

			if (hostElementType === "checkbox" || hostElementType === "radiobutton") {

				// set .ink diametr
				var d = Math.max(rippler.outerWidth(), rippler.outerHeight());
				ink.css({ height: d, width: d });

				var x = rippler.width() / 2 - ink.width() / 2;
				var y = rippler.height() / 2 - ink.height() / 2;

				// set .ink position and add class .animate
				ink.css({
					top: y + 'px',
					left: x + 'px'
				});
			}

			// Ripple-effect animation
			if ($.jqx.ripplers.length === 1) {
				$(document).on('mouseup', function (e) {
					$.jqx.ripple.mouseCaptured = false;

					for (var i = 0; i < $.jqx.ripplers.length; i++) {
						var rippler = $.jqx.ripplers[i];

						rippler.ink.removeClass('active');
						rippler.element.removeClass('active');

						if (hostElementType !== "checkbox" && hostElementType !== "radiobutton") {
							if (rippler.ink.hasClass('animate')) {
								rippler.ink.removeClass('animate');
							}
						}
					}
				});
			}
			hostElement.off('mousedown.ripple');
			hostElement.on('mousedown.ripple', function (e) {
				var rippler = $(element);

				$.jqx.ripple.mouseCaptured = true;

				setTimeout(function () {
					// create .ink element if it doesn't exist

					if (rippler.find('.ink').length == 0) {
						rippler.append("<span class='ink'></span>");
					}

					var ink = rippler.find('.ink');

					// prevent quick double clicks
					ink.removeClass('animate');


					// set .ink diametr
					if (!ink.height() && !ink.width()) {
						var d = Math.max(rippler.outerWidth(), rippler.outerHeight());
						ink.css({ height: d, width: d });
					}

					if (hostElementType === "checkbox" || hostElementType === "radiobutton") {
						if (hostElementType === "checkbox") {
							if (hostElement.jqxCheckBox('disabled')) {
								return;
							}
						}

						if (hostElementType === "radiobutton") {
							if (hostElement.jqxRadioButton('disabled')) {
								return;
							}
						}

						// get click coordinates
						var x = rippler.width() / 2 - ink.width() / 2;
						var y = rippler.height() / 2 - ink.height() / 2;

						// set .ink position and add class .animate
						ink.css({
							top: y + 'px',
							left: x + 'px'
						}).addClass('animate');

						ink.on('animationend', function () {
							if ($.jqx.ripple.mouseCaptured) {
								ink.removeClass('animate')
								ink.addClass('active')
								element.addClass('active')
							}
						});

						return;
					}

					// get click coordinates
					var x = e.pageX - rippler.offset().left - ink.width() / 2;
					var y = e.pageY - rippler.offset().top - ink.height() / 2;

					// set .ink position and add class .animate
					ink.css({
						top: y + 'px',
						left: x + 'px'
					}).addClass('animate');
				});
			});
		}
	})(jqxBaseFramework);
})();




/***/ }),

/***/ 3907:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {
    var ArrayExporter = (function () {

        var exportModules = {},
            data, dataFields, styles, exporter, stylesArray, hierarchy, exportFormat, filename;

        function exportData(exporter, data, dataFields, styles, hierarchy, exportFormat, filename) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            that.hierarchy = hierarchy;
            that.exportFormat = exportFormat;
            that.filename = filename;

            exporter.beginFile(filename);
            exportHeader(exporter);
            exportContent(exporter);
            exporter.endFile(filename);
            return exporter.getFile();
        }

        function exportHeader(exporter) {
            var exportHeaders = true;
            $.each(dataFields, function () {
                if (this.hidden) {
                    exportHeaders = false;
                    return false;
                }
            });

            exporter.beginHeader(exportHeaders);
            var index = 0;
            for (var cellContent in dataFields) {
                if (dataFields[cellContent].columnsDataFields) {
                    cellContent = dataFields[cellContent].columnsDataFields[index].displayfield;
                }
                var style = getHeaderStyle(cellContent, dataFields[cellContent]);
                exporter.appendHeaderCell(dataFields[cellContent], cellContent, style, exportHeaders, index);
                index++;
            }
            exporter.endHeader(exportHeaders);
        }

        function exportContent(exporter) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            exporter.beginBody();
            if (that.hierarchy) {
                var exporHierarchy = function (data) {
                    for (var i = 0; i < data.length; i += 1) {
                        if (data[i] !== undefined) {
                            exporter.hierarchy = true;
                            exporter.beginRow(data[i].level);
                            exportRow(exporter, data[i], i, true);
                            if (data[i].records) {
                                exporter.beginRows(data[i].level);
                                exporHierarchy(data[i].records);
                                exporter.endRows(data[i].level);
                            }
                            exporter.endRow(data[i].level);
                        }
                    }
                }
                exporHierarchy(data);
                exporter.endBody();
                return;
            }

            for (var i = 0; i < data.length; i += 1) {
                if (data[i] !== undefined) {
                    exportRow(exporter, data[i], i);
                }
            }
            exporter.endBody();
        }

        function exportRow(exporter, data, rowId, hierarchy) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            var style;
            if (hierarchy != true) {
                exporter.beginRow();
            }
            var indx = 0;
            for (var column in dataFields) {
                if (dataFields[column].columnsDataFields) {
                    column = dataFields[column].columnsDataFields[indx].displayfield;
                }

                style = getRowCellStyle(rowId, column);
                if (style) {
                    if (style.level != undefined) {
                        if (style.index - 1 > data.level && style.index - 1 < style.maxLevel) {
                            indx++;
                            continue;
                        }
                    }
                    if (style.maxLevel != undefined) {
                        if (style.index - 1 == style.maxLevel) {
                            style = $.extend({}, style);
                            style.merge = style.maxLevel - data.level - 1;
                        }
                    }
                }
                if (data.level != undefined && data.label != undefined) {
                    if (that.exportFormat === "xml" || that.exportFormat === "json") {
                        var dataGroup = {};
                        dataGroup['text'] = "group";
                        exporter.appendBodyCell(data.label, dataGroup, style, data, indx, "group");
                        break;
                    }
                }

                if (data.hasOwnProperty(column)) {
                    exporter.appendBodyCell(data[column], dataFields[column], style, data, indx);
                }
                else {
                    exporter.appendBodyCell("", dataFields[column], style, data, indx);
                }
                indx++;
            }
            if (hierarchy != true) {
                exporter.endRow();
            }
        }

        function getHeaderStyle(columnName, dataField) {
            if (dataField.style) {
                return styles[dataField.style];
            }

            var rowStyles = getStylesArray();
            if (rowStyles.length > 0) {
                return rowStyles[0].style;
            }
            return null;
        }

        function getStylesArray() {
            if (!stylesArray) {
                stylesArray = new Array();
                $.each(styles, function (index, value) {
                    stylesArray[stylesArray.length] = { name: index, style: value };
                });
            }

            return stylesArray;
        }

        function getRowCellStyle(rowId, column) {
            var dataField = dataFields[column];
            if (dataField) {
                if (dataField.customCellStyles) {
                    var customStyle = dataField.customCellStyles[rowId];
                    if (customStyle) {
                        return styles[customStyle];
                    }
                }

                if (dataField.cellStyle) {
                    if (dataField.cellAltStyle) {
                        var styleId = rowId % 2;
                        if (styleId == 0)
                            return styles[dataField.cellStyle];
                        return styles[dataField.cellAltStyle];
                    }
                    return styles[dataField.cellStyle];
                }
                else {
                    var rowStyles = getStylesArray();
                    if (rowStyles.length > 0) {
                        var styleId = rowId % (rowStyles.length - 1);
                        var style = rowStyles[styleId + 1].style;
                        return style;
                    }
                }
            }
            return null;
        }

        function createHiddenInput(value, name, form) {
            var input = document.createElement('input');
            input.name = name;
            input.value = value;
            input.type = 'hidden';
            form.appendChild(input);
            return input;
        }

        function createHiddenTextArea(value, name, form) {
            var textArea = document.createElement('textarea');
            textArea.name = name;
            textArea.value = value;
            //      textArea.type = 'hidden';
            form.appendChild(textArea);
            return textArea;
        }

        function createForm(filename, format, content, exportServer, charset) {
            var form = document.createElement('form');
            createHiddenInput(filename, 'filename', form);
            createHiddenInput(format, 'format', form);
            createHiddenTextArea(content, 'content', form);
            if (exportServer == undefined || exportServer == '') {
                if (window && window.location.toString().indexOf('jqwidgets.com') >= 0) {
                    exportServer = 'https://jqwidgets.com/export_server/dataexport.php';
                }
                else {
                    exportServer = 'http://jquerygrid.net/export_server/dataexport.php';
                }
            }

            form.action = exportServer;
            form.method = 'post';
            if (charset) {
                form.acceptCharset = charset;
            }

            document.body.appendChild(form);
            return form;
        }

        exporter = function (inputData, inputDataFields, inputStyles, exportServer, hierarchy, exportFormat) {
            if (!(this instanceof ArrayExporter)) {
                return new ArrayExporter(inputData, inputDataFields, inputStyles, hierarchy, exportFormat);
            }
            data = inputData;
            dataFields = inputDataFields;
            styles = inputStyles;

            this.exportTo = function (format, hierarchy, exportFormat, filename) {
                format = format.toString().toLowerCase();
                var module = exportModules[format];
                if (typeof module === 'undefined') {
                    throw 'You can\'t export to ' + format + ' format.';
                }
                if (format === "pdf" && filename == undefined) {
                    var table = this.exportTo(format, hierarchy, format, "pdf");
                    if (!$.jqx.pdfExport) {
                        $.jqx.pdfExport =
                        {
                            orientation: "portrait",
                            paperSize: "a4"
                        }
                    }

                    var doc = new pdfDataExport($.jqx.pdfExport.orientation, 'pt', $.jqx.pdfExport.paperSize);
                    doc.cellInitialize();
                    var headerCells = $(table).find('th');
                    var tableRows = $(table).find('tr');
                    var rows = 0;
                    doc.setFontSize(13 * 72 / 96);
                    var totalWidth = 595;
                    switch ($.jqx.pdfExport.paperSize) {
                        case "legal":
                            var totalWidth = 612;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 1008;
                            }
                            break;
                        case "letter":
                            var totalWidth = 612;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 792;
                            }
                            break;
                        case "a3":
                            var totalWidth = 841;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 1190;
                            }
                            break;
                        case "a4":
                            var totalWidth = 595;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 842;
                            }
                            break;
                        case "a5":
                            var totalWidth = 420;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 595;
                            }
                            break
                    }
                    totalWidth -= 20;
                    var totalColumnsWidth = 0;
                    var columnWidths = [];
                    $.each(headerCells, function (index) {
                        var width = parseInt(this.style.width);
                        if (isNaN(width)) {
                            width = 25;
                        }
                        var widthPoints = width * 72 / 96;
                        columnWidths[index] = widthPoints;
                        totalColumnsWidth += widthPoints;
                    });

                    if (headerCells.length === 0) {
                        $.each(tableRows[0].cells, function (index) {
                            var width = parseInt(this.style.width);
                            if (isNaN(width)) {
                                width = totalWidth / tableRows[0].cells.length;
                            }
                            var widthPoints = width * 72 / 96;
                            columnWidths[index] = widthPoints;
                            totalColumnsWidth += widthPoints;
                        });
                    }

                    if (totalColumnsWidth > totalWidth) {
                        $.each(columnWidths, function (index) {
                            columnWidths[index] = (columnWidths[index] / totalColumnsWidth) * 100;
                            columnWidths[index] = columnWidths[index] * totalWidth / 100;
                        });
                    }

                    $.each(headerCells, function (index) {
                        var widthPoints = columnWidths[index];
                        var heightPoints = 25 * 72 / 96;
                        var textDimension = doc.getTextDimensions($(this).html());
                        var cellText = $(this).html();
                        if (textDimension.w + 3 > widthPoints) {
                            var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                            var newText = splitText[0];
                            if (newText.length > 3) {
                                cellText = newText.substring(0, newText.length - 3) + "...";
                            }
                            else cellText = newText.substring(0, 1) + "...";
                            var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                            var newText = splitText[0];
                            if (newText != cellText) {
                                cellText = newText;
                            }
                        }
                        doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                    });

                    rows++;
                    $.each(tableRows, function (index) {
                        if (index === 0) return true;
                        var rowCells = $(this).children();
                        var isTreeGrid = rowCells.length > headerCells.length && headerCells.length > 0;
                        if (isTreeGrid) {
                            var mergeLength = rowCells.length - headerCells.length;
                            var cellText = "";
                            var widthPoints = columnWidths[0];
                            var heightPoints = 25 * 72 / 96;
                            for (var i = 0; i <= mergeLength; i++) {
                                var cellHTML = rowCells[i].innerHTML;
                                if (cellHTML === "+" || cellHTML === "-") cellHTML = cellHTML + " ";
                                if (cellHTML === "&nbsp;") cellHTML = "   ";
                                cellText += cellHTML;
                            }
                            var textDimension = doc.getTextDimensions(cellText);
                            if (textDimension.w + 3 > widthPoints) {
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText.length > 3) {
                                    cellText = newText.substring(0, newText.length - 3) + "...";
                                }
                                else cellText = newText.substring(0, 1) + "...";
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText != cellText) {
                                    cellText = newText;
                                }
                            }

                            doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                            for (var i = mergeLength + 1; i < rowCells.length; i++) {
                                var index = i - mergeLength;
                                var widthPoints = columnWidths[index];
                                var heightPoints = 25 * 72 / 96;
                                var cellText = $(rowCells[i]).html();
                                var textDimension = doc.getTextDimensions($(rowCells[i]).html());
                                if (textDimension.w + 3 > widthPoints) {
                                    var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                    var newText = splitText[0];
                                    if (newText.length > 3) {
                                        cellText = newText.substring(0, newText.length - 3) + "...";
                                    }
                                    else cellText = newText.substring(0, 1) + "...";
                                    var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                    var newText = splitText[0];
                                    if (newText != cellText) {
                                        cellText = newText;
                                    }
                                }
                                doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                            }
                            rows++;
                            return true;
                        }

                        $.each(rowCells, function (index) {
                            var widthPoints = columnWidths[index];
                            var heightPoints = 25 * 72 / 96;
                            var cellText = $(this).html();
                            var textDimension = doc.getTextDimensions($(this).html());
                            if (textDimension.w + 3 > widthPoints) {
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText.length > 3) {
                                    cellText = newText.substring(0, newText.length - 3) + "...";
                                }
                                else cellText = newText.substring(0, 1) + "...";
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText != cellText) {
                                    cellText = newText;
                                }
                            }
                            doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                        }
                        );
                        rows++;
                    });
                    if ($.jqx.browser.msie && $.jqx.browser.version < 10) {
                        throw new Error("PDF export requires a browser with HTML5 support");
                        return;
                    }

                    return doc;
                }

                return exportData(module, data, dataFields, styles, hierarchy, exportFormat, filename);
            };

            this.exportToFile = function (format, filename, exportServer, charset, hierarchy) {
                if (format === "pdf") {
                    var table = this.exportTo(format, hierarchy, format, filename);
                    if (!$.jqx.pdfExport) {
                        $.jqx.pdfExport =
                        {
                            orientation: "portrait",
                            paperSize: "a4"
                        }
                    }

                    var doc = new pdfDataExport($.jqx.pdfExport.orientation, 'pt', $.jqx.pdfExport.paperSize);
                    if (charset == "utf-8" || charset == "UTF-8") {
                        doc.setFont("courier", "normal");
                    }

                    doc.cellInitialize();
                    var headerCells = $(table).find('th');
                    var tableRows = $(table).find('tr');
                    var rows = 0;
                    doc.setFontSize(13 * 72 / 96);
                    var totalWidth = 595;
                    switch ($.jqx.pdfExport.paperSize) {
                        case "legal":
                            var totalWidth = 612;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 1008;
                            }
                            break;
                        case "letter":
                            var totalWidth = 612;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 792;
                            }
                            break;
                        case "a3":
                            var totalWidth = 841;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 1190;
                            }
                            break;
                        case "a4":
                            var totalWidth = 595;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 842;
                            }
                            break;
                        case "a5":
                            var totalWidth = 420;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 595;
                            }
                            break
                    }
                    totalWidth -= 20;
                    var totalColumnsWidth = 0;
                    var columnWidths = [];
                    $.each(headerCells, function (index) {
                        var width = parseInt(this.style.width);
                        if (isNaN(width)) {
                            width = 25;
                        }
                        var widthPoints = width * 72 / 96;
                        columnWidths[index] = widthPoints;
                        totalColumnsWidth += widthPoints;
                    });

                    if (headerCells.length === 0) {
                        $.each(tableRows[0].cells, function (index) {
                            var width = parseInt(this.style.width);
                            if (isNaN(width)) {
                                width = totalWidth / tableRows[0].cells.length;
                            }
                            var widthPoints = width * 72 / 96;
                            columnWidths[index] = widthPoints;
                            totalColumnsWidth += widthPoints;
                        });
                    }

                    if (totalColumnsWidth > totalWidth) {
                        $.each(columnWidths, function (index) {
                            columnWidths[index] = (columnWidths[index] / totalColumnsWidth) * 100;
                            columnWidths[index] = columnWidths[index] * totalWidth / 100;
                        });
                    }

                    $.each(headerCells, function (index) {
                        var widthPoints = columnWidths[index];
                        var heightPoints = 25 * 72 / 96;
                        var textDimension = doc.getTextDimensions($(this).html());
                        var cellText = $(this).html();
                        if (textDimension.w + 3 > widthPoints) {
                            var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                            var newText = splitText[0];
                            if (newText.length > 3) {
                                cellText = newText.substring(0, newText.length - 3) + "...";
                            }
                            else cellText = newText.substring(0, 1) + "...";
                            var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                            var newText = splitText[0];
                            if (newText != cellText) {
                                cellText = newText;
                            }
                        }
                        doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                    });

                    rows++;
                    $.each(tableRows, function (index) {
                        if (index === 0) return true;
                        var rowCells = $(this).children();
                        var isTreeGrid = rowCells.length > headerCells.length && headerCells.length > 0;
                        if (isTreeGrid) {
                            var mergeLength = rowCells.length - headerCells.length;
                            var cellText = "";
                            var widthPoints = columnWidths[0];
                            var heightPoints = 25 * 72 / 96;
                            for (var i = 0; i <= mergeLength; i++) {
                                var cellHTML = rowCells[i].innerHTML;
                                if (cellHTML === "+" || cellHTML === "-") cellHTML = cellHTML + " ";
                                if (cellHTML === "&nbsp;") cellHTML = "   ";
                                cellText += cellHTML;
                            }
                            var textDimension = doc.getTextDimensions(cellText);
                            if (textDimension.w + 3 > widthPoints) {
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText.length > 3) {
                                    cellText = newText.substring(0, newText.length - 3) + "...";
                                }
                                else cellText = newText.substring(0, 1) + "...";
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText != cellText) {
                                    cellText = newText;
                                }
                            }

                            doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                            for (var i = mergeLength + 1; i < rowCells.length; i++) {
                                var index = i - mergeLength;
                                var widthPoints = columnWidths[index];
                                var heightPoints = 25 * 72 / 96;
                                var cellText = $(rowCells[i]).html();
                                if (cellText === "&nbsp;") cellText = "   ";

                                var textDimension = doc.getTextDimensions($(rowCells[i]).html());
                                if (textDimension.w + 3 > widthPoints) {
                                    var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                    var newText = splitText[0];
                                    if (newText.length > 3) {
                                        cellText = newText.substring(0, newText.length - 3) + "...";
                                    }
                                    else cellText = newText.substring(0, 1) + "...";
                                    var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                    var newText = splitText[0];
                                    if (newText != cellText) {
                                        cellText = newText;
                                    }
                                }
                                doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                            }
                            rows++;
                            return true;
                        }

                        $.each(rowCells, function (index) {
                            var widthPoints = columnWidths[index];
                            var heightPoints = 25 * 72 / 96;
                            var cellText = $(this).html();
                            if (cellText === "&nbsp;") cellText = "   ";

                            var textDimension = doc.getTextDimensions($(this).html());
                            if (textDimension.w + 3 > widthPoints) {
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText.length > 3) {
                                    cellText = newText.substring(0, newText.length - 3) + "...";
                                }
                                else cellText = newText.substring(0, 1) + "...";
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText != cellText) {
                                    cellText = newText;
                                }
                            }
                            doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                        }
                        );
                        rows++;
                    });
                    if ($.jqx.browser.msie && $.jqx.browser.version < 10) {
                        throw new Error("PDF export requires a browser with HTML5 support");
                        return;
                    }

                    doc.save(filename + ".pdf");
                    return;
                }

                var content = this.exportTo(format, hierarchy, format, filename),
                    form = createForm(filename, format, content, exportServer, charset);
                form.submit();
                document.body.removeChild(form);
            };

            this.exportToLocalFile = function (format, filename, hierarchy, exportFormat) {
                var content = this.exportTo(format, hierarchy, exportFormat);
                document.location.href = 'data:application/octet-stream;filename=' + filename + ',' + encodeURIComponent(content);
            };

        };

        exporter.extend = function (exportFormat, exporter) {
            if (exporter instanceof $.jqx.dataAdapter.DataExportModuleBase) {
                exportModules[exportFormat] = exporter;
            } else {
                throw 'The module ' + exportFormat + ' is not instance of DataExportModuleBase.';
            }
        };

        return exporter;

    }());

    $.jqx.dataAdapter.ArrayExporter = ArrayExporter;

})(jqxBaseFramework);


(function ($) {

    //Defines common interface for all modules used for exportation
    var DataExportModuleBase = function () {

        this.formatData = function (data, type, formatString, localization) {
            if (type === 'date') {
                var tmpdate = "";
                if (typeof data === 'string') {
                    tmpdate = $.jqx.dataFormat.tryparsedate(data);
                    data = tmpdate;
                }
                if (data === "" || data === null) return "";
                tmpdate = $.jqx.dataFormat.formatdate(data, formatString, localization);
                if ((tmpdate && tmpdate.toString() == "NaN") || tmpdate == null) return "";
                data = tmpdate;
            } else if (type === 'number' || type === 'float' || type === 'int' || type == 'integer') {
                if (data === "" || data === null) return "";

                if (!isNaN(new Number(data))) {
                    var tmpdata = $.jqx.dataFormat.formatnumber(data, formatString, localization);
                    if (tmpdata.toString() == "NaN") return "";
                    else data = tmpdata;
                }
            } else {
                data = data;
            }
            if (data === null) return "";
            return data;
        };

        this.getFormat = function (dataOptions) {
            var formatString = dataOptions ? dataOptions['formatString'] : "";
            var localization = dataOptions ? dataOptions['localization'] : "";
            var dataType = 'string';
            dataType = dataOptions ? dataOptions['type'] : 'string';

            if (dataType == 'number' || dataType == 'float') {
                if (!formatString) formatString = 'f2';
            }
            if (dataType == 'int' || dataType == 'integer') {
                if (!formatString) formatString = 'n0';
            }
            if (dataType == 'date') {
                if (!formatString) formatString = 'd';
            }
            return { type: dataType, formatString: formatString, localization: localization };
        };

        this.beginFile = function () {
            throw 'Not implemented!';
        };

        this.beginHeader = function () {
            throw 'Not implemented!';
        };

        this.appendHeaderCell = function () {
            throw 'Not implemented!';
        };

        this.endHeader = function () {
            throw 'Not implemented!';
        };

        this.beginBody = function () {
            throw 'Not implemented!';
        };

        this.beginRow = function () {
            throw 'Not implemented!';
        };

        this.beginRows = function () {
            throw 'Not implemented!';
        };

        this.endRows = function () {
            throw 'Not implemented!';
        };

        this.appendBodyCell = function () {
            throw 'Not implemented!';
        };

        this.endRow = function () {
            throw 'Not implemented!';
        };

        this.endBody = function () {
            throw 'Not implemented!';
        };

        this.endFile = function () {
            throw 'Not implemented!';
        };

        this.getFile = function () {
            throw 'Not implemented!';
        };
    }

    $.jqx.dataAdapter.DataExportModuleBase = DataExportModuleBase;

})(jqxBaseFramework);

//Extending the exporter with TSV and CSV exporters
(function ($) {

    //Value exporter. This object is common prototype for TSV and CVS.
    var SvExporter = function (inValueSeparator) {

        var file, valueSeparator, hasHeader;
        var rowIndex = 0;
        var me = this;

        this.beginFile = function () {
            file = '';
        };

        this.beginHeader = function () {
        };

        this.appendHeaderCell = function (data, fieldName, style, exportHeader, index) {
            if (style) {
                if (style.level != undefined) {
                    if (index < style.maxLevel) {
                        return;
                    }
                    else if (index === style.maxLevel) {
                        if (exportHeader) {
                            appendCell(data.text);
                        }
                        for (var i = 0; i < style.maxLevel; i++) {
                            appendCell("");
                        }
                        return;
                    }
                }
            }

            hasHeader = exportHeader;
            if (exportHeader) {
                appendCell(data.text);
            }
        };

        this.endHeader = function () {
            this.endRow();
        };

        this.beginBody = function () {
            rowIndex = 0;
        };

        this.beginRow = function () {
            if ((rowIndex > 0) || (rowIndex == 0 && hasHeader)) {
                file += '\n';
            }
            rowIndex++;
        };

        this.appendBodyCell = function (data, dataType, style, row, index) {
            if (style) {
                if (style.maxLevel != undefined) {
                    if (index === style.maxLevel) {
                        appendCell(data, dataType);
                        for (var i = 0; i < style.maxLevel - row.level - 1; i++) {
                            appendCell("", dataType);
                        }
                        return;
                    }
                }
            }
            appendCell(data, dataType);
        };

        this.endRow = function () {
            file = file.substring(0, file.length - 1);
        };

        this.endBody = function () {
        };

        this.endFile = function () {
        };

        this.getFile = function () {
            return file;
        };

        function prepareData(data, dataOptions) {
            if (dataOptions) {
                var format = me.getFormat(dataOptions);
                data = me.formatData(data, format.type, format.formatString, format.localization);
            }
            data = '"' + data + '"';
            return data;
        };

        function appendCell(data, dataOptions) {
            data = prepareData(data, dataOptions);
            file += data + inValueSeparator;
        };

    };

    SvExporter.prototype = new $.jqx.dataAdapter.DataExportModuleBase();

    var CsvExporter = function () { };
    CsvExporter.prototype = new SvExporter(',');

    var TsvExporter = function () { };
    TsvExporter.prototype = new SvExporter('\t');

    $.jqx.dataAdapter.ArrayExporter.extend('csv', new CsvExporter());
    $.jqx.dataAdapter.ArrayExporter.extend('tsv', new TsvExporter());

})(jqxBaseFramework);

//Extending the exporter with HTML exporter
(function ($) {

    var HtmlExporter = function () {
        var isPDF = false;
        var file;
        var hasHeader;
        var rowIndex = 0;

        this.setPDF = function () {
            isPDF = true;
        };

        this.beginFile = function (filename) {
            if (isPDF || filename == undefined) {
                file = '<table style="empty-cells: show;" cellspacing="0" cellpadding="2">';
            }
            else {
                file = '<html>\n\t<head>\n\t\t<title></title>\n' +
					   '\t\t<meta http-equiv=Content-type content=\"text/html; charset=UTF-8\">\n\t</head>\n\t<body>\n' +
					   '\t\t<table style="empty-cells: show;" cellspacing="0" cellpadding="2">';
            }
        };

        this.beginHeader = function () {
            if (isPDF) {
                file += '\n\t<thead><tr>';
            }
            else {
                file += '\n\t\t\t<thead>';
            }
        };

        this.appendHeaderCell = function (data, fieldName, style, exportHeader) {
            hasHeader = exportHeader;
            if (!exportHeader) return;

            if (isPDF) {
                file += '\n\t\t\t\t<th style="' + buildStyle(style) + '">' + data.text + '</th>';
            }
            else {
                if (style.disabled) return;

                if (style.merge) {
                    if (data.width) {
                        file += '\n\t\t\t\t<th colspan=' + (1 + style.merge) + ' style="width: ' + data.width + 'px; ' + buildStyle(style) + '">' + data.text + '</th>';
                    }
                    else {
                        file += '\n\t\t\t\t<th colspan=' + (1 + style.merge) + ' style="' + buildStyle(style) + '">' + data.text + '</th>';
                    }
                }
                else {
                    if (data.width) {
                        file += '\n\t\t\t\t<th style="width: ' + data.width + 'px; ' + buildStyle(style) + '">' + data.text + '</th>';
                    }
                    else {
                        file += '\n\t\t\t\t<th style="' + buildStyle(style) + '">' + data.text + '</th>';
                    }
                }
            }
        };

        this.endHeader = function () {
            if (isPDF) {
                file += '\n\t</tr></thead>';
            }
            else {
                file += '\n\t\t\t</thead>';
            }
        };

        this.beginBody = function () {
            if (isPDF) {
                file += '\n\t<tbody>';
            }
            else {
                file += '\n\t\t\t<tbody>';
            }
            rowIndex = 0;
        };

        this.beginRow = function () {
            if (isPDF) {
                file += '\n\t<tr>';
            }
            else {
                file += '\n\t\t\t\t<tr>';
            }
            rowIndex++;
        };

        this.appendBodyCell = function (data, dataOptions, style) {
            var format = this.getFormat(dataOptions);
            if (data === "") data = "&nbsp;";
            if (isPDF) {
                if (rowIndex == 1 && !hasHeader) {
                    file += '\n\t\t\t\t\t<td style="' + buildStyle(style) + ' border-top-width: 1px;">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                }
                else {
                    file += '\n\t\t\t\t\t<td style="' + buildStyle(style) + '">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                }
            }
            else {
                if (style.merge) {
                    if (rowIndex == 1 && !hasHeader) {
                        file += '\n\t\t\t\t\t<td colspan=' + (1 + style.merge) + ' style="' + buildStyle(style) + ' border-top-width: 1px;">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                    }
                    else {
                        file += '\n\t\t\t\t\t<td colspan=' + (1 + style.merge) + ' style="' + buildStyle(style) + '">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                    }
                }
                else {
                    if (rowIndex == 1 && !hasHeader) {
                        file += '\n\t\t\t\t\t<td style="' + buildStyle(style) + ' border-top-width: 1px;">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                    }
                    else {
                        file += '\n\t\t\t\t\t<td style="' + buildStyle(style) + '">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                    }
                }
            }
        };

        this.endRow = function () {
            if (isPDF) {
                file += '\n\t</tr>';
            }
            else {
                file += '\n\t\t\t\t</tr>';
            }
        };

        this.endBody = function () {
            if (isPDF) {
                file += '\n\t</tbody>';
            }
            else {
                file += '\n\t\t\t</tbody>';
            }
        };

        this.endFile = function (filename) {
            if (isPDF || filename == undefined) {
                file += '\n</table>';
            }
            else {
                file += '\n\t\t</table>\n\t</body>\n</html>\n';
            }
        };

        this.getFile = function () {
            return file;
        };

        function buildStyle(styles) {
            var result = '';
            for (var style in styles) {
                if (styles.hasOwnProperty(style)) {
                    if (isPDF && style == 'font-size') {
                        styles[style] = '100%';
                    }
                    result += style + ':' + styles[style] + ';';
                }
            }
            return result;
        }
    }

    HtmlExporter.prototype = new $.jqx.dataAdapter.DataExportModuleBase();

    var TableExporter = function () { };
    TableExporter.prototype = new HtmlExporter();

    var PDFExporter = function () { };
    PDFExporter.prototype = new HtmlExporter();
    var exporter = new PDFExporter();

    $.jqx.dataAdapter.ArrayExporter.extend('html', new TableExporter());
    $.jqx.dataAdapter.ArrayExporter.extend('pdf', exporter);

})(jqxBaseFramework);

//Exporting to XLS format (MS Office Excel 2003)
(function ($) {

    var ExcelExporter = function () {

        var header, content, headerFields, headerStyles, existingStyles, styleCounter,
            styleBuilder = {

                style: '',

                stylesMap: {
                    'font': {
                        'color': 'Color',
                        'font-family': 'FontName',
                        'font-style': 'Italic',
                        'font-weight': 'Bold'
                    },
                    'interior': {
                        'background-color': 'Color',
                        'background': 'Color'
                    },
                    'alignment': {
                        'left': 'Left',
                        'center': 'Center',
                        'right': 'Right'
                    }
                },

                startStyle: function (styleName) {
                    this.style += '\n\t\t<Style ss:ID="' + styleName + '" ss:Name="' + styleName + '">';
                },

                buildAlignment: function (styles) {
                    if (styles['text-align']) {
                        var alignment = this.stylesMap['alignment'][styles['text-align']];
                        if (!alignment) {
                            alignment = "Left";
                        }
                        var style = '\n\t\t\t<Alignment ss:Vertical="Bottom" ss:Horizontal="' + alignment + '"/>';
                        this.style += style;
                    }
                },

                buildBorder: function (styles) {
                    if (styles['border-color']) {
                        var border = '\n\t\t\t<Borders>';
                        var bottomBorder = '\n\t\t\t\t<Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="' + styles['border-color'] + '"/>';
                        var leftBorder = '\n\t\t\t\t<Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="' + styles['border-color'] + '"/>';
                        var rightBorder = '\n\t\t\t\t<Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="' + styles['border-color'] + '"/>';
                        var topBorder = '\n\t\t\t\t<Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="' + styles['border-color'] + '"/>';

                        border += bottomBorder;
                        border += leftBorder;
                        border += rightBorder;
                        border += topBorder;
                        border += '\n\t\t\t</Borders>';
                        this.style += border;
                    }
                },

                buildFont: function (styles) {
                    var map = this.stylesMap['font'],
                        font = '\n\t\t\t<Font ';
                    for (var prop in map) {
                        if (typeof styles[prop] !== 'undefined') {
                            if (prop === 'font-style' && styles[prop].toString().toLowerCase() === 'italic') {
                                font += 'ss:Italic="1" ';
                            } else if (prop === 'font-weight' && styles[prop].toString().toLowerCase() === 'bold') {
                                font += 'ss:Bold="1" ';
                            } else if (prop === 'color') {
                                font += 'ss:' + map[prop] + '="' + styles[prop] + '" ';
                            }
                        }
                    }
                    font += '/>';
                    this.style += font;
                },

                buildInterior: function (styles) {
                    var map = this.stylesMap['interior'],
                        interior = '\n\t\t\t<Interior ';
                    var hasInterior = false;
                    for (var prop in map) {
                        if (typeof styles[prop] !== 'undefined') {
                            interior += 'ss:' + map[prop] + '="' + styles[prop] + '" ';
                            hasInterior = true;
                        }
                    }
                    if (hasInterior)
                        interior += 'ss:Pattern="Solid"';

                    interior += '/>';
                    this.style += interior;
                },

                buildFormat: function (styles) {
                    if (styles['dataType'] == 'number' || styles['dataType'] == 'float' || styles['dataType'] == 'int' || styles['dataType'] == 'integer') {
                        var formatString = styles['formatString'];
                        if (formatString == "" || formatString.indexOf('n') != -1 || formatString.indexOf('N') != -1) {
                            this.style += '\n\t\t\t<NumberFormat ss:Format="0"/>';
                        }
                        else if (formatString == "f" || formatString == "F" || formatString == "D" || formatString.indexOf('d') != -1) {
                            this.style += '\n\t\t\t<NumberFormat ss:Format="#,##0.00_);[Red]\(#,##0.00\)"/>';
                        }
                        else if (formatString.indexOf('p') != -1 || formatString.indexOf('P') != -1) {
                            this.style += '\n\t\t\t<NumberFormat ss:Format="Percent"/>';
                        }
                        else if (formatString.indexOf('c') != -1 || formatString.indexOf('C') != -1) {
                            if (styles['currencysymbol'] && parseInt(styles['currencysymbol'].charCodeAt(0)) == 8364) {
                                this.style += '\n\t\t\t<NumberFormat ss:Format="Euro Currency"/>';
                            }
                            else {
                                this.style += '\n\t\t\t<NumberFormat ss:Format="Currency"/>';
                            }
                        }
                    }
                    else if (styles['dataType'] == 'date') {
                        this.style += '\n\t\t\t<NumberFormat ss:Format="Short Date"/>';
                    }
                },

                closeStyle: function () {
                    this.style += '\n\t\t</Style>';
                },

                toString: function () {
                    var temp = this.style;
                    this.style = '';
                    return temp;
                }
            };

        this.beginFile = function () {
            existingStyles = {};
            styleCounter = 0;
            header = '<?xml version="1.0"?>' +
                            '\n\t<?mso-application progid="Excel.Sheet"?> ' +
                            '\n\t<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" ' +
                            '\n\txmlns:o="urn:schemas-microsoft-com:office:office" ' +
                            '\n\txmlns:x="urn:schemas-microsoft-com:office:excel" ' +
                            '\n\txmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" ' +
                            '\n\txmlns:html="http://www.w3.org/TR/REC-html40"> ' +
                            '\n\t<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office"> ' +
                            '\n\t<Version>12.00</Version> ' +
                            '\n\t</DocumentProperties> ' +
                            '\n\t<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel"> ' +
                            '\n\t<WindowHeight>8130</WindowHeight> ' +
                            '\n\t<WindowWidth>15135</WindowWidth> ' +
                            '\n\t<WindowTopX>120</WindowTopX> ' +
                            '\n\t<WindowTopY>45</WindowTopY> ' +
                            '\n\t<ProtectStructure>False</ProtectStructure> ' +
                            '\n\t<ProtectWindows>False</ProtectWindows> ' +
                            '\n\t</ExcelWorkbook> ' +
                        '\n\t<Styles>';
        };

        this.beginHeader = function () {
            content = '\n\t<Worksheet ss:Name="Sheet1">\n\t\t<Table>';
            headerFields = [];
            headerStyles = [];
        };

        this.appendHeaderCell = function (data, fieldName, style) {
            var width = data.width != undefined ? data.width : data.text.length * 10;
            content += '\n\t\t\t<Column ss:Width="' + width + '"/>';
            headerFields.push(data);
            headerStyles.push(style);
        };

        this.endHeader = function (exportHeader) {
            if (exportHeader) {
                this.beginRow();
                for (var i = 0; i < headerFields.length; i += 1) {
                    if (headerStyles[i].disabled) continue;
                    appendCell.call(this, headerFields[i]['text'], null, headerStyles[i]);
                }
                this.endRow();
            }
        };

        this.beginBody = function () {
        };

        this.beginRow = function (level) {
            if (level != undefined) {
                content += '\n\t\t\t';
                for (var i = 0; i < level; i++) {
                    content += '\t';
                }
                content += '<Row>';
                return;
            }

            content += '\n\t\t\t<Row>';
        };

        this.beginRows = function (level) {
            content += '\n\t\t\t\t<Rows>';
        };

        this.appendBodyCell = function (data, dataType, style, row) {
            appendCell.call(this, data, dataType, style, row);
        };

        this.endRow = function (level) {
            if (level != undefined) {
                content += '\n\t\t\t';
                for (var i = 0; i < level; i++) {
                    content += '\t';
                }
                content += '</Row>';
                return;
            }

            content += '\n\t\t\t</Row>';
        };

        this.endRows = function (level) {
            if (level != undefined) {
                content += '\n\t\t\t';
                for (var i = 0; i < level; i++) {
                    content += '\t';
                }
                content += '</Rows>';
                return;
            }
        };

        this.endBody = function () {
            content += '\n\t\t</Table>';
        };

        this.endFile = function () {
            content += '\n\t</Worksheet>\n</Workbook>';
            header += '\n\t</Styles>';
        };

        this.getFile = function () {
            return header + content;
        };

        function appendCell(data, dataOptions, style, row) {
            var columnType = "String";

            var format = this.getFormat(dataOptions);

            if (data != null && data.toString().substring(0, 3) == "_AG") {
                data = data.toString().substring(3);
                columnType = "String";
            }
            else {
                if (format.type == 'date') {
                    var date = data;
                    data = this.formatData(data, format.type, format.formatString, format.localization);
                    if (data === null || data === "") {
                        data = "";
                        columnType = "String";
                    }
                    else {
                        data = date.toISOString();
                        columnType = "DateTime";
                    }
                }
                if (format.type == 'string') {
                    if (data === null || data === undefined) {
                        data = "";
                    }
                    else {
                        if (data.toString().indexOf('&') >= 0) {
                            data = data.toString().replace(/&/g, '&amp;');
                        }
                        if (data.toString().indexOf('>') >= 0) {
                            data = data.toString().replace(/>/g, '&gt;');
                        }
                        if (data.toString().indexOf('<') >= 0) {
                            data = data.toString().replace(/</g, '&lt;');
                        }
                        if (data.toString().indexOf('"') >= 0) {
                            data = data.toString().replace(/"/g, '&quot;');
                        }
                        if (data.toString().indexOf("'") >= 0) {
                            data = data.toString().replace(/'/g, '&apos;');
                        }
                    }
                }

                if (style.dataType == 'number' || style.dataType == 'float' || style.dataType == 'int' || style.dataType == 'integer') {
                    columnType = "Number";
                    data = parseFloat(data);
                    if (data === null || isNaN(data) || data === "") {
                        data = "";
                        columnType = "String";
                    }
                    if (data && columnType != "String" && data != "") {
                        if (dataOptions && dataOptions.formatString && dataOptions.formatString.indexOf('p') >= 0) {
                            data = data / 100;
                        }
                    }

                    style.currencysymbol = dataOptions.localization.currencysymbol;
                }
            }

            var styleId = getStyleId(style);
            if (style.merge) {
                content += '\n\t\t\t\t<Cell ss:MergeAcross="' + style.merge + '" ss:StyleID="' + styleId + '"><Data ss:Type="' + columnType + '">' + data + '</Data></Cell>';
            }
            else {
                content += '\n\t\t\t\t<Cell ss:StyleID="' + styleId + '"><Data ss:Type="' + columnType + '">' + data + '</Data></Cell>';
            }
        }

        function generateStyleId() {
            styleCounter += 1;
            return 'xls-style-' + styleCounter;
        }

        function findStyle(style) {
            for (var s in existingStyles) {
                if (isSubset(style, existingStyles[s]) && isSubset(existingStyles[s], style)) {
                    return s;
                }
            }
            return undefined;
        }

        function isSubset(first, second) {
            var subset = true;
            for (var p in first) {
                if (first[p] !== second[p]) {
                    subset = false;
                }
            }
            return subset;
        }

        function appendStyle(id, style) {
            styleBuilder.startStyle(id);
            styleBuilder.buildAlignment(style);
            styleBuilder.buildBorder(style);
            styleBuilder.buildFont(style);
            styleBuilder.buildInterior(style);
            styleBuilder.buildFormat(style);
            styleBuilder.closeStyle();
            header += styleBuilder.toString();
        }

        function getStyleId(style) {
            if (!style) {
                return '';
            }
            var id = findStyle(style);
            if (typeof id === 'undefined') {
                id = generateStyleId();
                existingStyles[id] = style;
                appendStyle(id, style);
            }
            return id;
        }
    }

    ExcelExporter.prototype = new $.jqx.dataAdapter.DataExportModuleBase();
    $.jqx.dataAdapter.ArrayExporter.extend('xls', new ExcelExporter());
})(jqxBaseFramework);

//Exporting to XML
(function ($) {

    var XmlExporter = function () {

        var file, headerFields, index;

        this.beginFile = function () {
            file = '<?xml version="1.0" encoding="UTF-8" ?>';
            file += '\n<table>';
        }

        this.beginHeader = function () {
            headerFields = [];
        }

        this.appendHeaderCell = function (data, fieldName) {
            headerFields.push(fieldName);
        }

        this.endHeader = function () {
        }

        this.beginBody = function (data, dataType) {
        }

        this.beginRow = function (level) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            if (level != undefined) {
                if (that.hierarchy) {
                    file += '\n\t';
                    for (var i = 0; i < level; i++) {
                        file += '\t\t';
                    }
                    file += '<row>';
                    index = 0;
                    return;
                }
            }

            file += '\n\t<row>';
            index = 0;
        }

        this.beginRows = function (level) {
            if (level != undefined) {
                file += '\n\t\t';
                for (var i = 0; i < level; i++) {
                    file += '\t\t';
                }
                file += '<rows>';
                index = 0;
                return;
            }
            file += '\n\t\t<rows>';
        }

        this.appendBodyCell = function (data, dataOptions, style, row, indx, group) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            var format = this.getFormat(dataOptions);
            data = this.formatData(data, format.type, format.formatString, format.localization);
            if (format.type == "string") {
                if (data.toString().indexOf('&') >= 0) {
                    data = data.toString().replace(/&/g, '&amp;');
                }
                if (data.toString().indexOf('>') >= 0) {
                    data = data.toString().replace(/>/g, '&gt;');
                }
                if (data.toString().indexOf('<') >= 0) {
                    data = data.toString().replace(/</g, '&lt;');
                }
                if (data.toString().indexOf('"') >= 0) {
                    data = data.toString().replace(/"/g, '&quot;');
                }
                if (data.toString().indexOf("'") >= 0) {
                    data = data.toString().replace(/'/g, '&apos;');
                }
            }
            if (row.level != undefined) {
                if (that.hierarchy) {
                    file += '\n\t\t';
                    for (var i = 0; i < row.level; i++) {
                        file += '\t\t';
                    }
                    if (group === undefined) {
                        file += '<' + headerFields[index] + '>' + data + '</' + headerFields[index] + '>';
                    }
                    else {
                        file += '<' + group + '>' + data + '</' + group + '>';
                    }
                }
                else {
                    if (group != undefined) {
                        file += '\n\t\t<' + group + '>' + data + '</' + group + '>';
                    }
                    else {
                        file += '\n\t\t<' + headerFields[index] + '>' + data + '</' + headerFields[index] + '>';
                    }
                }
            }
            else {
                file += '\n\t\t<' + headerFields[index] + '>' + data + '</' + headerFields[index] + '>';
            }
            index++;
        }

        this.endRow = function (level) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            if (level != undefined) {
                if (that.hierarchy) {
                    file += '\n\t';
                    for (var i = 0; i < level; i++) {
                        file += '\t\t';
                    }

                    file += '</row>';
                    index = 0;
                    return;
                }
            }
            file += '\n\t</row>';
            index = 0;
        }

        this.endRows = function (level) {
            if (level != undefined) {
                file += '\n\t\t';
                for (var i = 0; i < level; i++) {
                    file += '\t\t';
                }
                file += '</rows>';
                index = 0;
                return;
            }
            file += '\n\t\t</rows>';
        }

        this.endBody = function () {
        }

        this.endFile = function () {
            file += '\n</table>';
        }

        this.getFile = function () {
            return file;
        }
    }

    XmlExporter.prototype = new $.jqx.dataAdapter.DataExportModuleBase();
    $.jqx.dataAdapter.ArrayExporter.extend('xml', new XmlExporter());
})(jqxBaseFramework);


//Exporting to JSON
(function ($) {

    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        meta = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"': '\\"',
            '\\': '\\\\'
        };

    function quote(string) {
        return '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"';
    }

    function formatNumber(n) {
        return n < 10 ? '0' + n : n;
    }

    function stringifyDate(value) {
        var date;
        if (isFinite(value.valueOf())) {
            date = value.getUTCFullYear() + '-' + formatNumber(value.getUTCMonth() + 1) + '-' +
            formatNumber(value.getUTCDate()) + 'T' + formatNumber(value.getUTCHours()) + ':' +
            formatNumber(value.getUTCMinutes()) + ':' + formatNumber(value.getUTCSeconds()) + 'Z"';
        } else {
            date = 'null';
        }
        return date;
    }

    function stringifyArray(value) {
        var len = value.length,
            partial = [],
            i;
        for (i = 0; i < len; i++) {
            partial.push(str(i, value) || 'null');
        }

        return '[' + partial.join(',') + ']';
    }

    function stringifyObject(value) {
        var partial = [],
            i, v;
        for (i in value) {
            if (Object.prototype.hasOwnProperty.call(value, i)) {
                v = str(i, value);
                if (v) {
                    partial.push(quote(i) + ':' + v);
                }
            }
        }
        return '{' + partial.join(',') + '}';
    }

    function stringifyReference(value) {
        switch (Object.prototype.toString.call(value)) {
            case '[object Date]':
                return stringifyDate(value);
            case '[object Array]':
                return stringifyArray(value);
        }
        return stringifyObject(value);
    }

    function stringifyPrimitive(value, type) {
        switch (type) {
            case 'string':
                return quote(value);
            case 'number':
            case 'float':
            case 'integer':
            case 'int':
                return isFinite(value) ? value : 'null';
            case 'boolean':
                return value;
        }
        return 'null';
    }

    function str(key, holder) {
        var value = holder[key], type = typeof value;

        if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
            type = typeof value;
        }
        if (/(number|float|int|integer|string|boolean)/.test(type) || (!value && type === 'object')) {
            return stringifyPrimitive(value, type);
        } else {
            return stringifyReference(value);
        }
    }

    function stringify(value) {
        if (window.JSON && typeof window.JSON.stringify === 'function') {
            return window.JSON.stringify(value);
        }

        return str("", { "": value });
    }

    var JsonExporter = function () {
        var me = this;
        this.prepareData = function (data, dataOptions) {
            if (dataOptions) {
                var format = me.getFormat(dataOptions);
                data = me.formatData(data, format.type, format.formatString, format.localization);
            }
            return data;
        }

        var file,
            content,
            currentCell,
            cellHierarchy = [],
            level = 0
        ;

        this.beginFile = function () {
            content = [];
        }

        this.beginHeader = function () {
        }

        this.appendHeaderCell = function (data) {
        }

        this.endHeader = function () {
        }

        this.beginBody = function (data, dataType) {
        }

        this.beginRow = function () {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            if (that.hierarchy || window.jqx.hierarchy) {
                cellHierarchy[level] = {};
            }
            else {
                currentCell = {};
            }
        }

        this.beginRows = function () {
            cellHierarchy[level].rows = [];
            level++;
            cellHierarchy[level] = {};
        }
        this.endRows = function () {
            level--;
        }

        this.appendBodyCell = function (data, dataType) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }


            var text = this.prepareData(data, dataType);
            if (that.hierarchy || window.jqx.hierarchy) {
                cellHierarchy[level][dataType['text']] = text;
            }
            else {
                currentCell[dataType['text']] = text;
            }
        }

        this.endRow = function () {
            var that = this;

            if (!that) {
                that = window.jqx;
            }


            if (that.hierarchy || window.jqx.hierarchy) {
                if (level == 0) {
                    content.push(cellHierarchy[level]);
                }
                else {
                    cellHierarchy[level - 1].rows.push(cellHierarchy[level]);
                }
            }
            else {
                content.push(currentCell);
            }
        }

        this.endBody = function () {
        }

        this.endFile = function () {
            file = stringify(content);
        }

        this.getFile = function () {
            return file;
        }
    }

    JsonExporter.prototype = new $.jqx.dataAdapter.DataExportModuleBase();
    $.jqx.dataAdapter.ArrayExporter.extend('json', new JsonExporter());

})(jqxBaseFramework);


var pdfDataExport = window.jqxPdfDataExport = (function () {
    'use strict';
    if (typeof btoa === 'undefined') {
        window.btoa = function (data) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                b64a = b64.split(''),
                o1,
                o2,
                o3,
                h1,
                h2,
                h3,
                h4,
                bits,
                i = 0,
                ac = 0,
                enc = "",
                tmp_arr = [],
                r;

            do {
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                tmp_arr[ac++] = b64a[h1] + b64a[h2] + b64a[h3] + b64a[h4];
            } while (i < data.length);

            enc = tmp_arr.join('');
            r = data.length % 3;
            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
        };
    }

    if (typeof atob === 'undefined') {
        window.atob = function (data) {

            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                o1,
                o2,
                o3,
                h1,
                h2,
                h3,
                h4,
                bits,
                i = 0,
                ac = 0,
                dec = "",
                tmp_arr = [];

            if (!data) {
                return data;
            }

            data += '';

            do { // unpack four hexets into three octets using index points in b64
                h1 = b64.indexOf(data.charAt(i++));
                h2 = b64.indexOf(data.charAt(i++));
                h3 = b64.indexOf(data.charAt(i++));
                h4 = b64.indexOf(data.charAt(i++));

                bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

                o1 = bits >> 16 & 0xff;
                o2 = bits >> 8 & 0xff;
                o3 = bits & 0xff;

                if (h3 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1);
                } else if (h4 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2);
                } else {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
                }
            } while (i < data.length);
            dec = tmp_arr.join('');
            return dec;
        };
    }

    var getObjectLength = typeof Object.keys === 'function' ?
                function (object) {
                    return Object.keys(object).length;
                } :
                function (object) {
                    var i = 0, e;
                    for (e in object) {
                        if (object.hasOwnProperty(e)) {
                            i++;
                        }
                    }
                    return i;
                },

/**
PubSub implementation

@class
@name PubSub
*/
        PubSub = function (context) {
            /*
            @private
            @fieldOf PubSub
            */
            this.topics = {};
            /**
            Stores what will be `this` within the callback functions.

            @private
            @fieldOf PubSub#
            */
            this.context = context;
            /**
            Allows caller to emit an event and pass arguments to event listeners.
            @public
            @function
            @param topic {String} Name of the channel on which to voice this event
            @param args Any number of arguments you want to pass to the listeners of this event.
            @methodOf PubSub#
            @name publish
            */
            this.publish = function (topic, args) {
                if (this.topics[topic]) {
                    var currentTopic = this.topics[topic],
                        toremove = [],
                        fn,
                        i,
                        l,
                        pair,
                        emptyFunc = function () { };
                    args = Array.prototype.slice.call(arguments, 1);
                    for (i = 0, l = currentTopic.length; i < l; i++) {
                        pair = currentTopic[i]; // this is a [function, once_flag] array
                        fn = pair[0];
                        if (pair[1]) { /* 'run once' flag set */
                            pair[0] = emptyFunc;
                            toremove.push(i);
                        }
                        fn.apply(this.context, args);
                    }
                    for (i = 0, l = toremove.length; i < l; i++) {
                        currentTopic.splice(toremove[i], 1);
                    }
                }
            };
            /**
            Allows listener code to subscribe to channel and be called when data is available
            @public
            @function
            @param topic {String} Name of the channel on which to voice this event
            @param callback {Function} Executable (function pointer) that will be ran when event is voiced on this channel.
            @param once {Boolean} (optional. False by default) Flag indicating if the function is to be triggered only once.
            @returns {Object} A token object that cen be used for unsubscribing.
            @methodOf PubSub#
            @name subscribe
            */
            this.subscribe = function (topic, callback, once) {
                if (!this.topics[topic]) {
                    this.topics[topic] = [[callback, once]];
                } else {
                    this.topics[topic].push([callback, once]);
                }
                return {
                    "topic": topic,
                    "callback": callback
                };
            };
            /**
            Allows listener code to unsubscribe from a channel
            @public
            @function
            @param token {Object} A token object that was returned by `subscribe` method
            @methodOf PubSub#
            @name unsubscribe
            */
            this.unsubscribe = function (token) {
                if (this.topics[token.topic]) {
                    var currentTopic = this.topics[token.topic], i, l;

                    for (i = 0, l = currentTopic.length; i < l; i++) {
                        if (currentTopic[i][0] === token.callback) {
                            currentTopic.splice(i, 1);
                        }
                    }
                }
            };
        };


    /**
    @constructor
    @private
    */
    function pdfDataExport(orientation, unit, format, compressPdf) { /** String orientation, String unit, String format, Boolean compressed */

        // Default parameter values
        if (typeof orientation === 'undefined') {
            orientation = 'p';
        } else {
            orientation = orientation.toString().toLowerCase();
        }
        if (typeof unit === 'undefined') { unit = 'mm'; }
        if (typeof format === 'undefined') { format = 'a4'; }
        if (typeof compressPdf === 'undefined' && typeof zpipe === 'undefined') { compressPdf = false; }

        var format_as_string = format.toString().toLowerCase(),
            version = '0.9.0rc2',
            content = [],
            content_length = 0,
            compress = compressPdf,
            pdfVersion = '1.3', // PDF Version
            pageFormats = { // Size in pt of various paper formats
                'a3': [841.89, 1190.55],
                'a4': [595.28, 841.89],
                'a5': [420.94, 595.28],
                'letter': [612, 792],
                'legal': [612, 1008]
            },
            textColor = '0 g',
            drawColor = '0 G',
            page = 0,
            pages = [],
            objectNumber = 2, // 'n' Current object number
            outToPages = false, // switches where out() prints. outToPages true = push to pages obj. outToPages false = doc builder content
            offsets = [], // List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.
            fonts = {}, // collection of font objects, where key is fontKey - a dynamically created label for a given font.
            fontmap = {}, // mapping structure fontName > fontStyle > font key - performance layer. See addFont()
            activeFontSize = 16,
            activeFontKey, // will be string representing the KEY of the font as combination of fontName + fontStyle
            lineWidth = 0.200025, // 2mm
            pageHeight,
            pageWidth,
            k, // Scale factor
            documentProperties = { 'title': '', 'subject': '', 'author': '', 'keywords': '', 'creator': '' },
            lineCapID = 0,
            lineJoinID = 0,
            API = {},
            events = new PubSub(API),
            tmp,
            plugin,
            /////////////////////
            // Private functions
            /////////////////////
            // simplified (speedier) replacement for sprintf's %.2f conversion
            f2 = function (number) {
                return number.toFixed(2);
            },
            // simplified (speedier) replacement for sprintf's %.3f conversion
            f3 = function (number) {
                return number.toFixed(3);
            },
            // simplified (speedier) replacement for sprintf's %02d
            padd2 = function (number) {
                var n = (number).toFixed(0);
                if (number < 10) {
                    return '0' + n;
                } else {
                    return n;
                }
            },
            // simplified (speedier) replacement for sprintf's %02d
            padd10 = function (number) {
                var n = (number).toFixed(0);
                if (n.length < 10) {
                    return new Array(11 - n.length).join('0') + n;
                } else {
                    return n;
                }
            },
            out = function (string) {
                if (outToPages) { /* set by beginPage */
                    pages[page].push(string);
                } else {
                    content.push(string);
                    content_length += string.length + 1; // +1 is for '\n' that will be used to join contents of content
                }
            },
            newObject = function () {
                // Begin a new object
                objectNumber++;
                offsets[objectNumber] = content_length;
                out(objectNumber + ' 0 obj');
                return objectNumber;
            },
            putStream = function (str) {
                out('stream');
                out(str);
                out('endstream');
            },
            wPt,
            hPt,
            kids,
            i,
            putPages = function () {
                wPt = pageWidth * k;
                hPt = pageHeight * k;

                // outToPages = false as set in endDocument(). out() writes to content.

                var n, p, arr, uint, i, deflater, adler32;
                for (n = 1; n <= page; n++) {
                    newObject();
                    out('<</Type /Page');
                    out('/Parent 1 0 R');
                    out('/Resources 2 0 R');
                    out('/Contents ' + (objectNumber + 1) + ' 0 R>>');
                    out('endobj');

                    // Page content
                    p = pages[n].join('\n');
                    newObject();
                    if (compress) {
                        arr = [];
                        for (i = 0; i < p.length; ++i) {
                            arr[i] = p.charCodeAt(i);
                        }
                        adler32 = adler32cs.from(p);
                        deflater = new Deflater(6);
                        deflater.append(new Uint8Array(arr));
                        p = deflater.flush();
                        arr = [new Uint8Array([120, 156]), new Uint8Array(p),
                               new Uint8Array([adler32 & 0xFF, (adler32 >> 8) & 0xFF, (adler32 >> 16) & 0xFF, (adler32 >> 24) & 0xFF])];
                        p = '';
                        for (i in arr) {
                            if (arr.hasOwnProperty(i)) {
                                p += String.fromCharCode.apply(null, arr[i]);
                            }
                        }
                        out('<</Length ' + p.length + ' /Filter [/FlateDecode]>>');
                    } else {
                        out('<</Length ' + p.length + '>>');
                    }
                    putStream(p);
                    out('endobj');
                }
                offsets[1] = content_length;
                out('1 0 obj');
                out('<</Type /Pages');
                kids = '/Kids [';
                for (i = 0; i < page; i++) {
                    kids += (3 + 2 * i) + ' 0 R ';
                }
                out(kids + ']');
                out('/Count ' + page);
                out('/MediaBox [0 0 ' + f2(wPt) + ' ' + f2(hPt) + ']');
                out('>>');
                out('endobj');
            },
            putFont = function (font) {
                font.objectNumber = newObject();
                out('<</BaseFont/' + font.PostScriptName + '/Type/Font');
                if (typeof font.encoding === 'string') {
                    out('/Encoding/' + font.encoding);
                }
                out('/Subtype/Type1>>');
                out('endobj');
            },
            putFonts = function () {
                var fontKey;
                for (fontKey in fonts) {
                    if (fonts.hasOwnProperty(fontKey)) {
                        putFont(fonts[fontKey]);
                    }
                }
            },
            putXobjectDict = function () {
                // Loop through images, or other data objects
                events.publish('putXobjectDict');
            },
            putResourceDictionary = function () {
                out('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');
                out('/Font <<');
                // Do this for each font, the '1' bit is the index of the font
                var fontKey;
                for (fontKey in fonts) {
                    if (fonts.hasOwnProperty(fontKey)) {
                        out('/' + fontKey + ' ' + fonts[fontKey].objectNumber + ' 0 R');
                    }
                }
                out('>>');
                out('/XObject <<');
                putXobjectDict();
                out('>>');
            },
            putResources = function () {
                putFonts();
                events.publish('putResources');
                // Resource dictionary
                offsets[2] = content_length;
                out('2 0 obj');
                out('<<');
                putResourceDictionary();
                out('>>');
                out('endobj');
                events.publish('postPutResources');
            },
            addToFontDictionary = function (fontKey, fontName, fontStyle) {
                // this is mapping structure for quick font key lookup.
                // returns the KEY of the font (ex: "F1") for a given pair of font name and type (ex: "Arial". "Italic")
                var undef;
                if (fontmap[fontName] === undef) {
                    fontmap[fontName] = {}; // fontStyle is a var interpreted and converted to appropriate string. don't wrap in quotes.
                }
                fontmap[fontName][fontStyle] = fontKey;
            },
            /**
            FontObject describes a particular font as member of an instnace of pdfDataExport

            It's a collection of properties like 'id' (to be used in PDF stream),
            'fontName' (font's family name), 'fontStyle' (font's style variant label)

            @class
            @public
            @property id {String} PDF-document-instance-specific label assinged to the font.
            @property PostScriptName {String} PDF specification full name for the font
            @property encoding {Object} Encoding_name-to-Font_metrics_object mapping.
            @name FontObject
            */
            FontObject = {},
            addFont = function (PostScriptName, fontName, fontStyle, encoding) {
                var fontKey = 'F' + (getObjectLength(fonts) + 1).toString(10),
                    // This is FontObject
                    font = fonts[fontKey] = {
                        'id': fontKey,
                        // , 'objectNumber':   will be set by putFont()
                        'PostScriptName': PostScriptName,
                        'fontName': fontName,
                        'fontStyle': fontStyle,
                        'encoding': encoding,
                        'metadata': {}
                    };

                addToFontDictionary(fontKey, fontName, fontStyle);

                events.publish('addFont', font);

                return fontKey;
            },
            addFonts = function () {

                var HELVETICA = "helvetica",
                    TIMES = "times",
                    COURIER = "courier",
                    NORMAL = "normal",
                    BOLD = "bold",
                    ITALIC = "italic",
                    BOLD_ITALIC = "bolditalic",
                    encoding = 'StandardEncoding',
                    standardFonts = [
                        ['Helvetica', HELVETICA, NORMAL],
                        ['Helvetica-Bold', HELVETICA, BOLD],
                        ['Helvetica-Oblique', HELVETICA, ITALIC],
                        ['Helvetica-BoldOblique', HELVETICA, BOLD_ITALIC],
                        ['Courier', COURIER, NORMAL],
                        ['Courier-Bold', COURIER, BOLD],
                        ['Courier-Oblique', COURIER, ITALIC],
                        ['Courier-BoldOblique', COURIER, BOLD_ITALIC],
                        ['Times-Roman', TIMES, NORMAL],
                        ['Times-Bold', TIMES, BOLD],
                        ['Times-Italic', TIMES, ITALIC],
                        ['Times-BoldItalic', TIMES, BOLD_ITALIC]
                    ],
                    i,
                    l,
                    fontKey,
                    parts;
                for (i = 0, l = standardFonts.length; i < l; i++) {
                    var en = encoding;

                    fontKey = addFont(
                        standardFonts[i][0],
                        standardFonts[i][1],
                        standardFonts[i][2],
                        en
                    );

                    // adding aliases for standard fonts, this time matching the capitalization
                    parts = standardFonts[i][0].split('-');
                    addToFontDictionary(fontKey, parts[0], parts[1] || '');
                }

                events.publish('addFonts', { 'fonts': fonts, 'dictionary': fontmap });
            },
            /**

            @public
            @function
            @param text {String}
            @param flags {Object} Encoding flags.
            @returns {String} Encoded string
            */
            to8bitStream = function (text, flags) {

                var i, l, undef, sourceEncoding, encodingBlock, outputEncoding, newtext, isUnicode, ch, bch;

                if (flags === undef) {
                    flags = {};
                }

                sourceEncoding = flags.sourceEncoding ? sourceEncoding : 'Unicode';

                outputEncoding = flags.outputEncoding;

                // This 'encoding' section relies on font metrics format
                // attached to font objects by, among others,
                // "Willow Systems' standard_font_metrics plugin"
                // see pdfDataExport.plugin.standard_font_metrics.js for format
                // of the font.metadata.encoding Object.
                // It should be something like
                //   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}
                //   .widths = {0:width, code:width, ..., 'fof':divisor}
                //   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}
                if ((flags.autoencode || outputEncoding) &&
                        fonts[activeFontKey].metadata &&
                        fonts[activeFontKey].metadata[sourceEncoding] &&
                        fonts[activeFontKey].metadata[sourceEncoding].encoding
                        ) {
                    encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;

                    // each font has default encoding. Some have it clearly defined.
                    if (!outputEncoding && fonts[activeFontKey].encoding) {
                        outputEncoding = fonts[activeFontKey].encoding;
                    }

                    // Hmmm, the above did not work? var's try again, in different place.
                    if (!outputEncoding && encodingBlock.codePages) {
                        outputEncoding = encodingBlock.codePages[0]; // var's say, first one is the default
                    }

                    if (typeof outputEncoding === 'string') {
                        outputEncoding = encodingBlock[outputEncoding];
                    }
                    // we want output encoding to be a JS Object, where
                    // key = sourceEncoding's character code and
                    // value = outputEncoding's character code.
                    if (outputEncoding) {
                        isUnicode = false;
                        newtext = [];
                        for (i = 0, l = text.length; i < l; i++) {
                            ch = outputEncoding[text.charCodeAt(i)];
                            if (ch) {
                                newtext.push(
                                    String.fromCharCode(ch)
                                );
                            } else {
                                newtext.push(
                                    text[i]
                                );
                            }

                            // since we are looping over chars anyway, might as well
                            // check for residual unicodeness
                            if (newtext[i].charCodeAt(0) >> 8) { /* more than 255 */
                                isUnicode = true;
                            }
                        }
                        text = newtext.join('');
                    }
                }

                i = text.length;
                // isUnicode may be set to false above. Hence the triple-equal to undefined
                while (isUnicode === undef && i !== 0) {
                    if (text.charCodeAt(i - 1) >> 8) { /* more than 255 */
                        isUnicode = true;
                    }
                    i--;
                }
                if (!isUnicode) {
                    return text;
                } else {
                    newtext = flags.noBOM ? [] : [254, 255];
                    for (i = 0, l = text.length; i < l; i++) {
                        ch = text.charCodeAt(i);
                        bch = ch >> 8; // divide by 256
                        if (bch >> 8) { /* something left after dividing by 256 second time */
                            throw new Error("Character at position " + i.toString(10) + " of string '" + text + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
                        }
                        newtext.push(bch);
                        newtext.push(ch - (bch << 8));
                    }
                    return String.fromCharCode.apply(undef, newtext);
                }
            },
            // Replace '/', '(', and ')' with pdf-safe versions
            pdfEscape = function (text, flags) {
                // doing to8bitStream does NOT make this PDF display unicode text. For that
                // we also need to reference a unicode font and embed it - royal pain in the rear.

                // There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,
                // which JavaScript Strings are happy to provide. So, while we still cannot display
                // 2-byte characters property, at least CONDITIONALLY converting (entire string containing)
                // 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF
                // is still parseable.
                // This will allow immediate support for unicode in document properties strings.
                return to8bitStream(text, flags).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
            },
            putInfo = function () {
                out('/Producer (pdfDataExport ' + version + ')');
                if (documentProperties.title) {
                    out('/Title (' + pdfEscape(documentProperties.title) + ')');
                }
                if (documentProperties.subject) {
                    out('/Subject (' + pdfEscape(documentProperties.subject) + ')');
                }
                if (documentProperties.author) {
                    out('/Author (' + pdfEscape(documentProperties.author) + ')');
                }
                if (documentProperties.keywords) {
                    out('/Keywords (' + pdfEscape(documentProperties.keywords) + ')');
                }
                if (documentProperties.creator) {
                    out('/Creator (' + pdfEscape(documentProperties.creator) + ')');
                }
                var created = new Date();
                out('/CreationDate (D:' +
                    [
                        created.getFullYear(),
                        padd2(created.getMonth() + 1),
                        padd2(created.getDate()),
                        padd2(created.getHours()),
                        padd2(created.getMinutes()),
                        padd2(created.getSeconds())
                    ].join('') +
                    ')'
                    );
            },
            putCatalog = function () {
                out('/Type /Catalog');
                out('/Pages 1 0 R');
                // @TODO: Add zoom and layout modes
                out('/OpenAction [3 0 R /FitH null]');
                out('/PageLayout /OneColumn');
                events.publish('putCatalog');
            },
            putTrailer = function () {
                out('/Size ' + (objectNumber + 1));
                out('/Root ' + objectNumber + ' 0 R');
                out('/Info ' + (objectNumber - 1) + ' 0 R');
            },
            beginPage = function () {
                page++;
                // Do dimension stuff
                outToPages = true;
                pages[page] = [];
            },
            _addPage = function () {
                beginPage();
                // Set line width
                out(f2(lineWidth * k) + ' w');
                // Set draw color
                out(drawColor);
                // resurrecting non-default line caps, joins
                if (lineCapID !== 0) {
                    out(lineCapID.toString(10) + ' J');
                }
                if (lineJoinID !== 0) {
                    out(lineJoinID.toString(10) + ' j');
                }
                events.publish('addPage', { 'pageNumber': page });
            },
            /**
            Returns a document-specific font key - a label assigned to a
            font name + font type combination at the time the font was added
            to the font inventory.

            Font key is used as label for the desired font for a block of text
            to be added to the PDF document stream.
            @private
            @function
            @param fontName {String} can be undefined on "falthy" to indicate "use current"
            @param fontStyle {String} can be undefined on "falthy" to indicate "use current"
            @returns {String} Font key.
            */
            getFont = function (fontName, fontStyle) {
                var key, undef;

                if (fontName === undef) {
                    fontName = fonts[activeFontKey].fontName;
                }
                if (fontStyle === undef) {
                    fontStyle = fonts[activeFontKey].fontStyle;
                }

                try {
                    key = fontmap[fontName][fontStyle]; // returns a string like 'F3' - the KEY corresponding tot he font + type combination.
                } catch (e) {
                    key = undef;
                }
                if (!key) {
                    throw new Error("Unable to look up font label for font '" + fontName + "', '" + fontStyle + "'. Refer to getFontList() for available fonts.");
                }

                return key;
            },
            buildDocument = function () {

                outToPages = false; // switches out() to content
                content = [];
                offsets = [];

                // putHeader()
                out('%PDF-' + pdfVersion);

                putPages();

                putResources();

                // Info
                newObject();
                out('<<');
                putInfo();
                out('>>');
                out('endobj');

                // Catalog
                newObject();
                out('<<');
                putCatalog();
                out('>>');
                out('endobj');

                // Cross-ref
                var o = content_length, i;
                out('xref');
                out('0 ' + (objectNumber + 1));
                out('0000000000 65535 f ');
                for (i = 1; i <= objectNumber; i++) {
                    out(padd10(offsets[i]) + ' 00000 n ');
                }
                // Trailer
                out('trailer');
                out('<<');
                putTrailer();
                out('>>');
                out('startxref');
                out(o);
                out('%%EOF');

                outToPages = true;

                return content.join('\n');
            },
            getStyle = function (style) {
                // see Path-Painting Operators of PDF spec
                var op = 'S'; // stroke
                if (style === 'F') {
                    op = 'f'; // fill
                } else if (style === 'FD' || style === 'DF') {
                    op = 'B'; // both
                }
                return op;
            },

            /**
            Generates the PDF document.
            Possible values:
                datauristring (alias dataurlstring) - Data-Url-formatted data returned as string.
                datauri (alias datauri) - Data-Url-formatted data pushed into current window's location (effectively reloading the window with contents of the PDF).

            If `type` argument is undefined, output is raw body of resulting PDF returned as a string.

            @param {String} type A string identifying one of the possible output types.
            @param {Object} options An object providing some additional signalling to PDF generator.
            @function
            @returns {pdfDataExport}
            @methodOf pdfDataExport#
            @name output
            */
            output = function (type, options) {
                var undef, data, length, array, i, blob;
                switch (type) {
                    case undef:
                        return buildDocument();
                    case 'save':
                        if (navigator.getUserMedia) {
                            if (window.URL === undefined) {
                                return API.output('dataurlnewwindow');
                            } else if (window.URL.createObjectURL === undefined) {
                                return API.output('dataurlnewwindow');
                            }
                        }
                        data = buildDocument();

                        // Need to add the file to BlobBuilder as a Uint8Array
                        length = data.length;
                        array = new Uint8Array(new ArrayBuffer(length));

                        for (i = 0; i < length; i++) {
                            array[i] = data.charCodeAt(i);
                        }

                        blob = new Blob([array], { type: "application/pdf" });

                        saveAs(blob, options);
                        break;
                    case 'datauristring':
                    case 'dataurlstring':
                        return 'data:application/pdf;base64,' + btoa(buildDocument());
                    case 'datauri':
                    case 'dataurl':
                        document.location.href = 'data:application/pdf;base64,' + btoa(buildDocument());
                        break;
                    case 'dataurlnewwindow':
                        window.open('data:application/pdf;base64,' + btoa(buildDocument()));
                        break;
                    default:
                        throw new Error('Output type "' + type + '" is not supported.');
                }
                // @TODO: Add different output options
            };

        if (unit === 'pt') {
            k = 1;
        } else if (unit === 'mm') {
            k = 72 / 25.4;
        } else if (unit === 'cm') {
            k = 72 / 2.54;
        } else if (unit === 'in') {
            k = 72;
        } else {
            throw ('Invalid unit: ' + unit);
        }

        // Dimensions are stored as user units and converted to points on output
        if (pageFormats.hasOwnProperty(format_as_string)) {
            pageHeight = pageFormats[format_as_string][1] / k;
            pageWidth = pageFormats[format_as_string][0] / k;
        } else {
            try {
                pageHeight = format[1];
                pageWidth = format[0];
            } catch (err) {
                throw ('Invalid format: ' + format);
            }
        }

        if (orientation === 'p' || orientation === 'portrait') {
            orientation = 'p';
            if (pageWidth > pageHeight) {
                tmp = pageWidth;
                pageWidth = pageHeight;
                pageHeight = tmp;
            }
        } else if (orientation === 'l' || orientation === 'landscape') {
            orientation = 'l';
            if (pageHeight > pageWidth) {
                tmp = pageWidth;
                pageWidth = pageHeight;
                pageHeight = tmp;
            }
        } else {
            throw ('Invalid orientation: ' + orientation);
        }



        //---------------------------------------
        // Public API

        /*
        Object exposing internal API to plugins
        @public
        */
        API.internal = {
            'pdfEscape': pdfEscape,
            'getStyle': getStyle,
            /**
            Returns {FontObject} describing a particular font.
            @public
            @function
            @param fontName {String} (Optional) Font's family name
            @param fontStyle {String} (Optional) Font's style variation name (Example:"Italic")
            @returns {FontObject}
            */
            'getFont': function () { return fonts[getFont.apply(API, arguments)]; },
            'getFontSize': function () { return activeFontSize; },
            'btoa': btoa,
            'write': function (string1, string2, string3, etc) {
                out(
                    arguments.length === 1 ? string1 : Array.prototype.join.call(arguments, ' ')
                );
            },
            'getCoordinateString': function (value) {
                return f2(value * k);
            },
            'getVerticalCoordinateString': function (value) {
                return f2((pageHeight - value) * k);
            },
            'collections': {},
            'newObject': newObject,
            'putStream': putStream,
            'events': events,
            // ratio that you use in multiplication of a given "size" number to arrive to 'point'
            // units of measurement.
            // scaleFactor is set at initialization of the document and calculated against the stated
            // default measurement units for the document.
            // If default is "mm", k is the number that will turn number in 'mm' into 'points' number.
            // through multiplication.
            'scaleFactor': k,
            'pageSize': { 'width': pageWidth, 'height': pageHeight },
            'output': function (type, options) {
                return output(type, options);
            }
        };

        /**
        Adds (and transfers the focus to) new page to the PDF document.
        @function
        @returns {pdfDataExport}

        @methodOf pdfDataExport#
        @name addPage
         */
        API.addPage = function () {
            _addPage();
            return this;
        };

        var padz =
[
   "",
   "0",
   "00",
   "000",
   "0000"
];
        var pdfEscape16 = function (text, flags) {
            var ar = ["FEFF"];
            for (var i = 0, l = text.length, t; i < l; ++i) {
                t = text.charCodeAt(i).toString(16).toUpperCase();
                ar.push(padz[4 - t.length], t);
            }
            return ar.join("");
        };

        API.text16 = function (text, x, y, flags) {
            /**
            * Inserts something like this into PDF
            BT
            /F1 16 Tf % Font name + size
            16 TL % How many units down for next line in multiline text
            0 g % color
            28.35 813.54 Td % position
            (line one) Tj
            T* (line two) Tj
            T* (line three) Tj
            ET
            */

            var undef, _first, _second, _third, newtext, str, i;
            // Pre-August-2012 the order of arguments was function(x, y, text, flags)
            // in effort to make all calls have similar signature like
            // function(data, coordinates... , miscellaneous)
            // this method had its args flipped.
            // code below allows backward compatibility with old arg order.
            if (typeof text === 'number') {
                _first = y;
                _second = text;
                _third = x;

                text = _first;
                x = _second;
                y = _third;
            }

            // If there are any newlines in text, we assume
            // the user wanted to print multiple lines, so break the
            // text up into an array. If the text is already an array,
            // we assume the user knows what they are doing.
            if (typeof text === 'string' && text.match(/[\n\r]/)) {
                text = text.split(/\r\n|\r|\n/g);
            }

            if (typeof flags === 'undefined') {
                flags = { 'noBOM': true, 'autoencode': true };
            } else {

                if (flags.noBOM === undef) {
                    flags.noBOM = true;
                }

                if (flags.autoencode === undef) {
                    flags.autoencode = true;
                }

            }
            flags.autoencode = false;
            if (typeof text === 'string') {
                str = pdfEscape16(text, flags);
            } else if (text instanceof Array) { /* Array */
                // we don't want to destroy original text array, so cloning it
                newtext = text.concat();
                // we do array.join('text that must not be PDFescaped")
                // thus, pdfEscape each component separately
                for (i = newtext.length - 1; i !== -1; i--) {
                    newtext[i] = pdfEscape16(newtext[i], flags);
                }
                str = newtext.join("> Tj\nT* <");
            } else {
                throw new Error('Type of text must be string or Array. "' + text + '" is not recognized.');
            }
            // Using "'" ("go next line and render text" mark) would save space but would complicate our rendering code, templates

            // BT .. ET does NOT have default settings for Tf. You must state that explicitely every time for BT .. ET
            // if you want text transformation matrix (+ multiline) to work reliably (which reads sizes of things from font declarations)
            // Thus, there is NO useful, *reliable* concept of "default" font for a page.
            // The fact that "default" (reuse font used before) font worked before in basic cases is an accident
            // - readers dealing smartly with brokenness of jsPDF's markup.
            out(
                'BT\n/' +
                    activeFontKey + ' ' + activeFontSize + ' Tf\n' + // font face, style, size
                      activeFontSize + ' TL\n' + // line spacing
                     textColor +
                    '\n' + f2(x * k) + ' ' + f2((pageHeight - y) * k) + ' Td\n<' +
                    str +
                    '> Tj\nET'
            );

            return this;
        };
        /**
        Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.
        @function
        @param {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.
        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Object} flags Collection of settings signalling how the text must be encoded. Defaults are sane. If you think you want to pass some flags, you likely can read the source.
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name text
         */
        API.text = function (text, x, y, flags) {
            /**
             * Inserts something like this into PDF
                BT
                /F1 16 Tf  % Font name + size
                16 TL % How many units down for next line in multiline text
                0 g % color
                28.35 813.54 Td % position
                (line one) Tj
                T* (line two) Tj
                T* (line three) Tj
                ET
            */

            var undef, _first, _second, _third, newtext, str, i;
            if (typeof text === 'number') {
                _first = y;
                _second = text;
                _third = x;

                text = _first;
                x = _second;
                y = _third;
            }

            if (typeof text === 'string' && text.match(/[\n\r]/)) {
                text = text.split(/\r\n|\r|\n/g);
            }

            if (typeof flags === 'undefined') {
                flags = { 'noBOM': true, 'autoencode': true };
            } else {

                if (flags.noBOM === undef) {
                    flags.noBOM = true;
                }

                if (flags.autoencode === undef) {
                    flags.autoencode = true;
                }

            }

            if (typeof text === 'string') {
                str = pdfEscape(text, flags);
            } else if (text instanceof Array) {  /* Array */
                // we don't want to destroy  original text array, so cloning it
                newtext = text.concat();
                // we do array.join('text that must not be PDFescaped")
                // thus, pdfEscape each component separately
                for (i = newtext.length - 1; i !== -1; i--) {
                    newtext[i] = pdfEscape(newtext[i], flags);
                }
                str = newtext.join(") Tj\nT* (");
            } else {
                throw new Error('Type of text must be string or Array. "' + text + '" is not recognized.');
            }
            out(
             'BT\n/' +
                 activeFontKey + ' ' + activeFontSize + ' Tf\n' + // font face, style, size
                 activeFontSize + ' TL\n' + // line spacing
                 textColor +
                 '\n' + f2(x * k) + ' ' + f2((pageHeight - y) * k) + ' Td\n(' +
                 str +
                 ') Tj\nET'
         );
            return this;
        };

        API.line = function (x1, y1, x2, y2) {
            out(
                f2(x1 * k) + ' ' + f2((pageHeight - y1) * k) + ' m ' +
                    f2(x2 * k) + ' ' + f2((pageHeight - y2) * k) + ' l S'
            );
            return this;
        };

        /**
        Adds series of curves (straight lines or cubic bezier curves) to canvas, starting at `x`, `y` coordinates.
        All data points in `lines` are relative to last line origin.
        `x`, `y` become x1,y1 for first line / curve in the set.
        For lines you only need to specify [x2, y2] - (ending point) vector against x1, y1 starting point.
        For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.

        @example .lines([[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 212,110, 10) // line, line, bezier curve, line
        @param {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).
        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name lines
         */
        API.lines = function (lines, x, y, scale, style) {
            var undef, _first, _second, _third, scalex, scaley, i, l, leg, x2, y2, x3, y3, x4, y4;

            // Pre-August-2012 the order of arguments was function(x, y, lines, scale, style)
            // in effort to make all calls have similar signature like
            //   function(content, coordinateX, coordinateY , miscellaneous)
            // this method had its args flipped.
            // code below allows backward compatibility with old arg order.
            if (typeof lines === 'number') {
                _first = y;
                _second = lines;
                _third = x;

                lines = _first;
                x = _second;
                y = _third;
            }

            style = getStyle(style);
            scale = scale === undef ? [1, 1] : scale;

            // starting point
            out(f3(x * k) + ' ' + f3((pageHeight - y) * k) + ' m ');

            scalex = scale[0];
            scaley = scale[1];
            l = lines.length;
            //, x2, y2 // bezier only. In page default measurement "units", *after* scaling
            //, x3, y3 // bezier only. In page default measurement "units", *after* scaling
            // ending point for all, lines and bezier. . In page default measurement "units", *after* scaling
            x4 = x; // last / ending point = starting point for first item.
            y4 = y; // last / ending point = starting point for first item.

            for (i = 0; i < l; i++) {
                leg = lines[i];
                if (leg.length === 2) {
                    // simple line
                    x4 = leg[0] * scalex + x4; // here last x4 was prior ending point
                    y4 = leg[1] * scaley + y4; // here last y4 was prior ending point
                    out(f3(x4 * k) + ' ' + f3((pageHeight - y4) * k) + ' l');
                } else {
                    // bezier curve
                    x2 = leg[0] * scalex + x4; // here last x4 is prior ending point
                    y2 = leg[1] * scaley + y4; // here last y4 is prior ending point
                    x3 = leg[2] * scalex + x4; // here last x4 is prior ending point
                    y3 = leg[3] * scaley + y4; // here last y4 is prior ending point
                    x4 = leg[4] * scalex + x4; // here last x4 was prior ending point
                    y4 = leg[5] * scaley + y4; // here last y4 was prior ending point
                    out(
                        f3(x2 * k) + ' ' +
                            f3((pageHeight - y2) * k) + ' ' +
                            f3(x3 * k) + ' ' +
                            f3((pageHeight - y3) * k) + ' ' +
                            f3(x4 * k) + ' ' +
                            f3((pageHeight - y4) * k) + ' c'
                    );
                }
            }
            // stroking / filling / both the path
            out(style);
            return this;
        };

        /**
        Adds a rectangle to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} w Width (in units declared at inception of PDF document)
        @param {Number} h Height (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name rect
         */
        API.rect = function (x, y, w, h, style) {
            var op = getStyle(style);
            out([
                f2(x * k),
                f2((pageHeight - y) * k),
                f2(w * k),
                f2(-h * k),
                're',
                op
            ].join(' '));
            return this;
        };

        /**
        Adds a triangle to PDF

        @param {Number} x1 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y1 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} x2 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y2 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} x3 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y3 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name triangle
         */
        API.triangle = function (x1, y1, x2, y2, x3, y3, style) {
            this.lines(
                [
                    [x2 - x1, y2 - y1], // vector to point 2
                    [x3 - x2, y3 - y2], // vector to point 3
                    [x1 - x3, y1 - y3] // closing vector back to point 1
                ],
                x1,
                y1, // start of path
                [1, 1],
                style
            );
            return this;
        };

        /**
        Adds a rectangle with rounded corners to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} w Width (in units declared at inception of PDF document)
        @param {Number} h Height (in units declared at inception of PDF document)
        @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
        @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name roundedRect
        */
        API.roundedRect = function (x, y, w, h, rx, ry, style) {
            var MyArc = 4 / 3 * (Math.SQRT2 - 1);
            this.lines(
                [
                    [(w - 2 * rx), 0],
                    [(rx * MyArc), 0, rx, ry - (ry * MyArc), rx, ry],
                    [0, (h - 2 * ry)],
                    [0, (ry * MyArc), -(rx * MyArc), ry, -rx, ry],
                    [(-w + 2 * rx), 0],
                    [-(rx * MyArc), 0, -rx, -(ry * MyArc), -rx, -ry],
                    [0, (-h + 2 * ry)],
                    [0, -(ry * MyArc), (rx * MyArc), -ry, rx, -ry]
                ],
                x + rx,
                y, // start of path
                [1, 1],
                style
            );
            return this;
        };

        /**
        Adds an ellipse to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
        @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name ellipse
         */
        API.ellipse = function (x, y, rx, ry, style) {
            var op = getStyle(style),
                lx = 4 / 3 * (Math.SQRT2 - 1) * rx,
                ly = 4 / 3 * (Math.SQRT2 - 1) * ry;

            out([
                f2((x + rx) * k),
                f2((pageHeight - y) * k),
                'm',
                f2((x + rx) * k),
                f2((pageHeight - (y - ly)) * k),
                f2((x + lx) * k),
                f2((pageHeight - (y - ry)) * k),
                f2(x * k),
                f2((pageHeight - (y - ry)) * k),
                'c'
            ].join(' '));
            out([
                f2((x - lx) * k),
                f2((pageHeight - (y - ry)) * k),
                f2((x - rx) * k),
                f2((pageHeight - (y - ly)) * k),
                f2((x - rx) * k),
                f2((pageHeight - y) * k),
                'c'
            ].join(' '));
            out([
                f2((x - rx) * k),
                f2((pageHeight - (y + ly)) * k),
                f2((x - lx) * k),
                f2((pageHeight - (y + ry)) * k),
                f2(x * k),
                f2((pageHeight - (y + ry)) * k),
                'c'
            ].join(' '));
            out([
                f2((x + lx) * k),
                f2((pageHeight - (y + ry)) * k),
                f2((x + rx) * k),
                f2((pageHeight - (y + ly)) * k),
                f2((x + rx) * k),
                f2((pageHeight - y) * k),
                'c',
                op
            ].join(' '));
            return this;
        };

        /**
        Adds an circle to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} r Radius (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name circle
         */
        API.circle = function (x, y, r, style) {
            return this.ellipse(x, y, r, r, style);
        };

        /**
        Adds a properties to the PDF document

        @param {Object} A property_name-to-property_value object structure.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setProperties
         */
        API.setProperties = function (properties) {
            // copying only those properties we can render.
            var property;
            for (property in documentProperties) {
                if (documentProperties.hasOwnProperty(property) && properties[property]) {
                    documentProperties[property] = properties[property];
                }
            }
            return this;
        };

        /**
        Sets font size for upcoming text elements.

        @param {Number} size Font size in points.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setFontSize
         */
        API.setFontSize = function (size) {
            activeFontSize = size;
            return this;
        };

        /**
        Sets text font face, variant for upcoming text elements.
        See output of pdfDataExport.getFontList() for possible font names, styles.

        @param {String} fontName Font name or family. Example: "times"
        @param {String} fontStyle Font style or variant. Example: "italic"
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setFont
         */
        API.setFont = function (fontName, fontStyle) {
            activeFontKey = getFont(fontName, fontStyle);
            // if font is not found, the above line blows up and we never go further
            return this;
        };

        /**
        Switches font style or variant for upcoming text elements,
        while keeping the font face or family same.
        See output of pdfDataExport.getFontList() for possible font names, styles.

        @param {String} style Font style or variant. Example: "italic"
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setFontStyle
         */
        API.setFontStyle = API.setFontType = function (style) {
            var undef;
            activeFontKey = getFont(undef, style);
            // if font is not found, the above line blows up and we never go further
            return this;
        };

        /**
        Returns an object - a tree of fontName to fontStyle relationships available to
        active PDF document.

        @public
        @function
        @returns {Object} Like {'times':['normal', 'italic', ... ], 'arial':['normal', 'bold', ... ], ... }
        @methodOf pdfDataExport#
        @name getFontList
        */
        API.getFontList = function () {
            // TODO: iterate over fonts array or return copy of fontmap instead in case more are ever added.
            var list = {},
                fontName,
                fontStyle,
                tmp;

            for (fontName in fontmap) {
                if (fontmap.hasOwnProperty(fontName)) {
                    list[fontName] = tmp = [];
                    for (fontStyle in fontmap[fontName]) {
                        if (fontmap[fontName].hasOwnProperty(fontStyle)) {
                            tmp.push(fontStyle);
                        }
                    }
                }
            }

            return list;
        };

        /**
        Sets line width for upcoming lines.

        @param {Number} width Line width (in units declared at inception of PDF document)
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setLineWidth
         */
        API.setLineWidth = function (width) {
            out((width * k).toFixed(2) + ' w');
            return this;
        };

        /**
        Sets the stroke color for upcoming elements.

        Depending on the number of arguments given, Gray, RGB, or CMYK
        color space is implied.

        When only ch1 is given, "Gray" color space is implied and it
        must be a value in the range from 0.00 (solid black) to to 1.00 (white)
        if values are communicated as String types, or in range from 0 (black)
        to 255 (white) if communicated as Number type.
        The RGB-like 0-255 range is provided for backward compatibility.

        When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
        value must be in the range from 0.00 (minimum intensity) to to 1.00
        (max intensity) if values are communicated as String types, or
        from 0 (min intensity) to to 255 (max intensity) if values are communicated
        as Number types.
        The RGB-like 0-255 range is provided for backward compatibility.

        When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
        value must be a in the range from 0.00 (0% concentration) to to
        1.00 (100% concentration)

        Because JavaScript treats fixed point numbers badly (rounds to
        floating point nearest to binary representation) it is highly advised to
        communicate the fractional numbers as String types, not JavaScript Number type.

        @param {Number|String} ch1 Color channel value
        @param {Number|String} ch2 Color channel value
        @param {Number|String} ch3 Color channel value
        @param {Number|String} ch4 Color channel value

        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setDrawColor
         */
        API.setDrawColor = function (ch1, ch2, ch3, ch4) {
            var color;
            if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
                // Gray color space.
                if (typeof ch1 === 'string') {
                    color = ch1 + ' G';
                } else {
                    color = f2(ch1 / 255) + ' G';
                }
            } else if (ch4 === undefined) {
                // RGB
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, 'RG'].join(' ');
                } else {
                    color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'RG'].join(' ');
                }
            } else {
                // CMYK
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, ch4, 'K'].join(' ');
                } else {
                    color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'K'].join(' ');
                }
            }

            out(color);
            return this;
        };

        /**
        Sets the fill color for upcoming elements.

        Depending on the number of arguments given, Gray, RGB, or CMYK
        color space is implied.

        When only ch1 is given, "Gray" color space is implied and it
        must be a value in the range from 0.00 (solid black) to to 1.00 (white)
        if values are communicated as String types, or in range from 0 (black)
        to 255 (white) if communicated as Number type.
        The RGB-like 0-255 range is provided for backward compatibility.

        When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
        value must be in the range from 0.00 (minimum intensity) to to 1.00
        (max intensity) if values are communicated as String types, or
        from 0 (min intensity) to to 255 (max intensity) if values are communicated
        as Number types.
        The RGB-like 0-255 range is provided for backward compatibility.

        When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
        value must be a in the range from 0.00 (0% concentration) to to
        1.00 (100% concentration)

        Because JavaScript treats fixed point numbers badly (rounds to
        floating point nearest to binary representation) it is highly advised to
        communicate the fractional numbers as String types, not JavaScript Number type.

        @param {Number|String} ch1 Color channel value
        @param {Number|String} ch2 Color channel value
        @param {Number|String} ch3 Color channel value
        @param {Number|String} ch4 Color channel value

        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setFillColor
         */
        API.setFillColor = function (ch1, ch2, ch3, ch4) {
            var color;

            if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
                // Gray color space.
                if (typeof ch1 === 'string') {
                    color = ch1 + ' g';
                } else {
                    color = f2(ch1 / 255) + ' g';
                }
            } else if (ch4 === undefined) {
                // RGB
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, 'rg'].join(' ');
                } else {
                    color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'rg'].join(' ');
                }
            } else {
                // CMYK
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, ch4, 'k'].join(' ');
                } else {
                    color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'k'].join(' ');
                }
            }

            out(color);
            return this;
        };

        /**
        Sets the text color for upcoming elements.
        If only one, first argument is given,
        treats the value as gray-scale color value.

        @param {Number} r Red channel color value in range 0-255
        @param {Number} g Green channel color value in range 0-255
        @param {Number} b Blue channel color value in range 0-255
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setTextColor
        */
        API.setTextColor = function (r, g, b) {
            if ((r === 0 && g === 0 && b === 0) || (typeof g === 'undefined')) {
                textColor = f3(r / 255) + ' g';
            } else {
                textColor = [f3(r / 255), f3(g / 255), f3(b / 255), 'rg'].join(' ');
            }
            return this;
        };

        /**
        Is an Object providing a mapping from human-readable to
        integer flag values designating the varieties of line cap
        and join styles.

        @returns {Object}
        @fieldOf pdfDataExport#
        @name CapJoinStyles
        */
        API.CapJoinStyles = {
            0: 0,
            'butt': 0,
            'but': 0,
            'bevel': 0,
            1: 1,
            'round': 1,
            'rounded': 1,
            'circle': 1,
            2: 2,
            'projecting': 2,
            'project': 2,
            'square': 2,
            'milter': 2
        };

        /**
        Sets the line cap styles
        See {pdfDataExport.CapJoinStyles} for variants

        @param {String|Number} style A string or number identifying the type of line cap
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setLineCap
        */
        API.setLineCap = function (style) {
            var id = this.CapJoinStyles[style];
            if (id === undefined) {
                throw new Error("Line cap style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            }
            lineCapID = id;
            out(id.toString(10) + ' J');

            return this;
        };

        /**
        Sets the line join styles
        See {pdfDataExport.CapJoinStyles} for variants

        @param {String|Number} style A string or number identifying the type of line join
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setLineJoin
        */
        API.setLineJoin = function (style) {
            var id = this.CapJoinStyles[style];
            if (id === undefined) {
                throw new Error("Line join style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            }
            lineJoinID = id;
            out(id.toString(10) + ' j');

            return this;
        };

        // Output is both an internal (for plugins) and external function
        API.output = output;

        /**
         * Saves as PDF document. An alias of pdfDataExport.output('save', 'filename.pdf')
         * @param  {String} filename The filename including extension.
         *
         * @function
         * @returns {pdfDataExport}
         * @methodOf pdfDataExport#
         * @name save
         */
        API.save = function (filename) {
            API.output('save', filename);
        };

        // applying plugins (more methods) ON TOP of built-in API.
        // this is intentional as we allow plugins to override
        // built-ins
        for (plugin in pdfDataExport.API) {
            if (pdfDataExport.API.hasOwnProperty(plugin)) {
                if (plugin === 'events' && pdfDataExport.API.events.length) {
                    (function (events, newEvents) {

                        // pdfDataExport.API.events is a JS Array of Arrays
                        // where each Array is a pair of event name, handler
                        // Events were added by plugins to the pdfDataExport instantiator.
                        // These are always added to the new instance and some ran
                        // during instantiation.

                        var eventname, handler_and_args, i;

                        for (i = newEvents.length - 1; i !== -1; i--) {
                            // subscribe takes 3 args: 'topic', function, runonce_flag
                            // if undefined, runonce is false.
                            // users can attach callback directly,
                            // or they can attach an array with [callback, runonce_flag]
                            // that's what the "apply" magic is for below.
                            eventname = newEvents[i][0];
                            handler_and_args = newEvents[i][1];
                            events.subscribe.apply(
                                events,
                                [eventname].concat(
                                    typeof handler_and_args === 'function' ?
                                            [handler_and_args] :
                                            handler_and_args
                                )
                            );
                        }
                    }(events, pdfDataExport.API.events));
                } else {
                    API[plugin] = pdfDataExport.API[plugin];
                }
            }
        }

        /////////////////////////////////////////
        // continuing initilisation of pdfDataExport Document object
        /////////////////////////////////////////


        // Add the first page automatically
        addFonts();
        activeFontKey = 'F1';
        _addPage();

        events.publish('initialized');

        return API;
    }

    /**
    pdfDataExport.API is a STATIC property of pdfDataExport class.
    pdfDataExport.API is an object you can add methods and properties to.
    The methods / properties you add will show up in new pdfDataExport objects.
    
    One property is prepopulated. It is the 'events' Object. Plugin authors can add topics, callbacks to this object. These will be reassigned to all new instances of pdfDataExport.
    Examples:
        pdfDataExport.API.events['initialized'] = function(){ 'this' is API object }
        pdfDataExport.API.events['addFont'] = function(added_font_object){ 'this' is API object }
    
    @static
    @public
    @memberOf pdfDataExport
    @name API
    
    @example
        pdfDataExport.API.mymethod = function(){
            // 'this' will be ref to internal API object. see pdfDataExport source
            // , so you can refer to built-in methods like so:
            //     this.line(....)
            //     this.text(....)
        }
        var pdfdoc = new pdfDataExport()
        pdfdoc.mymethod() // <- !!!!!!
    */
    pdfDataExport.API = { 'events': [] };

    return pdfDataExport;
}());

(function (pdfDataExportAPI) {
    'use strict';
    /*jslint browser:true */
    /*global document: false, pdfDataExport */

    var maxLn = 0,
        lnP = 0,
        fontName,
        fontSize,
        fontStyle,
        lastCellPos = { x: undefined, y: undefined, w: undefined, h: undefined, ln: undefined },
        pages = 1,
        newPage = false,
        setLastCellPosition = function (x, y, w, h, ln) {
            lastCellPos = { x: x, y: y, w: w, h: h, ln: ln };
        },
        getLastCellPosition = function () {
            return lastCellPos;
        },
        setMaxLn = function (x) {
            maxLn = x;
        },
        getMaxLn = function () {
            return maxLn;
        },
        setLnP = function (x) {
            lnP = x;
        },
        getLnP = function (x) {
            return lnP;
        };

    pdfDataExportAPI.getTextDimensions = function (txt) {
        fontName = this.internal.getFont().fontName;
        fontSize = this.internal.getFontSize();
        fontStyle = this.internal.getFont().fontStyle;

        // 1 pixel = 0.264583 mm and 1 mm = 72/25.4 point
        var px2pt = 0.264583 * 72 / 25.4,
            dimensions,
            text;

        text = document.createElement('font');
        text.id = "pdfDataExportCell";
        text.style.fontStyle = fontStyle;
        text.style.fontName = fontName;
        text.style.fontSize = fontSize + 'pt';
        text.innerHTML = txt;

        document.body.appendChild(text);

        dimensions = { w: (text.offsetWidth + 1) * px2pt, h: (text.offsetHeight + 1) * px2pt };

        document.body.removeChild(text);

        return dimensions;
    };

    pdfDataExportAPI.cellAddPage = function () {
        this.addPage();
        setLastCellPosition(undefined, undefined, undefined, undefined, undefined);
        newPage = true;
        pages += 1;
        setLnP(1);
    };

    pdfDataExportAPI.cellInitialize = function () {
        maxLn = 0;
        lastCellPos = { x: undefined, y: undefined, w: undefined, h: undefined, ln: undefined };
        pages = 1;
        newPage = false;
        setLnP(0);
    };

    pdfDataExportAPI.cell = function (x, y, w, h, txt, ln) {
        this.lnMod = this.lnMod === undefined ? 0 : this.lnMod;
        if (this.printingHeaderRow !== true && this.lnMod !== 0) {
            ln = ln + this.lnMod;
        }

        if ((((ln * h) + y + (h * 2)) / pages) >= this.internal.pageSize.height && pages === 1 && !newPage) {
            this.cellAddPage();

            if (this.printHeaders && this.tableHeaderRow) {
                this.printHeaderRow(ln);
                this.lnMod += 1;
                ln += 1;
            }
            if (getMaxLn() === 0) {
                setMaxLn(Math.round((this.internal.pageSize.height - (h * 2)) / h));
            }
        } else if (newPage && getLastCellPosition().ln !== ln && getLnP() === getMaxLn()) {
            this.cellAddPage();

            if (this.printHeaders && this.tableHeaderRow) {
                this.printHeaderRow(ln);
                this.lnMod += 1;
                ln += 1;
            }
        }

        var curCell = getLastCellPosition(),
            dim = this.getTextDimensions(txt),
            isNewLn = 1;
        if (curCell.x !== undefined && curCell.ln === ln) {
            x = curCell.x + curCell.w;
        }
        if (curCell.y !== undefined && curCell.y === y) {
            y = curCell.y;
        }
        if (curCell.h !== undefined && curCell.h === h) {
            h = curCell.h;
        }
        if (curCell.ln !== undefined && curCell.ln === ln) {
            ln = curCell.ln;
            isNewLn = 0;
        }
        if (newPage) {
            y = h * (getLnP() + isNewLn);
        } else {
            y = (y + (h * Math.abs(getMaxLn() * pages - ln - getMaxLn())));
        }
        this.rect(x, y, w, h);
        var match = /[--]/.test(txt);
        if (match) {
            this.text16(txt, x + 3, y + h - 3);
        }
        else {
            this.text(txt, x + 3, y + h - 3);
        }
        setLnP(getLnP() + isNewLn);
        setLastCellPosition(x, y, w, h, ln);
        return this;
    };

    /**
     * Return an array containing all of the owned keys of an Object
     * @type {Function}
     * @return {String[]} of Object keys
     */
    pdfDataExportAPI.getKeys = (typeof Object.keys === 'function')
        ? function (object) {
            if (!object) {
                return [];
            }
            return Object.keys(object);
        }
            : function (object) {
                var keys = [],
                    property;

                for (property in object) {
                    if (object.hasOwnProperty(property)) {
                        keys.push(property);
                    }
                }

                return keys;
            };

    /**
     * Return the maximum value from an array
     * @param array
     * @param comparisonFn
     * @returns {*}
     */
    pdfDataExportAPI.arrayMax = function (array, comparisonFn) {
        var max = array[0],
            i,
            ln,
            item;

        for (i = 0, ln = array.length; i < ln; i += 1) {
            item = array[i];

            if (comparisonFn) {
                if (comparisonFn(max, item) === -1) {
                    max = item;
                }
            } else {
                if (item > max) {
                    max = item;
                }
            }
        }

        return max;
    };

    /**
     * Create a table from a set of data.
     * @param {Object[]} data As array of objects containing key-value pairs
     * @param {String[]} [headers] Omit or null to auto-generate headers at a performance cost
     * @param {Object} [config.printHeaders] True to print column headers at the top of every page
     * @param {Object} [config.autoSize] True to dynamically set the column widths to match the widest cell value
     * @param {Object} [config.autoStretch] True to force the table to fit the width of the page
     */
    pdfDataExportAPI.table = function (data, headers, config) {

        var headerNames = [],
            headerPrompts = [],
            header,
            autoSize,
            printHeaders,
            autoStretch,
            i,
            ln,
            columnMatrix = {},
            columnWidths = {},
            columnData,
            column,
            columnMinWidths = [],
            j,
            tableHeaderConfigs = [],
            model,
            jln,
            func;

        /**
         * @property {Number} lnMod
         * Keep track of the current line number modifier used when creating cells
         */
        this.lnMod = 0;

        if (config) {
            autoSize = config.autoSize || false;
            printHeaders = this.printHeaders = config.printHeaders || true;
            autoStretch = config.autoStretch || true;
        }

        if (!data) {
            throw 'No data for PDF table';
        }

        // Set headers
        if (headers === undefined || (headers === null)) {

            // No headers defined so we derive from data
            headerNames = this.getKeys(data[0]);

        } else if (headers[0] && (typeof headers[0] !== 'string')) {

            // Split header configs into names and prompts
            for (i = 0, ln = headers.length; i < ln; i += 1) {
                header = headers[i];
                headerNames.push(header.name);
                headerPrompts.push(header.prompt);
            }

        } else {
            headerNames = headers;
        }

        if (config.autoSize) {

            // Create Columns Matrix

            func = function (rec) {
                return rec[header];
            };

            for (i = 0, ln = headerNames.length; i < ln; i += 1) {
                header = headerNames[i];

                columnMatrix[header] = data.map(
                    func
                );

                // get header width
                columnMinWidths.push(this.getTextDimensions(headerPrompts[i] || header).w);

                column = columnMatrix[header];

                // get cell widths
                for (j = 0, ln = column.length; j < ln; j += 1) {
                    columnData = column[j];

                    columnMinWidths.push(this.getTextDimensions(columnData).w);
                }

                // get final column width
                columnWidths[header] = pdfDataExportAPI.arrayMax(columnMinWidths);
            }
        }

        // -- Construct the table

        if (config.printHeaders) {

            // Construct the header row
            for (i = 0, ln = headerNames.length; i < ln; i += 1) {
                header = headerNames[i];
                tableHeaderConfigs.push([10, 10, columnWidths[header], 25, String(headerPrompts.length ? headerPrompts[i] : header)]);
            }

            // Store the table header config
            this.setTableHeaderRow(tableHeaderConfigs);

            // Print the header for the start of the table
            this.printHeaderRow(1);
        }

        // Construct the data rows
        for (i = 0, ln = data.length; i < ln; i += 1) {
            model = data[i];

            for (j = 0, jln = headerNames.length; j < jln; j += 1) {
                header = headerNames[j];
                this.cell(10, 10, columnWidths[header], 25, String(model[header]), i + 2);
            }
        }

        return this;
    };

    /**
     * Store the config for outputting a table header
     * @param {Object[]} config
     * An array of cell configs that would define a header row: Each config matches the config used by pdfDataExportAPI.cell
     * except the ln parameter is excluded
     */
    pdfDataExportAPI.setTableHeaderRow = function (config) {
        this.tableHeaderRow = config;
    };

    /**
     * Output the store header row
     * @param lineNumber The line number to output the header at
     */
    pdfDataExportAPI.printHeaderRow = function (lineNumber) {
        if (!this.tableHeaderRow) {
            throw 'Property tableHeaderRow does not exist.';
        }

        var tableHeaderCell,
            tmpArray,
            i,
            ln;

        this.printingHeaderRow = true;

        for (i = 0, ln = this.tableHeaderRow.length; i < ln; i += 1) {

            tableHeaderCell = this.tableHeaderRow[i];
            tmpArray = [].concat(tableHeaderCell);

            this.cell.apply(this, tmpArray.concat(lineNumber));
        }

        this.printingHeaderRow = false;
    };

}(pdfDataExport.API));


; (function (API) {
    'use strict'

    /**
    Returns an array of length matching length of the 'word' string, with each
    cell ocupied by the width of the char in that position.
    
    @function
    @param word {String}
    @param widths {Object}
    @param kerning {Object}
    @returns {Array}
    */
    var getCharWidthsArray = API.getCharWidthsArray = function (text, options) {

        if (!options) {
            options = {}
        }

        var widths = options.widths ? options.widths : this.internal.getFont().metadata.Unicode.widths
        , widthsFractionOf = widths.fof ? widths.fof : 1
        , kerning = options.kerning ? options.kerning : this.internal.getFont().metadata.Unicode.kerning
        , kerningFractionOf = kerning.fof ? kerning.fof : 1

        // console.log("widths, kergnings", widths, kerning)

        var i, l
        , char_code
        , char_width
        , prior_char_code = 0 // for kerning
        , default_char_width = widths[0] || widthsFractionOf
        , output = []

        for (i = 0, l = text.length; i < l; i++) {
            char_code = text.charCodeAt(i)
            output.push(
                (widths[char_code] || default_char_width) / widthsFractionOf +
                (kerning[char_code] && kerning[char_code][prior_char_code] || 0) / kerningFractionOf
            )
            prior_char_code = char_code
        }

        return output
    }
    var getArraySum = function (array) {
        var i = array.length
        , output = 0
        while (i) {
            ; i--;
            output += array[i]
        }
        return output
    }
    /**
    Returns a widths of string in a given font, if the font size is set as 1 point.
    
    In other words, this is "proportional" value. For 1 unit of font size, the length
    of the string will be that much.
    
    Multiply by font size to get actual width in *points*
    Then divide by 72 to get inches or divide by (72/25.6) to get 'mm' etc.
    
    @public
    @function
    @param
    @returns {Type}
    */
    var getStringUnitWidth = API.getStringUnitWidth = function (text, options) {
        return getArraySum(getCharWidthsArray.call(this, text, options))
    }

    /** 
    returns array of lines
    */
    var splitLongWord = function (word, widths_array, firstLineMaxLen, maxLen) {
        var answer = []

        // 1st, chop off the piece that can fit on the hanging line.
        var i = 0
        , l = word.length
        , workingLen = 0
        while (i !== l && workingLen + widths_array[i] < firstLineMaxLen) {
            workingLen += widths_array[i]
            ; i++;
        }
        // this is first line.
        answer.push(word.slice(0, i))

        // 2nd. Split the rest into maxLen pieces.
        var startOfLine = i
        workingLen = 0
        while (i !== l) {
            if (workingLen + widths_array[i] > maxLen) {
                answer.push(word.slice(startOfLine, i))
                workingLen = 0
                startOfLine = i
            }
            workingLen += widths_array[i]
            ; i++;
        }
        if (startOfLine !== i) {
            answer.push(word.slice(startOfLine, i))
        }

        return answer
    }

    // Note, all sizing inputs for this function must be in "font measurement units"
    // By default, for PDF, it's "point".
    var splitParagraphIntoLines = function (text, maxlen, options) {
        // at this time works only on Western scripts, ones with space char
        // separating the words. Feel free to expand.

        if (!options) {
            options = {}
        }

        var spaceCharWidth = getCharWidthsArray(' ', options)[0]

        var words = text.split(' ')

        var line = []
        , lines = [line]
        , line_length = options.textIndent || 0
        , separator_length = 0
        , current_word_length = 0
        , word
        , widths_array

        var i, l, tmp
        for (i = 0, l = words.length; i < l; i++) {
            word = words[i]
            widths_array = getCharWidthsArray(word, options)
            current_word_length = getArraySum(widths_array)

            if (line_length + separator_length + current_word_length > maxlen) {
                if (current_word_length > maxlen) {
                    // this happens when you have space-less long URLs for example.
                    // we just chop these to size. We do NOT insert hiphens
                    tmp = splitLongWord(word, widths_array, maxlen - (line_length + separator_length), maxlen)
                    // first line we add to existing line object
                    line.push(tmp.shift()) // it's ok to have extra space indicator there
                    // last line we make into new line object
                    line = [tmp.pop()]
                    // lines in the middle we apped to lines object as whole lines
                    while (tmp.length) {
                        lines.push([tmp.shift()]) // single fragment occupies whole line
                    }
                    current_word_length = getArraySum(widths_array.slice(word.length - line[0].length))
                } else {
                    // just put it on a new line
                    line = [word]
                }

                // now we attach new line to lines
                lines.push(line)

                line_length = current_word_length
                separator_length = spaceCharWidth

            } else {
                line.push(word)

                line_length += separator_length + current_word_length
                separator_length = spaceCharWidth
            }
        }

        var output = []
        for (i = 0, l = lines.length; i < l; i++) {
            output.push(lines[i].join(' '))
        }
        return output

    }

    /**
    Splits a given string into an array of strings. Uses 'size' value
    (in measurement units declared as default for the pdfDataExport instance)
    and the font's "widths" and "Kerning" tables, where availabe, to
    determine display length of a given string for a given font.
    
    We use character's 100% of unit size (height) as width when Width
    table or other default width is not available.
    
    @public
    @function
    @param text {String} Unencoded, regular JavaScript (Unicode, UTF-16 / UCS-2) string.
    @param size {Number} Nominal number, measured in units default to this instance of pdfDataExport.
    @param options {Object} Optional flags needed for chopper to do the right thing.
    @returns {Array} with strings chopped to size.
    */
    API.splitTextToSize = function (text, maxlen, options) {
        'use strict'

        if (!options) {
            options = {}
        }

        var fsize = options.fontSize || this.internal.getFontSize()
        , newOptions = (function (options) {
            var widths = { 0: 1 }
            , kerning = {}

            if (!options.widths || !options.kerning) {
                var f = this.internal.getFont(options.fontName, options.fontStyle)
                , encoding = 'Unicode'
                // NOT UTF8, NOT UTF16BE/LE, NOT UCS2BE/LE
                // Actual JavaScript-native String's 16bit char codes used.
                // no multi-byte logic here

                if (f.metadata[encoding]) {
                    return {
                        widths: f.metadata[encoding].widths || widths
                        , kerning: f.metadata[encoding].kerning || kerning
                    }
                }
            } else {
                return {
                    widths: options.widths
                    , kerning: options.kerning
                }
            }

            // then use default values
            return {
                widths: widths
                , kerning: kerning
            }
        }).call(this, options)

        // first we split on end-of-line chars
        var paragraphs
        if (text.match(/[\n\r]/)) {
            paragraphs = text.split(/\r\n|\r|\n/g)
        } else {
            paragraphs = [text]
        }

        // now we convert size (max length of line) into "font size units"
        // at present time, the "font size unit" is always 'point'
        // 'proportional' means, "in proportion to font size"
        var fontUnit_maxLen = 1.0 * this.internal.scaleFactor * maxlen / fsize
        // at this time, fsize is always in "points" regardless of the default measurement unit of the doc.
        // this may change in the future?
        // until then, proportional_maxlen is likely to be in 'points'

        // If first line is to be indented (shorter or longer) than maxLen 
        // we indicate that by using CSS-style "text-indent" option.
        // here it's in font units too (which is likely 'points')
        // it can be negative (which makes the first line longer than maxLen)
        newOptions.textIndent = options.textIndent ?
            options.textIndent * 1.0 * this.internal.scaleFactor / fsize :
            0

        var i, l
        , output = []
        for (i = 0, l = paragraphs.length; i < l; i++) {
            output = output.concat(
                splitParagraphIntoLines(
                    paragraphs[i]
                    , fontUnit_maxLen
                    , newOptions
                )
            )
        }

        return output
    }

})(pdfDataExport.API);


; (function (pdfDataExportAPI) {
    'use strict'

    var namespace = 'addImage_'

    var getJpegSize = function (imgData) {
        'use strict'
        var width, height;
        // Verify we have a valid jpeg header 0xff,0xd8,0xff,0xe0,?,?,'J','F','I','F',0x00
        if (!imgData.charCodeAt(0) === 0xff ||
            !imgData.charCodeAt(1) === 0xd8 ||
            !imgData.charCodeAt(2) === 0xff ||
            !imgData.charCodeAt(3) === 0xe0 ||
            !imgData.charCodeAt(6) === 'J'.charCodeAt(0) ||
            !imgData.charCodeAt(7) === 'F'.charCodeAt(0) ||
            !imgData.charCodeAt(8) === 'I'.charCodeAt(0) ||
            !imgData.charCodeAt(9) === 'F'.charCodeAt(0) ||
            !imgData.charCodeAt(10) === 0x00) {
            throw new Error('getJpegSize requires a binary jpeg file')
        }
        var blockLength = imgData.charCodeAt(4) * 256 + imgData.charCodeAt(5);
        var i = 4, len = imgData.length;
        while (i < len) {
            i += blockLength;
            if (imgData.charCodeAt(i) !== 0xff) {
                throw new Error('getJpegSize could not find the size of the image');
            }
            if (imgData.charCodeAt(i + 1) === 0xc0) {
                height = imgData.charCodeAt(i + 5) * 256 + imgData.charCodeAt(i + 6);
                width = imgData.charCodeAt(i + 7) * 256 + imgData.charCodeAt(i + 8);
                return [width, height];
            } else {
                i += 2;
                blockLength = imgData.charCodeAt(i) * 256 + imgData.charCodeAt(i + 1)
            }
        }
    }
    // Image functionality ported from pdf.js
    , putImage = function (img) {
        var objectNumber = this.internal.newObject()
        , out = this.internal.write
        , putStream = this.internal.putStream

        img['n'] = objectNumber

        out('<</Type /XObject')
        out('/Subtype /Image')
        out('/Width ' + img['w'])
        out('/Height ' + img['h'])
        if (img['cs'] === 'Indexed') {
            out('/ColorSpace [/Indexed /DeviceRGB '
                    + (img['pal'].length / 3 - 1) + ' ' + (objectNumber + 1)
                    + ' 0 R]');
        } else {
            out('/ColorSpace /' + img['cs']);
            if (img['cs'] === 'DeviceCMYK') {
                out('/Decode [1 0 1 0 1 0 1 0]');
            }
        }
        out('/BitsPerComponent ' + img['bpc']);
        if ('f' in img) {
            out('/Filter /' + img['f']);
        }
        if ('dp' in img) {
            out('/DecodeParms <<' + img['dp'] + '>>');
        }
        if ('trns' in img && img['trns'].constructor == Array) {
            var trns = '';
            for (var i = 0; i < img['trns'].length; i++) {
                trns += (img[trns][i] + ' ' + img['trns'][i] + ' ');
                out('/Mask [' + trns + ']');
            }
        }
        if ('smask' in img) {
            out('/SMask ' + (objectNumber + 1) + ' 0 R');
        }
        out('/Length ' + img['data'].length + '>>');

        putStream(img['data']);

        out('endobj');
    }
    , putResourcesCallback = function () {
        var images = this.internal.collections[namespace + 'images']
        for (var i in images) {
            putImage.call(this, images[i])
        }
    }
    , putXObjectsDictCallback = function () {
        var images = this.internal.collections[namespace + 'images']
        , out = this.internal.write
        , image
        for (var i in images) {
            image = images[i]
            out(
                '/I' + image['i']
                , image['n']
                , '0'
                , 'R'
            )
        }
    }

    pdfDataExportAPI.addImage = function (imageData, format, x, y, w, h) {
        'use strict'
        if (typeof imageData === 'object' && imageData.nodeType === 1) {
            var canvas = document.createElement('canvas');
            canvas.width = imageData.clientWidth;
            canvas.height = imageData.clientHeight;

            var ctx = canvas.getContext('2d');
            if (!ctx) {
                throw ('addImage requires canvas to be supported by browser.');
            }
            ctx.drawImage(imageData, 0, 0, canvas.width, canvas.height);
            imageData = canvas.toDataURL('image/jpeg');
            format = "JPEG";
        }
        if (format.toUpperCase() !== 'JPEG') {
            throw new Error('addImage currently only supports format \'JPEG\', not \'' + format + '\'');
        }

        var imageIndex
        , images = this.internal.collections[namespace + 'images']
        , coord = this.internal.getCoordinateString
        , vcoord = this.internal.getVerticalCoordinateString;

        // Detect if the imageData is raw binary or Data URL
        if (imageData.substring(0, 23) === 'data:image/jpeg;base64,') {
            imageData = atob(imageData.replace('data:image/jpeg;base64,', ''));
        }

        if (images) {
            // this is NOT the first time this method is ran on this instance of pdfDataExport object.
            imageIndex = Object.keys ?
            Object.keys(images).length :
            (function (o) {
                var i = 0
                for (var e in o) { if (o.hasOwnProperty(e)) { i++ } }
                return i
            })(images)
        } else {
            // this is the first time this method is ran on this instance of pdfDataExport object.
            imageIndex = 0
            this.internal.collections[namespace + 'images'] = images = {}
            this.internal.events.subscribe('putResources', putResourcesCallback)
            this.internal.events.subscribe('putXobjectDict', putXObjectsDictCallback)
        }

        var dims = getJpegSize(imageData);
        var info = {
            w: dims[0],
            h: dims[1],
            cs: 'DeviceRGB',
            bpc: 8,
            f: 'DCTDecode',
            i: imageIndex,
            data: imageData
            // n: objectNumber will be added by putImage code

        };
        images[imageIndex] = info
        if (!w && !h) {
            w = -96;
            h = -96;
        }
        if (w < 0) {
            w = (-1) * info['w'] * 72 / w / this.internal.scaleFactor;
        }
        if (h < 0) {
            h = (-1) * info['h'] * 72 / h / this.internal.scaleFactor;
        }
        if (w === 0) {
            w = h * info['w'] / info['h'];
        }
        if (h === 0) {
            h = w * info['h'] / info['w'];
        }

        this.internal.write(
            'q'
            , coord(w)
            , '0 0'
            , coord(h) // TODO: check if this should be shifted by vcoord
            , coord(x)
            , vcoord(y + h)
            , 'cm /I' + info['i']
            , 'Do Q'
        )

        return this
    }
})(pdfDataExport.API)

; (function (API) {
    'use strict'

    /**
    Uncompresses data compressed into custom, base16-like format. 
    @public
    @function
    @param
    @returns {Type}
    */
    var uncompress = function (data) {

        var decoded = '0123456789abcdef'
        , encoded = 'klmnopqrstuvwxyz'
        , mapping = {}

        for (var i = 0; i < encoded.length; i++) {
            mapping[encoded[i]] = decoded[i]
        }

        var undef
        , output = {}
        , sign = 1
        , stringparts // undef. will be [] in string mode

        , activeobject = output
        , parentchain = []
        , parent_key_pair
        , keyparts = ''
        , valueparts = ''
        , key // undef. will be Truthy when Key is resolved.
        , datalen = data.length - 1 // stripping ending }
        , ch

        i = 1 // stripping starting {

        while (i != datalen) {
            // - { } ' are special.

            ch = data[i]
            i += 1

            if (ch == "'") {
                if (stringparts) {
                    // end of string mode
                    key = stringparts.join('')
                    stringparts = undef
                } else {
                    // start of string mode
                    stringparts = []
                }
            } else if (stringparts) {
                stringparts.push(ch)
            } else if (ch == '{') {
                // start of object
                parentchain.push([activeobject, key])
                activeobject = {}
                key = undef
            } else if (ch == '}') {
                // end of object
                parent_key_pair = parentchain.pop()
                parent_key_pair[0][parent_key_pair[1]] = activeobject
                key = undef
                activeobject = parent_key_pair[0]
            } else if (ch == '-') {
                sign = -1
            } else {
                // must be number
                if (key === undef) {
                    if (mapping.hasOwnProperty(ch)) {
                        keyparts += mapping[ch]
                        key = parseInt(keyparts, 16) * sign
                        sign = +1
                        keyparts = ''
                    } else {
                        keyparts += ch
                    }
                } else {
                    if (mapping.hasOwnProperty(ch)) {
                        valueparts += mapping[ch]
                        activeobject[key] = parseInt(valueparts, 16) * sign
                        sign = +1
                        key = undef
                        valueparts = ''
                    } else {
                        valueparts += ch
                    }
                }
            }
        } // end while

        return output
    }

    // encoding = 'Unicode' 
    // NOT UTF8, NOT UTF16BE/LE, NOT UCS2BE/LE. NO clever BOM behavior
    // Actual 16bit char codes used.
    // no multi-byte logic here

    // Unicode characters to WinAnsiEncoding:
    // {402: 131, 8211: 150, 8212: 151, 8216: 145, 8217: 146, 8218: 130, 8220: 147, 8221: 148, 8222: 132, 8224: 134, 8225: 135, 8226: 149, 8230: 133, 8364: 128, 8240:137, 8249: 139, 8250: 155, 710: 136, 8482: 153, 338: 140, 339: 156, 732: 152, 352: 138, 353: 154, 376: 159, 381: 142, 382: 158}
    // as you can see, all Unicode chars are outside of 0-255 range. No char code conflicts.
    // this means that you can give Win cp1252 encoded strings to pdfDataExport for rendering directly
    // as well as give strings with some (supported by these fonts) Unicode characters and 
    // these will be mapped to win cp1252 
    // for example, you can send char code (cp1252) 0x80 or (unicode) 0x20AC, getting "Euro" glyph displayed in both cases.

    var encodingBlock = {
        'codePages': ['WinAnsiEncoding']
        , 'WinAnsiEncoding': uncompress("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
    }
    , encodings = {
        'Unicode': {
            'Courier': encodingBlock
            , 'Courier-Bold': encodingBlock
            , 'Courier-BoldOblique': encodingBlock
            , 'Courier-Oblique': encodingBlock
            , 'Helvetica': encodingBlock
            , 'Helvetica-Bold': encodingBlock
            , 'Helvetica-BoldOblique': encodingBlock
            , 'Helvetica-Oblique': encodingBlock
            , 'Times-Roman': encodingBlock
            , 'Times-Bold': encodingBlock
            , 'Times-BoldItalic': encodingBlock
            , 'Times-Italic': encodingBlock
            //	, 'Symbol'
            //	, 'ZapfDingbats'
        }
    }

    , fontMetrics = {
        'Unicode': {
            // all sizing numbers are n/fontMetricsFractionOf = one font size unit
            // this means that if fontMetricsFractionOf = 1000, and letter A's width is 476, it's
            // width is 476/1000 or 47.6% of its height (regardless of font size)
            // At this time this value applies to "widths" and "kerning" numbers.

            // char code 0 represents "default" (average) width - use it for chars missing in this table.
            // key 'fof' represents the "fontMetricsFractionOf" value

            'Courier-Oblique': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")
            , 'Times-BoldItalic': uncompress("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}")
            , 'Helvetica-Bold': uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}")
            , 'Courier': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")
            , 'Courier-BoldOblique': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")
            , 'Times-Bold': uncompress("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}")
            //, 'Symbol': uncompress("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}")
            , 'Helvetica': uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
            , 'Helvetica-BoldOblique': uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}")
            //, 'ZapfDingbats': uncompress("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}")
            , 'Courier-Bold': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")
            , 'Times-Italic': uncompress("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}")
            , 'Times-Roman': uncompress("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}")
            , 'Helvetica-Oblique': uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
        }
    };

    /*
    This event handler is fired when a new pdfDataExport object is initialized
    This event handler appends metrics data to standard fonts within
    that pdfDataExport instance. The metrics are mapped over Unicode character
    codes, NOT CIDs or other codes matching the StandardEncoding table of the
    standard PDF fonts.
    Future:
    Also included is the encoding maping table, converting Unicode (UCS-2, UTF-16)
    char codes to StandardEncoding character codes. The encoding table is to be used
    somewhere around "pdfEscape" call.
    */

    API.events.push([
        'addFonts'
        , function (fontManagementObjects) {
            // fontManagementObjects is {
            //	'fonts':font_ID-keyed hash of font objects
            //	, 'dictionary': lookup object, linking ["FontFamily"]['Style'] to font ID
            //}
            var font
            , fontID
            , metrics
            , unicode_section
            , encoding = 'Unicode'
            , encodingBlock

            for (fontID in fontManagementObjects.fonts) {
                if (fontManagementObjects.fonts.hasOwnProperty(fontID)) {
                    font = fontManagementObjects.fonts[fontID]

                    // // we only ship 'Unicode' mappings and metrics. No need for loop.
                    // // still, leaving this for the future.

                    // for (encoding in fontMetrics){
                    // 	if (fontMetrics.hasOwnProperty(encoding)) {

                    metrics = fontMetrics[encoding][font.PostScriptName]
                    if (metrics) {
                        if (font.metadata[encoding]) {
                            unicode_section = font.metadata[encoding]
                        } else {
                            unicode_section = font.metadata[encoding] = {}
                        }

                        unicode_section.widths = metrics.widths
                        unicode_section.kerning = metrics.kerning
                    }
                    // 	}
                    // }
                    // for (encoding in encodings){
                    // 	if (encodings.hasOwnProperty(encoding)) {
                    encodingBlock = encodings[encoding][font.PostScriptName]
                    if (encodingBlock) {
                        if (font.metadata[encoding]) {
                            unicode_section = font.metadata[encoding]
                        } else {
                            unicode_section = font.metadata[encoding] = {}
                        }

                        unicode_section.encoding = encodingBlock
                        if (encodingBlock.codePages && encodingBlock.codePages.length) {
                            font.encoding = encodingBlock.codePages[0]
                        }
                    }
                    // 	}
                    // }
                }
            }
        }
    ]) // end of adding event handler

})(pdfDataExport.API);


/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */


var saveAs = window.jqxSaveAs = saveAs
  || (navigator.msSaveBlob && navigator.msSaveBlob.bind(navigator))
  || (function (view) {
      "use strict";
      var
            doc = view.document
            // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
          , get_URL = function () {
              return view.URL || view.webkitURL || view;
          }
          , URL = view.URL || view.webkitURL || view
           , save_link = $("<a></a>")[0]
      //   , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
          , can_use_save_link = "download" in save_link
          , click = function (node) {
              var event = doc.createEvent("MouseEvents");
              event.initMouseEvent(
                  "click", true, false, view, 0, 0, 0, 0, 0
                  , false, false, false, false, 0, null
              );
              return node.dispatchEvent(event); // false if event was cancelled
          }
          , webkit_req_fs = view.webkitRequestFileSystem
          , req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
          , throw_outside = function (ex) {
              (view.setImmediate || view.setTimeout)(function () {
                  throw ex;
              }, 0);
          }
          , force_saveable_type = "application/octet-stream"
          , fs_min_size = 0
          , deletion_queue = []
          , process_deletion_queue = function () {
              var i = deletion_queue.length;
              while (i--) {
                  var file = deletion_queue[i];
                  if (typeof file === "string") { // file is an object URL
                      URL.revokeObjectURL(file);
                  } else { // file is a File
                      file.remove();
                  }
              }
              deletion_queue.length = 0; // clear queue
          }
          , dispatch = function (filesaver, event_types, event) {
              event_types = [].concat(event_types);
              var i = event_types.length;
              while (i--) {
                  var listener = filesaver["on" + event_types[i]];
                  if (typeof listener === "function") {
                      try {
                          listener.call(filesaver, event || filesaver);
                      } catch (ex) {
                          throw_outside(ex);
                      }
                  }
              }
          }
          , FileSaver = function (blob, name) {
              // First try a.download, then web filesystem, then object URLs
              var
                    filesaver = this
                  , type = blob.type
                  , blob_changed = false
                  , object_url
                  , target_view
                  , get_object_url = function () {
                      var object_url = get_URL().createObjectURL(blob);
                      deletion_queue.push(object_url);
                      return object_url;
                  }
                  , dispatch_all = function () {
                      dispatch(filesaver, "writestart progress write writeend".split(" "));
                  }
                  // on any filesys errors revert to saving with object URLs
                  , fs_error = function () {
                      // don't create more object URLs than needed
                      if (blob_changed || !object_url) {
                          object_url = get_object_url(blob);
                      }
                      if (target_view) {
                          target_view.location.href = object_url;
                      }
                      filesaver.readyState = filesaver.DONE;
                      dispatch_all();
                  }
                  , abortable = function (func) {
                      return function () {
                          if (filesaver.readyState !== filesaver.DONE) {
                              return func.apply(this, arguments);
                          }
                      };
                  }
                  , create_if_not_found = { create: true, exclusive: false }
                  , slice
              ;
              filesaver.readyState = filesaver.INIT;
              if (!name) {
                  name = "download";
              }
              if (can_use_save_link) {
                  object_url = get_object_url(blob);
                  save_link.href = object_url;
                  save_link.download = name;
                  if (click(save_link)) {
                      filesaver.readyState = filesaver.DONE;
                      dispatch_all();
                      return;
                  }
              }
              // Object and web filesystem URLs have a problem saving in Google Chrome when
              // viewed in a tab, so I force save with application/octet-stream
              // http://code.google.com/p/chromium/issues/detail?id=91158
              if (view.chrome && type && type !== force_saveable_type) {
                  slice = blob.slice || blob.webkitSlice;
                  blob = slice.call(blob, 0, blob.size, force_saveable_type);
                  blob_changed = true;
              }
              // Since I can't be sure that the guessed media type will trigger a download
              // in WebKit, I append .download to the filename.
              // https://bugs.webkit.org/show_bug.cgi?id=65440
              if (webkit_req_fs && name !== "download") {
                  name += ".download";
              }
              if (type === force_saveable_type || webkit_req_fs) {
                  target_view = view;
              } else {
                  target_view = view.open();
              }
              if (!req_fs) {
                  fs_error();
                  return;
              }
              fs_min_size += blob.size;
              req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
                  fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) {
                      var save = function () {
                          dir.getFile(name, create_if_not_found, abortable(function (file) {
                              file.createWriter(abortable(function (writer) {
                                  writer.onwriteend = function (event) {
                                      target_view.location.href = file.toURL();
                                      deletion_queue.push(file);
                                      filesaver.readyState = filesaver.DONE;
                                      dispatch(filesaver, "writeend", event);
                                  };
                                  writer.onerror = function () {
                                      var error = writer.error;
                                      if (error.code !== error.ABORT_ERR) {
                                          fs_error();
                                      }
                                  };
                                  "writestart progress write abort".split(" ").forEach(function (event) {
                                      writer["on" + event] = filesaver["on" + event];
                                  });
                                  writer.write(blob);
                                  filesaver.abort = function () {
                                      writer.abort();
                                      filesaver.readyState = filesaver.DONE;
                                  };
                                  filesaver.readyState = filesaver.WRITING;
                              }), fs_error);
                          }), fs_error);
                      };
                      dir.getFile(name, { create: false }, abortable(function (file) {
                          // delete file if it already exists
                          file.remove();
                          save();
                      }), abortable(function (ex) {
                          if (ex.code === ex.NOT_FOUND_ERR) {
                              save();
                          } else {
                              fs_error();
                          }
                      }));
                  }), fs_error);
              }), fs_error);
          }
          , FS_proto = FileSaver.prototype
          , saveAs = function (blob, name) {
              return new FileSaver(blob, name);
          }
      ;
      FS_proto.abort = function () {
          var filesaver = this;
          filesaver.readyState = filesaver.DONE;
          dispatch(filesaver, "abort");
      };
      FS_proto.readyState = FS_proto.INIT = 0;
      FS_proto.WRITING = 1;
      FS_proto.DONE = 2;

      FS_proto.error =
      FS_proto.onwritestart =
      FS_proto.onprogress =
      FS_proto.onwrite =
      FS_proto.onabort =
      FS_proto.onerror =
      FS_proto.onwriteend =
          null;

      if (view.addEventListener) {
          view.addEventListener("unload", process_deletion_queue, false);
      }
      return saveAs;
  }(self));


; (function (API) {
    'use strict'

    var name = 'pdfDataExport IE Below 9 Shim plugin';
    // Shim in IE6-9 support
    API.output = function (type, options) {

        // If not IE then return early
        return this.internal.output(type, options);

        var filename = 'Output.pdf';
        switch (type) {
            case 'datauristring':
            case 'dataurlstring':
            case 'datauri':
            case 'dataurl':
            case 'dataurlnewwindow':
                if (console)
                    console.log(name + ': Data URIs are not supported on IE6-9.');
                break;
            case 'save':
                filename = options;
                break;
        }

        // @TODO: IE shim 


    };



})(pdfDataExport.API)
})();



/***/ }),

/***/ 4198:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

( function ( $ ) {

    if ( !Array.prototype.find ) {
        Object.defineProperty( Array.prototype, 'find', {
            value: function ( predicate ) {
                // 1. Let O be ? ToObject(this value).
                if ( this == null ) {
                    throw TypeError( '"this" is null or not defined' );
                }

                var o = Object( this );

                // 2. Let len be ? ToLength(? Get(O, "length")).
                var len = o.length >>> 0;

                // 3. If IsCallable(predicate) is false, throw a TypeError exception.
                if ( typeof predicate !== 'function' ) {
                    throw TypeError( 'predicate must be a function' );
                }

                // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
                var thisArg = arguments[ 1 ];

                // 5. Let k be 0.
                var k = 0;

                // 6. Repeat, while k < len
                while ( k < len ) {
                    // a. Let Pk be ! ToString(k).
                    // b. Let kValue be ? Get(O, Pk).
                    // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
                    // d. If testResult is true, return kValue.
                    var kValue = o[ k ];
                    if ( predicate.call( thisArg, kValue, k, o ) ) {
                        return kValue;
                    }
                    // e. Increase k by 1.
                    k++;
                }

                // 7. Return undefined.
                return undefined;
            },
            configurable: true,
            writable: true
        } );
    }

    $.jqx.observableArray = function ( items, observeFunction ) {
        if ( typeof ( items ) == 'string' ) {
            items = $.parseJSON( items );
        }

        if ( !Object.defineProperty ||
            !( function () { try { Object.defineProperty( {}, 'x', {} ); return true; } catch ( e ) { return false; } }() ) ) {
            var orig = Object.defineProperty;
            Object.defineProperty = function ( o, prop, desc ) {
                // In IE8 try built-in implementation for defining properties on DOM prototypes.
                if ( orig ) { try { return orig( o, prop, desc ); } catch ( e ) { } }

                if ( o !== Object( o ) ) { throw TypeError( "Object.defineProperty called on non-object" ); }
                if ( Object.prototype.__defineGetter__ && ( 'get' in desc ) ) {
                    Object.prototype.__defineGetter__.call( o, prop, desc.get );
                }
                if ( Object.prototype.__defineSetter__ && ( 'set' in desc ) ) {
                    Object.prototype.__defineSetter__.call( o, prop, desc.set );
                }
                if ( 'value' in desc ) {
                    o[ prop ] = desc.value;
                }
                else if ( !o[ prop ] ) {
                    o[ prop ] = desc;
                }

                return o;
            };
        }

        if ( !Array.prototype.forEach ) {
            Array.prototype.forEach = function ( fun /*, thisp */ ) {
                if ( this === void 0 || this === null ) { throw TypeError(); }

                var t = Object( this );
                var len = t.length >>> 0;
                if ( typeof fun !== "function" ) { throw TypeError(); }

                var thisp = arguments[ 1 ], i;
                for ( i = 0; i < len; i++ ) {
                    if ( i in t ) {
                        fun.call( thisp, t[ i ], i, t );
                    }
                }
            };
        }

        if ( typeof Object.getOwnPropertyNames !== "function" ) {
            Object.getOwnPropertyNames = function ( o ) {
                if ( o !== Object( o ) ) { throw TypeError( "Object.getOwnPropertyNames called on non-object" ); }
                var props = [], p;
                for ( p in o ) {
                    if ( Object.prototype.hasOwnProperty.call( o, p ) ) {
                        props.push( p );
                    }
                }
                return props;
            };
        }

        var that = this, notifier, array = [];
        that.notifier = null;
        that.name = "observableArray";
        that.observing = true;
        that.changes = new Array();

        var observeFunction = observeFunction;
        that.observe = function () {
            that.observing = true;
            if ( arguments.length == 1 ) {
                observeFunction = arguments[ 0 ];
            }
        }

        that.unobserve = function () {
            that.observing = false;
        }

        that.toArray = function () {
            return array.slice( 0 );
        }

        that.toJSON = function ( keys, subArray ) {
            var value = array;
            if ( subArray ) {
                value = subArray;
            }
            var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                meta = {
                    '\b': '\\b',
                    '\t': '\\t',
                    '\n': '\\n',
                    '\f': '\\f',
                    '\r': '\\r',
                    '"': '\\"',
                    '\\': '\\\\'
                };

            function quote( string ) {
                return '"' + string.replace( escapable, function ( a ) {
                    var c = meta[ a ];
                    return typeof c === 'string' ? c : '\\u' + ( '0000' + a.charCodeAt( 0 ).toString( 16 ) ).slice( -4 );
                } ) + '"';
            }

            function formatNumber( n ) {
                return n < 10 ? '0' + n : n;
            }

            function stringifyDate( value ) {
                var date;
                if ( isFinite( value.valueOf() ) ) {
                    date = value.getUTCFullYear() + '-' + formatNumber( value.getUTCMonth() + 1 ) + '-' +
                        formatNumber( value.getUTCDate() ) + 'T' + formatNumber( value.getUTCHours() ) + ':' +
                        formatNumber( value.getUTCMinutes() ) + ':' + formatNumber( value.getUTCSeconds() ) + 'Z"';
                } else {
                    date = 'null';
                }
                return date;
            }

            function stringifyArray( value ) {
                var len = value.length,
                    partial = [],
                    i;
                for ( i = 0; i < len; i++ ) {
                    partial.push( str( i, value ) || 'null' );
                }

                return '[' + partial.join( ',' ) + ']';
            }

            function stringifyObject( value ) {
                var partial = [],
                    i, v;
                for ( i in value ) {
                    if ( Object.prototype.hasOwnProperty.call( value, i ) ) {
                        if ( i != "" && keys && keys.indexOf( i ) === -1 ) {
                            continue;
                        }

                        v = str( i, value );
                        if ( v ) {
                            partial.push( quote( i ) + ':' + v );
                        }
                    }
                }
                return '{' + partial.join( ',' ) + '}';
            }

            function stringifyReference( value ) {
                switch ( Object.prototype.toString.call( value ) ) {
                    case '[object Date]':
                        return stringifyDate( value );
                    case '[object Array]':
                        return stringifyArray( value );
                }
                return stringifyObject( value );
            }

            function stringifyPrimitive( value, type ) {
                switch ( type ) {
                    case 'string':
                        return quote( value );
                    case 'number':
                    case 'float':
                    case 'integer':
                    case 'int':
                        return isFinite( value ) ? value : 'null';
                    case 'boolean':
                        return value;
                }
                return 'null';
            }

            function str( key, holder ) {
                var value = holder[ key ], type = typeof value;

                if ( value && typeof value === 'object' && typeof value.toJSON === 'function' ) {
                    value = value.toJSON( key );
                    type = typeof value;
                }
                if ( /(number|float|int|integer|string|boolean)/.test( type ) || ( !value && type === 'object' ) ) {
                    return stringifyPrimitive( value, type );
                } else {
                    return stringifyReference( value );
                }
            }
            if ( !keys && window.JSON && typeof window.JSON.stringify === 'function' ) {
                return window.JSON.stringify( value );
            }

            return str( "", { "": value } );
        }

        that.defineIndexProperty = function ( index ) {
            if ( !( index in that ) ) {
                var defineProperty = function ( obj, property, path, context ) {
                    var newValue = obj[ property ];
                    var oldValue = newValue;
                    var getter = function () {
                        return oldValue;
                    }
                    var setter = function ( val ) {
                        newValue = val;
                        if ( oldValue !== newValue ) {
                            var oldValueArg = oldValue;
                            oldValue = newValue;
                            if ( typeof notifier === "function" ) {
                                var index = array.indexOf( context );

                                var propertyPath = "";
                                var getPath = function ( obj, path ) {
                                    Object.getOwnPropertyNames( obj ).forEach( function ( name ) {
                                        var type = $.type( obj[ name ] );
                                        if ( type == "array" || type == "object" ) {
                                            getPath( obj[ name ], path + "." + name );
                                        }
                                        else if ( property === name ) {
                                            propertyPath = path + "." + name;
                                        }
                                    } );
                                }
                                getPath( context, index );

                                notifier( { object: that, type: 'update', path: propertyPath, index: index, name: property, newValue: newValue, oldValue: oldValueArg } );
                            }
                        }
                        oldValue = newValue;
                        return newValue;
                    }
                    if ( obj[ property ] != undefined && property != "length" ) {
                        if ( Object.defineProperty )
                            Object.defineProperty( obj, property, {
                                get: getter,
                                set: setter
                            } );
                        else if ( Object.prototype.__defineGetter__ && Object.prototype.__defineSetter__ ) {
                            Object.prototype.__defineGetter__.call( obj, property, getter );
                            Object.prototype.__defineSetter__.call( obj, property, setter );
                        }
                    }
                }

                var defineProperties = function ( obj, path, context ) {
                    var type = $.type( obj );
                    if ( /(number|float|int|integer|string|boolean)/.test( type ) ) {
                        return;
                    }

                    if ( obj === undefined ) {
                        return;
                    }

                    Object.getOwnPropertyNames( obj ).forEach( function ( name ) {
                        var type = $.type( obj[ name ] );
                        if ( type == "array" || type == "object" ) {
                            defineProperty( obj, name, path + "." + name, context );
                            defineProperties( obj[ name ], path + "." + name, context );
                        }
                        else {
                            defineProperty( obj, name, path + "." + name, context );
                        }
                    } );
                }

                Object.defineProperty( that, index, {
                    configurable: true,
                    enumerable: true,
                    get: function () {
                        return array[ index ];
                    },
                    set: function ( newValue ) {
                        var oldValue = array[ index ];
                        if ( that.toJSON( null, oldValue ) != that.toJSON( null, newValue ) ) {
                            array[ index ] = newValue;
                            if ( typeof notifier === "function" ) {
                                notifier( { object: that, type: 'update', path: index.toString(), index: index, name: "index", newValue: newValue, oldValue: oldValue } );
                            }
                            defineProperties( newValue, index, newValue );
                        }
                    }
                } );
                defineProperties( that[ index ], index, that[ index ] );
            }
        }

        that.push = function () {
            var index;
            for ( var i = 0, ln = arguments.length; i < ln; i++ ) {
                index = array.length;
                array.push( arguments[ i ] );
                that.defineIndexProperty( index );
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'add', name: "length", index: index, newValue: array.length, oldValue: index } );
                }
            }
            return array.length;
        };

        that.pop = function () {
            if ( ~array.length ) {
                var index = array.length - 1,
                    item = array.pop();
                delete that[ index ];
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'delete', name: "length", index: index, newValue: array.length, oldValue: index } );
                }
                return item;
            }
        };

        that.unshift = function () {
            var index = array.length;
            for ( var i = 0, ln = arguments.length; i < ln; i++ ) {
                array.splice( i, 0, arguments[ i ] );
                that.defineIndexProperty( array.length - 1 );
            }
            if ( typeof notifier === "function" ) {
                notifier( { object: that, type: 'add', index: 0, name: "length", newValue: array.length, oldValue: index } );
            }
            return array.length;
        };

        that.shift = function () {
            var index = array.length;
            if ( ~array.length ) {
                var item = array.shift();
                array.length === 0 && delete that[ index ];
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'delete', index: index, name: "length", newValue: array.length, oldValue: index } );
                }
                return item;
            }
        };

        that.slice = function ( start, end, observeFunction ) {
            var newArray = array.slice( start, end );
            var observableArray = new $.jqx.observableArray( newArray, observeFunction );
            return observableArray;
        }

        that.splice = function ( index, howMany, observeFunction ) {
            var removed = [],
                item,
                pos;

            index = !~index ? array.length - index : index;

            howMany = ( howMany == null ? array.length - index : howMany ) || 0;

            while ( howMany-- ) {
                item = array.splice( index, 1 )[ 0 ];
                removed.push( item );
                delete that[ array.length ];
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'delete', index: index, name: "length", newValue: -1, oldValue: index } );
                }
            }

            for ( var i = 2, ln = arguments.length; i < ln; i++ ) {
                array.splice( index, 0, arguments[ i ] );
                this.defineIndexProperty( array.length - 1 );
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'add', index: index, name: "length", newValue: array.length - 1, oldValue: index } );
                }
                index++;
            }

            var observableArray = new $.jqx.observableArray( removed, observeFunction );
            return observableArray;
        };

        Object.defineProperty( that, "length", {
            configurable: false,
            enumerable: true,
            get: function () {
                return array.length;
            },
            set: function ( value ) {
                var n = Number( value );
                if ( n % 1 === 0 && n >= 0 ) {
                    if ( n < array.length ) {
                        that.splice( n );
                    } else if ( n > array.length ) {
                        that.push.apply( that, new Array( n - array.length ) );
                    }
                } else {
                    throw new RangeError( "Invalid array length" );
                }
                return value;
            }
        } );

        $.jqx.observableArray.prototype.fromArray = function ( array, observeFunction ) {
            var observableArray = new $.jqx.observableArray( array, observeFunction );
            return observableArray;
        }

        $.jqx.observableArray.prototype.clone = function () {
            var observableArray = new $.jqx.observableArray( array, observeFunction );
            observableArray.observing = that.observing;
            observableArray.changes = that.changes;
            observableArray.notifier = that.notifier;
            return observableArray;
        }

        that.remove = function ( index ) {
            if ( index < 0 || index >= that.length ) {
                throw new Error( 'Invalid index : ' + index );
            }
            if ( that.hasOwnProperty( index ) ) {
                var oldValue = that[ index ];
                that[ index ] = undefined;
                array[ index ] = undefined;
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'delete', index: index, name: "index", newValue: undefined, oldValue: oldValue } );
                }
                return true;
            }
            return false;
        };

        that.concat = function ( args, observeFunction ) {
            var newArray = array.concat( args );
            var observableArray = new $.jqx.observableArray( newArray, observeFunction );
            return observableArray;
        };

        Object.getOwnPropertyNames( Array.prototype ).forEach( function ( name ) {
            if ( !( name in that ) ) {
                var fn = function () {
                    var tmp = that.observing;
                    that.observing = false;
                    var arrayFn = array[ name ];
                    var result = arrayFn.apply( array, arguments );
                    that.observing = tmp;
                    return result;
                }
                Object.defineProperty( that, name, {
                    configurable: false,
                    enumerable: true,
                    writeable: false,
                    value: fn
                } );
            }
        } );


        that.set = function ( index, value ) {
            if ( $.type( index ) == "string" && index.split( "." ).length > 1 ) {
                var items = index.split( "." );
                var obj = that;
                for ( var i = 0; i < items.length; i++ ) {
                    if ( i === 0 ) {
                        if ( items[ i ] >= that.length ) {
                            throw new Error( "Invalid Index: " + index );
                        }
                    }
                    if ( i < items.length - 1 ) {
                        obj = obj[ items[ i ] ];
                    }
                    else {
                        obj[ items[ i ] ] = value;
                    }
                }
                return true;
            }
            if ( index >= that.length ) {
                that.push( value );
            }
            else {
                that[ index ] = value;
            }
            return true;
        }

        that.get = function ( index ) {
            return that[ index ];
        }

        if ( items instanceof Array ) {
            that.push.apply( that, items );
        }

        notifier = function () {
            if ( !that.observing ) {
                return;
            }

            if ( arguments && arguments[ 0 ] ) {
                that.changes.push( arguments[ 0 ] );
            }

            if ( observeFunction ) {
                observeFunction.apply( that, arguments );
            }
            if ( that.notifier ) {
                that.notifier.apply( that, arguments );
            }
        }

        return that;
    }

    $.jqx.formatDate = function ( value, format, calendar ) {
        var result = $.jqx.dataFormat.formatdate( value, format, calendar );
        return result;
    }

    $.jqx.formatNumber = function ( value, format, calendar ) {
        var result = $.jqx.dataFormat.formatnumber( value, format, calendar );
        return result;
    }

    $.jqx.dataAdapter = function ( source, options ) {
        if ( source != undefined ) {
            if ( source.dataFields !== undefined ) {
                source.datafields = source.dataFields;
            }
            if ( source.dataType !== undefined ) {
                source.datatype = source.dataType;
            }
            if ( source.localData !== undefined ) {
                source.localdata = source.localData;
            }
            if ( source.sortColumn !== undefined ) {
                source.sortcolumn = source.sortColumn;
            }
            if ( source.sortDirection !== undefined ) {
                source.sortdirection = source.sortDirection;
            }
            if ( source.sortColumns !== undefined ) {
                source.sortcolumns = source.sortColumns;
            }
            if ( source.sortDirections !== undefined ) {
                source.sortdirections = source.sortDirections;
            }
            if ( source.sortOrder !== undefined ) {
                source.sortdirection = source.sortOrder;
            }
            if ( source.formatData !== undefined ) {
                source.formatdata = source.formatData;
            }
            if ( source.processData !== undefined ) {
                source.processdata = source.processData;
            }
            if ( source.pageSize !== undefined ) {
                source.pagesize = source.pageSize;
            }
            if ( source.pageNum !== undefined ) {
                source.pagenum = source.pageNum;
            }
            if ( source.updateRow !== undefined ) {
                source.updaterow = source.updateRow;
            }
            if ( source.addRow !== undefined ) {
                source.addrow = source.addRow;
            }
            if ( source.deleteRow !== undefined ) {
                source.deleterow = source.deleteRow;
            }
            if ( source.contentType !== undefined ) {
                source.contenttype = source.contentType;
            }
            if ( source.totalRecords != undefined ) {
                source.totalrecords = source.totalRecords;
            }
            if ( source.loadError != undefined ) {
                source.loadError = source.loadError;
            }
            if ( source.sortComparer != undefined ) {
                source.sortcomparer = source.sortComparer;
            }
        }

        this._source = source;
        this._options = options || {};
        if ( source.beforeLoadComplete != undefined ) {
            this._options.beforeLoadComplete = this._source.beforeLoadComplete;
        }
        if ( source.downloadComplete != undefined ) {
            this._options.downloadComplete = this._source.downloadComplete;
        }
        if ( source.loadComplete != undefined ) {
            this._options.loadComplete = this._source.loadComplete;
        }
        if ( source.autoBind != undefined ) {
            this._options.downloadComplete = this._source.autoBind;
        }
        if ( source.formatData != undefined ) {
            this._options.formatData = this._source.formatData;
        }
        if ( source.loadError != undefined ) {
            this._options.loadError = this._source.loadError;
        }
        if ( source.beforeSend != undefined ) {
            this._options.beforeSend = this._source.beforeSend;
        }
        if ( source.contentType != undefined ) {
            this._options.contentType = this._source.contentType;
        }
        if ( source.async != undefined ) {
            this._options.async = this._source.async;
        }
        if ( source.loadServerData != undefined ) {
            this._options.loadServerData = this._source.loadServerData;
        }
        if ( source.uniqueDataFields != undefined ) {
            this._options.uniqueDataFields = this._source.uniqueDataFields;
        }

        this.records = new Array();
        this._downloadComplete = new Array();
        this._bindingUpdate = new Array();

        if ( source != undefined && source.localdata != null && typeof source.localdata == "function" ) {
            var localData = source.localdata();
            if ( localData != null ) {
                source._localdata = source.localdata;
                var me = this;
                if ( source._localdata.subscribe ) {
                    me._oldlocaldata = [];
                    source._localdata.subscribe( function ( value ) {
                        var deepClone = function ( objThing ) {
                            if ( $.isArray( objThing ) ) {
                                return $.makeArray( deepClone( $( objThing ) ) );
                            }
                            return $.extend( true, {}, objThing );
                        };
                        if ( me.suspendKO == false || me.suspendKO == undefined || me._oldlocaldata.length == 0 ) {
                            me._oldlocaldata = deepClone( value );
                        }
                    }, source._localdata, 'beforeChange' );

                    source._localdata.subscribe( function ( value ) {
                        if ( me.suspendKO == false || me.suspendKO == undefined ) {
                            var changeType = "";
                            me._oldrecords = me.records;
                            if ( me._oldlocaldata.length == 0 ) {
                                source.localdata = source._localdata();
                            }

                            if ( me._oldlocaldata.length == 0 ) {
                                changeType = 'change';
                            }
                            else {
                                if ( value ) {
                                    if ( me._oldlocaldata.length == value.length ) {
                                        changeType = 'update';
                                    }
                                    if ( me._oldlocaldata.length > value.length ) {
                                        changeType = 'remove';
                                    }
                                    if ( me._oldlocaldata.length < value.length ) {
                                        changeType = 'add';
                                    }
                                }
                            }
                            me.dataBind( null, changeType );
                        }
                    }, source._localdata, 'change' );

                    me._knockoutdatasource = true;
                }

                source.localdata = localData;
            }
        }
        if ( this._options.autoBind == true ) {
            this.dataBind();
        }
    }

    $.jqx.dataAdapter.prototype = {
        getrecords: function () {
            return this.records;
        },

        beginUpdate: function () {
            this.isUpdating = true;
        },

        endUpdate: function ( refresh ) {
            this.isUpdating = false;
            if ( refresh != false ) {
                if ( this._changedrecords && this._changedrecords.length > 0 ) {
                    this.callBindingUpdate( "update" );
                    this._changedrecords = [];
                }
                else {
                    this.dataBind( null, "" );
                }
            }
        },

        formatDate: function ( value, format, calendar ) {
            var result = $.jqx.dataFormat.formatdate( value, format, calendar );
            return result;
        },

        formatNumber: function ( value, format, calendar ) {
            var result = $.jqx.dataFormat.formatnumber( value, format, calendar );
            return result;
        },

        dataBind: function ( objectuniqueId, collectionChanged ) {
            if ( this.isUpdating == true )
                return;

            var source = this._source;
            if ( !source )
                return;

            if ( source.generatedfields ) {
                source.datafields = null;
                source.generatedfields = null;
            }

            $.jqx.dataFormat.datescache = new Array();
            if ( source.dataFields != null ) {
                source.datafields = source.dataFields;
            }

            if ( source.recordstartindex == undefined ) {
                source.recordstartindex = 0;
            }
            if ( source.recordendindex == undefined ) {
                source.recordendindex = 0;
            }
            if ( source.loadallrecords == undefined ) {
                source.loadallrecords = true;
            }
            if ( source.root == undefined ) source.root = '';
            if ( source.record == undefined ) source.record = '';

            if ( source.sort != undefined ) {
                this.sort = source.sort;
            }

            if ( source.filter != undefined ) {
                this.filter = source.filter;
            }
            else this.filter = null;

            if ( source.sortcolumn != undefined ) {
                this.sortcolumn = source.sortcolumn;
            }

            if ( source.sortdirection != undefined ) {
                this.sortdirection = source.sortdirection;
            }
            if ( source.sortcolumns != undefined ) {
                this.sortcolumns = source.sortcolumns;
            }

            if ( source.sortdirections != undefined ) {
                this.sortdirections = source.sortdirections;
            }

            if ( source.sortcomparer != undefined ) {
                this.sortcomparer = source.sortcomparer;
            }

            this.records = new Array();
            var options = this._options || {};
            this.virtualmode = options.virtualmode != undefined ? options.virtualmode : false;
            this.totalrecords = options.totalrecords != undefined ? options.totalrecords : 0;
            this.pageable = options.pageable != undefined ? options.pageable : false;
            this.pagesize = options.pagesize != undefined ? options.pagesize : 0;
            this.pagenum = options.pagenum != undefined ? options.pagenum : 0;
            this.cachedrecords = options.cachedrecords != undefined ? options.cachedrecords : new Array();
            this.originaldata = new Array();
            this.recordids = new Array();
            this.updaterow = options.updaterow != undefined ? options.updaterow : null;
            this.addrow = options.addrow != undefined ? options.addrow : null;
            this.deleterow = options.deleterow != undefined ? options.deleterow : null;
            this.cache = options.cache != undefined ? options.cache : false;
            this.unboundmode = false;
            if ( source.formatdata != undefined ) {
                options.formatData = source.formatdata;
            }
            if ( source.data != undefined ) {
                if ( options.data == undefined ) {
                    options.data = {};
                }
                $.extend( options.data, source.data );
            }

            if ( source.mapChar != undefined ) {
                source.mapchar = source.mapChar;
            }

            if ( source.mapchar != undefined ) {
                this.mapChar = source.mapchar ? source.mapchar : '>';
            }
            else {
                this.mapChar = options.mapChar ? options.mapChar : '>';
            }

            if ( options.unboundmode || source.unboundmode ) {
                this.unboundmode = options.unboundmode || source.unboundmode;
            }

            if ( source.cache != undefined ) {
                this.cache = source.cache;
            }

            if ( this.koSubscriptions ) {
                for ( var subscription = 0; subscription < this.koSubscriptions.length; subscription++ ) {
                    this.koSubscriptions[ subscription ].dispose();
                }
            }
            this.koSubscriptions = new Array();

            if ( this.pagenum < 0 ) {
                this.pagenum = 0;
            }

            var me = this;

            var datatype = source.datatype;

            if ( source.datatype === 'csv' || source.datatype === 'tab' || source.datatype === 'tsv' || source.datatype == 'text' )
                datatype = 'text';

            var async = options.async != undefined ? options.async : true;

            if ( source.async != undefined ) {
                async = source.async;
            }

            if ( datatype === "xlsx" && source.url ) {
                source.localdata = [];
                datatype = "array";
                if ( window.jqxDataSource ) {
                    var data = new window.jqxDataSource( {
                        dataSource: source.url,
                        async: false,
                        dataFields: source.datafields
                    } );
                    data.notify( function () {
                        source.url = null;
                        source.localdata = data.boundSource;
                        source.datatype = "array";
                        me.dataBind();
                    } );
                }
            }

            switch ( datatype ) {
                case "local":
                case "array":
                case "observablearray":
                case "observableArray":
                default:
                    if ( source.localdata == undefined && source.length ) {
                        source.localdata = new Array();
                        for ( var i = 0; i < source.length; i++ ) {
                            source.localdata[ source.localdata.length ] = source[ i ];
                            source[ i ].uid = i;
                        }
                    }
                    if ( source.beforeprocessing && $.isFunction( source.beforeprocessing ) ) {
                        source.beforeprocessing( source.localdata );
                    }

                    var length = source.localdata.length;
                    this.totalrecords = this.virtualmode ? ( source.totalrecords || length ) : length;

                    if ( this.unboundmode ) {
                        this.totalrecords = this.unboundmode ? ( source.totalrecords || length ) : length;
                        var datafieldslength = source.datafields ? source.datafields.length : 0;
                        if ( datafieldslength > 0 ) {
                            for ( var i = 0; i < this.totalrecords; i++ ) {
                                var record = {};
                                for ( var j = 0; j < datafieldslength; j++ ) {
                                    record[ source.datafields[ j ].name ] = "";
                                }
                                record.uid = i;
                                source.localdata[ source.localdata.length ] = record;
                            }
                        }
                    }

                    if ( this.totalrecords == undefined ) {
                        this.totalrecords = 0;
                    }

                    var datafieldslength = source.datafields ? source.datafields.length : 0;
                    var getrecord = function ( record, datafieldslength ) {
                        var datarow = {};
                        for ( var j = 0; j < datafieldslength; j++ ) {
                            var datafield = source.datafields ? source.datafields[ j ] : {};
                            var value = '';
                            if ( undefined == datafield || datafield == null ) {
                                continue;
                            }

                            if ( datafield.map ) {
                                if ( $.isFunction( datafield.map ) ) {
                                    value = datafield.map( record );
                                }
                                else {
                                    var splitMap = datafield.map.split( me.mapChar );
                                    if ( splitMap.length > 0 ) {
                                        var datarecord = record;
                                        for ( var p = 0; p < splitMap.length; p++ ) {
                                            if ( !datarecord ) continue;
                                            datarecord = datarecord[ splitMap[ p ] ];
                                        }
                                        value = datarecord;
                                    }
                                    else {
                                        value = record[ datafield.map ];
                                    }
                                }

                                if ( value != undefined && value != null ) {
                                    value = value.toString();
                                }
                                else {
                                    if ( value == undefined && value != null ) {
                                        value = '';
                                    }
                                }
                            }
                            var isEmptyString = false;
                            // searches by both selectors when necessary.
                            if ( value == '' ) {
                                isEmptyString = true;
                                value = record[ datafield.name ];
                                if ( value != undefined && value != null ) {
                                    if ( source._localdata && value.subscribe ) {
                                        value = value();
                                    }
                                    else {
                                        if ( datafield.type != "array" ) {
                                            if ( datafield.type === 'date' ) {
                                                if ( value && value instanceof Date ) {
                                                    value = value;
                                                }
                                            }
                                            else {
                                                value = value.toString();
                                            }
                                        }
                                    }
                                }
                            }
                            if ( value == "[object Object]" && datafield.map && isEmptyString ) {
                                value = '';
                            }

                            value = me.getvaluebytype( value, datafield );
                            if ( datafield.displayname != undefined ) {
                                datarow[ datafield.displayname ] = value;
                            }
                            else {
                                datarow[ datafield.name ] = value;
                            }
                        }
                        return datarow;
                    }

                    if ( source._localdata ) {
                        this._changedrecords = [];
                        this.records = new Array();
                        var localdata = source._localdata();

                        $.each( localdata, function ( i, value ) {
                            if ( typeof value === 'string' ) {
                                me.records.push( value );
                            }
                            else {
                                var record = {};
                                var _koindex = 0;
                                var dataObject = this;
                                $.each( this, function ( obj, objvalue ) {
                                    var map = null;
                                    var type = 'string';
                                    var dataFieldName = obj;
                                    if ( datafieldslength > 0 ) {
                                        var hasField = false;
                                        var hasMap = false;
                                        for ( var j = 0; j < datafieldslength; j++ ) {
                                            var datafield = source.datafields[ j ];
                                            if ( datafield != undefined && ( datafield.name == obj ) ) {
                                                hasField = true;
                                                map = datafield.map;
                                                type = datafield.type;
                                                dataFieldName = datafield.name;
                                                break;
                                            }
                                            else if ( datafield != undefined && datafield.map && ( datafield.map.indexOf( obj ) >= 0 ) ) {
                                                hasField = true;
                                                map = datafield.map;
                                                type = datafield.type;
                                                dataFieldName = datafield.name;
                                                hasMap = true;
                                                var value = dataObject[ obj ];
                                                if ( map != null ) {
                                                    var splitMap = map.split( me.mapChar );
                                                    if ( splitMap.length > 0 ) {
                                                        var datarecord = dataObject;
                                                        for ( var p = 0; p < splitMap.length; p++ ) {
                                                            datarecord = datarecord[ splitMap[ p ] ];
                                                        }
                                                        value = datarecord;
                                                    }
                                                    else {
                                                        value = dataObject[ map ];
                                                    }
                                                }

                                                if ( type != 'string' ) {
                                                    value = me.getvaluebytype( value, { type: type } );
                                                }
                                                record[ dataFieldName ] = value;
                                                if ( record[ dataFieldName ] != undefined ) {
                                                    _koindex += record[ dataFieldName ].toString().length + record[ dataFieldName ].toString().substr( 0, 1 );
                                                }
                                            }
                                        }
                                        if ( !hasField ) return true;
                                        if ( hasMap ) return true;
                                    }

                                    var isFunction = $.isFunction( dataObject[ obj ] );
                                    if ( isFunction ) {
                                        var value = dataObject[ obj ]();
                                        if ( type != 'string' ) {
                                            value = me.getvaluebytype( value, { type: type } );
                                        }
                                        record[ obj ] = value;
                                        if ( dataObject[ obj ].subscribe ) {
                                            var recordindex = i;
                                            me.koSubscriptions[ me.koSubscriptions.length ] = dataObject[ obj ].subscribe( function ( value ) {
                                                var _changeindex = recordindex;
                                                record[ obj ] = value;
                                                var changedRecord = { index: _changeindex, oldrecord: record, record: record };
                                                me._changedrecords.push( changedRecord );
                                                if ( me.isUpdating )
                                                    return;

                                                me.callBindingUpdate( "update" );
                                                me._changedrecords = [];
                                                return false;
                                            } );
                                        }
                                    }
                                    else {
                                        var value = dataObject[ obj ];
                                        if ( map != null ) {
                                            var splitMap = map.split( me.mapChar );
                                            if ( splitMap.length > 0 ) {
                                                var datarecord = dataObject;
                                                for ( var p = 0; p < splitMap.length; p++ ) {
                                                    datarecord = datarecord[ splitMap[ p ] ];
                                                }
                                                value = datarecord;
                                            }
                                            else {
                                                value = dataObject[ map ];
                                            }
                                        }

                                        if ( type != 'string' ) {
                                            value = me.getvaluebytype( value, { type: type } );
                                        }
                                        record[ dataFieldName ] = value;
                                        if ( record[ dataFieldName ] != undefined ) {
                                            _koindex += record[ dataFieldName ].toString().length + record[ dataFieldName ].toString().substr( 0, 1 );
                                        }
                                    }
                                } );

                                var recordid = me.getid( source.id, dataObject, i );
                                record.uid = recordid;
                                me.records.push( record );

                                record._koindex = _koindex;
                                if ( me._oldrecords ) {
                                    var _changeindex = me.records.length - 1;
                                    if ( collectionChanged == 'update' ) {
                                        if ( me._oldrecords[ _changeindex ]._koindex != _koindex ) {
                                            var changedRecord = { index: _changeindex, oldrecord: me._oldrecords[ _changeindex ], record: record };
                                            me._changedrecords.push( changedRecord );
                                        }
                                    }
                                }
                            }
                        } );
                        if ( collectionChanged == 'add' ) {
                            var length = me.records.length;
                            for ( var i = 0; i < length; i++ ) {
                                var record = me.records[ i ];
                                var hasOldRecord = false;
                                for ( var p = 0; p < me._oldrecords.length; p++ ) {
                                    if ( me._oldrecords[ p ]._koindex === record._koindex ) {
                                        hasOldRecord = true;
                                        break;
                                    }
                                }
                                if ( !hasOldRecord ) {
                                    me._changedrecords.push( { index: i, oldrecord: null, record: record, position: ( i != 0 ? "last" : "first" ) } );
                                }
                            }
                        }
                        else if ( collectionChanged == 'remove' ) {
                            var length = me._oldrecords.length;
                            for ( var i = 0; i < length; i++ ) {
                                var oldrecord = me._oldrecords[ i ];
                                if ( !me.records[ i ] ) {
                                    me._changedrecords.push( { index: i, oldrecord: oldrecord, record: null } );
                                }
                                else {
                                    if ( me.records[ i ]._koindex != oldrecord._koindex ) {
                                        me._changedrecords.push( { index: i, oldrecord: oldrecord, record: null } );
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if ( !$.isArray( source.localdata ) ) {
                            this.records = new Array();
                            var fields = 0;
                            var generatedfields = new Array();
                            $.each( source.localdata, function ( i ) {
                                var recordid = me.getid( source.id, this, i );
                                if ( datafieldslength == 0 ) {
                                    if ( !( typeof this === "string" || this instanceof String ) ) {
                                        for ( var obj in this ) {
                                            fields++;
                                            var valueType = $.type( this[ obj ] );

                                            generatedfields.push( { name: obj, type: valueType } );
                                        }
                                        datafieldslength = fields;
                                        source.datafields = generatedfields;
                                        source.generatedfields = generatedfields;
                                    }
                                }
                                if ( datafieldslength > 0 ) {
                                    var record = this;
                                    var datarow = getrecord( record, datafieldslength );
                                    datarow.uid = recordid;
                                    me.records[ me.records.length ] = datarow;
                                }
                                else {
                                    this.uid = recordid;
                                    me.records[ me.records.length ] = this;
                                }
                            } );
                        }
                        else {
                            if ( datafieldslength == 0 ) {
                                var fields = 0;
                                var generatedfields = new Array();

                                $.each( source.localdata, function ( i, value ) {
                                    //      var record = $.extend({}, this);
                                    var record = new Object( this );
                                    if ( typeof value === "string" ) {
                                        me.records = source.localdata;
                                        return false;
                                    }
                                    else {
                                        var recordid = me.getid( source.id, record, i );
                                        if ( typeof ( recordid ) === "object" ) {
                                            recordid = i;
                                        }
                                        record.uid = recordid;
                                        if ( i == 0 ) {
                                            for ( var obj in this ) {
                                                fields++;
                                                var valueType = $.type( this[ obj ] );

                                                generatedfields.push( { name: obj, type: valueType } );
                                            }
                                            datafieldslength = fields;
                                            source.datafields = generatedfields;
                                            source.generatedfields = generatedfields;
                                        }
                                        if ( datafieldslength > 0 ) {
                                            var datarow = getrecord( record, datafieldslength );
                                            datarow.uid = recordid;
                                            me.records[ me.records.length ] = datarow;
                                        }
                                        else {
                                            me.records[ me.records.length ] = record;
                                        }
                                    }
                                } );
                            }
                            else {
                                $.each( source.localdata, function ( i ) {
                                    var record = this;
                                    var datarow = getrecord( record, datafieldslength );
                                    var recordid = me.getid( source.id, datarow, i );
                                    if ( typeof ( recordid ) === "object" ) {
                                        recordid = i;
                                    }
                                    //      var record = $.extend({}, datarow);
                                    var record = new Object( datarow );
                                    record.uid = recordid;
                                    me.records[ me.records.length ] = record;
                                } );
                            }
                        }
                    }

                    this.originaldata = source.localdata;
                    this.cachedrecords = this.records;
                    this.addForeignValues( source );
                    if ( options.uniqueDataFields ) {
                        var uniquerecords = this.getUniqueRecords( this.records, options.uniqueDataFields );
                        this.records = uniquerecords;
                        this.cachedrecords = uniquerecords;
                    }

                    if ( options.beforeLoadComplete ) {
                        var newRecords = options.beforeLoadComplete( me.records, this.originaldata );
                        if ( newRecords != undefined ) {
                            me.records = newRecords;
                            me.cachedrecords = newRecords;
                        }
                    }

                    if ( options.autoSort && options.autoSortField ) {
                        var tmpToString = Object.prototype.toString;
                        Object.prototype.toString = ( typeof field == "function" ) ? field : function () { return this[ options.autoSortField ] };
                        me.records.sort( function ( value1, value2 ) {
                            if ( value1 === undefined ) { value1 = null; }
                            if ( value2 === undefined ) { value2 = null; }
                            if ( value1 === null && value2 === null ) {
                                return 0;
                            }
                            if ( value1 === null && value2 !== null ) {
                                return 1;
                            }
                            if ( value1 !== null && value2 === null ) {
                                return -1;
                            }

                            value1 = value1.toString();
                            value2 = value2.toString();
                            if ( value1 === null && value2 === null ) {
                                return 0;
                            }
                            if ( value1 === null && value2 !== null ) {
                                return 1;
                            }
                            if ( value1 !== null && value2 === null ) {
                                return -1;
                            }
                            if ( $.jqx.dataFormat.isNumber( value1 ) && $.jqx.dataFormat.isNumber( value2 ) ) {
                                if ( value1 < value2 ) { return -1; }
                                if ( value1 > value2 ) { return 1; }
                                return 0;
                            }
                            else if ( $.jqx.dataFormat.isDate( value1 ) && $.jqx.dataFormat.isDate( value2 ) ) {
                                if ( value1 < value2 ) { return -1; }
                                if ( value1 > value2 ) { return 1; }
                                return 0;
                            }
                            else if ( !$.jqx.dataFormat.isNumber( value1 ) && !$.jqx.dataFormat.isNumber( value2 ) ) {
                                value1 = String( value1 ).toLowerCase();
                                value2 = String( value2 ).toLowerCase();
                            }

                            try {
                                if ( value1 < value2 ) { return -1; }
                                if ( value1 > value2 ) { return 1; }
                            }
                            catch ( error ) {
                                var er = error;
                            }

                            return 0;
                        } );
                        Object.prototype.toString = tmpToString;
                    }

                    me.loadedData = source.localdata;
                    me.buildHierarchy();

                    if ( $.isFunction( options.loadComplete ) ) {
                        options.loadComplete( source.localdata, me.records );
                    }
                    break;
                case "json":
                case "jsonp":
                case "xml":
                case "xhtml":
                case "script":
                case "text":
                case "ics":
                    {
                        if ( source.localdata != null && !source.url ) {
                            if ( $.isFunction( source.beforeprocessing ) ) {
                                source.beforeprocessing( source.localdata );
                            }
                            if ( source.datatype === "xml" ) {
                                me.loadxml( source.localdata, source.localdata, source );
                            }
                            else if ( datatype === "text" ) {
                                me.loadtext( source.localdata, source );
                            }
                            else if ( datatype === "ics" ) {
                                me.loadics( source.localdata, source );
                            }
                            else {
                                me.loadjson( source.localdata, source.localdata, source );
                            }
                            me.addForeignValues( source );
                            if ( options.uniqueDataFields ) {
                                var uniquerecords = me.getUniqueRecords( me.records, options.uniqueDataFields );
                                me.records = uniquerecords;
                                me.cachedrecords = uniquerecords;
                            }

                            if ( options.beforeLoadComplete ) {
                                var newRecords = options.beforeLoadComplete( me.records, this.originaldata );
                                if ( newRecords != undefined ) {
                                    me.records = newRecords;
                                    me.cachedrecords = newRecords;
                                }
                            }

                            me.loadedData = source.localdata;
                            me.buildHierarchy.call( me );
                            if ( $.isFunction( options.loadComplete ) ) {
                                options.loadComplete( source.localdata, me.records );
                            }
                            me.callBindingUpdate( collectionChanged );
                            return;
                        }

                        var postdata = options.data != undefined ? options.data : {};
                        // call the source object's processdata function.
                        if ( source.processdata ) {
                            source.processdata( postdata );
                        }
                        // call the adapter's process data function.
                        if ( $.isFunction( options.processData ) ) {
                            options.processData( postdata );
                        }

                        // call the adapter's format data function.
                        if ( $.isFunction( options.formatData ) ) {
                            var newpostdata = options.formatData( postdata );
                            if ( newpostdata != undefined ) {
                                postdata = newpostdata;
                            }
                        }

                        var contentType = 'application/x-www-form-urlencoded';
                        if ( options.contentType ) {
                            contentType = options.contentType;
                        }

                        var type = "GET";
                        if ( source.type ) {
                            type = source.type;
                        }

                        if ( options.type ) {
                            type = options.type;
                        }

                        var dataType = datatype;
                        if ( datatype == "ics" ) dataType = "text";
                        if ( source.url && source.url.length > 0 ) {
                            if ( $.isFunction( options.loadServerData ) ) {
                                me._requestData( postdata, source, options );
                            }
                            else {
                                this.xhr = $.jqx.data.ajax( {
                                    dataType: dataType,
                                    cache: this.cache,
                                    type: type,
                                    url: source.url,
                                    async: async,
                                    timeout: source.timeout,
                                    contentType: contentType,
                                    data: postdata,
                                    success: function ( data, status, xhr ) {
                                        if ( $.isFunction( source.beforeprocessing ) ) {
                                            var tmpdata = source.beforeprocessing( data, status, xhr );
                                            if ( tmpdata != undefined ) {
                                                data = tmpdata;
                                            }
                                        }
                                        if ( $.isFunction( options.downloadComplete ) ) {
                                            var tmpdata = options.downloadComplete( data, status, xhr );
                                            if ( tmpdata != undefined ) {
                                                data = tmpdata;
                                            }
                                        }

                                        if ( data == null ) {
                                            me.records = new Array();
                                            me.cachedrecords = new Array();
                                            me.originaldata = new Array();

                                            me.callDownloadComplete();
                                            if ( $.isFunction( options.loadComplete ) ) {
                                                options.loadComplete( new Array() );
                                            }
                                            return;
                                        }

                                        var records = data;
                                        if ( data.records ) {
                                            records = data.records;
                                        }

                                        if ( data.totalrecords != undefined ) {
                                            source.totalrecords = data.totalrecords;
                                        }
                                        else if ( data.totalRecords != undefined ) {
                                            source.totalrecords = data.totalRecords;
                                        }

                                        if ( source.datatype === "xml" ) {
                                            me.loadxml( null, records, source );
                                        }
                                        else if ( datatype === "text" ) {
                                            me.loadtext( records, source );
                                        }
                                        else if ( datatype === "ics" ) {
                                            me.loadics( records, source );
                                        }
                                        else {
                                            me.loadjson( null, records, source );
                                        }

                                        // add foreign values.
                                        me.addForeignValues( source );

                                        if ( options.uniqueDataFields ) {
                                            var uniquerecords = me.getUniqueRecords( me.records, options.uniqueDataFields );
                                            me.records = uniquerecords;
                                            me.cachedrecords = uniquerecords;
                                        }

                                        if ( options.beforeLoadComplete ) {
                                            var newRecords = options.beforeLoadComplete( me.records, data );
                                            if ( newRecords != undefined ) {
                                                me.records = newRecords;
                                                me.cachedrecords = newRecords;
                                            }
                                        }

                                        me.loadedData = data;
                                        me.buildHierarchy.call( me );

                                        me.callDownloadComplete();
                                        if ( $.isFunction( options.loadComplete ) ) {
                                            options.loadComplete( data, status, xhr, me.records );
                                        }
                                    },
                                    error: function ( xhr, status, error ) {
                                        if ( $.isFunction( source.loaderror ) ) { source.loaderror( xhr, status, error ); }
                                        if ( $.isFunction( options.loadError ) ) { options.loadError( xhr, status, error ); }
                                        xhr = null;
                                        me.callDownloadComplete();
                                    },
                                    beforeSend: function ( xhr, settings ) {
                                        if ( $.isFunction( options.beforeSend ) ) { options.beforeSend( xhr, settings ); }
                                        if ( $.isFunction( source.beforesend ) ) { source.beforesend( xhr, settings ); }
                                    }
                                } );
                            }
                        }
                        else {
                            me.buildHierarchy( new Array() );
                            me.callDownloadComplete();
                            if ( $.isFunction( options.loadComplete ) ) {
                                if ( !data ) {
                                    var data = {};
                                }
                                options.loadComplete( data );
                            }
                        }
                    }
                    break;
            }
            this.callBindingUpdate( collectionChanged );
        },

        buildHierarchy: function ( dataRecords ) {
            var source = this._source;
            var hierarchy = new Array();
            if ( !source.datafields ) {
                return;
            }

            if ( source.hierarchy && !source.hierarchy.reservedNames ) {
                source.hierarchy.reservedNames = {
                    leaf: "leaf",
                    parent: "parent",
                    expanded: "expanded",
                    checked: "checked",
                    selected: "selected",
                    level: "level",
                    icon: "icon",
                    data: "data"
                }
            }
            else {
                if ( source.hierarchy ) {
                    var names = source.hierarchy.reservedNames;
                    if ( !names.leaf ) names.leaf = "leaf";
                    if ( !names.parent ) names.parent = "parent";
                    if ( !names.expanded ) names.expanded = "expanded";
                    if ( !names.checked ) names.checked = "checked";
                    if ( !names.selected ) names.selected = "selected";
                    if ( !names.level ) names.level = "level";
                    if ( !names.data ) names.data = "data";
                }
            }

            if ( !source.hierarchy ) {
                return;
            }

            var that = this;
            var names = source.hierarchy.reservedNames;
            if ( source.hierarchy.root ) {
                if ( source.dataType == "xml" ) {
                    var hierarchy = this.getRecordsHierarchy( 'uid', 'parentuid', 'records', null, dataRecords );
                    this.hierarchy = hierarchy;
                    return hierarchy;
                }
                else {
                    this.hierarchy = this.records;
                    var root = source.hierarchy.root;
                    for ( var i = 0; i < this.records.length; i++ ) {
                        var record = this.records[ i ];
                        if ( !record ) {
                            continue;
                        }

                        var addRecords = function ( record ) {
                            if ( source.hierarchy.record ) {
                                record.records = record[ root ][ source.hierarchy.record ];
                            }
                            else {
                                var splitMap = root.split( that.mapChar );
                                var records = null;
                                if ( splitMap.length > 1 ) {
                                    var d = record;
                                    for ( var p = 0; p < splitMap.length; p++ ) {
                                        if ( d != undefined ) {
                                            d = d[ splitMap[ p ] ];
                                        }
                                    }
                                    records = d;
                                }
                                else records = record[ root ];
                                record.records = records;
                            }
                            if ( record.records == null || ( record.records && record.records.length == 0 ) ) {
                                record[ names.leaf ] = true;
                            }
                        }
                        addRecords( record );
                        record[ names.level ] = 0;
                        var recordid = this.getid( source.id, record, i );
                        record.uid = recordid;
                        record[ names.parent ] = null;
                        record[ names.data ] = record;
                        if ( record[ names.expanded ] === undefined ) {
                            record[ names.expanded ] = false;
                        }
                        var drillThrough = function ( parent, records ) {
                            if ( !records ) {
                                parent.records = new Array();
                                return;
                            }

                            for ( var i = 0; i < records.length; i++ ) {
                                var record = records[ i ];
                                if ( !record ) {
                                    continue;
                                }

                                addRecords( record );
                                record[ names.level ] = parent[ names.level ] + 1;
                                record[ names.parent ] = parent;
                                record[ names.data ] = record;
                                var recordid = that.getid( source.id, record, i );
                                if ( recordid == i && source.id == null ) {
                                    record.uid = parent.uid + "_" + recordid;
                                }
                                else {
                                    record.uid = recordid;
                                }

                                if ( record[ names.expanded ] === undefined ) {
                                    record[ names.expanded ] = false;
                                }
                                drillThrough( record, record.records );
                            }
                        }
                        drillThrough( record, record.records );
                    }
                }
                return this.hierarchy;
            }

            if ( source.hierarchy.keyDataField && source.hierarchy.parentDataField ) {
                var hierarchy = this.getRecordsHierarchy( source.hierarchy.keyDataField.name, source.hierarchy.parentDataField.name, 'records', null, dataRecords );
                this.hierarchy = hierarchy;
                return hierarchy;
            }

            if ( source.hierarchy.groupingDataFields ) {
                var groups = new Array();
                for ( var i = 0; i < source.hierarchy.groupingDataFields.length; i++ ) {
                    groups.push( source.hierarchy.groupingDataFields[ i ].name );
                }

                var hierarchy = this.getGroupedRecords( groups, 'records', 'label', null, 'data', null, 'parent', dataRecords );
                this.hierarchy = hierarchy;
                return hierarchy;
            }
        },

        addRecord: function ( record, position, parentID, virtualMode ) {
            var that = this;
            var reservedNames = function () {
                return {
                    leaf: "leaf",
                    parent: "parent",
                    expanded: "expanded",
                    checked: "checked",
                    selected: "selected",
                    level: "level",
                    icon: "icon",
                    data: "data"
                }
            }
            if ( record != undefined ) {
                if ( parentID != undefined ) {
                    if ( this.hierarchy.length > 0 ) {
                        var traverse = function ( records ) {
                            if ( records ) {
                                for ( var i = 0; i < records.length; i++ ) {
                                    var r = records[ i ];
                                    if ( r.uid == parentID ) {
                                        var names = ( that._source && that._source.hierarchy ) ? that._source.hierarchy.reservedNames : null;
                                        if ( names == null ) names = reservedNames();

                                        record[ names.parent ] = r;
                                        record[ names.level ] = r[ names.level ] + 1;

                                        if ( !r.records ) {
                                            r.records = new Array();
                                            r[ names.leaf ] = false;
                                        }
                                        else {
                                            r[ names.leaf ] = false;
                                        }

                                        if ( position == 'last' ) {
                                            r.records.push( record );
                                        }
                                        else if ( typeof position === 'number' && isFinite( position ) ) {
                                            r.records.splice( position, 0, record );
                                        }
                                        else {
                                            r.records.splice( 0, 0, record );
                                        }
                                        return true;
                                    }
                                    if ( r.records ) {
                                        traverse( r.records );
                                    }
                                }
                            }
                        }
                        traverse( this.hierarchy );
                    }
                }
                else {
                    if ( this.hierarchy && this.hierarchy.length >= 0 && ( this._source.hierarchy || virtualMode ) ) {
                        var names = ( that._source && that._source.hierarchy ) ? that._source.hierarchy.reservedNames : null;
                        if ( names == null ) names = reservedNames();

                        record[ names.level ] = 0;

                        if ( position == 'last' ) {
                            this.hierarchy.push( record );
                        }
                        else if ( typeof position === 'number' && isFinite( position ) ) {
                            this.hierarchy.splice( position, 0, record );
                        }
                        else {
                            this.hierarchy.splice( 0, 0, record );
                        }
                    }
                    else {
                        if ( position == 'last' ) {
                            this.records.push( record );
                        }
                        else if ( typeof position === 'number' && isFinite( position ) ) {
                            this.records.splice( position, 0, record );
                        }
                        else {
                            this.records.splice( 0, 0, record );
                        }
                    }
                    return true;
                }
            }
            return false;
        },

        deleteRecord: function ( uid ) {
            var that = this;
            if ( this.hierarchy.length > 0 ) {
                var traverse = function ( records ) {
                    if ( records ) {
                        for ( var i = 0; i < records.length; i++ ) {
                            var r = records[ i ];
                            if ( r.uid == uid ) {
                                records.splice( i, 1 );
                                if ( that.recordids[ uid ] ) {
                                    delete that.recordids[ uid ];
                                }

                                var removeChildren = function ( children ) {
                                    for ( var x = 0; x < children.length; x++ ) {
                                        var uid = children[ x ].uid;
                                        for ( var j = 0; j < that.records.length; j++ ) {
                                            var r = that.records[ j ];
                                            if ( r.uid == uid ) {
                                                that.records.splice( j, 1 );
                                                break;
                                            }
                                        }
                                        if ( children[ x ].records ) {
                                            removeChildren( children[ x ].records );
                                        }
                                    }
                                }
                                if ( r.records ) {
                                    removeChildren( r.records );
                                }
                                for ( var j = 0; j < that.records.length; j++ ) {
                                    var r = that.records[ j ];
                                    if ( r.uid == uid ) {
                                        that.records.splice( j, 1 );
                                        break;
                                    }
                                }
                                return true;
                            }
                            if ( r.records ) {
                                traverse( r.records );
                            }
                        }
                    }
                }
                traverse( this.hierarchy );
            }
            else {
                for ( var i = 0; i < this.records.length; i++ ) {
                    var r = this.records[ i ];
                    if ( r.uid == uid ) {
                        this.records.splice( i, 1 );
                        return true;
                    }
                }
            }
            return false;
        },

        addForeignValues: function ( source ) {
            var me = this;
            var datafieldslength = source.datafields ? source.datafields.length : 0;
            for ( var j = 0; j < datafieldslength; j++ ) {
                var datafield = source.datafields[ j ];
                if ( datafield != undefined ) {
                    if ( datafield.values != undefined ) {
                        if ( datafield.value == undefined ) datafield.value = datafield.name;
                        if ( datafield.values[ 'value' ] == undefined ) {
                            datafield.values[ 'value' ] = datafield.value;
                        }

                        var matchedIDs = new Array();
                        var start, end;
                        if ( me.pageable && me.virtualmode ) {
                            start = me.pagenum * me.pagesize;
                            end = start + me.pagesize;
                            if ( end > me.totalrecords ) {
                                end = me.totalrecords;
                            }
                        }
                        else if ( me.virtualmode ) {
                            start = source.recordstartindex;
                            end = source.recordendindex;
                            if ( end > me.totalrecords ) {
                                end = me.totalrecords;
                            }
                        }
                        else {
                            start = 0;
                            end = me.records.length;
                        }

                        for ( var i = start; i < end; i++ ) {
                            var record = me.records[ i ];
                            var name = datafield.name;
                            var value = record[ datafield.value ];

                            if ( matchedIDs[ value ] != undefined ) {
                                record[ name ] = matchedIDs[ value ];
                            }
                            else {
                                for ( var p = 0; p < datafield[ 'values' ].source.length; p++ ) {
                                    var sourcerecord = datafield.values.source[ p ];
                                    var sourcevalue = sourcerecord[ datafield.values[ 'value' ] ];
                                    if ( sourcevalue == undefined ) {
                                        sourcevalue = sourcerecord.uid;
                                    }
                                    if ( sourcevalue == value ) {
                                        var label = sourcerecord[ datafield.values[ 'name' ] ];
                                        record[ name ] = label;
                                        matchedIDs[ value ] = label;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    else if ( datafield.value != undefined ) {
                        for ( var i = 0; i < me.records.length; i++ ) {
                            var record = me.records[ i ];
                            record[ datafield.name ] = record[ datafield.value ];
                        }
                    }
                }
            }
        },

        abort: function () {
            if ( this.xhr && this.xhr.readyState != 4 ) {
                this.xhr.abort();
                this.callDownloadComplete();
            }
        },

        _requestData: function ( postdata, source, options ) {
            var me = this;
            var success = function ( requestedData ) {
                if ( requestedData.totalrecords ) {
                    source.totalrecords = requestedData.totalrecords;
                    me.totalrecords = requestedData.totalrecords;
                }
                if ( requestedData.records ) {
                    me.records = requestedData.records;
                    me.cachedrecords = requestedData.records;
                }
                // add foreign values.
                me.addForeignValues( source );

                if ( options.uniqueDataFields ) {
                    var uniquerecords = me.getUniqueRecords( me.records, options.uniqueDataFields );
                    me.records = uniquerecords;
                    me.cachedrecords = uniquerecords;
                }

                if ( options.beforeLoadComplete ) {
                    var newRecords = options.beforeLoadComplete( me.records, requestedData );
                    if ( newRecords != undefined ) {
                        me.records = newRecords;
                        me.cachedrecords = newRecords;
                    }
                }
                for ( var i = 0; i < me.records.length; i++ ) {
                    var record = me.records[ i ];
                    if ( undefined == record ) {
                        continue;
                    }

                    if ( undefined == record.uid ) {
                        record.uid = me.getid( source.id, record, i );
                    }
                }

                me.buildHierarchy.call( me );
                if ( $.isFunction( options.loadComplete ) ) {
                    options.loadComplete( requestedData );
                }
                me.callDownloadComplete();
            }
            options.loadServerData( postdata, source, success );
        },

        getUniqueRecords: function ( records, dataFields ) {
            if ( records && dataFields ) {
                var length = records.length;
                var datafieldslength = dataFields.length;

                var uniqueRecords = new Array();
                var lookupkeys = new Array();
                // loop through all records.
                for ( var urec = 0; urec < length; urec++ ) {
                    var datarow = records[ urec ];
                    var lookupkey = "";
                    if ( datarow == undefined )
                        continue;
                    // build lookup key from the datafield values.
                    for ( var datafieldindex = 0; datafieldindex < datafieldslength; datafieldindex++ ) {
                        var datafield = dataFields[ datafieldindex ];
                        if ( datarow[ datafield ] !== undefined ) {
                            lookupkey += datarow[ datafield ] + "_";
                        }
                    }
                    // add the unique record.
                    if ( !lookupkeys[ lookupkey ] && lookupkey ) {
                        uniqueRecords[ uniqueRecords.length ] = datarow;
                    }
                    // add the lookup key.
                    lookupkeys[ lookupkey ] = true;
                }
            }

            return uniqueRecords;
        },

        getAggregatedData: function ( aggregates, calendar, records, level ) {
            var dataRecords = records;
            if ( !dataRecords ) {
                dataRecords = this.records;
            }
            var data = {};
            var dataValuesByAggregate = new Array();
            var length = dataRecords.length;
            if ( length == 0 ) return;
            if ( length == undefined ) return;
            for ( var i = 0; i < length; i++ ) {
                var record = dataRecords[ i ];
                for ( var j = 0; j < aggregates.length; j++ ) {
                    var aggregate = aggregates[ j ];
                    var value = record[ aggregate.name ];
                    //            if (value === null) continue;
                    if ( aggregate.aggregates ) {
                        data[ aggregate.name ] = data[ aggregate.name ] || {};
                        dataValuesByAggregate[ aggregate.name ] = dataValuesByAggregate[ aggregate.name ] || 0;
                        dataValuesByAggregate[ aggregate.name ]++;
                        var _customCalcFunc = function ( aggObject ) {
                            for ( var obj in aggObject ) {
                                var oldValue = data[ aggregate.name ][ obj ];
                                if ( oldValue == null ) {
                                    data[ aggregate.name ][ obj ] = 0;
                                    oldValue = 0;
                                }
                                if ( $.isFunction( aggObject[ obj ] ) ) {
                                    oldValue = aggObject[ obj ]( oldValue, value, aggregate.name, record, level );
                                }
                                data[ aggregate.name ][ obj ] = oldValue;
                            }
                        }

                        var canParse = parseFloat( value );
                        if ( isNaN( canParse ) ) canParse = false; else canParse = true;
                        if ( canParse )
                            value = parseFloat( value );

                        if ( typeof value === 'number' && isFinite( value ) ) {
                            $.each( aggregate.aggregates, function () {
                                var oldValue = data[ aggregate.name ][ this ];
                                if ( oldValue == null ) {
                                    oldValue = 0;
                                    if ( this == 'min' ) oldValue = 9999999999999;
                                    if ( this == 'max' ) oldValue = -9999999999999;
                                }
                                if ( this == 'sum' || this == 'avg' || this == 'stdev'
                                    || this == 'stdevp' || this == 'var' || this == 'varp' ) {
                                    oldValue += parseFloat( value );
                                }
                                else if ( this == 'product' ) {
                                    if ( i == 0 )
                                        oldValue = parseFloat( value );
                                    else
                                        oldValue *= parseFloat( value );
                                }
                                else if ( this == 'min' ) {
                                    oldValue = Math.min( oldValue, parseFloat( value ) );
                                }
                                else if ( this == 'max' ) {
                                    oldValue = Math.max( oldValue, parseFloat( value ) );
                                }
                                else if ( this == 'count' ) {
                                    oldValue++;
                                }
                                else if ( typeof ( this ) == 'object' ) {
                                    _customCalcFunc( this );
                                    return;
                                }
                                data[ aggregate.name ][ this ] = oldValue;
                            } );
                        }
                        else {
                            $.each( aggregate.aggregates, function () {
                                if ( this == 'min' || this == 'max' || this == 'count' || this == 'product' || this == 'sum'
                                    || this == 'avg' || this == 'stdev'
                                    || this == 'stdevp' || this == 'var' || this == 'varp' ) {
                                    if ( value === null ) return true;

                                    var oldValue = data[ aggregate.name ][ this ];
                                    if ( oldValue == null ) {
                                        oldValue = 0;
                                    }
                                    data[ aggregate.name ][ this ] = oldValue;
                                    return true;
                                }

                                if ( typeof ( this ) == 'object' ) {
                                    _customCalcFunc( this );
                                }
                            } );
                        }
                    }
                }
            }

            for ( var j = 0; j < aggregates.length; j++ ) {
                var aggregate = aggregates[ j ];
                if ( !data[ aggregate.name ] ) {
                    data[ aggregate.name ] = {};
                    $.each( aggregate.aggregates, function ( index ) {
                        data[ aggregate.name ][ this ] = 0;
                    } );
                }

                if ( data[ aggregate.name ][ 'avg' ] != undefined ) {
                    var value = data[ aggregate.name ][ 'avg' ];
                    var dataValues = dataValuesByAggregate[ aggregate.name ];
                    if ( dataValues === 0 || dataValues == undefined ) {
                        data[ aggregate.name ][ 'avg' ] = 0;
                    }
                    else {
                        data[ aggregate.name ][ 'avg' ] = value / dataValues;
                    }
                }
                else if ( data[ aggregate.name ][ 'count' ] != undefined ) {
                    data[ aggregate.name ][ 'count' ] = length;
                }

                // stdev, stdevp, var, varp.
                // stdev - Standard deviation on a sample.
                // varp - Variance on an entire population.
                // var - Variance on a sample.
                if ( data[ aggregate.name ][ 'stdev' ] || data[ aggregate.name ][ 'stdevp' ]
                    || data[ aggregate.name ][ 'var' ] || data[ aggregate.name ][ 'varp' ] ) {
                    $.each( aggregate.aggregates, function ( index ) {
                        if ( this == 'stdev' || this == 'var' || this == 'varp' || this == 'stdevp' ) {
                            var value = data[ aggregate.name ][ this ];
                            var count = length;
                            var average = ( value / length );
                            var sumSq = 0.0;
                            for ( var i = 0; i < length; i++ ) {
                                var record = dataRecords[ i ];
                                var recordvalue = record[ aggregate.name ];
                                sumSq += ( recordvalue - average ) * ( recordvalue - average );
                            }

                            var denominator = ( this == 'stdevp' || this == 'varp' ) ? count : count - 1;
                            if ( denominator == 0 )
                                denominator = 1;

                            if ( this == 'var' || this == 'varp' ) {
                                data[ aggregate.name ][ this ] = sumSq / denominator;
                            }
                            else if ( this == 'stdevp' || this == 'stdev' ) {
                                data[ aggregate.name ][ this ] = Math.sqrt( sumSq / denominator );
                            }
                        }
                    } );
                }

                if ( aggregate.formatStrings ) {
                    $.each( aggregate.aggregates, function ( index ) {
                        var formatString = aggregate.formatStrings[ index ];
                        if ( formatString ) {
                            if ( this == 'min' || this == 'max' || this == 'count' || this == 'product' || this == 'sum'
                                || this == 'avg' || this == 'stdev'
                                || this == 'stdevp' || this == 'var' || this == 'varp' ) {
                                var value = data[ aggregate.name ][ this ];
                                data[ aggregate.name ][ this ] = $.jqx.dataFormat.formatnumber( value, formatString, calendar );
                            }
                            else if ( typeof this == 'object' ) {
                                for ( var obj in this ) {
                                    var value = data[ aggregate.name ][ obj ];
                                    data[ aggregate.name ][ obj ] = $.jqx.dataFormat.formatnumber( value, formatString, calendar );
                                }
                            }
                        }
                    } );
                }
            }
            return data;
        },

        bindDownloadComplete: function ( id, func ) {
            this._downloadComplete[ this._downloadComplete.length ] = { id: id, func: func };

        },

        unbindDownloadComplete: function ( id ) {
            for ( var i = 0; i < this._downloadComplete.length; i++ ) {
                if ( this._downloadComplete[ i ].id == id ) {
                    this._downloadComplete[ i ].func = null;
                    this._downloadComplete.splice( i, 1 );
                    break;
                }
            }
        },

        callDownloadComplete: function () {
            for ( var complete = 0; complete < this._downloadComplete.length; complete++ ) {
                var downloadComplete = this._downloadComplete[ complete ];
                if ( downloadComplete.func != null ) {
                    downloadComplete.func();
                }
            }
        },

        setSource: function ( source ) {
            this._source = source;
        },

        generatekey: function () {
            var S4 = function () {
                return ( ( ( 1 + Math.random() ) * 0x10000 ) | 0 ).toString( 16 ).substring( 1 );
            };
            return ( S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4() );
        },

        getGroupedRecords: function ( groups, collectionName, groupName, mappingFields, recordName, valueName, parentName, data, startIndex ) {
            var visualRows = 0;
            var self = this;
            if ( !startIndex ) startIndex = 0;
            var groupHashCodes = new Array();
            for ( var iGroupColumn = 0; iGroupColumn < groups.length; iGroupColumn++ ) {
                groupHashCodes[ iGroupColumn ] = self.generatekey();
            }

            if ( !collectionName ) {
                collectionName = 'items';
            }

            if ( !groupName ) {
                groupName = 'group';
            }

            if ( !recordName ) {
                recordName = 'record';
            }

            if ( !parentName ) {
                parentName = 'parentItem';
            }

            if ( undefined === valueName ) {
                valueName = 'value';
            }

            var grouprecords = new Array();
            var grouprecordsindex = 0;
            var hashRowGroups = new Array();
            var groupslength = groups.length;
            var groupsHierarchy = new Array();
            if ( !data ) {
                var data = this.records;
            }

            var dataLength = data.length;

            var itemByRecord = function ( record ) {
                var itemObj = record;
                if ( mappingFields ) {
                    $.each( mappingFields, function () {
                        if ( this.name && this.map ) {
                            itemObj[ this.map ] = itemObj[ this.name ];
                        }
                    } );
                }

                return itemObj;
            }

            for ( var obj = 0; obj < dataLength; obj++ ) {
                var item = itemByRecord( data[ obj ] );
                var id = item[ self.uniqueId ];
                var itemKeysHierarchy = new Array();
                var keys = 0;
                for ( iGroupColumn = 0; iGroupColumn < groupslength; iGroupColumn++ ) {
                    var group = groups[ iGroupColumn ];
                    var value = item[ group ];

                    if ( null == value )
                        continue;

                    itemKeysHierarchy[ keys++ ] = { value: value, hash: groupHashCodes[ iGroupColumn ] };
                }

                if ( itemKeysHierarchy.length != groupslength )
                    break;

                var parentItem = null;

                var lookupKey = "";
                var iLevel = -1;
                for ( var q = 0; q < itemKeysHierarchy.length; q++ ) {
                    iLevel++;
                    var itemKey = itemKeysHierarchy[ q ].value;
                    var columnHash = itemKeysHierarchy[ q ].hash;
                    lookupKey = lookupKey + "_" + columnHash + "_" + itemKey;
                    if ( hashRowGroups[ lookupKey ] != undefined && hashRowGroups[ lookupKey ] != null ) {
                        parentItem = hashRowGroups[ lookupKey ];
                        continue;
                    }
                    if ( parentItem == null ) {
                        parentItem = { level: 0 };
                        parentItem[ parentName ] = null;
                        parentItem[ groupName ] = itemKey;
                        parentItem[ recordName ] = item;
                        if ( item.expanded !== undefined ) {
                            parentItem.expanded = item.expanded;
                        }
                        else {
                            parentItem.expanded = false;
                        }

                        if ( valueName ) {
                            parentItem[ valueName ] = item[ valueName ];
                        }
                        parentItem[ collectionName ] = new Array();
                        var uid = grouprecords.length + startIndex;
                        if ( !this._source.id || typeof item.uid === "number" || isFinite( item.uid ) ) {
                            uid = "Row" + uid;
                        }
                        parentItem.uid = uid;
                        grouprecords[ grouprecordsindex++ ] = parentItem;
                    }
                    else {
                        var subItem = { level: parentItem.level + 1 };
                        subItem[ parentName ] = parentItem;
                        subItem[ groupName ] = itemKey;
                        subItem[ collectionName ] = new Array();
                        subItem[ recordName ] = item;
                        if ( item.expanded !== undefined ) {
                            subItem.expanded = item.expanded;
                        }
                        else {
                            subItem.expanded = false;
                        }

                        if ( valueName ) {
                            subItem[ valueName ] = item[ valueName ];
                        }
                        subItem.uid = parentItem.uid + "_" + parentItem[ collectionName ].length;
                        parentItem[ collectionName ][ parentItem[ collectionName ].length ] = subItem;
                        parentItem = subItem;
                    }

                    hashRowGroups[ lookupKey ] = parentItem;
                }

                if ( item ) {
                    item.leaf = true;
                }

                if ( parentItem != null ) {
                    if ( this._source.id == null ) {
                        if ( undefined == item.uid ) {
                            item.uid = parentItem.uid + "_" + parentItem[ collectionName ].length;
                        }
                        else {
                            if ( item.uid.toString().indexOf( parentItem.uid ) == -1 ) {
                                item.uid = parentItem.uid + "_" + item.uid;
                            }
                        }
                    }
                    item[ parentName ] = parentItem;
                    item.level = parentItem.level + 1;
                    parentItem[ collectionName ][ parentItem[ collectionName ].length ] = item;
                }
                else {
                    if ( undefined == item.uid ) {
                        item.uid = this.generatekey();
                    }
                }
            }
            return grouprecords;
        },

        getRecordsHierarchy: function ( fieldName, parentFieldName, collectionName, mappingFields, dataRecords ) {
            var recordsHierarchy = new Array();
            var flatData = this.records;
            if ( dataRecords ) {
                flatData = dataRecords;
            }

            if ( this.records.length == 0 )
                return null;

            var subItemsName = collectionName != null ? collectionName : "items";
            var items = [];
            var data = flatData;
            var dataLength = data.length;
            var names = ( this._source && this._source.hierarchy ) ? this._source.hierarchy.reservedNames : null;

            var itemByRecord = function ( record ) {
                var itemObj = record;
                if ( mappingFields ) {
                    $.each( mappingFields, function () {
                        if ( this.name && this.map ) {
                            itemObj[ this.map ] = itemObj[ this.name ];
                        }
                    } );
                }

                return itemObj;
            }

            // build hierarchical source.
            for ( var i = 0; i < dataLength; i++ ) {
                var item = $.extend( {}, data[ i ] );
                var parentid = item[ parentFieldName ];
                var id = item[ fieldName ];
                items[ id ] = { parentid: parentid, item: item };
            }

            for ( var i = 0; i < dataLength; i++ ) {
                var item = $.extend( {}, data[ i ] );
                var parentid = item[ parentFieldName ];
                var id = item[ fieldName ];

                if ( items[ parentid ] != undefined ) {
                    var item = { parentid: parentid, item: items[ id ].item };
                    var parentItem = items[ parentid ].item;
                    if ( !parentItem[ subItemsName ] ) {
                        parentItem[ subItemsName ] = [];
                    }
                    var length = parentItem[ subItemsName ].length;
                    var record = item.item;

                    if ( !names ) {
                        if ( record.parent == undefined ) {
                            record.parent = parentItem;
                        }
                    }
                    else {
                        if ( record[ names.parent ] == undefined ) {
                            record[ names.parent ] = parentItem;
                        }
                    }

                    var itemObj = itemByRecord( record );
                    parentItem[ subItemsName ][ length ] = itemObj;
                    items[ parentid ].item = parentItem;
                    items[ id ] = item;
                }
                else {
                    var record = items[ id ].item;
                    if ( !names ) {
                        if ( record.parent == undefined ) {
                            record.parent = null;
                        }
                    }
                    else {
                        if ( record[ names.parent ] == undefined ) {
                            record[ names.parent ] = null;
                        }
                    }

                    var itemObj = itemByRecord( record );
                    if ( !names ) {
                        itemObj.level = 0;
                    }
                    else {
                        itemObj[ names.level ] = 0;
                    }

                    recordsHierarchy[ recordsHierarchy.length ] = itemObj;
                }
            }
            if ( recordsHierarchy.length != 0 ) {
                var updateLevels = function ( level, records ) {
                    for ( var i = 0; i < records.length; i++ ) {
                        if ( !names ) {
                            records[ i ].level = level;
                        }
                        else {
                            records[ i ][ names.level ] = level;
                        }

                        var subRecords = records[ i ][ subItemsName ];
                        if ( subRecords ) {
                            if ( subRecords.length > 0 ) {
                                updateLevels( level + 1, subRecords );
                            }
                            else {
                                if ( !names ) {
                                    records[ i ].leaf = true;
                                }
                                else {
                                    records[ i ][ names.leaf ] = true;
                                }
                            }
                        }
                        else {
                            if ( !names ) {
                                records[ i ].leaf = true;
                            }
                            else {
                                records[ i ][ names.leaf ] = true;
                            }
                        }
                    }
                };
                updateLevels( 0, recordsHierarchy );
            }
            return recordsHierarchy;
        },

        bindBindingUpdate: function ( id, func ) {
            this._bindingUpdate[ this._bindingUpdate.length ] = { id: id, func: func };

        },

        unbindBindingUpdate: function ( id ) {
            for ( var i = 0; i < this._bindingUpdate.length; i++ ) {
                if ( this._bindingUpdate[ i ].id == id ) {
                    this._bindingUpdate[ i ].func = null;
                    this._bindingUpdate.splice( i, 1 );
                    break;
                }
            }
        },

        callBindingUpdate: function ( collectionChanged ) {
            for ( var update = 0; update < this._bindingUpdate.length; update++ ) {
                var bindingUpdate = this._bindingUpdate[ update ];
                if ( bindingUpdate.func != null ) {
                    bindingUpdate.func( collectionChanged );
                }
            }
        },

        getid: function ( id, record, index ) {
            if ( id != null && id.name != undefined ) {
                if ( id.name ) {
                    var result = $( record ).attr( id.name );
                    if ( result != null && result.toString().length > 0 ) {
                        return result;
                    }
                    else if ( id.map ) {
                        try {
                            var result = $( record ).attr( id.map );
                            if ( result != null && result.toString().length > 0 ) {
                                return result;
                            }
                            else if ( $( id.map, record ).length > 0 ) {
                                return $( id.map, record ).text();
                            }
                            else if ( $( id.name, record ).length > 0 ) {
                                return $( id.name, record ).text();
                            }
                        }
                        catch ( error ) {
                            return index;
                        }
                    }
                    return;
                }
            }

            if ( $( id, record ).length > 0 ) {
                return $( id, record ).text();
            }

            if ( id ) {
                if ( id.toString().length > 0 ) {
                    var result = $( record ).attr( id );
                    if ( result != null && result.toString().length > 0 ) {
                        return $.trim( result ).split( " " ).join( "" ).replace( /([ #;?%&,.+*~\':"!^$[\]()=>|\/\\@])/g, '' );
                    }
                    else {
                        var splitMap = id.split( this.mapChar );
                        if ( splitMap.length > 1 ) {
                            var d = record;
                            for ( var p = 0; p < splitMap.length; p++ ) {
                                if ( d != undefined ) {
                                    d = d[ splitMap[ p ] ];
                                }
                            }
                            if ( d != undefined ) {
                                return d;
                            }
                        }
                        else {
                            if ( record[ id ] != undefined ) {
                                return record[ id ];
                            }
                        }
                    }
                }
            }

            return index;
        },

        loadjson: function ( jsondata, data, source ) {
            if ( typeof ( jsondata ) == 'string' ) {
                jsondata = $.parseJSON( jsondata );
            }

            if ( source.root == undefined ) source.root = '';
            if ( source.record == undefined ) source.record = '';

            var jsondata = jsondata || data;
            if ( !jsondata ) {
                jsondata = [];
            }

            var me = this;
            if ( source.root != '' ) {
                var splitMap = source.root.split( me.mapChar );
                if ( splitMap.length > 1 ) {
                    var d = jsondata;
                    for ( var p = 0; p < splitMap.length; p++ ) {
                        if ( d != undefined ) {
                            d = d[ splitMap[ p ] ];
                        }
                    }
                    jsondata = d;
                }
                else {
                    if ( jsondata[ source.root ] !== undefined ) {
                        jsondata = jsondata[ source.root ];
                    }
                    else if ( jsondata[ 0 ] && jsondata[ 0 ][ source.root ] !== undefined ) {
                        jsondata = jsondata[ 0 ][ source.root ];
                    }
                    else {
                        $.each( jsondata, function ( i ) {
                            var root = this;
                            if ( this == source.root ) {
                                jsondata = this;
                                return false;
                            }
                            else if ( this[ source.root ] != undefined ) {
                                jsondata = this[ source.root ];
                            }
                        } );
                    }

                    if ( !jsondata ) {
                        var splitMap = source.root.split( me.mapChar );
                        if ( splitMap.length > 0 ) {
                            var d = jsondata;
                            for ( var p = 0; p < splitMap.length; p++ ) {
                                if ( d != undefined ) {
                                    d = d[ splitMap[ p ] ];
                                }
                            }
                            jsondata = d;
                        }
                    }
                }
            }
            else {
                if ( !jsondata.length ) {
                    for ( var obj in jsondata ) {
                        if ( $.isArray( jsondata[ obj ] ) ) {
                            jsondata = jsondata[ obj ];
                            break;
                        }
                    }
                }
            }

            if ( jsondata != null && jsondata.length == undefined ) {
                jsondata = $.makeArray( jsondata );
            }

            if ( jsondata == null || jsondata == undefined || jsondata == "undefined" || jsondata.length == undefined ) {
                throw new Error( 'jqxDataAdapter: JSON Parse error! Invalid JSON. Please, check your JSON or your jqxDataAdapter initialization!' );
                return;
            }

            if ( jsondata.length == 0 ) {
                this.totalrecords = 0;
                return;
            }

            var length = jsondata.length;
            this.totalrecords = this.virtualmode ? ( source.totalrecords || length ) : length;
            this.records = new Array();
            this.originaldata = new Array();

            var records = this.records;
            var recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;

            this.recordids = new Array();

            if ( source.loadallrecords ) {
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var dataoffset = 0;
            if ( this.virtualmode ) {
                recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;
                dataoffset = recordsstartindex;
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var datafieldslength = source.datafields ? source.datafields.length : 0;
            // auto-generate data columns
            if ( datafieldslength == 0 ) {
                var firstrecord = jsondata[ 0 ];
                var datafields = new Array();
                for ( var obj in firstrecord ) {
                    var field = obj;
                    datafields[ datafields.length ] = { name: field };
                }
                source.datafields = datafields;
                source.generatedfields = source.datafields;
                datafieldslength = datafields.length;
            }

            var index = recordsstartindex;
            for ( var i = recordsstartindex; i < length; i++ ) {
                var record = jsondata[ i ];

                if ( record == undefined )
                    break;

                if ( source.record && source.record != '' ) {
                    record = record[ source.record ];
                    if ( record == undefined )
                        continue;
                }

                var recordid = this.getid( source.id, record, i );
                if ( typeof ( recordid ) === "object" ) {
                    recordid = i;
                }

                if ( !this.recordids[ recordid ] ) {
                    this.recordids[ recordid ] = record;
                    var datarow = {};

                    for ( var j = 0; j < datafieldslength; j++ ) {
                        var datafield = source.datafields[ j ];
                        var value = '';
                        if ( undefined == datafield || datafield == null ) {
                            continue;
                        }

                        if ( datafield.map ) {
                            if ( $.isFunction( datafield.map ) ) {
                                value = datafield.map( record );
                            }
                            else {
                                var splitMap = datafield.map.split( me.mapChar );
                                if ( splitMap.length > 0 ) {
                                    var datarecord = record;
                                    for ( var p = 0; p < splitMap.length; p++ ) {
                                        if ( datarecord != undefined ) {
                                            datarecord = datarecord[ splitMap[ p ] ];
                                        }
                                    }
                                    value = datarecord;
                                }
                                else {
                                    value = record[ datafield.map ];
                                }
                            }

                            if ( value != undefined && value != null ) {
                                value = this.getvaluebytype( value, datafield );
                            }
                            else if ( value == undefined && value != null ) {
                                value = '';
                            }
                        }

                        // searches by both selectors when necessary.
                        if ( value == '' && !datafield.map ) {
                            value = record[ datafield.name ];
                            if ( value == undefined && value != null ) {
                                value = '';
                            }
                            // the datafield.value allows you to load values like: "Nombre":{"#text":"FASE 1"}, where the datafield is Nombre, the value is object.
                            // If the datafield.value is "#text", the value that will be loaded will be "FASE 1".
                            if ( datafield.value != undefined ) {
                                if ( value != undefined ) {
                                    var tmpvalue = value[ datafield.value ];
                                    if ( tmpvalue != undefined ) {
                                        value = tmpvalue;
                                    }
                                }
                            }
                        }

                        value = this.getvaluebytype( value, datafield );
                        if ( datafield.displayname != undefined ) {
                            datarow[ datafield.displayname ] = value;
                        }
                        else {
                            datarow[ datafield.name ] = value;
                        }

                        if ( datafield.type === "array" ) {
                            var updateValues = function ( records ) {
                                if ( !records ) return;
                                for ( var t = 0; t < records.length; t++ ) {
                                    var record = records[ t ];
                                    if ( !record ) {
                                        continue;
                                    }

                                    for ( var c = 0; c < datafieldslength; c++ ) {
                                        var datafield = source.datafields[ c ];
                                        var value = '';
                                        if ( undefined == datafield || datafield == null ) {
                                            continue;
                                        }

                                        if ( datafield.map ) {
                                            if ( $.isFunction( datafield.map ) ) {
                                                value = datafield.map( record );
                                            }
                                            else {
                                                var splitMap = datafield.map.split( me.mapChar );
                                                if ( splitMap.length > 0 ) {
                                                    var datarecord = record;
                                                    for ( var p = 0; p < splitMap.length; p++ ) {
                                                        if ( datarecord != undefined ) {
                                                            datarecord = datarecord[ splitMap[ p ] ];
                                                        }
                                                    }
                                                    value = datarecord;
                                                }
                                                else {
                                                    value = record[ datafield.map ];
                                                }
                                            }

                                            if ( value != undefined && value != null ) {
                                                value = this.getvaluebytype( value, datafield );
                                            }
                                            else if ( value == undefined && value != null ) {
                                                value = '';
                                            }
                                        }

                                        // searches by both selectors when necessary.
                                        if ( value == '' && !datafield.map ) {
                                            value = record[ datafield.name ];
                                            if ( value == undefined && value != null ) {
                                                value = '';
                                            }
                                            // the datafield.value allows you to load values like: "Nombre":{"#text":"FASE 1"}, where the datafield is Nombre, the value is object.
                                            // If the datafield.value is "#text", the value that will be loaded will be "FASE 1".
                                            if ( datafield.value != undefined ) {
                                                if ( value != undefined ) {
                                                    var tmpvalue = value[ datafield.value ];
                                                    if ( tmpvalue != undefined ) {
                                                        value = tmpvalue;
                                                    }
                                                }
                                            }
                                        }

                                        value = this.getvaluebytype( value, datafield );
                                        if ( datafield.displayname != undefined ) {
                                            record[ datafield.displayname ] = value;
                                        }
                                        else {
                                            record[ datafield.name ] = value;
                                        }
                                        if ( datafield.type === "array" ) {
                                            updateValues.call( this, value );
                                        }
                                    }
                                }
                            }
                            updateValues.call( this, value );
                        }
                    }

                    if ( source.recordendindex <= 0 || recordsstartindex < source.recordendindex ) {
                        //      records[dataoffset + index] = $.extend({}, datarow);
                        records[ dataoffset + index ] = new Object( datarow );
                        records[ dataoffset + index ].uid = recordid;

                        this.originaldata[ dataoffset + index ] = new Object( records[ i ] );

                        //     this.originaldata[dataoffset + index] = $.extend({}, records[i]);
                        index++;
                    }
                }
            }
            this.records = records;
            this.cachedrecords = this.records;
        },

        loadxml: function ( xmldata, data, source ) {
            if ( typeof ( xmldata ) == 'string' ) {
                xmldata = data = $( $.parseXML( xmldata ) );
                xmldata = null;
            }

            if ( source.root == undefined ) source.root = '';
            if ( source.record == undefined ) source.record = '';


            var xmldata;

            if ( $.jqx.browser.msie && data ) {
                if ( data.xml != undefined ) {
                    xmldata = $( source.root + " " + source.record, $.parseXML( data.xml ) );
                }
                else {
                    xmldata = xmldata || $( source.root + " " + source.record, data );
                }
            }
            else xmldata = xmldata || $( source.root + " " + source.record, data );

            if ( !xmldata ) {
                xmldata = [];
            }

            var length = xmldata.length;
            if ( xmldata.length == 0 ) {
                return;
            }

            this.totalrecords = this.virtualmode ? ( source.totalrecords || length ) : length;
            this.records = new Array();
            this.originaldata = new Array();

            var records = this.records;
            var recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;

            this.recordids = new Array();

            if ( source.loadallrecords ) {
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var dataoffset = 0;
            if ( this.virtualmode ) {
                recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;
                dataoffset = recordsstartindex;
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var datafieldslength = source.datafields ? source.datafields.length : 0;
            // auto-generate data columns
            if ( datafieldslength == 0 ) {
                var firstrecord = xmldata[ 0 ];
                var datafields = new Array();
                for ( var obj in firstrecord ) {
                    var field = obj;
                    datafields[ datafields.length ] = { name: field };
                }
                source.datafields = datafields;
                source.generatedfields = source.datafields;

                datafieldslength = datafields.length;
            }

            var p = recordsstartindex;
            var hasArray = false;
            for ( var i = recordsstartindex; i < length; i++ ) {
                var record = xmldata[ i ];
                if ( record == undefined )
                    break;

                var recordid = this.getid( source.id, record, i );
                if ( !this.recordids[ recordid ] ) {
                    this.recordids[ recordid ] = record;
                    var datarow = {};

                    var multiLevel = false;
                    if ( source.hierarchy && source.hierarchy.root ) {
                        multiLevel = true;
                    }

                    for ( var j = 0; j < datafieldslength; j++ ) {
                        var datafield = source.datafields[ j ];
                        var value = '';
                        if ( undefined == datafield || datafield == null ) {
                            continue;
                        }

                        if ( datafield.map ) {
                            if ( $.isFunction( datafield.map ) ) {
                                value = datafield.map( record );
                            }
                            else {
                                var attributeStartIndex = datafield.map.indexOf( '[' );
                                if ( attributeStartIndex < 0 ) {
                                    value = $( datafield.map, record );
                                    if ( value.length == 1 ) value = value.text();
                                    else {
                                        hasArray = true;
                                        var subArray = new Array();
                                        for ( var f = 0; f < value.length; f++ ) {
                                            subArray.push( $( value[ f ] ).text() );
                                        }
                                        value = subArray;
                                        if ( multiLevel && subArray.length > 0 ) {
                                            value = subArray[ 0 ];
                                        }
                                    }
                                }
                                else {
                                    var submap = datafield.map.substring( 0, attributeStartIndex - 1 );
                                    var attributeEndIndex = datafield.map.indexOf( ']' );
                                    var attribute = datafield.map.substring( attributeStartIndex + 1, attributeEndIndex );
                                    value = $( submap, record ).attr( attribute );
                                    if ( value == undefined ) {
                                        value = $( record ).attr( attribute );
                                    }

                                    if ( value == undefined ) value = '';
                                }
                                if ( value == '' ) {
                                    value = $( record ).attr( datafield.map );
                                    if ( value == undefined ) value = '';
                                }
                            }
                        }
                        // searches by both selectors when necessary.
                        if ( value == '' ) {
                            value = $( datafield.name, record );
                            if ( value.length == 1 ) value = value.text();
                            else {
                                var subArray = new Array();
                                for ( var f = 0; f < value.length; f++ ) {
                                    subArray.push( $( value[ f ] ).text() );
                                }
                                value = subArray;
                                if ( multiLevel && subArray.length > 0 ) {
                                    value = subArray[ 0 ];
                                }
                            }

                            if ( value == '' ) {
                                value = $( record ).attr( datafield.name );
                                if ( value == undefined ) value = '';
                            }
                            if ( value == '' ) {
                                if ( record.nodeName && record.nodeName == datafield.name && record.firstChild ) {
                                    value = $( record.firstChild ).text();
                                }
                            }
                        }

                        var originalvalue = value;
                        value = this.getvaluebytype( value, datafield );
                        if ( datafield.displayname != undefined ) {
                            datarow[ datafield.displayname ] = value;
                        }
                        else {
                            datarow[ datafield.name ] = value;
                        }
                    }
                    if ( source.recordendindex <= 0 || recordsstartindex < source.recordendindex ) {
                        records[ dataoffset + p ] = $.extend( {}, datarow );
                        records[ dataoffset + p ].uid = recordid;

                        this.originaldata[ dataoffset + p ] = $.extend( {}, records[ i ] );
                        p++;
                    }
                }
            }

            if ( source.hierarchy && source.hierarchy.root ) {
                for ( var i = recordsstartindex; i < length; i++ ) {
                    var record = xmldata[ i ];
                    var dataRecord = records[ i ];

                    if ( $( record ).parent().length > 0 ) {
                        var recordid = this.getid( source.id, $( record ).parents( source.hierarchy.record + ":first" ) );
                        dataRecord.parentuid = recordid;
                    }
                    else {
                        dataRecord.parentuid = null;
                    }
                }
            }

            this.records = records;
            this.cachedrecords = this.records;
        },

        loadics: function ( data, source ) {
            if ( data == null ) {
                return;
            }

            var rowDelimiter = source.rowDelimiter || this.rowDelimiter || '\n';
            var rows = data.split( rowDelimiter );
            var length = rows.length;
            var rowsWithNewRowDelimiter = data.split( '\r' );
            if ( length == 1 && rowsWithNewRowDelimiter.length > 1 ) {
                rows = rowsWithNewRowDelimiter;
                length = rows.length;
            }
            this.records = new Array();
            this.originaldata = new Array();

            var records = this.records;
            this.recordids = new Array();

            var dataoffset = 0;

            var stringToDate = function ( until ) {
                var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z)?$/;
                var bits = re.exec( until );
                if ( !bits ) {
                    throw new Error( 'Invalid UNTIL value: ' + until )
                }
                return new Date(
                    Date.UTC( bits[ 1 ],
                        bits[ 2 ] - 1,
                        bits[ 3 ],
                        bits[ 5 ] || 0,
                        bits[ 6 ] || 0,
                        bits[ 7 ] || 0
                    ) );
            }

            for ( var i = 0; i < length; i++ ) {
                var record = rows[ i ];
                if ( record == "BEGIN:VEVENT" ) {
                    var appointment = {};
                    continue;
                }

                if ( record.indexOf( "SUMMARY" ) >= 0 ) {
                    appointment.SUMMARY = record.substring( record.indexOf( "SUMMARY" ) + 8 );
                    continue;
                }
                if ( record.indexOf( "LOCATION" ) >= 0 ) {
                    appointment.LOCATION = record.substring( record.indexOf( "LOCATION" ) + 9 );
                    continue;
                }
                if ( record.indexOf( "DESCRIPTION" ) >= 0 ) {
                    appointment.DESCRIPTION = record.substring( record.indexOf( "DESCRIPTION" ) + 12 );
                    continue;
                }
                if ( record.indexOf( "RRULE" ) >= 0 ) {
                    appointment.RRULE = record.substring( record.indexOf( "RRULE" ) + 6 );
                    continue;
                }
                if ( record.indexOf( "EXDATE" ) >= 0 ) {
                    var exDate = record.substring( record.indexOf( "EXDATE" ) + 7 );
                    appointment.EXDATE = exDate;
                    continue;
                }
                if ( record.indexOf( "DTEND" ) >= 0 ) {
                    appointment.DTEND = stringToDate( record.substring( record.indexOf( "DTEND" ) + 6 ) );
                    continue;
                }
                if ( record.indexOf( "DTSTART" ) >= 0 ) {
                    appointment.DTSTART = stringToDate( record.substring( record.indexOf( "DTSTART" ) + 8 ) );
                    continue;
                }
                if ( record.indexOf( "UID" ) >= 0 ) {
                    appointment.uid = appointment.UID = record.substring( record.indexOf( "UID" ) + 4 );
                    continue;
                }
                if ( record.indexOf( "STATUS" ) >= 0 ) {
                    appointment.STATUS = record.substring( record.indexOf( "STATUS" ) + 7 );
                    continue;
                }
                if ( record == "END:VEVENT" ) {
                    records.push( appointment );
                    continue;
                }
            }
            this.records = records;
            this.cachedrecords = this.records;
        },

        loadtext: function ( data, source ) {
            if ( data == null ) {
                return;
            }

            var rowDelimiter = source.rowDelimiter || this.rowDelimiter || '\n';
            var rows = data.split( rowDelimiter );
            var length = rows.length;
            var rowsWithNewRowDelimiter = data.split( '\r' );
            if ( length == 1 && rowsWithNewRowDelimiter.length > 1 ) {
                rows = rowsWithNewRowDelimiter;
                length = rows.length;
            }
            this.totalrecords = this.virtualmode ? ( source.totalrecords || length ) : length;
            this.records = new Array();
            this.originaldata = new Array();

            var records = this.records;
            var recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;

            this.recordids = new Array();

            if ( source.loadallrecords ) {
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var dataoffset = 0;
            if ( this.virtualmode ) {
                recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;
                dataoffset = recordsstartindex;
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var datafieldslength = source.datafields.length;
            var columnDelimiter = source.columnDelimiter || this.columnDelimiter;
            if ( !columnDelimiter )
                columnDelimiter = ( source.datatype === 'tab' || source.datatype === 'tsv' ) ? '\t' : ',';

            for ( var i = recordsstartindex; i < length; i++ ) {
                var record = rows[ i ];
                var recordid = null;
                if ( !this.recordids[ recordid ] ) {
                    if ( source.id == null ) {
                        recordid = i;
                        this.recordids[ recordid ] = record;
                    }

                    var datarow = {};
                    var columns = rows[ i ].split( columnDelimiter );

                    for ( var j = 0; j < datafieldslength; j++ ) {
                        if ( j >= columns.length )
                            continue;
                        var datafield = source.datafields[ j ];

                        var value = columns[ j ];
                        if ( datafield.map && $.isFunction( datafield.map ) ) {
                            value = datafield.map( record );
                        }

                        if ( datafield.type ) {
                            value = this.getvaluebytype( value, datafield );
                        }

                        var key = datafield.map || datafield.name || j.toString();
                        datarow[ key ] = value;
                        if ( source.id != null ) {
                            if ( source.id === datafield.name ) {
                                recordid = value;
                                this.recordids[ recordid ] = record;
                            }
                        }
                    }
                    if ( recordid == null ) {
                        recordid = i;
                    }

                    records[ dataoffset + i ] = $.extend( {}, datarow );
                    records[ dataoffset + i ].uid = recordid;

                    this.originaldata[ dataoffset + i ] = $.extend( {}, records[ i ] );
                }
            }
            this.records = records;
            this.cachedrecords = this.records;
        },

        getvaluebytype: function ( value, datafield ) {
            var originalvalue = value;
            if ( value == null ) return value;
            if ( $.isArray( value ) && datafield.type != "array" ) {
                for ( var t = 0; t < value.length; t++ ) {
                    value[ t ] = this.getvaluebytype( value[ t ], datafield );
                }
                return value;
            }

            if ( datafield.type == 'date' ) {
                if ( value == "NaN" ) {
                    value = "";
                }
                else {
                    if ( value && value instanceof Date ) {
                        return value;
                    }

                    var tmpvalue = new Date( value );

                    if ( typeof value == 'string' ) {
                        if ( datafield.format ) {
                            var newtmpvalue = $.jqx.dataFormat.parsedate( value, datafield.format );
                            if ( newtmpvalue != null ) {
                                tmpvalue = newtmpvalue;
                            }
                        }
                    }

                    if ( tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date" ) {
                        if ( $.jqx.dataFormat ) {
                            value = $.jqx.dataFormat.tryparsedate( value );
                        }
                        else value = tmpvalue;
                    }
                    else {
                        value = tmpvalue;
                    }

                    if ( value == null ) {
                        value = originalvalue;
                    }
                }
            }
            else if ( datafield.type == 'float' || datafield.type == 'number' || datafield.type == 'decimal' ) {
                if ( value == "NaN" ) value = "";
                else {
                    var value = parseFloat( value );
                    if ( isNaN( value ) ) {
                        value = originalvalue;
                    }
                }
            }
            else if ( datafield.type == 'int' || datafield.type == 'integer' ) {
                var value = parseInt( value );
                if ( isNaN( value ) ) {
                    value = originalvalue;
                }
            }
            else if ( datafield.type == 'bool' || datafield.type == 'boolean' ) {
                if ( value != null ) {
                    if ( value.toLowerCase != undefined ) {
                        if ( value.toLowerCase() == 'false' ) {
                            value = false;
                        }
                        else if ( value.toLowerCase() == 'true' ) {
                            value = true;
                        }
                    }
                }

                if ( value == 1 ) {
                    value = true;
                }
                else if ( value == 0 && value !== "" ) {
                    value = false;
                }
                else value = '';
            }

            return value;
        }
    }

    $.jqx.dataFormat = {};

    $.extend( $.jqx.dataFormat, {
        regexTrim: /^\s+|\s+$/g,
        regexInfinity: /^[+-]?infinity$/i,
        regexHex: /^0x[a-f0-9]+$/i,
        regexParseFloat: /^[+-]?\d*\.?\d*(e[+-]?\d+)?$/,
        toString: Object.prototype.toString,

        isBoolean: function ( value ) {
            return typeof value === 'boolean';
        },

        isObject: function ( value ) {
            return ( value && ( typeof value === 'object' || $.isFunction( value ) ) ) || false;
        },

        isDate: function ( value ) {
            return value instanceof Date;
        },

        arrayIndexOf: function ( array, item ) {
            if ( array.indexOf ) {
                return array.indexOf( item );
            }
            for ( var i = 0, length = array.length; i < length; i++ ) {
                if ( array[ i ] === item ) {
                    return i;
                }
            }
            return -1;
        },

        isString: function ( value ) {
            return typeof value === 'string';
        },

        isNumber: function ( value ) {
            return typeof value === 'number' && isFinite( value );
        },

        isNull: function ( value ) {
            return value === null;
        },

        isUndefined: function ( value ) {
            return typeof value === 'undefined';
        },

        isValue: function ( value ) {
            return ( this.isObject( value ) || this.isString( value ) || this.isNumber( value ) || this.isBoolean( value ) );
        },

        isEmpty: function ( value ) {
            if ( !this.isString( value ) && this.isValue( value ) ) {
                return false;
            } else if ( !this.isValue( value ) ) {
                return true;
            }
            value = $.trim( value ).replace( /\&nbsp\;/ig, '' ).replace( /\&#160\;/ig, '' );
            return value === "";
        },

        startsWith: function ( value, pattern ) {
            return value.indexOf( pattern ) === 0;
        },

        endsWith: function ( value, pattern ) {
            return value.substr( value.length - pattern.length ) === pattern;
        },

        trim: function ( value ) {
            return ( value + "" ).replace( this.regexTrim, "" );
        },

        isArray: function ( obj ) {
            return this.toString.call( obj ) === "[object Array]";
        },

        defaultcalendar: function () {
            var calendar = {
                // separator of parts of a date (e.g. '/' in 11/05/1955)
                '/': "/",
                // separator of parts of a time (e.g. ':' in 05:44 PM)
                ':': ":",
                // the first day of the week (0 = Sunday, 1 = Monday, etc)
                firstDay: 0,
                days: {
                    // full day names
                    names: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                    // abbreviated day names
                    namesAbbr: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                    // shortest day names
                    namesShort: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ]
                },
                months: {
                    // full month names (13 months for lunar calendards -- 13th month should be "" if not lunar)
                    names: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", "" ],
                    // abbreviated month names
                    namesAbbr: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "" ]
                },
                // AM and PM designators in one of these forms:
                // The usual view, and the upper and lower case versions
                //      [standard,lowercase,uppercase]
                // The culture does not use AM or PM (likely all standard date formats use 24 hour time)
                //      null
                AM: [ "AM", "am", "AM" ],
                PM: [ "PM", "pm", "PM" ],
                eras: [
                    // eras in reverse chronological order.
                    // name: the name of the era in this culture (e.g. A.D., C.E.)
                    // start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
                    // offset: offset in years from gregorian calendar
                    { "name": "A.D.", "start": null, "offset": 0 }
                ],
                twoDigitYearMax: 2029,
                patterns: {
                    // short date pattern
                    d: "M/d/yyyy",
                    // long date pattern
                    D: "dddd, MMMM dd, yyyy",
                    // short time pattern
                    t: "h:mm tt",
                    // long time pattern
                    T: "h:mm:ss tt",
                    // long date, short time pattern
                    f: "dddd, MMMM dd, yyyy h:mm tt",
                    // long date, long time pattern
                    F: "dddd, MMMM dd, yyyy h:mm:ss tt",
                    // month/day pattern
                    M: "MMMM dd",
                    // month/year pattern
                    Y: "yyyy MMMM",
                    // S is a sortable format that does not vary by culture
                    S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss",
                    // formatting of dates in MySQL DataBases
                    ISO: "yyyy-MM-dd hh:mm:ss",
                    ISO2: "yyyy-MM-dd HH:mm:ss",
                    d1: "dd.MM.yyyy",
                    d2: "dd-MM-yyyy",
                    d3: "MM-dd-yyyy",
                    zone1: "yyyy-MM-ddTHH:mm:ss-HH:mm",
                    zone2: "yyyy-MM-ddTHH:mm:ss+HH:mm",
                    custom: "yyyy-MM-ddTHH:mm:ss.fff",
                    custom2: "yyyy-MM-dd HH:mm:ss.fff"
                },
                percentsymbol: "%",
                currencysymbol: "$",
                currencysymbolposition: "before",
                decimalseparator: '.',
                thousandsseparator: ','
            }
            return calendar;
        },

        expandFormat: function ( calendar, format ) {
            // expands unspecified or single character date formats into the full pattern.
            format = format || "F";
            var pattern,
                patterns = calendar.patterns,
                len = format.length;
            if ( len === 1 ) {
                pattern = patterns[ format ];
                if ( !pattern ) {
                    throw "Invalid date format string '" + format + "'.";
                }
                format = pattern;
            }
            else if ( len === 2 && format.charAt( 0 ) === "%" ) {
                // %X escape format -- intended as a custom format string that is only one character, not a built-in format.
                format = format.charAt( 1 );
            }
            return format;
        },

        getEra: function ( date, eras ) {
            if ( !eras ) return 0;
            if ( typeof date === 'string' ) {
                return 0;
            }

            var start, ticks = date.getTime();
            for ( var i = 0, l = eras.length; i < l; i++ ) {
                start = eras[ i ].start;
                if ( start === null || ticks >= start ) {
                    return i;
                }
            }
            return 0;
        },

        toUpper: function ( value ) {
            // 'he-IL' has non-breaking space in weekday names.
            return value.split( "\u00A0" ).join( ' ' ).toUpperCase();
        },

        toUpperArray: function ( arr ) {
            var results = [];
            for ( var i = 0, l = arr.length; i < l; i++ ) {
                results[ i ] = this.toUpper( arr[ i ] );
            }
            return results;
        },

        getEraYear: function ( date, cal, era, sortable ) {
            var year = date.getFullYear();
            if ( !sortable && cal.eras ) {
                // convert normal gregorian year to era-shifted gregorian
                // year by subtracting the era offset
                year -= cal.eras[ era ].offset;
            }
            return year;
        },

        toUpper: function ( value ) {
            if ( value ) {
                return value.toUpperCase();
            }
            return "";
        },

        getDayIndex: function ( cal, value, abbr ) {
            var ret,
                days = cal.days,
                upperDays = cal._upperDays;
            if ( !upperDays ) {
                cal._upperDays = upperDays = [
                    this.toUpperArray( days.names ),
                    this.toUpperArray( days.namesAbbr ),
                    this.toUpperArray( days.namesShort )
                ];
            }
            value = value.toUpperCase();
            if ( abbr ) {
                ret = this.arrayIndexOf( upperDays[ 1 ], value );
                if ( ret === -1 ) {
                    ret = this.arrayIndexOf( upperDays[ 2 ], value );
                }
            }
            else {
                ret = this.arrayIndexOf( upperDays[ 0 ], value );
            }
            return ret;
        },

        getMonthIndex: function ( cal, value, abbr ) {
            var months = cal.months,
                monthsGen = cal.monthsGenitive || cal.months,
                upperMonths = cal._upperMonths,
                upperMonthsGen = cal._upperMonthsGen;
            if ( !upperMonths ) {
                cal._upperMonths = upperMonths = [
                    this.toUpperArray( months.names ),
                    this.toUpperArray( months.namesAbbr )
                ];
                cal._upperMonthsGen = upperMonthsGen = [
                    this.toUpperArray( monthsGen.names ),
                    this.toUpperArray( monthsGen.namesAbbr )
                ];
            }
            value = this.toUpper( value );
            var i = this.arrayIndexOf( abbr ? upperMonths[ 1 ] : upperMonths[ 0 ], value );
            if ( i < 0 ) {
                i = this.arrayIndexOf( abbr ? upperMonthsGen[ 1 ] : upperMonthsGen[ 0 ], value );
            }
            return i;
        },

        appendPreOrPostMatch: function ( preMatch, strings ) {
            // appends pre- and post- token match strings while removing escaped characters.
            // Returns a single quote count which is used to determine if the token occurs
            // in a string literal.
            var quoteCount = 0,
                escaped = false;
            for ( var i = 0, il = preMatch.length; i < il; i++ ) {
                var c = preMatch.charAt( i );
                switch ( c ) {
                    case '\'':
                        if ( escaped ) {
                            strings.push( "'" );
                        }
                        else {
                            quoteCount++;
                        }
                        escaped = false;
                        break;
                    case '\\':
                        if ( escaped ) {
                            strings.push( "\\" );
                        }
                        escaped = !escaped;
                        break;
                    default:
                        strings.push( c );
                        escaped = false;
                        break;
                }
            }
            return quoteCount;
        },

        getTokenRegExp: function () {
            // regular expression for matching date and time tokens in format strings.
            return /\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g;
        },

        formatlink: function ( value, format ) {
            var target = '';
            if ( format && format.target ) { target = 'target=' + format.target; }
            if ( target != '' ) {
                return "<a " + target + " href=\"" + value + "\">" + value + "</a>";
            }
            return "<a href=\"" + value + "\">" + value + "</a>";
        },

        formatemail: function ( value ) {
            return "<a href=\"mailto:" + value + "\">" + value + "</a>";
        },

        formatNumber: function ( value, format, calendar ) {
            return this.formatnumber( value, format, calendar );
        },

        formatnumber: function ( value, format, calendar ) {
            if ( calendar == undefined || calendar == null || calendar == "" ) {
                calendar = this.defaultcalendar();
            }

            if ( format === "" || format === null ) {
                return value;
            }

            if ( !this.isNumber( value ) ) {
                value *= 1;
            }
            var precision;
            if ( format.length > 1 ) precision = parseInt( format.slice( 1 ), 10 );

            var options = {}
            var current = format.charAt( 0 ).toUpperCase();

            options.thousandsSeparator = calendar.thousandsseparator;
            options.decimalSeparator = calendar.decimalseparator;
            switch ( current ) {
                case "D":
                case "d":
                case "F":
                case "f":
                    options.decimalPlaces = precision;
                    break;
                case "N":
                case "n":
                    options.decimalPlaces = 0;
                    break;
                case "C":
                case "c":
                    options.decimalPlaces = precision;
                    if ( calendar.currencysymbolposition == "before" ) {
                        options.prefix = calendar.currencysymbol;
                    }
                    else {
                        options.suffix = calendar.currencysymbol;
                    }
                    break;
                case "P":
                case "p":
                    options.suffix = calendar.percentsymbol;
                    options.decimalPlaces = precision;
                    break;
                default:
                    throw "Bad number format specifier: " + current;
            }

            if ( this.isNumber( value ) ) {
                var negative = ( value < 0 );
                var output = value + "";
                var decimalseparator = ( options.decimalSeparator ) ? options.decimalSeparator : ".";
                var decimalindex;
                if ( this.isNumber( options.decimalPlaces ) ) {
                    // Round to the correct decimal place
                    var decimalplaces = options.decimalPlaces;
                    var decimal = Math.pow( 10, decimalplaces );
                    output = ( value * decimal ).toFixed( 0 ) / decimal + "";
                    decimalindex = output.lastIndexOf( "." );
                    if ( decimalplaces > 0 ) {
                        // Add the decimal separator
                        if ( decimalindex < 0 ) {
                            output += decimalseparator;
                            decimalindex = output.length - 1;
                        }
                        // Replace the "."
                        else if ( decimalseparator !== "." ) {
                            output = output.replace( ".", decimalseparator );
                        }
                        // Add missing zeros
                        while ( ( output.length - 1 - decimalindex ) < decimalplaces ) {
                            output += "0";
                        }
                    }
                }
                else {
                    var output = value + "";
                    decimalindex = output.lastIndexOf( "." );
                    if ( decimalindex > 0 && decimalplaces == undefined ) {
                        // Replace the "."
                        if ( decimalseparator !== "." ) {
                            output = output.replace( ".", decimalseparator );
                        }
                    }
                }

                if ( options.thousandsSeparator ) {
                    var groupseparator = options.thousandsSeparator;
                    decimalindex = output.lastIndexOf( decimalseparator );
                    decimalindex = ( decimalindex > -1 ) ? decimalindex : output.length;
                    var newoutput = output.substring( decimalindex );
                    var nCount = -1;
                    for ( var i = decimalindex; i > 0; i-- ) {
                        nCount++;
                        if ( ( nCount % 3 === 0 ) && ( i !== decimalindex ) && ( !negative || ( i > 1 ) ) ) {
                            newoutput = groupseparator + newoutput;
                        }
                        newoutput = output.charAt( i - 1 ) + newoutput;
                    }
                    output = newoutput;
                }
                // Prepend prefix
                output = ( options.prefix ) ? options.prefix + output : output;
                // Append suffix
                output = ( options.suffix ) ? output + options.suffix : output;
                return output;

            } else {
                return value;
            }
        },

        tryparsedate: function ( value, calendar ) {
            if ( calendar == undefined || calendar == null ) {
                calendar = this.defaultcalendar();
            }
            var me = this;
            if ( value == "" )
                return null;

            if ( value != null && !value.substring ) {
                value = value.toString();
            }

            if ( value != null && value.substring( 0, 6 ) == "/Date(" ) {
                var jsonDateRE = /^\/Date\((-?\d+)(\+|-)?(\d+)?\)\/$/;

                var date = new Date( +value.replace( /\/Date\((\d+)\)\//, '$1' ) );
                if ( date == "Invalid Date" ) {
                    var m = value.match( /^\/Date\((\d+)([-+]\d\d)(\d\d)\)\/$/ );
                    var date = null;
                    if ( m )
                        date = new Date( 1 * m[ 1 ] + 3600000 * m[ 2 ] + 60000 * m[ 3 ] );
                }
                if ( date == null || date == "Invalid Date" || isNaN( date ) ) {
                    var arr = jsonDateRE.exec( value );
                    if ( arr ) {
                        // 0 - complete results; 1 - ticks; 2 - sign; 3 - minutes
                        var result = new Date( parseInt( arr[ 1 ] ) );
                        if ( arr[ 2 ] ) {
                            var mins = parseInt( arr[ 3 ] );
                            if ( arr[ 2 ] === "-" ) {
                                mins = -mins;
                            }
                            var current = result.getUTCMinutes();
                            result.setUTCMinutes( current - mins );
                        }
                        if ( !isNaN( result.valueOf() ) ) {
                            return result;
                        }
                    }
                }

                return date;
            }

            var patterns = calendar.patterns;
            for ( var prop in patterns ) {
                date = me.parsedate( value, patterns[ prop ], calendar );
                if ( date ) {
                    if ( prop == "ISO" ) {
                        var tmpDate = me.parsedate( value, patterns[ "ISO2" ], calendar );
                        if ( tmpDate ) return tmpDate;
                    }
                    return date;
                }
            }

            if ( value != null ) {
                var tmpDate = null;
                var dateParts = [ ':', '/', '-' ];
                var canParse = true;
                for ( var part = 0; part < dateParts.length; part++ ) {
                    if ( value.indexOf( dateParts[ part ] ) != -1 ) {
                        canParse = false;
                    }
                }

                if ( canParse ) {
                    var number = new Number( value );
                    if ( !isNaN( number ) ) {
                        return new Date( number );
                    }
                }
            }

            if ( $.type( value ) === "string" ) {
                var that = me;
                value = that.trim( value );
                var splitParts = [ ':', '/', '-', ' ', ',' ];
                var replaceAll = function ( find, replace, str ) {
                    return str.replace( new RegExp( find, 'g' ), replace );
                }
                value = replaceAll( ', ', ',', value );
                var timePart = "";
                var datePart = value;
                if ( value.indexOf( ":" ) >= 0 ) {
                    timePart = value.substring( value.indexOf( ":" ) - 2 );
                    timePart = that.trim( timePart );
                    datePart = value.substring( 0, value.indexOf( ":" ) - 2 );
                }
                else if ( value.toUpperCase().indexOf( "AM" ) >= 0 ) {
                    timePart = value.substring( value.toUpperCase().indexOf( "AM" ) - 2 );
                    timePart = that.trim( timePart );
                    datePart = value.substring( 0, value.toUpperCase().indexOf( "AM" ) - 2 );
                }
                else if ( value.toUpperCase().indexOf( "PM" ) >= 0 ) {
                    timePart = value.substring( value.toUpperCase().indexOf( "PM" ) - 2 );
                    timePart = that.trim( timePart );
                    datePart = value.substring( 0, value.toUpperCase().indexOf( "PM" ) - 2 );
                }
                var parseDate = new Date();
                var parsed = false;
                if ( datePart ) {
                    for ( var i = 0; i < splitParts.length; i++ ) {
                        if ( datePart.indexOf( splitParts[ i ] ) >= 0 ) {
                            dateParts = datePart.split( splitParts[ i ] );
                            break;
                        }
                    }

                    var days = new Array();
                    var months = new Array();
                    var years = new Array();
                    var dayPart = null;
                    var monthPart = null;
                    for ( var i = 0; i < dateParts.length; i++ ) {
                        var part = dateParts[ i ];
                        var isDay = that.parsedate( part, "d", calendar ) || that.parsedate( part, "dd", calendar ) || that.parsedate( part, "ddd", calendar ) || that.parsedate( part, "dddd", calendar );
                        if ( isDay ) {
                            if ( part.length <= 2 ) {
                                dayPart = i;
                                days.push( isDay.getDate() );
                                break
                            }
                        }
                    }
                    for ( var i = 0; i < dateParts.length; i++ ) {
                        var part = dateParts[ i ];
                        var isMonth = that.parsedate( part, "M", calendar ) || that.parsedate( part, "MM", calendar ) || that.parsedate( part, "MMM", calendar ) || that.parsedate( part, "MMMM", calendar );
                        if ( isMonth ) {
                            if ( dayPart != undefined && dayPart == i )
                                continue;

                            months.push( isMonth.getMonth() );

                            if ( part.length > 2 ) {
                                monthPart = i;
                                break;
                            }
                        }
                    }
                    for ( var i = 0; i < dateParts.length; i++ ) {
                        var part = dateParts[ i ];
                        var isYear = that.parsedate( part, "yyyy", calendar );
                        if ( isYear ) {
                            if ( dayPart != undefined && dayPart == i )
                                continue;

                            if ( monthPart != undefined && monthPart == i )
                                continue;

                            years.push( isYear.getFullYear() );
                        }
                    }
                    var dates = new Array();
                    for ( var d = 0; d < days.length; d++ ) {
                        for ( var m = 0; m < months.length; m++ ) {
                            for ( var y = 0; y < years.length; y++ ) {
                                var result = new Date( years[ y ], months[ m ], days[ d ] );
                                if ( years[ y ] < 1970 )
                                    result.setFullYear( years[ y ] );
                                if ( result.getTime() != NaN ) {
                                    dates.push( result );
                                }
                            }
                        }
                    }
                    if ( dates.length > 0 ) {
                        parseDate = dates[ 0 ];
                        parsed = true;
                    }
                }
                if ( timePart ) {
                    var timeParts = timePart.indexOf( ":" ) >= 0 ? timePart.split( ':' ) : timePart;
                    var parsedTime = that.parsedate( timePart, "h:mm tt", calendar ) || that.parsedate( timePart, "h:mm:ss tt", calendar ) || that.parsedate( timePart, "HH:mm:ss.fff", calendar ) || that.parsedate( timePart, "HH:mm:ss.ff", calendar ) || that.parsedate( timePart, "HH:mm:ss.tttt", calendar ) || that.parsedate( timePart, "HH:mm:ss", calendar ) || that.parsedate( timePart, "HH:mm", calendar ) || that.parsedate( timePart, "HH", calendar );

                    var hour = 0, minute = 0, second = 0, milisecond = 0;
                    if ( parsedTime && parsedTime.getTime() != NaN ) {
                        hour = parsedTime.getHours();
                        minute = parsedTime.getMinutes();
                        second = parsedTime.getSeconds();
                        milisecond = parsedTime.getMilliseconds();
                    }
                    else {
                        if ( timeParts.length == 1 ) {
                            hour = parseInt( timeParts[ 0 ] );
                        }
                        if ( timeParts.length == 2 ) {
                            hour = parseInt( timeParts[ 0 ] );
                            minute = parseInt( timeParts[ 1 ] );
                        }
                        if ( timeParts.length == 3 ) {
                            hour = parseInt( timeParts[ 0 ] );
                            minute = parseInt( timeParts[ 1 ] );
                            if ( timeParts[ 2 ].indexOf( "." ) >= 0 ) {
                                second = parseInt( timeParts[ 2 ].toString().split( "." )[ 0 ] );
                                milisecond = parseInt( timeParts[ 2 ].toString().split( "." )[ 1 ] );
                            }
                            else {
                                second = parseInt( timeParts[ 2 ] );
                            }
                        }
                        if ( timeParts.length == 4 ) {
                            hour = parseInt( timeParts[ 0 ] );
                            minute = parseInt( timeParts[ 1 ] );
                            second = parseInt( timeParts[ 2 ] );
                            milisecond = parseInt( timeParts[ 3 ] );
                        }
                    }
                    if ( parseDate && !isNaN( hour ) && !isNaN( minute ) && !isNaN( second ) && !isNaN( milisecond ) ) {
                        parseDate.setHours( hour, minute, second, milisecond );
                        parsed = true;
                    }
                }
                if ( parsed ) {
                    return parseDate;
                }
            }

            return null;
        },

        getparseregexp: function ( cal, format ) {
            // converts a format string into a regular expression with groups that
            // can be used to extract date fields from a date string.
            // check for a cached parse regex.
            var re = cal._parseRegExp;
            if ( !re ) {
                cal._parseRegExp = re = {};
            }
            else {
                var reFormat = re[ format ];
                if ( reFormat ) {
                    return reFormat;
                }
            }

            // expand single digit formats, then escape regular expression characters.
            var expFormat = this.expandFormat( cal, format ).replace( /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\\\$1" ),
                regexp = [ "^" ],
                groups = [],
                index = 0,
                quoteCount = 0,
                tokenRegExp = this.getTokenRegExp(),
                match;

            // iterate through each date token found.
            while ( ( match = tokenRegExp.exec( expFormat ) ) !== null ) {
                var preMatch = expFormat.slice( index, match.index );
                index = tokenRegExp.lastIndex;

                // don't replace any matches that occur inside a string literal.
                quoteCount += this.appendPreOrPostMatch( preMatch, regexp );
                if ( quoteCount % 2 ) {
                    regexp.push( match[ 0 ] );
                    continue;
                }

                // add a regex group for the token.
                var m = match[ 0 ],
                    len = m.length,
                    add;
                switch ( m ) {
                    case 'dddd': case 'ddd':
                    case 'MMMM': case 'MMM':
                    case 'gg': case 'g':
                        add = "(\\D+)";
                        break;
                    case 'tt': case 't':
                        add = "(\\D*)";
                        break;
                    case 'yyyy':
                    case 'fff':
                    case 'ff':
                    case 'f':
                        add = "(\\d{" + len + "})";
                        break;
                    case 'dd': case 'd':
                    case 'MM': case 'M':
                    case 'yy': case 'y':
                    case 'HH': case 'H':
                    case 'hh': case 'h':
                    case 'mm': case 'm':
                    case 'ss': case 's':
                        add = "(\\d\\d?)";
                        break;
                    case 'zzz':
                        add = "([+-]?\\d\\d?:\\d{2})";
                        break;
                    case 'zz': case 'z':
                        add = "([+-]?\\d\\d?)";
                        break;
                    case '/':
                        add = "(\\" + cal[ "/" ] + ")";
                        break;
                    default:
                        throw "Invalid date format pattern '" + m + "'.";
                        break;
                }
                if ( add ) {
                    regexp.push( add );
                }
                groups.push( match[ 0 ] );
            }
            this.appendPreOrPostMatch( expFormat.slice( index ), regexp );
            regexp.push( "$" );

            // allow whitespace to differ when matching formats.
            var regexpStr = regexp.join( '' ).replace( /\s+/g, "\\s+" ),
                parseRegExp = { 'regExp': regexpStr, 'groups': groups };

            // cache the regex for this format.
            return re[ format ] = parseRegExp;
        },

        outOfRange: function ( value, low, high ) {
            return value < low || value > high;
        },

        expandYear: function ( cal, year ) {
            // expands 2-digit year into 4 digits.
            var now = new Date(),
                era = this.getEra( now );
            if ( year < 100 ) {
                var twoDigitYearMax = cal.twoDigitYearMax;
                twoDigitYearMax = typeof twoDigitYearMax === 'string' ? new Date().getFullYear() % 100 + parseInt( twoDigitYearMax, 10 ) : twoDigitYearMax;
                var curr = this.getEraYear( now, cal, era );
                year += curr - ( curr % 100 );
                if ( year > twoDigitYearMax ) {
                    year -= 100;
                }
            }
            return year;
        },

        parsedate: function ( value, format, calendar ) {
            if ( calendar == undefined || calendar == null ) {
                calendar = this.defaultcalendar();
            }
            // try to parse the date string by matching against the format string
            // while using the specified culture for date field names.
            value = this.trim( value );
            var cal = calendar,
                // convert date formats into regular expressions with groupings.
                // use the regexp to determine the input format and extract the date fields.
                parseInfo = this.getparseregexp( cal, format ),
                match = new RegExp( parseInfo.regExp ).exec( value );
            if ( match === null ) {
                return null;
            }
            // found a date format that matches the input.
            var groups = parseInfo.groups,
                era = null, year = null, month = null, date = null, weekDay = null,
                hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,
                pmHour = false;
            // iterate the format groups to extract and set the date fields.
            for ( var j = 0, jl = groups.length; j < jl; j++ ) {
                var matchGroup = match[ j + 1 ];
                if ( matchGroup ) {
                    var current = groups[ j ],
                        clength = current.length,
                        matchInt = parseInt( matchGroup, 10 );
                    switch ( current ) {
                        case 'dd': case 'd':
                            // Day of month.
                            date = matchInt;
                            // check that date is generally in valid range, also checking overflow below.
                            if ( this.outOfRange( date, 1, 31 ) ) return null;
                            break;
                        case 'MMM':
                        case 'MMMM':
                            month = this.getMonthIndex( cal, matchGroup, clength === 3 );
                            if ( this.outOfRange( month, 0, 11 ) ) return null;
                            break;
                        case 'M': case 'MM':
                            // Month.
                            month = matchInt - 1;
                            if ( this.outOfRange( month, 0, 11 ) ) return null;
                            break;
                        case 'y': case 'yy':
                        case 'yyyy':
                            year = clength < 4 ? this.expandYear( cal, matchInt ) : matchInt;
                            if ( this.outOfRange( year, 0, 9999 ) ) return null;
                            break;
                        case 'h': case 'hh':
                            // Hours (12-hour clock).
                            hour = matchInt;
                            if ( hour === 12 ) hour = 0;
                            if ( this.outOfRange( hour, 0, 11 ) ) return null;
                            break;
                        case 'H': case 'HH':
                            // Hours (24-hour clock).
                            hour = matchInt;
                            if ( this.outOfRange( hour, 0, 23 ) ) return null;
                            break;
                        case 'm': case 'mm':
                            // Minutes.
                            min = matchInt;
                            if ( this.outOfRange( min, 0, 59 ) ) return null;
                            break;
                        case 's': case 'ss':
                            // Seconds.
                            sec = matchInt;
                            if ( this.outOfRange( sec, 0, 59 ) ) return null;
                            break;
                        case 'tt': case 't':
                            // AM/PM designator.
                            // see if it is standard, upper, or lower case PM. If not, ensure it is at least one of
                            // the AM tokens. If not, fail the parse for this format.
                            pmHour = cal.PM && ( matchGroup === cal.PM[ 0 ] || matchGroup === cal.PM[ 1 ] || matchGroup === cal.PM[ 2 ] );
                            if ( !pmHour && ( !cal.AM || ( matchGroup !== cal.AM[ 0 ] && matchGroup !== cal.AM[ 1 ] && matchGroup !== cal.AM[ 2 ] ) ) ) return null;
                            break;
                        case 'f':
                        // Deciseconds.
                        case 'ff':
                        // Centiseconds.
                        case 'fff':
                            // Milliseconds.
                            msec = matchInt * Math.pow( 10, 3 - clength );
                            if ( this.outOfRange( msec, 0, 999 ) ) return null;
                            break;
                        case 'ddd':
                        // Day of week.
                        case 'dddd':
                            // Day of week.
                            weekDay = this.getDayIndex( cal, matchGroup, clength === 3 );
                            if ( this.outOfRange( weekDay, 0, 6 ) ) return null;
                            break;
                        case 'zzz':
                            // Time zone offset in +/- hours:min.
                            var offsets = matchGroup.split( /:/ );
                            if ( offsets.length !== 2 ) return null;
                            hourOffset = parseInt( offsets[ 0 ], 10 );
                            if ( this.outOfRange( hourOffset, -12, 13 ) ) return null;
                            var minOffset = parseInt( offsets[ 1 ], 10 );
                            if ( this.outOfRange( minOffset, 0, 59 ) ) return null;
                            tzMinOffset = ( hourOffset * 60 ) + ( this.startsWith( matchGroup, '-' ) ? -minOffset : minOffset );
                            break;
                        case 'z': case 'zz':
                            // Time zone offset in +/- hours.
                            hourOffset = matchInt;
                            if ( this.outOfRange( hourOffset, -12, 13 ) ) return null;
                            tzMinOffset = hourOffset * 60;
                            break;
                        case 'g': case 'gg':
                            var eraName = matchGroup;
                            if ( !eraName || !cal.eras ) return null;
                            eraName = this.trim( eraName.toLowerCase() );
                            for ( var i = 0, l = cal.eras.length; i < l; i++ ) {
                                if ( eraName === cal.eras[ i ].name.toLowerCase() ) {
                                    era = i;
                                    break;
                                }
                            }
                            // could not find an era with that name
                            if ( era === null ) return null;
                            break;
                    }
                }
            }
            var result = new Date(), defaultYear, convert = cal.convert;
            defaultYear = result.getFullYear();
            if ( year === null ) {
                year = defaultYear;
            }
            else if ( cal.eras ) {
                // year must be shifted to normal gregorian year
                // but not if year was not specified, its already normal gregorian
                // per the main if clause above.
                year += cal.eras[ ( era || 0 ) ].offset;
            }
            // set default day and month to 1 and January, so if unspecified, these are the defaults
            // instead of the current day/month.
            if ( month === null ) {
                month = 0;
            }
            if ( date === null ) {
                date = 1;
            }
            // now have year, month, and date, but in the culture's calendar.
            // convert to gregorian if necessary
            if ( convert ) {
                result = convert.toGregorian( year, month, date );
                // conversion failed, must be an invalid match
                if ( result === null ) return null;
            }
            else {
                // have to set year, month and date together to avoid overflow based on current date.
                result.setFullYear( year, month, date );
                // check to see if date overflowed for specified month (only checked 1-31 above).
                if ( result.getDate() !== date ) return null;
                // invalid day of week.
                if ( weekDay !== null && result.getDay() !== weekDay ) {
                    return null;
                }
            }
            // if pm designator token was found make sure the hours fit the 24-hour clock.
            if ( pmHour && hour < 12 ) {
                hour += 12;
            }
            result.setHours( hour, min, sec, msec );
            if ( tzMinOffset !== null ) {
                // adjust timezone to utc before applying local offset.
                var adjustedMin = result.getMinutes() - ( tzMinOffset + result.getTimezoneOffset() );
                // Safari limits hours and minutes to the range of -127 to 127.  We need to use setHours
                // to ensure both these fields will not exceed this range.  adjustedMin will range
                // somewhere between -1440 and 1500, so we only need to split this into hours.
                result.setHours( result.getHours() + parseInt( adjustedMin / 60, 10 ), adjustedMin % 60 );
            }
            return result;
        },

        cleardatescache: function () {
            this.datescache = new Array();
        },

        formatDate: function ( value, format, calendar ) {
            return this.formatdate( value, format, calendar );
        },

        formatdate: function ( value, format, calendar ) {
            if ( calendar == undefined || calendar == null ) {
                calendar = this.defaultcalendar();
            }

            if ( typeof value === 'string' ) {
                return value;
            }

            var lookupkey = value.toString() + "_" + format;
            if ( this.datescache && this.datescache[ lookupkey ] ) {
                if ( format.indexOf( 'f' ) == -1 ) {
                    return this.datescache[ lookupkey ];
                }
            }

            if ( !format || !format.length || format === 'i' ) {
                var ret;
                ret = this.formatDate( value, calendar.patterns.F, calendar );
                return ret;
            }

            var eras = calendar.eras,
                sortable = format === "s";
            format = this.expandFormat( calendar, format );

            // Start with an empty string
            ret = [];
            var hour,
                zeros = [ '0', '00', '000' ],
                foundDay,
                checkedDay,
                dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,
                quoteCount = 0,
                tokenRegExp = this.getTokenRegExp(),
                converted;

            function padZeros( num, c ) {
                var r, s = num + '';
                if ( c > 1 && s.length < c ) {
                    r = ( zeros[ c - 2 ] + s );
                    return r.substr( r.length - c, c );
                }
                else {
                    r = s;
                }
                return r;
            }

            function hasDay() {
                if ( foundDay || checkedDay ) {
                    return foundDay;
                }
                foundDay = dayPartRegExp.test( format );
                checkedDay = true;
                return foundDay;
            }

            function getPart( date, part ) {
                if ( converted ) {
                    return converted[ part ];
                }
                if ( date.getMonth != undefined ) {
                    switch ( part ) {
                        case 0: return date.getFullYear();
                        case 1: return date.getMonth();
                        case 2: return date.getDate();
                    }
                }
            }

            for ( ; ; ) {
                // Save the current index
                var index = tokenRegExp.lastIndex,
                    // Look for the next pattern
                    ar = tokenRegExp.exec( format );

                // Append the text before the pattern (or the end of the string if not found)
                var preMatch = format.slice( index, ar ? ar.index : format.length );
                quoteCount += this.appendPreOrPostMatch( preMatch, ret );

                if ( !ar ) {
                    break;
                }

                // do not replace any matches that occur inside a string literal.
                if ( quoteCount % 2 ) {
                    ret.push( ar[ 0 ] );
                    continue;
                }

                var current = ar[ 0 ],
                    clength = current.length;

                switch ( current ) {
                    case "ddd":
                    //Day of the week, as a three-letter abbreviation
                    case "dddd":
                        // Day of the week, using the full name
                        var names = ( clength === 3 ) ? calendar.days.namesAbbr : calendar.days.names;
                        ret.push( names[ value.getDay() ] );
                        break;
                    case "d":
                    // Day of month, without leading zero for single-digit days
                    case "dd":
                        // Day of month, with leading zero for single-digit days
                        foundDay = true;
                        ret.push( padZeros( getPart( value, 2 ), clength ) );
                        break;
                    case "MMM":
                    // Month, as a three-letter abbreviation
                    case "MMMM":
                        // Month, using the full name
                        var part = getPart( value, 1 );
                        ret.push( calendar.months[ clength === 3 ? "namesAbbr" : "names" ][ part ] );
                        break;
                    case "M":
                    // Month, as digits, with no leading zero for single-digit months
                    case "MM":
                        // Month, as digits, with leading zero for single-digit months
                        ret.push( padZeros( getPart( value, 1 ) + 1, clength ) );
                        break;
                    case "y":
                    // Year, as two digits, but with no leading zero for years less than 10
                    case "yy":
                    // Year, as two digits, with leading zero for years less than 10
                    case "yyyy":
                        // Year represented by four full digits
                        part = this.getEraYear( value, calendar, this.getEra( value, eras ), sortable );
                        if ( clength < 4 ) {
                            part = part % 100;
                        }
                        ret.push( padZeros( part, clength ) );
                        break;
                    case "h":
                    // Hours with no leading zero for single-digit hours, using 12-hour clock
                    case "hh":
                        // Hours with leading zero for single-digit hours, using 12-hour clock
                        hour = value.getHours() % 12;
                        if ( hour === 0 ) hour = 12;
                        ret.push( padZeros( hour, clength ) );
                        break;
                    case "H":
                    // Hours with no leading zero for single-digit hours, using 24-hour clock
                    case "HH":
                        // Hours with leading zero for single-digit hours, using 24-hour clock
                        ret.push( padZeros( value.getHours(), clength ) );
                        break;
                    case "m":
                    // Minutes with no leading zero  for single-digit minutes
                    case "mm":
                        // Minutes with leading zero  for single-digit minutes
                        ret.push( padZeros( value.getMinutes(), clength ) );
                        break;
                    case "s":
                    // Seconds with no leading zero for single-digit seconds
                    case "ss":
                        // Seconds with leading zero for single-digit seconds
                        ret.push( padZeros( value.getSeconds(), clength ) );
                        break;
                    case "t":
                    // One character am/pm indicator ("a" or "p")
                    case "tt":
                        // Multicharacter am/pm indicator
                        part = value.getHours() < 12 ? ( calendar.AM ? calendar.AM[ 0 ] : " " ) : ( calendar.PM ? calendar.PM[ 0 ] : " " );
                        ret.push( clength === 1 ? part.charAt( 0 ) : part );
                        break;
                    case "f":
                    // Deciseconds
                    case "ff":
                    // Centiseconds
                    case "fff":
                        // Milliseconds
                        ret.push( padZeros( value.getMilliseconds(), 3 ).substr( 0, clength ) );
                        break;
                    case "z":
                    // Time zone offset, no leading zero
                    case "zz":
                        // Time zone offset with leading zero
                        hour = value.getTimezoneOffset() / 60;
                        ret.push( ( hour <= 0 ? '+' : '-' ) + padZeros( Math.floor( Math.abs( hour ) ), clength ) );
                        break;
                    case "zzz":
                        // Time zone offset with leading zero
                        hour = value.getTimezoneOffset() / 60;
                        ret.push( ( hour <= 0 ? '+' : '-' ) + padZeros( Math.floor( Math.abs( hour ) ), 2 ) +
                            // Hard coded ":" separator, rather than using calendar.TimeSeparator
                            // Repeated here for consistency, plus ":" was already assumed in date parsing.
                            ":" + padZeros( Math.abs( value.getTimezoneOffset() % 60 ), 2 ) );
                        break;
                    case "g":
                    case "gg":
                        if ( calendar.eras ) {
                            ret.push( calendar.eras[ this.getEra( value, eras ) ].name );
                        }
                        break;
                    case "/":
                        ret.push( calendar[ "/" ] );
                        break;
                    default:
                        throw "Invalid date format pattern '" + current + "'.";
                        break;
                }
            }

            var result = ret.join( '' );

            if ( !this.datescache ) {
                this.datescache = new Array();
            }

            this.datescache[ lookupkey ] = result;
            return result;
        }
    } );

    // AJAX
    $.jqx.data = {};
    var
        ajaxLocParts,
        ajaxLocation,

        rhash = /#.*$/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,
        rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rquery = /\?/,
        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        rts = /([?&])_=[^&]*/,
        rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
        core_rspace = /\s+/,
        _load = $.fn.load,
        prefilters = {},
        transports = {},
        allTypes = [ "*/" ] + [ "*" ];

    try {
        ajaxLocation = location.href;
    } catch ( e ) {
        ajaxLocation = document.createElement( "a" );
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

    ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

    function addToPrefiltersOrTransports( structure ) {

        return function ( dataTypeExpression, func ) {

            if ( typeof dataTypeExpression !== "string" ) {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType, list, placeBefore,
                dataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),
                i = 0,
                length = dataTypes.length;

            if ( $.isFunction( func ) ) {
                for ( ; i < length; i++ ) {
                    dataType = dataTypes[ i ];
                    placeBefore = /^\+/.test( dataType );
                    if ( placeBefore ) {
                        dataType = dataType.substr( 1 ) || "*";
                    }
                    list = structure[ dataType ] = structure[ dataType ] || [];
                    list[ placeBefore ? "unshift" : "push" ]( func );
                }
            }
        };
    }

    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
        dataType /* internal */, inspected /* internal */ ) {

        dataType = dataType || options.dataTypes[ 0 ];
        inspected = inspected || {};

        inspected[ dataType ] = true;

        var selection,
            list = structure[ dataType ],
            i = 0,
            length = list ? list.length : 0,
            executeOnly = ( structure === prefilters );

        for ( ; i < length && ( executeOnly || !selection ); i++ ) {
            selection = list[ i ]( options, originalOptions, jqXHR );
            if ( typeof selection === "string" ) {
                if ( !executeOnly || inspected[ selection ] ) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift( selection );
                    selection = inspectPrefiltersOrTransports(
                        structure, options, originalOptions, jqXHR, selection, inspected );
                }
            }
        }
        if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
            selection = inspectPrefiltersOrTransports(
                structure, options, originalOptions, jqXHR, "*", inspected );
        }
        return selection;
    }

    function ajaxExtend( target, src ) {
        var key, deep,
            flatOptions = $.jqx.data.ajaxSettings.flatOptions || {};
        for ( key in src ) {
            if ( src[ key ] !== undefined ) {
                ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
            }
        }
        if ( deep ) {
            $.extend( true, target, deep );
        }
    }

    $.extend( $.jqx.data, {
        ajaxSetup: function ( target, settings ) {
            if ( settings ) {
                ajaxExtend( target, $.jqx.data.ajaxSettings );
            } else {
                settings = target;
                target = $.jqx.data.ajaxSettings;
            }
            ajaxExtend( target, settings );
            return target;
        },

        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            processData: true,
            async: true,

            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": allTypes
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },

            converters: {
                "* text": window.String,
                "text html": true,
                "text json": $.parseJSON,
                "text xml": $.parseXML
            },

            flatOptions: {
                context: true,
                url: true
            }
        },

        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
        ajaxTransport: addToPrefiltersOrTransports( transports ),

        ajax: function ( url, options ) {

            if ( typeof url === "object" ) {
                options = url;
                url = undefined;
            }

            options = options || {};

            var ifModifiedKey,
                responseHeadersString,
                responseHeaders,
                transport,
                timeoutTimer,
                parts,
                fireGlobals,
                i,
                s = $.jqx.data.ajaxSetup( {}, options ),
                callbackContext = s.context || s,
                globalEventContext = callbackContext !== s &&
                    ( callbackContext.nodeType || callbackContext instanceof $ ) ?
                    $( callbackContext ) : $.event,
                deferred = $.Deferred(),
                completeDeferred = $.Callbacks( "once memory" ),
                statusCode = s.statusCode || {},
                requestHeaders = {},
                requestHeadersNames = {},
                state = 0,
                strAbort = "canceled",
                jqXHR = {
                    readyState: 0,
                    setRequestHeader: function ( name, value ) {
                        if ( !state ) {
                            var lname = name.toLowerCase();
                            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                            requestHeaders[ name ] = value;
                        }
                        return this;
                    },
                    getAllResponseHeaders: function () {
                        return state === 2 ? responseHeadersString : null;
                    },
                    getResponseHeader: function ( key ) {
                        var match;
                        if ( state === 2 ) {
                            if ( !responseHeaders ) {
                                responseHeaders = {};
                                while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                    responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
                                }
                            }
                            match = responseHeaders[ key.toLowerCase() ];
                        }
                        return match === undefined ? null : match;
                    },

                    overrideMimeType: function ( type ) {
                        if ( !state ) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    abort: function ( statusText ) {
                        statusText = statusText || strAbort;
                        if ( transport ) {
                            transport.abort( statusText );
                        }
                        done( 0, statusText );
                        return this;
                    }
                };

            function done( status, nativeStatusText, responses, headers ) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;

                if ( state === 2 ) {
                    return;
                }

                state = 2;
                if ( timeoutTimer ) {
                    clearTimeout( timeoutTimer );
                }

                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;

                if ( responses ) {
                    response = ajaxHandleResponses( s, jqXHR, responses );
                }

                if ( status >= 200 && status < 300 || status === 304 ) {

                    if ( s.ifModified ) {

                        modified = jqXHR.getResponseHeader( "Last-Modified" );
                        if ( modified ) {
                            $.lastModified[ ifModifiedKey ] = modified;
                        }
                        modified = jqXHR.getResponseHeader( "Etag" );
                        if ( modified ) {
                            $.etag[ ifModifiedKey ] = modified;
                        }
                    }

                    if ( status === 304 ) {
                        statusText = "notmodified";
                        isSuccess = true;
                    } else {

                        isSuccess = ajaxConvert( s, response );
                        statusText = isSuccess.state;
                        success = isSuccess.data;
                        error = isSuccess.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if ( !statusText || status ) {
                        statusText = "error";
                        if ( status < 0 ) {
                            status = 0;
                        }
                    }
                }

                jqXHR.status = status;
                jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                if ( isSuccess ) {
                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                } else {
                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                }

                jqXHR.statusCode( statusCode );
                statusCode = undefined;

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
                        [ jqXHR, s, isSuccess ? success : error ] );
                }

                completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                    if ( !( --$.active ) ) {
                        $.event.trigger( "ajaxStop" );
                    }
                }
            }

            deferred.promise( jqXHR );
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.add;

            jqXHR.statusCode = function ( map ) {
                if ( map ) {
                    var tmp;
                    if ( state < 2 ) {
                        for ( tmp in map ) {
                            statusCode[ tmp ] = [ statusCode[ tmp ], map[ tmp ] ];
                        }
                    } else {
                        tmp = map[ jqXHR.status ];
                        jqXHR.always( tmp );
                    }
                }
                return this;
            };

            s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
            s.dataTypes = $.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );

            if ( s.crossDomain == null ) {
                parts = rurl.exec( s.url.toLowerCase() );
                s.crossDomain = !!( parts &&
                    ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                        ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
                );
            }

            if ( s.data && s.processData && typeof s.data !== "string" ) {
                s.data = $.param( s.data, s.traditional );
            }

            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

            if ( state === 2 ) {
                return jqXHR;
            }

            fireGlobals = s.global;
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test( s.type );

            if ( fireGlobals && $.active++ === 0 ) {
                $.event.trigger( "ajaxStart" );
            }

            if ( !s.hasContent ) {
                if ( s.data ) {
                    s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
                    delete s.data;
                }

                ifModifiedKey = s.url;

                if ( s.cache === false ) {

                    var ts = ( new Date() ).getTime(),
                        ret = s.url.replace( rts, "$1_=" + ts );

                    s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
                }
            }

            if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                jqXHR.setRequestHeader( "Content-Type", s.contentType );
            }

            if ( s.ifModified ) {
                ifModifiedKey = ifModifiedKey || s.url;
                if ( $.lastModified[ ifModifiedKey ] ) {
                    jqXHR.setRequestHeader( "If-Modified-Since", $.lastModified[ ifModifiedKey ] );
                }
                if ( $.etag[ ifModifiedKey ] ) {
                    jqXHR.setRequestHeader( "If-None-Match", $.etag[ ifModifiedKey ] );
                }
            }

            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
                    s.accepts[ s.dataTypes[ 0 ] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts[ "*" ]
            );

            for ( i in s.headers ) {
                jqXHR.setRequestHeader( i, s.headers[ i ] );
            }

            if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                return jqXHR.abort();

            }

            strAbort = "abort";

            for ( i in { success: 1, error: 1, complete: 1 } ) {
                jqXHR[ i ]( s[ i ] );
            }

            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

            if ( !transport ) {
                done( -1, "No Transport" );
            } else {
                jqXHR.readyState = 1;
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                }
                if ( s.async && s.timeout > 0 ) {
                    timeoutTimer = setTimeout( function () {
                        jqXHR.abort( "timeout" );
                    }, s.timeout );
                }

                try {
                    state = 1;
                    transport.send( requestHeaders, done );
                } catch ( e ) {
                    if ( state < 2 ) {
                        done( -1, e );
                    } else {
                        throw e;
                    }
                }
            }

            return jqXHR;
        },

        active: 0,

        lastModified: {},
        etag: {}

    } );

    function ajaxHandleResponses( s, jqXHR, responses ) {

        var ct, type, finalDataType, firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes,
            responseFields = s.responseFields;

        for ( type in responseFields ) {
            if ( type in responses ) {
                jqXHR[ responseFields[ type ] ] = responses[ type ];
            }
        }

        while ( dataTypes[ 0 ] === "*" ) {
            dataTypes.shift();
            if ( ct === undefined ) {
                ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
            }
        }

        if ( ct ) {
            for ( type in contents ) {
                if ( contents[ type ] && contents[ type ].test( ct ) ) {
                    dataTypes.unshift( type );
                    break;
                }
            }
        }

        if ( dataTypes[ 0 ] in responses ) {
            finalDataType = dataTypes[ 0 ];
        } else {
            for ( type in responses ) {
                if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
                    finalDataType = type;
                    break;
                }
                if ( !firstDataType ) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }

        if ( finalDataType ) {
            if ( finalDataType !== dataTypes[ 0 ] ) {
                dataTypes.unshift( finalDataType );
            }
            return responses[ finalDataType ];
        }
    }

    function ajaxConvert( s, response ) {
        var conv, conv2, current, tmp,
            dataTypes = s.dataTypes.slice(),
            prev = dataTypes[ 0 ],
            converters = {},
            i = 0;

        if ( s.dataFilter ) {
            response = s.dataFilter( response, s.dataType );
        }

        if ( dataTypes[ 1 ] ) {
            for ( conv in s.converters ) {
                converters[ conv.toLowerCase() ] = s.converters[ conv ];
            }
        }

        for ( ; ( current = dataTypes[ ++i ] ); ) {
            if ( current !== "*" ) {
                if ( prev !== "*" && prev !== current ) {
                    conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                    if ( !conv ) {
                        for ( conv2 in converters ) {
                            tmp = conv2.split( " " );
                            if ( tmp[ 1 ] === current ) {
                                conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                    converters[ "* " + tmp[ 0 ] ];
                                if ( conv ) {
                                    if ( conv === true ) {
                                        conv = converters[ conv2 ];

                                    } else if ( converters[ conv2 ] !== true ) {
                                        current = tmp[ 0 ];
                                        dataTypes.splice( i--, 0, current );
                                    }

                                    break;
                                }
                            }
                        }
                    }

                    if ( conv !== true ) {
                        if ( conv && s[ "throws" ] ) {
                            response = conv( response );
                        } else {
                            try {
                                response = conv( response );
                            } catch ( e ) {
                                return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                            }
                        }
                    }
                }

                prev = current;
            }
        }

        return { state: "success", data: response };
    }
    var oldCallbacks = [],
        rquestion = /\?/,
        rjsonp = /(=)\?(?=&|$)|\?\?/,
        nonce = ( new Date() ).getTime();

    $.jqx.data.ajaxSetup( {
        jsonp: "callback",
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || ( $.expando + "_" + ( nonce++ ) );
            this[ callback ] = true;
            return callback;
        }
    } );

    $.jqx.data.ajaxPrefilter( "json jsonp", function ( s, originalSettings, jqXHR ) {

        var callbackName, overwritten, responseContainer,
            data = s.data,
            url = s.url,
            hasCallback = s.jsonp !== false,
            replaceInUrl = hasCallback && rjsonp.test( url ),
            replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
                !( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) &&
                rjsonp.test( data );

        if ( s.dataTypes[ 0 ] === "jsonp" || replaceInUrl || replaceInData ) {

            callbackName = s.jsonpCallback = $.isFunction( s.jsonpCallback ) ?
                s.jsonpCallback() :
                s.jsonpCallback;
            overwritten = window[ callbackName ];

            if ( replaceInUrl ) {
                s.url = url.replace( rjsonp, "$1" + callbackName );
            } else if ( replaceInData ) {
                s.data = data.replace( rjsonp, "$1" + callbackName );
            } else if ( hasCallback ) {
                s.url += ( rquestion.test( url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
            }

            s.converters[ "script json" ] = function () {
                if ( !responseContainer ) {
                    $.error( callbackName + " was not called" );
                }
                return responseContainer[ 0 ];
            };

            s.dataTypes[ 0 ] = "json";

            window[ callbackName ] = function () {
                responseContainer = arguments;
            };

            jqXHR.always( function () {
                window[ callbackName ] = overwritten;
                if ( s[ callbackName ] ) {
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    oldCallbacks.push( callbackName );
                }

                if ( responseContainer && $.isFunction( overwritten ) ) {
                    overwritten( responseContainer[ 0 ] );
                }

                responseContainer = overwritten = undefined;
            } );

            return "script";
        }
    } );

    $.jqx.data.ajaxSetup( {
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function ( text ) {
                $.globalEval( text );
                return text;
            }
        }
    } );

    $.jqx.data.ajaxPrefilter( "script", function ( s ) {
        if ( s.cache === undefined ) {
            s.cache = false;
        }
        if ( s.crossDomain ) {
            s.type = "GET";
            s.global = false;
        }
    } );

    $.jqx.data.ajaxTransport( "script", function ( s ) {
        if ( s.crossDomain ) {
            var script,
                head = document.head || document.getElementsByTagName( "head" )[ 0 ] || document.documentElement;

            return {

                send: function ( _, callback ) {

                    script = document.createElement( "script" );

                    script.async = "async";

                    if ( s.scriptCharset ) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    script.onload = script.onreadystatechange = function ( _, isAbort ) {

                        if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                            script.onload = script.onreadystatechange = null;

                            if ( head && script.parentNode ) {
                                head.removeChild( script );
                            }

                            script = undefined;

                            if ( !isAbort ) {
                                callback( 200, "success" );
                            }
                        }
                    };
                    head.insertBefore( script, head.firstChild );
                },

                abort: function () {
                    if ( script ) {
                        script.onload( 0, 1 );
                    }
                }
            };
        }
    } );
    var xhrCallbacks,
        xhrOnUnloadAbort = window.ActiveXObject ? function () {
            for ( var key in xhrCallbacks ) {
                xhrCallbacks[ key ]( 0, 1 );
            }
        } : false,
        xhrId = 0;

    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch ( e ) { }
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject( "Microsoft.XMLHTTP" );
        } catch ( e ) { }
    }

    $.jqx.data.ajaxSettings.xhr = window.ActiveXObject ?
        function () {
            return !this.isLocal && createStandardXHR() || createActiveXHR();
        } :
        createStandardXHR;

    ( function ( xhr ) {
        $.extend( $.support, {
            ajax: !!xhr,
            cors: !!xhr && ( "withCredentials" in xhr )
        } );
    } )( $.jqx.data.ajaxSettings.xhr() );

    if ( !$.support ) $.support = { ajax: true };
    if ( $.support.ajax ) {

        $.jqx.data.ajaxTransport( function ( s ) {
            if ( !s.crossDomain || $.support.cors ) {

                var callback;

                return {
                    send: function ( headers, complete ) {

                        var handle, i,
                            xhr = s.xhr();

                        if ( s.username ) {
                            xhr.open( s.type, s.url, s.async, s.username, s.password );
                        } else {
                            xhr.open( s.type, s.url, s.async );
                        }

                        if ( s.xhrFields ) {
                            for ( i in s.xhrFields ) {
                                xhr[ i ] = s.xhrFields[ i ];
                            }
                        }

                        if ( s.mimeType && xhr.overrideMimeType ) {
                            xhr.overrideMimeType( s.mimeType );
                        }


                        if ( !s.crossDomain && !headers[ "X-Requested-With" ] ) {
                            headers[ "X-Requested-With" ] = "XMLHttpRequest";
                        }

                        try {
                            for ( i in headers ) {
                                xhr.setRequestHeader( i, headers[ i ] );
                            }
                        } catch ( _ ) { }

                        xhr.send( ( s.hasContent && s.data ) || null );

                        callback = function ( _, isAbort ) {

                            var status,
                                statusText,
                                responseHeaders,
                                responses,
                                xml;
                            try {

                                if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
                                    callback = undefined;
                                    if ( handle ) {
                                        xhr.onreadystatechange = function () { };
                                        if ( xhrOnUnloadAbort ) {
                                            delete xhrCallbacks[ handle ];
                                        }
                                    }

                                    if ( isAbort ) {
                                        if ( xhr.readyState !== 4 ) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;

                                        if ( xml && xml.documentElement /* #4958 */ ) {
                                            responses.xml = xml;
                                        }

                                        try {
                                            responses.text = xhr.responseText;
                                        } catch ( e ) {
                                        }

                                        try {
                                            statusText = xhr.statusText;
                                        } catch ( e ) {
                                            statusText = "";
                                        }

                                        if ( !status && s.isLocal && !s.crossDomain ) {
                                            status = responses.text ? 200 : 404;
                                        } else if ( status === 1223 ) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch ( firefoxAccessException ) {
                                if ( !isAbort ) {
                                    complete( -1, firefoxAccessException );
                                }
                            }

                            if ( responses ) {
                                complete( status, statusText, responses, responseHeaders );
                            }
                        };

                        if ( !s.async ) {
                            callback();
                        } else if ( xhr.readyState === 4 ) {
                            setTimeout( callback, 0 );
                        } else {
                            handle = ++xhrId;
                            if ( xhrOnUnloadAbort ) {
                                if ( !xhrCallbacks ) {
                                    xhrCallbacks = {};
                                    $( window ).unload( xhrOnUnloadAbort );
                                }
                                xhrCallbacks[ handle ] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },

                    abort: function () {
                        if ( callback ) {
                            callback( 0, 1 );
                        }
                    }
                };
            }
        } );
    }
    $.jqx.filter = function () {
        this.operator = 'and';
        var and_operator = 0;
        var or_operator = 1;
        var stringcomparisonoperators = [ 'EMPTY', 'NOT_EMPTY', 'CONTAINS', 'CONTAINS_CASE_SENSITIVE',
            'DOES_NOT_CONTAIN', 'DOES_NOT_CONTAIN_CASE_SENSITIVE', 'STARTS_WITH', 'STARTS_WITH_CASE_SENSITIVE',
            'ENDS_WITH', 'ENDS_WITH_CASE_SENSITIVE', 'EQUAL', 'EQUAL_CASE_SENSITIVE', 'NULL', 'NOT_NULL' ];
        var numericcomparisonoperators = [ 'EQUAL', 'NOT_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'NULL', 'NOT_NULL' ];
        var datecomparisonoperators = [ 'EQUAL', 'NOT_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'NULL', 'NOT_NULL' ];
        var booleancomparisonoperators = [ 'EQUAL', 'NOT_EQUAL' ];

        var filters = new Array();
        var comparisonoperators = new Array();

        this.evaluate = function ( value ) {
            var result = true;
            for ( var i = 0; i < filters.length; i++ ) {
                var currentResult = filters[ i ].evaluate( value );
                if ( i == 0 ) {
                    result = currentResult;
                }
                else {
                    if ( comparisonoperators[ i ] == or_operator || comparisonoperators[ i ] == "or" )
                        result = result || currentResult;
                    else
                        result = result && currentResult;
                }
            }

            return result;
        }

        this.getfilterscount = function () {
            return filters.length;
        }

        this.setoperatorsbyfiltertype = function ( type, array ) {
            switch ( type ) {
                case "numericfilter":
                    numericcomparisonoperators = array;
                    break;
                case "stringfilter":
                    stringcomparisonoperators = array;
                    break;
                case "datefilter":
                    datecomparisonoperators = array;
                    break;
                case "booleanfilter":
                    booleancomparisonoperators = array;
                    break;
            }
        }

        this.getoperatorsbyfiltertype = function ( type ) {
            var array = new Array();
            switch ( type ) {
                case "numericfilter":
                    array = numericcomparisonoperators.slice( 0 );
                    break;
                case "stringfilter":
                    array = stringcomparisonoperators.slice( 0 );
                    break;
                case "datefilter":
                    array = datecomparisonoperators.slice( 0 );
                    break;
                case "booleanfilter":
                    array = booleancomparisonoperators.slice( 0 );
                    break;
            }
            return array;
        }

        var generatefilterkey = function () {
            var S4 = function () {
                return ( ( ( 1 + Math.random() ) * 0x10000 ) | 0 ).toString( 16 ).substring( 1 );
            };
            return ( S4() + "-" + S4() + "-" + S4() );
        }

        this.createfilter = function ( filtertype, filtervalue, filtercomparisonoperator, customfilter, formatstring, localization ) {
            if ( filtertype == null || filtertype == undefined )
                return null;

            switch ( filtertype ) {
                case 'numericfilter':
                    return new numericfilter( filtervalue, filtercomparisonoperator.toUpperCase() );
                case 'stringfilter':
                    return new stringfilter( filtervalue, filtercomparisonoperator.toUpperCase() );
                case 'datefilter':
                    return new datefilter( filtervalue, filtercomparisonoperator.toUpperCase(), formatstring, localization );
                case 'booleanfilter':
                    return new booleanfilter( filtervalue, filtercomparisonoperator.toUpperCase() );
                case 'custom':
                    return new filter( filtervalue, filtercomparisonoperator.toUpperCase(), customfilter );
            }

            throw new Error( "jqxGrid: There is no such filter type. The available filter types are: 'numericfilter', 'stringfilter', 'datefilter' and 'booleanfilter'" );
            return null;
        }

        this.getfilters = function () {
            var filtersarray = new Array();
            for ( var i = 0; i < filters.length; i++ ) {
                var filter = { value: filters[ i ].filtervalue, condition: filters[ i ].comparisonoperator, operator: comparisonoperators[ i ], type: filters[ i ].type };
                if ( filters[ i ].data ) {
                    filter.id = filters[ i ].data;
                }
                filtersarray[ i ] = filter;
            }
            return filtersarray;
        }

        this.addfilter = function ( comparisonoperator, filter ) {
            filters[ filters.length ] = filter;
            filter.key = generatefilterkey();
            comparisonoperators[ comparisonoperators.length ] = comparisonoperator;
        }

        this.removefilter = function ( filter ) {
            for ( var i = 0; i < filters.length; i++ ) {
                if ( filters[ i ].key == filter.key ) {
                    filters.splice( i, 1 );
                    comparisonoperators.splice( i, 1 );
                    break;
                }
            }
        }

        this.getoperatorat = function ( index ) {
            if ( index == undefined || index == null )
                return null;

            if ( index < 0 || index > filters.length )
                return null;

            return comparisonoperators[ index ];
        }

        this.setoperatorat = function ( index, comparisonoperator ) {
            if ( index == undefined || index == null )
                return null;

            if ( index < 0 || index > filters.length )
                return null;

            comparisonoperators[ comparisonoperator ] = comparisonoperator;
        }

        this.getfilterat = function ( index ) {
            if ( index == undefined || index == null )
                return null;

            if ( index < 0 || index > filters.length )
                return null;

            return filters[ index ];
        }

        this.setfilterat = function ( index, filter ) {
            if ( index == undefined || index == null )
                return null;

            if ( index < 0 || index > filters.length )
                return null;

            filter.key = generatefilterkey();
            filters[ index ] = filter;
        }

        this.clear = function () {
            filters = new Array();
            comparisonoperators = new Array();
        }

        var stringfilter = function ( filtervalue, comparisonoperator ) {
            this.filtervalue = filtervalue;
            this.comparisonoperator = comparisonoperator;
            this.type = 'stringfilter';
            this.evaluate = function ( value ) {
                var filtervalue = this.filtervalue;
                var comparisonoperator = this.comparisonoperator;
                if ( value == null || value == undefined || value == "" ) {
                    if ( comparisonoperator == 'NULL' )
                        return true;

                    if ( comparisonoperator == 'NOT_NULL' )
                        return false;

                    if ( comparisonoperator == "EQUAL" && value == filtervalue ) {
                        return true;
                    }

                    if ( comparisonoperator == "NOT_EQUAL" && value != filtervalue ) {
                        return true;
                    }

                    if ( comparisonoperator != 'EMPTY' )
                        return false;
                    else if ( value == "" )
                        return true;
                }

                var val = "";
                try {
                    val = value.toString();
                }
                catch ( error ) {
                    return true;
                }

                var compare = function ( val, filtervalue ) {
                    switch ( comparisonoperator ) {
                        case 'EQUAL':
                            return $.jqx.string.equalsIgnoreCase( val, filtervalue );
                        case 'EQUAL_CASE_SENSITIVE':
                            return $.jqx.string.equals( val, filtervalue );
                        case 'NOT_EQUAL':
                            return !$.jqx.string.equalsIgnoreCase( val, filtervalue );
                        case 'NOT_EQUAL_CASE_SENSITIVE':
                            return !$.jqx.string.equals( val, filtervalue );
                        case 'CONTAINS':
                            return $.jqx.string.containsIgnoreCase( val, filtervalue );
                        case 'CONTAINS_CASE_SENSITIVE':
                            return $.jqx.string.contains( val, filtervalue );
                        case 'DOES_NOT_CONTAIN':
                            return !$.jqx.string.containsIgnoreCase( val, filtervalue );
                        case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                            return !$.jqx.string.contains( val, filtervalue );
                        case 'EMPTY':
                            return val == '';
                        case 'NOT_EMPTY':
                            return val != '';
                        case 'NOT_NULL':
                            return val != null;
                        case 'STARTS_WITH':
                            return $.jqx.string.startsWithIgnoreCase( val, filtervalue );
                        case 'ENDS_WITH':
                            return $.jqx.string.endsWithIgnoreCase( val, filtervalue );
                        case 'ENDS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.endsWith( val, filtervalue );
                        case 'STARTS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.startsWith( val, filtervalue );
                        default:
                            return false;
                    }
                }

                var filterValues = new Array();
                if ( filtervalue && filtervalue.indexO && comparisonoperator !== 'NOT_EQUAL' ) {
                    if ( filtervalue.indexOf( "|" ) >= 0 || filtervalue.indexOf( " AND " ) >= 0 || filtervalue.indexOf( " OR " ) >= 0 || filtervalue.indexOf( " and " ) >= 0 || filtervalue.indexOf( " or " ) >= 0 ) {
                        var result = compare( val, filtervalue );
                        if ( result ) {
                            return result;
                        }

                        var andFilters = filtervalue.indexOf( " AND " ) >= 0 ? filtervalue.split( " AND " ) : new Array();
                        var orFilters = filtervalue.indexOf( " OR " ) >= 0 ? filtervalue.split( " OR " ) : new Array();
                        var andLowerCaseFilters = filtervalue.indexOf( " and " ) >= 0 ? filtervalue.split( " and " ) : new Array();
                        var orLowerCaseFilters = filtervalue.indexOf( " or " ) >= 0 ? filtervalue.split( " or " ) : new Array();
                        var delimiterFilters = filtervalue.indexOf( "|" ) >= 0 ? filtervalue.split( "|" ) : new Array();
                        if ( delimiterFilters.length > 0 ) {
                            for ( var i = 0; i < delimiterFilters.length; i++ ) {
                                delimiterFilters[ i ] = $.trim( delimiterFilters[ i ] );
                            }
                        }
                        var commaFilters = filtervalue.indexOf( " " ) >= 0 ? filtervalue.split( " " ) : new Array();
                        if ( commaFilters.length > 0 ) {
                            for ( var i = 0; i < commaFilters.length; i++ ) {
                                commaFilters[ i ] = $.trim( commaFilters[ i ] );
                            }
                        }

                        andFilters = andFilters.concat( commaFilters );
                        andFilters = andFilters.concat( andLowerCaseFilters );
                        orFilters = orFilters.concat( delimiterFilters );
                        orFilters = orFilters.concat( orLowerCaseFilters );

                        if ( andFilters.length > 0 ) {
                            for ( var i = 0; i < andFilters.length; i++ ) {
                                if ( !andFilters[ i ].indexOf( " OR " ) >= 0 ) {
                                    filterValues.push( andFilters[ i ] );
                                }
                            }
                        }
                        if ( orFilters.length > 0 ) {
                            for ( var i = 0; i < orFilters.length; i++ ) {
                                if ( !orFilters[ i ].indexOf( " AND " ) >= 0 ) {
                                    filterValues.push( orFilters[ i ] );
                                }
                            }
                        }

                        var filterresult = undefined;
                        for ( var j = 0; j < filterValues.length; j++ ) {
                            var value = filterValues[ j ];
                            var result = compare( val, value );
                            var filteroperator = j < andFilters.length ? "and" : "or";
                            if ( filterresult == undefined ) {
                                filterresult = result;
                            }
                            else {
                                if ( filteroperator == 'or' ) {
                                    filterresult = filterresult || result;
                                }
                                else {
                                    filterresult = filterresult && result;
                                }
                            }
                        }
                        return filterresult;
                    }
                }

                return compare( val, filtervalue );
            }
        }

        var booleanfilter = function ( filtervalue, comparisonoperator ) {
            this.filtervalue = filtervalue;
            this.comparisonoperator = comparisonoperator;
            this.type = 'booleanfilter';
            this.evaluate = function ( value ) {
                var filtervalue = this.filtervalue;
                var comparisonoperator = this.comparisonoperator;
                if ( value == null || value == undefined ) {
                    if ( comparisonoperator == 'NULL' )
                        return true;

                    return false;
                }

                var val = value;

                switch ( comparisonoperator ) {
                    case 'EQUAL':
                        return val == filtervalue || val.toString() == filtervalue.toString();
                    case 'NOT_EQUAL':
                        return val != filtervalue && val.toString() != filtervalue.toString();
                    default:
                        return false;
                }
            }
        }

        var numericfilter = function ( filtervalue, comparisonoperator ) {
            this.filtervalue = filtervalue;
            this.comparisonoperator = comparisonoperator;
            this.type = 'numericfilter';
            this.evaluate = function ( value ) {
                var filtervalue = this.filtervalue;
                var comparisonoperator = this.comparisonoperator;
                if ( value === null || value === undefined || value === "" ) {
                    if ( comparisonoperator == 'NOT_NULL' )
                        return false;

                    if ( comparisonoperator == 'NULL' )
                        return true;
                    else {
                        switch ( comparisonoperator ) {
                            case 'EQUAL':
                                return value == filtervalue;
                            case 'NOT_EQUAL':
                                return value != filtervalue;
                        }
                        return false;
                    }
                }
                else {
                    if ( comparisonoperator == 'NULL' )
                        return false;

                    if ( comparisonoperator == 'NOT_NULL' )
                        return true;
                }

                var val = value;

                try {
                    val = parseFloat( val );
                }
                catch ( error ) {
                    if ( value.toString() != "" )
                        return false;
                }

                var compare = function ( val, filtervalue ) {
                    switch ( comparisonoperator ) {
                        case 'EQUAL':
                            return val == filtervalue;
                        case 'NOT_EQUAL':
                            return val != filtervalue;
                        case 'GREATER_THAN':
                            return val > filtervalue;
                        case 'GREATER_THAN_OR_EQUAL':
                            return val >= filtervalue;
                        case 'LESS_THAN':
                            return val < filtervalue;
                        case 'LESS_THAN_OR_EQUAL':
                            return val <= filtervalue;
                        case 'STARTS_WITH':
                            return $.jqx.string.startsWithIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'ENDS_WITH':
                            return $.jqx.string.endsWithIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'ENDS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.endsWith( val.toString(), filtervalue.toString() );
                        case 'STARTS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.startsWith( val.toString(), filtervalue.toString() );
                        case 'CONTAINS':
                            return $.jqx.string.containsIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'CONTAINS_CASE_SENSITIVE':
                            return $.jqx.string.contains( val.toString(), filtervalue.toString() );
                        case 'DOES_NOT_CONTAIN':
                            return !$.jqx.string.containsIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                            return !$.jqx.string.contains( val.toString(), filtervalue.toString() );
                        default:
                            return true;
                    }
                }

                var filterValues = new Array();

                if ( filtervalue && filtervalue.indexOf )
                    filtervalue = filtervalue.replace( '$', '' );

                if ( filtervalue && filtervalue.indexOf && ( filtervalue.indexOf( "|" ) >= 0 || filtervalue.indexOf( " AND " ) >= 0 || filtervalue.indexOf( " OR " ) >= 0 || filtervalue.indexOf( " and " ) >= 0 || filtervalue.indexOf( " or " ) >= 0 ) ) {
                    var result = compare( val, filtervalue );
                    if ( result ) {
                        return result;
                    }
                    filtervalue = filtervalue.toString();
                    var andFilters = filtervalue.indexOf( " AND " ) >= 0 ? filtervalue.split( " AND " ) : new Array();
                    var orFilters = filtervalue.indexOf( " OR " ) >= 0 ? filtervalue.split( " OR " ) : new Array();
                    var andLowerCaseFilters = filtervalue.indexOf( " and " ) >= 0 ? filtervalue.split( " and " ) : new Array();
                    var orLowerCaseFilters = filtervalue.indexOf( " or " ) >= 0 ? filtervalue.split( " or " ) : new Array();
                    andFilters = andFilters.concat( andLowerCaseFilters );
                    orFilters = orFilters.concat( orLowerCaseFilters );
                    var delimiterFilters = filtervalue.indexOf( "|" ) >= 0 ? filtervalue.split( "|" ) : new Array();
                    if ( delimiterFilters.length > 0 ) {
                        for ( var i = 0; i < delimiterFilters.length; i++ ) {
                            delimiterFilters[ i ] = $.trim( delimiterFilters[ i ] );
                        }
                    }
                    orFilters = orFilters.concat( delimiterFilters );

                    if ( andFilters.length > 0 ) {
                        for ( var i = 0; i < andFilters.length; i++ ) {
                            if ( !andFilters[ i ].indexOf( " OR " ) >= 0 ) {
                                filterValues.push( andFilters[ i ] );
                            }
                        }
                    }
                    if ( orFilters.length > 0 ) {
                        for ( var i = 0; i < orFilters.length; i++ ) {
                            if ( !orFilters[ i ].indexOf( " AND " ) >= 0 ) {
                                filterValues.push( orFilters[ i ] );
                            }
                        }
                    }

                    var filterresult = undefined;
                    for ( var j = 0; j < filterValues.length; j++ ) {
                        var value = filterValues[ j ];

                        if ( value && value.indexOf && value.indexOf( ".." ) >= 0 ) {
                            var values = value.toString().split( ".." );
                            if ( values.length == 2 ) {
                                result = val >= values[ 0 ] && val <= values[ 1 ];
                            }
                        }
                        else {
                            var result = compare( val, value );
                        }
                        var filteroperator = j < andFilters.length ? "and" : "or";
                        if ( filterresult == undefined ) {
                            filterresult = result;
                        }
                        else {
                            if ( filteroperator == 'or' ) {
                                filterresult = filterresult || result;
                            }
                            else {
                                filterresult = filterresult && result;
                            }
                        }
                    }
                    return filterresult;
                }
                if ( filtervalue && filtervalue.indexOf && filtervalue.indexOf( ".." ) >= 0 ) {
                    filterValues = filtervalue.toString().split( ".." );
                    if ( filterValues.length == 2 ) {
                        return val >= filterValues[ 0 ] && val <= filterValues[ 1 ];
                    }
                }
                return compare( val, filtervalue );
            }
        }

        var datefilter = function ( filtervalue, comparisonoperator, formatstring, localization ) {
            this.filtervalue = filtervalue;
            this.type = 'datefilter';
            var that = this;
            if ( formatstring != undefined && localization != undefined ) {
                var parsedDate = $.jqx.dataFormat.parsedate( filtervalue, formatstring, localization );
                if ( parsedDate != null ) {
                    this.filterdate = parsedDate;
                }
                else {
                    var result = $.jqx.dataFormat.tryparsedate( filtervalue, localization );
                    if ( result != null ) this.filterdate = result;
                }

            }
            else {
                var tmpvalue = new Date( filtervalue );
                if ( tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date" ) {
                    this.filterdate = $.jqx.dataFormat.tryparsedate( filtervalue );
                }
                else {
                    this.filterdate = tmpvalue;
                }
            }
            if ( !this.filterdate ) {
                var tmpvalue = new Date( filtervalue );
                if ( tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date" ) {
                    this.filterdate = $.jqx.dataFormat.tryparsedate( filtervalue );
                }
                else {
                    this.filterdate = tmpvalue;
                }
            }

            this.comparisonoperator = comparisonoperator;
            this.evaluate = function ( value ) {
                var filtervalue = this.filtervalue;
                var comparisonoperator = this.comparisonoperator;
                if ( value == null || value == undefined || value == "" ) {
                    if ( comparisonoperator == 'NOT_NULL' )
                        return false;

                    if ( comparisonoperator == 'NULL' )
                        return true;
                    else {
                        switch ( comparisonoperator ) {
                            case 'EQUAL':
                                return value == filtervalue;
                            case 'NOT_EQUAL':
                                return value != filtervalue;
                        }
                        return false;
                    }
                }
                else {
                    if ( comparisonoperator == 'NULL' )
                        return false;

                    if ( comparisonoperator == 'NOT_NULL' )
                        return true;
                }

                var val = new Date();
                val.setFullYear( 1900, 0, 1 );
                val.setHours( 12, 0, 0, 0 );
                try {
                    var tmpvalue = new Date( value );

                    if ( tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date" ) {
                        value = $.jqx.dataFormat.tryparsedate( value );
                    }
                    else {
                        value = tmpvalue;
                    }

                    val = value;

                    var compareTimePart = false;
                    if ( formatstring != undefined && localization != undefined ) {
                        if ( formatstring.indexOf( 't' ) >= 0 || formatstring.indexOf( 'T' ) >= 0 || formatstring.indexOf( ':' ) >= 0 || formatstring.indexOf( 'f' ) >= 0 ) {
                            compareTimePart = true;
                            if ( filtervalue && filtervalue.toString().indexOf( ':' ) == -1 ) {
                                var result = $.jqx.dataFormat.tryparsedate( filtervalue.toString() + ":00", localization );
                                if ( result != null ) that.filterdate = result;
                            }
                        }
                    }
                    if ( formatstring != undefined ) {
                        if ( formatstring.indexOf( 'hh' ) >= 0 || formatstring.indexOf( 't' ) >= 0 ) {
                            compareTimePart = true;
                        }
                    }

                    if ( !compareTimePart ) {
                        val.setHours( 0 );
                        val.setMinutes( 0 );
                        val.setSeconds( 0 );
                    }
                }
                catch ( error ) {
                    if ( value && value.toString() != "" )
                        return false;
					
					return false;
                }

                if ( that.filterdate != null ) {
                    filtervalue = that.filterdate;
                }
                else {
                    if ( filtervalue && filtervalue.indexOf ) {
                        if ( filtervalue.indexOf( ':' ) != -1 || !isNaN( parseInt( filtervalue ) ) ) {
                            var tmpFilter = new Date( val );
                            tmpFilter.setHours( 12, 0, 0, 0 );
                            var timeStrings = filtervalue.split( ':' );
                            for ( var i = 0; i < timeStrings.length; i++ ) {
                                if ( i == 0 ) {
                                    tmpFilter.setHours( timeStrings[ i ] );
                                }
                                if ( i == 1 ) {
                                    tmpFilter.setMinutes( timeStrings[ i ] );
                                }
                                if ( i == 2 ) {
                                    tmpFilter.setSeconds( timeStrings[ i ] );
                                }
                            }
                            filtervalue = tmpFilter;
                        }
                    }
                }
                if ( compareTimePart ) {
                    if ( filtervalue && filtervalue.setFullYear ) {
                        if ( val && val.getFullYear ) {
                            if ( formatstring.indexOf( 'd' ) == -1 && formatstring.indexOf( 'M' ) == -1 && formatstring.indexOf( 'y' ) == -1 ) {
                                filtervalue.setFullYear( val.getFullYear(), val.getMonth(), val.getDate() );
                            }
                        }
                    }
                }


                var compare = function ( val, filtervalue ) {
                    if ( val == null ) val = "";
                    switch ( comparisonoperator ) {
                        case 'EQUAL':
                            return val.toString() == filtervalue.toString();
                        case 'NOT_EQUAL':
                            return val.toString() != filtervalue.toString();
                        case 'GREATER_THAN':
                            return val > filtervalue;
                        case 'GREATER_THAN_OR_EQUAL':
                            return val >= filtervalue;
                        case 'LESS_THAN':
                            return val < filtervalue;
                        case 'LESS_THAN_OR_EQUAL':
                            return val <= filtervalue;
                        case 'STARTS_WITH':
                            return $.jqx.string.startsWithIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'ENDS_WITH':
                            return $.jqx.string.endsWithIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'ENDS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.endsWith( val.toString(), filtervalue.toString() );
                        case 'STARTS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.startsWith( val.toString(), filtervalue.toString() );
                        case 'CONTAINS':
                            return $.jqx.string.containsIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'CONTAINS_CASE_SENSITIVE':
                            return $.jqx.string.contains( val.toString(), filtervalue.toString() );
                        case 'DOES_NOT_CONTAIN':
                            return !$.jqx.string.containsIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                            return !$.jqx.string.contains( val.toString(), filtervalue.toString() );
                        default:
                            return true;
                    }
                }
                var filterValues = new Array();
                if ( filtervalue && filtervalue.indexOf )
                    if ( filtervalue.indexOf( "|" ) >= 0 || filtervalue.indexOf( " AND " ) >= 0 || filtervalue.indexOf( " OR " ) >= 0 || filtervalue.indexOf( " and " ) >= 0 || filtervalue.indexOf( " or " ) >= 0 ) {
                        var result = compare( val, filtervalue );
                        if ( result ) {
                            return result;
                        }
                        var andFilters = filtervalue.indexOf( " AND " ) >= 0 ? filtervalue.split( " AND " ) : new Array();
                        var orFilters = filtervalue.indexOf( " OR " ) >= 0 ? filtervalue.split( " OR " ) : new Array();
                        var andLowerCaseFilters = filtervalue.indexOf( " and " ) >= 0 ? filtervalue.split( " and " ) : new Array();
                        var orLowerCaseFilters = filtervalue.indexOf( " or " ) >= 0 ? filtervalue.split( " or " ) : new Array();
                        andFilters = andFilters.concat( andLowerCaseFilters );
                        orFilters = orFilters.concat( orLowerCaseFilters );
                        var delimiterFilters = filtervalue.indexOf( "|" ) >= 0 ? filtervalue.split( "|" ) : new Array();
                        if ( delimiterFilters.length > 0 ) {
                            for ( var i = 0; i < delimiterFilters.length; i++ ) {
                                delimiterFilters[ i ] = $.trim( delimiterFilters[ i ] );
                            }
                        }
                        orFilters = orFilters.concat( delimiterFilters );

                        if ( andFilters.length > 0 ) {
                            for ( var i = 0; i < andFilters.length; i++ ) {
                                if ( !andFilters[ i ].indexOf( " OR " ) >= 0 ) {
                                    filterValues.push( andFilters[ i ] );
                                }
                            }
                        }
                        if ( orFilters.length > 0 ) {
                            for ( var i = 0; i < orFilters.length; i++ ) {
                                if ( !orFilters[ i ].indexOf( " AND " ) >= 0 ) {
                                    filterValues.push( orFilters[ i ] );
                                }
                            }
                        }

                        var filterresult = undefined;
                        for ( var j = 0; j < filterValues.length; j++ ) {
                            var value = filterValues[ j ];
                            if ( value && value.indexOf && value.indexOf( ".." ) >= 0 ) {
                                var values = value.toString().split( ".." );
                                if ( values.length == 2 ) {
                                    result = val >= values[ 0 ] && val <= values[ 1 ];
                                }
                            }
                            else {
                                var result = compare( val, value );
                            }
                            var filteroperator = j < andFilters.length ? "and" : "or";
                            if ( filterresult == undefined ) {
                                filterresult = result;
                            }
                            else {
                                if ( filteroperator == 'or' ) {
                                    filterresult = filterresult || result;
                                }
                                else {
                                    filterresult = filterresult && result;
                                }
                            }
                        }
                        return filterresult;
                    }
                if ( filtervalue && filtervalue.indexOf && filtervalue.indexOf( ".." ) >= 0 ) {
                    filterValues = filtervalue.toString().split( ".." );
                    if ( filterValues.length == 2 ) {
                        return val >= filterValues[ 0 ] && val <= filterValues[ 1 ];
                    }
                }
                return compare( val, filtervalue );
            }
        }

        var filter = function ( filtervalue, comparisonoperator, customfilter ) {
            this.filtervalue = filtervalue;
            this.comparisonoperator = comparisonoperator;
            this.evaluate = function ( value, comparisonoperator ) {
                return customfilter( this.filtervalue, value, this.comparisonoperator );
            }
        }
    }
} )( jqxBaseFramework );
})();



/***/ }),

/***/ 5868:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {

        $.jqx.jqxWidget("jqxDropDownList", "", {});

        $.extend($.jqx._jqxDropDownList.prototype, {
            defineInstance: function () {
                var settings = {
                    // enables/disables the dropdownlist.
                    disabled: false,
                    // gets or sets the listbox width.
                    width: null,
                    // gets or sets the listbox height.
                    height: null,
                    // Represents the collection of list items.
                    items: new Array(),
                    // Gets or sets the selected index.
                    selectedIndex: -1,
                    // data source.
                    source: null,
                    // gets or sets the scrollbars size.
                    scrollBarSize: 15,
                    // gets or sets the scrollbars size.
                    arrowSize: 17,
                    // enables/disables the hover state.
                    enableHover: true,
                    // enables/disables the selection.
                    enableSelection: true,
                    autoItemsHeight: false,
                    // gets the visible items. // this property is internal for the dropdownlist.
                    visualItems: new Array(),
                    // gets the groups. // this property is internal for the dropdownlist.
                    groups: new Array(),
                    // gets or sets whether the items width should be equal to the dropdownlist's width.
                    equalItemsWidth: true,
                    // gets or sets the height of the ListBox Items. When the itemHeight == - 1, each item's height is equal to its desired height.
                    itemHeight: -1,
                    // represents the dropdownlist's events.
                    visibleItems: new Array(),
                    // emptry group's text.
                    emptyGroupText: 'Group',
                    checkboxes: false,
                    // Type: Number
                    // Default: 100
                    // Showing Popup Animation's delay.
                    openDelay: 250,
                    // Type: Number
                    // Default: 200
                    // Hiding Popup Animation's delay.
                    closeDelay: 300,
                    dropDownContainer: "default",
                    // default, none
                    // Type: String.
                    // enables or disables the animation.
                    animationType: 'default',
                    autoOpen: false,
                    // Type: String
                    // Default: auto ( the drop down takes the dropdownlist's width.)
                    // Sets the popup's width.
                    dropDownWidth: 'auto',
                    // Type: String
                    // Default: 200px ( the height is 200px )
                    // Sets the popup's height.
                    dropDownHeight: '200px',
                    // Type: Boolean
                    // Default: false
                    // Sets the popup's height to be equal to the items summary height,
                    autoDropDownHeight: false,
                    keyboardSelection: true,
                    // Type: Boolean
                    // Default: false
                    // Enables or disables the browser detection.
                    enableBrowserBoundsDetection: false,
                    dropDownHorizontalAlignment: 'left',
                    dropDownVerticalAlignment: 'bottom',
                    displayMember: "",
                    valueMember: "",
                    groupMember: "",
                    searchMember: "",
                    searchMode: 'startswithignorecase',
                    incrementalSearch: true,
                    incrementalSearchDelay: 700,
                    renderer: null,
                    placeHolder: "",
                    promptText: "Please Choose:",
                    emptyString: "",
                    rtl: false,
                    selectionRenderer: null,
                    listBox: null,
                    popupZIndex: 3001,
                    renderMode: "default",
                    touchMode: "auto",
                    _checkForHiddenParent: true,
                    autoBind: true,
                    ready: null,
                    focusable: true,
                    filterable: false,
                    filterHeight: 27,
                    filterPlaceHolder: "Looking for",
                    filterDelay: 100,
                    hint: true,
                    // "primary", "inverse", "danger", "info", "success", "warning", "link"
                    template: "default",
                    aria:
                    {
                        "aria-disabled": { name: "disabled", type: "boolean" }
                    },
                    events:
                        [
                            // occurs when the dropdownlist is opened.
                            'open',
                            // occurs when the dropdownlist is closed.
                            'close',
                            // occurs when an item is selected.
                            'select',
                            // occurs when an item is unselected.
                            'unselect',
                            // occurs when the selection is changed.
                            'change',
                            // triggered when the user checks or unchecks an item.
                            'checkChange',
                            // triggered when the binding operation is completed.
                            'bindingComplete',
                            // triggered when a new item is added.
                            'itemAdd',
                            // triggered when a new item is removed.
                            'itemRemove',
                            // triggered when a new item is updated.
                            'itemUpdate'
                        ]
                }
                if (this === $.jqx._jqxDropDownList.prototype) {
                    return settings;
                }
                $.extend(true, this, settings);
                return settings;
            },

            createInstance: function (args) {
                var that = this;

                if (that.isMaterialized()) {
                    var elementStyle = window.getComputedStyle(this.element);
                    var animation = elementStyle.getPropertyValue('--jqx-dropdown-animation');
                    var rowHeight = elementStyle.getPropertyValue('--jqx-list-item-height');
                    var arrowSize = elementStyle.getPropertyValue('--jqx-action-button-size');

                    if (arrowSize) {
                        this.arrowSize = parseInt(arrowSize);
                    }
                    else {
                        this.arrowSize = 25;
                    }

                    if (animation && this.animationType == "default") {
                        this.animationType = animation.trim();
                    }

                    if (rowHeight && this.itemHeight === -1) {
                        this.itemHeight = parseInt(rowHeight);
                    }
                }

                this.render();
            },

            render: function () {
                var self = this;
                if (!self.width) self.width = 200;
                if (!self.height) self.height = 25;

                self.host.addClass(self.toThemeProperty('jqx-dropdownlist'));

                var nodeName = self.element.nodeName.toLowerCase();
                if (nodeName == "select" || nodeName == "ul" || nodeName == "ol") {
                    self.field = self.element;
                    if (self.field.className) {
                        self._className = self.field.className;
                    }

                    var properties = {
                        'title': self.field.title
                    };

                    if (self.field.id.length) {
                        properties.id = self.field.id.replace(/[^\w]/g, '_') + "_jqxDropDownList";
                    }
                    else {
                        properties.id = $.jqx.utilities.createId() + "_jqxDropDownList";
                    }

                    var wrapper = $("<div></div>", properties);
                    if (!self.width) {
                        self.width = $(self.field).width();
                    }
                    if (!self.height) {
                        self.height = $(self.field).outerHeight();
                    }
                    wrapper[0].style.cssText = self.field.style.cssText;
                    $(self.field).hide().after(wrapper);
                    var data = self.host.data();
                    self.host = wrapper;
                    self.host.data(data);
                    self.element = wrapper[0];
                    self.element.id = self.field.id;
                    self.field.id = properties.id;
                    if (self._className) {
                        self.host.addClass(self._className);
                        $(self.field).removeClass(self._className);
                    }

                    if (self.field.tabIndex) {
                        var tabIndex = self.field.tabIndex;
                        self.field.tabIndex = -1;
                        self.element.tabIndex = tabIndex;
                    }
                    var result = $.jqx.parseSourceTag(self.field);
                    self.source = result.items;
                    if (self.selectedIndex == -1)
                        self.selectedIndex = result.index;
                }
                else {
                    if (self.host.find('li').length > 0 || self.host.find('option').length > 0) {
                        var result = $.jqx.parseSourceTag(self.element);
                        self.source = result.items;
                    }
                }
                self.element.innerHTML = "";
                self.isanimating = false;
                self.id = self.element.id || $.jqx.utilities.createId();
                self.host.attr('role', 'combobox');
                self.host.attr('aria-label', 'DropDownList');
                self.host.attr('aria-expanded', 'false');

                $.jqx.aria(self, "aria-autocomplete", "both");
                $.jqx.aria(self, "aria-readonly", false);

                var comboStructure = "<div style='background-color: transparent; -webkit-appearance: none; outline: none; width:100%; height: 100%; padding: 0px; margin: 0px; border: 0px; position: relative;'>" +
                    "<div id='dropdownlistWrapper' style='overflow: hidden; outline: none; background-color: transparent; border: none; float: left; width:100%; height: 100%; position: relative;'>" +
                    "<div id='dropdownlistContent' unselectable='on' style='outline: none; background-color: transparent; border: none; float: left; position: relative;'></div>" +
                    "<div id='dropdownlistArrow' unselectable='on' style='background-color: transparent; border: none; float: right; position: relative;'><div unselectable='on'></div></div>" +
                    "</div>" +
                    "</div>";

                if ($.jqx._jqxListBox == null || $.jqx._jqxListBox == undefined) {
                    throw new Error("jqxDropDownList: Missing reference to jqxlistbox.js.");
                }

                if (self.host.attr('tabindex')) {
                }
                else {
                    self.host.attr('tabindex', 0);
                }

                var me = self;

                self.touch = $.jqx.mobile.isTouchDevice();
                self.comboStructure = comboStructure;
                self.element.innerHTML = comboStructure;

                self.dropdownlistWrapper = $(self.element.firstChild.firstChild);
                self.dropdownlistArrow = $(self.dropdownlistWrapper[0].firstChild.nextSibling);
                self.arrow = $(self.dropdownlistArrow[0].firstChild);
                self.dropdownlistContent = $(self.dropdownlistWrapper[0].firstChild);
                self.dropdownlistContent.addClass(self.toThemeProperty('jqx-dropdownlist-content jqx-disableselect'));
                if (self.rtl) {
                    self.dropdownlistContent.addClass(self.toThemeProperty('jqx-rtl jqx-dropdownlist-content-rtl'));
                }
                self.addHandler(self.dropdownlistWrapper, 'selectstart', function () { return false; });
                self.dropdownlistWrapper[0].id = "dropdownlistWrapper" + self.element.id;
                self.dropdownlistArrow[0].id = "dropdownlistArrow" + self.element.id;
                self.dropdownlistContent[0].id = "dropdownlistContent" + self.element.id;
                self._addInput();

                var label = $("<label></label");
                if (this.hint) {
                    label[0].innerHTML = this.placeHolder;
                }
                label.addClass(self.toThemeProperty('jqx-input-label'));
                self.dropdownlistWrapper.append(label);
                self.label = label;

                var bar = $("<span></span>");
                self.dropdownlistWrapper.append(bar);
                bar.addClass(self.toThemeProperty('jqx-input-bar'));
                self.bar = bar;
                self.bar.css('top', this.host.height());

                var that = this;

                if (that.template) {
                    that.bar.addClass(that.toThemeProperty("jqx-" + that.template));
                    that.label.addClass(that.toThemeProperty("jqx-" + that.template));
                }

                if (self.promptText != "Please Choose:") self.placeHolder = self.promptText;
                var hostClassName = self.toThemeProperty('jqx-widget') + " " + self.toThemeProperty('jqx-dropdownlist-state-normal') + " " + self.toThemeProperty('jqx-rc-all') + " " + self.toThemeProperty('jqx-fill-state-normal');
                self.element.className += " " + hostClassName;
                self._firstDiv = $(self.element.firstChild);

                try {
                    var listBoxID = 'listBox' + self.id;
                    var oldContainer = $($.find('#' + listBoxID));
                    if (oldContainer.length > 0) {
                        oldContainer.remove();
                    }
                    $.jqx.aria(self, "aria-owns", listBoxID);
                    $.jqx.aria(self, "aria-haspopup", true);

                    var container = $("<div style='overflow: hidden; background-color: transparent; border: none; position: absolute;' id='listBox" + self.id + "'><div id='innerListBox" + self.id + "'></div></div>");
                    container.hide();
                    container.addClass(self.toThemeProperty('jqx-listbox-container'));
                    if (self.dropDownContainer == "element") {
                        container.appendTo(self.host);
                    }
                    else {
                        container.appendTo(document.body);
                    }
                    self.container = container;
                    self.listBoxContainer = $($.find('#innerListBox' + self.id));

                    var width = self.width;
                    if (self.dropDownWidth != 'auto') {
                        width = self.dropDownWidth;
                    }
                    if (width == null) {
                        width = self.host.width();
                        if (width == 0) width = self.dropDownWidth;
                    }

                    if (self.dropDownHeight == null) {
                        self.dropDownHeight = 200;
                    }
                    var me = self;
                    self.container.width(parseInt(width) + 25);
                    self.container.height(parseInt(self.dropDownHeight) + 25);
                    self._ready = false;
                    self.addHandler(self.listBoxContainer, 'bindingComplete', function (event) {
                        if (!self.listBox) {
                            self.listBox = $.data(self.listBoxContainer[0], "jqxListBox").instance;
                        }
                        if (self.selectedIndex != self.listBoxContainer.jqxListBox('selectedIndex')) {
                            self.listBox = $.data(self.listBoxContainer[0], "jqxListBox").instance;
                            self.listBoxContainer.jqxListBox({ selectedIndex: self.selectedIndex });
                            self.renderSelection('mouse');
                        } else {
                            self.renderSelection('mouse');
                        }
                        if (!self._ready) {
                            if (self.ready) {
                                self.ready();
                            }
                            self._ready = true;
                        }
                        self._raiseEvent('6');
                    });
                    self.addHandler(self.listBoxContainer, 'itemAdd', function (event) {
                        self._raiseEvent('7', event.args);
                    });
                    self.addHandler(self.listBoxContainer, 'itemRemove', function (event) {
                        self._raiseEvent('8', event.args);
                    });
                    self.addHandler(self.listBoxContainer, 'itemUpdate', function (event) {
                        self._raiseEvent('9', event.args);
                    });

                    self.listBoxContainer.jqxListBox({
                        filterHeight: self.filterHeight,
                        filterPlaceHolder: self.filterPlaceHolder,
                        filterDelay: self.filterDelay,
                        autoItemsHeight: self.autoItemsHeight,
                        filterable: self.filterable, allowDrop: false, allowDrag: false,
                        autoBind: self.autoBind, _checkForHiddenParent: false, focusable: self.focusable,
                        touchMode: self.touchMode, checkboxes: self.checkboxes, rtl: self.rtl, _renderOnDemand: true, emptyString: self.emptyString, itemHeight: self.itemHeight, width: width, searchMode: self.searchMode, incrementalSearch: self.incrementalSearch, incrementalSearchDelay: self.incrementalSearchDelay, groupMember: self.groupMember, searchMember: self.searchMember, displayMember: self.displayMember, valueMember: self.valueMember, height: self.dropDownHeight, autoHeight: self.autoDropDownHeight, scrollBarSize: self.scrollBarSize, selectedIndex: self.selectedIndex, source: self.source, theme: self.theme,
                        rendered: function () {
                            if (self.selectedIndex != self.listBoxContainer.jqxListBox('selectedIndex')) {
                                self.listBox = $.data(self.listBoxContainer[0], "jqxListBox").instance;
                                self.listBoxContainer.jqxListBox({ selectedIndex: self.selectedIndex });
                                self.renderSelection('mouse');
                            } else {
                                self.renderSelection('mouse');
                            }
                        }, renderer: self.renderer,
                        filterChange: function (value) {
                            if (self.autoDropDownHeight) {
                                self.container.height(self.listBoxContainer.height() + 25);
                            }
                        }
                    });
                    if (self.dropDownContainer === "element") {
                        self.listBoxContainer.css({ position: 'absolute', top: 0, left: 0 });
                    }
                    else {
                        self.listBoxContainer.css({ position: 'absolute', zIndex: self.popupZIndex, top: 0, left: 0 });
                    }
                    if (self.template) {
                        self.listBoxContainer.addClass(self.toThemeProperty("jqx-" + self.template + "-item"));
                    }

                    self.listBox = $.data(self.listBoxContainer[0], "jqxListBox").instance;
                    self.listBox.enableSelection = self.enableSelection;
                    self.listBox.enableHover = self.enableHover;
                    self.listBox.equalItemsWidth = self.equalItemsWidth;
                    self.listBox.selectIndex(self.selectedIndex);
                    self.listBox._arrange();
                    self.listBoxContainer.addClass(self.toThemeProperty('jqx-popup'));
                    if ($.jqx.browser.msie) {
                        self.listBoxContainer.addClass(self.toThemeProperty('jqx-noshadow'));
                    }

                    self.addHandler(self.listBoxContainer, 'unselect', function (event) {
                        self._raiseEvent('3', { index: event.args.index, type: event.args.type, item: event.args.item });
                    });

                    self.addHandler(self.listBoxContainer, 'change', function (event) {
                        if (event.args) {
                            if (event.args.type != "keyboard") {
                                self._raiseEvent('4', { index: event.args.index, type: event.args.type, item: event.args.item });
                            }
                            else if (event.args.type == "keyboard") {
                                if (!self.isOpened()) {
                                    self._raiseEvent('4', { index: self.selectedIndex, type: 'keyboard', item: self.getItem(self.selectedIndex) });
                                }
                                else {
                                    if (event.args.item && event.args.oldItem && event.args.item.label !== event.args.oldItem.label) {
                                        self._raiseEvent('4', { index: self.selectedIndex, type: 'keyboard', item: self.getItem(self.selectedIndex) });
                                    }
                                }
                            }
                        }
                    });

                    if (self.animationType == 'none') {
                        self.container.css('display', 'none');
                    }
                    else {
                        self.container.hide();
                    }
                }
                catch (e) {
                    if (console)
                        console.log(e);
                }

                var self = self;
                self.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    if (value) {
                        instance.host.addClass(self.toThemeProperty('jqx-dropdownlist-state-disabled'));
                        instance.host.addClass(self.toThemeProperty('jqx-fill-state-disabled'));
                        instance.dropdownlistContent.addClass(self.toThemeProperty('jqx-dropdownlist-content-disabled'));
                    }
                    else {
                        instance.host.removeClass(self.toThemeProperty('jqx-dropdownlist-state-disabled'));
                        instance.host.removeClass(self.toThemeProperty('jqx-fill-state-disabled'));
                        instance.dropdownlistContent.removeClass(self.toThemeProperty('jqx-dropdownlist-content-disabled'));
                    }
                    $.jqx.aria(instance, "aria-disabled", instance.disabled);
                }

                if (self.disabled) {
                    self.host.addClass(self.toThemeProperty('jqx-dropdownlist-state-disabled'));
                    self.host.addClass(self.toThemeProperty('jqx-fill-state-disabled'));
                    self.dropdownlistContent.addClass(self.toThemeProperty('jqx-dropdownlist-content-disabled'));
                }

                if (self.dropDownVerticalAlignment == "top") {
                    self.arrow.addClass(self.toThemeProperty('jqx-icon-arrow-up'));
                }
                else {
                    self.arrow.addClass(self.toThemeProperty('jqx-icon-arrow-down'));
                }
                self.arrow.addClass(self.toThemeProperty('jqx-icon'));

                if (self.renderMode === "simple") {
                    self.arrow.remove();
                    self.host.removeClass(self.toThemeProperty('jqx-fill-state-normal'));
                    self.host.removeClass(self.toThemeProperty('jqx-rc-all'));
                }
                if (self.template) {
                    self.host.addClass(self.toThemeProperty("jqx-" + self.template))
                }

                self._updateHandlers();
                self._setSize();
                self._arrange();
                if (self.listBox) {
                    self.renderSelection();
                }

                // fix for IE7
                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                    if (self.host.parents('.jqx-window').length > 0) {
                        var zIndex = self.host.parents('.jqx-window').css('z-index');
                        container.css('z-index', zIndex + 10);
                        self.listBoxContainer.css('z-index', zIndex + 10);
                    }
                }
            },

            resize: function (width, height) {
                this.width = width;
                this.height = height;
                this._setSize();
                this._arrange();
            },

            val: function (value) {
                if (!this.dropdownlistContent) return "";

                var isEmpty = function (obj) {
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key))
                            return false;
                    }

                    if (typeof value == "number")
                        return false;
                    if (typeof value == "date")
                        return false;
                    if (typeof value == "boolean")
                        return false;
                    if (typeof value == "string")
                        return false;

                    return true;
                }

                if (this.input && (isEmpty(value) || arguments.length == 0)) {
                    return this.input.val();
                }

                var item = this.getItemByValue(value);
                if (item != null) {
                    this.selectItem(item);
                }

                if (this.input) {
                    return this.input.val();
                }
            },

            focus: function () {
                try {
                    var me = this;
                    var doFocus = function () {
                        if (me.host) {
                            me.host.focus();
                            if (me._firstDiv) {
                                me._firstDiv.focus();
                            }
                        }
                    }
                    doFocus();
                    setTimeout(function () {
                        doFocus();
                    }, 10);
                }
                catch (error) {
                }
            },

            _addInput: function () {
                var name = this.host.attr('name');
                this.input = $("<input type='hidden'/>");
                this.host.append(this.input);
                if (name) {
                    this.input.attr('name', name);
                }
            },

            getItems: function () {
                if (!this.listBox) {
                    return new Array();
                }

                return this.listBox.items;
            },

            getVisibleItems: function () {
                return this.listBox.getVisibleItems();
            },


            _setSize: function () {
                var computedStyle = window.getComputedStyle(this.element);
                var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
                var boxSizing = computedStyle.boxSizing;

                if (this.element.offsetWidth === 0) {
                    borderSize = 2;
                }

                if (boxSizing === 'border-box' || isNaN(borderSize)) {
                    borderSize = 0;
                }

                if (this.width != null && this.width.toString().indexOf("px") != -1) {
                    this.element.style.width = parseInt(this.width) - borderSize + 'px';
                }
                else if (this.width != undefined && !isNaN(this.width)) {
                    this.element.style.width = parseInt(this.width) - borderSize + 'px';
                }

                if (this.height != null && this.height.toString().indexOf("px") != -1) {
                    this.element.style.height = parseInt(this.height) - borderSize + 'px';
                }
                else if (this.height != undefined && !isNaN(this.height)) {
                    this.element.style.height = parseInt(this.height) - borderSize + 'px';
                };

                var isPercentage = false;
                if (this.width != null && this.width.toString().indexOf("%") != -1) {
                    isPercentage = true;
                    this.element.style.width = this.width;

                    if (borderSize > 0) {
                        this.host.css('box-sizing', 'border-box');
                        this.listBoxContainer.css('box-sizing', 'border-box');
                    }
                }

                if (this.height != null && this.height.toString().indexOf("%") != -1) {
                    isPercentage = true;
                    this.element.style.height = this.height;
                }

                var me = this;
                var resizeFunc = function () {
                    me._arrange();
                    if (me.dropDownWidth == 'auto') {
                        var width = me.host.width() + 2;
                        me.listBoxContainer.jqxListBox({ width: width });
                        me.container.width(parseInt(width) + 25);
                    }
                }

                if (isPercentage) {
                    var width = this.host.width() + 2;
                    if (this.dropDownWidth != 'auto') {
                        width = this.dropDownWidth;
                    }
                    this.listBoxContainer.jqxListBox({ width: width });
                    this.container.width(parseInt(width) + 25);
                }
                $.jqx.utilities.resize(this.host, function () {
                    resizeFunc();
                }, false, this._checkForHiddenParent);
            },

            // returns true when the listbox is opened, otherwise returns false.
            isOpened: function () {
                var me = this;
                var openedListBox = $.data(document.body, "openedJQXListBox" + this.id);
                if (openedListBox != null && openedListBox == me.listBoxContainer) {
                    return true;
                }

                return false;
            },

            _updateHandlers: function () {
                var self = this;
                var hovered = false;
                this.removeHandlers();
                if (!this.touch) {
                    this.addHandler(this.host, 'mouseenter', function () {
                        if (!self.disabled && self.enableHover && self.renderMode !== 'simple') {
                            hovered = true;
                            self.host.addClass(self.toThemeProperty('jqx-dropdownlist-state-hover'));
                            if (self.dropDownVerticalAlignment == "top") {
                                self.arrow.addClass(self.toThemeProperty('jqx-icon-arrow-up-hover'));
                            }
                            else {
                                self.arrow.addClass(self.toThemeProperty('jqx-icon-arrow-down-hover'));
                            }
                            self.host.addClass(self.toThemeProperty('jqx-fill-state-hover'));
                        }
                    });

                    this.addHandler(this.host, 'mouseleave', function () {
                        if (!self.disabled && self.enableHover && self.renderMode !== 'simple') {
                            self.host.removeClass(self.toThemeProperty('jqx-dropdownlist-state-hover'));
                            self.host.removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                            self.arrow.removeClass(self.toThemeProperty('jqx-icon-arrow-down-hover'));
                            self.arrow.removeClass(self.toThemeProperty('jqx-icon-arrow-up-hover'));
                            hovered = false;
                        }
                    });
                }

                if (this.host.parents()) {
                    this.addHandler(this.host.parents(), 'scroll.dropdownlist' + this.element.id, function (event) {
                        var opened = self.isOpened();
                        if (opened) {
                            self.close();
                        }
                    });
                }

                var eventName = 'mousedown';
                if (this.touch) eventName = $.jqx.mobile.getTouchEventName('touchstart');
                this.addHandler(this.dropdownlistWrapper, eventName,
                    function (event) {
                        if (!self.disabled) {
                            var isOpen = self.container.css('display') == 'block';
                            if (!self.isanimating) {
                                if (isOpen) {
                                    self.hideListBox();
                                    return false;
                                }
                                else {
                                    self.showListBox();
                                    if (!self.focusable) {
                                        if (event.preventDefault) {
                                            event.preventDefault();
                                        }
                                    }
                                    else self.focus();

                                    //    event.stopPropagation();
                                }
                            }
                        }
                    });

                if (self.autoOpen) {
                    this.addHandler(this.host, 'mouseenter', function () {
                        var isOpened = self.isOpened();
                        if (!isOpened && self.autoOpen) {
                            self.open();
                            self.host.focus();
                        }
                    });

                    $(document).on('mousemove.' + self.id, function (event) {
                        var isOpened = self.isOpened();
                        if (isOpened && self.autoOpen) {
                            var offset = self.host.coord();
                            var top = offset.top;
                            var left = offset.left;
                            var popupOffset = self.container.coord();
                            var popupLeft = popupOffset.left;
                            var popupTop = popupOffset.top;

                            var canClose = true;

                            if (event.pageY >= top && event.pageY <= top + self.host.height()) {
                                if (event.pageX >= left && event.pageX < left + self.host.width())
                                    canClose = false;
                            }
                            if (event.pageY >= popupTop && event.pageY <= popupTop + self.container.height()) {
                                if (event.pageX >= popupLeft && event.pageX < popupLeft + self.container.width())
                                    canClose = false;
                            }

                            if (canClose) {
                                self.close();
                            }
                        }
                    });
                }

                if (this.touch) {
                    this.addHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.' + this.id, self.closeOpenedListBox, { me: this, listbox: this.listBox, id: this.id });
                }
                else this.addHandler($(document), 'mousedown.' + this.id, self.closeOpenedListBox, { me: this, listbox: this.listBox, id: this.id });

                this.addHandler(this.host, 'keydown', function (event) {
                    var isOpen = self.container.css('display') == 'block';

                    if (self.host.css('display') == 'none') {
                        return true;
                    }

                    if (event.keyCode == '13' || event.keyCode == '9') {
                        if (!self.isanimating) {
                            if (isOpen) {
                                self.renderSelection();
                                if (event.keyCode == '13' && self.focusable) {
                                    self._firstDiv.focus();
                                }
                                self.hideListBox();
                                if (!self.keyboardSelection) {
                                    self._raiseEvent('2', { index: self.selectedIndex, type: 'keyboard', item: self.getItem(self.selectedIndex) });
                                }
                                if (event.keyCode == "13") {
                                    self._raiseEvent('4', { index: self.selectedIndex, type: 'keyboard', item: self.getItem(self.selectedIndex) });
                                }
                            }
                            if (isOpen && event.keyCode != '9') {
                                return false;
                            }
                            return true;
                        }
                    }

                    if (event.keyCode == 115) {
                        if (!self.isanimating) {
                            if (!self.isOpened()) {
                                self.showListBox();
                            }
                            else if (self.isOpened()) {
                                self.hideListBox();
                            }
                        }
                        return false;
                    }

                    if (event.altKey) {
                        if (self.host.css('display') == 'block') {
                            if (event.keyCode == 38) {
                                if (self.isOpened()) {
                                    self.hideListBox();
                                    return true;
                                }
                            }
                            else if (event.keyCode == 40) {
                                if (!self.isOpened()) {
                                    self.showListBox();
                                    return true;
                                }
                            }
                        }
                    }

                    if (event.keyCode == '27') {
                        if (!self.ishiding) {
                            if (self.isOpened()) {
                                self.hideListBox();
                                if (self.tempSelectedIndex != undefined) {
                                    self.selectIndex(self.tempSelectedIndex);
                                }
                            }

                            return true;
                        }
                    }

                    if (!self.disabled) {
                        self._kbnavigated = self.listBox._handleKeyDown(event);
                        return self._kbnavigated;
                    }
                });
                this.addHandler(this.listBoxContainer, 'checkChange', function (event) {
                    self.renderSelection();
                    self._updateInputSelection();
                    self._raiseEvent(5, { label: event.args.label, value: event.args.value, checked: event.args.checked, item: event.args.item });
                });

                this.addHandler(this.listBoxContainer, 'select', function (event) {
                    if (!self.disabled) {
                        if (!event.args)
                            return;

                        if (event.args.type == 'keyboard' && !self.isOpened()) {
                            self.renderSelection();
                        }

                        if (event.args.type != 'keyboard' || self.keyboardSelection) {
                            self.renderSelection();
                            self._raiseEvent('2', { index: event.args.index, type: event.args.type, item: event.args.item, originalEvent: event.args.originalEvent });
                            if (event.args.type == 'mouse') {
                                if (!self.checkboxes) {
                                    self.hideListBox();
                                    if (self._firstDiv && self.focusable) {
                                        self._firstDiv.focus();
                                    }
                                }
                            }
                        }
                    }
                });
                if (this.listBox) {
                    if (this.listBox.content) {
                        this.addHandler(this.listBox.content, 'click', function (event) {
                            if (!self.disabled) {
                                if (self.listBox.itemswrapper && event.target === self.listBox.itemswrapper[0])
                                    return true;

                                self.renderSelection('mouse');
                                if (!self.touch) {
                                    if (!self.ishiding) {
                                        if (!self.checkboxes) {
                                            self.hideListBox();
                                            if (self._firstDiv && self.focusable) {
                                                self._firstDiv.focus();
                                            }
                                        }
                                    }
                                }

                                if (!self.keyboardSelection) {
                                    if (self._kbnavigated === false) {
                                        if (self.tempSelectedIndex != self.selectedIndex) {
                                            self._raiseEvent('4', { index: self.selectedIndex, type: "mouse", item: self.getItem(self.selectedIndex) });
                                        }
                                        self._kbnavigated = true;
                                    }

                                    if (self._oldSelectedInd == undefined) self._oldSelectedIndx = self.selectedIndex;

                                    if (self.selectedIndex != self._oldSelectedIndx) {
                                        self._raiseEvent('2', { index: self.selectedIndex, type: 'keyboard', item: self.getItem(self.selectedIndex) });
                                        self._oldSelectedIndx = self.selectedIndex;
                                    }
                                }
                            }
                        });
                    }
                }

                this.addHandler(this.host, 'focus', function (event) {
                    if (self.renderMode !== 'simple') {
                        self.host.addClass(self.toThemeProperty('jqx-dropdownlist-state-focus'));
                        self.host.addClass(self.toThemeProperty('jqx-fill-state-focus'));
                    }
                    self.bar.addClass('focused');
                    self.label.addClass('focused');
                });
                this.addHandler(this.host, 'blur', function () {
                    if (self.renderMode !== 'simple') {
                        self.host.removeClass(self.toThemeProperty('jqx-dropdownlist-state-focus'));
                        self.host.removeClass(self.toThemeProperty('jqx-fill-state-focus'));
                    }
                    self.bar.removeClass('focused');
                    self.label.removeClass('focused');
                });
                this.addHandler(this._firstDiv, 'focus', function (event) {
                    if (self.renderMode !== 'simple') {
                        self.host.addClass(self.toThemeProperty('jqx-dropdownlist-state-focus'));
                        self.host.addClass(self.toThemeProperty('jqx-fill-state-focus'));
                    }
                    self.bar.addClass('focused');
                    self.label.addClass('focused');
                });
                this.addHandler(this._firstDiv, 'blur', function () {
                    if (self.renderMode !== 'simple') {
                        self.host.removeClass(self.toThemeProperty('jqx-dropdownlist-state-focus'));
                        self.host.removeClass(self.toThemeProperty('jqx-fill-state-focus'));
                    }
                    self.bar.removeClass('focused');
                    self.label.removeClass('focused');
                });
            },

            removeHandlers: function () {
                var self = this;
                var eventName = 'mousedown';
                if (this.touch) eventName = $.jqx.mobile.getTouchEventName('touchstart');
                this.removeHandler(this.dropdownlistWrapper, eventName);
                if (this.listBox) {
                    if (this.listBox.content) {
                        this.removeHandler(this.listBox.content, 'click');
                    }
                }

                this.removeHandler(this.host, 'loadContent');
                this.removeHandler(this.listBoxContainer, 'checkChange');
                this.removeHandler(this.host, 'keydown');
                this.removeHandler(this.host, 'focus');
                this.removeHandler(this.host, 'blur');
                this.removeHandler(this._firstDiv, 'focus');
                this.removeHandler(this._firstDiv, 'blur');
                this.removeHandler(this.host, 'mouseenter');
                this.removeHandler(this.host, 'mouseleave');
                this.removeHandler($(document), 'mousemove.' + self.id);
            },

            // gets an item by index.
            getItem: function (index) {
                var item = this.listBox.getItem(index);
                return item;
            },

            getItemByValue: function (value) {
                var item = this.listBox.getItemByValue(value);
                return item;
            },

            selectItem: function (item) {
                if (this.listBox != undefined) {
                    this.listBox.selectItem(item);
                    this.selectedIndex = this.listBox.selectedIndex;
                    this.renderSelection('mouse');
                }
            },

            unselectItem: function (item) {
                if (this.listBox != undefined) {
                    this.listBox.unselectItem(item);
                    this.renderSelection('mouse');
                }
            },

            checkItem: function (item) {
                if (this.listBox != undefined) {
                    this.listBox.checkItem(item);
                }
            },

            uncheckItem: function (item) {
                if (this.listBox != undefined) {
                    this.listBox.uncheckItem(item);
                }
            },

            indeterminateItem: function (item) {
                if (this.listBox != undefined) {
                    this.listBox.indeterminateItem(item);
                }
            },


            // renders the selection.
            renderSelection: function () {
                if (this.listBox == null)
                    return;

                if (this.height && this.height.toString().indexOf('%') != -1) {
                    this._arrange();
                }

                var item = this.listBox.visibleItems[this.listBox.selectedIndex];
                if (this.filterable) {
                    if (this.listBox.selectedIndex == -1) {
                        for (var selectedValue in this.listBox.selectedValues) {
                            var value = this.listBox.selectedValues[selectedValue];
                            var selectedItem = this.listBox.getItemByValue(value);
                            if (selectedItem) {
                                item = selectedItem;
                            }
                        }
                    }
                }

                var me = this;
                if (this.checkboxes) {
                    var checkedItems = this.getCheckedItems();
                    if (checkedItems != null && checkedItems.length > 0) {
                        item = checkedItems[0];
                    }
                    else item = null;
                }

                if (this.hint) {
                    if (this.label) {
                        this.label[0].innerHTML = this.placeHolder;
                    }

                    if (item != null) {
                        this.element.setAttribute('hint', true);
                    }
                    else {
                        this.element.removeAttribute('hint');
                    }
                }

                this.bar.css('top', this.host.height());
                if (item == null) {
                    var spanElement = $('<span unselectable="on" style="color: inherit; border: none; background-color: transparent;"></span>');
                    spanElement.appendTo($(document.body));
                    spanElement.addClass(this.toThemeProperty('jqx-widget'));
                    spanElement.addClass(this.toThemeProperty('jqx-listitem-state-normal'));
                    spanElement.addClass(this.toThemeProperty('jqx-item'));

                    $.jqx.utilities.html(spanElement, this.placeHolder);
                    if (this.isMaterialized() && !this.element.getAttribute('default-placeholder') && this.hint) {
                        spanElement[0].innerHTML = "";

                        if (this.label) {
                            this.label[0].innerHTML = this.placeHolder;
                        }
                    }
                    var topPadding = this.dropdownlistContent.css('padding-top');
                    var bottomPadding = this.dropdownlistContent.css('padding-bottom');
                    spanElement.css('padding-top', topPadding);
                    spanElement.css('padding-bottom', bottomPadding);
                    var spanHeight = spanElement.outerHeight();
                    spanElement.remove();
                    spanElement.removeClass();
                    $.jqx.utilities.html(this.dropdownlistContent, spanElement);
                    var height = this.host.height();
                    if (this.height != null && this.height != undefined) {
                        if (this.height.toString().indexOf('%') === -1) {
                            height = parseInt(this.height);
                        }
                    }

                    var top = parseInt((parseInt(height) - parseInt(spanHeight)) / 2);

                    if (this.host.css('box-sizing') === 'border-box') {
                        top = parseInt((parseInt(height - 2) - parseInt(spanHeight)) / 2);
                    }

                    if (top > 0) {
                        this.dropdownlistContent.css('margin-top', top + 'px');
                        this.dropdownlistContent.css('margin-bottom', top + 'px');
                    }
                    if (this.selectionRenderer) {
                        $.jqx.utilities.html(this.dropdownlistContent, this.selectionRenderer(spanElement, -1, "", ""));
                        this.dropdownlistContent.css('margin-top', '0px');
                        this.dropdownlistContent.css('margin-bottom', '0px');
                        this._updateInputSelection();
                    }
                    else this._updateInputSelection();
                    this.selectedIndex = this.listBox.selectedIndex;
                    if (this.width === "auto") {
                        this._arrange();
                    }
                    if (this.focusable && this.isOpened()) {
                        this.focus();
                    }
                    return;
                }

                this.selectedIndex = this.listBox.selectedIndex;
                var spanElement = $(document.createElement('span'));
                spanElement[0].setAttribute('unselectable', 'on');
                try {
                    spanElement[0].style.color = "inherit";
                }
                catch (er) {
                }

                spanElement[0].style.borderWidth = '0px';
                spanElement[0].style.backgroundColor = "transparent";
                spanElement.appendTo($(document.body));
                spanElement.addClass(this.toThemeProperty('jqx-widget jqx-listitem-state-normal jqx-item'));

                var emptyItem = false;
                try {
                    if (item.html != undefined && item.html != null && item.html.toString().length > 0) {
                        $.jqx.utilities.html(spanElement, item.html);
                    }
                    else if (item.label != undefined && item.label != null && item.label.toString().length > 0) {
                        $.jqx.utilities.html(spanElement, item.label);
                    }
                    else if (item.label === null || item.label === "") {
                        emptyItem = true;
                        $.jqx.utilities.html(spanElement, "");
                    }
                    else if (item.value != undefined && item.value != null && item.value.toString().length > 0) {
                        $.jqx.utilities.html(spanElement, item.value);

                    }
                    else if (item.title != undefined && item.title != null && item.title.toString().length > 0) {
                        $.jqx.utilities.html(spanElement, item.title);
                    }
                    else if (item.label == "" || item.label == null) {
                        emptyItem = true;
                        $.jqx.utilities.html(spanElement, "");
                    }
                }
                catch (error) {
                    var errorMessage = error;
                }

                var topPadding = this.dropdownlistContent[0].style.paddingTop;
                var bottomPadding = this.dropdownlistContent[0].style.paddingBottom;
                if (topPadding === "") topPadding = "0px";
                if (bottomPadding === "") bottomPadding = "0px";

                spanElement[0].style.paddingTop = topPadding;
                spanElement[0].style.paddingBottom = bottomPadding;

                var spanHeight = spanElement.outerHeight();
                if (spanHeight === 0) {
                    spanHeight = 16;
                }

                if ((item.label == "" || item.label == null) && emptyItem) {
                    $.jqx.utilities.html(spanElement, "");
                }
                var notPercentageWidth = this.width && this.width.toString().indexOf('%') <= 0;

                spanElement.remove();
                spanElement.removeClass();
                if (this.selectionRenderer) {
                    $.jqx.utilities.html(this.dropdownlistContent, this.selectionRenderer(spanElement, item.index, item.label, item.value));
                    if (this.focusable && this.isOpened()) {
                        this.focus();
                    }
                }
                else {
                    if (this.checkboxes) {
                        var items = this.getCheckedItems();
                        var str = "";
                        for (var i = 0; i < items.length; i++) {
                            if (i == items.length - 1) {
                                str += items[i].label;
                            }
                            else {
                                str += items[i].label + ",";
                            }
                        }
                        spanElement.text(str);
                        if (notPercentageWidth) {
                            spanElement.css('max-width', this.host.width() - 30);
                        }
                        spanElement.css('overflow', 'hidden');
                        spanElement.css('display', 'block');
                        if (!this.rtl) {
                            if (notPercentageWidth) {
                                spanElement.css('width', this.host.width() - 30);
                            }
                        }
                        spanElement.css('text-overflow', 'ellipsis');
                        spanElement.css('padding-bottom', 1 + parseInt(bottomPadding));

                        this.dropdownlistContent.html(spanElement);
                        if (this.focusable && this.isOpened()) {
                            this.focus();
                        }
                    }
                    else {
                        var w = this.host.width() - this.arrowSize - 1;
                        if (this.width && this.width !== 'auto') {
                            if (notPercentageWidth) {
                                if (!this.rtl) {
                                    spanElement.css('max-width', w + "px");
                                }
                            }

                            spanElement[0].style.overflow = "hidden";
                            spanElement[0].style.display = "block";
                            spanElement[0].style.paddingTop = (1 + parseInt(bottomPadding)) + "px";
                            if (!this.rtl) {
                                if (notPercentageWidth) {
                                    if (w < 0) w = 0;
                                    spanElement[0].style.width = w + "px";
                                }
                            }
                            spanElement[0].style.textOverflow = 'ellipsis';
                        }

                        this.dropdownlistContent[0].innerHTML = spanElement[0].innerHTML;
                        if (this.focusable && this.isOpened()) {
                            this.focus();
                        }
                    }
                }

                var height = this.host.height();
                if (this.height != null && this.height != undefined) {
                    if (this.height.toString().indexOf('%') === -1) {
                        height = parseInt(this.height);
                    }
                }

                var top = parseInt((parseInt(height) - parseInt(spanHeight)) / 2);

                if (this.host.css('box-sizing') === 'border-box') {
                    top = parseInt((parseInt(height - 2) - parseInt(spanHeight)) / 2);
                }

                if (top >= 0) {
                    this.dropdownlistContent[0].style.marginTop = top + 'px';
                    this.dropdownlistContent[0].style.marginBottom = top + 'px';
                }
                if (this.selectionRenderer) {
                    this.dropdownlistContent[0].style.marginTop = '0px';
                    this.dropdownlistContent[0].style.marginBottom = '0px';
                }
                if (this.dropdownlistContent && this.input) {
                    this._updateInputSelection();
                }
                if (this.listBox && this.listBox._activeElement) {
                    $.jqx.aria(this, "aria-activedescendant", this.listBox._activeElement.id);
                }
                if (this.width === "auto") {
                    this._arrange();
                }
            },

            _updateInputSelection: function () {
                if (this.input) {
                    var selectedValues = new Array();
                    if (this.selectedIndex == -1) {
                        this.input.val("");
                    }
                    else {
                        var selectedItem = this.getSelectedItem();
                        if (selectedItem != null) {
                            this.input.val(selectedItem.value);
                            selectedValues.push(selectedItem.value);
                        }
                        else {
                            this.input.val(this.dropdownlistContent.text());
                        }
                    }
                    if (this.checkboxes) {
                        var items = this.getCheckedItems();
                        var str = "";
                        if (items != null) {
                            for (var i = 0; i < items.length; i++) {
                                var value = items[i].value;
                                if (value == undefined) continue;
                                if (i == items.length - 1) {
                                    str += value;
                                }
                                else {
                                    str += value + ",";
                                }
                                selectedValues.push(value);
                            }
                        }
                        this.input.val(str);
                    }
                }
                if (this.field && this.input) {
                    if (this.field.nodeName.toLowerCase() == "select") {
                        $.each(this.field, function (index, value) {
                            $(this).removeAttr('selected');
                            this.selected = selectedValues.indexOf(this.value) >= 0;
                            if (this.selected) {
                                $(this).attr('selected', true);
                            }
                        });
                    }
                    else {
                        $.each(this.items, function (index, value) {
                            $(this.originalItem.originalItem).removeAttr('data-selected');
                            this.selected = selectedValues.indexOf(this.value) >= 0;
                            if (this.selected) {
                                $(this.originalItem.originalItem).attr('data-selected', true);
                            }
                        });
                    }
                }
            },

            setContent: function (content) {
                $.jqx.utilities.html(this.dropdownlistContent, content);
                this._updateInputSelection();
            },

            dataBind: function () {
                this.listBoxContainer.jqxListBox({ source: this.source });
                this.renderSelection('mouse');
                if (this.source == null) {
                    this.clearSelection();
                }
            },

            clear: function () {
                this.listBoxContainer.jqxListBox({ source: null });
                this.clearSelection();
            },

            // clears the selection.
            clearSelection: function (render) {
                this.selectedIndex = -1;
                this._updateInputSelection();
                this.listBox.clearSelection();
                this.renderSelection();
                if (!this.selectionRenderer && !this.hint && !this.isMaterialized()) {
                    $.jqx.utilities.html(this.dropdownlistContent, this.placeHolder);
                }
            },

            // unselects an item at specific index.
            // @param Number
            unselectIndex: function (index, render) {
                if (isNaN(index))
                    return;

                this.listBox.unselectIndex(index, render);
                this.renderSelection();
            },

            // selects an item at specific index.
            // @param Number
            selectIndex: function (index, ensureVisible, render, forceSelect) {
                this.listBox.selectIndex(index, ensureVisible, render, forceSelect, 'api');
            },

            // gets the selected index.
            getSelectedIndex: function () {
                return this.selectedIndex;
            },

            // gets the selected item.
            getSelectedItem: function () {
                return this.listBox.getVisibleItem(this.selectedIndex);
            },

            getCheckedItems: function () {
                return this.listBox.getCheckedItems();
            },

            checkIndex: function (index) {
                this.listBox.checkIndex(index);
            },

            uncheckIndex: function (index) {
                this.listBox.uncheckIndex(index);
            },

            indeterminateIndex: function (index) {
                this.listBox.indeterminateIndex(index);
            },
            checkAll: function () {
                this.listBox.checkAll();
                this.renderSelection('mouse');
            },

            uncheckAll: function () {
                this.listBox.uncheckAll();
                this.renderSelection('mouse');
            },

            addItem: function (item) {
                return this.listBox.addItem(item);
            },

            insertAt: function (item, index) {
                if (item == null)
                    return false;

                return this.listBox.insertAt(item, index);
            },

            removeAt: function (index) {
                var result = this.listBox.removeAt(index);
                this.renderSelection('mouse');
                return result;
            },

            removeItem: function (item) {
                var result = this.listBox.removeItem(item);
                this.renderSelection('mouse');
                return result;
            },

            updateItem: function (item, oldItem) {
                var result = this.listBox.updateItem(item, oldItem);
                this.renderSelection('mouse');
                return result;
            },

            updateAt: function (item, index) {
                var result = this.listBox.updateAt(item, index);
                this.renderSelection('mouse');
                return result;
            },

            ensureVisible: function (index) {
                return this.listBox.ensureVisible(index);
            },

            disableAt: function (index) {
                return this.listBox.disableAt(index);
            },

            enableAt: function (index) {
                return this.listBox.enableAt(index);
            },

            disableItem: function (item) {
                return this.listBox.disableItem(item);
            },

            enableItem: function (item) {
                return this.listBox.enableItem(item);
            },

            _findPos: function (obj) {
                while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
                    obj = obj['nextSibling'];
                }
                var position = $(obj).coord(true);
                return [position.left, position.top];
            },

            testOffset: function (element, offset, inputHeight) {
                var dpWidth = element.outerWidth();
                var dpHeight = element.outerHeight();
                var viewWidth = $(window).width() + $(window).scrollLeft();
                var viewHeight = $(window).height() + $(window).scrollTop();

                if (offset.left + dpWidth > viewWidth) {
                    if (dpWidth > this.host.width()) {
                        var hostLeft = this.host.coord().left;
                        var hOffset = dpWidth - this.host.width();
                        offset.left = hostLeft - hOffset + 2;
                    }
                }
                if (offset.left < 0) {
                    offset.left = parseInt(this.host.coord().left) + 'px'
                }

                offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                    Math.abs(dpHeight + inputHeight + 22) : 0);

                return offset;
            },

            open: function () {
                this.showListBox();
            },

            close: function () {
                this.hideListBox();
            },

            _getBodyOffset: function () {
                var top = 0;
                var left = 0;
                if ($('body').css('border-top-width') != '0px') {
                    top = parseInt($('body').css('border-top-width'));
                    if (isNaN(top)) top = 0;
                }
                if ($('body').css('border-left-width') != '0px') {
                    left = parseInt($('body').css('border-left-width'));
                    if (isNaN(left)) left = 0;
                }
                return { left: left, top: top };
            },

            // shows the listbox.
            showListBox: function () {
                $.jqx.aria(this, "aria-expanded", true);
                if (this.listBox._renderOnDemand) {
                    this.listBoxContainer.jqxListBox({ _renderOnDemand: false });
                }

                if (this.dropDownWidth == 'auto' && this.width != null && this.width.indexOf && (this.width.indexOf('%') != -1 || this.width.indexOf('auto') != -1)) {
                    if (this.listBox.host.width() != this.host.width()) {
                        var width = this.element.offsetWidth;
                        this.listBoxContainer.jqxListBox({ width: width });
                        this.container.width(parseInt(width) + 25);
                    }
                }
                if (this.dropDownWidth == 'auto' && this.host.css('border-left-width') === "0px") {
                    var width = this.element.offsetWidth;
                    this.listBoxContainer.jqxListBox({ width: width + 1 });
                    this.container.width(parseInt(width) + 25);
                }

                var self = this;
                var listBox = this.listBoxContainer;
                var listBoxInstance = this.listBox;
                var scrollPosition = $(window).scrollTop();
                var scrollLeftPosition = $(window).scrollLeft();
                var top = parseInt(this._findPos(this.host[0])[1]) + parseInt(this.host.outerHeight()) - 1 + 'px';
                //var left = parseInt(Math.round(this.host.coord(true).left)) + 'px';
                var left, leftPos = parseInt(Math.round(this.host.coord(true).left));
                left = leftPos + 'px';


                if (this.dropDownContainer === 'element') {
                    top = parseInt(this.host.outerHeight()) - 1 + 'px';
                    left = 0;
                }


                var isMobileBrowser = false;//$.jqx.mobile.isSafariMobileBrowser() || $.jqx.mobile.isWindowsPhone();

                if (this.listBox == null)
                    return;

                this.ishiding = false;
                if (!this.keyboardSelection) {
                    this.listBox.selectIndex(this.selectedIndex);
                    this.listBox.ensureVisible(this.selectedIndex);
                }

                this.tempSelectedIndex = this.selectedIndex;

                if (this.autoDropDownHeight) {
                    this.container.height(this.listBoxContainer.height() + 25);
                }

                if ((isMobileBrowser != null && isMobileBrowser)) {
                    left = $.jqx.mobile.getLeftPos(this.element);
                    top = $.jqx.mobile.getTopPos(this.element) + parseInt(this.host.outerHeight());
                    if ($('body').css('border-top-width') != '0px') {
                        top = parseInt(top) - this._getBodyOffset().top + 'px';
                    }
                    if ($('body').css('border-left-width') != '0px') {
                        left = parseInt(left) - this._getBodyOffset().left + 'px';
                    }
                }

                listBox.stop();
                if (this.renderMode !== 'simple') {
                    this.host.addClass(this.toThemeProperty('jqx-dropdownlist-state-selected'));
                    this.host.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                    if (this.dropDownVerticalAlignment == "top") {
                        this.arrow.addClass(this.toThemeProperty('jqx-icon-arrow-up-selected'));
                    }
                    else {
                        this.arrow.addClass(this.toThemeProperty('jqx-icon-arrow-down-selected'));
                    }
                }


                this.container.css('left', left);
                this.container.css('top', top);
                listBoxInstance._arrange();

                var closeAfterSelection = true;
                var positionChanged = false;

                if (this.dropDownHorizontalAlignment == 'right' || this.rtl) {
                    var containerWidth = this.container.outerWidth();
                    var containerLeftOffset = -2 + Math.abs(containerWidth - this.host.width());

                    if (containerWidth > this.host.width()) {
                        this.container.css('left', 25 + parseInt(Math.round(leftPos)) - containerLeftOffset + "px");
                    }
                    else this.container.css('left', 25 + parseInt(Math.round(leftPos)) + containerLeftOffset + "px");
                }

                if (this.dropDownVerticalAlignment == "top") {
                    var dpHeight = listBox.height();
                    positionChanged = true;

                    listBox.css('top', 23);
                    listBox.addClass(this.toThemeProperty('jqx-popup-up'));
                    var inputHeight = parseInt(this.host.outerHeight());
                    var t = parseInt(top) - Math.abs(dpHeight + inputHeight + 23);

                    this.container.css('top', t);
                }

                if (this.enableBrowserBoundsDetection) {
                    var newOffset = this.testOffset(listBox, { left: parseInt(this.container.css('left')), top: parseInt(top) }, parseInt(this.host.outerHeight()));
                    if (parseInt(this.container.css('top')) != newOffset.top) {
                        positionChanged = true;
                        listBox.css('top', 23);
                        listBox.addClass(this.toThemeProperty('jqx-popup-up'));
                    }
                    else listBox.css('top', 0);

                    this.container.css('top', newOffset.top);
                    if (parseInt(this.container.css('left')) != newOffset.left) {
                        this.container.css('left', newOffset.left);
                    }
                }

                if (this.animationType == 'none' || this.animationType === 'transform') {
                    this.container.css('display', 'block');
                    $.data(document.body, "openedJQXListBoxParent", self);
                    $.data(document.body, "openedJQXListBox" + this.id, listBox);
                    listBox.css('margin-top', 0);
                    listBox.css('opacity', 1);
                    listBoxInstance._renderItems();
                    self._raiseEvent('0', listBoxInstance);
                }
                else {
                    this.container.css('display', 'block');
                    self.isanimating = true;
                    if (this.animationType == 'fade') {
                        listBox.css('margin-top', 0);
                        listBox.css('opacity', 0);
                        listBox.animate({ 'opacity': 1 }, this.openDelay, function () {
                            $.data(document.body, "openedJQXListBoxParent", self);
                            $.data(document.body, "openedJQXListBox" + self.id, listBox);
                            self.ishiding = false;
                            self.isanimating = false;
                            listBoxInstance._renderItems();
                            self._raiseEvent('0', listBoxInstance);
                        });
                    }
                    else {
                        listBox.css('opacity', 1);
                        var height = listBox.outerHeight();
                        if (positionChanged) {
                            listBox.css('margin-top', height);
                        }
                        else {
                            listBox.css('margin-top', -height);
                        }

                        listBox.animate({ 'margin-top': 0 }, this.openDelay, function () {
                            $.data(document.body, "openedJQXListBoxParent", self);
                            $.data(document.body, "openedJQXListBox" + self.id, listBox);
                            self.ishiding = false;
                            self.isanimating = false;
                            listBoxInstance._renderItems();
                            self._raiseEvent('0', listBoxInstance);
                        });
                    }
                }
                if (!positionChanged) {
                    this.host.addClass(this.toThemeProperty('jqx-rc-b-expanded'));
                    listBox.addClass(this.toThemeProperty('jqx-rc-t-expanded'));
                }
                else {
                    this.host.addClass(this.toThemeProperty('jqx-rc-t-expanded'));
                    listBox.addClass(this.toThemeProperty('jqx-rc-b-expanded'));
                }
                if (this.renderMode !== 'simple') {
                    listBox.addClass(this.toThemeProperty('jqx-fill-state-focus'));
                    this.host.addClass(this.toThemeProperty('jqx-dropdownlist-state-focus'));
                    this.host.addClass(this.toThemeProperty('jqx-fill-state-focus'));
                }

                this.element.setAttribute('opened', true);
                listBox.addClass(this.toThemeProperty('jqx-popup-show'));
            },

            // hides the listbox.
            hideListBox: function () {
                $.jqx.aria(this, "aria-expanded", false);

                var listBox = this.listBoxContainer;
                var listBoxInstance = this.listBox;
                var container = this.container;
                var me = this;
                this.element.removeAttribute('opened');

                listBox.removeClass('jqx-popup-show');

                $.data(document.body, "openedJQXListBox" + this.id, null);
                if (this.animationType == 'none') {
                    this.container.css('display', 'none');
                }
                else if (this.animationType === 'transform') {
                    setTimeout(function () {
                        container.css('display', 'none');
                    }, this.closeDelay);
                }
                else {
                    if (!me.ishiding) {
                        listBox.stop();
                        var height = listBox.outerHeight();
                        listBox.css('margin-top', 0);
                        me.isanimating = true;

                        var animationValue = -height;
                        if (parseInt(this.container.coord().top) < parseInt(this.host.coord().top)) {
                            animationValue = height;
                        }

                        if (this.animationType == 'fade') {
                            listBox.css({ 'opacity': 1 });
                            listBox.animate({ 'opacity': 0 }, this.closeDelay, function () {
                                container.css('display', 'none');
                                me.isanimating = false;
                                me.ishiding = false;
                            });
                        }
                        else {
                            listBox.animate({ 'margin-top': animationValue }, this.closeDelay, function () {
                                container.css('display', 'none');
                                me.isanimating = false;
                                me.ishiding = false;
                            });
                        }
                    }
                }

                this.ishiding = true;
                this.host.removeClass(this.toThemeProperty('jqx-dropdownlist-state-selected'));
                this.host.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this.arrow.removeClass(this.toThemeProperty('jqx-icon-arrow-down-selected'));
                this.arrow.removeClass(this.toThemeProperty('jqx-icon-arrow-up-selected'));
                this.host.removeClass(this.toThemeProperty('jqx-rc-b-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-rc-t-expanded'));
                this.host.removeClass(this.toThemeProperty('jqx-rc-t-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-rc-b-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-fill-state-focus'));
                this.host.removeClass(this.toThemeProperty('jqx-dropdownlist-state-focus'));
                this.host.removeClass(this.toThemeProperty('jqx-fill-state-focus'));

                this._raiseEvent('1', listBoxInstance);
            },

            /* Close popup if clicked elsewhere. */
            closeOpenedListBox: function (event) {
                var self = event.data.me;
                var $target = $(event.target);
                var openedListBox = event.data.listbox;
                if (openedListBox == null)
                    return true;

                if ($(event.target).ischildof(event.data.me.host)) {
                    return true;
                }

                if (!self.isOpened()) {
                    return true;
                }

                if ($(event.target).ischildof(self.listBoxContainer)) {
                    return true;
                }

                var dropdownlistInstance = self;

                var isListBox = false;
                $.each($target.parents(), function () {
                    if (this.className != 'undefined') {
                        if (this.className.indexOf) {
                            if (this.className.indexOf('jqx-listbox') != -1) {
                                isListBox = true;
                                return false;
                            }
                            if (this.className.indexOf('jqx-dropdownlist') != -1) {
                                if (self.element.id == this.id) {
                                    isListBox = true;
                                }
                                return false;
                            }
                        }
                    }
                });

                if (openedListBox != null && !isListBox && self.isOpened()) {
                    self.hideListBox();
                }

                return true;
            },

            clearFilter: function () {
                this.listBox.clearFilter();
            },

            loadFromSelect: function (id) {
                this.listBox.loadFromSelect(id);
            },

            refresh: function (initialRefresh) {
                if (initialRefresh !== true) {
                    this._setSize();
                    this._arrange();
                    if (this.listBox) {
                        this.renderSelection();
                    }
                }
            },

            _arrange: function () {
                var that = this;
                var width = parseInt(that.host.width());
                var height = parseInt(that.host.height());
                var arrowHeight = that.arrowSize;
                var arrowWidth = that.arrowSize;
                var rightOffset = 3;
                var contentWidth = width - arrowWidth - 2 * rightOffset;
                if (contentWidth > 0 && that.width !== "auto") {
                    that.dropdownlistContent[0].style.width = contentWidth + "px";
                }
                else if (contentWidth <= 0) {
                    that.dropdownlistContent[0].style.width = "0px";
                }

                if (that.width === "auto") {
                    that.dropdownlistContent.css('width', 'auto');
                    width = 2 + that.dropdownlistContent.width() + arrowWidth + 2 * rightOffset;
                    if (width < 47) {
                        width = 47;
                    }
                    that.host.width(width);
                }
                that.dropdownlistContent[0].style.height = height + "px";
                that.dropdownlistContent[0].style.left = "0px";
                that.dropdownlistContent[0].style.top = "0px";

                that.dropdownlistArrow[0].style.width = arrowWidth + "px";
                if (that.width && that.width.toString().indexOf('%') >= 0) {
                    var arrowPercentage = (arrowWidth * 100) / width;
                    var contentPercentage = (contentWidth * 100) / width;
                    that.dropdownlistArrow[0].style.width = arrowPercentage + '%';
                    that.dropdownlistContent[0].style.width = contentPercentage + '%';
                }
                that.dropdownlistArrow[0].style.height = height + "px";

                if (that.rtl) {
                    that.dropdownlistArrow.css('float', 'left');
                    that.dropdownlistContent.css('float', 'right');
                }
            },

            destroy: function () {
                $.jqx.utilities.resize(this.host, null, true);
                this.removeHandler(this.listBoxContainer, 'select');
                this.removeHandler(this.listBoxContainer, 'unselect');
                this.removeHandler(this.listBoxContainer, 'change');
                this.removeHandler(this.dropdownlistWrapper, 'selectstart');
                this.removeHandler(this.dropdownlistWrapper, 'mousedown');
                this.removeHandler(this.host, 'keydown');
                this.removeHandler(this.listBoxContainer, 'select');
                this.removeHandler(this.listBox.content, 'click');
                this.removeHandler(this.listBoxContainer, 'bindingComplete');

                if (this.host.parents()) {
                    this.removeHandler(this.host.parents(), 'scroll.dropdownlist' + this.element.id);
                }

                this.removeHandlers();

                this.listBoxContainer.jqxListBox('destroy');
                this.listBoxContainer.remove();
                this.host.removeClass();
                this.removeHandler($(document), 'mousedown.' + this.id, this.closeOpenedListBox);
                if (this.touch) {
                    this.removeHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.' + this.id);
                }

                this.dropdownlistArrow.remove();
                delete this.dropdownlistArrow;
                delete this.dropdownlistWrapper;
                delete this.listBoxContainer;
                delete this.input;
                delete this.arrow;
                delete this.dropdownlistContent;
                delete this.listBox;
                delete this._firstDiv;
                this.container.remove();
                delete this.container;
                var vars = $.data(this.element, "jqxDropDownList");
                if (vars) {
                    delete vars.instance;
                }
                this.host.removeData();
                this.host.remove();
                delete this.comboStructure;
                delete this.host;
                delete this.element;
            },

            _raiseEvent: function (id, arg) {
                if (arg == undefined)
                    arg = { owner: null };

                var evt = this.events[id];
                var args = arg;
                args.owner = this;

                var event = new $.Event(evt);
                event.owner = this;
                if (id == 2 || id == 3 || id == 4 || id == 5 || id == 6 || id == 7 || id == 8 || id == 9) {
                    event.args = arg;
                }

                var result = this.host.trigger(event);
                return result;
            },


            propertiesChangedHandler: function (object, key, value) {
                if (value.width && value.height && Object.keys(value).length == 2) {
                    object._setSize();
                    if (key == 'width') {
                        if (object.dropDownWidth == 'auto') {
                            var width = object.host.width();
                            object.listBoxContainer.jqxListBox({ width: width });
                            object.container.width(parseInt(width) + 25);
                        }
                    }
                    object._arrange();
                    object.close();
                }
            },

            propertyChangedHandler: function (object, key, oldvalue, value) {
                if (object.isInitialized == undefined || object.isInitialized == false)
                    return;

                if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                    return;
                }

                if (key == "template") {
                    object.listBoxContainer.removeClass(object.toThemeProperty("jqx-" + oldvalue + "-item"));
                    object.listBoxContainer.addClass(object.toThemeProperty("jqx-" + object.template + "-item"));
                    object.host.removeClass(object.toThemeProperty("jqx-" + oldvalue + ""));
                    object.host.addClass(object.toThemeProperty("jqx-" + object.template + ""));
                }

                if (key == "dropDownVerticalAlignment") {
                    object.close();
                    object.arrow.removeClass(object.toThemeProperty('jqx-icon-arrow-up'));
                    object.arrow.removeClass(object.toThemeProperty('jqx-icon-arrow-down'));
                    if (object.dropDownVerticalAlignment == "top") {
                        object.arrow.addClass(object.toThemeProperty('jqx-icon-arrow-up'));
                    }
                    else {
                        object.arrow.addClass(object.toThemeProperty('jqx-icon-arrow-down'));
                    }
                    object.listBoxContainer.css('top', 0);
                    object.listBoxContainer.removeClass(this.toThemeProperty('jqx-popup-up'));
                }

                if (key == "autoItemsHeight") {
                    object.listBoxContainer.jqxListBox({ autoItemsHeight: value });
                }

                if (key == "filterable") {
                    object.listBoxContainer.jqxListBox({ filterable: value });
                }
                if (key == "filterHeight") {
                    object.listBoxContainer.jqxListBox({ filterHeight: value });
                }
                if (key == "filterPlaceHolder") {
                    object.listBoxContainer.jqxListBox({ filterPlaceHolder: value });
                }
                if (key == "filterDelay") {
                    object.listBoxContainer.jqxListBox({ filterDelay: value });
                }

                if (key == "enableSelection") {
                    object.listBoxContainer.jqxListBox({ enableSelection: value });
                }
                if (key == "enableHover") {
                    object.listBoxContainer.jqxListBox({ enableHover: value });
                }

                if (key == 'autoOpen') {
                    object._updateHandlers();
                }
                if (key == 'emptyString') {
                    object.listBox.emptyString = object.emptyString;
                }
                if (key == "itemHeight") {
                    object.listBoxContainer.jqxListBox({ itemHeight: value });
                }

                if (key == "renderer") {
                    object.listBoxContainer.jqxListBox({ renderer: value });
                }

                if (key == "rtl") {
                    if (value) {
                        object.dropdownlistArrow.css('float', 'left');
                        object.dropdownlistContent.css('float', 'right');
                    }
                    else {
                        object.dropdownlistArrow.css('float', 'right');
                        object.dropdownlistContent.css('float', 'left');
                    }
                    object.listBoxContainer.jqxListBox({ rtl: object.rtl });
                }
                if (key == 'source') {
                    object.listBoxContainer.jqxListBox({ source: object.source });
                    object.listBox.selectedIndex = -1;
                    object.listBox.selectIndex(this.selectedIndex);
                    object.renderSelection();
                    if (value == null) {
                        object.clear();
                    }
                }

                if (key == "displayMember" || key == "valueMember") {
                    object.listBoxContainer.jqxListBox({ displayMember: object.displayMember, valueMember: object.valueMember });
                    object.renderSelection();
                }
                if (key == "placeHolder") {
                    object.renderSelection();
                }

                if (key == 'theme' && value != null) {
                    object.listBoxContainer.jqxListBox({ theme: value });
                    object.listBoxContainer.addClass(object.toThemeProperty('jqx-popup'));
                    $.jqx.utilities.setTheme(oldvalue, value, object.host);
                }

                if (key == "autoDropDownHeight") {
                    object.listBoxContainer.jqxListBox({ autoHeight: object.autoDropDownHeight });
                    if (object.autoDropDownHeight) {
                        object.container.height(object.listBoxContainer.height() + 25);
                    }
                    else {
                        object.listBoxContainer.jqxListBox({ height: object.dropDownHeight });
                        object.container.height(parseInt(object.dropDownHeight) + 25);
                    }

                    object.listBox._arrange();
                    object.listBox._updatescrollbars();
                }

                if (key == "searchMode") {
                    object.listBoxContainer.jqxListBox({ searchMode: object.searchMode });
                }

                if (key == "incrementalSearch") {
                    object.listBoxContainer.jqxListBox({ incrementalSearch: object.incrementalSearch });
                }

                if (key == "incrementalSearchDelay") {
                    object.listBoxContainer.jqxListBox({ incrementalSearchDelay: object.incrementalSearchDelay });
                }

                if (key == "dropDownHeight") {
                    if (!object.autoDropDownHeight) {
                        object.listBoxContainer.jqxListBox({ height: object.dropDownHeight });
                        object.container.height(parseInt(object.dropDownHeight) + 25);
                    }
                }

                if (key == "dropDownWidth" || key == "scrollBarSize") {
                    var width = object.width;
                    if (object.dropDownWidth != 'auto') {
                        width = object.dropDownWidth;
                    }

                    object.listBoxContainer.jqxListBox({ width: width, scrollBarSize: object.scrollBarSize });
                    object.container.width(parseInt(width) + 25);
                }

                if (key == 'width' || key == 'height') {
                    if (value != oldvalue) {
                        this.refresh();
                        if (key == 'width') {
                            if (object.dropDownWidth == 'auto') {
                                var width = 2 + object.host.width();
                                object.listBoxContainer.jqxListBox({ width: width });
                                object.container.width(parseInt(width) + 25);
                            }
                        }
                        object.close();
                    }
                }

                if (key == "checkboxes") {
                    object.listBoxContainer.jqxListBox({ checkboxes: object.checkboxes });
                }

                if (key == 'selectedIndex') {
                    if (object.listBox != null) {
                        object.listBox.selectIndex(parseInt(value));
                        object.renderSelection();
                    }
                }
            }
        });
    })(jqxBaseFramework);
})();



/***/ }),

/***/ 714:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {
        window.jqxToDash = function (value) {
            return value.split(/(?=[A-Z])/).join('-').toLowerCase();
        }

        var LINE_SEPARATOR2 = "\r\n";
        function returnAttributeIfPopulated(key, value, booleanTransformer) {
            if (!value && value !== "" && value !== 0) {
                return "";
            }
            let xmlValue = value;
            if (typeof value === "boolean") {
                if (booleanTransformer) {
                    xmlValue = booleanTransformer(value);
                }
            }
            return ` ${key}="${xmlValue}"`;
        }

        var XmlFactory = class {
            static createHeader(headerElement = {}) {
                const headerStart = "<?";
                const headerEnd = "?>";
                const keys = ["version"];
                if (!headerElement.version) {
                    headerElement.version = "1.0";
                }
                if (headerElement.encoding) {
                    keys.push("encoding");
                }
                if (headerElement.standalone) {
                    keys.push("standalone");
                }
                const att = keys.map((key) => `${key}="${headerElement[key]}"`).join(" ");
                return `${headerStart}xml ${att} ${headerEnd}`;
            }
            static createXml(xmlElement, booleanTransformer) {
                let props = "";
                if (xmlElement.properties) {
                    if (xmlElement.properties.prefixedAttributes) {
                        xmlElement.properties.prefixedAttributes.forEach((prefixedSet) => {
                            Object.keys(prefixedSet.map).forEach((key) => {
                                props += returnAttributeIfPopulated(
                                    prefixedSet.prefix + key,
                                    prefixedSet.map[key],
                                    booleanTransformer
                                );
                            });
                        });
                    }
                    if (xmlElement.properties.rawMap) {
                        Object.keys(xmlElement.properties.rawMap).forEach((key) => {
                            props += returnAttributeIfPopulated(key, xmlElement.properties.rawMap[key], booleanTransformer);
                        });
                    }
                }
                let result = "<" + xmlElement.name + props;
                if (!xmlElement.children && xmlElement.textNode == null) {
                    return result + "/>" + LINE_SEPARATOR2;
                }
                if (xmlElement.textNode != null) {
                    return result + ">" + xmlElement.textNode + "</" + xmlElement.name + ">" + LINE_SEPARATOR2;
                }
                result += ">" + LINE_SEPARATOR2;
                if (xmlElement.children) {
                    xmlElement.children.forEach((it) => {
                        result += this.createXml(it, booleanTransformer);
                    });
                }
                return result + "</" + xmlElement.name + ">" + LINE_SEPARATOR2;
            }
        };

        class DataExporter {
            constructor(exportDetails, groupBy, filterBy, conditionalFormatting) {
                const that = this;

                if (!exportDetails) {
                    exportDetails = {};
                }

                /*
                 * "style" object definition (all properties are optional):
                 *
                 * any valid CSS property - applied to whole table
                 * header (Object)
                 *      any valid CSS property - applied to header cells
                 *      any column name (Object)
                 *          any valid CSS property - applied to particular column header cell
                 * columns (Object)
                 *      any valid CSS property - applied to column cells
                 *      any column name (Object)
                 *          any valid CSS property - applied to the cells of particular column
                 *          format - applicable to numeric and date columns
                 *          n (Object), where n is a row index (related to use of "ConditionalFormatting" object)
                 *              background
                 *              border
                 *              color
                 * rows (Object)
                 *      any valid CSS property - applied to rows
                 *      alternationCount
                 *      alternationStart
                 *      alternationEnd
                 *      alternationIndexnColor, where n is an integer
                 *      alternationIndexnBorderColor, where n is an integer
                 *      alternationIndexnBackgroundColor, where n is an integer
                 *      n (Object), where n is a row index
                 *          any valid CSS property - applied to particular row
                 */
                that.style = exportDetails.style;

                that.header = exportDetails.header;
                that.exportHeader = exportDetails.exportHeader !== undefined ? exportDetails.exportHeader : true;
                that.hierarchical = exportDetails.hierarchical;
                that.expandChar = exportDetails.expandChar || '+';
                that.collapseChar = exportDetails.collapseChar || '-';
                that.pageOrientation = exportDetails.pageOrientation;
                that.allowNull = exportDetails.allowNull || false;
                that.spreadsheets = exportDetails.spreadsheets || null;

                that._media = [];

                if (!that.hierarchical && groupBy && groupBy.length > 0) {
                    that.groupBy = groupBy;
                }
                else {
                    that.mergedCells = exportDetails.mergedCells;
                }

                if (!that.groupBy && filterBy && Object.keys(filterBy).length > 0) {
                    that.filterBy = filterBy;
                }

                if (conditionalFormatting) {
                    that.conditionalFormatting = conditionalFormatting;
                }

                that.timeBetween1900And1970 = new Date(1970, 0, 1, 0, 0, 0).getTime() - new Date(1900, 0, 1, 0, 0, 0).getTime();
            }

            /**
             * Generates and downloads a file.
             */
            downloadFile(data, type, fileName) {
                let file;

                if (!fileName) {
                    return data;
                }

                if (data instanceof Blob) {
                    file = data;
                }
                else {
                    file = new Blob([data], { type: type });
                }

                if (window.navigator.msSaveOrOpenBlob) { // Edge
                    window.navigator.msSaveOrOpenBlob(file, fileName);
                }
                else { // Chrome, Firefox, Safari
                    const a = document.createElement('a'),
                        url = URL.createObjectURL(file);

                    a.href = url;
                    a.download = fileName;
                    a.style.position = 'absolute';
                    a.style.visibility = 'hidden';

                    document.body.appendChild(a);

                    a.click();

                    setTimeout(function () {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                    }, 100);
                }
            }

            /**
             * Exports data.
             */
            exportData(data, format, fileName, callback) {
                const that = this;

                that.actualHierarchy = that.hierarchical;
                format = format.toLowerCase();

                if (that.exportHeader) {
                    if (that.header) {
                        data = data.slice(0);

                        if (data.length === 0) {
                            that.actualHierarchy = false;
                        }

                        that.processComplexHeader(that.header, data, format);
                    }
                    else if (data.length === 1) {
                        that.actualHierarchy = false;
                    }
                }

                if (data.length === 0) {
                    // eslint-disable-next-line
                    console.warn('No data to export.');
                    return;
                }

                if (format === 'xlsx') {
                    that.xlsxStartIndex = that.complexHeader ? that.complexHeader.length : +that.exportHeader;

                    const offset = that.headerContent ? that.headerContent.length : 0;
                    that.xlsxStartIndex = that.xlsxStartIndex + offset;
                }

                if (that.actualHierarchy) {
                    data = that.processHierarchicalData(data, format);
                }

                that.getDatafields(data);

                if (fileName && fileName.slice(fileName.length - format.length - 1, fileName.length) !== '.' + format) {
                    fileName += '.' + format;
                }

                let output = null;
                switch (format) {
                    case 'csv':
                        output = that.exportToCSVAndTSV(data, { delimiter: ', ', MIME: 'text/csv', toRemove: 2 }, fileName);
                        break;
                    case 'html':
                        output = that.exportToHTML(data, fileName);
                        break;
                    case 'jpeg':
                    case 'png':
                        that.exportToImage(data, fileName, format, callback);
                        break;
                    case 'json':
                        output = that.exportToJSON(data, fileName);
                        break;
                    case 'pdf':
                        output = that.exportToPDF(data, fileName);
                        break;
                    case 'tsv':
                        output = that.exportToCSVAndTSV(data, { delimiter: '\t', MIME: 'text/tab-separated-values', toRemove: 1 }, fileName);
                        break;
                    case 'xlsx':
                        output = that.exportToXLSX(data, fileName, callback);
                        break;
                    case 'xml':
                        output = that.exportToXML(data, fileName);
                        break;
                    case 'md':
                        output = that.exportToMD(data, fileName);
                        break;
                }

                if (callback && output) {
                    callback(output);
                }

                delete that.complexHeader;

                return output;
            }

            /**
             * Exports to CSV and TSV.
             */
            exportToCSVAndTSV(data, formatOptions, fileName) {
                const that = this,
                    datafields = that.datafields;
                let stringResult = '';

                for (let i = 0; i < data.length; i++) {
                    const currentRecord = data[i];
                    let stringifiedCurrentRecord = '';

                    for (let j = 0; j < datafields.length; j++) {
                        if (that.actualHierarchy && j === 0) {
                            stringifiedCurrentRecord += ('""' + formatOptions.delimiter).repeat(currentRecord._level - 1) +
                                '"' + currentRecord[datafields[j]] + '"' + formatOptions.delimiter +
                                ('""' + formatOptions.delimiter).repeat(that.maxLevel - currentRecord._level);
                            continue;
                        }

                        stringifiedCurrentRecord += '"' + currentRecord[datafields[j]] + '"' + formatOptions.delimiter;
                    }

                    stringifiedCurrentRecord = stringifiedCurrentRecord.slice(0, stringifiedCurrentRecord.length - formatOptions.toRemove) + '\n';
                    stringResult += stringifiedCurrentRecord;
                }

                if (!fileName) {
                    return stringResult;
                }
                return this.downloadFile(stringResult, formatOptions.MIME, fileName);
            }

            /**
             * Exports to HTML.
             */
            exportToHTML(data, fileName) {
                const that = this,
                    datafields = that.datafields,
                    style = that.style;
                let header = '',
                    startIndex = 0,
                    html2canvas = '';

                data = that.processGroupingInformation(data);
                that.data = data;

                if (that.exportHeader) {
                    header = that.getHTMLHeader(datafields, data);
                    startIndex = 1;
                }

                if (arguments[2]) {
                    const scripts = Array.from(document.getElementsByTagName('script')),
                        html2canvasScript = scripts.find(script => script.src.indexOf('html2canvas') !== -1);
                    html2canvas = `<script type="text/javascript" src="${html2canvasScript.src}"></script>`;
                }

                let htmlContent = `<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <style type="text/css">
    ${that.getRowStyle()}${that.getColumnStyle()}
        </style>${html2canvas}${that.toggleableFunctionality()}
    </head>
    <body>
        <table${that.getTableStyle()}>${header}
            <tbody>\n`;

                const mergedMainCells = {},
                    mergedSecondaryCells = {},
                    groupsHandled = [];

                that.getMergedCellsInfo(mergedMainCells, mergedSecondaryCells);

                mainLoop:
                for (let i = startIndex; i < data.length; i++) {
                    const currentRecord = data[i],
                        row = i - startIndex;
                    let n = that.getAlternationIndex(row, ' rowN'),
                        toCollapse = '',
                        level = '',
                        groupId = '',
                        outlineLevel = 0;

                    if (that.actualHierarchy) {
                        if (currentRecord._collapsed) {
                            toCollapse = ' collapsed';
                        }

                        level = ` level="${currentRecord._level}"`;
                    }
                    else if (that.groupBy) {
                        for (let k = 0; k < that.groupBy.length; k++) {
                            const datafield = that.groupBy[k],
                                currentGroup = currentRecord[datafield],
                                currentGroupLabel = that.groups[datafield][currentGroup];

                            groupId += currentGroup;

                            if (groupsHandled.indexOf(groupId) === -1) {
                                htmlContent += `            <tr class="row">
                    <td class="column group" style="padding-left: ${outlineLevel * 25}px;" colspan="${that.datafields.length}">${currentGroupLabel}</td>
                </tr>`;
                                groupsHandled.push(groupId);
                                i--;
                                continue mainLoop;
                            }

                            outlineLevel++;
                        }
                    }

                    let currentContent = `            <tr class="row row${row}${n}${toCollapse}"${level}`;

                    if (!fileName) {
                        currentContent += ' style="page-break-inside: avoid;"'
                    }

                    currentContent += '>\n';

                    for (let j = 0; j < datafields.length; j++) {
                        const cellCode = j + ',' + (row);
                        let colspan = 1, rowspan = 1;

                        if (mergedMainCells[cellCode]) {
                            colspan = mergedMainCells[cellCode].colspan;
                            rowspan = mergedMainCells[cellCode].rowspan;
                        }
                        else if (mergedSecondaryCells[cellCode]) {
                            continue;
                        }

                        const datafield = datafields[j];
                        let value = currentRecord[datafield],
                            indent = '';

                        if (that.actualHierarchy && j === 0) {
                            let sign = '';

                            if (currentRecord._expanded) {
                                sign = that.collapseChar;
                            }
                            else if (currentRecord._expanded === false) {
                                sign = that.expandChar;
                            }

                            indent = `<div class="toggle-element" style="margin-left: ${25 * (currentRecord._level - 1) + 5}px;" expanded>${sign}</div>`;
                        }

                        value = that.getFormattedValue(value, datafield);

                        if (typeof value === 'string' && (value.indexOf('base64') >= 0 || value.indexOf('.svg') >= 0 || value.indexOf('.png') >= 0 || value.indexOf('.jpeg') >= 0)) {
                            value = `<img height="30" src="${value}"/>`;
                        }

                        let css = '';

                        if (style && style.columns && style.columns[datafield] && style.columns[datafield][row]) {
                            const uniqueStyle = style.columns[datafield][row];

                            css += `border-color: ${uniqueStyle.border}; background-color: ${uniqueStyle.background}; color: ${uniqueStyle.color};"`;
                        }

                        if (j === 0 && outlineLevel > 1) {
                            css += `padding-left: ${(outlineLevel - 1) * 25}px;"`;
                        }

                        if (css) {
                            css = ` style="${css}"`;
                        }

                        currentContent += `                <td class="column column${datafield}"${css} colspan="${colspan}" rowspan="${rowspan}">${indent + value}</td>\n`;
                    }

                    htmlContent += currentContent + '            </tr>\n';
                }

                htmlContent += `        </tbody>
        </table>
    </body>
    </html>`;

                if (arguments[2]) {
                    return htmlContent;
                }

                return this.downloadFile(htmlContent, 'text/html', fileName);
            }

            /**
             * Exports to an image (PNG/JPEG).
             */
            exportToImage(data, fileName, fileExtension, callback) {
                const that = this;

                try {
                    html2canvas;
                }
                catch (error) {
                    throw new Error('jqx-grid: Missing reference to \'html2canvas.min.js\'.');
                }

                let imageData = null;

                const htmlContent = that.exportToHTML(data, fileName, true),
                    iframe = document.createElement('iframe');

                iframe.style.position = 'absolute';
                iframe.style.top = 0;
                iframe.style.left = 0;
                iframe.style.border = 'none';
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.opacity = 0;
                iframe.style.pointerEvents = 'none';

                document.body.appendChild(iframe);

                iframe.contentDocument.write(htmlContent);

                function checkIframePopulated() {
                    if (!iframe.contentDocument.body || !iframe.contentDocument.body.firstElementChild) {
                        requestAnimationFrame(checkIframePopulated);
                    }
                    else {
                        iframe.contentWindow.html2canvas(iframe.contentDocument.body.firstElementChild).then(canvas => {
                            const draw = new JQX.Utilities.Draw(document.createElement('div'));

                            imageData = canvas.toDataURL('image/png');

                            if (callback) {
                                callback(imageData);
                            }
                            else {
                                document.body.appendChild(canvas);
                                draw.exportImage(undefined, canvas, fileExtension, fileName);
                            }

                            iframe.remove();
                            canvas.remove();
                        });
                    }
                }

                checkIframePopulated();

                return imageData;
            }

            /**
             * Gets merged cells information (for use in HTML and PDF export).
             */
            getMergedCellsInfo(mergedMainCells, mergedSecondaryCells, mapping) {
                const that = this;

                if (!that.mergedCells) {
                    return;
                }

                const multipleTables = mapping && mapping[that.datafields.length - 1] !== 0;

                that.mergedCellsPDF = that.mergedCells.slice(0);

                for (let i = 0; i < that.mergedCellsPDF.length; i++) {
                    const cellDefinition = that.mergedCellsPDF[i];
                    let colspan = cellDefinition.colspan,
                        rowspan = cellDefinition.rowspan;

                    if (rowspan < 2 && colspan < 2) {
                        continue;
                    }

                    const row = cellDefinition.cell[1];
                    let col = cellDefinition.cell[0];

                    if (multipleTables && colspan > 1) {
                        const startTable = mapping[col],
                            endTable = mapping[col + colspan - 1],
                            splitCells = [];

                        if (endTable > startTable) {
                            let currentTable = startTable,
                                currentColumn = col,
                                overal = 0;

                            mainLoop:
                            for (let i = startTable; i <= endTable; i++) {
                                let start = currentColumn,
                                    span = 0;

                                while (mapping[currentColumn] === currentTable) {
                                    currentColumn++;
                                    overal++;
                                    span++;

                                    if (overal === colspan) {
                                        splitCells.push({ start: start, span: span });
                                        break mainLoop;
                                    }
                                }

                                splitCells.push({ start: start, span: span });
                                currentTable = mapping[currentColumn];
                            }

                            colspan = splitCells[0].span;

                            for (let i = 1; i < splitCells.length; i++) {
                                that.mergedCellsPDF.push({ cell: [splitCells[i].start, row], colspan: splitCells[i].span, rowspan: rowspan, originalCell: col });
                            }
                        }
                    }

                    for (let j = col; j < col + colspan; j++) {
                        for (let k = row; k < row + rowspan; k++) {
                            const code = j + ',' + k;

                            if (j === col && k === row) {
                                mergedMainCells[code] = { colspan: colspan, rowspan: rowspan, originalCell: cellDefinition.originalCell };
                                continue;
                            }

                            mergedSecondaryCells[code] = true;
                        }
                    }
                }
            }

            /**
             * Gets alternation index.
             */
            getAlternationIndex(row, prefix) {
                const that = this;

                if (!that.style) {
                    return '';
                }

                const rowsDefinition = that.style.rows,
                    alternationCount = rowsDefinition && rowsDefinition.alternationCount;

                if (alternationCount &&
                    (((rowsDefinition.alternationStart === undefined || row >= rowsDefinition.alternationStart) &&
                        (rowsDefinition.alternationEnd === undefined || row <= rowsDefinition.alternationEnd)) ||
                        rowsDefinition.alternationStart === rowsDefinition.alternationEnd)) {
                    return prefix + (row % rowsDefinition.alternationCount);
                }

                return '';
            }

            /**
             * Gets formatted numeric or date value (for use in HTML and PDF export).
             */
            getFormattedValue(value, datafield) {
                const that = this,
                    style = that.style;

                if (value === null) {
                    return that.allowNull ? 'null' : '';
                }

                if (datafield && style && style.columns &&
                    style.columns[datafield] && style.columns[datafield].format) {
                    if (typeof value === 'number') {
                        return that.formatNumber(value, style.columns[datafield].format);
                    }
                    else if (value instanceof Date) {
                        return that.formatDate(value, style.columns[datafield].format);
                    }
                }
                else if (value instanceof Date) {
                    return that.formatDate(value, 'd');
                }

                return value;
            }

            /**
             * Exports to JSON.
             */
            exportToJSON(data, fileName) {
                return this.downloadFile(JSON.stringify(data, this.datafields.concat('rows')), 'application/json', fileName);
            }

            /**
             * Export to Markdown(MD)
             * @param {string} data - the data to export
             * @param {string} fileName - the name of the file
             * @returns 
             */
            exportToMD(data, fileName) {
                const that = this,
                    dataFields = that.datafields;
                let text = '';


                for (let i = 0, max = data.length; i < max; i += 1) {
                    for (let j = 0, max = dataFields.length; j < max; j += 1) {
                        const dataField = data[i][dataFields[j]];

                        if (typeof dataField === 'string') {
                            text += dataField;
                        }
                    }
                }

                return that.downloadFile(text, 'application/text', fileName);
            }

            /**
             * Exports to PDF.
             */
            exportToPDF(data, fileName) {
                try {
                    pdfMake;
                }
                catch (error) {
                    throw new Error('Missing reference to \'pdfmake.min.js\'.');
                }

                const that = this,
                    datafields = that.datafields,
                    startIndex = +that.exportHeader,
                    groupsHandled = [],
                    mergedMainCells = {},
                    mergedSecondaryCells = {},
                    mapping = {},
                    headerRows = startIndex ? that.complexHeader ? that.complexHeader.length : 1 : 0,
                    docDefinition = {
                        pageOrientation: that.pageOrientation || 'portrait'
                    };
                let header = [], content = [], tables;

                function createTableRow() {
                    let tableRow = [];

                    for (let i = 0; i < tables.length; i++) {
                        tableRow.push([]);
                    }

                    return tableRow;
                }

                data = that.processGroupingInformation(data);
                that.data = data;
                that.headerRows = headerRows;
                that.getPDFStyle();

                const styleInfo = that.styleInfo;

                tables = styleInfo ? that.wrapPDFColumns(docDefinition, mapping) : [{ body: header, datafields: datafields }];

                if (startIndex) {
                    header = that.getPDFHeader(datafields, tables, mapping);
                }

                that.getMergedCellsInfo(mergedMainCells, mergedSecondaryCells, mapping);

                mainLoop:
                for (let i = startIndex; i < data.length; i++) {
                    const currentRecord = data[i];
                    let groupId = '',
                        outlineLevel = 0;

                    if (that.groupBy) {
                        for (let k = 0; k < that.groupBy.length; k++) {
                            const datafield = that.groupBy[k],
                                currentGroup = currentRecord[datafield],
                                currentGroupLabel = that.groups[datafield][currentGroup];

                            groupId += currentGroup;

                            if (groupsHandled.indexOf(groupId) === -1) {
                                that.createGroupHeaderRow(tables, { text: currentGroupLabel, style: ['row', 'cell', 'group'], marginLeft: outlineLevel * 7.5 });
                                groupsHandled.push(groupId);
                                i--;
                                continue mainLoop;
                            }

                            outlineLevel++;
                        }
                    }

                    const tableRow = createTableRow(),
                        row = i - startIndex;
                    let n = that.getAlternationIndex(row, '');

                    for (let j = 0; j < datafields.length; j++) {
                        const datafield = datafields[j],
                            entry = { style: ['row', 'row' + row, 'cell', 'cell' + datafield] },
                            tableIndex = mapping[j] || 0;

                        if (n !== undefined) {
                            entry.style.splice(1, 0, 'rowN' + n);
                        }

                        if (that.mergedCellsPDF) {
                            const cellCode = j + ',' + row,
                                mergeInfo = mergedMainCells[cellCode];

                            if (mergeInfo) {
                                entry.colSpan = mergeInfo.colspan;
                                entry.rowSpan = mergeInfo.rowspan;

                                if (mergeInfo.originalCell !== undefined) {
                                    entry.text = '';
                                    entry.style[entry.style.length - 1] = 'cell' + datafields[mergeInfo.originalCell];
                                    tableRow[tableIndex].push(entry);
                                    continue;
                                }
                            }
                            else if (mergedSecondaryCells[cellCode]) {
                                tableRow[tableIndex].push({});
                                continue;
                            }
                        }

                        const value = that.getFormattedValue(currentRecord[datafield], datafield);

                        entry.text = value.toString();
                        that.getUniqueStylePDF(entry, datafield, row);
                        that.setIndentation(entry, { j: j, currentRecord: currentRecord, value: value, outlineLevel: outlineLevel });
                        tableRow[tableIndex].push(entry);
                    }

                    for (let k = 0; k < tables.length; k++) {
                        tables[k].body.push(tableRow[k]);
                    }
                }

                if (styleInfo) {
                    for (let i = 0; i < tables.length; i++) {
                        const body = tables[i].body;

                        for (let j = headerRows - 1; j >= 0; j--) {
                            body.unshift(header[i][j]);
                        }

                        content.push({
                            table: {
                                headerRows: headerRows,
                                widths: tables[i].widths,
                                heights: function (row) {
                                    if (styleInfo.heights[row]) {
                                        return styleInfo.heights[row];
                                    }

                                    if (styleInfo.defaultHeight) {
                                        return styleInfo.defaultHeight;
                                    }
                                },
                                body: body
                            },
                            pageBreak: 'after'
                        });
                    }

                    delete content[tables.length - 1].pageBreak;
                    docDefinition.styles = styleInfo.styles;
                }
                else {
                    const body = tables[0].body;

                    for (let j = headerRows - 1; j >= 0; j--) {
                        body.unshift(header[0][j]);
                    }

                    content = [{ table: { headerRows: headerRows, body: body } }];
                    docDefinition.styles = { header: { bold: true }, group: { bold: true } };
                }

                docDefinition.content = content;

                if (!fileName) {
                    const output = pdfMake.createPdf(docDefinition);

                    delete that.mergedCellsPDF;
                    delete that.styleInfo;

                    return output;
                }
                pdfMake.createPdf(docDefinition).download(fileName);

                delete that.mergedCellsPDF;
                delete that.styleInfo;
            }

            /**
             * Gets the header content when exporting to PDF.
             */
            getPDFStyle() {
                const that = this,
                    style = that.style;

                if (!style) {
                    return '';
                }

                const sampleRecord = that.data[0],
                    headerDefinition = style.header,
                    columnsDefinition = style.columns,
                    rowsDefinition = style.rows,
                    styleInfo = {
                        heights: [],
                        widths: Array(that.datafields.length).fill('*'),
                        styles: {
                            header: {},
                            row: {},
                            cell: {},
                            group: { fillColor: '#FFFFFF', color: '#000000', bold: true }
                        }
                    };

                that.styleInfo = styleInfo;

                function processStyleDefinition(definition, type) {
                    if (!definition) {
                        return;
                    }

                    for (let prop in definition) {
                        if (!Object.prototype.hasOwnProperty.call(definition, prop)) {
                            continue;
                        }

                        if (sampleRecord[prop] === undefined) {
                            if (prop === 'height' && type === 'header') {
                                for (let i = 0; i < that.headerRows; i++) {
                                    styleInfo.heights[i] = (parseInt(definition[prop], 10) / that.headerRows) / 1.4;
                                }
                            }
                            else {
                                that.storePDFStyle({ prop: prop, value: definition[prop], toUpdate: type });
                            }
                        }
                        else {
                            for (let columnProp in definition[prop]) {
                                if (!isNaN(columnProp) || !Object.prototype.hasOwnProperty.call(definition[prop], columnProp)) {
                                    continue;
                                }

                                const value = definition[prop][columnProp],
                                    index = that.datafields.indexOf(prop);

                                if (columnProp === 'width' && styleInfo.widths[index] === '*') {
                                    styleInfo.widths[index] = value;
                                }
                                else {
                                    that.storePDFStyle({ prop: columnProp, value: value, toUpdate: type + prop });
                                }
                            }
                        }
                    }
                }

                processStyleDefinition(headerDefinition, 'header');
                processStyleDefinition(columnsDefinition, 'cell');

                if (!rowsDefinition) {
                    return;
                }

                for (let prop in rowsDefinition) {
                    if (!Object.prototype.hasOwnProperty.call(rowsDefinition, prop) || prop.indexOf('alt') !== -1) {
                        continue;
                    }

                    const value = rowsDefinition[prop];

                    if (!isNaN(prop)) {
                        for (let rowProp in value) {
                            if (Object.prototype.hasOwnProperty.call(value, rowProp)) {
                                if (rowProp === 'height') {
                                    styleInfo.heights[parseFloat(prop) + that.headerRows] = parseFloat(value[rowProp]) / 1.4;
                                }
                                else {
                                    that.storePDFStyle({ prop: rowProp, value: value[rowProp], toUpdate: 'row' + prop });
                                }
                            }
                        }

                        continue;
                    }

                    if (prop === 'height') {
                        styleInfo.defaultHeight = parseFloat(value) / 1.4;
                    }
                    else {
                        that.storePDFStyle({ prop: prop, value: value, toUpdate: 'row' });
                    }
                }

                if (!rowsDefinition.alternationCount) {
                    return;
                }

                for (let i = 0; i < rowsDefinition.alternationCount; i++) {
                    const styleN = {};

                    if (rowsDefinition[`alternationIndex${i}Color`]) {
                        styleN.color = rowsDefinition[`alternationIndex${i}Color`];
                    }

                    if (rowsDefinition[`alternationIndex${i}BackgroundColor`]) {
                        styleN.fillColor = rowsDefinition[`alternationIndex${i}BackgroundColor`];
                    }

                    styleInfo.styles['rowN' + i] = styleN;
                }
            }

            /**
             * Stores style in object to be applied to generated PDF.
             */
            storePDFStyle(details) {
                const that = this;
                let objectToUpdate = that.styleInfo.styles[details.toUpdate];

                if (!objectToUpdate) {
                    objectToUpdate = {};
                    that.styleInfo.styles[details.toUpdate] = objectToUpdate;
                }

                let value = details.value;

                switch (details.prop) {
                    case 'backgroundColor':
                        objectToUpdate.fillColor = value;
                        break;
                    case 'color':
                        objectToUpdate.color = value;
                        break;
                    case 'fontSize':
                        objectToUpdate.fontSize = parseFloat(value);
                        break;
                    case 'fontStyle':
                        if (value === 'italic') {
                            objectToUpdate.italics = true;
                        }

                        break;
                    case 'fontWeight':
                        if (value === 'bold') {
                            objectToUpdate.bold = true;
                        }

                        break;
                    case 'textAlign':
                        objectToUpdate.alignment = value;
                        break;
                }
            }

            /**
             * Enables column wrapping when exporting to PDF.
             */
            wrapPDFColumns(docDefinition, mapping) {
                const that = this,
                    styleInfo = this.styleInfo,
                    maxPerPage = docDefinition.pageOrientation === 'portrait' ? 655 : 1155, // maximum of 655px (portrait) or 1155px (landscape) per A4 page
                    tables = [];
                let currentPage = 0;

                for (let i = 0; i < styleInfo.widths.length; i++) {
                    let currentWidth = styleInfo.widths[i],
                        numericWidth;

                    if (currentWidth === '*') {
                        numericWidth = maxPerPage / 6;
                    }
                    else if (typeof currentWidth === 'string' && currentWidth.indexOf('%') !== -1) {
                        numericWidth = Math.min(maxPerPage, Math.floor((parseFloat(currentWidth) / 100) * maxPerPage));

                        if (numericWidth === maxPerPage) {
                            currentWidth = '*';
                        }
                    }
                    else {
                        currentWidth = parseFloat(currentWidth);

                        if (currentWidth >= maxPerPage) {
                            numericWidth = maxPerPage
                            currentWidth = '*';
                        }
                        else {
                            numericWidth = currentWidth;
                            currentWidth /= 1.4;
                        }
                    }

                    if (tables[currentPage] === undefined) {
                        const body = [];

                        tables[currentPage] = {
                            body: body,
                            width: numericWidth,
                            widths: [currentWidth],
                            datafields: [that.datafields[i]]
                        };
                        mapping[i] = currentPage;
                        continue;
                    }

                    const table = tables[currentPage];

                    if (table.width + numericWidth > maxPerPage) {
                        currentPage++;
                        i--;
                        continue;
                    }

                    mapping[i] = currentPage;
                    table.width += numericWidth;
                    table.widths.push(currentWidth);
                    table.datafields.push(that.datafields[i]);
                }

                return tables;
            }

            /**
             * Gets the header content when exporting to PDF.
             */
            getPDFHeader(datafields, tables, mapping) {
                const that = this,
                    headerArray = [],
                    headerRows = that.headerRows,
                    headers = [],
                    headerDataFields = [];
                let result = [],
                    headerStructure, headerDataFieldStructure;

                if (that.complexHeader) {
                    headerStructure = that.complexHeader;
                    headerDataFieldStructure = that.complexDataFieldsHeader;
                }
                else {
                    headerStructure = [Object.values(that.data[0])];
                    headerDataFieldStructure = headerStructure;
                }

                for (let i = 0; i < headerRows; i++) {
                    const row = headerStructure[i],
                        rowDataField = headerDataFieldStructure[i];

                    for (let k = 0; k < row.length; k++) {
                        let tableIndex = mapping[k] || 0;

                        if (!headers[tableIndex]) {
                            headers[tableIndex] = [];
                            headerDataFields[tableIndex] = [];
                        }

                        if (!headers[tableIndex][i]) {
                            headers[tableIndex][i] = [];
                            headerDataFields[tableIndex][i] = [];
                        }

                        headers[tableIndex][i].push(row[k]);
                        headerDataFields[tableIndex][i].push(rowDataField[k]);
                    }
                }

                function processHeader(header, headerDataField, result, table) {
                    for (let j = 0; j < headerRows; j++) {
                        const row = header[j],
                            rowDataField = headerDataField[j];
                        const tableRow = [];

                        for (let k = 0; k < row.length; k++) {
                            const currentDataField = rowDataField[k];
                            let colspan = 1, rowspan = 1;

                            if ((rowDataField[k - 1] && rowDataField[k - 1] === currentDataField) ||
                                (headerDataField[j - 1] && (headerDataField[j - 1][k] === currentDataField))) {
                                tableRow.push({});
                                continue;
                            }

                            let iterator = k + 1;

                            while (rowDataField[iterator] && rowDataField[iterator] === rowDataField[iterator - 1]) {
                                colspan++;
                                iterator++;
                            }

                            iterator = j + 1;

                            while (headerDataField[iterator] && headerDataField[iterator][k] === currentDataField) {
                                rowspan++;
                                iterator++;
                            }

                            const datafield = j === headerRows - 1 || rowspan + j === headerRows ?
                                table.datafields[k] : null,
                                entry = {
                                    text: row[k], colSpan: colspan, rowSpan: rowspan
                                };

                            if (!datafield) {
                                entry.alignment = 'center';
                                entry.style = 'header';
                            }
                            else {
                                entry.style = ['header', 'header' + datafield];
                            }

                            tableRow.push(entry);
                        }

                        result.push(tableRow);
                    }
                }

                for (let i = 0; i < tables.length; i++) {
                    result = [];
                    processHeader(headers[i], headerDataFields[i], result, tables[i]);
                    headerArray.push(result);
                }

                return headerArray;
            }

            /**
             * Creates group header rows when exporting to PDF.
             */
            createGroupHeaderRow(tables, entryTemplate) {
                for (let i = 0; i < tables.length; i++) {
                    const entry = Object.assign({}, entryTemplate),
                        colspan = tables[i].datafields.length,
                        tableRow = [entry];

                    entry.colSpan = colspan;
                    tableRow.length = colspan;
                    tableRow.fill({}, 1, colspan - 1);

                    tables[i].body.push(tableRow);
                }
            }

            /**
             * Gets unique cell style when exporting to PDF.
             */
            getUniqueStylePDF(entry, datafield, row) {
                const style = this.style;

                function toHex(background) {
                    const parts = /rgba\((\d+),(\d+),(\d+)\,(\d*.\d+|\d+)\)/gi.exec(background.replace(/\s/g, ''));

                    if (parts === null) {
                        return background;
                    }

                    const r = parseFloat(parts[1]).toString(16).toUpperCase(),
                        g = parseFloat(parts[2]).toString(16).toUpperCase(),
                        b = parseFloat(parts[3]).toString(16).toUpperCase();

                    return '#' + ('0').repeat(2 - r.length) + r +
                        ('0').repeat(2 - g.length) + g +
                        ('0').repeat(2 - b.length) + b;
                }

                if (!style || !style.columns || !style.columns[datafield]) {
                    return;
                }

                const uniqueStyle = style.columns[datafield][row];

                if (!uniqueStyle) {
                    return;
                }

                entry.fillColor = toHex(uniqueStyle.background);
                entry.color = uniqueStyle.color.toLowerCase();
            }

            /**
             * Sets the indentation of a PDF cell.
             */
            setIndentation(entry, details) {
                if (details.j !== 0) {
                    return;
                }

                const that = this;

                if (that.actualHierarchy) {
                    const currentRecord = details.currentRecord;

                    if (currentRecord._expanded !== undefined) {
                        entry.marginLeft = 25 * (currentRecord._level - 1);
                        entry.text = that.collapseChar + ' ' + details.value;
                    }
                    else {
                        entry.marginLeft = 25 * (currentRecord._level - 1) + 6;
                    }
                }
                else if (details.outlineLevel > 1) {
                    entry.marginLeft = (details.outlineLevel - 1) * 7.5;
                }
            }

            addBodyImageToMap(image, rowIndex, col, columnsToExport) {
                const sheetIndex = 1;
                const { row, column } = image.position || {};
                const calculatedImage = image;
                if (columnsToExport) {
                    if (rowIndex !== null && col !== null && (!row || !column)) {
                        if (!image.position) {
                            image.position = {};
                        }
                        image.position = Object.assign({}, image.position, {
                            row: rowIndex,
                            column: columnsToExport.indexOf(col) + 1
                        });
                    }
                    calculatedImage.totalWidth = calculatedImage.width;
                    calculatedImage.totalHeight = calculatedImage.height;
                }
                this.buildImageMap({ imageToAdd: calculatedImage, idx: sheetIndex });
                let worksheetImageIdMap = this.worksheetImageIds.get(sheetIndex);
                if (!worksheetImageIdMap) {
                    worksheetImageIdMap = new Map();
                    this.worksheetImageIds.set(sheetIndex, worksheetImageIdMap);
                }
                const sheetImages = this.worksheetImages.get(sheetIndex);
                if (!sheetImages) {
                    this.worksheetImages.set(sheetIndex, [calculatedImage]);
                } else {
                    sheetImages.push(calculatedImage);
                }
                if (!worksheetImageIdMap.get(image.id)) {
                    worksheetImageIdMap.set(image.id, { index: worksheetImageIdMap.size, type: image.imageType });
                }
            }
            buildImageMap(params) {
                const { imageToAdd, idx } = params;
                const mappedImagesToSheet = this.images.get(imageToAdd.id);
                if (mappedImagesToSheet) {
                    const currentSheetImages = mappedImagesToSheet.find((currentImage) => currentImage.sheetId === idx);
                    if (currentSheetImages) {
                        currentSheetImages.image.push(imageToAdd);
                    } else {
                        mappedImagesToSheet.push({
                            sheetId: idx,
                            image: [imageToAdd]
                        });
                    }
                } else {
                    this.images.set(imageToAdd.id, [{ sheetId: idx, image: [imageToAdd] }]);
                    this.workbookImageIds.set(imageToAdd.id, { type: imageToAdd.imageType, index: this.workbookImageIds.size });
                }
            }

            createXmlPart(body, skipHeader) {
                const header = XmlFactory.createHeader({
                    encoding: "UTF-8",
                    standalone: "yes"
                });
                const xmlBody = XmlFactory.createXml(body);
                if (skipHeader) {
                    return xmlBody;
                }
                return `${header}${xmlBody}`;
            }

            generateWorksheetImages(zip, xl, data) {
                const that = this;

                this.images = new Map();
                this.worksheetImages = new Map();
                this.worksheetHeaderFooterImages = new Map();
                this.workbookImageIds = new Map();
                this.worksheetImageIds = new Map();
                let drawingIndex = 0;
                let imgCounter = 0;
                let imgIndex = 0;
                if (that.addImageToCell) {
                    let offset = that.headerContent ? that.headerContent.length : 0;
                    if (that.complexHeader) {
                        offset += that.complexHeader.length - 1;
                    }

                    for (let i = 1 + offset; i < data.length; i++) {
                        const row = data[i];
                        for (let j = 0; j < that.datafields.length; j++) {
                            const dataField = that.datafields[j];
                            let value = row[dataField];

                            if (value && Array.isArray(value)) {
                                for (let m = 0; m < value.length; m++) {
                                    const addedImage = that.addImageToCell(i + imgIndex++, dataField, value[m], value, row, m);
                                    if (addedImage) {
                                        row[dataField] = '';
                                        this.addBodyImageToMap(
                                            addedImage.image,
                                            1 + i,
                                            dataField,
                                            that.datafields
                                        );
                                    }
                                }
                                continue;
                            }

                            const addedImage = that.addImageToCell(i + imgIndex++, dataField, value, value, row, 0);
                            if (addedImage) {
                                row[dataField] = '';
                                if (addedImage.value && addedImage.value !== value) {
                                    row[dataField] = addedImage.value;
                                }
                                this.addBodyImageToMap(
                                    addedImage.image,
                                    1 + i,
                                    dataField,
                                    that.datafields
                                );
                            }
                        }
                    }

                    if (that.headerContent) {
                        for (let m = 0; m < that.headerContent.length; m++) {
                            const row = data[m];
                            for (let j = 0; j < that.datafields.length; j++) {
                                const dataField = that.datafields[j];
                                const value = row[dataField];

                                const addedImage = that.addImageToCell(m + 1, dataField, value, value, row, 0);
                                if (addedImage) {
                                    row[dataField] = '';
                                    this.addBodyImageToMap(
                                        addedImage.image,
                                        1 + m,
                                        dataField,
                                        that.datafields
                                    );
                                }
                            }
                        }
                    }

                    this.images.forEach((value) => {
                        const firstImage = value[0].image[0];
                        const { base64, imageType } = firstImage;
                        const ext = imageType === 'jpg' ? 'jpeg' : imageType;
                        // Function to convert a base64 string to a Blob
                        const base64ToBlob = (base64, mimeType) => {
                            if (!base64) {
                                base64 = '';
                            }
                            const byteCharacters = atob(base64);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            return new Blob([byteArray], { type: mimeType });
                        }

                        let imageBlob;
                        // Convert the Base64 string to a PNG Blob
                        if (base64 && Array.isArray(base64)) {
                            imageBlob = base64ToBlob(base64[0].split(',')[1], 'image/' + ext);
                        }
                        else {
                            imageBlob = base64ToBlob(base64.split(',')[1], 'image/' + ext);
                        }

                        zip.file(`xl/media/image${++imgCounter}.${ext}`, imageBlob, true);
                    });
                }

                let imageRelationCounter = 0;

                var INCH_TO_EMU = 9525;

                var pixelsToEMU = (value) => {
                    return Math.ceil(value * INCH_TO_EMU);
                };

                var getImageBoxSize = (image) => {
                    image.fitCell = !!image.fitCell || !image.width || !image.height;
                    const { position = {}, fitCell, width = 0, height = 0, totalHeight, totalWidth } = image;
                    const { offsetX = 0, offsetY = 0, row = 1, rowSpan = 1, column = 1, colSpan = 1 } = position;
                    return {
                        from: {
                            row: row - 1,
                            col: column - 1,
                            offsetX: pixelsToEMU(offsetX),
                            offsetY: pixelsToEMU(offsetY)
                        },
                        to: {
                            row: row - 1 + (fitCell ? 1 : rowSpan - 1),
                            col: column - 1 + (fitCell ? 1 : colSpan - 1),
                            offsetX: pixelsToEMU(width + offsetX),
                            offsetY: pixelsToEMU(height + offsetY)
                        },
                        height: pixelsToEMU(totalHeight || height),
                        width: pixelsToEMU(totalWidth || width)
                    };
                };
                var getPicture = (image, currentIndex, worksheetImageIndex, imageBoxSize) => {
                    return {
                        name: "xdr:pic",
                        children: [
                            getNvPicPr(image, currentIndex + 1),
                            getBlipFill(image, worksheetImageIndex + 1),
                            getSpPr(image, imageBoxSize)
                        ]
                    };
                };


                var getBlipFill = (image, index) => {
                    let blipChildren;
                    if (image.transparency) {
                        const transparency = Math.min(Math.max(image.transparency, 0), 100);
                        blipChildren = [
                            {
                                name: "a:alphaModFix",
                                properties: {
                                    rawMap: {
                                        amt: 1e5 - Math.round(transparency * 1e3)
                                    }
                                }
                            }
                        ];
                    }
                    if (image.recolor) {
                        if (!blipChildren) {
                            blipChildren = [];
                        }
                        switch (image.recolor.toLocaleLowerCase()) {
                            case "grayscale":
                                blipChildren.push({ name: "a:grayscl" });
                                break;
                            case "sepia":
                                blipChildren.push(getDuoTone({ color: "black" }, { color: "D9C3A5", tint: 50, saturation: 180 }));
                                break;
                            case "washout":
                                blipChildren.push({
                                    name: "a:lum",
                                    properties: {
                                        rawMap: {
                                            bright: "70000",
                                            contrast: "-70000"
                                        }
                                    }
                                });
                                break;
                            default:
                        }
                    }
                    return {
                        name: "xdr:blipFill",
                        children: [
                            {
                                name: "a:blip",
                                properties: {
                                    rawMap: {
                                        cstate: "print",
                                        "r:embed": `rId${index}`,
                                        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
                                    }
                                },
                                children: blipChildren
                            },
                            {
                                name: "a:stretch",
                                children: [
                                    {
                                        name: "a:fillRect"
                                    }
                                ]
                            }
                        ]
                    };
                };
                var getSpPr = (image, imageBoxSize) => {
                    const xfrm = {
                        name: "a:xfrm",
                        children: [
                            {
                                name: "a:off",
                                properties: {
                                    rawMap: {
                                        x: 0,
                                        y: 0
                                    }
                                }
                            },
                            {
                                name: "a:ext",
                                properties: {
                                    rawMap: {
                                        cx: imageBoxSize.width,
                                        cy: imageBoxSize.height
                                    }
                                }
                            }
                        ]
                    };
                    if (image.rotation) {
                        const rotation = image.rotation;
                        xfrm.properties = {
                            rawMap: {
                                rot: Math.min(Math.max(rotation, 0), 360) * 6e4
                            }
                        };
                    }
                    const prstGeom = {
                        name: "a:prstGeom",
                        properties: {
                            rawMap: {
                                prst: "rect"
                            }
                        },
                        children: [{ name: "a:avLst" }]
                    };
                    const ret = {
                        name: "xdr:spPr",
                        children: [xfrm, prstGeom]
                    };
                    return ret;
                };

                var getExt = (image) => {
                    const children = [
                        {
                            name: "a:ext",
                            properties: {
                                rawMap: {
                                    uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}"
                                }
                            },
                            children: [
                                {
                                    name: "a16:creationId",
                                    properties: {
                                        rawMap: {
                                            id: "{822E6D20-D7BC-2841-A643-D49A6EF008A2}",
                                            "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main"
                                        }
                                    }
                                }
                            ]
                        }
                    ];
                    const recolor = image.recolor && image.recolor.toLowerCase();
                    switch (recolor) {
                        case "grayscale":
                        case "sepia":
                        case "washout":
                            children.push({
                                name: "a:ext",
                                properties: {
                                    rawMap: {
                                        uri: "{C183D7F6-B498-43B3-948B-1728B52AA6E4}"
                                    }
                                },
                                children: [
                                    {
                                        name: "adec:decorative",
                                        properties: {
                                            rawMap: {
                                                val: "0",
                                                "xmlns:adec": "http://schemas.microsoft.com/office/drawing/2017/decorative"
                                            }
                                        }
                                    }
                                ]
                            });
                    }
                    return {
                        name: "a:extLst",
                        children
                    };
                };

                var getNvPicPr = (image, index) => ({
                    name: "xdr:nvPicPr",
                    children: [
                        {
                            name: "xdr:cNvPr",
                            properties: {
                                rawMap: {
                                    id: index,
                                    name: image.id,
                                    descr: image.altText != null ? image.altText : void 0
                                }
                            },
                            children: [getExt(image)]
                        },
                        {
                            name: "xdr:cNvPicPr",
                            properties: {
                                rawMap: {
                                    preferRelativeResize: "0"
                                }
                            },
                            children: [
                                {
                                    name: "a:picLocks"
                                }
                            ]
                        }
                    ]
                });

                var getAnchor = (name, imageAnchor) => ({
                    name: `xdr:${name}`,
                    children: [
                        {
                            name: "xdr:col",
                            textNode: imageAnchor.col.toString()
                        },
                        {
                            name: "xdr:colOff",
                            textNode: imageAnchor.offsetX.toString()
                        },
                        {
                            name: "xdr:row",
                            textNode: imageAnchor.row.toString()
                        },
                        {
                            name: "xdr:rowOff",
                            textNode: imageAnchor.offsetY.toString()
                        }
                    ]
                });

                var drawingFactory = {
                    getTemplate(config) {
                        const { sheetIndex } = config;
                        const sheetImages = that.worksheetImages.get(sheetIndex);
                        const sheetImageIds = that.worksheetImageIds.get(sheetIndex);
                        const children = sheetImages.map((image, idx) => {
                            const boxSize = getImageBoxSize(image);
                            return {
                                name: "xdr:twoCellAnchor",
                                properties: {
                                    rawMap: {
                                        editAs: "absolute"
                                    }
                                },
                                children: [
                                    getAnchor("from", boxSize.from),
                                    getAnchor("to", boxSize.to),
                                    getPicture(image, idx, sheetImageIds.get(image.id).index, boxSize),
                                    { name: "xdr:clientData" }
                                ]
                            };
                        });
                        return {
                            name: "xdr:wsDr",
                            properties: {
                                rawMap: {
                                    "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
                                    "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main",
                                }
                            },
                            children
                        };
                    }
                };

                const createDrawing = (sheetIndex) => {
                    return this.createXmlPart(drawingFactory.getTemplate({ sheetIndex }));
                }
                // enterprise-modules/excel-export/src/excelExport/files/ooxml/relationship.ts
                var relationshipFactory = {
                    getTemplate(config) {
                        const { Id, Type, Target } = config;
                        return {
                            name: "Relationship",
                            properties: {
                                rawMap: {
                                    Id,
                                    Type,
                                    Target
                                }
                            }
                        };
                    }
                };
                var relationship_default = relationshipFactory;

                // enterprise-modules/excel-export/src/excelExport/files/ooxml/relationships.ts
                var relationshipsFactory = {
                    getTemplate(c) {
                        const children = c.map((relationship) => relationship_default.getTemplate(relationship));
                        return {
                            name: "Relationships",
                            properties: {
                                rawMap: {
                                    xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
                                }
                            },
                            children
                        };
                    }
                };
                var relationships_default = relationshipsFactory;

                const createDrawingRel = (sheetIndex) => {
                    const worksheetImageIds = this.worksheetImageIds.get(sheetIndex) || [];
                    const XMLArr = [];
                    for (const [key, value] of worksheetImageIds) {
                        XMLArr.push({
                            Id: `rId${value.index + 1}`,
                            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                            Target: `../media/image${this.workbookImageIds.get(key).index + 1}.${value.type}`
                        });
                    }
                    return this.createXmlPart(relationshipsFactory.getTemplate(XMLArr));
                }

                var createExcelXmlDrawings = (sheetIndex, drawingIndex) => {
                    const drawingFolder = 'xl/drawings';
                    const drawingFileName = `${drawingFolder}/drawing${drawingIndex + 1}.xml`;
                    const relFileName = `${drawingFolder}/_rels/drawing${drawingIndex + 1}.xml.rels`;
                    zip.file(relFileName, createDrawingRel(sheetIndex));
                    zip.file(drawingFileName, createDrawing(sheetIndex));
                };

                for (let i = 1; i < data.length; i++) {
                    const hasImages = this.worksheetImages.has(i);
                    if (hasImages) {
                        createExcelXmlDrawings(i, imageRelationCounter);
                        drawingIndex = imageRelationCounter;
                        imageRelationCounter++;
                    }
                }

                const createRelationships = ({
                    drawingIndex,
                    tableIndex
                } = {}) => {
                    if (drawingIndex === void 0 && tableIndex === void 0) {
                        return '';
                    }
                    const config = [];

                    if (drawingIndex !== null && imgCounter > 0) {
                        config.push({
                            Id: `rId${config.length + 1}`,
                            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
                            Target: `../drawings/drawing${drawingIndex + 1}.xml`
                        });
                    }
                    if (tableIndex !== null) {
                        config.push({
                            Id: `rId${config.length + 1}`,
                            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table",
                            Target: `../tables/table1.xml`
                        });
                    }
                    const rs = relationships_default.getTemplate(config);
                    return this.createXmlPart(rs);
                }

                var tableIndex = this.exportAsTable ? 1 : 0;
                const worksheetRelFile = `xl/worksheets/_rels/sheet1.xml.rels`;
                zip.file(
                    worksheetRelFile,
                    createRelationships({
                        tableIndex,
                        drawingIndex
                    })
                );
            }
            /**
             * Exports to XLSX.
             */
            exportToXLSX(data, fileName, callback) {
                try {
                    JSZip;
                }
                catch (error) {
                    throw new Error('Missing reference to \'jszip.min.js\'.');
                }

                const that = this;
                let style = that.style;

                data = that.processGroupingInformation(data, true);
                that.data = data;
                that.getColumnsArray();

                that.complexHeaderMergedCells = [];

                if (that.complexHeaderMergeInfo) {
                    for (let cell in that.complexHeaderMergeInfo) {
                        if (Object.prototype.hasOwnProperty.call(that.complexHeaderMergeInfo, cell)) {
                            const currentEntry = that.complexHeaderMergeInfo[cell];

                            if (currentEntry.from[0] === currentEntry.to[0] &&
                                currentEntry.from[1] === currentEntry.to[1]) {
                                continue;
                            }

                            that.complexHeaderMergedCells.push({
                                from: that.columnsArray[currentEntry.from[1]] + (currentEntry.from[0] + 1),
                                to: that.columnsArray[currentEntry.to[1]] + (currentEntry.to[0] + 1)
                            });
                        }
                    }
                }

                that.getConditionalFormatting();

                if (!style) {
                    style = that.generateDefaultStyle(data);
                }

                // eslint-disable-next-line
                const zip = new JSZip(),
                    _rels = zip.folder('_rels'),
                    docProps = zip.folder('docProps'),
                    xl = zip.folder('xl');

                if (that.headerContent) {
                    const rows = that.headerContent;
                    const customRows = [];
                    for (let i = 0; i < rows.length; i++) {
                        const row = rows[i];
                        const cells = row.cells;
                        let customRow = {};
                        for (let j = 0; j < that.datafields.length; j++) {
                            const dataField = that.datafields[j];
                            if (cells[dataField]) {
                                customRow[dataField] = cells[dataField];
                            }
                            else {
                                customRow[dataField] = null;
                            }
                        }
                        customRows.push(customRow);
                    }
                    data = [...customRows, ...data];
                }

                if (that.footerContent) {
                    const rows = that.footerContent;
                    const customRows = [];
                    for (let i = 0; i < rows.length; i++) {
                        const row = rows[i];
                        const cells = row.cells;
                        let customRow = {};
                        for (let j = 0; j < that.datafields.length; j++) {
                            const dataField = that.datafields[j];
                            if (cells[dataField]) {
                                customRow[dataField] = cells[dataField];
                            }
                            else {
                                customRow[dataField] = null;
                            }
                        }
                        customRows.push(customRow);
                    }
                    data = [...data, ...customRows];
                }

                this.generateWorksheetImages(zip, xl, data);

                const sharedStrings = that.generateSharedStrings(data),
                    sharedStringsCollection = sharedStrings.collection,
                    sharedStringsXML = sharedStrings.xml,
                    stylesXML = that.generateStyles(style),
                    sheet1XML = that.groupBy ? that.generateSheet1WithGrouping(data, sharedStringsCollection) :
                        that.generateSheet1(data, sharedStringsCollection, that.datafields, that.columnsArray),
                    auxiliaryFiles = that.generateAuxiliaryFiles();


                let hasImages = false;
                const worksheetImages = this.worksheetImages.get(1);
                if (worksheetImages && worksheetImages.length) {
                    hasImages = true;
                }

                const xl_rels = xl.folder('_rels'),
                    theme = xl.folder('theme'),
                    worksheets = xl.folder('worksheets');

                if (hasImages) {
                    const media = xl.folder('media'),
                        drawings = xl.folder('drawings'),
                        drawingsRels = xl.folder('drawings/_rels');
                }

                _rels.file('.rels', auxiliaryFiles._relsRels);
                docProps.file('app.xml', auxiliaryFiles.docPropsAppXml);
                docProps.file('core.xml', auxiliaryFiles.docPropsCoreXml);
                xl_rels.file('workbook.xml.rels', auxiliaryFiles.xl_relsWorkbookXmlRels);
                theme.file('theme1.xml', auxiliaryFiles.xlThemeTheme1Xml);
                worksheets.file('sheet1.xml', sheet1XML);
                xl.file('sharedStrings.xml', sharedStringsXML);
                xl.file('styles.xml', stylesXML);
                xl.file('workbook.xml', auxiliaryFiles.xlWorkbookXml);
                zip.file('[Content_Types].xml', auxiliaryFiles.Content_TypesXml);


                if (this.spreadsheets) {
                    let sheetIndex = 2;
                    for (let s = 0; s < this.spreadsheets.length; s++) {
                        const sheet = this.spreadsheets[s];
                        const dataFields = sheet.dataFields;
                        let data = [...sheet.dataSource];

                        let header = [];
                        for (let i = 0; i < sheet.columns.length; i++) {
                            const column = sheet.columns[i];
                            if (typeof column === 'string') {
                                header[column] = column;
                            }
                            else {
                                header[column.dataField] = column.label || column.text;
                            }
                        }
                        data.splice(0, 0, header);
                        const sheet1XML = that.generateSheet1(data, sharedStringsCollection, dataFields, that.getColumnsArrayFromDataFields(dataFields), sheetIndex);
                        worksheets.file('sheet' + sheetIndex++ + '.xml', sheet1XML);
                    }
                }

                if (this.exportAsTable) {
                    const columnNames = Object.values(that.data[0]);

                    const createGUID = () => {
                        function part() {
                            return Math.floor((1 + Math.random()) * 0x10000)
                                .toString(16)
                                .substring(1);
                        }

                        return part() + part() + '-' + part() + '-' + part() + '-' + part() + '-' + part() + part() + part();
                    }

                    const dimensionEnd = (that.groupBy && that.groupBy.length) ? that.groupDimensionEnd : that.columnsArray[that.columnsArray.length - 1] + (data.length - 1);

                    let table = `<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" mc:Ignorable="xr xr3" id="1" name="Table1" displayName="Table1" ref="A${this.xlsxStartIndex}:${dimensionEnd}" totalsRowShown="0">
    <autoFilter ref="A${this.xlsxStartIndex}:${dimensionEnd}">`;
                    for (let i = 0; i < columnNames.length; i++) {
                        table += `<filterColumn colId="${i}" hiddenButton="0"/>
    `;
                    }
                    table += '</autoFilter>';
                    let tableColumns = `
    <tableColumns count="${columnNames.length}">`;

                    for (let i = 0; i < columnNames.length; i++) {
                        const column = columnNames[i];

                        tableColumns += `<tableColumn id="${i + 1}" name="${column}" dataCellStyle="Normal"/>
    `;
                    }
                    tableColumns += `
    </tableColumns>`;

                    table += tableColumns;
                    table += `
        <tableStyleInfo name="TableStyleLight1" showFirstColumn="0" showLastColumn="0" showRowStripes="1" showColumnStripes="0"/>
    </table>`;


                    const tables = xl.folder('tables');
                    tables.file('table1.xml', table);
                }

                zip.generateAsync({
                    type: 'blob',
                    mimeType:
                        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                })
                    .then(function (content) {
                        if (!fileName && callback) {
                            callback(content);
                        }
                        return that.downloadFile(content, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', fileName);
                    });

                delete that.conditionalFormattingXLSX;
                delete that.complexHeaderMergeInfo;
                delete that.defaultRowHeight;
                delete that.rowHeight;
            }

            /**
             * Processes grouping information.
             */
            processGroupingInformation(data, xlsx) {
                const that = this;

                if (!that.groupBy) {
                    return data;
                }

                let header;

                data = data.slice(0);

                if (that.exportHeader) {
                    if (xlsx && that.complexHeader) {
                        header = data.slice(0, that.complexHeader.length);
                        data.splice(0, that.complexHeader.length);
                    }
                    else {
                        header = [data[0]];
                        data.splice(0, 1);
                    }
                }

                if (data.length > 1) {
                    const getCompareFunction = function (a, knownDataType) {
                        // gets data type of column (not necessary if the Grid provides this information)
                        const dataType = knownDataType || typeof a;
                        let compareFunction;

                        switch (dataType) {
                            case 'string':
                                compareFunction = new Intl.Collator().compare;
                                break;
                            case 'number':
                                compareFunction = function (a, b) {
                                    return a - b;
                                };
                                break;
                            case 'boolean':
                            case 'bool':
                                compareFunction = function (a, b) {
                                    if (a === b) {
                                        return 0;
                                    }
                                    else if (a === false) {
                                        return -1;
                                    }
                                    else {
                                        return 1;
                                    }
                                };
                                break;
                            case 'date':
                            case 'time':
                            case 'dateTime':
                                if (a instanceof Date) {
                                    compareFunction = function (a, b) {
                                        return a.getTime() - b.getTime();
                                    };
                                }

                                break;
                            case 'object':
                                if (a instanceof Date) {
                                    compareFunction = function (a, b) {
                                        return a.getTime() - b.getTime();
                                    };
                                }


                                break;
                        }

                        return compareFunction;
                    }

                    const sortByMultipleColumns = function (dataSource, sortColumns, directions, customSortingCallback) {
                        if (!dataSource || !(Array.isArray(dataSource)) || dataSource.length === 0 ||
                            !sortColumns || Array.isArray(sortColumns) && sortColumns.length === 0) {
                            return;
                        }

                        if (typeof sortColumns === 'string') {
                            sortColumns = [sortColumns];
                        }

                        const directionCoefficients = [],
                            compareFunctions = [];

                        if (directions === undefined) {
                            directions = [];
                        }

                        for (let i = 0; i < sortColumns.length; i++) {
                            if (directions[i] === undefined || directions[i] === 'asc' || directions[i] === 'ascending') {
                                directionCoefficients[i] = 1;
                            }
                            else {
                                directionCoefficients[i] = -1;
                            }

                            compareFunctions[i] = getCompareFunction(dataSource[0][sortColumns[i]]);
                        }

                        if (customSortingCallback) {
                            customSortingCallback(dataSource, sortColumns, directions, compareFunctions);
                            return;
                        }

                        dataSource.sort(function (a, b) {
                            for (let i = 0; i < sortColumns.length; i++) {
                                const result = compareFunctions[i](a[sortColumns[i]], b[sortColumns[i]]);

                                if (result === 0) {
                                    if (sortColumns[i + 1]) {
                                        continue;
                                    }
                                    else if (a._index !== undefined) {
                                        // makes sorting stable
                                        return (a._index - b._index) * directionCoefficients[i];
                                    }

                                    return 0;
                                }

                                return result * directionCoefficients[i];
                            }
                        });
                    }

                    sortByMultipleColumns(data, that.groupBy);
                }

                if (header) {
                    data = header.concat(data);
                }

                that.getGroupLabels(data);

                return data;
            }

            /**
             * Exports to XML.
             */
            exportToXML(data, fileName) {
                const datafields = this.datafields.slice(0);
                let xmlContent = '<?xml version="1.0" encoding="UTF-8" ?>\n<table>\n';

                if (datafields.indexOf('rows') === -1) {
                    datafields.push('rows');
                }

                function recursion(records, indent) {
                    let content = '';

                    for (let i = 0; i < records.length; i++) {
                        const currentRecord = records[i];

                        content += indent + '<row>\n';

                        for (let j = 0; j < datafields.length; j++) {
                            const datafield = datafields[j];

                            if (datafield === 'rows') {
                                if (!currentRecord.rows) {
                                    continue;
                                }

                                content += `${indent}    <rows>\n${recursion(currentRecord.rows, indent + '        ')}${indent}    </rows>\n`;
                                continue;
                            }

                            content += indent + `    <${datafield}>${currentRecord[datafield]}</${datafield}>\n`;
                        }

                        content += indent + '</row>\n';
                    }

                    return content;
                }

                xmlContent += recursion(data, '    ') + '</table>';

                if (!fileName) {
                    return xmlContent;
                }

                return this.downloadFile(xmlContent, 'application/xml', fileName);
            }

            /**
             * Formats a date.
             */
            formatDate(value, format) {
                return value;
            }

            /**
             * Formats a number.
             */
            formatNumber(value, format) {
                return value;
            }

            /**
             * Generates auxiliary files necessary for XLSX.
             */
            generateAuxiliaryFiles() {
                // _rels\.rels
                const _relsRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>`;

                // docProps\app.xml
                const docPropsAppXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>`;

                // docProps\core.xml
                const now = new Date().toISOString(),
                    docPropsCoreXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator>Smart HTML Elements</dc:creator><cp:lastModifiedBy>Smart HTML Elements</cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">${now}</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">${now}</dcterms:modified></cp:coreProperties>`;

                // xl\_rels\workbook.xml.rels
                let relationShips = `<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>`;
                let relationShipId = 1;
                if (this.spreadsheets) {
                    for (let s = 0; s < this.spreadsheets.length; s++) {
                        const sheetId = 2 + s;
                        relationShipId++;
                        relationShips += `<Relationship Id="rId${sheetId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet${sheetId}.xml"/>`;
                    }
                }

                const xl_relsWorkbookXmlRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">${relationShips}<Relationship Id="rId${++relationShipId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId${++relationShipId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId${++relationShipId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/></Relationships>`;

                // xl\theme\theme1.xml
                const xlThemeTheme1Xml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=" Light"/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=" Light"/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=""/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=""/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>`;

                // xl\workbook.xml
                let sheets = '<sheet name="Sheet1" sheetId="1" r:id="rId1"/>';
                if (this.spreadsheets) {
                    for (let s = 0; s < this.spreadsheets.length; s++) {
                        const sheetId = 2 + s;
                        const sheet = this.spreadsheets[s];
                        sheets += `<sheet name="${sheet.label}" sheetId="${sheetId}" r:id="rId${sheetId}"/>`;
                    }
                }

                const xlWorkbookXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15 xr xr6 xr10 xr2" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr6="http://schemas.microsoft.com/office/spreadsheetml/2016/revision6" xmlns:xr10="http://schemas.microsoft.com/office/spreadsheetml/2016/revision10" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2"><fileVersion appName="xl" lastEdited="7" lowestEdited="7" rupBuild="20325"/><workbookPr defaultThemeVersion="166925"/><mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice Requires="x15"><x15ac:absPath url="C:\Users\jqwidgets\Desktop\" xmlns:x15ac="http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac"/></mc:Choice></mc:AlternateContent><xr:revisionPtr revIDLastSave="0" documentId="13_ncr:1_{0DEDCB6D-5403-4CD8-AAA5-59B6D238A8B6}" xr6:coauthVersionLast="34" xr6:coauthVersionMax="34" xr10:uidLastSave="{00000000-0000-0000-0000-000000000000}"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="19200" windowHeight="6950" xr2:uid="{0CB664E6-3800-4A88-B158-B46A682E7484}"/></bookViews><sheets>${sheets}</sheets><calcPr calcId="179021"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>`;

                const worksheetImages = this.worksheetImages.get(1);
                let drawings = '';
                if (worksheetImages && worksheetImages.length) {
                    drawings = '<Override PartName="/xl/drawings/drawing1.xml" ContentType="application/vnd.openxmlformats-officedocument.drawing+xml"/>';
                }

                let tables = '';
                if (this.exportAsTable) {
                    tables = '<Override PartName="/xl/tables/table1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"/>';
                }

                // [Content_Types].xml
                let sheetOverrides = `<Override PartName = "/xl/worksheets/sheet1.xml" ContentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />`;
                if (this.spreadsheets) {
                    for (let i = 0; i < this.spreadsheets.length; i++) {
                        sheetOverrides += `<Override PartName = "/xl/worksheets/sheet${i + 2}.xml" ContentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />`;
                    }
                }
                const Content_TypesXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="bin" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings"/><Default Extension="jpeg" ContentType="image/jpeg"/><Default Extension="png" ContentType="image/png"/><Default Extension="svg" ContentType="image/svg"/><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>${sheetOverrides}<Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>${tables}${drawings}<Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/><Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/></Types>`;

                return {
                    _relsRels: _relsRels,
                    docPropsAppXml: docPropsAppXml,
                    docPropsCoreXml: docPropsCoreXml,
                    xl_relsWorkbookXmlRels: xl_relsWorkbookXmlRels,
                    xlThemeTheme1Xml: xlThemeTheme1Xml,
                    xlWorkbookXml: xlWorkbookXml,
                    Content_TypesXml: Content_TypesXml
                };
            }

            /**
             * Generates default style object (for use in XLSX export).
             */
            generateDefaultStyle(data) {
                const that = this,
                    defaultStyle = {},
                    datafields = that.datafields,
                    firstRecord = that.complexHeader ? data[that.complexHeader.length] : data[+that.exportHeader];

                if (!firstRecord) {
                    return defaultStyle;
                }

                for (let i = 0; i < datafields.length; i++) {
                    const sampleValue = firstRecord[datafields[i]];

                    if (sampleValue instanceof Date) {
                        if (!defaultStyle.columns) {
                            defaultStyle.columns = [];
                        }

                        defaultStyle.columns[datafields[i]] = { format: 'd' };
                    }
                }

                return defaultStyle;
            }

            /**
             * Generates group row.
             */
            generateGroupRow(details) {
                const rowNumber = details.rowNumber,
                    from = 'A' + rowNumber,
                    recordXML = `        <row r="${rowNumber}" outlineLevel="${details.outlineLevel}" spans="1:${details.numberOfColumns}"${this.getCustomRowHeight(rowNumber - 1)} x14ac:dyDescent="0.45">
                <c r="${from}" t="s" s="0">
                    <v>${details.sharedStringIndex}</v>
                </c>
            </row>\n`;

                details.mergedCells.push({ from: from, to: this.columnsArray[details.numberOfColumns - 1] + rowNumber });

                return recordXML;
            }

            /**
             * Generates sharedStrings.xml.
             */
            generateSharedStrings(data) {
                const that = this,
                    datafields = that.datafields,
                    collection = [];
                let xml = '',
                    count = 0,
                    uniqueCount = 0;

                function addSharedString(currentValue) {
                    count++;

                    if (collection.indexOf(currentValue) === -1) {
                        uniqueCount++;
                        collection.push(currentValue);

                        currentValue = currentValue.replace(/&(?!amp;)/g, '&amp;');
                        currentValue = currentValue.replace(/'/g, '&apos;');
                        currentValue = currentValue.replace(/"/g, '&quot;');
                        currentValue = currentValue.replace(/>/g, '&gt;');
                        currentValue = currentValue.replace(/</g, '&lt;');

                        xml += `<si><t>${currentValue}</t></si>`;
                    }
                }

                const addSharedStrings = (data, datafields) => {
                    for (let i = 0; i < data.length; i++) {
                        const currentRecord = data[i];

                        for (let j = 0; j < datafields.length; j++) {
                            let currentValue = currentRecord[datafields[j]];

                            if (currentValue === null && !that.allowNull) {
                                currentValue = '';
                            }

                            if (typeof currentValue !== 'string') {
                                continue;
                            }

                            addSharedString(currentValue);
                        }
                    }
                }

                addSharedStrings(data, datafields);

                if (that.spreadsheets) {
                    for (let i = 0; i < that.spreadsheets.length; i++) {
                        const sheet = that.spreadsheets[i];
                        const datafields = sheet.dataFields;
                        let data = [...sheet.dataSource];

                        let header = [];
                        for (let i = 0; i < sheet.columns.length; i++) {
                            const column = sheet.columns[i];
                            if (typeof column === 'string') {
                                header[column] = column;
                            }
                            else {
                                header[column.dataField] = column.label;
                            }
                        }
                        data.splice(0, 0, header);
                        addSharedStrings(data, datafields);
                    }

                }

                if (that.groupLabels) {
                    for (let i = 0; i < that.groupLabels.length; i++) {
                        addSharedString(that.groupLabels[i]);
                    }
                }

                xml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="${count}" uniqueCount="${uniqueCount}">${xml}</sst>`;

                return { collection: collection, xml: xml };
            }


            /**
             * Generates sheet1.xml.
             */
            generateSheet1(data, sharedStrings, datafields, columnsArray, sheetIndex) {
                const that = this,
                    numberOfColumns = columnsArray.length,
                    numberOfRows = data.length,
                    dimensionEnd = columnsArray[numberOfColumns - 1] + numberOfRows,
                    autoFilter = that.getFilters(),
                    mergedCells = [].concat(that.complexHeaderMergedCells);
                let rIdCounter = 0;

                const addDrawingRel = (currentSheet2) => {
                    let xmlContent = '';

                    const worksheetImages = this.worksheetImages.get(currentSheet2);
                    if (worksheetImages && worksheetImages.length) {
                        xmlContent += `<drawing r:id="rId${++rIdCounter}"/>`;
                    }
                    return xmlContent;
                };
                const addTableRel = () => {
                    if (!that.exportAsTable) {
                        return '';
                    }

                    let xmlContent = `<tableParts count="1">
                    <tablePart r:id="rId${++rIdCounter}"/>
                </tableParts>`;

                    return xmlContent;
                };

                const freezeHeader = that.freezeHeader ? `<sheetView rightToLeft="0" workbookViewId="0">
             <pane state="frozen" topLeftCell="A${that.xlsxStartIndex + 1}" ySplit="${that.xlsxStartIndex}"/>
            </sheetView>` : '';

                let cols = that.getCustomColumnWidths(columnsArray);

                if (sheetIndex > 1) {
                    let colsString = '<cols>';
                    for (let i = 0; i < columnsArray.length; i++) {
                        colsString += '<col min="1" max="1" width="25" hidden="0" bestFit="0" customWidth="1"/>';
                    }
                    colsString += '</cols>';

                    cols = colsString;
                }

                const tabSelected = sheetIndex <= 1 ? 'tabSelected="1"' : '';

                let xmlContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac xr xr2 xr3" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" xr:uid="{7F25248B-C640-4C64-AD47-C0EA0E5D90D0}">
        <sheetPr filterMode="${autoFilter !== ''}" />
        <dimension ref="A1:${dimensionEnd}" />
        <sheetViews>
            <sheetView ${tabSelected} workbookViewId="0" />
            ${freezeHeader}
        </sheetViews>
        <sheetFormatPr defaultRowHeight="14.5" x14ac:dyDescent="0.35" />${cols}
        <sheetData>\n`;

                function r(col, row) {
                    return columnsArray[col] + row;
                }

                for (let i = 0; i <= data.length; i++) {
                    const currentRecord = data[i],
                        rowNumber = i + 1;
                    let collapsed = '';

                    if (that.actualHierarchy) {
                        const previousRecord = data[i - 1];

                        if (previousRecord && previousRecord._collapsed &&
                            (!currentRecord || previousRecord._level > currentRecord._level)) {
                            collapsed = ' collapsed="true"';
                        }
                    }

                    if (i === data.length) {
                        if (collapsed) {
                            xmlContent += `        <row r="${rowNumber}" outlineLevel="${Math.max(data[i - 1]._level - 2, 0)}" hidden="false" collapsed="true" />\n`;
                        }

                        break;
                    }

                    let recordXML = `        <row r="${rowNumber}"${that.getOutlineLevel(currentRecord)} hidden="${currentRecord._hidden || currentRecord._collapsed || false}"${collapsed} spans="1:${numberOfColumns}"${that.getCustomRowHeight(rowNumber - 1)} customHeight="1" x14ac:dyDescent="0.45">\n`;

                    for (let j = 0; j < datafields.length; j++) {
                        const s = that.getXLSXCellStyle(r(j, rowNumber));

                        recordXML += that.getActualCellData(currentRecord[datafields[j]], { r: r(j, rowNumber), s: s }, sharedStrings, rowNumber, datafields[j]);
                    }

                    recordXML += '        </row>\n';
                    xmlContent += recordXML;
                }

                if (that.headerContent) {
                    for (let m = 0; m < that.headerContent.length; m++) {
                        const row = that.headerContent[m];
                        if (row.style && row.style.mergeAcross) {
                            mergedCells.push({
                                from: 'A' + (m + 1),
                                to: columnsArray[numberOfColumns - 1] + (m + 1)
                            });
                        }
                    }
                }
                if (that.footerContent) {
                    for (let m = 0; m < that.footerContent.length; m++) {
                        const row = that.footerContent[m];
                        if (row.style && row.style.mergeAcross) {
                            mergedCells.push({
                                from: 'A' + (data.length - m),
                                to: columnsArray[numberOfColumns - 1] + (data.length - m)
                            });
                        }
                    }
                }
                xmlContent += `    </sheetData>${that.conditionalFormattingXLSX.conditions}${autoFilter}${that.getMergedCells(mergedCells)}
        <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />
        <pageSetup paperSize="9" orientation="portrait" r:id="rId1" />
        ${addDrawingRel(sheetIndex ? sheetIndex : 1)}
        ${addTableRel()}
    </worksheet>`;



                return xmlContent;
            }

            /**
             * Generates sheet1.xml with grouping.
             */
            generateSheet1WithGrouping(data, sharedStrings) {
                const that = this,
                    numberOfColumns = that.columnsArray.length,
                    numberOfRows = data.length,
                    dimensionEnd = that.columnsArray[numberOfColumns - 1] + numberOfRows,
                    datafields = that.datafields,
                    mergedCells = [].concat(that.complexHeaderMergedCells);
                let rIdCounter = 0;

                const addDrawingRel = (currentSheet2) => {
                    let xmlContent = '';

                    const worksheetImages = this.worksheetImages.get(currentSheet2);
                    if (worksheetImages && worksheetImages.length) {
                        xmlContent += `<drawing r:id="rId${++rIdCounter}"/>`;
                    }
                    return xmlContent;
                };
                const addTableRel = () => {
                    if (!that.exportAsTable) {
                        return '';
                    }

                    let xmlContent = `<tableParts count="1">
                    <tablePart r:id="rId${++rIdCounter}"/>
                </tableParts>`;

                    return xmlContent;
                };
                const freezeHeader = that.freezeHeader ? `<sheetView rightToLeft="0" workbookViewId="0">
             <pane state="frozen" topLeftCell="A${that.xlsxStartIndex + 1}" ySplit="${that.xlsxStartIndex}"/>
            </sheetView>` : '';
                let xmlContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac xr xr2 xr3" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" xr:uid="{7F25248B-C640-4C64-AD47-C0EA0E5D90D0}">
        <dimension ref="A1:${dimensionEnd}" />
        <sheetViews>
            <sheetView tabSelected="1" workbookViewId="0" />
            ${freezeHeader}
        </sheetViews>
        <sheetFormatPr defaultRowHeight="14.5" x14ac:dyDescent="0.35" />${that.getCustomColumnWidths()}
        <sheetData>\n`,
                    rowNumberCorrection = 0,
                    groupsHandled = [];

                function r(col, row) {
                    return that.columnsArray[col] + row;
                }

                mainLoop:
                for (let i = 0; i < data.length; i++) {
                    const currentRecord = data[i],
                        rowNumber = i + 1 + rowNumberCorrection;
                    let outlineLevel = 0,
                        outlineXML = '';

                    if (!that.exportHeader ||
                        (!that.complexHeader && i !== 0) ||
                        (that.complexHeader && i >= that.complexHeader.length)) {
                        let groupId = '';

                        for (let k = 0; k < that.groupBy.length; k++) {
                            const datafield = that.groupBy[k],
                                currentGroup = currentRecord[datafield],
                                currentGroupLabel = that.groups[datafield][currentGroup];

                            groupId += currentGroup;

                            if (groupsHandled.indexOf(groupId) === -1) {
                                let sharedStringIndex = sharedStrings.indexOf(currentGroupLabel);

                                xmlContent += that.generateGroupRow({
                                    rowNumber: rowNumber,
                                    outlineLevel: outlineLevel,
                                    numberOfColumns: numberOfColumns,
                                    sharedStringIndex: sharedStringIndex,
                                    mergedCells: mergedCells
                                });
                                groupsHandled.push(groupId);
                                i--;
                                rowNumberCorrection++;
                                continue mainLoop;
                            }

                            outlineLevel++;
                        }

                        outlineXML = ` outlineLevel="${outlineLevel}"`;
                    }

                    let recordXML = `        <row r="${rowNumber}"${outlineXML} spans="1:${numberOfColumns}"${that.getCustomRowHeight(rowNumber - 1)} customHeight="1" x14ac:dyDescent="0.45">\n`;

                    for (let j = 0; j < datafields.length; j++) {
                        const s = that.getXLSXCellStyle(r(j, i + 1));

                        recordXML += that.getActualCellData(currentRecord[datafields[j]], { r: r(j, rowNumber), s: s }, sharedStrings, rowNumber, datafields[j]);
                    }

                    recordXML += '        </row>\n';
                    xmlContent += recordXML;
                }

                xmlContent += `    </sheetData>${!that.exportAsTable ? that.getMergedCells(mergedCells) : ''}
        <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />
        <pageSetup paperSize="9" orientation="portrait" r:id="rId1" />
        ${addDrawingRel(1)}
        ${addTableRel()}
    </worksheet>`;

                that.groupDimensionEnd = that.columnsArray[numberOfColumns - 1] + (numberOfRows + rowNumberCorrection);
                that.groupRowsCount = numberOfRows + rowNumberCorrection;
                return xmlContent;
            }

            isFormula(value) {
                if (value === null) {
                    return false;
                }
                return this.autoConvertFormulas && value.toString().startsWith('=');
            }

            /**
             * Gets actual spreadsheet cell data.
             */
            getActualCellData(currentValue, details, sharedStrings) {
                const r = details.r,
                    s = details.s || ' s="0"';

                if (currentValue === null && !this.allowNull) {
                    currentValue = '';
                }

                if (currentValue && this.isFormula(currentValue)) {
                    return `            <c r="${r}" t="s"${s}>
                    <f>${currentValue.slice(1)}</f>
                </c>\n`;
                }

                if (typeof currentValue === 'string') {
                    return `            <c r="${r}" t="s"${s}>
                    <v>${sharedStrings.indexOf(currentValue)}</v>
                </c>\n`;
                }

                if (typeof currentValue === 'boolean') {
                    return `            <c r="${r}" t="b"${s}>
                    <v>${+currentValue}</v>
                </c>\n`;
                }

                if (currentValue instanceof Date) {
                    //    const timeZoneOffset = currentValue.getTimezoneOffset() * 1000 * 60;
                    //    const excelDate = (currentValue.getTime() + this.timeBetween1900And1970 - timeZoneOffset) / (1000 * 60 * 60 * 24) + 3;

                    const timeBetweenJSandExcel = 2 + Math.round(this.timeBetween1900And1970 / (1000 * 60 * 60 * 24));
                    const excelDateTime = timeBetweenJSandExcel + ((currentValue.getTime() - (currentValue.getTimezoneOffset() * 60 * 1000)) / (1000 * 60 * 60 * 24));

                    return `            <c r="${r}"${s}>
                    <v>${excelDateTime}</v>
                </c>\n`;
                }

                // numeric cells
                return `            <c r="${r}"${s}>
                    <v>${currentValue}</v>
                </c>\n`;
            }

            /**
             * Gets column labels.
             */
            getColumnsArray() {
                const that = this,
                    numberOfColumns = that.datafields.length,
                    columnsCollection = [];

                function getIterator(i) {
                    if (i < 26) {
                        return '';
                    }

                    return String.fromCharCode(64 + Math.floor(i / 26));
                }

                for (let i = 0; i < numberOfColumns; i++) {
                    columnsCollection.push(getIterator(i) + String.fromCharCode(65 + (i < 26 ? i : i % 26)));
                }

                that.columnsArray = columnsCollection;
            }

            /**
           * Gets column labels.
           */
            getColumnsArrayFromDataFields(datafields) {
                const that = this,
                    numberOfColumns = datafields.length,
                    columnsCollection = [];

                function getIterator(i) {
                    if (i < 26) {
                        return '';
                    }

                    return String.fromCharCode(64 + Math.floor(i / 26));
                }

                for (let i = 0; i < numberOfColumns; i++) {
                    columnsCollection.push(getIterator(i) + String.fromCharCode(65 + (i < 26 ? i : i % 26)));
                }

                return columnsCollection;
            }

            /**
             * Gets column style.
             */
            getColumnStyle() {
                const that = this,
                    style = that.style;

                if (!style) {
                    return `        .header { border: 1px solid black; padding: 5px; }
            .column { border: 1px solid black; padding: 5px; }
            .group { background-color: #FFFFFF; color: #000000; font-weight: bold; }`;
                }

                let styles;

                if (style.removeDefault) {
                    styles = {
                        header: '',
                        column: '',
                        group: ''
                    };
                }
                else {
                    styles = {
                        header: 'border: 1px solid black; padding: 5px; ',
                        column: 'white-space: nowrap; overflow: hidden; border: 1px solid black; padding: 5px; ',
                        group: 'background-color: #FFFFFF; color: #000000; font-weight: bold; '
                    };
                }

                const sampleRecord = that.data[0];
                let generatedStyle = '';

                const headerDefinition = style.header || {};

                for (let prop in headerDefinition) {
                    if (!Object.prototype.hasOwnProperty.call(headerDefinition, prop)) {
                        continue;
                    }

                    const value = headerDefinition[prop];

                    if (sampleRecord[prop]) {
                        if (!styles['header' + prop]) {
                            styles['header' + prop] = '';
                        }

                        for (let columnProp in value) {
                            if (Object.prototype.hasOwnProperty.call(value, columnProp)) {
                                const css = window.jqxToDash(columnProp) + ': ' + value[columnProp] + '; ';

                                styles['header' + prop] += css;

                                if (columnProp === 'width') {
                                    if (!styles['column' + prop]) {
                                        styles['column' + prop] = '';
                                    }

                                    styles['column' + prop] += css;
                                }
                            }
                        }

                        continue;
                    }

                    if (prop === 'height' && that.complexHeader) {
                        styles.header += 'height: ' + parseInt(headerDefinition[prop], 10) / that.complexHeader.length + 'px; ';
                    }
                    else {
                        styles.header += window.jqxToDash(prop) + ': ' + headerDefinition[prop] + '; ';
                    }
                }

                const columnsDefinition = style.columns || {};

                for (let prop in columnsDefinition) {
                    if (!Object.prototype.hasOwnProperty.call(columnsDefinition, prop)) {
                        continue;
                    }

                    const value = columnsDefinition[prop];

                    if (sampleRecord[prop]) {
                        if (!styles['column' + prop]) {
                            styles['column' + prop] = '';
                        }

                        for (let columnProp in value) {
                            if (isNaN(columnProp) && Object.prototype.hasOwnProperty.call(value, columnProp) && columnProp !== 'format') {
                                styles['column' + prop] += window.jqxToDash(columnProp) + ': ' + value[columnProp] + '; ';
                            }
                        }

                        continue;
                    }

                    styles.column += window.jqxToDash(prop) + ': ' + value + '; ';
                }

                for (let prop in styles) {
                    if (Object.prototype.hasOwnProperty.call(styles, prop)) {
                        generatedStyle += `        .${prop} { ${styles[prop]}}\n`;
                    }
                }

                if (style.custom) {
                    generatedStyle += `${style.custom}\n`;
                }

                return generatedStyle;
            }

            /**
             * Gets custom column widths.
             */
            getCustomColumnWidths(columnsArray) {
                const that = this;

                if (columnsArray !== that.columnsArray) {
                    return '';
                }

                if (!that.style || !that.columnWidth || that.columnWidth.length === 0) {
                    return '';
                }

                let xml = '\n    <cols>\n';

                for (let i = 0; i < that.columnWidth.length; i++) {
                    let width = that.columnWidth[i];

                    if (width !== undefined) {
                        width = Math.round(parseFloat(width)) / 7;
                        xml += `        <col min="${i + 1}" max="${i + 1}" width="${width}" customWidth="1" />\n`;
                    }
                }

                xml += '    </cols>';

                return xml;
            }

            /**
             * Returns customFilter tag.
             */
            getCustomFilter(value, condition) {
                let operator = 'equal',
                    val;

                if (value instanceof Date) {
                    value = (value.getTime() + this.timeBetween1900And1970) / 86400000 + 2;
                }

                condition = condition.toUpperCase();

                switch (condition) {
                    case 'EMPTY':
                        val = '';
                        break;
                    case 'NOT_EMPTY':
                        val = '';
                        operator = 'notEqual';
                        break;
                    case 'CONTAINS':
                    case 'CONTAINS_CASE_SENSITIVE':
                        val = `*${value}*`;
                        break;
                    case 'DOES_NOT_CONTAIN':
                    case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                        val = `*${value}*`;
                        operator = 'notEqual';
                        break;
                    case 'STARTS_WITH':
                    case 'STARTS_WITH_CASE_SENSITIVE':
                        val = `${value}*`;
                        break;
                    case 'ENDS_WITH':
                    case 'ENDS_WITH_CASE_SENSITIVE':
                        val = `*${value}`;
                        break;
                    case 'EQUAL':
                    case 'EQUAL_CASE_SENSITIVE':
                        val = value;
                        break;
                    case 'NULL':
                        val = null;
                        break;
                    case 'NOT_NULL':
                        val = null;
                        operator = 'notEqual';
                        break;
                    case 'NOT_EQUAL':
                        val = value;
                        operator = 'notEqual';
                        break;
                    case 'LESS_THAN':
                        val = value;
                        operator = 'lessThan';
                        break;
                    case 'LESS_THAN_OR_EQUAL':
                        val = value;
                        operator = 'lessThanOrEqual';
                        break;
                    case 'GREATER_THAN':
                        val = value;
                        operator = 'greaterThan';
                        break;
                    case 'GREATER_THAN_OR_EQUAL':
                        val = value;
                        operator = 'greaterThanOrEqual';
                        break;
                }

                return `                <customFilter val="${val}" operator="${operator}"/>\n`;
            }

            /**
             * Gets custom row height.
             */
            getCustomRowHeight(row) {
                const that = this;

                if (that.style) {
                    return that.rowHeight[row] || that.defaultRowHeight || '';
                }

                return '';
            }

            /**
             * Gets datafields.
             */
            getDatafields(data) {
                const that = this,
                    sampleRecord = data[0],
                    datafields = [];

                for (let prop in sampleRecord) {
                    if (Object.prototype.hasOwnProperty.call(sampleRecord, prop) && prop.charAt(0) !== '_') {
                        datafields.push(prop);
                    }
                }

                that.datafields = datafields;
            }

            /**
             * Returns autoFilter XML.
             */
            getFilters() {
                const that = this,
                    filterBy = that.filterBy;

                if (!filterBy) {
                    return '';
                }

                let xml = '';

                for (let datafield in filterBy) {
                    if (Object.prototype.hasOwnProperty.call(filterBy, datafield)) {
                        const colId = that.datafields.indexOf(datafield);

                        if (colId === -1) {
                            continue;
                        }

                        const filterDetails = filterBy[datafield],
                            filters = filterDetails.filters;

                        xml += `        <filterColumn colId="${colId}">
                <customFilters and="${!filterDetails.operator}">\n`;

                        for (let i = 0; i < filters.length; i++) {
                            xml += that.getCustomFilter(filters[i].value, filters[i].condition);
                        }

                        xml += `            </customFilters>
            </filterColumn>`;
                    }
                }

                if (!xml) {
                    return '';
                }

                xml = `\n    <autoFilter ref="A1:${that.columnsArray[that.columnsArray.length - 1] + that.data.length}">\n${xml}\n    </autoFilter>`;
                return xml;
            }

            /**
             * Gets group labels based on data.
             */
            getGroupLabels(data) {
                const that = this,
                    startIndex = that.xlsxStartIndex !== undefined ? that.xlsxStartIndex : +that.exportHeader,
                    groups = {},
                    groupLabels = [];

                for (let i = startIndex; i < data.length; i++) {
                    const currentRecord = data[i];

                    for (let j = 0; j < that.groupBy.length; j++) {
                        const datafield = that.groupBy[j],
                            currentValue = currentRecord[datafield];
                        let group = groups[datafield];

                        if (group === undefined) {
                            groups[datafield] = {};
                            group = groups[datafield];
                        }

                        if (group[currentValue] === undefined) {
                            group[currentValue] = (that.exportHeader ? data[startIndex - 1][datafield] : datafield) + ': ' + currentValue;
                            groupLabels.push(group[currentValue]);
                        }
                    }
                }

                that.groups = groups;
                that.groupLabels = groupLabels;
            }

            /**
             * Gets the header content when exporting to HTML.
             */
            getHTMLHeader(datafields, data) {
                const that = this;
                let header = '\n        <thead>\n';

                if (!that.complexHeader) {
                    header += '            <tr>\n';

                    for (let j = 0; j < datafields.length; j++) {
                        const datafield = datafields[j];

                        header += `                <th class="header header${datafield}">${data[0][datafield]}</th>\n`;
                    }

                    header += '            </tr>\n        </thead>';
                    return header;
                }

                for (let j = 0; j < that.complexDataFieldsHeader.length; j++) {
                    const row = that.complexDataFieldsHeader[j];

                    header += '            <tr>\n';

                    for (let k = 0; k < row.length; k++) {
                        const currentLabel = row[k];
                        let colspan = 1, rowspan = 1;

                        if ((row[k - 1] && row[k - 1] === currentLabel) ||
                            (that.complexDataFieldsHeader[j - 1] && (that.complexDataFieldsHeader[j - 1][k] === currentLabel))) {
                            continue;
                        }

                        let iterator = k + 1;

                        while (row[iterator] && row[iterator] === row[iterator - 1]) {
                            colspan++;
                            iterator++;
                        }

                        iterator = j + 1;

                        while (that.complexDataFieldsHeader[iterator] && that.complexDataFieldsHeader[iterator][k] === currentLabel) {
                            rowspan++;
                            iterator++;
                        }

                        const datafield = j === that.complexHeader.length - 1 || rowspan + j === that.complexHeader.length ?
                            ' header' + datafields[k] : '';

                        header += `                <th class="header${datafield}" colspan="${colspan}" rowspan="${rowspan}">${that.complexHeader[j][k]}</th>\n`;
                    }

                    header += '            </tr>\n';
                }

                header += '        </thead>';
                return header;
            }

            /**
             * Gets conditional formatting XML.
             */
            getConditionalFormatting() {
                const that = this,
                    conditionalFormatting = that.conditionalFormatting;

                if (!conditionalFormatting) {
                    that.conditionalFormattingXLSX = { conditions: '', styles: '' };
                    return;
                }

                const dxfCodes = [];
                let conditionsXml = '',
                    stylesXml = '';

                for (let i = conditionalFormatting.length - 1; i >= 0; i--) {
                    const columnFormat = conditionalFormatting[i],
                        columnLetter = that.columnsArray[that.datafields.indexOf(columnFormat.column)],
                        startCell = columnLetter + (that.xlsxStartIndex + 1),
                        sqref = startCell + ':' + columnLetter + (that.data.length),
                        dxfCode = columnFormat.background + columnFormat.color,
                        attr = that.getConditionalAttributes(columnFormat, startCell);
                    let dxfId = dxfCodes.indexOf(dxfCode);

                    if (dxfId === -1) {
                        const newDxf = `        <dxf>
                <font>
                    <b val="0"/>
                    <i val="0"/>
                    <color rgb="${columnFormat.color === 'White' ? 'FFFFFFFF' : 'FF000000'}"/>
                    <sz val="10"/>
                </font>
                <fill>
                    <patternFill>
                        <bgColor rgb="${that.toARGB(columnFormat.background)}"/>
                    </patternFill>
                </fill>
            </dxf>\n`;

                        stylesXml += newDxf;
                        dxfId = dxfCodes.length;
                        dxfCodes.push(dxfCode);
                    }

                    conditionsXml += `    <conditionalFormatting sqref="${sqref}">
            <cfRule dxfId="${dxfId}" text="${attr.text}" rank="${attr.rank}" percent="${attr.percent}" bottom="${attr.bottom}" equalAverage="${attr.equalAverage}" aboveAverage="${attr.aboveAverage}"${attr.operator}${attr.timePeriod} priority="${i + 2}" type="${attr.type}">
    ${attr.formula}        </cfRule>
        </conditionalFormatting>\n`;
                }

                stylesXml = `    <dxfs count="${dxfCodes.length}">\n${stylesXml}    </dxfs>`;

                that.conditionalFormattingXLSX = { conditions: conditionsXml, styles: stylesXml };
            }

            /**
             * Gets conditional formatting XML attributes.
             */
            getConditionalAttributes(columnFormat, startCell) {
                let condition = columnFormat.condition,
                    comparator = columnFormat.comparator,
                    text = '',
                    rank = 0,
                    percent = 0,
                    bottom = 0,
                    equalAverage = 0,
                    aboveAverage = 0,
                    operator = '',
                    timePeriod = '',
                    type = '',
                    formula = '';

                switch (condition) {
                    case 'equal':
                        operator = 'equal';
                        type = 'cellIs';
                        formula = `            <formula>${comparator}</formula>\n`;
                        break;
                    case 'lessThan':
                        operator = 'lessThan';
                        type = 'cellIs';
                        formula = `            <formula>${comparator}</formula>\n`;
                        break;
                    case 'greaterThan':
                        operator = 'greaterThan';
                        type = 'cellIs';
                        formula = `            <formula>${comparator}</formula>\n`;
                        break;
                    case 'notEqual':
                        operator = 'notEqual';
                        type = 'cellIs';
                        formula = `            <formula>${comparator}</formula>\n`;
                        break;
                    case 'between':
                        operator = 'between';
                        type = 'cellIs';
                        formula = `            <formula>${columnFormat.min}</formula>
                <formula>${columnFormat.max}</formula>\n`;
                        break;
                    case 'duplicate':
                        type = 'duplicateValues';
                        formula = '            <formula>0</formula>\n';
                        break;
                    case 'topNItems':
                        rank = comparator;
                        type = 'top10';
                        break;
                    case 'bottomNItems':
                        rank = comparator;
                        bottom = 1;
                        type = 'top10';
                        break;
                    case 'topNPercent':
                        rank = comparator;
                        percent = 1;
                        type = 'top10';
                        break;
                    case 'bottomNPercent':
                        rank = comparator;
                        percent = 1;
                        bottom = 1;
                        type = 'top10';
                        break;
                    case 'aboveAverage':
                        aboveAverage = 1;
                        type = 'aboveAverage';
                        formula = '            <formula>0</formula>\n';
                        break;
                    case 'belowAverage':
                        type = 'aboveAverage';
                        formula = '            <formula>0</formula>\n';
                        break;
                    case 'contains':
                        text = comparator;
                        operator = 'containsText';
                        type = 'containsText';
                        formula = `            <formula>NOT(ISERROR(SEARCH("${comparator}",${startCell})))</formula>\n`;
                        break;
                    case 'doesNotContain':
                        text = comparator;
                        operator = 'notContains';
                        type = 'notContainsText';
                        formula = `            <formula>ISERROR(SEARCH("${comparator}",${startCell}))</formula>\n`;
                        break;
                    case 'dateOccur':
                        timePeriod = ` timePeriod="${comparator}"`;
                        type = 'timePeriod';
                        break;
                }

                if (operator) {
                    operator = ` operator="${operator}" `;
                }

                return {
                    text: text,
                    rank: rank,
                    percent: percent,
                    bottom: bottom,
                    equalAverage: equalAverage,
                    aboveAverage: aboveAverage,
                    operator: operator,
                    timePeriod: timePeriod,
                    type: type,
                    formula: formula
                }
            }

            /**
             * Gets merged cells XML.
             */
            getMergedCells(mergedCells) {
                const that = this;

                let mergeCellsXml = '';

                for (let i = 0; i < mergedCells.length; i++) {
                    if (mergedCells[i].from === mergedCells[i].to) {
                        continue;
                    }

                    mergeCellsXml += `\n        <mergeCell ref="${mergedCells[i].from}:${mergedCells[i].to}" />\n`;
                }

                if (that.mergedCells) {
                    for (let i = 0; i < that.mergedCells.length; i++) {
                        const cellDefinition = that.mergedCells[i];

                        if (cellDefinition.rowspan < 2 && cellDefinition.colspan < 2) {
                            continue;
                        }

                        const from = that.columnsArray[cellDefinition.cell[0]] + (cellDefinition.cell[1] + that.xlsxStartIndex + 1),
                            to = that.columnsArray[cellDefinition.cell[0] + cellDefinition.colspan - 1] + (cellDefinition.cell[1] + that.xlsxStartIndex + cellDefinition.rowspan);

                        mergeCellsXml += `\n        <mergeCell ref="${from}:${to}" />\n`;
                    }
                }

                if (mergeCellsXml) {
                    mergeCellsXml = `\n    <mergeCells count="${mergedCells.length}">${mergeCellsXml}    </mergeCells>`;
                }

                return mergeCellsXml;
            }

            /**
             * Gets numFmt index.
             */
            getNumFmtIndex(format, numFmts) {
                let index = numFmts.collection.indexOf(format);

                if (index === -1) {
                    index = numFmts.collection.length + 100;
                    numFmts.collection.push(format);
                    numFmts.xml += `<numFmt numFmtId="${index}" formatCode="${format}"/>`;
                }
                else {
                    index += 100;
                }

                return index;
            }

            /**
                * Returns outlineLevel.
                */
            getOutlineLevel(record) {
                if (!this.actualHierarchy || record._level === 1) {
                    return '';
                }

                return ` outlineLevel="${record._level - 1}"`;
            }

            /**
             * Gets row style.
             */
            getRowStyle() {
                const that = this,
                    style = that.style;

                if (!style) {
                    return '';
                }

                const rowsDefinition = style.rows;

                if (!rowsDefinition) {
                    return '';
                }

                const styles = {
                    row: ''
                };
                let generatedStyle = '';

                for (let prop in rowsDefinition) {
                    if (!Object.prototype.hasOwnProperty.call(rowsDefinition, prop) ||
                        prop === 'alternationCount' ||
                        prop === 'alternationStart' ||
                        prop === 'alternationEnd') {
                        continue;
                    }

                    const value = rowsDefinition[prop];

                    if (prop.indexOf('alt') !== -1) {
                        const i = prop.slice(16, 17),
                            property = prop.slice(17);

                        if (!styles['rowN' + i]) {
                            styles['rowN' + i] = '';
                        }

                        if (property === 'Color') {
                            styles['rowN' + i] += 'color : ' + value + '; ';
                        }
                        else if (property === 'BorderColor') {
                            styles['rowN' + i] += 'border-color : ' + value + '; ';
                        }
                        else {
                            styles['rowN' + i] += 'background-color : ' + value + '; ';
                        }

                        continue;
                    }

                    if (!isNaN(prop)) {
                        if (!styles['row' + prop]) {
                            styles['row' + prop] = '';
                        }

                        for (let rowProp in value) {
                            if (Object.prototype.hasOwnProperty.call(value, rowProp)) {
                                styles['row' + prop] += window.jqxToDash(rowProp) + ': ' + value[rowProp] + '; ';
                            }
                        }

                        continue;
                    }

                    styles.row += window.jqxToDash(prop) + ': ' + rowsDefinition[prop] + '; ';
                }

                let keys = Object.keys(styles);

                keys.sort(function (a, b) {
                    if (a === 'row') {
                        return -1;
                    }

                    if (b === 'row') {
                        return 1;
                    }

                    const aIsNum = !isNaN(a.slice(3)),
                        bIsNum = !isNaN(b.slice(3));

                    if (aIsNum && !bIsNum) {
                        return 1;
                    }

                    if (!aIsNum && bIsNum) {
                        return -1;
                    }

                    return +(a < b);
                });

                for (let i = 0; i < keys.length; i++) {
                    generatedStyle += `        .${keys[i]} { ${styles[keys[i]]}}\n`;
                }

                return generatedStyle;
            }

            /**
             * Gets table style.
             */
            getTableStyle() {
                const that = this,
                    style = that.style;

                if (!style) {
                    return ' style="table-layout: fixed; border: 1px solid black; border-collapse: collapse;"';
                }

                let generatedStyle = 'table-layout: fixed; ';

                for (let prop in style) {
                    if (Object.prototype.hasOwnProperty.call(style, prop) &&
                        ['header', 'columns', 'rows', 'removeDefault', 'custom'].indexOf(prop) === -1) {
                        generatedStyle += window.jqxToDash(prop) + ': ' + style[prop] + '; ';
                    }
                }

                if (generatedStyle) {
                    generatedStyle = ' style="' + generatedStyle + '"';
                }

                return generatedStyle;
            }

            /**
             * Gets the "s" (style) attribute of an XLSX cell.
             */
            getXLSXCellStyle(r) {
                const that = this;

                if (that.cellStyleMapping[r] !== undefined) {
                    return ` s="${that.cellStyleMapping[r]}"`;
                }

                return '';
            }

            /**
             * Gets the "s" (style) attribute of an XLSX cell.
             */
            getXLSXFormat(format, cellValue) {
                if (typeof cellValue === 'number') {
                    let currencySign = '$';
                    if (format && typeof (format) === 'string' && format.indexOf('c') >= 0 && format.indexOf('x') >= 0) {
                        currencySign = format.substring(0, format.indexOf('x'));
                        format = format.substring(1 + format.indexOf('x'));
                    }

                    if (!/^([a-zA-Z]\d*)$/g.test(format)) {
                        return format;
                    }

                    let precision = parseFloat(format.slice(1)) || 0,
                        precisionCode = precision > 0 ? '.' + ('0').repeat(precision) : '';

                    format = format.slice(0, 1);

                    switch (format) {
                        case 'C':
                        case 'c':
                            if (currencySign !== '$') {
                                return '\#,0' + precisionCode + ' ' + currencySign;
                            }
                            return currencySign + '\#,0' + precisionCode;
                        case 'D':
                        case 'd':
                            if (precision) {
                                return ('0').repeat(precision);
                            }

                            return '0';
                        case 'E':
                        case 'e':
                            return '0' + precisionCode + format + '000';
                        case 'F':
                        case 'f':
                            return '0' + precisionCode;
                        case 'N':
                        case 'n':
                            return '#,0' + precisionCode;
                        case 'P':
                        case 'p':
                            return '#,0' + precisionCode + ' %';
                        default:
                            return;
                    }
                }
                else if (cellValue instanceof Date) {
                    switch (format) {
                        case 'd':
                            return 'm/d/yyyy';
                        case 'D':
                            return 'nnnnmmmm dd, yyyy';
                        case 't':
                            return 'h:m AM/PM';
                        case 'T':
                            return 'h:mm:ss AM/PM';
                        case 'f':
                            return 'nnnnmmmm dd, yyyy h:m AM/PM';
                        case 'F':
                            return 'nnnnmmmm dd, yyyy h:mm:ss AM/PM';
                        case 'M':
                            return 'mmmm d';
                        case 'Y':
                            return 'yyyy mmmm';
                        case 'FP':
                        case 'PP':
                            return 'yyyy-mm-dd hh:mm:ss';
                        case 'FT':
                        case 'PT':
                            return 'hh:mm:ss';
                    }

                    format = format.replace(/f|u|n|p|e|a|x|o/gi, '');
                    format = format.replace(/tt/gi, 'AM/PM');
                    format = format.replace(/:{2,}|:\s|:$|\.$/g, '');
                    format = format.trim();
                    return format;
                }
            }

            /**
             * Processes column styles.
             */
            processColumnStyle(style) {
                const that = this,
                    headerDefinition = style.header,
                    columnsDefinition = style.columns,
                    sampleRecord = that.data[0],
                    startIndex = that.xlsxStartIndex;

                that.columnWidth = [];

                if (startIndex && headerDefinition) {
                    for (let i = 0; i < that.columnsArray.length; i++) {
                        const columnLetter = that.columnsArray[i],
                            cell = columnLetter + startIndex,
                            columnSpecific = headerDefinition[that.datafields[i]];

                        for (let prop in headerDefinition) {
                            if (Object.prototype.hasOwnProperty.call(headerDefinition, prop) && sampleRecord[prop] === undefined) {
                                if (that.complexHeader) {
                                    for (let j = 0; j < that.complexHeader.length; j++) {
                                        if (prop === 'height') {
                                            that.rowHeight[j] = ` ht="${(parseFloat(headerDefinition.height) / 1) / 2}"`;
                                            continue;
                                        }
                                        else {
                                            that.storeCellStyle(columnLetter + (j + 1), prop, headerDefinition[prop]);
                                        }
                                    }
                                }
                                else {
                                    if (prop === 'height') {
                                        that.rowHeight[startIndex - 1] = ` ht="${parseFloat(headerDefinition.height) / 2}"`;
                                        continue;
                                    }

                                    that.storeCellStyle(cell, prop, headerDefinition[prop]);
                                }
                            }
                        }

                        if (!columnSpecific) {
                            continue;
                        }

                        for (let prop in columnSpecific) {
                            if (Object.prototype.hasOwnProperty.call(columnSpecific, prop)) {
                                if (prop === 'width') {
                                    that.columnWidth[i] = columnSpecific.width;
                                    continue;
                                }

                                that.storeCellStyle(cell, prop, columnSpecific[prop]);
                            }
                        }
                    }
                }
                else if (headerDefinition) {
                    for (let i = 0; i < that.columnsArray.length; i++) {
                        const columnSpecific = headerDefinition[that.datafields[i]];

                        if (columnSpecific && columnSpecific.width !== undefined) {
                            that.columnWidth[i] = columnSpecific.width;
                        }
                    }
                }

                if (!columnsDefinition) {
                    return '';
                }

                for (let i = startIndex; i < that.data.length; i++) {
                    for (let j = 0; j < that.columnsArray.length; j++) {
                        const columnLetter = that.columnsArray[j],
                            cell = columnLetter + (i + 1),
                            datafield = that.datafields[j],
                            columnSpecific = columnsDefinition[datafield];

                        for (let prop in columnsDefinition) {
                            if (Object.prototype.hasOwnProperty.call(columnsDefinition, prop) && sampleRecord[prop] === undefined) {
                                that.storeCellStyle(cell, prop, columnsDefinition[prop]);
                            }
                        }

                        if (!columnSpecific) {
                            continue;
                        }

                        for (let prop in columnSpecific) {
                            if (!isNaN(prop) || !Object.prototype.hasOwnProperty.call(columnSpecific, prop)) {
                                continue;
                            }

                            that.storeCellStyle(cell, prop, columnSpecific[prop], that.data[i][datafield]);
                        }

                        if (columnSpecific[i]) {
                            const cellProperties = columnSpecific[i];
                            for (let prop in cellProperties) {
                                if (!isNaN(prop) || !Object.prototype.hasOwnProperty.call(cellProperties, prop)) {
                                    continue;
                                }
                                if (!cellProperties[prop]) {
                                    continue;
                                }

                                that.storeCellStyle(cell, prop, cellProperties[prop], that.data[i][datafield]);
                            }
                        }
                    }
                }

                // prepend

                if (that.headerContent && that.headerContent.length) {
                    for (let m = 0; m < that.headerContent.length; m++) {
                        const applyToRowCells = (row, prop, value) => {
                            for (let j = 0; j < that.columnsArray.length; j++) {
                                const currentCell = that.columnsArray[j] + (row);

                                that.storeCellStyle(currentCell, prop, value);
                            }
                        }

                        const row = m + 1;

                        if (that.headerContent[m].style) {
                            const contentStyle = that.headerContent[m].style;

                            const hexDigits = new Array
                                ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');

                            const hex = (x) => {
                                return isNaN(x) ? '00' : hexDigits[(x - x % 16) / 16] + hexDigits[x % 16];
                            }

                            //Function to convert rgb color to hex format
                            const toHex = (rgb) => {
                                if (!rgb.startsWith('#')) {
                                    rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);

                                    if (!rgb) {
                                        return null;
                                    }
                                }
                                else {
                                    return rgb.toUpperCase();
                                }

                                return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]).toUpperCase();
                            }



                            for (let prop in contentStyle) {
                                let value = contentStyle[prop];

                                if (prop === 'height') {
                                    that.rowHeight[row - 1] = ` ht="${parseFloat(value)}"`;
                                    continue;
                                }
                                if (prop === 'color' || prop === 'backgroundColor') {
                                    value = toHex(value);
                                }

                                applyToRowCells(row, prop, value);
                            }
                        }
                    }
                }




                // append
                if (that.footerContent && that.footerContent.length) {
                    for (let m = 0; m < that.footerContent.length; m++) {
                        const applyToRowCells = (row, prop, value) => {
                            for (let j = 0; j < that.columnsArray.length; j++) {
                                const currentCell = that.columnsArray[j] + (row);

                                that.storeCellStyle(currentCell, prop, value);
                            }
                        }

                        let prefix = (that.headerContent && that.headerContent.length) ? that.headerContent.length : 0;

                        const row = 1 + that.data.length + m + prefix;

                        if (that.footerContent[m].style) {
                            const contentStyle = that.footerContent[m].style;

                            const hexDigits = new Array
                                ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');

                            const hex = (x) => {
                                return isNaN(x) ? '00' : hexDigits[(x - x % 16) / 16] + hexDigits[x % 16];
                            }

                            //Function to convert rgb color to hex format
                            const toHex = (rgb) => {
                                if (!rgb.startsWith('#')) {
                                    rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);

                                    if (!rgb) {
                                        return null;
                                    }
                                }
                                else {
                                    return rgb.toUpperCase();
                                }

                                return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]).toUpperCase();
                            }



                            for (let prop in contentStyle) {
                                let value = contentStyle[prop];

                                if (prop === 'height') {
                                    that.rowHeight[row - 1] = ` ht="${parseFloat(value)}"`;
                                    continue;
                                }
                                if (prop === 'color' || prop === 'backgroundColor') {
                                    value = toHex(value);
                                }

                                applyToRowCells(row, prop, value);
                            }
                        }
                    }
                }
            }

            /**
             * Processes complex header object.
             */
            processComplexHeader(header, data, format) {
                const that = this,
                    flatHeader = {},
                    processGrouping = ['html', 'jpeg', 'pdf', 'png', 'xlsx'].indexOf(format) !== -1 && header.columngroups,
                    datafieldMapping = [],
                    columnGroupHierarchy = {},
                    columnGroupNameHierarchy = {},
                    complexHeader = [],
                    complexDataFieldsHeader = [];
                let headerDepth = 0;

                function getColumnGroup(columnGroup) {
                    for (let i = 0; i < header.columngroups.length; i++) {
                        const currentGroupDefinition = header.columngroups[i];

                        if (currentGroupDefinition.name === columnGroup) {
                            return currentGroupDefinition;
                        }
                    }
                }

                function getColumnGroupHierarchy(groupDefinition, property) {
                    const columnGroups = [];

                    while (groupDefinition) {
                        columnGroups.unshift(groupDefinition[property]);

                        if (groupDefinition.parentGroup) {
                            groupDefinition = getColumnGroup(groupDefinition.parentGroup);
                        }
                        else {
                            return columnGroups;
                        }
                    }
                }

                if (processGrouping) {
                    for (let i = 0; i < header.columngroups.length; i++) {
                        const currentGroupDefinition = header.columngroups[i],
                            groupHierarchy = getColumnGroupHierarchy(currentGroupDefinition, 'label');

                        columnGroupHierarchy[currentGroupDefinition.name] = groupHierarchy;
                        columnGroupNameHierarchy[currentGroupDefinition.name] = getColumnGroupHierarchy(currentGroupDefinition, 'name');
                        headerDepth = Math.max(headerDepth, groupHierarchy.length);
                    }

                    headerDepth++;

                    for (let i = 0; i < headerDepth; i++) {
                        complexHeader[i] = [];
                        complexDataFieldsHeader[i] = [];
                    }
                }

                for (let i = 0; i < header.columns.length; i++) {
                    const currentColumn = header.columns[i];

                    flatHeader[currentColumn.dataField] = currentColumn.label;

                    if (!processGrouping) {
                        continue;
                    }

                    datafieldMapping[i] = currentColumn.dataField;
                    complexHeader[headerDepth - 1][i] = currentColumn.label;
                    complexDataFieldsHeader[headerDepth - 1][i] = currentColumn.dataField;

                    if (!currentColumn.columnGroup) {
                        continue;
                    }

                    const columnGroups = columnGroupHierarchy[currentColumn.columnGroup],
                        columnGroupNames = columnGroupNameHierarchy[currentColumn.columnGroup];

                    if (columnGroups) {
                        for (let j = 0; j < columnGroups.length; j++) {
                            complexHeader[j][i] = columnGroups[j];
                            complexDataFieldsHeader[j][i] = columnGroupNames[j];
                        }
                    }
                }

                if (complexHeader.length > 1) {
                    const numberOfDatafields = Object.keys(flatHeader).length;

                    for (let i = 0; i < headerDepth - 1; i++) {
                        const entry = {};

                        for (let j = 0; j < numberOfDatafields; j++) {
                            if (complexHeader[i][j] === undefined) {
                                let iterator = i + 1;

                                while (complexHeader[iterator][j] === undefined) {
                                    iterator++;
                                }

                                complexHeader[i][j] = complexHeader[iterator][j];
                                complexDataFieldsHeader[i][j] = complexDataFieldsHeader[iterator][j];
                            }

                            entry[datafieldMapping[j]] = complexHeader[i][j];
                        }

                        if (format === 'xlsx') {
                            data.splice(i, 0, entry);
                        }
                    }

                    that.complexHeader = complexHeader;
                    that.complexDataFieldsHeader = complexDataFieldsHeader;

                    if (format !== 'xlsx') {
                        data.unshift(flatHeader);
                    }
                    else {
                        data.splice(headerDepth - 1, 0, flatHeader);

                        const toMerge = {};

                        for (let i = 0; i < headerDepth; i++) {
                            for (let j = 0; j < numberOfDatafields; j++) {
                                const dataField = complexDataFieldsHeader[i][j];

                                if (!toMerge[dataField]) {
                                    toMerge[dataField] = { from: [i, j] };
                                    toMerge[dataField].to = toMerge[dataField].from;
                                }
                                else {
                                    const oldMergeTo = toMerge[dataField].to;

                                    if (i - oldMergeTo[0] > 1 || j - oldMergeTo[1] > 1) {
                                        toMerge[dataField + Math.random().toString(36)] = toMerge[dataField];
                                        toMerge[dataField] = { from: [i, j], to: [i, j] };
                                        continue;
                                    }

                                    toMerge[dataField].to = [i, j];
                                }
                            }
                        }

                        that.complexHeaderMergeInfo = toMerge;
                    }
                }
                else {
                    data.unshift(flatHeader);
                }
            }

            /**
             * Processes hierarchical data.
             */
            processHierarchicalData(data, format) {
                const that = this,
                    startIndex = format !== 'xlsx' ? +that.exportHeader : that.xlsxStartIndex,
                    siblingGroups = {},
                    processedData = [];
                let maxLevel = 0,
                    actualHierarchy = false;

                function process(parentKey, level, collapsed) {
                    const group = siblingGroups[parentKey];

                    maxLevel = Math.max(maxLevel, level);

                    if (group === undefined) {
                        return;
                    }

                    for (let i = 0; i < group.length; i++) {
                        const currentRecord = group[i],
                            keyDataField = currentRecord._keyDataField;

                        currentRecord._collapsed = collapsed;
                        currentRecord._level = level;
                        processedData.push(currentRecord);

                        if (siblingGroups[keyDataField]) {
                            actualHierarchy = true;
                            currentRecord._expanded = currentRecord._expanded !== undefined ? currentRecord._expanded : true;
                            process(keyDataField, level + 1, collapsed || !currentRecord._expanded);
                        }
                    }
                }

                function processJSONXML(parentKey, level, parent) {
                    const group = siblingGroups[parentKey];

                    maxLevel = Math.max(maxLevel, level);

                    if (group === undefined) {
                        return;
                    }

                    for (let i = 0; i < group.length; i++) {
                        const currentRecord = group[i],
                            keyDataField = currentRecord._keyDataField;
                        let cleanedRecord;

                        if (format === 'json') {
                            cleanedRecord = {};

                            for (let prop in currentRecord) {
                                if (Object.prototype.hasOwnProperty.call(currentRecord, prop) && prop.charAt(0) !== '_') {
                                    cleanedRecord[prop] = currentRecord[prop];
                                }
                            }
                        }
                        else {
                            cleanedRecord = Object.assign({}, currentRecord);
                        }

                        parent.push(cleanedRecord);

                        if (siblingGroups[keyDataField]) {
                            actualHierarchy = true;
                            cleanedRecord.rows = [];
                            processJSONXML(keyDataField, level + 1, cleanedRecord.rows);
                        }
                    }
                }

                if (data[startIndex]._keyDataField === undefined) {
                    return that.processNestedData(data, format, startIndex);
                }

                for (let i = startIndex; i < data.length; i++) {
                    const currentRecord = Object.assign({}, data[i]);
                    let parentKey = currentRecord._parentDataField;

                    if (parentKey === undefined) {
                        parentKey = null;
                    }

                    if (siblingGroups[parentKey] === undefined) {
                        siblingGroups[parentKey] = [currentRecord];
                    }
                    else {
                        siblingGroups[parentKey].push(currentRecord);
                    }
                }

                if (startIndex) {
                    for (let i = 0; i < startIndex; i++) {
                        processedData.push(Object.assign({}, data[i]));

                        if (['json', 'pdf', 'xml'].indexOf(format) === -1) {
                            processedData[i]._level = 1;
                        }
                    }
                }

                if (format !== 'json' && format !== 'xml') {
                    process(null, 1, false);
                }
                else {
                    processJSONXML(null, 1, processedData);
                }

                if (!actualHierarchy) {
                    that.actualHierarchy = false;
                }

                that.maxLevel = maxLevel;
                return processedData;
            }

            /**
             * Processes nested hierarchical data.
             */
            processNestedData(data, format, startIndex) {
                const that = this,
                    processedData = [];
                let maxLevel = 0,
                    actualHierarchy = false;

                function process(start, children, level, collapsed) {
                    maxLevel = Math.max(maxLevel, level);

                    for (let i = start; i < children.length; i++) {
                        const currentRecord = Object.assign({}, children[i]);

                        currentRecord._collapsed = collapsed;
                        currentRecord._level = level;
                        processedData.push(currentRecord);

                        if (currentRecord.children && currentRecord.children.length > 0) {
                            actualHierarchy = true;
                            currentRecord._expanded = currentRecord._expanded !== undefined ? currentRecord._expanded : true;
                            process(0, currentRecord.children, level + 1, collapsed || !currentRecord._expanded);
                        }

                        delete currentRecord.children;
                    }
                }

                function processJSONXML(start, children, rows, level) {
                    maxLevel = Math.max(maxLevel, level);

                    for (let i = start; i < children.length; i++) {
                        const currentRecord = Object.assign({}, children[i]);

                        if (level === 1) {
                            processedData[i] = currentRecord;
                        }
                        else {
                            rows[i] = currentRecord;
                        }

                        if (currentRecord.children && currentRecord.children.length > 0) {
                            actualHierarchy = true;
                            currentRecord.rows = [];
                            processJSONXML(0, currentRecord.children, currentRecord.rows, level + 1);
                        }

                        delete currentRecord.children;
                    }
                }

                if (startIndex) {
                    for (let i = 0; i < startIndex; i++) {
                        processedData.push(Object.assign({}, data[i]));

                        if (['json', 'pdf', 'xml'].indexOf(format) === -1) {
                            processedData[i]._level = 1;
                        }
                    }
                }

                if (format !== 'json' && format !== 'xml') {
                    process(startIndex, data, 1, false);
                }
                else {
                    processJSONXML(startIndex, data, undefined, 1);
                }

                if (!actualHierarchy) {
                    that.actualHierarchy = false;
                }

                that.maxLevel = maxLevel;
                return processedData;
            }

            /**
             * Processes row styles.
             */
            processRowStyle(style) {
                const that = this,
                    rowsDefinition = style.rows;

                that.rowHeight = [];

                if (!rowsDefinition) {
                    return;
                }

                const startIndex = that.xlsxStartIndex;

                function applyToRowCells(row, prop, value) {
                    for (let j = 0; j < that.columnsArray.length; j++) {
                        const currentCell = that.columnsArray[j] + (row + 1 + startIndex);

                        that.storeCellStyle(currentCell, prop, value);
                    }
                }

                if (rowsDefinition.height) {
                    if (!rowsDefinition.height) {
                        rowsDefinition.height = 15;
                    }
                    that.defaultRowHeight = ` ht="${parseFloat(rowsDefinition.height) / 2}"`;
                }

                for (let i = startIndex; i < that.data.length; i++) {
                    const row = i - startIndex;

                    for (let prop in rowsDefinition) {
                        if (Object.prototype.hasOwnProperty.call(rowsDefinition, prop) &&
                            prop.indexOf('alt') === -1 &&
                            isNaN(prop) &&
                            prop !== 'height') {
                            applyToRowCells(row, prop, rowsDefinition[prop]);
                        }
                    }

                    if (rowsDefinition.alternationCount &&
                        (((rowsDefinition.alternationStart === undefined || row >= rowsDefinition.alternationStart) &&
                            (rowsDefinition.alternationEnd === undefined || row <= rowsDefinition.alternationEnd)) ||
                            rowsDefinition.alternationStart === rowsDefinition.alternationEnd)) {
                        const start = rowsDefinition.alternationStart || 0,
                            i = (row - start) % rowsDefinition.alternationCount;

                        if (rowsDefinition[`alternationIndex${i}Color`]) {
                            applyToRowCells(row, 'color', rowsDefinition[`alternationIndex${i}Color`]);
                        }

                        if (rowsDefinition[`alternationIndex${i}BorderColor`]) {
                            applyToRowCells(row, 'borderColor', rowsDefinition[`alternationIndex${i}BorderColor`]);
                        }

                        if (rowsDefinition[`alternationIndex${i}BackgroundColor`]) {
                            applyToRowCells(row, 'backgroundColor', rowsDefinition[`alternationIndex${i}BackgroundColor`]);
                        }
                    }

                    if (that.setRowHeight) {
                        const rowHeight = that.setRowHeight(row);
                        if (rowHeight) {
                            that.rowHeight[i] = ` ht="${parseFloat(rowHeight)}"`;
                            continue;
                        }
                    }

                    if (rowsDefinition[row]) {
                        for (let prop in rowsDefinition[row]) {
                            if (Object.prototype.hasOwnProperty.call(rowsDefinition[row], prop)) {
                                if (prop === 'height') {
                                    that.rowHeight[i] = ` ht="${parseFloat(rowsDefinition[row].height) / 2}"`;
                                    continue;
                                }

                                if (that.data[i] && that.data[i][prop]) {
                                    function applyToRowCell(row, prop, value, dataField) {
                                        const j = that.datafields ? that.datafields.indexOf(dataField) : -1;
                                        if (j >= 0) {
                                            const currentCell = that.columnsArray[j] + (row + 1 + startIndex);

                                            that.storeCellStyle(currentCell, prop, value);
                                        }
                                    }
                                    for (let styleProp in rowsDefinition[row][prop]) {
                                        applyToRowCell(row, styleProp, rowsDefinition[row][prop][styleProp], prop);
                                    }
                                    continue;
                                }

                                applyToRowCells(row, prop, rowsDefinition[row][prop]);
                            }
                        }
                    }
                }
            }

            /**
             * Stores cell style in "styleMap" object.
             */
            storeCellStyle(cell, prop, value) {
                const that = this,
                    cellMap = that.styleMap[cell];

                switch (prop) {
                    case 'backgroundColor':
                        cellMap.fills.fgColor = value;
                        break;
                    case 'color':
                        cellMap.fonts.color = value;
                        break;
                    case 'fontFamily':
                        cellMap.fonts.name = value.replace(/"/g, '\'');
                        break;
                    case 'fontSize':
                        cellMap.fonts.sz = Math.round(parseFloat(value) / (96 / 72));
                        break;
                    case 'fontStyle':
                        if (value === 'italic') {
                            cellMap.fonts.i = true;
                        }
                        else {
                            delete cellMap.fonts.i;
                        }

                        break;
                    case 'fontWeight':
                        if (value === 'bold') {
                            cellMap.fonts.b = true;
                        }
                        else {
                            delete cellMap.fonts.b;
                        }

                        break;
                    case 'numFmt': {
                        cellMap.numFmt = value;
                        break;
                    }
                    case 'textAlign':
                        cellMap.alignment.horizontal = value;
                        break;
                    case 'textDecoration':
                        if (value === 'underline') {
                            cellMap.fonts.u = true;
                        }
                        else {
                            delete cellMap.fonts.u;
                        }

                        break;
                    case 'verticalAlign':
                        if (value === 'middle') {
                            value = 'center';
                        }

                        cellMap.alignment.vertical = value;
                        break;
                }
            }

            /**
             * Returns an Alpha Red Green Blue color value.
             */
            toARGB(color) {
                color = color.replace(/\s/g, '');

                const rgbResult = /rgb\((\d+),(\d+),(\d+)\)/gi.exec(color);

                if (rgbResult !== null) {
                    const r = parseFloat(rgbResult[1]).toString(16).toUpperCase(),
                        g = parseFloat(rgbResult[2]).toString(16).toUpperCase(),
                        b = parseFloat(rgbResult[3]).toString(16).toUpperCase();

                    return 'FF' + ('0').repeat(2 - r.length) + r +
                        ('0').repeat(2 - g.length) + g +
                        ('0').repeat(2 - b.length) + b;
                }

                const rgbaResult = /rgba\((\d+),(\d+),(\d+)\,(\d*.\d+|\d+)\)/gi.exec(color);

                if (rgbaResult !== null) {
                    const a = Math.round(parseFloat(rgbaResult[4]) * 255).toString(16).toUpperCase(),
                        r = parseFloat(rgbaResult[1]).toString(16).toUpperCase(),
                        g = parseFloat(rgbaResult[2]).toString(16).toUpperCase(),
                        b = parseFloat(rgbaResult[3]).toString(16).toUpperCase();

                    return ('0').repeat(2 - a.length) + a +
                        ('0').repeat(2 - r.length) + r +
                        ('0').repeat(2 - g.length) + g +
                        ('0').repeat(2 - b.length) + b;
                }

                const shortHexResult = /^#(.)(.)(.)$/gi.exec(color);

                if (shortHexResult !== null) {
                    const r = shortHexResult[1].toUpperCase(),
                        g = shortHexResult[2].toUpperCase(),
                        b = shortHexResult[3].toUpperCase();

                    return 'FF' + r + r + g + g + b + b;
                }

                return 'FF' + color.toUpperCase().slice(1);
            }

            /**
             * Adds toggleable functionality.
             */
            toggleableFunctionality() {
                const that = this;

                if (!that.actualHierarchy) {
                    return '';
                }

                return `\n    <style type="text/css">
            .toggle-element {
                width: 5px;
                height: 1px;
                padding-right: 5px;
                float: left;
                text-align: right;
                cursor: pointer;
                user-select: none;
            }
    
            .collapsed {
                display: none;
            }
        </style>
        <script type="text/javascript">
            window.onload = function () {
                var expandChar = '${that.expandChar}',
                    collapseChar = '${that.collapseChar}',
                    toggleElements = document.getElementsByClassName('toggle-element');
    
                function getParent(child) {
                    var prevSibling = child.previousElementSibling;
    
                    while (prevSibling) {
                        if (child.getAttribute('level') > prevSibling.getAttribute('level')) {
                            return prevSibling;
                        }
    
                        prevSibling = prevSibling.previousElementSibling;
                    }
    
                }
    
                function getFirstCollapsedAncestor(child) {
                    var parent = getParent(child);
    
                    while (parent) {
                        if (parent.firstElementChild.firstElementChild.innerHTML === expandChar) {
                            return parent;
                        }
    
                        parent = getParent(parent);
                    }
                }
    
                for (var i = 0; i < toggleElements.length; i++) {
                    toggleElements[i].addEventListener('click', function (event) {
                        var expanded = this.innerHTML === collapseChar,
                            row = this.parentElement.parentElement,
                            sibling = row.nextElementSibling;
    
                        if (expanded) {
                            this.innerHTML = expandChar;
                        }
                        else {
                            this.innerHTML = collapseChar;
                        }
    
                        while (sibling && row.getAttribute('level') < sibling.getAttribute('level')) {
                            if (expanded) {
                                sibling.style.display = 'none';
                            }
                            else {
                                var firstCollapsedAncestor = getFirstCollapsedAncestor(sibling);
    
                                if (!firstCollapsedAncestor || firstCollapsedAncestor === row) {
                                    sibling.classList.remove('collapsed');
                                    sibling.style.display = null;
                                }
    
                            }
    
                            sibling = sibling.nextElementSibling;
                        }
                    });
                }
            }
        </script>`;
            }

            /**
             * Generates styles.xml.
             */
            generateStyles(style) {
                const that = this;

                that.cellStyleMapping = {};

                if (Object.keys(style).length === 0 && !that.complexHeader) {
                    // default style
                    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2 xr" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><charset val="204"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/></cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>${that.conditionalFormattingXLSX.styles || '<dxfs count="0"/>'}<tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>`;
                }

                that.styleMap = {};

                let offset = that.headerContent ? that.headerContent.length : 0;
                offset += that.footerContent ? that.footerContent.length : 0;

                let count = that.data.length + offset;

                if (that.groupBy && that.groupBy.length) {
                    count += 50;
                }

                for (let i = 0; i < count; i++) {
                    for (let j = 0; j < that.columnsArray.length; j++) {
                        that.styleMap[that.columnsArray[j] + (i + 1)] = {
                            numFmts: {}, fonts: {}, fills: {}, borders: {}, alignment: {}
                        }
                    }
                }

                if (style && style.columns) {
                    for (let i = 0; i < that.columnsArray.length; i++) {
                        const datafield = that.datafields[i];

                        if (!style.columns[datafield] || !style.columns[datafield].format) {
                            continue;
                        }

                        const XLSXFormatFirst = that.getXLSXFormat(style.columns[datafield].format, that.data[1][datafield]);
                        const XLSXFormat = that.getXLSXFormat(style.columns[datafield].format, that.data[that.data.length - 1][datafield]);

                        if (XLSXFormat) {
                            style.columns[datafield].numFmt = XLSXFormat;
                        }
                        else if (XLSXFormatFirst) {
                            style.columns[datafield].numFmt = XLSXFormatFirst;
                        }
                        else if (style.columns[datafield].format && (datafield.toLowerCase().indexOf('date') >= 0 || style.columns[datafield].format.indexOf('d/') >= 0)) {
                            let format = style.columns[datafield].format;
                            switch (format) {
                                case 'd':
                                    format = 'm/d/yyyy';
                                    break;
                                case 'D':
                                    format = 'nnnnmmmm dd, yyyy';
                                    break;
                                case 't':
                                    format = 'h:m AM/PM';
                                    break;
                                case 'T':
                                    format = 'h:mm:ss AM/PM';
                                    break;
                                case 'f':
                                    format = 'nnnnmmmm dd, yyyy h:m AM/PM';
                                    break;
                                case 'F':
                                    format = 'nnnnmmmm dd, yyyy h:mm:ss AM/PM';
                                    break;
                                case 'M':
                                    format = 'mmmm d';
                                    break;
                                case 'Y':
                                    format = 'yyyy mmmm';
                                    break;
                                case 'FP':
                                case 'PP':
                                    format = 'yyyy-mm-dd hh:mm:ss';
                                    break;
                                case 'FT':
                                case 'PT':
                                    format = 'hh:mm:ss';
                                    break;
                            }

                            format = format.replace(/f|u|n|p|e|a|x|o/gi, '');
                            format = format.replace(/tt/gi, 'AM/PM');
                            format = format.replace(/:{2,}|:\s|:$|\.$/g, '');
                            format = format.trim();
                            style.columns[datafield].numFmt = format;
                        }
                    }
                }

                that.processRowStyle(style);
                that.processColumnStyle(style);

                const cellAliases = {};

                for (let i = 0; i < that.complexHeaderMergedCells.length; i++) {
                    const currentCell = that.complexHeaderMergedCells[i];

                    if (parseFloat(currentCell.to[1]) === that.complexHeader.length) {
                        cellAliases[currentCell.to] = currentCell.from;
                        continue;
                    }

                    that.styleMap[currentCell.from].alignment.horizontal = 'center';
                    that.styleMap[currentCell.from].alignment.vertical = 'center';
                }

                const fonts = {
                    xml: '<font><sz val="11" /><color theme="1" /><name val="Calibri" /><family val="2" /><charset val="204" /><scheme val="minor" /></font>',
                    collection: ['default']
                },
                    fills = {
                        xml: '<fill><patternFill patternType="none" /></fill><fill><patternFill patternType="gray125" /></fill>',
                        collection: ['default', 'gray125']
                    },
                    numFmts = {
                        xml: '',
                        collection: []
                    },
                    cellXfs = {
                        xml: '<xf fontId="0" fillId="0" borderId="1"/>',
                        collection: ['default']
                    };

                for (let i = 0; i < count; i++) { // iterate rows
                    for (let j = 0; j < that.columnsArray.length; j++) { // iterate columns
                        const currentCell = that.columnsArray[j] + (i + 1),
                            currentCellStyle = that.styleMap[currentCell];
                        let currentFont = '', currentFill = '', currentAlignment = '',
                            currentFontCode = [], currentFillCode = [], currentAlignmentCode = [], xf = [];

                        for (let prop in currentCellStyle.fonts) {
                            if (Object.prototype.hasOwnProperty.call(currentCellStyle.fonts, prop)) {
                                const value = currentCellStyle.fonts[prop];

                                switch (prop) {
                                    case 'color':
                                        currentFontCode[0] = value;
                                        currentFont += `<color rgb="${that.toARGB(value)}" />`;
                                        break;
                                    case 'name':
                                        currentFontCode[1] = value;
                                        currentFont += `<name val="${value}" />`;
                                        break;
                                    case 'sz':
                                        currentFontCode[2] = value;
                                        currentFont += `<sz val="${value}" />`;
                                        break;
                                    case 'i':
                                        currentFontCode[3] = value;
                                        currentFont += '<i />';
                                        break;
                                    case 'b':
                                        currentFontCode[4] = value;
                                        currentFont += '<b />';
                                        break;
                                    case 'u':
                                        currentFontCode[5] = value;
                                        currentFont += '<u />';
                                        break;
                                }
                            }
                        }

                        for (let prop in currentCellStyle.fills) {
                            if (Object.prototype.hasOwnProperty.call(currentCellStyle.fills, prop)) {
                                const value = currentCellStyle.fills[prop];

                                switch (prop) {
                                    case 'fgColor':
                                        currentFillCode[0] = value;
                                        currentFill += `<fgColor rgb="${that.toARGB(value)}" />`;
                                        break;
                                }
                            }
                        }

                        for (let prop in currentCellStyle.alignment) {
                            if (Object.prototype.hasOwnProperty.call(currentCellStyle.alignment, prop)) {
                                const value = currentCellStyle.alignment[prop];

                                switch (prop) {
                                    case 'horizontal':
                                        currentAlignmentCode[0] = value;
                                        currentAlignment += `horizontal="${value}" `;
                                        break;
                                    case 'vertical':
                                        currentAlignmentCode[1] = value;
                                        currentAlignment += `vertical="${value}" `;
                                        break;
                                }
                            }
                        }

                        currentFontCode = currentFontCode.toString();
                        currentFillCode = currentFillCode.toString();

                        if (currentFont !== '') {
                            let fontIndex = fonts.collection.indexOf(currentFontCode);

                            if (fontIndex === -1) {
                                fontIndex = fonts.collection.length;

                                fonts.xml += '<font>' + currentFont + '</font>';
                                fonts.collection.push(currentFontCode);
                            }

                            xf[0] = fontIndex;
                        }

                        if (currentFill !== '') {
                            let fillIndex = fills.collection.indexOf(currentFillCode);

                            if (fillIndex === -1) {
                                fillIndex = fills.collection.length;

                                fills.xml += '<fill><patternFill patternType="solid">' + currentFill + '</patternFill></fill>';
                                fills.collection.push(currentFillCode);
                            }

                            xf[1] = fillIndex;
                        }

                        if (currentAlignmentCode.length > 0) {
                            xf[2] = currentAlignment;
                        }

                        if (currentCellStyle.numFmt !== undefined) {
                            xf[3] = that.getNumFmtIndex(currentCellStyle.numFmt, numFmts);
                        }

                        const xfCode = xf.toString();

                        if (xfCode !== '') {
                            let xfIndex = cellXfs.collection.indexOf(xfCode);

                            if (xfIndex === -1) {
                                let newXfXML = '<xf ';

                                xfIndex = cellXfs.collection.length;

                                if (xf[0] !== undefined) {
                                    newXfXML += `fontId="${xf[0]}" `;
                                }

                                if (xf[1] !== undefined) {
                                    newXfXML += `fillId="${xf[1]}" `;
                                }

                                if (xf[3] !== undefined) {
                                    newXfXML += `numFmtId="${xf[3]}" `;
                                }

                                if (xf[2] !== undefined) {
                                    newXfXML += `applyAlignment="1" borderId="1"><alignment ${currentAlignment}/></xf>`;
                                }
                                else {
                                    newXfXML += ' borderId="1"/>';
                                }

                                cellXfs.xml += newXfXML;
                                cellXfs.collection.push(xfCode);
                            }

                            that.cellStyleMapping[cellAliases[currentCell] || currentCell] = xfIndex;
                        }
                    }
                }

                if (numFmts.collection.length) {
                    numFmts.xml = `<numFmts count="${numFmts.collection.length}">${numFmts.xml}</numFmts>`;
                }

                return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2 xr" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision">${numFmts.xml}<fonts count="${fonts.collection.length}" x14ac:knownFonts="1">${fonts.xml}</fonts><fills count="${fills.collection.length}">${fills.xml}</fills><borders count="2"><border><left/><right/><top/><bottom/></border><border><left style="hair"/><right style="hair"/><top style="hair"/><bottom style="hair"/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="${cellXfs.collection.length}">${cellXfs.xml}</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>${that.conditionalFormattingXLSX.styles}<dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>`;
            }
        }

        if ($.jqx && $.jqx.dataAdapter) {
            $.jqx.dataAdapter.DataExporter = DataExporter;
        }
    })(jqxBaseFramework);
})();

/***/ }),

/***/ 1282:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {
    'use strict';

    $.jqx.jqxWidget('jqxFormattedInput', '', {});

    $.extend($.jqx._jqxFormattedInput.prototype, {
        defineInstance: function () {
            var settings = {
                // public properties
                width: null,
                height: null,
                radix: 10, // possible values: 2, 8, 10, 16, "binary", "octal", "decimal", "hexadecimal"
                decimalNotation: 'default', // possible values: "default", "exponential"
                value: '0',
                min: '-9223372036854775808', // can be set in binary, octal, decimal or hexadecimal numeral system (has to correspond to the radix property)
                max: '9223372036854775807', // can be set in binary, octal, decimal or hexadecimal numeral system (has to correspond to the radix property)
                upperCase: false,
                spinButtons: true,
                spinButtonsStep: 1, // decimal value
                dropDown: false,
                dropDownWidth: null,
                popupZIndex: 20000,
                placeHolder: '',
                roundedCorners: true,
                disabled: false,
                rtl: false,
                changeType: null,
                template: '',
                hint: true,
                // internal properties
                _opened: false,
                $popup: $('<ul></ul>'),
                item: '<li><a href="#"></a></li>',

                // events
                events: ['open', 'close', 'change', 'radixChange']
            };
            if (this === $.jqx._jqxFormattedInput.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        createInstance: function () {
            var that = this;

            // enables 64-bit number support
            that._Long();

            that._regex = { 2: new RegExp(/([0-1])/), 8: new RegExp(/([0-7])/), 10: new RegExp(/([0-9\-])/), 16: new RegExp(/([0-9]|[a-f])/i) };

            that.render();
        },

        render: function () {
            var that = this;

            // sets the internal numeric radix based on the radix property
            that._radixNumber = that._getRadix(that.radix);

            if (that.value !== '') {
                // representation of the input value as a 64-bit number
                that._number = new that.longObj.math.Long.fromString((that.value).toString(), that._radixNumber);
            }



            if (this.element instanceof HTMLInputElement) {
                var group = $("<div></div>");
                group.addClass(that.toThemeProperty('jqx-input-group'));
                this.host.after(group);
                var input = this.element;
                var data = this.host.data();

                group.append(input);
                group[0].id = this.element.id;
                this.element.removeAttribute('id');
                this.element.setAttribute("hint", true);
                group[0].style = this.element.style;
                that.input = that.element;
                if (!(this.input instanceof HTMLInputElement)) {
                    this.input = this.host.find('input');
                    if (this.input.length > 0) {
                        this.input = this.input[0];
                    }
                    $(this.input).addClass(this.toThemeProperty("jqx-input-widget"));
                }
                this.element.style = '';
            }

            if (that.baseHost) {
                that.host = that.baseHost;
                that.element = that.host[0]; //.find("input")
            }

            if (this.element.nodeName.toLowerCase() === 'div') {
                this.baseHost = this.element;
                var input = this.host.find('input');
                var hasTextInput = false;
                $.each(input, function () {
                    var type = this.type;
                    if (type === null || type === 'text' || type === 'textarea') {
                        input = $(this);
                        hasTextInput = true;
                        return false;
                    }
                });
                if (!hasTextInput) {
                    throw new Error('jqxFormattedInput: Missing Text Input in the Input Group');
                }

                if (input.length > 0) {
                    this.baseHost = $(this.element);
                    var data = this.host.data();
                    this.host = input;
                    this.element = input[0];
                    this.host.data(data);
                    this.baseHost.addClass(this.toThemeProperty('jqx-widget'));
                    this.baseHost.addClass(this.toThemeProperty('jqx-rc-all'));
                    this.baseHost.addClass(this.toThemeProperty('jqx-input-group'));
                    this.baseHost.addClass(this.toThemeProperty('jqx-formattedinput'));
                    var children = this.baseHost.children();
                    $.each(children, function (index) {
                        $(this).addClass(that.toThemeProperty('jqx-input-group-addon'));
                        $(this).removeClass(that.toThemeProperty('jqx-rc-all'));
                        if (index === 0) {
                            $(this).addClass(that.toThemeProperty('jqx-rc-l'));
                        }
                        if (index === children.length - 1) {
                            $(this).addClass(that.toThemeProperty('jqx-rc-r'));
                        }
                        if (this !== that.element) {
                            $(this).addClass(that.toThemeProperty('jqx-fill-state-normal'));
                        }
                        if (this.nodeName.toLowerCase() === 'div') {

                            that.appendSpinButtons = function (child) {
                                that._spinButtonsContainer = $(child);
                                that._spinButtonsContainer.addClass(that.toThemeProperty('jqx-formatted-input-spin-buttons-container'));
                                // spin buttons
                                var spinButtonString = '<div class="' + that.toThemeProperty('jqx-fill-state-normal jqx-formatted-input-spin-button') + '"><div class="' + that.toThemeProperty('jqx-input-icon') + '"></div></div>';
                                that._upbutton = $(spinButtonString);
                                that._spinButtonsContainer.append(that._upbutton);
                                that._downbutton = $(spinButtonString);
                                that._spinButtonsContainer.append(that._downbutton);
                                // arrows
                                that._upArrow = that._upbutton.find('div');
                                that._upArrow.addClass(that.toThemeProperty('jqx-icon-arrow-up'));
                                that._downArrow = that._downbutton.find('div');
                                that._downArrow.addClass(that.toThemeProperty('jqx-icon-arrow-down'));
                                if (that.template) {
                                    that._upbutton.addClass(that.toThemeProperty('jqx-' + that.template));
                                    that._downbutton.addClass(that.toThemeProperty('jqx-' + that.template));
                                }
                                that._spinButtonsStepLong = new that.longObj.math.Long.fromNumber(that.spinButtonsStep);
                            };

                            var appendAddon = function (child) {
                                that._addon = $(child);
                                that._addon.addClass(that.toThemeProperty('jqx-formatted-input-addon'));
                                if (!that._arrow) {
                                    that._arrow = $('<div class="' + that.toThemeProperty('jqx-icon') + ' ' + that.toThemeProperty('jqx-icon-arrow-down') + '"></div>');
                                    that._arrow.appendTo(that._addon);
                                }
                                if (that.template) {
                                    that._addon.addClass(that.toThemeProperty('jqx-' + that.template));
                                }
                            };

                            if (that.rtl === false) {
                                if (!that._spinButtonsContainer && that.spinButtons === true) { // spin buttons
                                    that.appendSpinButtons(this);
                                } else if (!that._addon && that.dropDown === true && ((index === 2) || (index === 1 && that.spinButtons === false))) { // dropdown arrow
                                    appendAddon(this);
                                }
                            } else {
                                if (!that._addon && that.dropDown === true) { // dropdown arrow
                                    appendAddon(this);
                                    if (that.spinButtons === true) {
                                        that._addon.addClass(that.toThemeProperty('jqx-formatted-input-addon-rtl'));
                                    }
                                } else if (!that._spinButtonsContainer && that.spinButtons === true && ((index === 1) || (index === 0 && that.dropDown === false))) { // spin buttons
                                    that.appendSpinButtons(this);
                                    that._spinButtonsContainer.addClass(that.toThemeProperty('jqx-formatted-input-spin-buttons-container-rtl'));
                                    if (that.dropDown === true) {
                                        that._addon.addClass(that.toThemeProperty('jqx-formatted-input-addon-rtl'));
                                    }
                                }
                            }
                        }
                    });
                }
            }

            that._inputAndAddon = that.host;
            if (that.baseHost) {
                if (that._spinButtonsContainer) {
                    that._inputAndAddon = that._inputAndAddon.add(that._spinButtonsContainer);
                }
                if (that._addon) {
                    that._inputAndAddon = that._inputAndAddon.add(that._addon);
                }
            }

            that.removeHandlers();
            this.addHandlers();
            if (this.rtl) {
                this.host.addClass(this.toThemeProperty('jqx-rtl'));
            }
            this.host.attr('role', 'textbox');
            $.jqx.aria(this, 'aria-autocomplete', 'both');
            $.jqx.aria(this, 'aria-disabled', this.disabled);
            $.jqx.aria(this, 'aria-readonly', false);
            $.jqx.aria(this, 'aria-multiline', false);
            $.jqx.aria(this, 'aria-haspopup', true);

            if (that.value !== '' && that.value !== null) {
                if (that.upperCase === true) {
                    that.host.addClass(that.toThemeProperty('jqx-formatted-input-upper-case'));
                } else {
                    that.host.addClass(that.toThemeProperty('jqx-formatted-input-lower-case'));
                }

                if (that._radixNumber === 10 && that.decimalNotation === 'exponential') {
                    that.element.value = that._getDecimalNotation('exponential');
                } else {
                    that.element.value = that.value;
                }
            } else {
                if (that._spinButtonsContainer) {
                    that._spinButtonsContainer.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
                }
            }

            if (that._radixNumber !== 10 && that.min.toString() === '-9223372036854775808') {
                that._minLong = new that.longObj.math.Long.fromNumber(that.min);
            } else {
                that._setMinMax('min');
            }
            if (that._radixNumber !== 10 && that.max.toString() === '9223372036854775807') {
                that._maxLong = new that.longObj.math.Long.fromNumber(that.max);
            } else {
                that._setMinMax('max');
            }

            this._addBarAndLabel((this.baseHost && $(this.baseHost.children()[this.baseHost.children.length - 1])) || this.host);
            if (that.isMaterialized()) {
                setTimeout(function () {

                    if (that.hint) {
                        that.label[0].innerHTML = that.placeHolder;
                    }

                    if (!that.baseHost) {
                        if (that.element.value.length === 0) {
                            that.element.removeAttribute('hint');
                        }
                        else {
                            that.element.setAttribute('hint', true);
                        }

                        that.bar.css('top', '');

                        return;
                    }

                    if (that.element.value.length === 0) {
                        that.baseHost[0].removeAttribute('hint');
                    }
                    else {
                        that.baseHost[0].setAttribute('hint', true);
                    }
                });
            }
        },

        _refreshClasses: function (add) {
            var func = add ? 'addClass' : 'removeClass';
            this.host[func](this.toThemeProperty('jqx-widget-content'));
            this.host[func](this.toThemeProperty('jqx-input'));
            this.host[func](this.toThemeProperty('jqx-formatted-input'));
            this.host[func](this.toThemeProperty('jqx-widget'));
            this.$popup[func](this.toThemeProperty('jqx-popup'));
            if ($.jqx.browser.msie) {
                this.$popup[func](this.toThemeProperty('jqx-noshadow'));
            }
            this.$popup[func](this.toThemeProperty('jqx-input-popup'));
            this.$popup[func](this.toThemeProperty('jqx-menu'));
            this.$popup[func](this.toThemeProperty('jqx-menu-vertical'));
            this.$popup[func](this.toThemeProperty('jqx-menu-dropdown'));
            this.$popup[func](this.toThemeProperty('jqx-widget'));
            this.$popup[func](this.toThemeProperty('jqx-widget-content'));
            if (this.roundedCorners) {
                this.host[func](this.toThemeProperty('jqx-rc-all'));
                this.$popup[func](this.toThemeProperty('jqx-rc-all'));
                if (this.baseHost) {
                    this.baseHost[func](this.toThemeProperty('jqx-rc-all'));
                    if (this.rtl === false) {
                        this.host[func](this.toThemeProperty('jqx-rc-l'));
                        if (this._addon) {
                            this._addon[func](this.toThemeProperty('jqx-rc-r'));
                        }
                    } else {
                        this.host[func](this.toThemeProperty('jqx-rc-r'));
                        if (this._addon) {
                            this._addon[func](this.toThemeProperty('jqx-rc-l'));
                        }
                    }
                }
            } else {
                this.host.removeClass(this.toThemeProperty('jqx-rc-all'));
                this.$popup.removeClass(this.toThemeProperty('jqx-rc-all'));
                if (this.baseHost) {
                    this.baseHost.removeClass(this.toThemeProperty('jqx-rc-all'));
                    if (this.rtl === false) {
                        this.host.removeClass(this.toThemeProperty('jqx-rc-l'));
                        if (this.dropDown) {
                            this._addon.removeClass(this.toThemeProperty('jqx-rc-r'));
                        } else if (this.spinButtons) {
                            this._spinButtonsContainer.removeClass(this.toThemeProperty('jqx-rc-r'));
                        }
                    } else {
                        this.host.removeClass(this.toThemeProperty('jqx-rc-r'));
                        if (this.dropDown) {
                            this._addon.removeClass(this.toThemeProperty('jqx-rc-l'));
                        } else if (this.spinButtons) {
                            this._spinButtonsContainer.removeClass(this.toThemeProperty('jqx-rc-l'));
                        }
                    }
                }
            }
            if (this.disabled) {
                this.host[func](this.toThemeProperty('jqx-fill-state-disabled'));
                if (this.baseHost) {
                    if (this._spinButtonsContainer) {
                        this._spinButtonsContainer[func](this.toThemeProperty('jqx-fill-state-disabled'));
                    }
                    if (this._addon) {
                        this._addon[func](this.toThemeProperty('jqx-fill-state-disabled'));
                    }
                }
            } else {
                this.host.removeClass(this.toThemeProperty('jqx-fill-state-disabled'));
                if (this.baseHost && this.value !== '' && this.value !== null) {
                    if (this._spinButtonsContainer) {
                        this._spinButtonsContainer.removeClass(this.toThemeProperty('jqx-fill-state-disabled'));
                    }
                    if (this._addon) {
                        this._addon.removeClass(this.toThemeProperty('jqx-fill-state-disabled'));
                    }
                }
            }
        },

        selectAll: function () {
            var textbox = this.host;
            setTimeout(function () {
                if ('selectionStart' in textbox[0]) {
                    textbox[0].focus();
                    textbox[0].setSelectionRange(0, textbox[0].value.length);
                }
                else {
                    var range = textbox[0].createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', textbox[0].value.length);
                    range.moveStart('character', 0);
                    range.select();
                }
            }, 10);
        },

        selectLast: function () {
            var textbox = this.host;
            this.selectStart(textbox[0].value.length);
        },

        selectFirst: function () {
            this.selectStart(0);
        },

        selectStart: function (index) {
            var textbox = this.host;
            setTimeout(function () {
                if ('selectionStart' in textbox[0]) {
                    textbox[0].focus();
                    textbox[0].setSelectionRange(index, index);
                }
                else {
                    var range = textbox[0].createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', index);
                    range.moveStart('character', index);
                    range.select();
                }
            }, 10);
        },

        focus: function () {
            try {
                this.host.focus();
                var that = this;
                setTimeout(function () {
                    that.host.focus();
                }, 25);

            }
            catch (error) {
            }
        },

        refresh: function () {
            var that = this;

            this._refreshClasses(false);
            this._refreshClasses(true);

            if (!this.baseHost) {
                if (this.width) {
                    this.host.width(this.width);
                }
                if (this.height) {
                    this.host.height(this.height);
                }
            }
            else {
                if (this.width) {
                    this.baseHost.width(this.width);
                }
                if (this.height) {
                    this.baseHost.height(this.height);
                    var totalWidth = 0;
                    var height = this.baseHost.height() - 2;
                    if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                        this.baseHost.css('display', 'inline-block');
                    }
                    $.each(this.baseHost.children(), function () {
                        if (this.className.indexOf('jqx-input-bar') >= 0) {
                            return true;
                        }
                        if (this.className.indexOf('jqx-input-label') >= 0) {
                            return true;
                        }

                        $(this).css('height', '100%');
                        if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                            $(this).css('height', height + 'px');
                        }
                        if (this !== that.element) {
                            totalWidth += $(this).outerWidth();
                        }
                    });
                    var pixel = (typeof that.width === 'string' && that.width.charAt(that.width.length - 1) === '%') ? 1 : 0;
                    this.host.css('width', this.baseHost.width() - totalWidth - pixel + 'px');
                    if ($.jqx.browser.msie && $.jqx.browser.version < 9) { // Internet Explorer 7 and 8
                        if (that._spinButtonsContainer) {
                            if (that.rtl === false || that.rtl === true && that._addon) {
                                that._spinButtonsContainer.css('border-left-width', '0');
                            }
                        }

                        if (that._addon) {
                            if (that.rtl === false) {
                                that._addon.css('border-left-width', '0');
                            } else {
                                if (!that._spinButtonsContainer) {
                                    that._addon.css('border-right-width', '0');
                                }
                            }
                        }

                        var heightFix = 0;
                        if ($.jqx.browser.version < 8) { // Internet Explorer 7 only
                            var widthFix = 0;
                            var borderSum = parseInt(that.host.css('border-left-width'), 10) + parseInt(that.host.css('border-right-width'), 10);
                            var paddingSum = parseInt(that.host.css('padding-left'), 10) + parseInt(that.host.css('padding-right'), 10);

                            if (that._spinButtonsContainer) {
                                borderSum += parseInt(that._spinButtonsContainer.css('border-left-width'), 10) + parseInt(that._spinButtonsContainer.css('border-right-width'), 10);
                                paddingSum += parseInt(that._spinButtonsContainer.css('padding-left'), 10) + parseInt(that._spinButtonsContainer.css('padding-right'), 10);
                                if (!that._addon) {
                                    widthFix = 2;
                                }
                            }

                            if (that._addon) {
                                borderSum += parseInt(that._addon.css('border-left-width'), 10) + parseInt(that._addon.css('border-right-width'), 10);
                                paddingSum += parseInt(that._addon.css('padding-left'), 10) + parseInt(that._addon.css('padding-right'), 10);
                                if (!that._spinButtonsContainer) {
                                    widthFix = 2;
                                }
                            }

                            that.host.width(that.host.width() - (paddingSum + borderSum) - widthFix);
                            heightFix = 6;
                        }
                        that.host.height(that.baseHost.height() - (parseInt(that.host.css('border-top-width'), 10) + parseInt(that.host.css('border-bottom-width'), 10) + parseInt(that.host.css('padding-top'), 10) + parseInt(that.host.css('padding-bottom'), 10) + heightFix));
                        var newHeight = that.host.height() + 'px';
                        that.host.css('min-height', newHeight);
                        that.host.css('line-height', newHeight);
                    }
                }

                if (that.baseHost && that.bar) {
                    that.bar.css('top', 1 + that.host.outerHeight());
                }
            }

            this.host.attr('disabled', this.disabled);

            if (!this.host.attr('placeholder')) {
                this._refreshPlaceHolder();
            }
        },

        _refreshPlaceHolder: function () {
            var that = this;

            if (this.isMaterialized() && this.hint) {
                this.label[0].innerHTML = this.placeHolder;
                return;
            }

            if ('placeholder' in this.element) {
                this.host.attr('placeHolder', this.placeHolder);
            }
            else {
                var that = this;
                if (this.element.value === '') {
                    this.element.value = this.placeHolder;

                    this.host.focus(function () {
                        if (that.element.value === that.placeHolder) {
                            that.element.value = '';
                        }
                    });

                    this.host.blur(function () {
                        if (that.element.value === '' || that.element.value === that.placeHolder) {
                            that.element.value = that.placeHolder;
                        }
                    });
                }
            }
        },

        destroy: function () {
            this.removeHandlers();
            if (this.baseHost) {
                $.jqx.utilities.resize(this.baseHost, null, true);
                this.baseHost.remove();
            } else {
                $.jqx.utilities.resize(this.host, null, true);
                this.host.remove();
            }
            if (this.$popup) {
                this.$popup.remove();
            }
        },

        propertyChangedHandler: function (object, key, oldvalue, value) {
            if (key === 'placeHolder') {
                object._refreshPlaceHolder();
                return;
            }

            if (key == 'template') {
                if (object.template) {
                    object._upbutton.removeClass(object.toThemeProperty('jqx-' + oldvalue));
                    object._downbutton.removeClass(object.toThemeProperty('jqx-' + oldvalue));
                    object._addon.removeClass(object.toThemeProperty('jqx-' + oldvalue));
                    object._upbutton.addClass(object.toThemeProperty('jqx-' + object.template));
                    object._downbutton.addClass(object.toThemeProperty('jqx-' + object.template));
                    object._addon.addClass(object.toThemeProperty('jqx-' + object.template));
                }
            }

            if (key === 'theme') {
                $.jqx.utilities.setTheme(oldvalue, value, object.host);
                return;
            }

            if (key === 'disabled') {
                $.jqx.aria(object, 'aria-disabled', object.disabled);
            }

            if (key === 'value' && oldvalue.toString().toUpperCase() !== value.toString().toUpperCase()) {
                object.val(value);
                return;
            }

            if (oldvalue !== value && key === 'radix') {
                object._changeRadix(value);
                return;
            }

            if (oldvalue !== value && key === 'decimalNotation' && object._radixNumber === 10) {
                if (value === 'exponential') {
                    object.element.value = object._getDecimalNotation('exponential');
                } else {
                    object.element.value = object._number.toString(10);
                }
            }

            if (oldvalue !== value && (key === 'min' || key === 'max')) {
                object._setMinMax(key);
                object._validateValue(object.value, true);
                object.value = object.element.value;
                return;
            }

            if (oldvalue !== value && (key === 'upperCase') && object.element.value !== '') {
                if (value === true) {
                    object.host.removeClass(object.toThemeProperty('jqx-formatted-input-lower-case'));
                    object.host.addClass(object.toThemeProperty('jqx-formatted-input-upper-case'));
                } else {
                    object.host.removeClass(object.toThemeProperty('jqx-formatted-input-upper-case'));
                    object.host.addClass(object.toThemeProperty('jqx-formatted-input-lower-case'));
                }
                return;
            }

            function showOrHideAddon(addon, value) {
                var inputWidth = object.host.width();
                var addonWidth = addon.outerWidth();
                if (value === false) {
                    object.host.width(inputWidth + addonWidth);
                    addon.hide();
                    if (object.rtl === true) {
                        if (object.spinButtons === true) {
                            object._spinButtonsContainer.addClass(object.toThemeProperty('jqx-formatted-input-spin-buttons-container-rtl-border'));
                        }
                        if (object.dropDown === true) {
                            object._addon.removeClass(object.toThemeProperty('jqx-formatted-input-addon-rtl'));
                        }
                    }
                } else {
                    object.host.width(inputWidth - addonWidth);
                    addon.show();
                    if (object.rtl === true && object.spinButtons === true && object.dropDown === true) {
                        object._spinButtonsContainer.removeClass(object.toThemeProperty('jqx-formatted-input-spin-buttons-container-rtl-border'));
                        object._addon.addClass(object.toThemeProperty('jqx-formatted-input-addon-rtl'));
                    }
                }
            }

            function appendAddon(addon, value) {
                if (value === true) {
                    var newAddon = $('<div></div>');
                    if (object.baseHost) { // the initialization element is a div
                        var currentAddon = object.baseHost.children('div');
                        if ((object.rtl === false && addon === 'spinButtons') || (object.rtl === true && addon === 'dropDown')) {
                            currentAddon.before(newAddon);
                        } else {
                            currentAddon.after(newAddon);
                        }
                        object.render();
                        object.host.width(object.host.width() - newAddon.outerWidth());

                    } else { // the initialization element is an input
                        var id = object.element.id;
                        object.host.removeAttr('id');
                        object.host.wrap('<div id="' + id + '" style="display: inline-block;"></div>');
                        var wrapper = $('#' + id);
                        if (object.rtl === false) {
                            wrapper.append(newAddon);
                        } else {
                            wrapper.prepend(newAddon);
                        }
                        var hostData = object.host.data();
                        hostData.jqxFormattedInput.host = wrapper;
                        hostData.jqxFormattedInput.element = wrapper[0];
                        object.baseHost = wrapper;
                        object.baseHost.data(hostData);
                        object.render();
                        object.refresh();
                    }
                }
            }

            if (key === 'spinButtons') {
                if (oldvalue !== value) {
                    if (object._spinButtonsContainer) { // spin buttons are present in the DOM
                        showOrHideAddon(object._spinButtonsContainer, value);
                    } else { // spin buttons are not present in the DOM
                        appendAddon('spinButtons', value);
                    }
                    return;
                } else {
                    return;
                }
            }

            if (oldvalue !== value && key === 'spinButtonsStep') {
                object._spinButtonsStepLong = new object.longObj.math.Long.fromNumber(value);
            }

            if (key === 'dropDown') {
                if (oldvalue !== value) {
                    if (object._addon) { // dropdown button is present in the DOM
                        showOrHideAddon(object._addon, value);
                    } else { // dropdown button is not present in the DOM
                        appendAddon('dropDown', value);
                    }
                    return;
                } else {
                    return;
                }
            }

            object.refresh();
        },

        select: function (event, ui, radix) {
            var that = this;

            if (!radix) {
                radix = that.$popup.find('.jqx-fill-state-pressed').attr('data-value');
            }

            that._changeRadix(parseInt(radix, 10));
            that._setMaxLength(true);
            that.close();
        },

        val: function (value) {
            var that = this;

            if ((value || value === '') && !(typeof value === 'object' && $.isEmptyObject(value) === true) && value !== 'binary' && value !== 'octal' && value !== 'decimal' && value !== 'exponential' && value !== 'scientific' && value !== 'engineering' && value !== 'hexadecimal') {
                value = value.toString();
                if (value.toUpperCase() !== that.element.value.toString().toUpperCase()) {
                    var oldValue = that.element.value;
                    if (that.upperCase === true) {
                        value = value.toUpperCase();
                    }
                    var arrayValue = value.split('');
                    for (var i = 0; i < arrayValue.length; i++) {
                        // validates the input value
                        if (!that._regex['' + that._radixNumber + ''].test(arrayValue[i])) {
                            return;
                        }
                    }
                    var newValue = that._validateValue(value, true);
                    that._raiseEvent('2', { 'value': newValue, 'oldValue': oldValue, 'radix': that._radixNumber }); // change event
                    that.value = newValue;
                    return newValue;
                } else {
                    return value;
                }
            } else {
                if (value && !(typeof value === 'object' && $.isEmptyObject(value) === true)) {
                    if (value === 'exponential' || value === 'scientific' || value === 'engineering') {
                        return that._getDecimalNotation(value);
                    } else {
                        var radix = that._getRadix(value);
                        return that._number.toString(radix);
                    }
                } else {
                    return that.element.value;
                }
            }
        },

        // changes the radix (numeral system)
        _changeRadix: function (radix) {
            var that = this;

            var newRadix = that._getRadix(radix);
            var newValue = that.value !== '' ? that._number.toString(newRadix) : '';
            var oldRadix = that.radix;
            var oldValue = that.value;

            that.radix = radix;
            that._radixNumber = newRadix;

            that.element.value = newValue;
            that.value = newValue;

            this._raiseEvent('3', { 'radix': radix, 'oldRadix': oldRadix, 'value': newValue, 'oldValue': oldValue }); // radixChange event
        },

        _raiseEvent: function (id, arg) {
            if (arg === undefined) {
                arg = { owner: null };
            }

            var evt = this.events[id];
            arg.owner = this;

            var event = new $.Event(evt);
            event.owner = this;
            if (id == 2) {
                arg.type = this.changeType;
                this.changeType = null;
            }
            event.args = arg;
            if (event.preventDefault) {
                event.preventDefault();
            }

            var result;
            if (this.baseHost) {
                result = this.baseHost.trigger(event);
            } else {
                result = this.host.trigger(event);
            }
            return result;
        },

        open: function () {
            var that = this;

            that._setPopupOptions();
            that._render(that._popupOptions);

            if ($.jqx.isHidden(this.host)) {
                return;
            }

            var position;
            if (that.baseHost) {
                position = $.extend({}, that.baseHost.coord(true), {
                    height: that.baseHost[0].offsetHeight
                });
            } else {
                position = $.extend({}, that.host.coord(true), {
                    height: that.host[0].offsetHeight
                });
            }

            if (this.$popup.parent().length === 0) {
                var popupId = this.element.id + '_' + 'popup';
                this.$popup[0].id = popupId;
                $.jqx.aria(this, 'aria-owns', popupId);
            }

            this.$popup
            .appendTo($(document.body))
            .css({ position: 'absolute', zIndex: this.popupZIndex, top: position.top + position.height, left: position.left })
            .show();
            var height = 0;
            var children = this.$popup.children();
            $.each(children, function () {
                height += $(this).outerHeight(true) - 1;
            });
            this.$popup.height(height);

            this._opened = true;
            if (that.baseHost) {
                that._addon.addClass(that.toThemeProperty('jqx-fill-state-pressed jqx-combobox-arrow-selected'));
                that._arrow.addClass(that.toThemeProperty('jqx-icon-arrow-down-selected'));
            }
            this._raiseEvent('0', { popup: this.$popup }); // open event
            $.jqx.aria(this, 'aria-expanded', true);
            return this;
        },

        close: function () {
            var that = this;

            this.$popup.hide();
            this._opened = false;
            if (that.baseHost) {
                that._addon.removeClass(that.toThemeProperty('jqx-fill-state-pressed jqx-combobox-arrow-selected'));
                that._arrow.removeClass(that.toThemeProperty('jqx-icon-arrow-down-selected'));
            }
            this._raiseEvent('1', { popup: this.$popup }); // close event
            $.jqx.aria(this, 'aria-expanded', false);
            return this;
        },

        _render: function (items) {
            var that = this;

            items = $(items).map(function (i, item) {
                var itemValue = item;
                var currentRadix;
                switch (i) {
                    case 0:
                        currentRadix = 2;
                        break;
                    case 1:
                        currentRadix = 8;
                        break;
                    case 2:
                        currentRadix = 10;
                        break;
                    case 3:
                        currentRadix = 16;
                        break;
                }
                i = $(that.item).attr('data-value', currentRadix);
                i.find('a').html(itemValue).attr('data-value', currentRadix);

                var rtlClass = '';
                if (that.rtl) {
                    rtlClass = ' ' + that.toThemeProperty('jqx-rtl') + ' ' + that.toThemeProperty('jqx-formatted-input-item-rtl');
                }
                i[0].className = that.toThemeProperty('jqx-item') + ' ' + that.toThemeProperty('jqx-menu-item') + ' ' + that.toThemeProperty('jqx-formatted-input-item') + ' ' + that.toThemeProperty('jqx-rc-all') + rtlClass;
                return i[0];
            });

            var selectedIndex;

            switch (that._radixNumber) {
                case 2:
                    selectedIndex = 0;
                    break;
                case 8:
                    selectedIndex = 1;
                    break;
                case 10:
                    selectedIndex = 2;
                    break;
                case 16:
                    selectedIndex = 3;
                    break;
            }

            // adds a pressed effect to the selected numeral system option
            items.eq(selectedIndex).addClass(this.toThemeProperty('jqx-fill-state-pressed'));
            this.$popup.html(items);
            if (!this.dropDownWidth) {
                if (that.baseHost) {
                    var pixel = (typeof that.width === 'string' && that.width.charAt(that.width.length - 1) === '%') ? 1 : 0;
                    this.$popup.width(this.baseHost.outerWidth() - 6 - pixel);
                } else {
                    this.$popup.width(this.host.outerWidth() - 6);
                }
            }
            else {
                this.$popup.width(this.dropDownWidth);
            }

            return this;
        },

        next: function () {
            var active = this.$popup.find('.jqx-fill-state-pressed').removeClass(this.toThemeProperty('jqx-fill-state-pressed')),
                next = active.next();

            if (!next.length) {
                next = $(this.$popup.find('li')[0]);
            }

            next.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
        },

        prev: function () {
            var active = this.$popup.find('.jqx-fill-state-pressed').removeClass(this.toThemeProperty('jqx-fill-state-pressed')),
                prev = active.prev();

            if (!prev.length) {
                prev = this.$popup.find('li').last();
            }

            prev.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
        },

        addHandlers: function () {
            var that = this;

            this.addHandler(this.host, 'focus', $.proxy(this.onFocus, this));
            this.addHandler(this.host, 'blur', $.proxy(this.onBlur, this));
            this.addHandler(this.host, 'keypress', $.proxy(this.keypress, this));
            this.addHandler(this.host, 'keyup', $.proxy(this.keyup, this));
            this.addHandler(this.host, 'keydown', $.proxy(this.keydown, this));
            this.addHandler(this.$popup, 'mousedown', $.proxy(this.click, this));
            if (this.host.on) {
                this.$popup.on('mouseenter', 'li', $.proxy(this.mouseenter, this));
            }
            else {
                this.$popup.bind('mouseenter', 'li', $.proxy(this.mouseenter, this));
            }
            this.addHandler(this.host, 'change', function (e) {
                e.stopPropagation();
                e.preventDefault();
            });

            if (that.baseHost) {
                var id = that.baseHost.attr('id');

                // spin buttons handlers
                if (that._spinButtonsContainer) {
                    var buttons = that._upbutton.add(that._downbutton);

                    that.addHandler(that._upbutton, 'mousedown.jqxFormattedInputSpinButtonUp' + id, function () {
                        if (!that.disabled && that.value !== '' && that.value !== null) {
                            that._upbutton.addClass(that.toThemeProperty('jqx-fill-state-pressed'));
                            that.changeType = 'mouse';
                            that._incrementOrDecrement('add');
                        }
                    });

                    that.addHandler(that._upbutton, 'mouseup.jqxFormattedInputSpinButtonUp' + id, function () {
                        if (!that.disabled && that.value !== '' && that.value !== null) {
                            that._upbutton.removeClass(that.toThemeProperty('jqx-fill-state-pressed'));
                        }
                    });

                    that.addHandler(that._downbutton, 'mousedown.jqxFormattedInputSpinButtonDown' + id, function () {
                        if (!that.disabled && that.value !== '' && that.value !== null) {
                            that.changeType = 'mouse';
                            that._downbutton.addClass(that.toThemeProperty('jqx-fill-state-pressed'));
                            that._incrementOrDecrement('subtract');
                        }
                    });

                    that.addHandler(that._downbutton, 'mouseup.jqxFormattedInputSpinButtonDown' + id, function () {
                        if (!that.disabled && that.value !== '' && that.value !== null) {
                            that._downbutton.removeClass(that.toThemeProperty('jqx-fill-state-pressed'));
                        }
                    });

                    that.addHandler(buttons, 'mouseenter.jqxFormattedInputSpinButtons' + id, function (e) {
                        if (!that.disabled && that.value !== '' && that.value !== null) {
                            var target = $(e.target);
                            if (target.hasClass('jqx-icon-arrow-up') || target.children().hasClass('jqx-icon-arrow-up')) {
                                that._upbutton.addClass(that.toThemeProperty('jqx-fill-state-hover'));
                                that._upArrow.addClass(that.toThemeProperty('jqx-icon-arrow-up-hover'));
                            } else {
                                that._downbutton.addClass(that.toThemeProperty('jqx-fill-state-hover'));
                                that._downArrow.addClass(that.toThemeProperty('jqx-icon-arrow-down-hover'));
                            }
                        }
                    });
                    that.addHandler(buttons, 'mouseleave.jqxFormattedInputSpinButtons' + id, function (e) {
                        if (!that.disabled && that.value !== '' && that.value !== null) {
                            var target = $(e.target);
                            if (target.hasClass('jqx-icon-arrow-up') || target.children().hasClass('jqx-icon-arrow-up')) {
                                that._upbutton.removeClass(that.toThemeProperty('jqx-fill-state-hover'));
                                that._upArrow.removeClass(that.toThemeProperty('jqx-icon-arrow-up-hover'));
                            } else {
                                that._downbutton.removeClass(that.toThemeProperty('jqx-fill-state-hover'));
                                that._downArrow.removeClass(that.toThemeProperty('jqx-icon-arrow-down-hover'));
                            }
                        }
                    });

                    that.addHandler($('body'), 'mouseup.jqxFormattedInputSpinButtons' + id, function () {
                        that._upbutton.add(that._downbutton).removeClass(that.toThemeProperty('jqx-fill-state-pressed'));
                    });
                }

                // dropdown arrow handlers
                if (that._addon) {
                    that.addHandler(that._addon, 'click.jqxFormattedInputAddon' + id, function () {
                        if (!that.disabled) {
                            if (that._opened) {
                                that.close();
                            } else {
                                that.open();
                            }
                        }
                    });
                    that.addHandler(that._addon, 'mouseenter.jqxFormattedInputAddon' + id, function () {
                        if (!that.disabled && that.value !== '' && that.value !== null) {
                            that._addon.addClass(that.toThemeProperty('jqx-fill-state-hover jqx-combobox-arrow-hover'));
                            that._arrow.addClass(that.toThemeProperty('jqx-icon-arrow-down-hover'));
                        }
                    });
                    that.addHandler(that._addon, 'mouseleave.jqxFormattedInputAddon' + id, function () {
                        if (!that.disabled && that.value !== '' && that.value !== null) {
                            that._addon.removeClass(that.toThemeProperty('jqx-fill-state-hover jqx-combobox-arrow-hover'));
                            that._arrow.removeClass(that.toThemeProperty('jqx-icon-arrow-down-hover'));
                        }
                    });
                    that.addHandler(that._addon.add(that._arrow), 'blur.jqxFormattedInputAddon' + id, function () {
                        if (that._opened && !that.disabled) {
                            that.close();
                        }
                    });
                }

                // fluid size support
                $.jqx.utilities.resize(that.baseHost, function () {
                    if (that._opened === true) {
                        that.close();
                    }

                    var addonsWidth = 0;
                    if (that._spinButtonsContainer) {
                        addonsWidth += that._spinButtonsContainer.outerWidth();
                    }
                    if (that._addon) {
                        addonsWidth += that._addon.outerWidth();
                    }
                    that.host.css('width', that.baseHost.width() - addonsWidth - 1);
                });
            }
        },

        removeHandlers: function () {
            var that = this;

            this.removeHandler(this.host, 'focus', $.proxy(this.onFocus, this));
            this.removeHandler(this.host, 'blur', $.proxy(this.onBlur, this));
            this.removeHandler(this.host, 'keypress', $.proxy(this.keypress, this));
            this.removeHandler(this.host, 'keyup', $.proxy(this.keyup, this));
            this.removeHandler(this.host, 'keydown', $.proxy(this.keydown, this));
            this.removeHandler(this.$popup, 'mousedown', $.proxy(this.click, this));
            if (this.host.off) {
                this.$popup.off('mouseenter', 'li', $.proxy(this.mouseenter, this));
            }
            else {
                this.$popup.unbind('mouseenter', 'li', $.proxy(this.mouseenter, this));
            }
            if (that.baseHost) {
                var id = that.baseHost.attr('id');

                if (that._spinButtonsContainer) {
                    var buttons = that._upbutton.add(that._downbutton);

                    that.removeHandler(that._upbutton, 'mousedown.jqxFormattedInputSpinButtonUp' + id);
                    that.removeHandler(that._upbutton, 'mouseup.jqxFormattedInputSpinButtonUp' + id);
                    that.removeHandler(that._downbutton, 'mousedown.jqxFormattedInputSpinButtonDown' + id);
                    that.removeHandler(that._downbutton, 'mouseup.jqxFormattedInputSpinButtonDown' + id);
                    that.removeHandler(buttons, 'mouseenter.jqxFormattedInputSpinButtons' + id);
                    that.removeHandler(buttons, 'mouseleave.jqxFormattedInputSpinButtons' + id);
                    that.removeHandler($('body'), 'mouseup.jqxFormattedInputSpinButtons' + id);
                }

                if (that._addon) {
                    that.removeHandler(that._addon, 'click.jqxFormattedInputAddon' + id);
                    that.removeHandler(that._addon, 'mouseenter.jqxFormattedInputAddon' + id);
                    that.removeHandler(that._addon, 'mouseleave.jqxFormattedInputAddon' + id);
                    that.removeHandler(that._addon.add(that._arrow), 'blur.jqxFormattedInputAddon' + id);
                }
            }
        },

        move: function (e) {
            if (!this._opened) {
                return;
            }

            switch (e.keyCode) {
                case 9: // tab
                case 13: // enter
                case 27: // escape
                    e.preventDefault();
                    break;

                case 38: // up arrow
                    e.preventDefault();
                    this.prev();
                    break;

                case 40: // down arrow
                    e.preventDefault();
                    this.next();
                    break;
            }

            e.stopPropagation();
        },

        keydown: function (e) {
            var that = this;
            that.changeType = 'keyboard';
            this.suppressKeyPressRepeat = ~$.inArray(e.keyCode, [40, 38, 9, 13, 27]);
            this.move(e);

            var keyCode = !e.charCode ? e.which : e.charCode,
                key = String.fromCharCode(keyCode);

            if (keyCode >= 96 && keyCode <= 105) { // for numeric keypad keys
                key = keyCode - 96;
                keyCode = keyCode - 48;
            }

            if (e.altKey === true) {
                if (keyCode === 40) { // Alt + Down arrow
                    if (that._addon) {
                        this.open();
                    }
                    return;
                } else if (keyCode === 38) { // Alt + Up arrow
                    if (that._addon) {
                        this.close();
                    }
                    return;
                }
            }

            if (e.ctrlKey === true) {
                if (keyCode === 67) { // Ctrl + C (Copy)
                    return;
                } else if (keyCode === 65) { // Ctrl + A (Select All)
                    that.selectAll();
                    return;
                }
            }

            // validates the entered character
            var specialCharacters = [8, 9, 13, 37, 38, 39, 40, 46, 88]; // backspace, tab, enter, left arrow, top arrow, right arrow, bottom arrow, delete, x

            var rInput = that._regex['' + that._radixNumber + ''];
            if (specialCharacters.indexOf(keyCode) === -1 && (!rInput.test(key) && !rInput.test(e['key']) && !rInput.test(e['char']))) {
                e.preventDefault();
                return false;
            } else {
                var selectionStart = that.host[0].selectionStart;
                var selectionLength = that.host[0].selectionEnd - selectionStart;

                var position = this._getCaretPosition(this.host[0]);
                var oldValue = this.element.value;
                var newValue = oldValue.split('');
                if (keyCode === 8) { // backspace
                    if (selectionLength > 0) {
                        newValue.splice(selectionStart, selectionLength);
                    } else {
                        newValue.splice(position - 1, 1);
                    }
                } else if (keyCode === 46) { // delete
                    if (selectionLength > 0) {
                        newValue.splice(selectionStart, selectionLength);
                    } else {
                        newValue.splice(position, 1);
                    }
                } else if (keyCode === 88) {
                    if (e.ctrlKey === true) { // Ctrl + X (Cut)
                        if (selectionLength > 0) {
                            newValue.splice(selectionStart, selectionLength);
                        }
                    } else {
                        e.preventDefault();
                    }
                } else if (keyCode === 189) { // minus
                    if (newValue[0] === '-') {
                        newValue.splice(0, 1);
                        that._minus = false;
                    } else {
                        newValue.splice(0, 0, '-');
                        that._minus = true;
                    }
                    e.preventDefault();
                } else {
                    var newCharacter = specialCharacters.indexOf(keyCode) === -1 ? key : '';
                    if (selectionLength > 0) {
                        newValue.splice(selectionStart, selectionLength);
                        newValue.splice(selectionStart, 0, newCharacter);
                    } else {
                        newValue.splice(position, 0, newCharacter);
                    }
                }
                newValue = newValue.join('');
                if (newValue !== oldValue) {
                    var isValid = that._validateValue(newValue, false);
                    if (isValid === false) {
                        that._inputAndAddon.addClass(that.toThemeProperty('jqx-input-invalid'));
                    } else {
                        that._inputAndAddon.removeClass(that.toThemeProperty('jqx-input-invalid'));
                    }
                }
            }
        },

        keypress: function (e) {
            var that = this;

            if (that.suppressKeyPressRepeat) {
                return;
            }
            that.move(e);
        },

        keyup: function (e) {
            var that = this;

            switch (e.keyCode) {
                case 40: // down arrow
                case 38: // up arrow
                case 16: // shift
                case 17: // ctrl
                case 18: // alt
                    break;

                case 9: // tab
                case 13: // enter
                    if (this._opened) {
                        this.select(e, this);
                    } else {
                        that._change();
                    }
                    break;

                case 27: // escape
                    if (!this._opened) {
                        return;
                    }
                    this.close();
                    break;

                case 189: // minus
                    if (that._radixNumber === 10) {
                        if (that._minus === true) {
                            that.element.value = '-' + that.element.value;
                        } else {
                            that.element.value = that.element.value.slice(1);
                        }
                    }
                    break;
            }

            e.stopPropagation();
            e.preventDefault();

            if (that.element.value !== '') {
                if (that.upperCase) {
                    that.host.addClass(that.toThemeProperty('jqx-formatted-input-upper-case'));
                } else {
                    that.host.addClass(that.toThemeProperty('jqx-formatted-input-lower-case'));
                }
                if (that._spinButtonsContainer) {
                    that._spinButtonsContainer.removeClass(that.toThemeProperty('jqx-fill-state-disabled'));
                }
            } else {
                that.host.removeClass(that.toThemeProperty('jqx-formatted-input-upper-case jqx-formatted-input-lower-case'));
                if (that._spinButtonsContainer) {
                    that._spinButtonsContainer.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
                }
            }

            if (that.isMaterialized() && that.hint) {
                setTimeout(function () {
                    that.label[0].innerHTML = that.placeHolder;
                    if (that.baseHost) {
                        if (that.element.value.length === 0) {
                            that.baseHost[0].removeAttribute('hint');
                        }
                        else {
                            that.baseHost[0].setAttribute('hint', true);
                        }
                    }
                });
            }
        },

        _getCaretPosition: function (input) {
            var CaretPos = 0;
            if (document.selection) {
                input.focus();
                var Sel = document.selection.createRange();
                Sel.moveStart('character', -input.value.length);
                CaretPos = Sel.text.length;
            }
            else if (input.selectionStart || input.selectionStart === '0') {
                CaretPos = input.selectionStart;
            }
            return (CaretPos);
        },

        onBlur: function () {
            var that = this;
            if (that._opened) {
                that.close();
            }
            that._setMaxLength();
            that._inputAndAddon.removeClass(that.toThemeProperty('jqx-fill-state-focus'));
            that._change();
            if (that._radixNumber === 10 && that.decimalNotation === 'exponential') {
                that.element.value = that._getDecimalNotation('exponential');
            }
            that._refreshPlaceHolder();
        },

        onFocus: function () {
            var that = this;
            that._setMaxLength(true);
            that._inputAndAddon.addClass(that.toThemeProperty('jqx-fill-state-focus'));
            if (that._radixNumber === 10 && that.decimalNotation === 'exponential') {
                that.element.value = that._number.toString(10);
            }
        },

        click: function (e) {
            e.stopPropagation();
            e.preventDefault();
            var radix = $(e.target).attr('data-value');
            this.select(e, this, radix);
        },

        mouseenter: function (e) {
            this.$popup.find('.jqx-fill-state-pressed').removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
            $(e.currentTarget).addClass(this.toThemeProperty('jqx-fill-state-pressed'));
        },

        // change event handler
        _change: function () {
            var that = this;

            var oldValue = that.value;
            var newValue = that._validateValue(that.element.value, true);
            that._inputAndAddon.removeClass(that.toThemeProperty('jqx-input-invalid'));
            if (newValue.toUpperCase() !== oldValue.toString().toUpperCase()) {
                that._raiseEvent('2', { 'value': newValue, 'oldValue': oldValue, 'radix': that._radixNumber }); // change event
                that.value = newValue;
            }
        },

        // gets the internal numeric radix based on the radix property
        _getRadix: function (radix) {
            switch (radix) {
                case 10:
                case 'decimal':
                    return 10;
                case 2:
                case 'binary':
                    return 2;
                case 8:
                case 'octal':
                    return 8;
                case 16:
                case 'hexadecimal':
                    return 16;
            }
        },

        // sets the pop-up list radix options
        _setPopupOptions: function () {
            var that = this;

            that._popupOptions = new Array();

            if (that.value !== '') {
                that._popupOptions.push(that._number.toString(2) + ' <em>(BIN)</em>');
                that._popupOptions.push(that._number.toString(8) + ' <em>(OCT)</em>');
                that._popupOptions.push(that._number.toString(10) + ' <em>(DEC)</em>');
                that._popupOptions.push(that._number.toString(16) + ' <em>(HEX)</em>');
            } else {
                that._popupOptions.push('BIN');
                that._popupOptions.push('OCT');
                that._popupOptions.push('DEC');
                that._popupOptions.push('HEX');
            }
        },

        // validates the current value
        _validateValue: function (value, set) {
            var that = this;
            if (value !== '') {
                var numberToValidate = new that.longObj.math.Long.fromString((value).toString(), that._radixNumber);

                if (numberToValidate.lessThan(that._minLong)) {
                    if (set) {
                        that._number = that._minLong;
                        var min = that._minLong.toString(that._radixNumber);
                        if (that._radixNumber === 16 && that.upperCase === true) {
                            min = min.toUpperCase();
                        }
                        that.element.value = min;
                        return min;
                    } else {
                        return false;
                    }
                } else if (numberToValidate.greaterThan(that._maxLong)) {
                    if (set) {
                        that._number = that._maxLong;
                        var max = that._maxLong.toString(that._radixNumber);
                        if (that._radixNumber === 16 && that.upperCase === true) {
                            max = max.toUpperCase();
                        }
                        that.element.value = max;
                        return max;
                    } else {
                        return false;
                    }
                } else {
                    if (set) {
                        that._number = numberToValidate;
                        that.element.value = value;
                        return value;
                    } else {
                        return true;
                    }
                }
            } else {
                if (set) {
                    that.element.value = '';
                    return value;
                } else {
                    return true;
                }
            }
        },

        // returns the decimal equivalent of a negative binary, octal or hexadecimal number
        _getNegativeDecimal: function (value, radix) {
            var negativeBinary = value;

            if (radix === 8) {
                var threeBits = new Array();
                for (var i = 0; i < 11; i++) {
                    var threeBit = parseInt(value.charAt(i), 8).toString(2);
                    while (threeBit.length !== 3) {
                        threeBit = '0' + threeBit;
                    }

                    threeBits.push(threeBit);
                }
                negativeBinary = threeBits.join('');
                if (negativeBinary.charAt(0) === '0') {
                    negativeBinary = negativeBinary.slice(1);
                }

            } else if (radix === 16) {
                var bytes = new Array();
                for (var j = 0; j < 8; j++) {
                    var currentByte = parseInt(value.charAt(j), 16).toString(2);
                    while (currentByte.length !== 4) {
                        currentByte = '0' + currentByte;
                    }

                    bytes.push(currentByte);
                }
                negativeBinary = bytes.join('');
            }

            var negativeDecimal = '';
            for (var k = 0; k < negativeBinary.length; k++) {
                var currentDigit = negativeBinary.charAt(k) === '1' ? '0' : '1';
                negativeDecimal += currentDigit;
            }
            negativeDecimal = (parseInt(negativeDecimal, 2) + 1) * -1;
            return negativeDecimal;
        },

        // sets the input's max length based on the radix
        _setMaxLength: function (focus) {
            var that = this;
            var max;

            if (focus === true) {
                switch (that._radixNumber) {
                    case 2:
                        max = 64;
                        break;
                    case 8:
                        max = 22;
                        break;
                    case 10:
                        max = 20;
                        break;
                    case 16:
                        max = 16;
                        break;
                }
            } else {
                max = 524288; // default value
            }

            that.host.attr('maxlength', max);
        },

        // sets or updates the internal representations of the min and max properties
        _setMinMax: function (key) {
            var that = this;
            that['_' + key + 'Long'] = new that.longObj.math.Long.fromString((that[key]).toString(), that._radixNumber);
        },

        // returns a decimal value in a specific notation
        _getDecimalNotation: function (outputNotation) {
            var that = this;

            var value = that._number.toString(10);

            function defaultToExponential(defaultValue) {
                if (defaultValue === '0') {
                    return parseInt(defaultValue, 10).toExponential();
                }

                var sign;

                if (defaultValue.charAt(0) === '-') {
                    sign = '-';
                    defaultValue = defaultValue.slice(1, defaultValue.length);
                } else {
                    sign = '';
                }

                var power = defaultValue.length - 1;

                while (defaultValue.charAt(defaultValue.length - 1) === '0') {
                    defaultValue = defaultValue.slice(0, defaultValue.length - 1);
                }

                var decimal = defaultValue.slice(1, defaultValue.length);
                if (decimal !== '') {
                    decimal = '.' + decimal;
                }

                return sign + '' + defaultValue.charAt(0) + decimal + 'e+' + power;
            }

            function exponentialToScientific(exponentialValue) {
                var indexOfE = exponentialValue.indexOf('e');
                var power = exponentialValue.slice(indexOfE + 1);
                var scientificValue = exponentialValue.slice(0, indexOfE + 1);
                scientificValue = scientificValue.replace('e', '10');
                scientificValue += that._toSuperScript(power);
                scientificValue = scientificValue.replace('+', '');

                return scientificValue;
            }

            function exponentialToEngineering(exponentialValue) {
                var indexOfE = exponentialValue.indexOf('e');
                var power = exponentialValue.slice(indexOfE + 1);
                var coefficient = exponentialValue.slice(0, indexOfE);
                var remainderPower = parseInt(power, 10) % 3;
                coefficient = coefficient * Math.pow(10, remainderPower);
                var floatFix = exponentialValue.slice(0, indexOfE).length - remainderPower - 2;
                if (floatFix >= 0) {
                    coefficient = coefficient.toFixed(floatFix);
                }
                var engineeringValue = coefficient + '10' + that._toSuperScript((parseInt(power, 10) - remainderPower).toString());

                return engineeringValue;
            }

            var exponentialValue = defaultToExponential(value);
            if (outputNotation === 'scientific') {
                return exponentialToScientific(exponentialValue);
            } else if (outputNotation === 'engineering') {
                return exponentialToEngineering(exponentialValue);
            } else {
                return exponentialValue;
            }
        },

        // converts a number to superscript
        _toSuperScript: function (value, supToNormal) {
            var chars = '-0123456789';
            var sup = '';
            var result = '';

            for (var i = 0; i < value.length; i++) {
                if (supToNormal === true) {
                    var m = sup.indexOf(value.charAt(i));
                    result += (m !== -1 ? chars[m] : value[i]);
                } else {
                    var n = chars.indexOf(value.charAt(i));
                    result += (n !== -1 ? sup[n] : value[i]);
                }
            }
            return result;
        },

        // increments or decrements the number in the input
        _incrementOrDecrement: function (func) {
            var that = this;

            if (that._number.toString(that._radixNumber) !== that.element.value) {
                that._number = new that.longObj.math.Long.fromString(that.element.value, that._radixNumber);
            }
            that._number = that._number[func](that._spinButtonsStepLong);
            that.element.value = that._number.toString(that._radixNumber);
            that._change();
        },

        // converts a positive binary to a 64-bit negative binary, octal or hexadecimal using two's complement
        _negativeBinary: function (result, radix) {
            var reversedResult = '';
            result = result.slice(1, result.length); // removes the minus
            while (result.length < 64) {
                result = '0' + result;
            }

            for (var i = 0; i < result.length; i++) {
                var reversedDigit = result.charAt(i) === '1' ? '0' : '1';
                reversedResult += reversedDigit;
            }

            var plusOne = true;
            var finalResult = '';

            for (var j = reversedResult.length - 1; j >= 0; j--) {
                var currentDigit = reversedResult.charAt(j);
                var newDigit;

                if (currentDigit === '0') {
                    if (plusOne === true) {
                        newDigit = '1';
                        plusOne = false;
                    } else {
                        newDigit = '0';
                    }
                } else {
                    if (plusOne === true) {
                        newDigit = '0';
                    } else {
                        newDigit = '1';
                    }
                }
                finalResult = newDigit + '' + finalResult;
            }

            switch (radix) {
                case 2:
                    return finalResult;
                case 8:
                    finalResult = '00' + finalResult;
                    var octResult = '';
                    for (var k = 22; k >= 1; k--) {
                        var currentOct = finalResult[k * 3 - 3] + '' + finalResult[k * 3 - 2] + '' + finalResult[k * 3 - 1];
                        octResult = parseInt(currentOct, 2).toString(8) + '' + octResult;
                    }
                    return octResult;
                case 16:
                    var hexResult = '';
                    for (var l = 16; l >= 1; l--) {
                        var currentHex = finalResult[l * 4 - 4] + '' + finalResult[l * 4 - 3] + '' + finalResult[l * 4 - 2] + '' + finalResult[l * 4 - 1];
                        hexResult = parseInt(currentHex, 2).toString(16) + '' + hexResult;
                    }
                    return hexResult;
            }
        },

        // enables 64-bit number support
        _Long: function () {
            var that = this;

            that.longObj = new Object();
            var longObj = that.longObj;
            longObj.math = new Object();
            longObj.math.Long = new Object();

            longObj.math.Long = function (low, high) {
                this.lowBits = low | 0;
                this.highBits = high | 0;
            };

            longObj.math.Long.IntCache = {};

            longObj.math.Long.fromInt = function (value) {
                if (-128 <= value && value < 128) {
                    var cachedObj = longObj.math.Long.IntCache[value];
                    if (cachedObj) {
                        return cachedObj;
                    }
                }

                var obj = new longObj.math.Long(value | 0, value < 0 ? -1 : 0);
                if (-128 <= value && value < 128) {
                    longObj.math.Long.IntCache[value] = obj;
                }
                return obj;
            };

            longObj.math.Long.fromNumber = function (value) {
                if (isNaN(value) || !isFinite(value)) {
                    return longObj.math.Long.ZERO;
                } else if (value <= -longObj.math.Long.TWO_PWR_63_DBL_) {
                    return longObj.math.Long.MIN_VALUE;
                } else if (value + 1 >= longObj.math.Long.TWO_PWR_63_DBL_) {
                    return longObj.math.Long.MAX_VALUE;
                } else if (value < 0) {
                    return longObj.math.Long.fromNumber(-value).negate();
                } else {
                    return new longObj.math.Long(
        (value % longObj.math.Long.TWO_PWR_32_DBL_) | 0,
        (value / longObj.math.Long.TWO_PWR_32_DBL_) | 0);
                }
            };

            longObj.math.Long.fromBits = function (lowBits, highBits) {
                return new longObj.math.Long(lowBits, highBits);
            };

            longObj.math.Long.fromString = function (str, optRadix) {
                if (str.length === 0) {
                    throw new Error('number format error: empty string');
                }

                var radix = optRadix || 10;
                if (radix < 2 || 36 < radix) {
                    throw new Error('radix out of range: ' + radix);
                }

                if (str.charAt(0) === '-') {
                    return longObj.math.Long.fromString(str.substring(1), radix).negate();
                } else if (str.indexOf('-') >= 0) {
                    throw new Error('number format error: interior "-" character: ' + str);
                }

                var radixToPower = longObj.math.Long.fromNumber(Math.pow(radix, 8));

                var result = longObj.math.Long.ZERO;
                for (var i = 0; i < str.length; i += 8) {
                    var size = Math.min(8, str.length - i);
                    var value = parseInt(str.substring(i, i + size), radix);
                    if (size < 8) {
                        var power = longObj.math.Long.fromNumber(Math.pow(radix, size));
                        result = result.multiply(power).add(longObj.math.Long.fromNumber(value));
                    } else {
                        result = result.multiply(radixToPower);
                        result = result.add(longObj.math.Long.fromNumber(value));
                    }
                }
                return result;
            };

            longObj.math.Long.TWO_PWR_16_DBL_ = 1 << 16;
            longObj.math.Long.TWO_PWR_24_DBL_ = 1 << 24;
            longObj.math.Long.TWO_PWR_32_DBL_ =
    longObj.math.Long.TWO_PWR_16_DBL_ * longObj.math.Long.TWO_PWR_16_DBL_;
            longObj.math.Long.TWO_PWR_31_DBL_ =
    longObj.math.Long.TWO_PWR_32_DBL_ / 2;
            longObj.math.Long.TWO_PWR_48_DBL_ =
    longObj.math.Long.TWO_PWR_32_DBL_ * longObj.math.Long.TWO_PWR_16_DBL_;
            longObj.math.Long.TWO_PWR_64_DBL_ =
    longObj.math.Long.TWO_PWR_32_DBL_ * longObj.math.Long.TWO_PWR_32_DBL_;
            longObj.math.Long.TWO_PWR_63_DBL_ =
    longObj.math.Long.TWO_PWR_64_DBL_ / 2;
            longObj.math.Long.ZERO = longObj.math.Long.fromInt(0);
            longObj.math.Long.ONE = longObj.math.Long.fromInt(1);
            longObj.math.Long.NEG_ONE = longObj.math.Long.fromInt(-1);
            longObj.math.Long.MAX_VALUE =
    longObj.math.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);
            longObj.math.Long.MIN_VALUE = longObj.math.Long.fromBits(0, 0x80000000 | 0);
            longObj.math.Long.TWO_PWR_24_ = longObj.math.Long.fromInt(1 << 24);

            longObj.math.Long.prototype.toInt = function () {
                return this.lowBits;
            };

            longObj.math.Long.prototype.toNumber = function () {
                return this.highBits * longObj.math.Long.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned();
            };

            longObj.math.Long.prototype.toString = function (optRadix) {
                var radix = optRadix || 10;
                if (radix < 2 || 36 < radix) {
                    throw new Error('radix out of range: ' + radix);
                }

                if (this.isZero()) {
                    return '0';
                }

                var rem, result;

                if (this.isNegative()) {
                    if (this.equals(longObj.math.Long.MIN_VALUE)) {
                        var radixLong = longObj.math.Long.fromNumber(radix);
                        var div = this.div(radixLong);
                        rem = div.multiply(radixLong).subtract(this);
                        return div.toString(radix) + rem.toInt().toString(radix);
                    } else {
                        switch (radix) {
                            case 2:
                            case 8:
                            case 16:
                                result = '-' + this.negate().toString(2);
                                return that._negativeBinary(result, radix);
                            default:
                                result = '-' + this.negate().toString(radix);
                                return result;
                        }
                    }
                }

                var radixToPower = longObj.math.Long.fromNumber(Math.pow(radix, 6));

                rem = this;
                result = '';
                while (true) {
                    var remDiv = rem.div(radixToPower);
                    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
                    var digits = intval.toString(radix);

                    rem = remDiv;
                    if (rem.isZero()) {
                        return digits + result;
                    } else {
                        while (digits.length < 6) {
                            digits = '0' + digits;
                        }
                        result = '' + digits + result;
                    }
                }
            };


            longObj.math.Long.prototype.getHighBits = function () {
                return this.highBits;
            };

            longObj.math.Long.prototype.getLowBits = function () {
                return this.lowBits;
            };

            longObj.math.Long.prototype.getLowBitsUnsigned = function () {
                return (this.lowBits >= 0) ?
      this.lowBits : longObj.math.Long.TWO_PWR_32_DBL_ + this.lowBits;
            };

            longObj.math.Long.prototype.getNumBitsAbs = function () {
                if (this.isNegative()) {
                    if (this.equals(longObj.math.Long.MIN_VALUE)) {
                        return 64;
                    } else {
                        return this.negate().getNumBitsAbs();
                    }
                } else {
                    var val = this.highBits !== 0 ? this.highBits : this.lowBits;
                    for (var bit = 31; bit > 0; bit--) {
                        if ((val & (1 << bit)) !== 0) {
                            break;
                        }
                    }
                    return this.highBits !== 0 ? bit + 33 : bit + 1;
                }
            };

            longObj.math.Long.prototype.isZero = function () {
                return this.highBits === 0 && this.lowBits === 0;
            };

            longObj.math.Long.prototype.isNegative = function () {
                return this.highBits < 0;
            };

            longObj.math.Long.prototype.isOdd = function () {
                return (this.lowBits & 1) === 1;
            };

            longObj.math.Long.prototype.equals = function (other) {
                return (this.highBits === other.highBits) && (this.lowBits === other.lowBits);
            };

            longObj.math.Long.prototype.notEquals = function (other) {
                return (this.highBits !== other.highBits) || (this.lowBits !== other.lowBits);
            };

            longObj.math.Long.prototype.lessThan = function (other) {
                return this.compare(other) < 0;
            };

            longObj.math.Long.prototype.lessThanOrEqual = function (other) {
                return this.compare(other) <= 0;
            };

            longObj.math.Long.prototype.greaterThan = function (other) {
                return this.compare(other) > 0;
            };

            longObj.math.Long.prototype.greaterThanOrEqual = function (other) {
                return this.compare(other) >= 0;
            };

            longObj.math.Long.prototype.compare = function (other) {
                if (this.equals(other)) {
                    return 0;
                }

                var thisNeg = this.isNegative();
                var otherNeg = other.isNegative();
                if (thisNeg && !otherNeg) {
                    return -1;
                }
                if (!thisNeg && otherNeg) {
                    return 1;
                }

                if (this.subtract(other).isNegative()) {
                    return -1;
                } else {
                    return 1;
                }
            };


            longObj.math.Long.prototype.negate = function () {
                if (this.equals(longObj.math.Long.MIN_VALUE)) {
                    return longObj.math.Long.MIN_VALUE;
                } else {
                    return this.not().add(longObj.math.Long.ONE);
                }
            };

            longObj.math.Long.prototype.add = function (other) {
                var a48 = this.highBits >>> 16;
                var a32 = this.highBits & 0xFFFF;
                var a16 = this.lowBits >>> 16;
                var a00 = this.lowBits & 0xFFFF;

                var b48 = other.highBits >>> 16;
                var b32 = other.highBits & 0xFFFF;
                var b16 = other.lowBits >>> 16;
                var b00 = other.lowBits & 0xFFFF;

                var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
                c00 += a00 + b00;
                c16 += c00 >>> 16;
                c00 &= 0xFFFF;
                c16 += a16 + b16;
                c32 += c16 >>> 16;
                c16 &= 0xFFFF;
                c32 += a32 + b32;
                c48 += c32 >>> 16;
                c32 &= 0xFFFF;
                c48 += a48 + b48;
                c48 &= 0xFFFF;
                return longObj.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
            };

            longObj.math.Long.prototype.subtract = function (other) {
                return this.add(other.negate());
            };

            longObj.math.Long.prototype.multiply = function (other) {
                if (this.isZero()) {
                    return longObj.math.Long.ZERO;
                } else if (other.isZero()) {
                    return longObj.math.Long.ZERO;
                }

                if (this.equals(longObj.math.Long.MIN_VALUE)) {
                    return other.isOdd() ? longObj.math.Long.MIN_VALUE : longObj.math.Long.ZERO;
                } else if (other.equals(longObj.math.Long.MIN_VALUE)) {
                    return this.isOdd() ? longObj.math.Long.MIN_VALUE : longObj.math.Long.ZERO;
                }

                if (this.isNegative()) {
                    if (other.isNegative()) {
                        return this.negate().multiply(other.negate());
                    } else {
                        return this.negate().multiply(other).negate();
                    }
                } else if (other.isNegative()) {
                    return this.multiply(other.negate()).negate();
                }

                if (this.lessThan(longObj.math.Long.TWO_PWR_24_) &&
      other.lessThan(longObj.math.Long.TWO_PWR_24_)) {
                    return longObj.math.Long.fromNumber(this.toNumber() * other.toNumber());
                }

                var a48 = this.highBits >>> 16;
                var a32 = this.highBits & 0xFFFF;
                var a16 = this.lowBits >>> 16;
                var a00 = this.lowBits & 0xFFFF;

                var b48 = other.highBits >>> 16;
                var b32 = other.highBits & 0xFFFF;
                var b16 = other.lowBits >>> 16;
                var b00 = other.lowBits & 0xFFFF;

                var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
                c00 += a00 * b00;
                c16 += c00 >>> 16;
                c00 &= 0xFFFF;
                c16 += a16 * b00;
                c32 += c16 >>> 16;
                c16 &= 0xFFFF;
                c16 += a00 * b16;
                c32 += c16 >>> 16;
                c16 &= 0xFFFF;
                c32 += a32 * b00;
                c48 += c32 >>> 16;
                c32 &= 0xFFFF;
                c32 += a16 * b16;
                c48 += c32 >>> 16;
                c32 &= 0xFFFF;
                c32 += a00 * b32;
                c48 += c32 >>> 16;
                c32 &= 0xFFFF;
                c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
                c48 &= 0xFFFF;
                return longObj.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
            };

            longObj.math.Long.prototype.div = function (other) {
                if (other.isZero()) {
                    throw new Error('division by zero');
                } else if (this.isZero()) {
                    return longObj.math.Long.ZERO;
                }

                var approx, rem;

                if (this.equals(longObj.math.Long.MIN_VALUE)) {
                    if (other.equals(longObj.math.Long.ONE) ||
        other.equals(longObj.math.Long.NEG_ONE)) {
                        return longObj.math.Long.MIN_VALUE;
                    } else if (other.equals(longObj.math.Long.MIN_VALUE)) {
                        return longObj.math.Long.ONE;
                    } else {
                        var halfThis = this.shiftRight(1);
                        approx = halfThis.div(other).shiftLeft(1);
                        if (approx.equals(longObj.math.Long.ZERO)) {
                            return other.isNegative() ? longObj.math.Long.ONE : longObj.math.Long.NEG_ONE;
                        } else {
                            rem = this.subtract(other.multiply(approx));
                            var result = approx.add(rem.div(other));
                            return result;
                        }
                    }
                } else if (other.equals(longObj.math.Long.MIN_VALUE)) {
                    return longObj.math.Long.ZERO;
                }

                if (this.isNegative()) {
                    if (other.isNegative()) {
                        return this.negate().div(other.negate());
                    } else {
                        return this.negate().div(other).negate();
                    }
                } else if (other.isNegative()) {
                    return this.div(other.negate()).negate();
                }

                var res = longObj.math.Long.ZERO;
                rem = this;
                while (rem.greaterThanOrEqual(other)) {
                    approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

                    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
                    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

                    var approxRes = longObj.math.Long.fromNumber(approx);
                    var approxRem = approxRes.multiply(other);
                    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
                        approx -= delta;
                        approxRes = longObj.math.Long.fromNumber(approx);
                        approxRem = approxRes.multiply(other);
                    }

                    if (approxRes.isZero()) {
                        approxRes = longObj.math.Long.ONE;
                    }

                    res = res.add(approxRes);
                    rem = rem.subtract(approxRem);
                }
                return res;
            };

            longObj.math.Long.prototype.modulo = function (other) {
                return this.subtract(this.div(other).multiply(other));
            };

            longObj.math.Long.prototype.not = function () {
                return longObj.math.Long.fromBits(~this.lowBits, ~this.highBits);
            };

            longObj.math.Long.prototype.and = function (other) {
                return longObj.math.Long.fromBits(this.lowBits & other.lowBits,
                                 this.highBits & other.highBits);
            };

            longObj.math.Long.prototype.or = function (other) {
                return longObj.math.Long.fromBits(this.lowBits | other.lowBits,
                                 this.highBits | other.highBits);
            };

            longObj.math.Long.prototype.xor = function (other) {
                return longObj.math.Long.fromBits(this.lowBits ^ other.lowBits,
                                 this.highBits ^ other.highBits);
            };

            longObj.math.Long.prototype.shiftLeft = function (numBits) {
                numBits &= 63;
                if (numBits === 0) {
                    return this;
                } else {
                    var low = this.lowBits;
                    if (numBits < 32) {
                        var high = this.highBits;
                        return longObj.math.Long.fromBits(
          low << numBits,
          (high << numBits) | (low >>> (32 - numBits)));
                    } else {
                        return longObj.math.Long.fromBits(0, low << (numBits - 32));
                    }
                }
            };

            longObj.math.Long.prototype.shiftRight = function (numBits) {
                numBits &= 63;
                if (numBits === 0) {
                    return this;
                } else {
                    var high = this.highBits;
                    if (numBits < 32) {
                        var low = this.lowBits;
                        return longObj.math.Long.fromBits(
          (low >>> numBits) | (high << (32 - numBits)),
          high >> numBits);
                    } else {
                        return longObj.math.Long.fromBits(
          high >> (numBits - 32),
          high >= 0 ? 0 : -1);
                    }
                }
            };

            longObj.math.Long.prototype.shiftRightUnsigned = function (numBits) {
                numBits &= 63;
                if (numBits === 0) {
                    return this;
                } else {
                    var high = this.highBits;
                    if (numBits < 32) {
                        var low = this.lowBits;
                        return longObj.math.Long.fromBits(
          (low >>> numBits) | (high << (32 - numBits)),
          high >>> numBits);
                    } else if (numBits === 32) {
                        return longObj.math.Long.fromBits(high, 0);
                    } else {
                        return longObj.math.Long.fromBits(high >>> (numBits - 32), 0);
                    }
                }
            };
        }
    });
})(jqxBaseFramework); //ignore jslint
})();



/***/ }),

/***/ 1062:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {

    $.jqx.jqxWidget("jqxListBox", "", {});

    $.extend($.jqx._jqxListBox.prototype, {
        defineInstance: function () {
            var settings = {
                // Type: Boolean
                // Default: true
                // enables/disables the listbox.
                disabled: false,
                // Type: Boolean
                // Default: 16
                // Gets or sets the checkbox size.
                checkboxSize: 16,
                // Type: Boolean
                // Default: false
                // Gets or sets whether the listbox should display a checkbox next to each item.
                checkboxes: false,
                // gets or sets the listbox width.
                width: null,
                // gets or sets the listbox height.
                height: null,
                // Represents the collection of list items.
                items: new Array(),
                // Type: Boolean
                // Default: false
                // enables/disables the multiple selection.
                multiple: false,
                // Gets or sets the selected index.
                selectedIndex: -1,
                // Gets the selected item indexes.
                selectedIndexes: new Array(),
                // Type: Object
                // Default: null
                // data source.
                source: null,
                // Type: Number
                // Default: 15
                // gets or sets the scrollbars size.
                scrollBarSize: $.jqx.utilities.scrollBarSize,
                // Type: Boolean
                // Default: true
                // enables/disables the hover state.
                enableHover: true,
                // Type: Boolean
                // Default: true
                // enables/disables the selection.
                enableSelection: true,
                // gets the visible items. // this property is internal for the listbox.
                visualItems: new Array(),
                // gets the groups. // this property is internal for the listbox.
                groups: new Array(),
                // Type: Boolean
                // Default: true
                // gets or sets whether the items width should be equal to the listbox's width.
                equalItemsWidth: true,
                // gets or sets the height of the ListBox Items. When the itemHeight == - 1, each item's height is equal to its desired height.
                itemHeight: -1,
                // this property is internal for the listbox.
                visibleItems: new Array(),
                // Type: String
                // Default: Group
                // represents the text of the empty group. This is displayed only when the items are not loaded from html select element.
                emptyGroupText: 'Group',
                // Type: Boolean
                // Default: false
                // Gets or sets whether the listbox checkboxes have three states - checked, unchecked and indeterminate.
                hasThreeStates: false,
                // Type: Boolean
                // Default: false
                // Gets or sets whether the listbox's height is equal to the sum of its items height
                autoHeight: false,
                autoItemsHeight: false,
                // represents the listbox's events.
                // Type: Boolean
                // Default: true
                // Gets or sets whether the listbox items are with rounded corners.
                roundedcorners: true,
                touchMode: 'auto',
                displayMember: "",
                groupMember: "",
                valueMember: "",
                searchMember: "",
                // Type: String
                // Default: startswithignorecase
                // Possible Values: 'none, 'contains', 'containsignorecase', 'equals', 'equalsignorecase', 'startswithignorecase', 'startswith', 'endswithignorecase', 'endswith'
                searchMode: 'startswithignorecase',
                incrementalSearch: true,
                incrementalSearchDelay: 1000,
                incrementalSearchKeyDownDelay: 300,
                allowDrag: false,
                allowDrop: true,
                // Possible values: 'none, 'default', 'copy'
                dropAction: 'default',
                touchModeStyle: 'auto',
                keyboardNavigation: true,
                enableMouseWheel: true,
                multipleextended: false,
                selectedValues: new Array(),
                emptyString: "",
                rtl: false,
                rendered: null,
                renderer: null,
                dragStart: null,
                dragEnd: null,
                focusable: true,
                ready: null,
                _checkForHiddenParent: true,
                autoBind: true,
                _renderOnDemand: false,
                filterable: false,
                filterHeight: 30,
                filterPlaceHolder: "Looking for",
                filterDelay: 100,
                filterChange: null,
                aria:
                {
                    "aria-disabled": { name: "disabled", type: "boolean" }
                },
                events:
                    [
                        // triggered when the user selects an item.
                        'select',
                        // triggered when the user unselects an item.
                        'unselect',
                        // triggered when the selection is changed.
                        'change',
                        // triggered when the user checks or unchecks an item.
                        'checkChange',
                        // triggered when the user drags an item.
                        'dragStart',
                        // triggered when the user drops an item.
                        'dragEnd',
                        // triggered when the binding is completed.
                        'bindingComplete',
                        // triggered when a new item is added.
                        'itemAdd',
                        // triggered when a new item is removed.
                        'itemRemove',
                        // triggered when a new item is updated.
                        'itemUpdate'
                    ]
            }
            if (this === $.jqx._jqxListBox.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        createInstance: function (args) {
            var self = this;
            if ($.jqx.utilities.scrollBarSize != 15) {
                self.scrollBarSize = $.jqx.utilities.scrollBarSize;
            }
            if (self.width == null) self.width = 200;
            if (self.height == null) self.height = 200;

            if (self.isMaterialized()) {
                var gridStyle = window.getComputedStyle(self.element);
                var rowHeight = gridStyle.getPropertyValue('--jqx-list-item-height');

                if (rowHeight && this.itemHeight === -1) {
                    this.itemHeight = parseInt(rowHeight);
                }
            }
            self.renderListBox();
            var that = self;
            $.jqx.utilities.resize(self.host, function () {
                that._updateSize();
            }, false, self._checkForHiddenParent);
        },

        resize: function (width, height) {
            this.width = width;
            this.height = height;
            this._updateSize();
        },

        render: function () {
            this.renderListBox();
            this.refresh();
        },

        renderListBox: function () {
            var self = this;
            var nodeName = self.element.nodeName.toLowerCase();
            if (nodeName == "select" || nodeName == "ul" || nodeName == "ol") {
                self.field = self.element;
                if (self.field.className) {
                    self._className = self.field.className;
                }

                var properties = {
                    'title': self.field.title
                };

                if (self.field.id.length) {
                    properties.id = self.field.id.replace(/[^\w]/g, '_') + "_jqxListBox";
                }
                else {
                    properties.id = $.jqx.utilities.createId() + "_jqxListBox";
                }

                var wrapper = $("<div></div>", properties);
                if (!self.width) {
                    self.width = $(self.field).width();
                }
                if (!self.height) {
                    self.height = $(self.field).outerHeight();
                }
                self.element.style.cssText = self.field.style.cssText;
                $(self.field).hide().after(wrapper);
                var data = self.host.data();
                self.host = wrapper;
                self.host.data(data);
                self.element = wrapper[0];
                self.element.id = self.field.id;
                self.field.id = properties.id;
                if (self._className) {
                    self.host.addClass(self._className);
                    $(self.field).removeClass(self._className);
                }

                if (self.field.tabIndex) {
                    var tabIndex = self.field.tabIndex;
                    self.field.tabIndex = -1;
                    self.element.tabIndex = tabIndex;
                }
            }
            else {
                if (self.host.find('li').length > 0 || self.host.find('option').length > 0) {
                    var result = $.jqx.parseSourceTag(self.element);
                    self.source = result.items;
                }
            }

            self.element.innerHTML = "";
            var self = self;

            var className = self.element.className;

            className += " " + self.toThemeProperty("jqx-listbox");
            className += " " + self.toThemeProperty("jqx-reset");
            className += " " + self.toThemeProperty("jqx-rc-all");
            className += " " + self.toThemeProperty("jqx-widget");
            className += " " + self.toThemeProperty("jqx-widget-content");

            self.element.className = className;

            var isPercentage = false;

            var computedStyle = window.getComputedStyle(this.element);
            var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
            var boxSizing = computedStyle.boxSizing;

            if (this.element.offsetWidth === 0) {
                borderSize = 2;
            }

            if (boxSizing === 'border-box' || isNaN(borderSize)) {
                borderSize = 0;
            }

            if (self.width != null && self.width.toString().indexOf("%") != -1) {
                self.host.width(self.width);
                if (borderSize > 0) {
                    this.host.css('box-sizing', 'border-box');
                }
                isPercentage = true;
            }
            if (self.height != null && self.height.toString().indexOf("%") != -1) {
                self.host.height(self.height);
                if (self.host.height() == 0) {
                    self.host.height(200);
                }
                isPercentage = true;
            }
            if (self.width != null && self.width.toString().indexOf("px") != -1) {
                self.element.style.width = parseInt(self.width) - borderSize + 'px';
            }
            else
                if (self.width != undefined && !isNaN(self.width)) {
                    self.element.style.width = parseInt(self.width) - borderSize + 'px';
                };

            if (self.height != null && self.height.toString().indexOf("px") != -1) {
                self.element.style.height = parseInt(self.height) - borderSize + 'px';
            }
            else if (self.height != undefined && !isNaN(self.height)) {
                self.element.style.height = parseInt(self.height) - borderSize + 'px';
            };

            if (self.multiple || self.multipleextended || self.checkboxes) {
                $.jqx.aria(self, "aria-multiselectable", true);
            }
            else {
                $.jqx.aria(self, "aria-multiselectable", false);
            }

            var listBoxStructure = "<div style='-webkit-appearance: none; background: transparent; outline: none; width:100%; height: 100%; align:left; border: 0px; padding: 0px; margin: 0px; left: 0px; top: 0px; valign:top; position: relative;'>" +
                "<div style='-webkit-appearance: none; border: none; background: transparent; outline: none; width:100%; height: 100%; padding: 0px; margin: 0px; align:left; left: 0px; top: 0px; valign:top; position: relative;'>" +
                "<div id='filter" + self.element.id + "' style='display: none; visibility: inherit; align:left; valign:top; left: 0px; top: 0px; position: absolute;'><input style='position: absolute;'/></div>" +
                "<div id='listBoxContent' style='-webkit-appearance: none; border: none; background: transparent; outline: none; border: none; padding: 0px; overflow: hidden; margin: 0px; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='verticalScrollBar" + self.element.id + "' style='visibility: inherit; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='horizontalScrollBar" + self.element.id + "' style='visibility: inherit; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='bottomRight' style='align:left; valign:top; left: 0px; top: 0px; border: none; position: absolute;'/>" +
                "</div>" +
                "</div>";

            self.host.attr('role', 'listbox');

            self.element.innerHTML = listBoxStructure;
            if (self._checkForHiddenParent) {
                self._addInput();
                if (!self.host.attr('tabIndex')) {
                    self.host.attr('tabIndex', 1);
                }
            }
            self.filter = $(self.element.firstChild.firstChild.firstChild);
            self.filterInput = $(self.filter[0].firstChild);
            self.filterInput.attr('placeholder', self.filterPlaceHolder);
            self.filterInput.addClass(self.toThemeProperty('jqx-widget jqx-listbox-filter-input jqx-input jqx-rc-all'));

            self.addHandler(self.filterInput, 'keyup.textchange', function (event) {
                if (event.keyCode == 13) {
                    self._search(event);
                }
                else {
                    if (self.filterDelay > 0) {
                        if (self._filterTimer)
                            clearTimeout(self._filterTimer);

                        self._filterTimer = setTimeout(function () {
                            self._search(event);
                        }, self.filterDelay);
                    }
                }

                event.stopPropagation();
            });

            var verticalScrollBar = $(self.element.firstChild.firstChild.firstChild.nextSibling.nextSibling);
            if (!self.host.jqxButton) {
                throw new Error('jqxListBox: Missing reference to jqxbuttons.js.');
                return;
            }
            if (!verticalScrollBar.jqxScrollBar) {
                throw new Error('jqxListBox: Missing reference to jqxscrollbar.js.');
                return;
            }

            var largestep = parseInt(self.host.height()) / 2;
            if (largestep == 0) largestep = 10;

            self.vScrollBar = verticalScrollBar.jqxScrollBar({ _initialLayout: true, 'vertical': true, rtl: self.rtl, theme: self.theme, touchMode: self.touchMode, largestep: largestep });
            var horizontalScrollBar = $(self.element.firstChild.firstChild.firstChild.nextSibling.nextSibling.nextSibling);
            self.hScrollBar = horizontalScrollBar.jqxScrollBar({ _initialLayout: true, 'vertical': false, rtl: self.rtl, touchMode: self.touchMode, theme: self.theme });

            self.content = $(self.element.firstChild.firstChild.firstChild.nextSibling);
            self.content.addClass(self.toThemeProperty('jqx-listbox-content-element'));
            self.content[0].id = 'listBoxContent' + self.element.id;
            self.bottomRight = $(self.element.firstChild.firstChild.firstChild.nextSibling.nextSibling.nextSibling.nextSibling).addClass(self.toThemeProperty('jqx-listbox-bottomright')).addClass(self.toThemeProperty('jqx-scrollbar-state-normal'));
            self.bottomRight[0].id = "bottomRight" + self.element.id;
            self.vScrollInstance = $.data(self.vScrollBar[0], 'jqxScrollBar').instance;
            self.hScrollInstance = $.data(self.hScrollBar[0], 'jqxScrollBar').instance;
            if (self.isTouchDevice()) {
                if (!($.jqx.browser.msie && $.jqx.browser.version < 9)) {
                    var overlayContent = $("<div class='overlay' unselectable='on' style='z-index: 99; -webkit-appearance: none; border: none; background: black; opacity: 0.01; outline: none; border: none; padding: 0px; overflow: hidden; margin: 0px; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>");
                    self.content.parent().append(overlayContent);
                    self.overlayContent = self.host.find('.overlay');
                    if (self.filterable) {
                        self.overlayContent.css('top', '30px');
                    }
                }
            }
            self._updateTouchScrolling();

            self.host.addClass('jqx-disableselect');
            if (self.host.jqxDragDrop) {
                window.jqxListBoxDragDrop();
            }
        },

        _highlight: function (label, searchstring) {
            var query = searchstring.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&')
            return label.replace(new RegExp('(' + query + ')', 'ig'), function ($1, match) {
                return '<b>' + match + '</b>'
            });
        },

        _addInput: function () {
            var name = this.host.attr('name');
            if (name) {
                this.host.attr('name', "");
            }

            this.input = $("<input type='hidden'/>");
            this.host.append(this.input);
            this.input.attr('name', name);
        },

        _updateTouchScrolling: function () {
            var self = this;
            if (this.isTouchDevice()) {
                self.enableHover = false;
                var element = this.overlayContent ? this.overlayContent : this.content;

                this.removeHandler($(element), $.jqx.mobile.getTouchEventName('touchstart') + '.touchScroll');
                this.removeHandler($(element), $.jqx.mobile.getTouchEventName('touchmove') + '.touchScroll');
                this.removeHandler($(element), $.jqx.mobile.getTouchEventName('touchend') + '.touchScroll');
                this.removeHandler($(element), 'touchcancel.touchScroll');

                $.jqx.mobile.touchScroll(element, self.vScrollInstance.max, function (left, top) {
                    if (top != null && self.vScrollBar.css('visibility') != 'hidden') {
                        var oldValue = self.vScrollInstance.value;
                        self.vScrollInstance.setPosition(top);
                        self._lastScroll = new Date();
                    }
                    if (left != null && self.hScrollBar.css('visibility') != 'hidden') {
                        var oldValue = self.hScrollInstance.value;
                        self.hScrollInstance.setPosition(left);
                        self._lastScroll = new Date();
                    }
                }, this.element.id, this.hScrollBar, this.vScrollBar);

                if (self.vScrollBar.css('visibility') != 'visible' && self.hScrollBar.css('visibility') != 'visible') {
                    $.jqx.mobile.setTouchScroll(false, this.element.id);
                }
                else {
                    $.jqx.mobile.setTouchScroll(true, this.element.id);
                }
                this._arrange();
            }
        },

        isTouchDevice: function () {
            var isTouchDevice = $.jqx.mobile.isTouchDevice();
            if (this.touchMode == true) {
                if (this.touchDevice)
                    return true;

                if ($.jqx.browser.msie && $.jqx.browser.version < 9)
                    return false;

                this.touchDevice = true;
                isTouchDevice = true;
                $.jqx.mobile.setMobileSimulator(this.element);
            }
            else if (this.touchMode == false) {
                isTouchDevice = false;
            }
            if (isTouchDevice && this.touchModeStyle != false) {
                this.scrollBarSize = $.jqx.utilities.touchScrollBarSize;
            }
            if (isTouchDevice) {
                this.host.addClass(this.toThemeProperty('jqx-touch'));
            }

            return isTouchDevice;
        },

        beginUpdate: function () {
            this.updatingListBox = true;
        },

        endUpdate: function () {
            this.updatingListBox = false;
            if ((this.allowDrag && this._enableDragDrop) || (this.virtualSize && this.virtualSize.height < 10 + this.host.height())) {
                this._addItems(true);
            }
            else {
                this._addItems(false);
            }
            this._renderItems();
            if (this.allowDrag && this._enableDragDrop) {
                this._enableDragDrop();
            }
        },

        beginUpdateLayout: function () {
            this.updating = true;
        },

        resumeUpdateLayout: function () {
            this.updating = false;
            this.vScrollInstance.value = 0;
            this._render(false);
        },

        propertiesChangedHandler: function (object, key, value) {
            if (value.width && value.height && Object.keys(value).length == 2) {
                object._cachedItemHtml = new Array();
                object.refresh();
            }
        },

        propertyChangedHandler: function (object, key, oldvalue, value) {
            if (this.isInitialized == undefined || this.isInitialized == false)
                return;

            if (oldvalue == value)
                return;

            if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                return;
            }

            if (key == "_renderOnDemand") {
                object._render(false, true);
                if (object.selectedIndex != -1) {
                    var tmpIndex = object.selectedIndex;
                    object.selectedIndex = -1;
                    object._stopEvents = true;
                    object.selectIndex(tmpIndex, false, true);
                    if (object.selectedIndex == -1) {
                        object.selectedIndex = tmpIndex;
                    }
                    object._stopEvents = false;
                }
            }

            if (key == "filterable") {
                object.refresh();
            }

            if (key == "filterHeight") {
                object._arrange();
            }

            if (key == "filterPlaceHolder") {
                object.filterInput.attr('placeholder', value);
            }

            if (key == "renderer") {
                object._cachedItemHtml = new Array();
                object.refresh();
            }

            if (key == "itemHeight" || key === "checkboxSize") {
                object.refresh();
            }

            if (key == 'source' || key == 'checkboxes') {
                if (value == null && oldvalue && oldvalue.unbindBindingUpdate) {
                    oldvalue.unbindBindingUpdate(object.element.id);
                    oldvalue.unbindDownloadComplete(object.element.id);
                }

                object.clearSelection();
                object.refresh();
            }

            if (key == 'scrollBarSize' || key == 'equalItemsWidth') {
                if (value != oldvalue) {
                    object._updatescrollbars();
                }
            }

            if (key == 'disabled') {
                object._renderItems();
                object.vScrollBar.jqxScrollBar({ disabled: value });
                object.hScrollBar.jqxScrollBar({ disabled: value });
            }

            if (key == "touchMode" || key == "rtl") {
                object._removeHandlers();
                object.vScrollBar.jqxScrollBar({ touchMode: value });
                object.hScrollBar.jqxScrollBar({ touchMode: value });
                if (key == "touchMode") {
                    if (!($.jqx.browser.msie && $.jqx.browser.version < 9)) {
                        var overlayContent = $("<div class='overlay' unselectable='on' style='z-index: 99; -webkit-appearance: none; border: none; background: black; opacity: 0.01; outline: none; border: none; padding: 0px; overflow: hidden; margin: 0px; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>");
                        object.content.parent().append(overlayContent);
                        object.overlayContent = object.host.find('.overlay');
                    }
                }
                if (object.filterable && object.filterInput) {
                    if (key == "rtl" && value) {
                        object.filterInput.addClass(object.toThemeProperty('jqx-rtl'));
                    }
                    else if (key == "rtl" && !value) {
                        object.filterInput.removeClass(object.toThemeProperty('jqx-rtl'));
                    }
                    object._arrange();
                }

                object._updateTouchScrolling();
                object._addHandlers();
                object._render(false);
            }

            if (!this.updating) {
                if (key == "width" || key == "height") {
                    object._updateSize();
                }
            }

            if (key == 'theme') {
                if (oldvalue != value) {
                    object.hScrollBar.jqxScrollBar({ theme: object.theme });
                    object.vScrollBar.jqxScrollBar({ theme: object.theme });
                    object.host.removeClass();
                    object.host.addClass(object.toThemeProperty("jqx-listbox"));
                    object.host.addClass(object.toThemeProperty("jqx-widget"));
                    object.host.addClass(object.toThemeProperty("jqx-widget-content"));
                    object.host.addClass(object.toThemeProperty("jqx-reset"));
                    object.host.addClass(object.toThemeProperty("jqx-rc-all"));
                    object.refresh();
                }
            }

            if (key == 'selectedIndex') {
                object.clearSelection();
                object.selectIndex(value, true);
            }

            if (key == "displayMember" || key == "valueMember") {
                if (oldvalue != value) {
                    var oldSelectedIndex = object.selectedIndex;
                    object.refresh();
                    object.selectedIndex = oldSelectedIndex;
                    object.selectedIndexes[oldSelectedIndex] = oldSelectedIndex;
                }
                object._renderItems();
            }

            if (key == 'autoHeight') {
                if (oldvalue != value) {
                    object._render(false);
                }
                else {
                    object._updatescrollbars();
                    object._renderItems();
                }
            }
            if (object._checkForHiddenParent && $.jqx.isHidden(object.host)) {
                $.jqx.utilities.resize(this.host, function () {
                    object._updateSize();
                }, false, object._checkForHiddenParent);
            }
        },

        loadFromSelect: function (id) {
            if (id == null)
                return;

            var searchElementId = '#' + id;
            var selectElement = $(searchElementId);
            if (selectElement.length > 0) {
                var result = $.jqx.parseSourceTag(selectElement[0]);
                var optionItems = result.items;
                var selectedOption = result.index;
                this.source = optionItems;
                this.fromSelect = true;
                this.clearSelection();
                this.selectedIndex = selectedOption;
                this.selectedIndexes[this.selectedIndex] = this.selectedIndex;
                this.refresh();
            }
        },

        invalidate: function () {
            this._cachedItemHtml = [];
            this._renderItems();
            this.virtualSize = null;
            this._updateSize();
        },

        refresh: function (initialRefresh) {
            var me = this;
            if (this.vScrollBar == undefined) {
                return;
            }

            this.itemHeight = parseInt(this.itemHeight);
            this._cachedItemHtml = [];
            this.visibleItems = new Array();
            var selectInitialItem = function (initialRefresh) {
                if (initialRefresh == true) {
                    if (me.selectedIndex != -1) {
                        var tmpIndex = me.selectedIndex;
                        me.selectedIndex = -1;
                        me._stopEvents = true;
                        me.selectIndex(tmpIndex, false, true);
                        if (me.selectedIndex == -1) {
                            me.selectedIndex = tmpIndex;
                        }
                        me._stopEvents = false;
                    }
                }
            }
            if (this.itemswrapper != null) {
                this.itemswrapper.remove();
                this.itemswrapper = null;
            }
            if ($.jqx.dataAdapter && this.source != null && this.source._source) {

                this.databind(this.source, initialRefresh);
                selectInitialItem(initialRefresh);
                return;
            }
            if (this.autoBind || (!this.autoBind && !initialRefresh)) {
                if (this.field) {
                    this.loadSelectTag();
                }
                this.items = this.loadItems(this.source);
            }

            this._render(false, initialRefresh == true);
            selectInitialItem(initialRefresh);
            this._raiseEvent('6');
        },

        loadSelectTag: function () {
            var result = $.jqx.parseSourceTag(this.field);
            this.source = result.items;
            if (this.selectedIndex == -1)
                this.selectedIndex = result.index;
        },

        _render: function (ensurevisible, initialRefresh) {
            if (this._renderOnDemand) {
                this.visibleItems = new Array();
                this.renderedVisibleItems = new Array();
                this._renderItems();
                return;
            }

            this._addItems();
            this._renderItems();
            this.vScrollInstance.setPosition(0);
            this._cachedItemHtml = new Array();
            if (ensurevisible == undefined || ensurevisible) {
                if (this.items != undefined && this.items != null) {
                    if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {
                        this.selectIndex(this.selectedIndex, true, true, true);
                    }
                }
            }

            if (this.allowDrag && this._enableDragDrop) {
                this._enableDragDrop();
                if (this.isTouchDevice()) {
                    this._removeHandlers();
                    if (this.overlayContent) {
                        this.overlayContent.remove();
                        this.overlayContent = null;
                    }
                    this._updateTouchScrolling();
                    this._addHandlers();
                    return;
                }
            }
            this._updateTouchScrolling();
            if (this.rendered) {
                this.rendered();
            }
            if (this.ready) {
                this.ready();
            }
        },

        _hitTest: function (hitLeft, hitTop) {
            if (this.filterable) {
                hitTop -= this.filterHeight;
                if (hitTop < 0) hitTop = 0;
            }

            var top = parseInt(this.vScrollInstance.value);
            var firstIndex = this._searchFirstVisibleIndex(hitTop + top, this.renderedVisibleItems)
            if (this.renderedVisibleItems[firstIndex] != undefined && this.renderedVisibleItems[firstIndex].isGroup)
                return null;

            if (this.renderedVisibleItems.length > 0) {
                var lastItem = this.renderedVisibleItems[this.renderedVisibleItems.length - 1];
                if (lastItem.height + lastItem.top < hitTop + top) {
                    return null;
                }
            }

            firstIndex = this._searchFirstVisibleIndex(hitTop + top)
            return this.visibleItems[firstIndex];

            return null;
        },

        _searchFirstVisibleIndex: function (value, collection) {
            if (value == undefined) {
                value = parseInt(this.vScrollInstance.value);
            }
            var min = 0;
            if (collection == undefined || collection == null) {
                collection = this.visibleItems;
            }

            var max = collection.length;
            while (min <= max) {
                var mid = parseInt((min + max) / 2)
                var item = collection[mid];
                if (item == undefined)
                    break;

                if (item.initialTop > value && item.initialTop + item.height > value) {
                    max = mid - 1;
                } else if (item.initialTop < value && item.initialTop + item.height <= value) {
                    min = mid + 1;
                } else {
                    return mid;
                    break;
                }
            }

            return 0;
        },

        _renderItems: function () {
            if (this.items == undefined || this.items.length == 0) {
                this.visibleItems = new Array();
                return;
            }

            if (this.updatingListBox == true)
                return;

            var touchDevice = this.isTouchDevice();
            var vScrollInstance = this.vScrollInstance;
            var hScrollInstance = this.hScrollInstance;
            var top = parseInt(vScrollInstance.value);
            var left = parseInt(hScrollInstance.value);
            if (this.rtl) {
                if (this.hScrollBar[0].style.visibility != 'hidden') {
                    left = hScrollInstance.max - left;
                }
            }

            var itemsLength = this.items.length;
            var hostWidth = this.host.width();
            var contentWidth = parseInt(this.content[0].style.width);
            var width = contentWidth + parseInt(hScrollInstance.max);
            var vScrollBarWidth = parseInt(this.vScrollBar[0].style.width) + 2;
            if (this.vScrollBar[0].style.visibility == 'hidden') {
                vScrollBarWidth = 0;
            }

            if (this.hScrollBar[0].style.visibility != 'visible') {
                width = contentWidth;
            }
            var virtualItemsCount = this._getVirtualItemsCount();
            var renderCollection = new Array();
            var y = 0;
            var hostHeight = parseInt(this.element.style.height) + 2;
            if (this.element.style.height.indexOf('%') != -1) {
                hostHeight = this.host.outerHeight();
            }

            if (isNaN(hostHeight)) {
                hostHeight = 0;
            }
            var maxWidth = 0;
            var visibleIndex = 0;
            var renderIndex = 0;

            if (vScrollInstance.value == 0 || this.visibleItems.length == 0) {
                for (var indx = 0; indx < this.items.length; indx++) {
                    var item = this.items[indx];
                    if (item.visible) {
                        item.top = -top;
                        item.initialTop = -top;
                        if (!item.isGroup && item.visible) {
                            this.visibleItems[visibleIndex++] = item;
                            item.visibleIndex = visibleIndex - 1;
                        }

                        this.renderedVisibleItems[renderIndex++] = item;

                        item.left = -left;
                        var bottom = item.top + item.height;
                        if (bottom >= 0 && item.top - item.height <= hostHeight) {
                            renderCollection[y++] = { index: indx, item: item };
                        }

                        top -= item.height;
                        top--;
                    }
                }
            }
            var firstIndex = top > 0 ? this._searchFirstVisibleIndex(this.vScrollInstance.value, this.renderedVisibleItems) : 0;
            var initialHeight = 0;
            y = 0;
            var scrollValue = this.vScrollInstance.value;
            var iterations = 0;
            while (initialHeight < 100 + hostHeight) {
                var item = this.renderedVisibleItems[firstIndex];
                if (item == undefined)
                    break;
                if (item.visible) {
                    item.left = -left;
                    var bottom = item.top + item.height - scrollValue;
                    if (bottom >= 0 && item.initialTop - scrollValue - item.height <= 2 * hostHeight) {
                        renderCollection[y++] = { index: firstIndex, item: item };
                    }
                }

                firstIndex++;
                if (item.visible) {
                    initialHeight += item.initialTop - scrollValue + item.height - initialHeight;
                }
                iterations++;
                if (iterations > this.items.length - 1)
                    break;
            }
            if (this._renderOnDemand) {
                return;
            }

            var listItemNormalClass = this.toThemeProperty('jqx-listitem-state-normal') + ' ' + this.toThemeProperty('jqx-item');
            var listItemGroupClass = this.toThemeProperty('jqx-listitem-state-group');
            var listItemDisabledClass = this.toThemeProperty('jqx-listitem-state-disabled') + ' ' + this.toThemeProperty('jqx-fill-state-disabled');

            if (this.checkboxes) {
                listItemNormalClass += ' ' + 'checkboxes';
            }

            var middle = 0;
            var me = this;
            for (var indx = 0; indx < this.visualItems.length; indx++) {
                var itemElement = this.visualItems[indx];
                var hideItem = function () {
                    var spanElement = itemElement[0].firstChild; // itemElement.find('#spanElement');
                    if (me.checkboxes) {
                        spanElement = itemElement[0].lastChild;
                    }

                    if (spanElement != null) {
                        spanElement.style.visibility = 'hidden';
                        spanElement.className = "";
                    }

                    if (me.checkboxes) {
                        var checkbox = itemElement[0].firstChild;
                        checkbox.style.visibility = "hidden";
                    }
                }

                if (indx < renderCollection.length) {
                    var item = renderCollection[indx].item;
                    if (item.initialTop - scrollValue >= hostHeight) {
                        hideItem();
                        continue;
                    }

                    var spanElement = $(itemElement[0].firstChild); // itemElement.find('#spanElement');
                    if (this.checkboxes) {
                        spanElement = $(itemElement[0].lastChild);
                    }

                    if (spanElement.length == 0)
                        continue;

                    if (spanElement[0] == null) continue;
                    spanElement[0].className = "";
                    spanElement[0].style.display = "block";
                    spanElement[0].style.visibility = "inherit";
                    var classNameBuilder = "";
                    //                    spanElement.css({ 'display': 'block', 'visibility': 'inherit' });

                    if (!item.isGroup && !this.selectedIndexes[item.index] >= 0) {
                        classNameBuilder = listItemNormalClass;
                        //spanElement.addClass(listItemNormalClass);
                    }
                    else {
                        classNameBuilder = listItemGroupClass;
                        //spanElement.addClass(listItemGroupClass);
                    }

                    if (item.disabled || this.disabled) {
                        classNameBuilder += " " + listItemDisabledClass;
                        //spanElement.addClass(listItemDisabledClass);
                    }

                    if (this.roundedcorners) {
                        classNameBuilder += " " + this.toThemeProperty('jqx-rc-all');
                        //spanElement.addClass(this.toThemeProperty('jqx-rc-all'));
                    }
                    if (touchDevice) {
                        classNameBuilder += " " + this.toThemeProperty('jqx-listitem-state-normal-touch');
                    }

                    spanElement[0].className = classNameBuilder;

                    if (this.renderer) {
                        if (!item.key) item.key = this.generatekey();
                        if (!this._cachedItemHtml) this._cachedItemHtml = new Array();
                        if (this._cachedItemHtml[item.key]) {
                            if (spanElement[0].innerHTML != this._cachedItemHtml[item.key]) {
                                spanElement[0].innerHTML = this._cachedItemHtml[item.key];
                            }
                        }
                        else {
                            var html = this.renderer(item.index, item.label, item.value);
                            spanElement[0].innerHTML = html;
                            this._cachedItemHtml[item.key] = spanElement[0].innerHTML;
                        }

                    }
                    else {
                        if (this.itemHeight !== -1) {
                            var paddingAndBorder = 2 + 2 * parseInt(spanElement.css('padding-top'));
                            spanElement[0].style.lineHeight = (item.height - paddingAndBorder) + 'px';
                            spanElement.css('vertical-align', 'middle');
                        }

                        if (item.html != null && item.html.toString().length > 0) {
                            spanElement[0].innerHTML = item.html;
                        }
                        else if (item.label != null || item.value != null) {
                            if (item.label != null) {
                                if (spanElement[0].innerHTML !== item.label) {
                                    spanElement[0].innerHTML = item.label;
                                }
                                if ($.trim(item.label) == "") {
                                    spanElement[0].innerHTML = this.emptyString;
                                    if (this.emptyString == "") {
                                        spanElement[0].style.height = (item.height - 8) + 'px';
                                    }
                                }
                                if (!this.incrementalSearch && !item.disabled) {
                                    if (this.searchString != undefined && this.searchString != "") {
                                        spanElement[0].innerHTML = this._highlight(item.label.toString(), this.searchString);
                                    }
                                }
                            }
                            else if (item.label === null) {
                                spanElement[0].innerHTML = this.emptyString;
                                if (this.emptyString == "") {
                                    spanElement[0].style.height = (item.height - 8) + 'px';
                                }
                            }
                            else {
                                if (spanElement[0].innerHTML !== item.value) {
                                    spanElement[0].innerHTML = item.value;
                                }
                                else if (item.label == "") {
                                    spanElement[0].innerHTML = " ";
                                }
                            }
                        }
                        else if (item.label == "" || item.label == null) {
                            spanElement[0].innerHTML = "";
                            spanElement[0].style.height = (item.height - 8) + 'px';
                        }
                    }

                    itemElement[0].style.left = item.left + 'px';
                    itemElement[0].style.top = item.initialTop - scrollValue + 'px';

                    item.element = spanElement[0];
                    if (this.isMaterialized() && !this.renderer) {
                        if (this._checkForHiddenParent) {
                            $(item.element).addClass('ripple');
                            $.jqx.ripple($(item.element));
                        }
                    }

                    //  $.data(spanElement[0], 'item', item);
                    if (item.title) {
                        spanElement[0].title = item.title;
                    }

                    if (this.equalItemsWidth && !item.isGroup) {
                        if (maxWidth == 0) {
                            var itemWidth = parseInt(width);
                            var diff = parseInt(spanElement.outerWidth()) - parseInt(spanElement.width());
                            itemWidth -= diff;
                            var borderSize = 1;
                            if (borderSize != null) {
                                borderSize = parseInt(borderSize);
                            }
                            else borderSize = 0;
                            if (this.host.css('box-sizing') === 'border-box') {
                                itemWidth -= 2;
                            }
                            //     itemWidth -= 2 * borderSize;
                            maxWidth = itemWidth;
                            if (this.checkboxes && this.hScrollBar[0].style.visibility == 'hidden') {
                                maxWidth -= this.checkboxSize + 13;
                            }
                        }
                        if (contentWidth > this.virtualSize.width) {
                            spanElement[0].style.width = maxWidth + 'px';
                            item.width = maxWidth;
                        }
                        else {
                            spanElement[0].style.width = -4 + this.virtualSize.width + 'px';
                            item.width = this.virtualSize.width - 4;
                        }
                    }
                    else {
                        if (spanElement.width() < this.host.width()) {
                            spanElement.width(this.host.width() - 2);
                        }
                    }

                    if (this.rtl) {
                        spanElement[0].style.textAlign = 'right';
                    }

                    if (this.autoItemsHeight) {
                        spanElement[0].style.whiteSpace = 'pre-line';
                        spanElement.width(maxWidth);
                        item.width = maxWidth;
                    }
                    middle = 0;
                    if (this.checkboxes && !item.isGroup) {
                        if (middle == 0) {
                            middle = (item.height - this.checkboxSize - 3) / 2;
                            middle = parseInt(middle);
                            middle++;
                        }
                        var checkbox = $(itemElement.children()[0]);
                        checkbox[0].item = item;

                        if (!this.rtl) {
                            var checkSize = (this.checkboxSize + 9);

                            if (spanElement[0].style.left != checkSize + 'px') {
                                spanElement[0].style.left = checkSize + 'px';
                            }
                        }
                        else {
                            if (spanElement[0].style.left != '0px') {
                                spanElement[0].style.left = '0px';
                            }
                        }
                        if (this.rtl) {
                            checkbox.css('left', 8 + item.width + 'px');
                        }
                        checkbox[0].style.top = middle + 'px';
                        checkbox[0].style.display = 'block';
                        checkbox[0].style.visibility = 'inherit';
                        var checked = item.checked;
                        var checkClass = item.checked ? " " + this.toThemeProperty("jqx-checkbox-check-checked") : "";
                        checkbox[0].setAttribute('checked', item.checked);
                        if (checkbox[0].firstChild && checkbox[0].firstChild.firstChild && checkbox[0].firstChild.firstChild.firstChild) {
                            if (checkbox[0].firstChild.firstChild) {
                                if (checked) {
                                    checkbox[0].firstChild.firstChild.firstChild.className = checkClass;
                                }
                                else if (checked === false) {
                                    checkbox[0].firstChild.firstChild.firstChild.className = "";
                                }
                                else if (checked === null) {
                                    checkbox[0].firstChild.firstChild.firstChild.className = this.toThemeProperty("jqx-checkbox-check-indeterminate");
                                }
                            }
                        }

                        if ($.jqx.ariaEnabled) {
                            if (checked) {
                                itemElement[0].setAttribute('aria-selected', true);
                            }
                            else {
                                itemElement[0].removeAttribute('aria-selected');
                            }
                        }

                    }
                    else if (this.checkboxes) {
                        var checkbox = $(itemElement.children()[0]);
                        checkbox.css({ 'display': 'none', 'visibility': 'inherit' });
                    }

                    if (!item.disabled && ((!this.filterable && this.selectedIndexes[item.visibleIndex] >= 0) || (item.selected && this.filterable))) {
                        spanElement.addClass(this.toThemeProperty('jqx-listitem-state-selected'));
                        spanElement.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                        if ($.jqx.ariaEnabled) {
                            itemElement[0].setAttribute('aria-selected', true);
                            this._activeElement = itemElement[0];
                        }
                    }
                    else if (!this.checkboxes) {
                        if ($.jqx.ariaEnabled) {
                            itemElement[0].removeAttribute('aria-selected');
                        }
                    }
                }
                else {
                    hideItem();
                }
            }
        },

        escapeHTML: function (value) {
            var entityMap = {
                '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;', '/': '&#x2F;', '`': '&#x60;', '=': '&#x3D;'
            };

            return String(value).replace(/[&<>"'`=\/]/g, function (s) { return entityMap[s] });
        },

        sanitizeHTML: function (value) {
            var that = this;
            var regExp = new RegExp('<\s*(applet|audio|base|bgsound|embed|form|iframe|isindex|keygen|layout|link|meta|object|script|svg|style|template|video)[^>]*>(.*?)<\s*/\s*(applet|audio|base|bgsound|embed|form|iframe|isindex|keygen|layout|link|meta|object|script|svg|style|template|video)>', 'ig');
            var result = String(value).replace(regExp, function (s) { return that.escapeHTML(s) });

            return result;
        },

        escape_HTML: function (html_str) {
            html_str = '' + html_str;
            if (html_str && (html_str.indexOf('onclick') >= 0 || html_str.indexOf('onload') >= 0 || html_str.indexOf('onerror') >= 0)) {
                return this.escapeHTML(html_str)
            }

            var sanitized = this.sanitizeHTML(html_str);

            return sanitized;
        },

        generatekey: function () {
            var S4 = function () {
                return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
            };
            return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
        },

        _calculateVirtualSize: function (ownerHeight) {
            if (this._renderOnDemand)
                return;

            var width = 0;
            var height = 2;
            var currentItem = 0;
            var spanElement = document.createElement('span');
            if (this.equalItemsWidth) {
                $(spanElement).css('float', 'left');
            }
            spanElement.style.whiteSpace = "pre";
            var itemsPerPage = 0;
            var hostHeight = undefined === ownerHeight ? this.host.outerHeight() : ownerHeight + 2;

            document.body.appendChild(spanElement);
            var length = this.items.length;
            var w = this.host.width();
            if (this.autoItemsHeight) {
                w -= 10;
                if (this.vScrollBar.css('visibility') != 'hidden') w -= 20;
            }

            if (this.autoItemsHeight || this.renderer || this.groups.length >= 1 || (length > 0 && this.items[0].html != null && this.items[0].html != "")) {
                for (var currentItem = 0; currentItem < length; currentItem++) {
                    var item = this.items[currentItem];

                    if (item.isGroup && (item.label == '' && item.html == '')) {
                        continue;
                    }

                    if (!item.visible)
                        continue;

                    var className = "";

                    if (!item.isGroup) {
                        className += this.toThemeProperty('jqx-widget jqx-listitem-state-normal jqx-rc-all');
                    }
                    else {
                        className += this.toThemeProperty('jqx-listitem-state-group jqx-rc-all');
                    }
                    className += " " + this.toThemeProperty('jqx-fill-state-normal');
                    if (this.isTouchDevice()) {
                        className += " " + this.toThemeProperty('jqx-touch');
                    }
                    spanElement.className = className;
                    if (this.autoItemsHeight) {
                        spanElement.style.whiteSpace = 'pre-line';
                        var checkSize = (this.checkboxSize + 9);

                        var checkWidth = this.checkboxes ? -checkSize : 0;
                        spanElement.style.width = (checkWidth + w) + 'px';
                    }

                    if (this.renderer) {
                        var html = this.renderer(item.index, item.label, item.value);
                        spanElement.innerHTML = html;
                    }
                    else {
                        if (item.html != null && item.html.toString().length > 0) {
                            spanElement.innerHTML = item.html;
                        }
                        else if (item.label != null || item.value != null) {
                            if (item.label != null) {
                                spanElement.innerHTML = this.escape_HTML(item.label);
                                if (item.label == "") spanElement.innerHTML = "Empty";
                            }
                            else spanElement.innerHTML = this.escape_HTML(item.value);
                        }
                    }

                    var spanHeight = spanElement.offsetHeight;
                    var spanWidth = spanElement.offsetWidth;

                    if (this.itemHeight > -1) {
                        spanHeight = this.itemHeight;
                    }

                    item.height = spanHeight;
                    item.width = spanWidth;
                    spanHeight++;
                    height += spanHeight;
                    width = Math.max(width, spanWidth);

                    if (height <= hostHeight) {
                        itemsPerPage++;
                    }
                }
            }
            else {
                var height = 0;
                var elementHeight = 0;
                var maxText = "";
                var maxTextLength = 0;
                var oldMaxTextLength = 0;
                var firstvisibleitem = -1;
                for (var currentItem = 0; currentItem < length; currentItem++) {
                    var item = this.items[currentItem];

                    if (item.isGroup && (item.label == '' && item.html == '')) {
                        continue;
                    }

                    if (!item.visible)
                        continue;
                    firstvisibleitem++;
                    var className = "";
                    if (firstvisibleitem == 0) {
                        className += this.toThemeProperty('jqx-listitem-state-normal jqx-rc-all');
                        className += " " + this.toThemeProperty('jqx-fill-state-normal');
                        className += " " + this.toThemeProperty('jqx-widget');
                        className += " " + this.toThemeProperty('jqx-listbox');
                        className += " " + this.toThemeProperty('jqx-widget-content');

                        if (this.isTouchDevice()) {
                            className += " " + this.toThemeProperty('jqx-touch');
                            className += " " + this.toThemeProperty('jqx-listitem-state-normal-touch');
                        }
                        spanElement.className = className;
                        if (this.autoItemsHeight) {
                            spanElement.style.whiteSpace = 'pre-line';
                            var checkSize = (this.checkboxSize + 9);
                            var checkWidth = this.checkboxes ? -checkSize : 0;
                            spanElement.style.width = (checkWidth + w) + 'px';
                        }

                        if (item.html == null || (item.label == "" || item.label == null)) {
                            spanElement.innerHTML = "Item";
                        }
                        else {
                            if (item.html != null && item.html.toString().length > 0) {
                                spanElement.innerHTML = item.html;
                            }
                            else if (item.label != null || item.value != null) {
                                if (item.label != null) {
                                    if (item.label.toString().match(new RegExp("\\w")) != null || item.label.toString().match(new RegExp("\\d")) != null) {
                                        spanElement.innerHTML = item.label;
                                    }
                                    else {
                                        spanElement.innerHTML = "Item";
                                    }
                                }
                                else spanElement.innerHTML = item.value;
                            }
                        }

                        var spanHeight = 1 + spanElement.offsetHeight;

                        if (this.itemHeight > -1) {
                            spanHeight = this.itemHeight;
                        }
                        elementHeight = spanHeight;
                    }

                    if (maxTextLength != undefined) {
                        oldMaxTextLength = maxTextLength;
                    }

                    if (item.html != null && item.html.toString().length > 0) {
                        maxTextLength = Math.max(maxTextLength, item.html.toString().length);
                        if (oldMaxTextLength != maxTextLength) {
                            maxText = item.html;
                        }
                    }
                    else if (item.label != null) {
                        maxTextLength = Math.max(maxTextLength, item.label.length);
                        if (oldMaxTextLength != maxTextLength) {
                            maxText = item.label;
                        }
                    }
                    else if (item.value != null) {
                        maxTextLength = Math.max(maxTextLength, item.value.length);
                        if (oldMaxTextLength != maxTextLength) {
                            maxText = item.value;
                        }
                    }

                    item.height = elementHeight;
                    height += elementHeight;
                    height++;
                    if (height <= hostHeight) {
                        itemsPerPage++;
                    }
                }
                spanElement.innerHTML = maxText;
                width = spanElement.offsetWidth;
            }

            height += 2;
            if (itemsPerPage < 10) itemsPerPage = 10;

            if (this.filterable) {
                height += this.filterHeight;
            }

            height -= 4;
            spanElement.parentNode.removeChild(spanElement);
            return { width: width, height: height, itemsPerPage: itemsPerPage };
        },

        _getVirtualItemsCount: function () {
            if (this.virtualItemsCount == 0) {
                var virtualItemsCount = parseInt(this.host.height()) / 5;
                if (virtualItemsCount > this.items.length) {
                    virtualItemsCount = this.items.length;
                }
                return virtualItemsCount;
            }
            else return this.virtualItemsCount;
        },

        _addItems: function (refreshUIItems) {
            if (this._renderOnDemand)
                return;

            var me = this;
            if (me.updatingListBox == true)
                return;

            if (me.items == undefined || me.items.length == 0) {
                me.virtualSize = { width: 0, height: 0, itemsPerPage: 0 };
                me._updatescrollbars();
                me.renderedVisibleItems = new Array();
                if (me.itemswrapper) {
                    me.itemswrapper.children().remove();
                }
                return;
            }
            var hostHeight = me.host.height();
            if (refreshUIItems == false) {
                var virtualSize = me._calculateVirtualSize(hostHeight);
                var virtualItemsCount = virtualSize.itemsPerPage * 2;
                if (me.autoHeight) {
                    virtualItemsCount = me.items.length;
                }

                me.virtualItemsCount = Math.min(virtualItemsCount, me.items.length);
                var virtualWidth = virtualSize.width;
                me.virtualSize = virtualSize;
                me._updatescrollbars();
                return;
            }
            var self = this;
            var top = 0;
            me.visibleItems = new Array();
            me.renderedVisibleItems = new Array();
            me._removeHandlers();
            if (me.allowDrag && me._enableDragDrop) {
                me.itemswrapper = null;
            }
            if (me.itemswrapper == null) {
                me.content[0].innerHTML = '';
                me.itemswrapper = $('<div style="outline: 0 none; overflow:hidden; width:100%; position: relative;"></div>');
                me.itemswrapper[0].style.height = (2 * hostHeight) + "px";
                me.content[0].appendChild(me.itemswrapper[0]);
            }

            var virtualSize = me._calculateVirtualSize(hostHeight);
            var virtualItemsCount = virtualSize.itemsPerPage * 2;
            if (me.autoHeight) {
                virtualItemsCount = me.items.length;
            }

            me.virtualItemsCount = Math.min(virtualItemsCount, me.items.length);
            var me = this;
            var virtualWidth = virtualSize.width;
            me.virtualSize = virtualSize;
            var wrapperWidth = Math.max(me.host.width(), 17 + virtualSize.width);
            me.itemswrapper[0].style.width = wrapperWidth + "px";
            var startIndex = 0;

            var html = "";
            var oldIE = $.jqx.browser.msie && $.jqx.browser.version < 9;
            var oldIEAttribute = oldIE ? ' unselectable="on"' : '';
            for (var virtualItemIndex = startIndex; virtualItemIndex < me.virtualItemsCount; virtualItemIndex++) {
                var item = me.items[virtualItemIndex];
                var id = 'listitem' + virtualItemIndex + me.element.id;
                if (me.theme != "") {
                    html += "<div" + oldIEAttribute + " role='option' id='" + id + "' class='jqx-listitem-element jqx-listitem-element-" + me.theme + "'>";
                }
                else {
                    html += "<div" + oldIEAttribute + " role='option' id='" + id + "' class='jqx-listitem-element'>";
                }
                if (me.checkboxes) {
                    var checkSize = this.checkboxSize + 8;

                    html += '<div style="background-color: transparent; padding: 0; margin: 0; overflow:hidden; position: absolute; float: left; width: ' + checkSize + 'px; height:  ' + checkSize + 'px;" class="' + me.toThemeProperty("jqx-checkbox") + ' ' + 'chkbox">';
                    var checkBoxContent = '<div class="' + me.toThemeProperty("jqx-checkbox-default") + ' ' + me.toThemeProperty("jqx-fill-state-normal") + ' ' + me.toThemeProperty("jqx-rc-all") + '"><div style="cursor: pointer; width:  ' + this.checkboxSize + 'px; height:  ' + this.checkboxSize + 'px;">';
                    var checkClass = item.checked ? " " + me.toThemeProperty("jqx-checkbox-check-checked") : "";
                    checkBoxContent += '<span style="width: ' + this.checkboxSize + 'px; height:  ' + this.checkboxSize + 'px;" class="checkBoxCheck' + checkClass + '"></span>';
                    checkBoxContent += '</div></div>';
                    html += checkBoxContent;
                    html += '</div>';
                }
                html += "<span" + oldIEAttribute + " style='white-space: pre; -ms-touch-action: none;'></span></div>"
            }

            if (self.WinJS) {
                me.itemswrapper.html(html);
            }
            else {
                me.itemswrapper[0].innerHTML = html;
            }

            var children = me.itemswrapper.children();
            for (var virtualItemIndex = startIndex; virtualItemIndex < me.virtualItemsCount; virtualItemIndex++) {
                var item = me.items[virtualItemIndex];
                var itemElement = $(children[virtualItemIndex]);

                if (me.allowDrag && me._enableDragDrop) {
                    itemElement.addClass('draggable');
                }

                if (me.checkboxes) {
                    var checkbox = $(itemElement.children()[0]);
                    itemElement.css('float', 'left');
                    var spanElement = $(itemElement[0].firstChild);
                    spanElement.css('float', 'left');
                }

                itemElement[0].style.height = item.height + 'px';
                itemElement[0].style.top = top + 'px';

                top += item.height + 1;
                me.visualItems[virtualItemIndex] = itemElement;
            };

            me._addHandlers();

            me._updatescrollbars();

            if (me.autoItemsHeight) {
                var virtualSize = me._calculateVirtualSize(hostHeight);
                var virtualItemsCount = virtualSize.itemsPerPage * 2;
                if (me.autoHeight) {
                    virtualItemsCount = me.items.length;
                }

                me.virtualItemsCount = Math.min(virtualItemsCount, me.items.length);
                var me = this;
                var virtualWidth = virtualSize.width;
                me.virtualSize = virtualSize;
                me._updatescrollbars();
            }

            if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                me.host.attr('hideFocus', true);
                me.host.find('div').attr('hideFocus', true);
            }
        },

        _updatescrollbars: function () {
            var me = this;
            if (!me.virtualSize) {
                return;
            }
            var virtualHeight = me.virtualSize.height;
            var virtualWidth = me.virtualSize.width;
            var vScrollInstance = me.vScrollInstance;
            var hScrollInstance = me.hScrollInstance;
            me._arrange(false);
            var hasChange = false;
            var outerWidth = me.host.outerWidth();
            var outerHeight = me.host.outerHeight();
            var hScrollOffset = 0;
            if (virtualWidth > outerWidth) {
                hScrollOffset = me.hScrollBar.outerHeight() + 2;
            }
            if (virtualHeight + hScrollOffset > outerHeight) {
                var oldmax = vScrollInstance.max;
                vScrollInstance.max = 2 + parseInt(virtualHeight) + hScrollOffset - parseInt(outerHeight - 2);
                if (me.vScrollBar[0].style.visibility != 'inherit') {
                    me.vScrollBar[0].style.visibility = 'inherit';
                    hasChange = true;
                }
                if (oldmax != vScrollInstance.max) {
                    vScrollInstance._arrange();
                }
            }
            else {
                if (me.vScrollBar[0].style.visibility != 'hidden') {
                    me.vScrollBar[0].style.visibility = 'hidden';
                    hasChange = true;
                    vScrollInstance.setPosition(0);
                }
            }

            var scrollOffset = 0;
            if (me.vScrollBar[0].style.visibility != 'hidden') {
                scrollOffset = me.scrollBarSize + 6;
            }

            var checkboxes = me.checkboxes ? (this.checkboxSize + 6) : 0;

            if (me.autoItemsHeight) {
                me.hScrollBar[0].style.visibility = 'hidden';
            }
            else {
                if (virtualWidth >= outerWidth - scrollOffset - checkboxes) {
                    var changedMax = hScrollInstance.max;
                    if (me.vScrollBar[0].style.visibility == 'inherit') {
                        hScrollInstance.max = checkboxes + scrollOffset + parseInt(virtualWidth) - me.host.width() + 2;
                    }
                    else {
                        hScrollInstance.max = checkboxes + parseInt(virtualWidth) - me.host.width() + 4;
                    }

                    if (me.hScrollBar[0].style.visibility != 'inherit') {
                        me.hScrollBar[0].style.visibility = 'inherit';
                        hasChange = true;
                    }
                    if (changedMax != hScrollInstance.max) {
                        hScrollInstance._arrange();
                    }
                    if (me.vScrollBar[0].style.visibility == 'inherit') {
                        vScrollInstance.max = 2 + parseInt(virtualHeight) + me.hScrollBar.outerHeight() + 2 - parseInt(me.host.height());
                    }
                }
                else {
                    if (me.hScrollBar[0].style.visibility != 'hidden') {
                        me.hScrollBar[0].style.visibility = 'hidden';
                        hasChange = true;
                    }
                }
            }

            hScrollInstance.setPosition(0);

            if (hasChange) {
                me._arrange();
            }

            if (me.itemswrapper) {
                me.itemswrapper[0].style.width = Math.max(0, Math.max(outerWidth - 2, 17 + virtualWidth)) + 'px';
                var wrapperWidth = Math.max(me.content.width(), 17 + me.virtualSize.width);
                me.itemswrapper[0].style.width = wrapperWidth + "px";

                me.itemswrapper[0].style.height = Math.max(0, 2 * outerHeight) + 'px';
            }

            var isTouchDevice = me.isTouchDevice();
            if (isTouchDevice) {
                if (me.vScrollBar.css('visibility') != 'visible' && me.hScrollBar.css('visibility') != 'visible') {
                    $.jqx.mobile.setTouchScroll(false, me.element.id);
                }
                else {
                    $.jqx.mobile.setTouchScroll(true, me.element.id);
                }
            }
        },

        clear: function () {
            this.source = null;
            this.visibleItems = new Array();
            this.renderedVisibleItems = new Array();
            this.itemsByValue = new Array();
            this.clearSelection();
            this.refresh();
        },

        // clears the selection.
        clearSelection: function (render) {
            for (var indx = 0; indx < this.selectedIndexes.length; indx++) {
                if (this.selectedIndexes[indx] && this.selectedIndexes[indx] != -1) {
                    this._raiseEvent('1', { index: indx, type: 'api', item: this.getVisibleItem(indx), originalEvent: null });
                }

                this.selectedIndexes[indx] = -1;
            }
            this.selectedIndex = -1;
            this.selectedValue = null;
            this.selectedValues = new Array();

            if (render != false) {
                this._renderItems();
            }
        },

        // unselects item by index.
        unselectIndex: function (index, render) {
            if (isNaN(index))
                return;

            this.selectedIndexes[index] = -1;

            var hasIndexes = false;
            for (var indx = 0; indx < this.selectedIndexes.length; indx++) {
                var sindex = this.selectedIndexes[indx];
                if (sindex != -1 && sindex != undefined) {
                    hasIndexes = true;
                }
            }
            if (!hasIndexes) {
                this.selectedValue = null;
                this.selectedIndex = -1;
                var visibleItem = this.getVisibleItem(index);
                if (visibleItem) {
                    if (this.selectedValues[visibleItem.value]) {
                        this.selectedValues[visibleItem.value] = null;
                    }
                }
            }

            if (render == undefined || render == true) {
                this._renderItems();
                this._raiseEvent('1', { index: index, type: 'api', item: this.getVisibleItem(index), originalEvent: null });
            }
            this._updateInputSelection();

            this._raiseEvent('2', { index: index, type: 'api', item: this.getItem(index) });
        },

        getInfo: function () {
            var that = this;
            var items = this.getItems();
            var visibleItems = this.getVisibleItems();
            var renderedItems = function () {
                var scrollValue = that.vScrollInstance.value;
                if (that.filterable)
                    scrollValue -= that.filterHeight;
                var rendered = new Array();
                for (var i = 0; i < visibleItems.length; i++) {
                    var item = visibleItems[i];
                    if (item) {
                        var itemTop = item.initialTop;
                        var itemHeight = item.height;
                        var visible = true;
                        if (itemTop + itemHeight - scrollValue < 0 || itemTop - scrollValue >= that.host.height()) {
                            visible = false;
                        }
                        if (visible) {
                            rendered.push(item);
                        }
                    }
                }
                return rendered;
            }();

            return { items: items, visibleItems: visibleItems, viewItems: renderedItems };
        },

        // gets item's instance.
        getItem: function (index) {
            if (index == -1 || isNaN(index) || typeof (index) === "string") {
                if (index === -1) {
                    return null;
                }
                return this.getItemByValue(index);
            }

            var result = null;
            var item = $.each(this.items, function () {
                if (this.index == index) {
                    result = this;
                    return false;
                }
            });

            return result;
        },

        getVisibleItem: function (index) {
            if (index == -1 || isNaN(index) || typeof (index) === "string") {
                if (index === -1) {
                    return null;
                }
                return this.getItemByValue(index);
            }
            return this.visibleItems[index];
        },

        getVisibleItems: function () {
            return this.visibleItems;
        },

        // checks a specific item by its index.
        checkIndex: function (index, render, raiseEvent) {
            if (!this.checkboxes) {
                return;
            }

            if (isNaN(index))
                return;

            if (index < 0 || index >= this.visibleItems.length)
                return;

            if (this.visibleItems[index] != null && this.visibleItems[index].disabled) {
                return;
            }

            if (this.disabled)
                return;

            var item = this.getItem(index);
            if (this.groups.length > 0 || this.filterable) {
                var item = this.getVisibleItem(index);
            }
            if (item != null) {
                var checkbox = $(item.checkBoxElement);
                item.checked = true;
                if (render == undefined || render == true) {
                    this._updateCheckedItems();
                }
            }

            if (raiseEvent == undefined || raiseEvent == true) {
                this._raiseEvent(3, { label: item.label, value: item.value, checked: true, item: item });
            }
        },

        getCheckedItems: function () {
            if (!this.checkboxes) {
                return null;
            }

            var checkedItems = new Array();
            if (this.items == undefined) return;

            $.each(this.items, function () {
                if (this.checked) {
                    checkedItems[checkedItems.length] = this;
                }
            });
            return checkedItems;
        },

        checkAll: function (raiseEvents) {
            if (!this.checkboxes) {
                return;
            }

            if (this.disabled)
                return;

            var me = this;
            $.each(this.items, function () {
                var item = this;
                var itemChecked = item.checked;

                this.checked = true;

                if (raiseEvents !== false && itemChecked !== true) {
                    me._raiseEvent(3, { label: item.label, value: item.value, checked: true, item: item });
                }
            });

            this._updateCheckedItems();
        },

        uncheckAll: function (raiseEvents) {
            if (!this.checkboxes) {
                return;
            }

            if (this.disabled)
                return;

            var me = this;
            $.each(this.items, function () {
                var item = this;
                var itemChecked = item.checked;

                this.checked = false;
                if (raiseEvents !== false && itemChecked !== false) {
                    this.checked = false;
                    me._raiseEvent(3, { label: item.label, value: item.value, checked: false, item: item });
                }
            });

            this._updateCheckedItems();
        },

        // unchecks a specific item by its index.
        uncheckIndex: function (index, render, raiseEvent) {
            if (!this.checkboxes) {
                return;
            }

            if (isNaN(index))
                return;

            if (index < 0 || index >= this.visibleItems.length)
                return;

            if (this.visibleItems[index] != null && this.visibleItems[index].disabled) {
                return;
            }

            if (this.disabled)
                return;

            var item = this.getItem(index);
            if (this.groups.length > 0 || this.filterable) {
                var item = this.getVisibleItem(index);
            }
            if (item != null) {
                var checkbox = $(item.checkBoxElement);
                item.checked = false;
                if (render == undefined || render == true) {
                    this._updateCheckedItems();
                }
            }
            if (raiseEvent == undefined || raiseEvent == true) {
                this._raiseEvent(3, { label: item.label, value: item.value, checked: false, item: item });
            }
        },

        // sets a specific item's checked property to null.
        indeterminateIndex: function (index, render, raiseEvent) {
            if (!this.checkboxes) {
                return;
            }

            if (isNaN(index))
                return;

            if (index < 0 || index >= this.visibleItems.length)
                return;

            if (this.visibleItems[index] != null && this.visibleItems[index].disabled) {
                return;
            }

            if (this.disabled)
                return;

            var item = this.getItem(index);
            if (this.groups.length > 0 || this.filterable) {
                var item = this.getVisibleItem(index);
            }
            if (item != null) {
                var checkbox = $(item.checkBoxElement);
                item.checked = null;
                if (render == undefined || render == true) {
                    this._updateCheckedItems();
                }
            }
            if (raiseEvent == undefined || raiseEvent == true) {
                this._raiseEvent(3, { checked: null });
            }
        },

        // gets the selected index.
        getSelectedIndex: function () {
            return this.selectedIndex;
        },

        // gets all selected items.
        getSelectedItems: function () {
            var visibleitems = this.getVisibleItems();
            var items = this.getItems();

            if (visibleitems && visibleitems.length !== items.length) {
                items = visibleitems;
            }

            var selectedIndexes = this.selectedIndexes;
            var selectedItems = [];
            // get selected items.
            for (var index in selectedIndexes) {
                if (selectedIndexes[index] != -1) {
                    selectedItems[selectedItems.length] = items[index];
                }
            }

            return selectedItems;
        },

        // gets the selected item.
        getSelectedItem: function () {
            var items = this.getSelectedItems();
            if (items && items.length > 0) {
                return items[0];
            }
            return null;
        },

        _updateCheckedItems: function () {
            var selectedIndex = this.selectedIndex;
            this.clearSelection(false);
            var items = this.getCheckedItems();
            this.selectedIndex = selectedIndex;

            this._renderItems();
            var selectedElement = $.data(this.element, 'hoveredItem');
            if (selectedElement != null) {
                $(selectedElement).addClass(this.toThemeProperty('jqx-listitem-state-hover'));
                $(selectedElement).addClass(this.toThemeProperty('jqx-fill-state-hover'));
            }

            this._updateInputSelection();
        },

        getItemByValue: function (value) {
            if (this.visibleItems == null) {
                return;
            }

            if (value && value.value) {
                value = value.value;
            }

            if (this.itemsByValue) {
                return this.itemsByValue[$.trim(value).split(" ").join("?")];
            }
            var items = this.visibleItems;

            for (var i = 0; i < items.length; i++) {
                if (items[i].value == value) {
                    return items[i];
                    break;
                }
            }
        },

        checkItem: function (item) {
            if (item != null) {
                var newItem = this._getItemByParam(item);
                return this.checkIndex(newItem.visibleIndex, true);
            }
            return false;
        },

        uncheckItem: function (item) {
            if (item != null) {
                var newItem = this._getItemByParam(item);
                return this.uncheckIndex(newItem.visibleIndex, true);
            }
            return false;
        },

        indeterminateItem: function (item) {
            if (item != null) {
                var newItem = this._getItemByParam(item);
                return this.indeterminateIndex(newItem.visibleIndex, true);
            }
            return false;
        },

        val: function (value) {
            if (!this.input)
                return;

            var isEmpty = function (obj) {
                for (var key in obj) {
                    if (obj.hasOwnProperty(key))
                        return false;
                }

                if (typeof value == "number")
                    return false;
                if (typeof value == "date")
                    return false;
                if (typeof value == "boolean")
                    return false;
                if (typeof value == "string")
                    return false;

                return true;
            }

            if (isEmpty(value) || arguments.length == 0) {
                return this.input.val();
            }

            var item = this.getItemByValue(value);
            if (item != null) {
                this.selectItem(item);
            }

            if (this.input) {
                return this.input.val();
            }
        },

        selectItem: function (item) {
            if (item != null) {
                if (item.index == undefined) {
                    var newItem = this.getItemByValue(item);
                    if (newItem) item = newItem;
                }
                return this.selectIndex(item.visibleIndex, true);
            }
            else this.clearSelection();
            return false;
        },

        unselectItem: function (item) {
            if (item != null) {
                if (item.index == undefined) {
                    var newItem = this.getItemByValue(item);
                    if (newItem) item = newItem;
                }
                return this.unselectIndex(item.visibleIndex, true);
            }
            return false;
        },

        // selects an item.
        selectIndex: function (index, ensureVisible, render, forceSelect, type, originalEvent) {
            if (isNaN(index))
                return;

            var tempSelectedIndex = this.selectedIndex;
            if (this.filterable) {
                this.selectedIndex = -1;
            }

            if (index < -1 || index >= this.visibleItems.length)
                return;

            if (this.visibleItems[index] != null && this.visibleItems[index].disabled) {
                return;
            }

            if (this.disabled)
                return;

            if (!this.multiple && !this.multipleextended && this.selectedIndex == index && !forceSelect && !this.checkboxes) {
                if (this.visibleItems && this.items && this.visibleItems.length != this.items.length) {
                    newItem = this.getVisibleItem(index);
                    if (newItem) {
                        this.selectedValue = newItem.value;
                        this.selectedValues[newItem.value] = newItem.value;
                    }
                }
                return;
            }
            if (this.checkboxes) {
                this._updateCheckedItems();
                var oldIndex = tempSelectedIndex;
                if (this.selectedIndex == index && !this.multiple) {
                    oldIndex = -1;
                }

                if (type == undefined) {
                    type = 'none';
                }

                var newItem = this.getItem(index);
                var oldItem = this.getItem(oldIndex);
                if (this.visibleItems && this.items && this.visibleItems.length != this.items.length) {
                    newItem = this.getVisibleItem(index);
                    oldItem = this.getVisibleItem(oldIndex);
                }

                this._raiseEvent('1', { index: oldIndex, type: type, item: oldItem, originalEvent: originalEvent });
                this.selectedIndex = index;
                this.selectedIndexes[oldIndex] = -1;
                this.selectedIndexes[index] = index;
                if (newItem) {
                    this.selectedValue = newItem.value;
                    this.selectedValues[newItem.value] = newItem.value;
                }
                this._raiseEvent('0', { index: index, type: type, item: newItem, originalEvent: originalEvent });
                this._renderItems();
                return;
            }

            this.focused = true;
            var newSelection = false;
            if (this.selectedIndex != index) newSelection = true;
            var oldIndex = tempSelectedIndex;
            if (this.selectedIndex == index && !this.multiple) {
                oldIndex = -1;
            }

            if (type == undefined) {
                type = 'none';
            }

            var newItem = this.getItem(index);
            var oldItem = this.getItem(oldIndex);
            if (this.visibleItems && this.items && this.visibleItems.length != this.items.length) {
                newItem = this.getVisibleItem(index);
                oldItem = this.getVisibleItem(oldIndex);
            }

            if (forceSelect != undefined && forceSelect) {
                this._raiseEvent('1', { index: oldIndex, type: type, item: oldItem, originalEvent: originalEvent });
                this.selectedIndex = index;
                this.selectedIndexes[oldIndex] = -1;
                this.selectedIndexes[index] = index;
                if (newItem) {
                    this.selectedValue = newItem.value;
                    this.selectedValues[newItem.value] = newItem.value;
                }
                this._raiseEvent('0', { index: index, type: type, item: newItem, originalEvent: originalEvent });
            }
            else {
                var me = this;
                var singleSelect = function (index, oldIndex, type, oldItem, newItem, originalEvent) {
                    me._raiseEvent('1', { index: oldIndex, type: type, item: oldItem, originalEvent: originalEvent });
                    me.selectedIndex = index;
                    me.selectedIndexes = [];
                    oldIndex = index;
                    me.selectedIndexes[index] = index;
                    me.selectedValues = new Array();
                    if (newItem) {
                        me.selectedValues[newItem.value] = newItem.value;
                    }

                    me._raiseEvent('0', { index: index, type: type, item: newItem, originalEvent: originalEvent });
                }
                var multipleSelect = function (index, oldIndex, type, oldItem, newItem, originalEvent) {
                    if (me.selectedIndexes[index] == undefined || me.selectedIndexes[index] == -1) {
                        me.selectedIndexes[index] = index;
                        me.selectedIndex = index;
                        if (newItem) {
                            me.selectedValues[newItem.value] = newItem.value;
                            me._raiseEvent('0', { index: index, type: type, item: newItem, originalEvent: originalEvent });
                        }
                    }
                    else {
                        oldIndex = me.selectedIndexes[index];
                        oldItem = me.getVisibleItem(oldIndex);
                        if (oldItem) {
                            me.selectedValues[oldItem.value] = null;
                        }

                        me.selectedIndexes[index] = -1;
                        me.selectedIndex = -1;
                        me._raiseEvent('1', { index: oldIndex, type: type, item: oldItem, originalEvent: originalEvent });
                    }
                }

                if (this.multipleextended) {
                    if (!this._shiftKey && !this._ctrlKey) {
                        if (type != 'keyboard' && type != 'mouse') {
                            multipleSelect(index, oldIndex, type, oldItem, newItem, originalEvent);
                            me._clickedIndex = index;
                        }
                        else {
                            this.clearSelection(false);
                            me._clickedIndex = index;
                            singleSelect(index, oldIndex, type, oldItem, newItem, originalEvent);
                        }
                    }
                    else if (this._ctrlKey) {
                        if (type == 'keyboard') {
                            this.clearSelection(false);
                            me._clickedIndex = index;
                        }
                        multipleSelect(index, oldIndex, type, oldItem, newItem, originalEvent);
                    }
                    else if (this._shiftKey) {
                        if (me._clickedIndex == undefined) me._clickedIndex = oldIndex;
                        var min = Math.min(me._clickedIndex, index);
                        var max = Math.max(me._clickedIndex, index);
                        this.clearSelection(false);
                        for (var i = min; i <= max; i++) {
                            me.selectedIndexes[i] = i;
                            me.selectedValues[me.getVisibleItem(i).value] = me.getVisibleItem(i).value;

                            me._raiseEvent('0', { index: i, type: type, item: this.getVisibleItem(i), originalEvent: originalEvent });
                        }
                        if (type != 'keyboard') {
                            me.selectedIndex = me._clickedIndex;
                        }
                        else {
                            me.selectedIndex = index;
                        }
                    }
                }
                else if (this.multiple) {
                    multipleSelect(index, oldIndex, type, oldItem, newItem, originalEvent);
                }
                else {
                    if (newItem) {
                        this.selectedValue = newItem.value;
                    }
                    singleSelect(index, oldIndex, type, oldItem, newItem, originalEvent);
                }
            }

            if (render == undefined || render == true) {
                this._renderItems();
            }

            if (ensureVisible != undefined && ensureVisible != null && ensureVisible == true) {
                this.ensureVisible(index);
            }

            this._raiseEvent('2', { index: index, item: newItem, oldItem: oldItem, type: type, originalEvent: originalEvent });
            this._updateInputSelection();

            return newSelection;
        },

        _updateInputSelection: function () {
            this._syncSelection();
            var selectedValues = new Array();
            if (this.input) {
                if (this.selectedIndex == -1) {
                    this.input.val("");
                }
                else {
                    if (this.items) {
                        if (this.items[this.selectedIndex] != undefined) {
                            this.input.val(this.items[this.selectedIndex].value);
                            selectedValues.push(this.items[this.selectedIndex].value);
                        }
                    }
                }
                if (this.multiple || this.multipleextended || this.checkboxes) {
                    var items = !this.checkboxes ? this.getSelectedItems() : this.getCheckedItems();
                    var str = "";
                    if (items) {
                        for (var i = 0; i < items.length; i++) {
                            if (undefined != items[i]) {
                                if (i == items.length - 1) {
                                    str += items[i].value;
                                }
                                else {
                                    str += items[i].value + ",";
                                }
                                selectedValues.push(items[i].value);
                            }
                        }
                        this.input.val(str);
                    }
                }
            }
            if (this.field && this.input) {
                if (this.field.nodeName.toLowerCase() == "select") {
                    $.each(this.field, function (index, value) {
                        $(this).removeAttr('selected');
                        this.selected = selectedValues.indexOf(this.value) >= 0;
                        if (this.selected) {
                            $(this).attr('selected', true);
                        }
                    });
                }
                else {
                    $.each(this.items, function (index, value) {
                        $(this.originalItem.originalItem).removeAttr('data-selected');
                        this.selected = selectedValues.indexOf(this.value) >= 0;
                        if (this.selected) {
                            $(this.originalItem.originalItem).attr('data-selected', true);
                        }
                    });
                }
            }
        },

        // checks whether an item is in the visible view.
        isIndexInView: function (index) {
            if (isNaN(index)) {
                return false;
            }

            if (!this.items)
                return false;

            if (index < 0 || index >= this.items.length) {
                return false;
            }

            var scrollValue = this.vScrollInstance.value;
            var filterHeight = 0;
            if (this.filterable)
                filterHeight = this.filterHeight;

            var item = this.visibleItems[index];
            if (item == undefined)
                return true;

            var itemTop = item.initialTop;
            var itemHeight = item.height;

            if (itemTop - scrollValue < filterHeight || itemTop - scrollValue + filterHeight + itemHeight >= this.host.outerHeight()) {
                return false;
            }

            return true;
        },

        //[optimize]
        _itemsInPage: function () {
            var itemsCount = 0;
            var me = this;

            if (this.items) {
                $.each(this.items, function () {
                    if ((this.initialTop + this.height) >= me.content.height()) {
                        return false;
                    }
                    itemsCount++;
                });
            }
            return itemsCount;
        },

        _firstItemIndex: function () {
            if (this.visibleItems != null) {
                if (this.visibleItems[0]) {
                    if (this.visibleItems[0].isGroup) {
                        return this._nextItemIndex(0);
                    }
                    else return 0;
                }
                else return 0;
            }

            return -1;
        },

        _lastItemIndex: function () {
            if (this.visibleItems != null) {
                if (this.visibleItems[this.visibleItems.length - 1]) {
                    if (this.visibleItems[this.visibleItems.length - 1].isGroup) {
                        return this._prevItemIndex(this.visibleItems.length - 1);
                    }
                    else return this.visibleItems.length - 1;
                }
                else return this.visibleItems.length - 1;
            }

            return -1;
        },

        _nextItemIndex: function (index) {
            for (var indx = index + 1; indx < this.visibleItems.length; indx++) {
                if (this.visibleItems[indx]) {
                    if (!this.visibleItems[indx].disabled && !this.visibleItems[indx].isGroup) {
                        return indx;
                    }
                }
            }

            return -1;
        },

        _prevItemIndex: function (index) {
            for (var indx = index - 1; indx >= 0; indx--) {
                if (this.visibleItems[indx]) {
                    if (!this.visibleItems[indx].disabled && !this.visibleItems[indx].isGroup) {
                        return indx;
                    }
                }
            }

            return -1;
        },

        clearFilter: function () {
            this.filterInput.val("");
            this._updateItemsVisibility("");
        },

        _search: function (event) {
            var that = this;
            var value = that.filterInput.val();

            if (event.keyCode == 9)
                return;

            if (that.searchMode == 'none' || that.searchMode == null || that.searchMode == 'undefined') {
                return;
            }

            if (event.keyCode == 16 || event.keyCode == 17 || event.keyCode == 20)
                return;

            if (event.keyCode == 37 || event.keyCode == 39)
                return false;

            if (event.altKey || event.keyCode == 18)
                return;

            if (event.keyCode >= 33 && event.keyCode <= 40) {
                return;
            }

            if (event.ctrlKey || event.metaKey || that.ctrlKey) {
                if (event.keyCode != 88 && event.keyCode != 86) {
                    return;
                }
            }

            if (value === that.searchString) {
                return;
            }

            that._updateItemsVisibility(value);
        },

        _updateItemsVisibility: function (value) {
            var items = this.getItems();
            if (items == undefined) {
                return { index: -1, matchItem: new Array() }
            }

            var me = this;
            var index = -1;
            var matchItems = new Array();
            var newItemsIndex = 0;

            $.each(items, function (i) {
                var itemValue = '';
                if (!this.isGroup) {
                    if (this.searchLabel) {
                        itemValue = this.searchLabel;
                    }
                    else if (this.label) {
                        itemValue = this.label;
                    }
                    else if (this.value) {
                        itemValue = this.value;
                    }
                    else if (this.title) {
                        itemValue = this.title;
                    }
                    else itemValue = 'jqxItem';
                    itemValue = itemValue.toString();
                    var matches = false;
                    switch (me.searchMode) {
                        case 'containsignorecase':
                            matches = $.jqx.string.containsIgnoreCase(itemValue, value);
                            break;
                        case 'contains':
                            matches = $.jqx.string.contains(itemValue, value);
                            break;
                        case 'equals':
                            matches = $.jqx.string.equals(itemValue, value);
                            break;
                        case 'equalsignorecase':
                            matches = $.jqx.string.equalsIgnoreCase(itemValue, value);
                            break;
                        case 'startswith':
                            matches = $.jqx.string.startsWith(itemValue, value);
                            break;
                        case 'startswithignorecase':
                            matches = $.jqx.string.startsWithIgnoreCase(itemValue, value);
                            break;
                        case 'endswith':
                            matches = $.jqx.string.endsWith(itemValue, value);
                            break;
                        case 'endswithignorecase':
                            matches = $.jqx.string.endsWithIgnoreCase(itemValue, value);
                            break;
                    }

                    if (!matches) {
                        this.visible = false;
                    }

                    if (matches) {
                        matchItems[newItemsIndex++] = this;
                        this.visible = true;
                        index = this.visibleIndex;
                    }

                    if (value == '') {
                        this.visible = true;
                        matches = false;
                    }
                }
            });

            me.renderedVisibleItems = new Array();
            me.visibleItems = new Array();
            me.vScrollInstance.setPosition(0, true);
            me._addItems(false);
            me._renderItems();
            for (var indx = 0; indx < me.items.length; indx++) {
                me.selectedIndexes[indx] = -1;
            }
            me.selectedIndex = -1;
            for (var selectedValue in me.selectedValues) {
                var value = me.selectedValues[selectedValue];
                var item = me.getItemByValue(value);
                if (item) {
                    if (item.visible) {
                        me.selectedIndex = item.visibleIndex;
                        me.selectedIndexes[item.visibleIndex] = item.visibleIndex;
                    }
                }
            }

            me._syncSelection();
            if (me.filterChange) {
                me.filterChange(value);
            }
        },

        // get all matches of a searched value.
        _getMatches: function (value, startindex) {
            if (value == undefined || value.length == 0)
                return -1;

            if (startindex == undefined) startindex = 0;

            var items = this.getItems();
            var me = this;
            var index = -1;
            var newItemsIndex = 0;

            $.each(items, function (i) {
                var itemValue = '';
                if (!this.isGroup) {
                    if (this.searchLabel) {
                        itemValue = this.searchLabel.toString();
                    }
                    else if (this.label) {
                        itemValue = this.label.toString();
                    }
                    else if (this.value) {
                        itemValue = this.value.toString();
                    }
                    else if (this.title) {
                        itemValue = this.title.toString();
                    }
                    else itemValue = 'jqxItem';

                    var mathes = false;
                    switch (me.searchMode) {
                        case 'containsignorecase':
                            mathes = $.jqx.string.containsIgnoreCase(itemValue, value);
                            break;
                        case 'contains':
                            mathes = $.jqx.string.contains(itemValue, value);
                            break;
                        case 'equals':
                            mathes = $.jqx.string.equals(itemValue, value);
                            break;
                        case 'equalsignorecase':
                            mathes = $.jqx.string.equalsIgnoreCase(itemValue, value);
                            break;
                        case 'startswith':
                            mathes = $.jqx.string.startsWith(itemValue, value);
                            break;
                        case 'startswithignorecase':
                            mathes = $.jqx.string.startsWithIgnoreCase(itemValue, value);
                            break;
                        case 'endswith':
                            mathes = $.jqx.string.endsWith(itemValue, value);
                            break;
                        case 'endswithignorecase':
                            mathes = $.jqx.string.endsWithIgnoreCase(itemValue, value);
                            break;
                    }

                    if (mathes && this.visibleIndex >= startindex) {
                        index = this.visibleIndex;
                        return false;
                    }
                }
            });

            return index;
        },

        // gets all items that match to a search value.
        findItems: function (value) {
            var items = this.getItems();
            var me = this;
            var index = 0;
            var matchItems = new Array();

            $.each(items, function (i) {
                var itemValue = '';
                if (!this.isGroup) {
                    if (this.label) {
                        itemValue = this.label;
                    }
                    else if (this.value) {
                        itemValue = this.value;
                    }
                    else if (this.title) {
                        itemValue = this.title;
                    }
                    else itemValue = 'jqxItem';

                    var mathes = false;
                    switch (me.searchMode) {
                        case 'containsignorecase':
                            mathes = $.jqx.string.containsIgnoreCase(itemValue, value);
                            break;
                        case 'contains':
                            mathes = $.jqx.string.contains(itemValue, value);
                            break;
                        case 'equals':
                            mathes = $.jqx.string.equals(itemValue, value);
                            break;
                        case 'equalsignorecase':
                            mathes = $.jqx.string.equalsIgnoreCase(itemValue, value);
                            break;
                        case 'startswith':
                            mathes = $.jqx.string.startsWith(itemValue, value);
                            break;
                        case 'startswithignorecase':
                            mathes = $.jqx.string.startsWithIgnoreCase(itemValue, value);
                            break;
                        case 'endswith':
                            mathes = $.jqx.string.endsWith(itemValue, value);
                            break;
                        case 'endswithignorecase':
                            mathes = $.jqx.string.endsWithIgnoreCase(itemValue, value);
                            break;
                    }

                    if (mathes) {
                        matchItems[index++] = this;
                    }
                }
            });

            return matchItems;
        },

        _syncSelection: function () {
            var that = this;
            if (that.filterable) {
                if (that.items) {
                    for (var i = 0; i < that.items.length; i++) {
                        var item = that.items[i];
                        item.selected = false;
                    }
                }
                for (var i = 0; i < that.visibleItems.length; i++) {
                    var item = that.visibleItems[i];
                    if (that.selectedIndexes && that.selectedIndexes[i] == item.visibleIndex) {
                        item.selected = true;
                    }
                }

                if (that.itemswrapper) {
                    that._renderItems();
                }
            }
        },

        _handleKeyDown: function (event) {
            var key = event.keyCode;
            var self = this;
            var index = self.selectedIndex;
            var selectedIndex = self.selectedIndex;
            var newSelection = false;

            if (!this.keyboardNavigation || !this.enableSelection)
                return;

            if (this.filterInput && event.target == this.filterInput[0]) {
                return;
            }

            if (event.target instanceof HTMLInputElement && $(event.target).ischildof(this.host)) {
                return;
            }

            var doClear = function () {
                if (self.multiple || self.checkboxes) {
                    self.clearSelection(false);
                }
            }

            if (event.altKey) key = -1;

            if (key == 32 && this.checkboxes) {
                var checkItem = this.getItem(index);
                if (checkItem != null) {
                    self._updateItemCheck(checkItem, index);
                    event.preventDefault();
                }
                self._searchString = "";
                self.selectIndex(checkItem.visibleIndex, false, true, true, 'keyboard', event);
                self._renderItems();
                return;
            }

            if (self.incrementalSearch) {
                var matchindex = -1;
                if (!self._searchString) {
                    self._searchString = "";
                }

                if ((key == 8 || key == 46) && self._searchString.length >= 1) {
                    self._searchString = self._searchString.substr(0, self._searchString.length - 1);
                }

                var letter = String.fromCharCode(key);

                if (event.key) {
                    letter = event.key;
                }

                var isDigit = (!isNaN(parseInt(letter)));
                var toReturn = false;
                if ((key >= 65 && key <= 97) || isDigit || key == 8 || key == 32 || key == 46) {
                    if (!event.shiftKey) {
                        letter = letter.toLocaleLowerCase();
                    }

                    var startIndex = 1 + self.selectedIndex;
                    if (key != 8 && key != 32 && key != 46) {
                        if (self._searchString.length > 0 && self._searchString.substr(0, 1) == letter) {
                            startIndex = 1 + self.selectedIndex;
                            self._searchString += letter;
                        }
                        else {
                            self._searchString += letter;
                        }
                    }

                    if (key == 32) {
                        self._searchString += " ";
                    }

                    var matches = this._getMatches(self._searchString, startIndex);
                    matchindex = matches;
                    if (matchindex == self._lastMatchIndex || matchindex == -1) {
                        var matches = this._getMatches(self._searchString, 0);
                        matchindex = matches;
                    }
                    self._lastMatchIndex = matchindex;

                    if (matchindex >= 0) {
                        var toSelect = function () {
                            doClear();
                            self.selectIndex(matchindex, false, false, false, 'keyboard', event);
                            var isInView = self.isIndexInView(matchindex);
                            if (!isInView) {
                                self.ensureVisible(matchindex);
                            }
                            else {
                                self._renderItems();
                            }
                        }
                        if (self._toSelectTimer) clearTimeout(self._toSelectTimer);
                        self._toSelectTimer = setTimeout(function () {
                            toSelect();
                        }, self.incrementalSearchKeyDownDelay);
                    }
                    toReturn = true;
                }

                if (self._searchTimer != undefined) {
                    clearTimeout(self._searchTimer);
                }

                if (key == 27 || key == 13) {
                    self._searchString = "";
                }

                self._searchTimer = setTimeout(function () {
                    self._searchString = "";
                    self._renderItems();
                }, self.incrementalSearchDelay);
                if (matchindex >= 0) {
                    return;
                }
                if (toReturn)
                    return false;
            }


            if (key == 33) {
                var itemsInPage = self._itemsInPage();
                if (self.selectedIndex - itemsInPage >= 0) {
                    doClear();
                    self.selectIndex(selectedIndex - itemsInPage, false, false, false, 'keyboard', event);
                }
                else {
                    doClear();
                    self.selectIndex(self._firstItemIndex(), false, false, false, 'keyboard', event);
                }
                self._searchString = "";
            }

            if (key == 32 && this.checkboxes) {
                var checkItem = this.getItem(index);
                if (checkItem != null) {
                    self._updateItemCheck(checkItem, index);
                    event.preventDefault();
                }
                self._searchString = "";
            }

            if (key == 36) {
                doClear();
                self.selectIndex(self._firstItemIndex(), false, false, false, 'keyboard', event);
                self._searchString = "";
            }

            if (key == 35) {
                doClear();
                self.selectIndex(self._lastItemIndex(), false, false, false, 'keyboard', event);
                self._searchString = "";
            }

            if (key == 34) {
                var itemsInPage = self._itemsInPage();
                if (self.selectedIndex + itemsInPage < self.visibleItems.length) {
                    doClear();
                    self.selectIndex(selectedIndex + itemsInPage, false, false, false, 'keyboard', event);
                }
                else {
                    doClear();
                    self.selectIndex(self._lastItemIndex(), false, false, false, 'keyboard', event);
                }
                self._searchString = "";
            }

            if (key == 38) {
                self._searchString = "";
                if (self.selectedIndex > 0) {
                    var newIndex = self._prevItemIndex(self.selectedIndex);
                    if (newIndex != self.selectedIndex && newIndex != -1) {
                        doClear();
                        self.selectIndex(newIndex, false, false, false, 'keyboard', event);
                    }
                    else return true;
                }
                else return false;
            }
            else if (key == 40) {
                self._searchString = "";
                if (self.selectedIndex + 1 < self.visibleItems.length) {
                    var newIndex = self._nextItemIndex(self.selectedIndex);
                    if (newIndex != self.selectedIndex && newIndex != -1) {
                        doClear();
                        self.selectIndex(newIndex, false, false, false, 'keyboard', event);
                    }
                    else return true;
                }
                else return false;
            }

            if (key == 35 || key == 36 || key == 38 || key == 40 || key == 34 || key == 33) {
                var isInView = self.isIndexInView(self.selectedIndex);
                if (!isInView) {
                    self.ensureVisible(self.selectedIndex);
                }
                else {
                    self._renderItems();
                }

                return false;
            }

            return true;
        },

        _updateItemCheck: function (checkItem, index) {
            if (this.disabled) return;

            if (checkItem.checked == true) {
                checkItem.checked = (checkItem.hasThreeStates && this.hasThreeStates) ? null : false;
            }
            else {
                checkItem.checked = checkItem.checked != null;
            }

            switch (checkItem.checked) {
                case true:
                    this.checkIndex(index);
                    break;
                case false:
                    this.uncheckIndex(index);
                    break;
                default:
                    this.indeterminateIndex(index);
                    break;
            }
        },

        // performs mouse wheel.
        wheel: function (event, self) {
            if (self.autoHeight || !self.enableMouseWheel) {
                event.returnValue = true;
                return true;
            }

            if (self.disabled) return true;

            var delta = 0;
            if (!event) /* For IE. */
                event = window.event;

            if (event.originalEvent && event.originalEvent.wheelDelta) {
                event.wheelDelta = event.originalEvent.wheelDelta;
            }

            if (event.wheelDelta) { /* IE/Opera. */
                delta = event.wheelDelta / 120;
            } else if (event.detail) { /** Mozilla case. */
                delta = -event.detail / 3;
            }
            if (delta) {
                var result = self._handleDelta(delta);
                if (result) {
                    if (event.preventDefault)
                        event.preventDefault();

                    if (event.originalEvent != null) {
                        event.originalEvent.mouseHandled = true;
                    }

                    if (event.stopPropagation != undefined) {
                        event.stopPropagation();
                    }
                }

                if (result) {
                    result = false;
                    event.returnValue = result;
                    return result;
                }
                else {
                    return false;
                }
            }

            if (event.preventDefault)
                event.preventDefault();
            event.returnValue = false;
        },

        _handleDelta: function (delta) {
            var oldvalue = this.vScrollInstance.value;
            if (delta < 0) {
                this.scrollDown();
            }
            else this.scrollUp();
            var newvalue = this.vScrollInstance.value;
            if (oldvalue != newvalue) {
                return true;
            }

            return false;
        },

        focus: function () {
            try {
                this.focused = true;
                this.host.focus();
                var me = this;
                setTimeout(function () {
                    me.host.focus();
                }, 25);
            }
            catch (error) {
            }
        },

        _removeHandlers: function () {
            var self = this;
            this.removeHandler($(document), 'keydown.listbox' + this.element.id);
            this.removeHandler($(document), 'keyup.listbox' + this.element.id);
            this.removeHandler(this.vScrollBar, 'valueChanged');
            this.removeHandler(this.hScrollBar, 'valueChanged');
            if (this._mousewheelfunc) {
                this.removeHandler(this.host, 'mousewheel', this._mousewheelfunc);
            }
            else {
                this.removeHandler(this.host, 'mousewheel');
            }

            this.removeHandler(this.host, 'keydown');
            this.removeHandler(this.content, 'mouseleave');
            this.removeHandler(this.content, 'focus');
            this.removeHandler(this.content, 'blur');
            this.removeHandler(this.host, 'focus');
            this.removeHandler(this.host, 'blur');
            this.removeHandler(this.content, 'mouseenter');
            this.removeHandler(this.content, 'mouseup');
            this.removeHandler(this.content, 'mousedown');
            this.removeHandler(this.content, 'touchend');

            if (this._mousemovefunc) {
                this.removeHandler(this.content, 'mousemove', this._mousemovefunc);
            }
            else {
                this.removeHandler(this.content, 'mousemove');
            }
            this.removeHandler(this.content, 'selectstart');
            if (this.overlayContent) {
                this.removeHandler(this.overlayContent, $.jqx.mobile.getTouchEventName('touchend'));
            }
        },

        _updateSize: function () {
            if (!this.virtualSize) {
                this._oldheight = null;
                this.virtualSize = this._calculateVirtualSize();
            }

            var self = this;
            self._arrange();
            if (self.host.height() != self._oldheight || self.host.width() != self._oldwidth) {
                var changedWidth = self.host.width() != self._oldwidth;

                if (self.autoItemsHeight) {
                    self._render(false);
                }
                else {
                    if (self.items) {
                        if (self.items.length > 0 && self.virtualItemsCount * self.items[0].height < self._oldheight - 2) {
                            self._render(false);
                        }
                        else {
                            var _oldScrollValue = self.vScrollInstance.value;
                            self._updatescrollbars();
                            self._renderItems();
                            if (_oldScrollValue < self.vScrollInstance.max) {
                                self.vScrollInstance.setPosition(_oldScrollValue);
                            }
                            else {
                                self.vScrollInstance.setPosition(self.vScrollInstance.max);
                            }
                        }
                    }
                }
                self._oldwidth = self.host.width();
                self._oldheight = self.host.height();
            }
        },

        _addHandlers: function () {
            var self = this;
            this.focused = false;
            var animating = false;
            var prevValue = 0;
            var object = null;
            var prevValue = 0;
            var newValue = 0;
            var lastScroll = new Date();
            var isTouchDevice = this.isTouchDevice();

            this.addHandler(this.vScrollBar, 'valueChanged', function (event) {
                if ($.jqx.browser.msie && $.jqx.browser.version > 9) {
                    setTimeout(function () {
                        self._renderItems();
                    }, 1);
                }
                else self._renderItems();
            });

            this.addHandler(this.hScrollBar, 'valueChanged', function () {
                self._renderItems();
            });

            if (this._mousewheelfunc) {
                this.removeHandler(this.host, 'mousewheel', this._mousewheelfunc);
            }

            this._mousewheelfunc = function (event) {
                self.wheel(event, self);
            };
            this.addHandler(this.host, 'mousewheel', this._mousewheelfunc);

            this.addHandler($(document), 'keydown.listbox' + this.element.id, function (event) {
                self._ctrlKey = event.ctrlKey || event.metaKey;
                self._shiftKey = event.shiftKey;
            });
            this.addHandler($(document), 'keyup.listbox' + this.element.id, function (event) {
                self._ctrlKey = event.ctrlKey || event.metaKey;
                self._shiftKey = event.shiftKey;
            });

            this.addHandler(this.host, 'keydown', function (event) {
                return self._handleKeyDown(event);
            });

            this.addHandler(this.content, 'mouseleave', function (event) {
                self.focused = false;
                var hoveredItem = $.data(self.element, 'hoveredItem');
                if (hoveredItem != null) {
                    $(hoveredItem).removeClass(self.toThemeProperty('jqx-listitem-state-hover'));
                    $(hoveredItem).removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                    $.data(self.element, 'hoveredItem', null);
                }
            });

            this.addHandler(this.content, 'focus', function (event) {
                if (!self.disabled) {
                    self.host.addClass(self.toThemeProperty('jqx-fill-state-focus'));
                    self.focused = true;
                }
            });

            this.addHandler(this.content, 'blur', function (event) {
                self.focused = false;
                self.host.removeClass(self.toThemeProperty('jqx-fill-state-focus'));
            });

            this.addHandler(this.host, 'focus', function (event) {
                if (!self.disabled) {
                    self.host.addClass(self.toThemeProperty('jqx-fill-state-focus'));
                    self.focused = true;
                }
            });

            this.addHandler(this.host, 'blur', function (event) {
                if ($.jqx.browser.msie && $.jqx.browser.version < 9 && self.focused) {
                    return;
                }

                self.host.removeClass(self.toThemeProperty('jqx-fill-state-focus'));
                self.focused = false;
            });

            this.addHandler(this.content, 'mouseenter', function (event) {
                self.focused = true;
            });
            var hasTransform = $.jqx.utilities.hasTransform(this.host);

            var isTouch = self.isTouchDevice() && this.touchMode !== true;
            var eventName = !isTouch ? 'mousedown' : 'touchend';
            var upEventName = !isTouch ? 'mouseup' : 'touchend';

            if (this.overlayContent) {
                this.addHandler(this.overlayContent, $.jqx.mobile.getTouchEventName('touchend'), function (event) {
                    if (!self.enableSelection) {
                        return true;
                    }

                    if (isTouch) {
                        self._newScroll = new Date();
                        if (self._newScroll - self._lastScroll < 500) {
                            return true;
                        }
                    }

                    var touches = $.jqx.mobile.getTouches(event);
                    var touch = touches[0];
                    if (touch != undefined) {
                        var selfOffset = self.host.offset();
                        var left = parseInt(touch.pageX);
                        var top = parseInt(touch.pageY);
                        if (self.touchMode == true) {
                            if (touch._pageX != undefined) {
                                left = parseInt(touch._pageX);
                                top = parseInt(touch._pageY);
                            }
                        }
                        left = left - selfOffset.left;
                        top = top - selfOffset.top;
                        var item = self._hitTest(left, top);
                        if (item != null && !item.isGroup) {
                            self._newScroll = new Date();
                            if (self._newScroll - self._lastScroll < 500) {
                                return false;
                            }
                            if (self.checkboxes) {
                                self._updateItemCheck(item, item.visibleIndex);
                                self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                return;
                            }


                            if (item.html.indexOf('href') != -1) {
                                setTimeout(function () {
                                    self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                    self.content.trigger('click');
                                    return false;
                                }, 100);
                            }
                            else {
                                self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                if (event.preventDefault) event.preventDefault();

                                self.content.trigger('click');
                                return false;
                            }
                        }
                    }
                });
            }
            else {
                var isMouseDown = false;

                this.addHandler(this.content, eventName, function (event) {
                    if (!self.enableSelection) {
                        return true;
                    }

                    isMouseDown = true;

                    if (isTouch) {
                        self._newScroll = new Date();
                        if (self._newScroll - self._lastScroll < 500) {
                            return false;
                        }
                    }

                    self.focused = true;
                    if (!self.isTouchDevice() && self.focusable) {
                        self.host.focus();
                    }
                    if (event.target.id != ('listBoxContent' + self.element.id) && self.itemswrapper[0] != event.target) {
                        var target = event.target;
                        var targetOffset = $(target).offset();
                        var selfOffset = self.host.offset();
                        if (hasTransform) {
                            var left = $.jqx.mobile.getLeftPos(target);
                            var top = $.jqx.mobile.getTopPos(target);
                            targetOffset.left = left; targetOffset.top = top;

                            left = $.jqx.mobile.getLeftPos(self.element);
                            top = $.jqx.mobile.getTopPos(self.element);
                            selfOffset.left = left; selfOffset.top = top;
                        }

                        var y = parseInt(targetOffset.top) - parseInt(selfOffset.top);
                        var x = parseInt(targetOffset.left) - parseInt(selfOffset.left);
                        var item = self._hitTest(x, y);
                        if (item != null && !item.isGroup) {
                            var doSelection = function (item, event) {
                                if (!self._shiftKey)
                                    self._clickedIndex = item.visibleIndex;
                                if (!self.checkboxes) {
                                    self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                } else {
                                    x = 20 + event.pageX - targetOffset.left;
                                    if (self.rtl) {
                                        var hscroll = self.hScrollBar.css('visibility') != 'hidden' ? self.hScrollInstance.max : self.host.width();
                                        if (x <= self.host.width() - 20) {
                                            if (!self.allowDrag) {
                                                self._updateItemCheck(item, item.visibleIndex);
                                                self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                            }
                                            else {
                                                setTimeout(function () {
                                                    if (!self._dragItem) {
                                                        if (!isMouseDown) {
                                                            self._updateItemCheck(item, item.visibleIndex);
                                                            self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                                        }
                                                    }
                                                }, 200);
                                            }
                                        }
                                    }
                                    else {
                                        if (x + self.hScrollInstance.value >= 20) {
                                            if (!self.allowDrag) {
                                                self._updateItemCheck(item, item.visibleIndex);
                                                self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                            }
                                            else {
                                                setTimeout(function () {
                                                    if (!self._dragItem) {
                                                        if (!isMouseDown) {
                                                            self._updateItemCheck(item, item.visibleIndex);
                                                            self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                                        }
                                                    }
                                                }, 200);
                                            }
                                        }
                                    }
                                }
                            }

                            if (!item.disabled) {
                                if (item.html.indexOf('href') != -1) {
                                    setTimeout(function () {
                                        doSelection(item, event);
                                    }, 100);
                                }
                                else {
                                    doSelection(item, event);
                                }
                            }
                        }
                        if (eventName == 'mousedown') {
                            var rightclick = false;
                            if (event.which) rightclick = (event.which == 3);
                            else if (event.button) rightclick = (event.button == 2);
                            if (rightclick) return true;
                            //     return false;
                        }
                    }

                    return true;
                });
            }

            this.addHandler(this.content, 'mouseup', function (event) {
                self.vScrollInstance.handlemouseup(self, event);
                isMouseDown = false;
            });

            if ($.jqx.browser.msie) {
                this.addHandler(this.content, 'selectstart', function (event) {
                    return false;
                });
            }

            // hover behavior.
            var isTouchDevice = this.isTouchDevice();
            if (this.enableHover && !isTouchDevice) {
                this._mousemovefunc = function (event) {
                    if (isTouchDevice)
                        return true;

                    if (!self.enableHover)
                        return true;

                    var which = $.jqx.browser.msie == true && $.jqx.browser.version < 9 ? 0 : 1;
                    if (event.target == null)
                        return true;

                    if (self.disabled)
                        return true;

                    self.focused = true;
                    var scrolling = self.vScrollInstance.isScrolling();
                    if (!scrolling && event.target.id != ('listBoxContent' + self.element.id)) {
                        if (self.itemswrapper[0] != event.target) {
                            var target = event.target;
                            var targetOffset = $(target).offset();
                            var selfOffset = self.host.offset();
                            if (hasTransform) {
                                var left = $.jqx.mobile.getLeftPos(target);
                                var top = $.jqx.mobile.getTopPos(target);
                                targetOffset.left = left; targetOffset.top = top;

                                left = $.jqx.mobile.getLeftPos(self.element);
                                top = $.jqx.mobile.getTopPos(self.element);
                                selfOffset.left = left; selfOffset.top = top;
                            }
                            var y = parseInt(targetOffset.top) - parseInt(selfOffset.top);
                            var x = parseInt(targetOffset.left) - parseInt(selfOffset.left);
                            var item = self._hitTest(x, y);
                            if (item != null && !item.isGroup && !item.disabled) {
                                var selectedElement = $.data(self.element, 'hoveredItem');
                                if (selectedElement != null) {
                                    $(selectedElement).removeClass(self.toThemeProperty('jqx-listitem-state-hover'));
                                    $(selectedElement).removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                                }

                                $.data(self.element, 'hoveredItem', item.element);
                                var $element = $(item.element);
                                $element.addClass(self.toThemeProperty('jqx-listitem-state-hover'));
                                $element.addClass(self.toThemeProperty('jqx-fill-state-hover'));
                            }
                        }
                    }
                };

                this.addHandler(this.content, 'mousemove', this._mousemovefunc);
            }
        },

        _arrange: function (arrangeScrollbars) {
            if (arrangeScrollbars == undefined) arrangeScrollbars = true;

            var me = this;
            var width = null;
            var height = null;
            var filterHeight = me.filterable ? me.filterHeight : 0;
            var computedStyle = window.getComputedStyle(this.element);
            var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
            var boxSizing = computedStyle.boxSizing;

            if (this.element.offsetWidth === 0) {
                borderSize = 2;
            }

            if (boxSizing === 'border-box' || isNaN(borderSize)) {
                borderSize = 0;
            }

            var _setHostHeight = function (height) {
                height = me.host.height() - borderSize;
                if (height == 0) {
                    height = 200;
                    me.host.height(height);
                }
                return height;
            }

            if (me.width != null && me.width.toString().indexOf("px") != -1) {
                width = me.width;
            }
            else
                if (me.width != undefined && !isNaN(me.width)) {
                    width = me.width;
                };

            if (me.height != null && me.height.toString().indexOf("px") != -1) {
                height = me.height;
            }
            else if (me.height != undefined && !isNaN(me.height)) {
                height = me.height;
            };

            if (me.width != null && me.width.toString().indexOf("%") != -1) {
                me.host.css("width", me.width);
                width = me.host.width();
            }
            if (me.height != null && me.height.toString().indexOf("%") != -1) {
                me.host.css("height", me.height);
                height = _setHostHeight(height);
            }

            if (width != null) {
                width = parseInt(width) - borderSize;
                if (parseInt(me.element.style.width) != parseInt(me.width)) {
                    me.element.style.width = parseInt(width) + "px";
                }
            }

            if (!me.autoHeight) {
                if (height != null) {
                    height = parseInt(height);
                    if (parseInt(me.element.style.height) != parseInt(me.height)) {
                        me.host.height(me.height);
                        _setHostHeight(height);
                    }
                }
            }
            else {
                if (me.virtualSize) {
                    if (me.hScrollBar.css('visibility') != 'hidden') {
                        me.host.height(me.virtualSize.height + parseInt(me.scrollBarSize) + 3);
                        me.height = me.virtualSize.height + parseInt(me.scrollBarSize) + 3;
                        height = me.height;
                    }
                    else {
                        me.host.height(me.virtualSize.height);
                        me.height = me.virtualSize.height;
                        height = me.virtualSize.height;
                    }
                }
            }

            // scrollbar Size.
            var scrollSize = me.scrollBarSize;
            if (isNaN(scrollSize)) {
                scrollSize = parseInt(scrollSize);
                if (isNaN(scrollSize)) {
                    scrollSize = '17px';
                }
                else scrollSize = scrollSize + 'px';
            }

            scrollSize = parseInt(scrollSize);
            var scrollOffset = 4;
            var bottomSizeOffset = 2;
            var rightSizeOffset = 1;
            // right scroll offset.
            if (me.vScrollBar) {
                if (me.vScrollBar[0].style.visibility != 'hidden') {
                    rightSizeOffset = scrollSize + scrollOffset;
                }
                else {
                    rightSizeOffset = 0;
                    me.vScrollInstance.setPosition(0);
                }
            }
            else return;
            if (scrollSize == 0) {
                rightSizeOffset = 0;
                bottomSizeOffset = 0;
            }

            if (me.hScrollBar) {
                // bottom scroll offset.
                if (me.hScrollBar[0].style.visibility != 'hidden') {
                    bottomSizeOffset = scrollSize + scrollOffset;
                }
                else {
                    me.hScrollInstance.setPosition(0);
                    bottomSizeOffset = 0;
                }
            }
            else return;

            if (me.autoItemsHeight) {
                me.hScrollBar[0].style.visibility = 'hidden';
                bottomSizeOffset = 0;
            }

            if (height == null) height = 0;
            var hScrollTop = parseInt(height) - scrollOffset - scrollSize;
            if (hScrollTop < 0) hScrollTop = 0;

            if (parseInt(me.hScrollBar[0].style.height) != scrollSize) {
                if (parseInt(scrollSize) < 0) {
                    scrollSize = 0;
                }

                me.hScrollBar[0].style.height = parseInt(scrollSize) + 'px';
            }

            if (me.hScrollBar[0].style.top != hScrollTop + 'px') {
                me.hScrollBar[0].style.top = hScrollTop + 'px';
                me.hScrollBar[0].style.left = '0px';
            }

            var hscrollwidth = width - scrollSize - scrollOffset;
            if (hscrollwidth < 0) hscrollwidth = 0;
            var hScrollWidth = hscrollwidth + 'px';

            if (me.hScrollBar[0].style.width != hScrollWidth) {
                me.hScrollBar[0].style.width = hScrollWidth;
            }

            if (rightSizeOffset <= 1) {
                if (width >= 2) {
                    me.hScrollBar[0].style.width = parseInt(width - 2) + 'px';
                }
            }

            if (scrollSize != parseInt(me.vScrollBar[0].style.width)) {
                me.vScrollBar[0].style.width = parseInt(scrollSize) + 'px';
            }
            if ((parseInt(height) - bottomSizeOffset) != parseInt(me.vScrollBar[0].style.height)) {
                var scrollHeight = parseInt(height) - bottomSizeOffset;
                if (scrollHeight < 0) scrollHeight = 0;
                me.vScrollBar[0].style.height = scrollHeight + 'px';
            }

            if (width == null) width = 0;
            var vScrollLeft = parseInt(width) - parseInt(scrollSize) - scrollOffset + 'px';
            if (this.host.css('box-sizing') === "border-box") {
                vScrollLeft = parseInt(vScrollLeft) - 2 + 'px';
            }
            if (vScrollLeft != me.vScrollBar[0].style.left) {
                if (parseInt(vScrollLeft) >= 0) {
                    me.vScrollBar[0].style.left = vScrollLeft;
                }
                me.vScrollBar[0].style.top = '0px';
            }

            var vScrollInstance = me.vScrollInstance;
            vScrollInstance.disabled = me.disabled;
            if (arrangeScrollbars) {
                vScrollInstance._arrange();
            }

            var hScrollInstance = me.hScrollInstance;
            hScrollInstance.disabled = me.disabled;
            if (arrangeScrollbars) {
                hScrollInstance._arrange();
            }

            if ((me.vScrollBar[0].style.visibility != 'hidden') && (me.hScrollBar[0].style.visibility != 'hidden')) {
                me.bottomRight[0].style.visibility = 'inherit';
                me.bottomRight[0].style.left = 1 + parseInt(me.vScrollBar[0].style.left) + 'px';
                me.bottomRight[0].style.top = 1 + parseInt(me.hScrollBar[0].style.top) + 'px';
                if (me.rtl) {
                    me.bottomRight.css({ left: 0 });
                }
                me.bottomRight[0].style.width = parseInt(scrollSize) + 3 + 'px';
                me.bottomRight[0].style.height = parseInt(scrollSize) + 3 + 'px';
            }
            else {
                me.bottomRight[0].style.visibility = 'hidden';
            }


            if (parseInt(me.content[0].style.width) != (parseInt(width) - rightSizeOffset)) {
                var w = parseInt(width) - rightSizeOffset;
                if (w < 0) w = 0;
                me.content[0].style.width = w + 'px';
            }

            if (me.rtl) {
                me.vScrollBar.css({ left: 0 + 'px', top: '0px' });
                me.hScrollBar.css({ left: me.vScrollBar.width() + 2 + 'px' });
                if (me.vScrollBar[0].style.visibility != 'hidden') {
                    me.content.css('margin-left', 4 + me.vScrollBar.width());
                }
                else {
                    me.content.css('margin-left', 0);
                    me.hScrollBar.css({ left: '0px' });
                }
                if (me.filterable && me.filterInput) {
                    me.filterInput.css({ left: me.vScrollBar.width() + 6 + 'px' });
                }
            }

            if (parseInt(me.content[0].style.height) != (parseInt(height) - bottomSizeOffset)) {
                var h = parseInt(height) - bottomSizeOffset;
                if (h < 0) h = 0;
                me.content[0].style.height = h + 'px';
                me.content[0].style.top = '0px';
            }
            if (filterHeight > 0) {
                me.content[0].style.top = filterHeight + 'px';
                me.content[0].style.height = parseInt(me.content[0].style.height) - filterHeight + 'px';
            }

            if (me.filterable) {
                me.filterInput[0].style.height = (filterHeight - 6) + 'px';
                me.filterInput[0].style.top = '3px';
                if (!me.rtl) {
                    me.filterInput[0].style.left = parseInt(me.content.css('left')) + 3 + 'px';
                }
                me.filterInput[0].style.width = parseInt(me.content.css('width')) - 7 + 'px';
                me.filter[0].style.display = "block";
            }
            else {
                me.filter[0].style.display = "none";
            }

            if (me.overlayContent) {
                me.overlayContent.width(parseInt(width) - rightSizeOffset);
                me.overlayContent.height(parseInt(height) - bottomSizeOffset);
            }
        },

        // scrolls to a list box item.
        ensureVisible: function (index, topItem) {
            if (isNaN(index)) {
                var item = this.getItemByValue(index);
                if (item) {
                    index = item.index;
                }
            }

            var isInView = this.isIndexInView(index);
            if (!isInView) {
                if (index < 0)
                    return;
                if (this.autoHeight) {
                    var vScrollInstance = $.data(this.vScrollBar[0], 'jqxScrollBar').instance;
                    vScrollInstance.setPosition(0);
                }
                else {
                    for (var indx = 0; indx < this.visibleItems.length; indx++) {
                        var item = this.visibleItems[indx];
                        if (item.visibleIndex == index && !item.isGroup) {
                            var vScrollInstance = $.data(this.vScrollBar[0], 'jqxScrollBar').instance;
                            var value = vScrollInstance.value;
                            var filterHeight = !this.filterable ? 0 : this.filterHeight + 2;

                            var hScrollVisible = this.hScrollBar.css('visibility') === 'hidden';
                            var hScrollOffset = hScrollVisible ? 0 : this.scrollBarSize + 4;
                            if (item.initialTop < value) {
                                vScrollInstance.setPosition(item.initialTop);
                                if (indx == 0) {
                                    vScrollInstance.setPosition(0);
                                }
                            }
                            else if (item.initialTop + item.height > value + this.host.height() - filterHeight) {
                                var hostHeight = this.host.height();

                                if (this.filterable) {
                                    vScrollInstance.setPosition(this.filterHeight + 2 + item.initialTop + item.height + 2 - hostHeight + hScrollOffset);
                                }
                                else {
                                    vScrollInstance.setPosition(item.initialTop + item.height + 2 - hostHeight + hScrollOffset);
                                    if (indx === this.visibleItems.length - 1) {
                                        vScrollInstance.setPosition(vScrollInstance.max);
                                    }
                                }
                                if (topItem) {
                                    var value = vScrollInstance.value;
                                    var desiredItemPosition = item.initialTop;
                                    if (this.filterable) {
                                        desiredItemPosition = this.filterHeight + 2 + item.initialTop;
                                    }
                                    if (value + hostHeight < vScrollInstance.max) {
                                        vScrollInstance.setPosition(desiredItemPosition);
                                    }
                                }
                            }

                            break;
                        }
                    }
                }
            }
            else {
                if (topItem) {
                    for (var indx = 0; indx < this.visibleItems.length; indx++) {
                        var item = this.visibleItems[indx];
                        if (item.visibleIndex == index && !item.isGroup) {
                            var value = this.vScrollInstance.value;
                            var desiredItemPosition = item.initialTop;
                            if (this.filterable) {
                                desiredItemPosition = this.filterHeight + 2 + item.initialTop;
                            }
                            if (value + this.host.height() < this.vScrollInstance.max) {
                                this.vScrollInstance.setPosition(desiredItemPosition);
                            }
                        }
                    }
                }
            }

            this._renderItems();
        },

        scrollTo: function (left, top) {
            if (this.vScrollBar.css('visibility') != 'hidden') {
                this.vScrollInstance.setPosition(top);
            }
            if (this.hScrollBar.css('visibility') != 'hidden') {
                this.hScrollInstance.setPosition(left);
            }
        },

        // scrolls down.
        scrollDown: function () {
            if (this.vScrollBar.css('visibility') == 'hidden')
                return false;

            var vScrollInstance = this.vScrollInstance;
            if (vScrollInstance.value + vScrollInstance.largestep <= vScrollInstance.max) {
                vScrollInstance.setPosition(vScrollInstance.value + vScrollInstance.largestep);
                return true;
            }
            else {
                vScrollInstance.setPosition(vScrollInstance.max);
                return true;
            }

            return false;
        },

        // scrolls up.
        scrollUp: function () {
            if (this.vScrollBar.css('visibility') == 'hidden')
                return false;

            var vScrollInstance = this.vScrollInstance;
            if (vScrollInstance.value - vScrollInstance.largestep >= vScrollInstance.min) {
                vScrollInstance.setPosition(vScrollInstance.value - vScrollInstance.largestep);
                return true;
            }
            else {
                if (vScrollInstance.value != vScrollInstance.min) {
                    vScrollInstance.setPosition(vScrollInstance.min);
                    return true;
                }
            }
            return false;
        },

        databind: function (source, initialRefresh) {
            this.records = new Array();
            var isdataadapter = source._source ? true : false;
            var dataadapter = new $.jqx.dataAdapter(source,
                {
                    autoBind: false
                }
            );

            if (isdataadapter) {
                dataadapter = source;
                source = source._source;
            }

            var initadapter = function (me) {
                if (source.type != undefined) {
                    dataadapter._options.type = source.type;
                }
                if (source.formatdata != undefined) {
                    dataadapter._options.formatData = source.formatdata;
                }
                if (source.contenttype != undefined) {
                    dataadapter._options.contentType = source.contenttype;
                }
                if (source.async != undefined) {
                    dataadapter._options.async = source.async;
                }
            }

            var updatefromadapter = function (me, type) {
                var getItem = function (record) {
                    var search = null;

                    if (typeof record === 'string') {
                        var label = record;
                        var value = record;
                        var group = '';
                    }
                    else if (me.displayMember != undefined && me.displayMember != "") {
                        var value = record[me.valueMember];
                        var label = record[me.displayMember];
                    }
                    var group = '';

                    if (me.groupMember) {
                        group = record[me.groupMember];
                    }
                    else if (record && record.group != undefined) {
                        group = record.group;
                    }
                    if (me.searchMember) {
                        search = record[me.searchMember];
                    }
                    else if (record && record.searchLabel != undefined) {
                        search = record.searchLabel;
                    }

                    if (!me.valueMember && !me.displayMember) {
                        if ($.type(record) == "string") {
                            label = value = record.toString();
                        }
                    }

                    if (record && record.label != undefined) {
                        var label = record.label;
                    }
                    if (record && record.value != undefined) {
                        var value = record.value;
                    }
                    var checked = false;
                    if (record && record.checked != undefined) {
                        checked = record.checked;
                    }
                    var html = '';
                    if (record && record.html != undefined) {
                        html = record.html;
                    }
                    var visible = true;
                    if (record && record.visible != undefined) {
                        visible = record.visible;
                    }
                    var disabled = false;
                    if (record && record.disabled != undefined) {
                        disabled = record.disabled;
                    }
                    var hasThreeStates = false;
                    if (record && record.hasThreeStates != undefined) {
                        hasThreeStates = record.hasThreeStates;
                    }

                    var listBoxItem = {};
                    listBoxItem.label = label;
                    listBoxItem.value = value;
                    listBoxItem.searchLabel = search;
                    listBoxItem.html = html;
                    listBoxItem.visible = visible;
                    listBoxItem.originalItem = record;
                    listBoxItem.group = group;
                    listBoxItem.groupHtml = '';
                    listBoxItem.disabled = disabled;
                    listBoxItem.checked = checked;
                    listBoxItem.hasThreeStates = hasThreeStates;

                    return listBoxItem;
                }

                if (type != undefined) {
                    var dataItem = dataadapter._changedrecords[0];
                    if (dataItem) {
                        $.each(dataadapter._changedrecords, function () {
                            var index = this.index;
                            var item = this.record;
                            if (type != 'remove') {
                                var mapItem = getItem(item);
                            }

                            switch (type) {
                                case "update":
                                    me.updateAt(mapItem, index);
                                    break;
                                case "add":
                                    me.insertAt(mapItem, index);
                                    break;
                                case "remove":
                                    me.removeAt(index);
                                    break;
                            }
                        });
                        return;
                    }
                }

                me.records = dataadapter.records;
                var recordslength = me.records.length;
                var items = new Array();
                for (var i = 0; i < recordslength; i++) {
                    var record = me.records[i];
                    var listBoxItem = getItem(record);
                    listBoxItem.index = i;
                    items[i] = listBoxItem;
                }
                me.items = me.loadItems(items, true);
                me._render();
                me._raiseEvent('6');
            }

            initadapter(this);

            var me = this;
            switch (source.datatype) {
                case "local":
                case "array":
                default:
                    if (source.localdata != null || $.isArray(source)) {
                        dataadapter.unbindBindingUpdate(this.element.id);
                        if (this.autoBind || (!this.autoBind && !initialRefresh)) {
                            dataadapter.dataBind();
                        }
                        updatefromadapter(this);
                        dataadapter.bindBindingUpdate(this.element.id, function (updatetype) {
                            updatefromadapter(me, updatetype);
                        });
                    }
                    break;
                case "json":
                case "jsonp":
                case "xml":
                case "xhtml":
                case "script":
                case "text":
                case "csv":
                case "tab":
                    {
                        if (source.localdata != null) {
                            dataadapter.unbindBindingUpdate(this.element.id);
                            if (this.autoBind || (!this.autoBind && !initialRefresh)) {
                                dataadapter.dataBind();
                            }
                            updatefromadapter(this);
                            dataadapter.bindBindingUpdate(this.element.id, function () {
                                updatefromadapter(me);
                            });
                            return;
                        }

                        var postdata = {};
                        if (dataadapter._options.data) {
                            $.extend(dataadapter._options.data, postdata);
                        }
                        else {
                            if (source.data) {
                                $.extend(postdata, source.data);
                            }
                            dataadapter._options.data = postdata;
                        }
                        var updateFunc = function () {
                            updatefromadapter(me);
                        }

                        dataadapter.unbindDownloadComplete(me.element.id);
                        dataadapter.bindDownloadComplete(me.element.id, updateFunc);


                        if (this.autoBind || (!this.autoBind && !initialRefresh)) {
                            dataadapter.dataBind();
                        }
                    }
            }
        },

        loadItems: function (items, adapter) {
            if (items == null) {
                this.groups = new Array();
                this.items = new Array();
                this.visualItems = new Array();
                return;
            }

            var self = this;
            var index = 0;
            var length = 0;
            var itemIndex = 0;
            this.groups = new Array();
            this.items = new Array();
            this.visualItems = new Array();
            var listItems = new Array();
            this.itemsByValue = new Array();

            $.map(items, function (item) {
                if (item == undefined)
                    return null;

                var listBoxItem = new $.jqx._jqxListBox.item();
                var group = item.group;
                var groupHtml = item.groupHtml;
                var title = item.title;
                var search = null;

                if (self.searchMember) {
                    search = item[self.searchMember];
                }
                else if (item && item.searchLabel != undefined) {
                    search = item.searchLabel;
                }


                if (title == null || title == undefined) {
                    title = '';
                }

                if (group == null || group == undefined) {
                    group = '';
                }
                if (self.groupMember) {
                    group = item[self.groupMember];
                }
                if (groupHtml == null || groupHtml == undefined) {
                    groupHtml = '';
                }

                if (!self.groups[group]) {
                    self.groups[group] = { items: new Array(), index: -1, caption: group, captionHtml: groupHtml };
                    index++;

                    var groupID = index + 'jqxGroup';
                    self.groups[groupID] = self.groups[group];
                    length++;
                    self.groups.length = length;
                }

                var uniqueGroup = self.groups[group];
                uniqueGroup.index++;
                uniqueGroup.items[uniqueGroup.index] = listBoxItem;

                if (typeof item === "string") {
                    listBoxItem.label = item;
                    listBoxItem.value = item;
                    if (arguments.length > 1 && arguments[1] && $.type(arguments[1]) == "string") {
                        listBoxItem.label = item;
                        listBoxItem.value = arguments[1];
                    }
                }
                else if (item.label == null && item.value == null && item.html == null && item.group == null && item.groupHtml == null) {
                    listBoxItem.label = item.toString();
                    listBoxItem.value = item.toString();
                }
                else {
                    listBoxItem.label = item.label;
                    listBoxItem.value = item.value;

                    if (listBoxItem.label === undefined)
                        listBoxItem.label = item.value;
                    if (listBoxItem.value === undefined)
                        listBoxItem.value = item.label;
                }

                if (typeof item != "string") {
                    if (item.label === undefined) {
                        if (self.displayMember != "") {
                            if (item[self.displayMember] != undefined) {
                                listBoxItem.label = item[self.displayMember];
                            }
                            else listBoxItem.label = "";
                        }
                    }

                    if (item.value === undefined) {
                        if (self.valueMember != "") {
                            listBoxItem.value = item[self.valueMember];
                        }
                    }
                }

                listBoxItem.hasThreeStates = item.hasThreeStates != undefined ? item.hasThreeStates : true;
                listBoxItem.originalItem = item;
                if (adapter) {
                    listBoxItem.originalItem = item.originalItem;
                }

                listBoxItem.title = title;
                if (title && listBoxItem.value === undefined && listBoxItem.label === undefined) {
                    listBoxItem.value = listBoxItem.label = title;
                }
                listBoxItem.html = item.html || '';
                if (item.html && item.html != '') {
                    //     listBoxItem.label = listBoxItem.value = item.html;
                    if (title && title != '') {
                        //           listBoxItem.label = listBoxItem.value = title;
                    }
                }

                if (typeof listBoxItem.label === "string") {
                    //          listBoxItem.label = listBoxItem.label.replace(/</g, '&lt;');
                    //        listBoxItem.label = listBoxItem.label.replace(/>/g, '&gt;');
                }

                listBoxItem.group = group;
                listBoxItem.checked = item.checked || false;
                listBoxItem.groupHtml = item.groupHtml || '';
                listBoxItem.disabled = item.disabled || false;
                listBoxItem.visible = item.visible != undefined ? item.visible : true;
                listBoxItem.searchLabel = search;
                listBoxItem.index = itemIndex;
                listItems[itemIndex] = listBoxItem;
                itemIndex++;
                return listBoxItem;
            });

            var itemsArray = new Array();
            var uniqueItemIndex = 0;

            if (this.fromSelect == undefined || this.fromSelect == false) {
                for (var indx = 0; indx < length; indx++) {
                    var index = indx + 1;
                    var groupID = index + 'jqxGroup';
                    var group = this.groups[groupID];
                    if (group == undefined || group == null)
                        break;

                    if (indx == 0 && group.caption == '' && group.captionHtml == '' && length <= 1) {
                        for (var i = 0; i < group.items.length; i++) {
                            var key = group.items[i].value;
                            if (group.items[i].value == undefined || group.items[i].value == null) key = i;
                            this.itemsByValue[$.trim(key).split(" ").join("?")] = group.items[i];
                        }
                        return group.items;
                    }
                    else {
                        var listBoxItem = new $.jqx._jqxListBox.item();
                        listBoxItem.isGroup = true;
                        listBoxItem.label = group.caption;
                        if (group.caption == '' && group.captionHtml == '') {
                            group.caption = this.emptyGroupText;
                            listBoxItem.label = group.caption;
                        }

                        listBoxItem.html = group.captionHtml;
                        itemsArray[uniqueItemIndex] = listBoxItem;

                        uniqueItemIndex++;
                    }

                    for (var j = 0; j < group.items.length; j++) {
                        itemsArray[uniqueItemIndex] = group.items[j];
                        var key = group.items[j].value;
                        if (group.items[j].value == "" || group.items[j].value == null) key = uniqueItemIndex;
                        self.itemsByValue[$.trim(key).split(" ").join("?")] = group.items[j];

                        uniqueItemIndex++;

                    }
                }
            }
            else {
                var uniqueItemIndex = 0;
                var checkedGroups = new Array();

                $.each(listItems, function () {
                    if (!checkedGroups[this.group]) {
                        if (this.group != '') {
                            var listBoxItem = new $.jqx._jqxListBox.item();
                            listBoxItem.isGroup = true;
                            listBoxItem.label = this.group;
                            itemsArray[uniqueItemIndex] = listBoxItem;
                            uniqueItemIndex++;
                            checkedGroups[this.group] = true;
                        }
                    }

                    itemsArray[uniqueItemIndex] = this;
                    var key = this.value;
                    if (this.value == "" || this.value == null) key = uniqueItemIndex - 1;
                    self.itemsByValue[$.trim(key).split(" ").join("?")] = this;

                    uniqueItemIndex++;
                });
            }

            return itemsArray;
        },

        _mapItem: function (item) {
            var listBoxItem = new $.jqx._jqxListBox.item();
            if (this.displayMember) {
                if (item.label == undefined) {
                    item.label = item[this.displayMember];
                }
                if (item.value == undefined) {
                    item.value = item[this.valueMember];
                }
            }

            if (typeof item === "string") {
                listBoxItem.label = item;
                listBoxItem.value = item;
            }
            else if (typeof item === 'number') {
                listBoxItem.label = item.toString();
                listBoxItem.value = item.toString();
            }
            else {
                listBoxItem.label = item.label !== undefined ? item.label : item.value;
                listBoxItem.value = item.value !== undefined ? item.value : item.label;
            }
            if (listBoxItem.label == undefined && listBoxItem.value == undefined && listBoxItem.html == undefined) {
                listBoxItem.label = listBoxItem.value = item;
            }

            listBoxItem.html = item.html || '';
            listBoxItem.group = item.group || '';
            listBoxItem.checked = item.checked || false;
            listBoxItem.title = item.title || '';
            listBoxItem.groupHtml = item.groupHtml || '';
            listBoxItem.disabled = item.disabled || false;
            listBoxItem.visible = item.visible || true;
            return listBoxItem;
        },

        // adds a new item.
        addItem: function (item) {
            return this.insertAt(item, this.items ? this.items.length : 0);
        },

        _getItemByParam: function (item) {
            if (item != null) {
                if (item.index == undefined) {
                    var newItem = this.getItemByValue(item);
                    if (newItem) item = newItem;
                }
            }
            return item;
        },

        insertItem: function (item, index) {
            var newItem = this._getItemByParam(item);
            return this.insertAt(newItem, index);
        },

        updateItem: function (item, oldItem) {
            var oldItemIndx = this._getItemByParam(oldItem);
            if (oldItemIndx && oldItemIndx.index != undefined) {
                return this.updateAt(item, oldItemIndx.index);
            }
            return false;
        },

        updateAt: function (item, index) {
            if (item != null) {
                var listBoxItem = this._mapItem(item);
                this.itemsByValue[$.trim(listBoxItem.value).split(" ").join("?")] = this.items[index];

                this.items[index].value = listBoxItem.value;
                this.items[index].label = listBoxItem.label;
                this.items[index].html = listBoxItem.html;
                this.items[index].disabled = listBoxItem.disabled;
                this._raiseEvent('9', { item: this.items[index] });

            }
            this._cachedItemHtml = [];
            this._renderItems();
            if (this.rendered) {
                this.rendered();
            }
        },

        // inserts an item at a specific position.
        insertAt: function (item, index) {
            if (item == null)
                return false;

            this._cachedItemHtml = [];
            if (this.items == undefined || this.items.length == 0) {
                this.source = new Array();
                this.refresh();
                var listBoxItem = this._mapItem(item);
                listBoxItem.index = 0;
                this.items[this.items.length] = listBoxItem;
                this._addItems(true);
                this._renderItems();
                if (this.rendered) {
                    this.rendered();
                }
                if (this.allowDrag && this._enableDragDrop) {
                    this._enableDragDrop();
                }
                var key = listBoxItem.value;
                if (listBoxItem.value == "" || listBoxItem.value == null) key = index;
                this.itemsByValue[$.trim(key).split(" ").join("?")] = listBoxItem;

                return false;
            }

            var listBoxItem = this._mapItem(item);
            if (index == -1 || index == undefined || index == null || index >= this.items.length) {
                listBoxItem.index = this.items.length;
                this.items[this.items.length] = listBoxItem;
            }
            else {
                var itemsArray = new Array();
                var currentItemIndex = 0;
                var inserted = false;
                var visualItemIndex = 0;
                for (var itemIndex = 0; itemIndex < this.items.length; itemIndex++) {
                    if (this.items[itemIndex].isGroup == false) {
                        if (visualItemIndex >= index && !inserted) {
                            itemsArray[currentItemIndex++] = listBoxItem;
                            listBoxItem.index = index;
                            visualItemIndex++;
                            inserted = true;
                        }
                    }

                    itemsArray[currentItemIndex] = this.items[itemIndex];
                    if (!this.items[itemIndex].isGroup) {
                        itemsArray[currentItemIndex].index = visualItemIndex;
                        visualItemIndex++;
                    }
                    currentItemIndex++;
                }

                this.items = itemsArray;
            }

            var key = listBoxItem.value;
            if (listBoxItem.value == "" || listBoxItem.value == null) key = index;
            this.itemsByValue[$.trim(key).split(" ").join("?")] = listBoxItem;

            this.visibleItems = new Array();
            this.renderedVisibleItems = new Array();
            var vScrollInstance = $.data(this.vScrollBar[0], 'jqxScrollBar').instance;
            var value = vScrollInstance.value;
            vScrollInstance.setPosition(0);
            if ((this.allowDrag && this._enableDragDrop) || (this.virtualSize && this.virtualSize.height < 10 + this.host.height())) {
                this._addItems(true);
            }
            else {
                this._addItems(false);
            }

            if (this.groups.length > 1) {
            }

            this._renderItems();
            if (this.allowDrag && this._enableDragDrop) {
                this._enableDragDrop();
            }
            vScrollInstance.setPosition(value);

            this._raiseEvent('7', { item: listBoxItem });

            if (this.rendered) {
                this.rendered();
            }

            return true;
        },

        // removes an item from a specific position.
        removeAt: function (index) {
            if (index < 0 || index > this.items.length - 1)
                return false;
            if (index == undefined)
                return false;

            var itemHeight = this.items[index].height;
            var key = this.items[index].value;
            if (key == "" || key == null) key = index;
            this.itemsByValue[$.trim(key).split(" ").join("?")] = null;
            var listBoxItem = this.items[index];
            if (this.groups.length > 1) {
                var nonGroups = new Array();
                for (var itemIndex = 0; itemIndex < this.items.length; itemIndex++) {
                    if (!this.items[itemIndex].isGroup) {
                        nonGroups.push({ item: this.items[itemIndex], key: itemIndex });
                    }
                }
                if (nonGroups[index]) {
                    this.items.splice(nonGroups[index].key, 1);
                }
                else return false;
            }
            else {
                this.items.splice(index, 1);
            }

            var itemsInGroup = 0;
            var groupIndex = -1;
            for (var i = 0; i < this.items.length; i++) {
                var item = this.items[i];

                if (item.isGroup) {
                    itemsInGroup = 0;
                    groupIndex = i;
                }
                else if (groupIndex >= 0) {
                    itemsInGroup++;
                }
            }

            if (itemsInGroup === 0 && groupIndex >= 0) {
                this.items.splice(groupIndex, 1);
            }

            var itemsArray = new Array();
            var currentItemIndex = 0;
            var inserted = false;
            var visualItemIndex = 0;
            for (var itemIndex = 0; itemIndex < this.items.length; itemIndex++) {
                itemsArray[currentItemIndex] = this.items[itemIndex];
                if (!this.items[itemIndex].isGroup) {
                    itemsArray[currentItemIndex].index = visualItemIndex;
                    visualItemIndex++;
                }
                currentItemIndex++;
            }

            this.items = itemsArray;

            var vScrollInstance = $.data(this.vScrollBar[0], 'jqxScrollBar').instance;
            var vScrollInstance = $.data(this.vScrollBar[0], 'jqxScrollBar').instance;
            var value = vScrollInstance.value;
            vScrollInstance.setPosition(0);

            this.visibleItems = new Array();
            this.renderedVisibleItems = new Array();
            if (this.items.length > 0) {
                if (this.virtualSize) {
                    this.virtualSize.height -= itemHeight;
                    var virtualItemsCount = this.virtualSize.itemsPerPage * 2;
                    if (this.autoHeight) {
                        virtualItemsCount = this.items.length;
                    }

                    this.virtualItemsCount = Math.min(virtualItemsCount, this.items.length);
                }

                this._updatescrollbars();
            }
            else {
                this._addItems();
            }
            this._renderItems();
            if (this.allowDrag && this._enableDragDrop) {
                this._enableDragDrop();
            }
            if (this.vScrollBar.css('visibility') != 'hidden') {
                vScrollInstance.setPosition(value);
            }
            else {
                vScrollInstance.setPosition(0);
            }
            this.itemsByValue = new Array();
            for (var i = 0; i < this.items.length; i++) {
                var key = this.items[i].value;
                if (this.items[i].value == "" || this.items[i].value == null) key = i;
                this.itemsByValue[$.trim(key).split(" ").join("?")] = this.items[i];
            }
            this._raiseEvent('8', { item: listBoxItem });

            if (this.items.length === 0) {
                this.selectedIndex = -1;
                this.selectedValue = null;
                this._updateInputSelection();
            }
            if (this.rendered) {
                this.rendered();
            }

            return true;
        },

        removeItem: function (item, removed) {
            var newItem = this._getItemByParam(item);
            var index = -1;
            if (newItem && newItem.index != undefined && removed !== true) {
                for (var i = 0; i < this.items.length; i++) {
                    if (this.items[i].label == newItem.label && this.items[i].value == newItem.value) {
                        index = i;
                        break;
                    }
                }
                if (index != -1) {
                    return this.removeAt(index);
                }
            }
            if (index == -1) {
                return this.removeAt(newItem.index);
            }
        },

        // gets all items.
        getItems: function () {
            return this.items;
        },

        disableItem: function (item) {
            var newItem = this._getItemByParam(item);
            this.disableAt(newItem.index);
        },

        enableItem: function (item) {
            var newItem = this._getItemByParam(item);
            this.enableAt(newItem.index);
        },

        // disables an item at position.
        disableAt: function (index) {
            if (!this.items)
                return false;

            if (index < 0 || index > this.items.length - 1)
                return false;

            this.items[index].disabled = true;
            this._renderItems();
            return true;
        },

        // enables an item at position.
        enableAt: function (index) {
            if (!this.items)
                return false;

            if (index < 0 || index > this.items.length - 1)
                return false;

            this.items[index].disabled = false;
            this._renderItems();
            return true;
        },

        destroy: function () {
            if (this.source && this.source.unbindBindingUpdate) {
                this.source.unbindBindingUpdate(this.element.id);
            }

            this._removeHandlers();
            this.vScrollBar.jqxScrollBar('destroy');
            this.hScrollBar.jqxScrollBar('destroy');
            this.vScrollBar.remove();
            this.hScrollBar.remove();
            this.content.remove();
            $.jqx.utilities.resize(this.host, null, true);

            var vars = $.data(this.element, "jqxListBox");
            delete this.hScrollInstance;
            delete this.vScrollInstance;
            delete this.vScrollBar;
            delete this.hScrollBar;
            delete this.content;
            delete this.bottomRight;
            delete this.itemswrapper;
            delete this.visualItems;
            delete this.visibleItems;
            delete this.items;
            delete this.groups;
            delete this.renderedVisibleItems;
            delete this._mousewheelfunc;
            delete this._mousemovefunc;
            delete this._cachedItemHtml;
            delete this.itemsByValue;
            delete this._activeElement;
            delete this.source;
            delete this.events;

            if (this.input) {
                this.input.remove();
                delete this.input;
            }
            if (vars) {
                delete vars.instance;
            }
            this.host.removeData();
            this.host.removeClass();
            this.host.remove();
            this.element = null;
            delete this.element;
            this.host = null;
            delete this.set;
            delete this.get;
            delete this.call;
            delete this.host;
        },

        _raiseEvent: function (id, arg) {
            if (this._stopEvents == true)
                return true;

            if (arg == undefined)
                arg = { owner: null };

            var evt = this.events[id];
            var args = arg;
            args.owner = this;
            this._updateInputSelection();
            var event = new $.Event(evt);
            event.owner = this;
            event.args = args;
            if (this.host != null) {
                var result = this.host.trigger(event);
            }
            return result;
        }
    })
})(jqxBaseFramework);

(function ($) {
    $.jqx.parseSourceTag = function (field) {
        var items = new Array();
        var options = $(field).find('option');
        var groups = $(field).find('optgroup');
        var ul = false;
        if (options.length === 0) {
            options = $(field).find('li');
            if (options.length > 0) {
                ul = true;
            }
        }
        if (options.length === 0) {
            var data = [];

            // select rows.
            var rows = $(field).find("tr");
            // select columns.
            var columns = $(field).find("th");
            var rowOffset = 0;

            if (columns.length === 0 && rows.length > 0) {
                columns = $(rows[0]).find("td");
                rowOffset = 1;
            }


            var sourceColumns = [];
            var dataFields = [];

            var data = [];
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                var datarow = {};

                if (i === rowOffset + 1) {
                    dataFields = [];
                }

                for (var j = 0; j < columns.length; j++) {
                    // get column's title.
                    var columnName = $.trim($(columns[j]).text());
                    // select cell.
                    var cell = $(row).find('td:eq(' + j + ')');
                    datarow[columnName] = $.trim(cell.text());

                    if (i === rowOffset) {
                        sourceColumns.push({ text: columnName, dataField: columnName });
                        dataFields.push({ name: columnName });
                    }

                    if (i === rowOffset + 1) {
                        var type = typeof datarow[columnName];
                        var format = '';

                        if (type === "string") {
                            if (datarow[columnName] === "true" || datarow[columnName] === "false") {
                                type = "bool";
                            }
                            else if (!isNaN(parseFloat(datarow[columnName])) && datarow[columnName].indexOf('-') === -1 && datarow[columnName].indexOf('/') === -1) {
                                type = "number";

                                if (datarow[columnName].indexOf('.') >= 0) {
                                    format = "f";
                                }
                                else {
                                    format = "n";
                                }
                            }
                            else if (datarow[columnName].indexOf('$') >= 0 || datarow[columnName].indexOf('%') >= 0) {
                                type = "number";
                                if (datarow[columnName].indexOf('$') >= 0) {
                                    format = "c";
                                }
                                if (datarow[columnName].indexOf('%') >= 0) {
                                    format = "p";
                                }
                                datarow[columnName] = datarow[columnName].replace('%', '').replace('$', '');
                            }
                            else if (new Date(datarow[columnName]).toString() !== "Invalid Date") {
                                type = "date";
                                format = "d";
                            }
                        }
                        sourceColumns[j].cellsformat = format;
                        if (type === "number") {
                            sourceColumns[j].cellsalign = "right";
                            sourceColumns[j].align = "right";
                        }
                        dataFields.push({ name: columnName, type: type });
                    }
                }

                if (i >= 1) {
                    data[data.length] = datarow;
                }
            }

            var source = {
                localdata: data,
                datatype: "array",
                datafields: dataFields
            };

            return { source: new $.jqx.dataAdapter(source), columns: sourceColumns };
        }

        var selectedOption = null;
        var index = 0;
        var selectedOption = -1;
        var that = this;
        var groupsArray = new Array();

        $.each(options, function (index) {
            var hasGroup = groups.find(this).length > 0;
            var group = null;

            if (this.text != null && (this.label == null || this.label == '')) {
                this.label = this.text;
            }
            if (ul === true) {
                this.label = $(this).text().trim();
                this.selected = $(this).attr('data-selected');
                this.checked = this.selected;
                this.value = $(this).attr('data-value') || index;
                this.disabled = $(this).attr('disabled');
            }

            var item = { style: this.style.cssText, selected: this.selected, html: this.innerHTML.trim(), classes: this.className, disabled: this.disabled, value: this.value, label: this.label, title: this.title, originalItem: this };

            var ie7 = $.jqx.browser.msie && $.jqx.browser.version < 8;
            if (ie7 && !ul) {
                if (item.value == '' && this.text != null && this.text.length > 0) {
                    item.value = this.text;
                }
            }

            if (hasGroup) {
                group = groups.find(this).parent()[0].label;
                item.group = group;
                if (!groupsArray[group]) {
                    groupsArray[group] = new Array();
                    groupsArray.length++;
                }
                groupsArray[group].push(item);
            }

            if (this.selected) {
                selectedOption = index;
            }
            item.checked = this.selected;
            if (item.label !== undefined) {
                items.push(item);
            }
        });
        if (groupsArray.length > 0) {
            var groupItems = new Array();
            for (var obj in groupsArray) {
                if (obj === "indexOf") continue;

                var originalItem = null;
                for (var i = 0; i < groups.length; i++) {
                    if (obj === groups[i].label || groups[i].text) {
                        originalItem = groups[i];
                        break;
                    }
                }

                $.each(groupsArray[obj], function (index, value) {
                    if (this.label !== undefined) {
                        groupItems.push(this);
                    }
                });
            };
        }

        if (groupItems && groupItems.length > 0) {
            return { items: groupItems, index: selectedOption };
        }
        else {
            return { items: items, index: selectedOption };
        }
    }

    $.jqx._jqxListBox.item = function () {
        var result =
        {
            group: '',
            groupHtml: '',
            selected: false,
            isGroup: false,
            highlighted: false,
            value: null,
            label: '',
            html: null,
            visible: true,
            disabled: false,
            element: null,
            width: null,
            height: null,
            initialTop: null,
            top: null,
            left: null,
            title: '',
            index: -1,
            checkBoxElement: null,
            originalItem: null,
            checked: false,
            visibleIndex: -1
        }
        return result;
    }
})(jqxBaseFramework);
})();



/***/ }),

/***/ 1610:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {

    $.jqx.jqxWidget("jqxMenu", "", {});

    $.extend($.jqx._jqxMenu.prototype, {
        defineInstance: function () {
            var settings = {
                //Type: Array
                //Gets the menu's items.
                items: new Array(),
                //Type: String.
                //Default: 'horizontal'.
                //Gets or sets the menu's display mode.
                //Possible Values: 'horizontal', 'vertical', 'popup', 'simple'
                mode: 'horizontal',
                //Type: Number.
                //Default: null.
                //Sets the width.
                width: null,
                //Type: Number.
                //Default: null.
                //Sets the height.
                height: null,
                //Type: Number.
                //Default: 'auto'.
                //Sets the height.
                minimizeWidth: 'auto',
                //Type: String.
                //Default: easeInOutSine.
                //Gets or sets the animation's easing to one of the JQuery's supported easings.
                easing: 'easeInOutSine',
                //Type: Number.
                //Default: 500.
                //Gets or sets the duration of the show animation.
                animationShowDuration: 200,
                //Type: Number.
                //Default: 'fast'.
                //Gets or sets the duration of the hide animation.
                animationHideDuration: 200,
                // Type: Number
                // Default: 0
                // Gets or sets whether the menu is automatically closed after a period of time.
                autoCloseInterval: 0,
                //Type: Number.
                //Default: 500.
                //Gets or sets the delay before the start of the hide animation.
                animationHideDelay: 100,
                //Type: Number.
                //Default: 200.
                //Gets or sets the delay before the start of the show animation.
                animationShowDelay: 10,
                //Type: Array.
                menuElements: new Array(),
                //Type: Boolean.
                //Default: true.
                //Auto-Sizes the Menu's main items when the menu's mode is 'horizontal'.
                autoSizeMainItems: false,
                //Type: Boolean.
                //Default: true.
                //Automatically closes the opened popups after a click.
                autoCloseOnClick: true,
                //Type: Boolean.
                //Default: true.
                //Automatically closes the opened popups after mouse leave.
                autoCloseOnMouseLeave: true,
                //Type: Boolean.
                //Default: true.
                //Enables or disables the rounded corners.
                enableRoundedCorners: true,
                //Type: Boolean.
                //Default: true.
                //Enables or disables the Menu.
                disabled: false,
                //Type: Boolean.
                //Default: true.
                //Opens the Context Menu when the right-mouse button is pressed.
                //When this property is set to false, the Open and Close functions can be used to open and close
                //the Context Menu.
                autoOpenPopup: true,
                // Type: Boolean
                // Default: true
                // enables or disables the hover state.
                enableHover: true,
                // Type: Boolean
                // Default: true
                // opens the top level menu items when the user hovers them.
                autoOpen: true,
                // Type: Boolean
                // Default: false
                // When this property is true, the menu is auto generated using all of ul and li tags inside the host.
                autoGenerate: true,
                // Type: Boolean
                // Default: false
                // opens an item after a click by the user.
                clickToOpen: false,
                // Type: Boolean
                // Default: false
                // shows the top-level item arrows in the default horizontal menu mode.
                showTopLevelArrows: false,
                // Sets whether the menu is on touch device.
                touchMode: 'auto',
                // Sets menu's source.
                source: null,
                popupZIndex: 1000,
                rtl: false,
                keyboardNavigation: false,
                lockFocus: false,
                title: "",
                // Menu events.
                events:
                    [
                        'shown', 'closed', 'itemclick', 'initialized', 'open', 'close'
                    ]
            };
            if (this === $.jqx._jqxMenu.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        createInstance: function (args) {
            var self = this;
            this.host.attr('role', 'menubar');
            $.jqx.utilities.resize(this.host, function () {
                self.refresh();
            }, false, this.mode != "popup");
            if (this.minimizeWidth != "auto" && this.minimizeWidth != null && this.width && this.width.toString().indexOf('%') == -1) {
                $(window).resize(function () {
                    self.refresh();
                });
            }

            if (self.isMaterialized()) {
                var elementStyle = window.getComputedStyle(this.element);
                var animation = elementStyle.getPropertyValue('--jqx-dropdown-animation');

                if (animation) {
                    this.animationType = animation.trim();
                    if (this.animationType === "transform") {
                        this.animationShowDuration = 0;
                        this.animationHideDuration = 0;
                        this.animationShowDelay = 0;
                    }
                }
            }

            this.host.css('outline', 'none');

            if (this.source) {
                if (this.source != null) {
                    var html = this.loadItems(this.source);
                    this.element.innerHTML = html;
                }
            }

            this._tmpHTML = this.element.innerHTML;
            if (this.element.innerHTML.indexOf('UL')) {
                var innerElement = this.host.find('ul:first');
                if (innerElement.length > 0) {
                    this._createMenu(innerElement[0]);
                }
            }

            this.host.data('autoclose', {});

            this._render();
            this._setSize();
            if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                this.host.attr('hideFocus', true);
            }
        },

        focus: function () {
            try {
                if (this.mode === "popup" && this.keyboardNavigation) {
                    var $popupElementparent = this.host.closest('div.jqx-menu-wrapper');
                    $popupElementparent.focus();
                }
                if (this.keyboardNavigation) {
                    this.host.focus();
                    var that = this;
                    var setActiveItem = function () {
                        if (!$.jqx.isHidden($(that.items[0].element))) {
                            $(that.items[0].element).addClass(that.toThemeProperty('jqx-fill-state-focus'));
                            that.activeItem = that.items[0];
                        }
                        else {
                            var item = that._nextVisibleItem(that.items[0], 0);
                            if (item) {
                                $(item.element).addClass(that.toThemeProperty('jqx-fill-state-focus'));
                                that.activeItem = item;
                            }
                        }
                    }

                    if (!this.activeItem) {
                        setActiveItem();
                    }
                    else {
                        if (!$.jqx.isHidden($(this.activeItem.element))) {
                            $(this.activeItem.element).addClass(this.toThemeProperty('jqx-fill-state-focus'));
                        }
                        else {
                            $(this.activeItem.element).removeClass(this.toThemeProperty('jqx-fill-state-focus'));
                            setActiveItem();
                        }
                    }
                }
            }
            catch (error) {
            }
        },

        loadItems: function (items, subMenuWidth) {
            if (items == null) {
                return;
            }
            if (items.length == 0) return "";

            var self = this;
            this.items = new Array();
            var html = '<ul class="jqx-menu-ul">';
            if (subMenuWidth) {
                html = '<ul class="jqx-menu-ul" style="width:' + subMenuWidth + ';">';
            }

            $.map(items, function (item) {
                if (item == undefined)
                    return null;

                html += self._parseItem(item);
            });

            html += '</ul>';
            return html;
        },

        _parseItem: function (item) {
            var html = "";

            if (item == undefined)
                return null;

            var label = item.label;
            if (!item.label && item.html) {
                label = item.html;
            }
            if (!label) {
                label = "Item";
            }

            if (typeof item === 'string') {
                label = item;
            }

            var selected = false;
            if (item.selected != undefined && item.selected) {
                selected = true;
            }

            var disabled = false;
            if (item.disabled != undefined && item.disabled) {
                disabled = true;
            }

            html += '<li';

            if (disabled) {
                html += ' item-disabled="true" ';
            }

            if (item.label && !item.html) {
                html += ' item-label="' + label + '" ';
            }

            if (item.value != null) {
                html += ' item-value="' + item.value + '" ';
            }

            if (item.id != undefined) {
                html += ' id="' + item.id + '" ';
            }

            html += '>' + label;

            if (item.items) {
                if (item.subMenuWidth) {
                    html += this.loadItems(item.items, item.subMenuWidth);
                }
                else {
                    html += this.loadItems(item.items);
                }
            }

            html += '</li>';
            return html;
        },

        _setSize: function () {
            if (this.width != null && this.width.toString().indexOf("%") != -1) {
                this.host.width(this.width);
            }
            else if (this.width != null && this.width.toString().indexOf("px") != -1) {
                this.host.width(this.width);
            }
            else
                if (this.width != undefined && !isNaN(this.width)) {
                    this.host.width(this.width);
                };

            if (this.height != null && this.height.toString().indexOf("%") != -1) {
                this.host.height(this.height);
            }
            else if (this.height != null && this.height.toString().indexOf("px") != -1) {
                this.host.height(this.height);
            }
            else if (this.height != undefined && !isNaN(this.height)) {
                this.host.height(this.height);
            };
            if (this.height === null) {
                this.host.height('auto');
            }

            var me = this;
            if (this.minimizeWidth != null && this.mode != "popup") {
                var windowWidth = $(window).width();

                if (!$.jqx.response) {
                    var isDesktop = false;
                    if (navigator.userAgent.match(/Windows|Linux|MacOS/)) {
                        var isWP = navigator.userAgent.indexOf('Windows Phone') >= 0 || navigator.userAgent.indexOf('WPDesktop') >= 0 || navigator.userAgent.indexOf('IEMobile') >= 0 || navigator.userAgent.indexOf('ZuneWP7') >= 0;
                        if (!isWP) {
                            isDesktop = true;
                        }
                    }

                    var w = this.minimizeWidth;
                    if (isDesktop && this.minimizeWidth == 'auto') {
                        return;
                    }
                }

                if (this.minimizeWidth == 'auto' && $.jqx.response) {
                    var response = new $.jqx.response();
                    if (response.device.type == "Phone" || response.device.type == "Tablet") {
                        if (!this.minimized) {
                            this.minimize();
                        }
                    }
                }
                else {
                    if ((windowWidth < w) && !this.minimized) {
                        this.minimize();
                    }
                    else if (this.minimized && windowWidth >= w) {
                        this.restore()
                    }
                }
            }
        },

        minimize: function () {
            if (this.minimized) return;
            var me = this;
            this.host.addClass(this.toThemeProperty('jqx-menu-minimized'));
            this.minimized = true;
            this._tmpMode = this.mode;
            this.mode = "simple";
            var wrapper = this.host.closest('div.jqx-menu-wrapper');
            wrapper.remove();
            $("#menuWrapper" + this.element.id).remove();
            $.each(this.items, function () {
                var item = this;
                var $menuElement = $(item.element);
                var $submenu = $(item.subMenuElement);
                var $popupElement = $submenu.closest('div.jqx-menu-popup');
                $popupElement.remove();
            });

            if (this.source) {
                var html = this.loadItems(this.source);
                this.element.innerHTML = html;
                this._tmpHTML = this.element.innerHTML;
            }

            this.element.innerHTML = this._tmpHTML;
            if (this.element.innerHTML.indexOf('UL')) {
                var innerElement = this.host.find('ul:first');
                if (innerElement.length > 0) {
                    this._createMenu(innerElement[0]);
                }
            }


            this._render();
            var ul = this.host.find('ul:first');
            ul.wrap('<div class="jqx-menu-wrapper" style="z-index:' + this.popupZIndex + '; padding: 0px; display: none; margin: 0px; height: auto; width: auto; position: absolute; top: 0; left: 0; display: block; visibility: visible;"></div>')
            var wrapper = ul.closest('div.jqx-menu-wrapper');
            wrapper[0].id = "menuWrapper" + this.element.id;
            wrapper.detach();
            wrapper.appendTo($(document.body));
            wrapper.addClass(this.toThemeProperty('jqx-widget'));
            wrapper.addClass(this.toThemeProperty('jqx-menu'));
            wrapper.addClass(this.toThemeProperty('jqx-menu-minimized'));
            wrapper.addClass(this.toThemeProperty('jqx-widget-header'));

            ul.children().hide();
            wrapper.hide();
            wrapper.find('ul').addClass(this.toThemeProperty('jqx-menu-ul-minimized'));
            this.minimizedItem = $("<div></div>");
            this.minimizedItem.addClass(this.toThemeProperty('jqx-item'));
            this.minimizedItem.addClass(this.toThemeProperty('jqx-menu-item-top'));

            this.addHandler(wrapper, 'keydown', function (event) {
                return me.handleKeyDown(event);
            });

            this.minimizedItem.addClass(this.toThemeProperty('jqx-menu-minimized-button'));
            this.minimizedItem.prependTo(this.host);

            this.titleElement = $("<div>" + this.title + "</div>");
            this.titleElement.addClass(this.toThemeProperty('jqx-item'));
            this.titleElement.addClass(this.toThemeProperty('jqx-menu-title'));
            this.titleElement.prependTo(this.host);
            $("<div style='clear:both;'></div>").insertAfter(this.minimizedItem);
            me.minimizedHidden = true;
            var hideMenu = function (e) {
                me.minimizedHidden = true;
                me.minimizedItem.show();
                var fromRight = false;
                if (me.minimizedItem.css('float') == 'right') {
                    fromRight = true;
                }

                wrapper.animate({
                    left: !fromRight ? -wrapper.outerWidth() : me.host.coord().left + me.host.width() + wrapper.width(),
                    opacity: 0
                }, me.animationHideDuration, function () {
                    wrapper.find('ul:first').children().hide();
                    wrapper.hide();
                });
            }

            var toggleMenu = function (e) {
                if (me.minimizedHidden) {
                    wrapper.find('ul:first').children().show();
                    me.minimizedHidden = false;
                    wrapper.show();
                    wrapper.css('opacity', 0);
                    wrapper.css('left', -wrapper.outerWidth());
                    var fromRight = false;
                    var wrapperWidth = wrapper.width();
                    if (me.minimizedItem.css('float') == 'right') {
                        wrapper.css('left', me.host.coord().left + me.host.width() + wrapperWidth);
                        fromRight = true;
                    }
                    wrapper.css('top', me.host.coord().top + me.host.height());
                    wrapper.animate({
                        left: !fromRight ? me.host.coord().left : me.host.coord().left + me.host.width() - wrapperWidth,
                        opacity: 0.95
                    }, me.animationShowDuration, function () {
                    });
                }
                else {
                    hideMenu(e);
                }
                me._raiseEvent('2', { type: "mouse", item: me.minimizedItem[0], event: e });
                me._setSize();
            }
            this.addHandler($(window), 'orientationchange.jqxmenu' + this.element.id, function (e) {
                setTimeout(function () {
                    if (!me.minimizedHidden) {
                        var wrapperWidth = wrapper.width();
                        var fromRight = false;
                        var wrapperWidth = wrapper.width();
                        if (me.minimizedItem.css('float') == 'right') {
                            fromRight = true;
                        }
                        wrapper.css('top', me.host.coord().top + me.host.height());
                        wrapper.css({
                            left: !fromRight ? me.host.coord().left : me.host.coord().left + me.host.width() - wrapperWidth
                        });
                    }
                }, 25);
            });

            this.addHandler(this.minimizedItem, 'click', function (e) {
                toggleMenu(e);
            });
        },

        restore: function () {
            if (!this.minimized) return;

            this.host.find('ul').removeClass(this.toThemeProperty('jqx-menu-ul-minimized'));
            this.host.removeClass(this.toThemeProperty('jqx-menu-minimized'));

            this.minimized = false;
            this.mode = this._tmpMode;
            if (this.minimizedItem)
                this.minimizedItem.remove();

            var wrapper = $("#menuWrapper" + this.element.id);
            wrapper.remove();

            if (this.source) {
                var html = this.loadItems(this.source);
                this.element.innerHTML = html;
                this._tmpHTML = html;
            }

            this.element.innerHTML = this._tmpHTML;
            if (this.element.innerHTML.indexOf('UL')) {
                var innerElement = this.host.find('ul:first');
                if (innerElement.length > 0) {
                    this._createMenu(innerElement[0]);
                }
            }

            this._setSize();
            this._render();
        },

        isTouchDevice: function () {
            if (this._isTouchDevice != undefined) return this._isTouchDevice;
            var isTouchDevice = $.jqx.mobile.isTouchDevice();
            if (this.touchMode == true) {
                isTouchDevice = true;
            }
            else if (this.touchMode == false) {
                isTouchDevice = false;
            }
            if (isTouchDevice) {
                this.host.addClass(this.toThemeProperty('jqx-touch'));
                $(".jqx-menu-item").addClass(this.toThemeProperty('jqx-touch'));
            }
            this._isTouchDevice = isTouchDevice;
            return isTouchDevice;
        },

        refresh: function (initialRefresh) {
            if (!initialRefresh) {
                this._setSize();
            }
        },

        resize: function (width, height) {
            this.width = width;
            this.height = height;
            this.refresh();
        },

        _closeAll: function (e) {
            var me = e != null ? e.data : this;
            var items = me.items;
            $.each(items, function () {
                var item = this;
                if (item.hasItems == true) {
                    if (item.isOpen) {
                        me._closeItem(me, item);
                    }
                }
            });

            if (me.mode == 'popup') {
                if (e != null) {
                    var rightclick = me._isRightClick(e);
                    if (!rightclick) {
                        me.close();
                    }
                }
            }
        },

        // @param id
        // closes a menu item by id.
        closeItem: function (id) {
            if (id == null)
                return false;
            var theId = id;
            var element = document.getElementById(theId);
            var me = this;

            $.each(me.items, function () {
                var item = this;
                if (item.isOpen == true && item.element == element) {
                    me._closeItem(me, item);
                    if (item.parentId) {
                        //        me.closeItem(item.parentId);
                    }
                }
            });

            return true;
        },

        // @param id
        // opens a menu item by id.
        openItem: function (id) {
            if (id == null)
                return false;

            var theId = id;
            var element = document.getElementById(theId);
            var me = this;
            $.each(me.items, function () {
                var item = this;
                if (item.isOpen == false && item.element == element) {
                    me._openItem(me, item);
                    if (item.parentId) {
                        me.openItem(item.parentId);
                    }
                }
            });

            return true;
        },

        _getClosedSubMenuOffset: function (item) {
            var $submenu = $(item.subMenuElement);
            var top = -$submenu.outerHeight();
            var left = -$submenu.outerWidth();
            var isTopItem = item.level == 0 && this.mode == 'horizontal';
            if (isTopItem) {
                left = 0;
            }
            else {
                top = 0;
            }

            switch (item['openVerticalDirection']) {
                case 'up':
                case 'center':
                    top = $submenu.outerHeight();
                    break;
            }

            switch (item['openHorizontalDirection']) {
                case this._getDir('left'):
                    if (isTopItem) {
                        left = 0;
                    }
                    else {
                        left = $submenu.outerWidth();
                    }
                    break;
                case 'center':
                    if (isTopItem) {
                        left = 0;
                    }
                    else {
                        left = $submenu.outerWidth();
                    }
                    break;
            }
            return { left: left, top: top };
        },


        _closeItem: function (me, item, subs, force) {
            if (me == null || item == null)
                return false;


            var $submenu = $(item.subMenuElement);

            var isTopItem = item.level == 0 && this.mode == 'horizontal';
            var subMenuOffset = this._getClosedSubMenuOffset(item);
            var top = subMenuOffset.top;
            var left = subMenuOffset.left;

            var $menuElement = $(item.element);
            var $popupElement = $submenu.closest('div.jqx-menu-popup');
            if ($popupElement != null) {
                $popupElement.removeClass('show');
                var delay = me.animationHideDelay;
                if (force == true) {
                    //     clearTimeout($submenu.data('timer').hide);
                    delay = 0;
                }

                if ($submenu.data('timer') && $submenu.data('timer').show != null) {
                    clearTimeout($submenu.data('timer').show);
                    $submenu.data('timer').show = null;
                }

                var hideFunc = function () {
                    item.isOpen = false;

                    if (isTopItem) {
                        $submenu.stop().animate({ top: top }, me.animationHideDuration, function () {
                            $(item.element).removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                            $(item.element).removeClass(me.toThemeProperty('jqx-menu-item-top-selected'));

                            $(item.element).removeClass(me.toThemeProperty('jqx-rc-b-expanded'));
                            $popupElement.removeClass(me.toThemeProperty('jqx-rc-t-expanded'));
                            var $arrowSpan = $(item.arrow);
                            if ($arrowSpan.length > 0 && me.showTopLevelArrows) {
                                $arrowSpan.removeClass();
                                if (item.openVerticalDirection == 'down') {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-down'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-down'));
                                }
                                else {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-up'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-up'));
                                }
                            }
                            $.jqx.aria($(item.element), 'aria-expanded', false);

                            $popupElement.css({ display: 'none' });
                            if (me.animationHideDuration == 0) {
                                $submenu.css({ top: top });
                            }
                            me._raiseEvent('1', item);
                        })
                    }
                    else {
                        if (!$.jqx.browser.msie) {
                            //       $popupElement.stop().animate({ opacity: 0 }, me.animationHideDuration, function () {
                            //         });
                        }

                        $submenu.stop().animate({ left: left }, me.animationHideDuration, function () {
                            if (me.animationHideDuration == 0) {
                                $submenu.css({ left: left });
                            }

                            if (item.level > 0) {
                                $(item.element).removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                                $(item.element).removeClass(me.toThemeProperty('jqx-menu-item-selected'));
                                var $arrowSpan = $(item.arrow);
                                if ($arrowSpan.length > 0) {
                                    $arrowSpan.removeClass();
                                    if (item.openHorizontalDirection != 'left') {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right')));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                                    }
                                    else {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('left')));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('left')));
                                    }
                                }
                            }
                            else {
                                $(item.element).removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                                $(item.element).removeClass(me.toThemeProperty('jqx-menu-item-top-selected'));
                                var $arrowSpan = $(item.arrow);
                                if ($arrowSpan.length > 0) {
                                    $arrowSpan.removeClass();
                                    if (item.openHorizontalDirection != 'left') {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-top-' + me._getDir('right')));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                                    }
                                    else {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-top-' + me._getDir('left')));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('left')));
                                    }
                                }
                            }
                            $.jqx.aria($(item.element), 'aria-expanded', false);
                            $popupElement.css({ display: 'none' })
                            me._raiseEvent('1', item);
                        })
                    }
                }

                if (delay > 0) {
                    if ($submenu.data('timer')) {
                        $submenu.data('timer').hide = setTimeout(function () {
                            hideFunc();
                        }, delay);
                    }
                }
                else {
                    hideFunc();
                }

                if (subs != undefined && subs) {
                    var children = $submenu.children();// find('.' + me.toThemeProperty('jqx-menu-item'));
                    $.each(children, function () {
                        if (me.menuElements[this.id] && me.menuElements[this.id].isOpen) {
                            var $submenu = $(me.menuElements[this.id].subMenuElement);
                            me._closeItem(me, me.menuElements[this.id], true, true);
                        }
                    });
                }
            }
        },

        // @param id
        // @param array.
        // get menu item's sub items.
        getSubItems: function (id, array) {
            if (id == null)
                return false;

            var me = this;
            var subItems = new Array();
            if (array != null) {
                $.extend(subItems, array);
            }

            var theId = id;
            var item = this.menuElements[theId];
            var $submenu = $(item.subMenuElement);
            var children = $submenu.find('.jqx-menu-item');
            $.each(children, function () {
                subItems[this.id] = me.menuElements[this.id];
                var innerArray = me.getSubItems(this.id, subItems);
                $.extend(subItems, innerArray);
            });

            return subItems;
        },

        // disables a menu item.
        // @param id
        // @param Boolean
        disable: function (id, disable) {
            if (id == null)
                return;
            var theId = id;
            var me = this;
            if (this.menuElements[theId]) {
                var item = this.menuElements[theId];
                item.disabled = disable;
                var $element = $(item.element);
                item.element.disabled = disable;
                $.each($element.children(), function () {
                    this.disabled = disable;
                });

                if (disable) {
                    $element.addClass(me.toThemeProperty('jqx-menu-item-disabled'));
                    $element.addClass(me.toThemeProperty('jqx-fill-state-disabled'));
                }
                else {
                    $element.removeClass(me.toThemeProperty('jqx-menu-item-disabled'));
                    $element.removeClass(me.toThemeProperty('jqx-fill-state-disabled'));
                }
            }
        },

        getItem: function (id) {
            if (this.menuElements[id]) {
                var item = this.menuElements[id];
                return item;
            }
            return null;
        },

        disableItem: function (id) {
            this.disable(id, true);
        },

        hideItem: function (id) {
            if (this.menuElements[id]) {
                var item = this.menuElements[id];
                $(item.element).hide();
            }
        },

        showItem: function (id) {
            if (this.menuElements[id]) {
                var item = this.menuElements[id];
                $(item.element).show();
            }
        },


        enableItem: function (id) {
            this.disable(id, false);
        },

        _setItemProperty: function (id, propertyname, value) {
            if (id == null)
                return;

            var theId = id;
            var me = this;

            if (this.menuElements[theId]) {
                var item = this.menuElements[theId];
                if (item[propertyname]) {
                    item[propertyname] = value;
                }
            }
        },

        // sets the open direction of an item.
        // @param id
        // @param String
        // @param String
        setItemOpenDirection: function (id, horizontal, vertical) {
            if (id == null)
                return;
            var theId = id;
            var me = this;
            var ie7 = $.jqx.browser.msie && $.jqx.browser.version < 8;

            if (this.menuElements[theId]) {
                var item = this.menuElements[theId];
                if (horizontal != null) {
                    item['openHorizontalDirection'] = horizontal;
                    if (item.hasItems && item.level > 0) {
                        var $element = $(item.element);
                        if ($element != undefined) {
                            var $arrowSpan = $(item.arrow);
                            if (item.arrow == null) {
                                $arrowSpan = $('<span id="arrow' + $element[0].id + '"></span>');
                                if (!ie7) {
                                    $arrowSpan.prependTo($element);
                                }
                                else {
                                    $arrowSpan.appendTo($element);
                                }
                                item.arrow = $arrowSpan[0];
                            }
                            $arrowSpan.removeClass();
                            if (item.openHorizontalDirection == 'left') {
                                $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('left')));
                                $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('left')));
                            }
                            else {
                                $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right')));
                                $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                            }
                            $arrowSpan.css('visibility', 'inherit');

                            if (!ie7) {
                                $arrowSpan.css('display', 'block');
                                $arrowSpan.css('float', 'right');
                            }
                            else {
                                $arrowSpan.css('display', 'inline-block');
                                $arrowSpan.css('float', 'none');
                            }
                        }
                    }
                }
                if (vertical != null) {
                    item['openVerticalDirection'] = vertical;
                    var $arrowSpan = $(item.arrow);
                    var $element = $(item.element);
                    if (!me.showTopLevelArrows) {
                        return;
                    }

                    if ($element != undefined) {
                        if (item.arrow == null) {
                            $arrowSpan = $('<span id="arrow' + $element[0].id + '"></span>');
                            if (!ie7) {
                                $arrowSpan.prependTo($element);
                            }
                            else {
                                $arrowSpan.appendTo($element);
                            }
                            item.arrow = $arrowSpan[0];
                        }
                        $arrowSpan.removeClass();
                        if (item.openVerticalDirection == 'down') {
                            $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-down'));
                            $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-down'));
                        }
                        else {
                            $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-up'));
                            $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-up'));
                        }
                        $arrowSpan.css('visibility', 'inherit');
                        if (!ie7) {
                            $arrowSpan.css('display', 'block');
                            $arrowSpan.css('float', 'right');
                        }
                        else {
                            $arrowSpan.css('display', 'inline-block');
                            $arrowSpan.css('float', 'none');

                        }
                    }
                }
            }
        },


        _getSiblings: function (item) {
            var siblings = new Array();
            var index = 0;
            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i] == item)
                    continue;

                if (this.items[i].parentId == item.parentId && this.items[i].hasItems) {
                    siblings[index++] = this.items[i];
                }
            }
            return siblings;
        },


        _openItem: function (me, item, zIndex) {
            if (me == null || item == null)
                return false;

            if (item.isOpen)
                return false;

            if (item.disabled)
                return false;

            if (me.disabled)
                return false;
            var zIndx = me.popupZIndex;
            if (zIndex != undefined) {
                zIndx = zIndex;
            }

            var hideDuration = me.animationHideDuration;
            me.animationHideDuration = 0;
            me._closeItem(me, item, true, true);
            me.animationHideDuration = hideDuration;

            $(item.element).focus();

            //  this.host.focus();

            var popupElementoffset = [5, 5];
            var $submenu = $(item.subMenuElement);
            if ($submenu != null) {
                $submenu.stop();
            }
            // stop hiding process.
            if ($submenu.data('timer') && $submenu.data('timer').hide != null) {
                clearTimeout($submenu.data('timer').hide);
                //      $submenu.data('timer').hide = null;
            }
            var $popupElement = $submenu.closest('div.jqx-menu-popup');
            var $menuElement = $(item.element);
            var offset = item.level == 0 ? this._getOffset(item.element) : $menuElement.position()

            if (item.level > 0 && this.hasTransform) {
                var topTransform = parseInt($menuElement.coord().top) - parseInt(this._getOffset(item.element).top);
                offset.top += topTransform;
            }

            if (item.level == 0 && this.mode == 'popup') {
                offset = $menuElement.coord();
            }

            var isTopItem = item.level == 0 && this.mode == 'horizontal';

            var menuItemLeftOffset = isTopItem ? offset.left : this.menuElements[item.parentId] != null && this.menuElements[item.parentId].subMenuElement != null ? parseInt($($(this.menuElements[item.parentId].subMenuElement).closest('div.jqx-menu-popup')).outerWidth()) - popupElementoffset[0]
                : parseInt($submenu.outerWidth());

            $popupElement.css({ visibility: 'visible', display: 'block', left: menuItemLeftOffset, top: isTopItem ? offset.top + $menuElement.outerHeight() : offset.top, zIndex: zIndx })
            $submenu.css('display', 'block');

            if (this.mode != 'horizontal' && item.level == 0) {
                var hostOffset = this._getOffset(this.element)
                $popupElement.css('left', -1 + hostOffset.left + this.host.outerWidth());

                //          $popupElement.css('left', -2 + offset.left + this.host.width() - popupElementoffset[0]);
                $submenu.css('left', -$submenu.outerWidth());
            }
            else {
                var subMenuOffset = this._getClosedSubMenuOffset(item);
                $submenu.css('left', subMenuOffset.left);
                $submenu.css('top', subMenuOffset.top);
            }

            $popupElement.css({ height: parseInt($submenu.outerHeight()) + parseInt(popupElementoffset[1]) + 'px' });

            var top = 0;
            var left = 0;

            switch (item['openVerticalDirection']) {
                case 'up':
                    if (isTopItem) {
                        $submenu.css('top', $submenu.outerHeight());
                        top = popupElementoffset[1];
                        var paddingBottom = parseInt($submenu.parent().css('padding-bottom'));
                        if (isNaN(paddingBottom)) paddingBottom = 0;
                        if (paddingBottom > 0) {
                            $popupElement.addClass(this.toThemeProperty('jqx-menu-popup-clear'));
                        }

                        $submenu.css('top', $submenu.outerHeight() - paddingBottom);
                        $popupElement.css({ display: 'block', top: offset.top - $popupElement.outerHeight(), zIndex: zIndx })
                    }
                    else {
                        top = popupElementoffset[1];
                        $submenu.css('top', $submenu.outerHeight());
                        $popupElement.css({ display: 'block', top: offset.top - $popupElement.outerHeight() + popupElementoffset[1] + $menuElement.outerHeight(), zIndex: zIndx })
                    }
                    break;
                case 'center':
                    if (isTopItem) {
                        $submenu.css('top', 0);
                        $popupElement.css({ display: 'block', top: offset.top - $popupElement.outerHeight() / 2 + popupElementoffset[1], zIndex: zIndx })
                    }
                    else {
                        $submenu.css('top', 0);
                        $popupElement.css({ display: 'block', top: offset.top + $menuElement.outerHeight() / 2 - $popupElement.outerHeight() / 2 + popupElementoffset[1], zIndex: zIndx })
                    }

                    break;
            }

            switch (item['openHorizontalDirection']) {
                case this._getDir('left'):
                    if (isTopItem) {
                        $popupElement.css({ left: offset.left - ($popupElement.outerWidth() - $menuElement.outerWidth() - popupElementoffset[0]) });
                    }
                    else {
                        left = 0;
                        $submenu.css('left', $popupElement.outerWidth());
                        $popupElement.css({ left: offset.left - ($popupElement.outerWidth()) + 2 * item.level });
                    }
                    break;
                case 'center':
                    if (isTopItem) {
                        $popupElement.css({ left: offset.left - ($popupElement.outerWidth() / 2 - $menuElement.outerWidth() / 2 - popupElementoffset[0] / 2) });
                    }
                    else {
                        $popupElement.css({ left: offset.left - ($popupElement.outerWidth() / 2 - $menuElement.outerWidth() / 2 - popupElementoffset[0] / 2) });
                        $submenu.css('left', $popupElement.outerWidth());
                    }
                    break;
            }

            if (isTopItem) {
                if (parseInt($submenu.css('top')) == top) {
                    item.isOpen = true;
                    return;
                }
            }
            else if (parseInt($submenu.css('left')) == left) {
                item.isOpen == true;
                return;
            }

            $.each(me._getSiblings(item), function () {
                me._closeItem(me, this, true, true);
            });
            var hideDelay = $.data(me.element, 'animationHideDelay');
            me.animationHideDelay = hideDelay;


            if (this.autoCloseInterval > 0) {
                if (this.host.data('autoclose') != null && this.host.data('autoclose').close != null) {
                    clearTimeout(this.host.data('autoclose').close);
                }

                if (this.host.data('autoclose') != null) {
                    this.host.data('autoclose').close = setTimeout(function () {
                        me._closeAll();
                    }, this.autoCloseInterval);
                }
            }
            if ($submenu.data('timer')) {
                $submenu.data('timer').show = setTimeout(function () {
                    if ($popupElement != null) {
                        if (isTopItem) {
                            $submenu.stop();
                            $submenu.css('left', left);
                            if (!$.jqx.browser.msie) {
                                //      $popupElement.css('opacity', 0.0);
                            }

                            $menuElement.addClass(me.toThemeProperty('jqx-fill-state-pressed'));
                            $menuElement.addClass(me.toThemeProperty('jqx-menu-item-top-selected'));
                            if (item.openVerticalDirection == "down") {
                                $(item.element).addClass(me.toThemeProperty('jqx-rc-b-expanded'));
                                $popupElement.addClass(me.toThemeProperty('jqx-rc-t-expanded'));
                                $popupElement.addClass(me.toThemeProperty('show'));
                            }
                            else {
                                $(item.element).addClass(me.toThemeProperty('jqx-rc-t-expanded'));
                                $popupElement.addClass(me.toThemeProperty('jqx-rc-b-expanded'));
                                $popupElement.addClass(me.toThemeProperty('show'));
                            }

                            var $arrowSpan = $(item.arrow);
                            if ($arrowSpan.length > 0 && me.showTopLevelArrows) {
                                $arrowSpan.removeClass();
                                if (item.openVerticalDirection == 'down') {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-down-selected'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-down'));
                                }
                                else {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-up-selected'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-up'));
                                }
                            }

                            if (me.animationShowDuration == 0) {
                                $submenu.css({ top: top });
                                item.isOpen = true;
                                me._raiseEvent('0', item);
                                $.jqx.aria($(item.element), 'aria-expanded', true);
                            }
                            else {
                                $submenu.animate({ top: top }, me.animationShowDuration, me.easing,
                                    function () {
                                        item.isOpen = true;
                                        $.jqx.aria($(item.element), 'aria-expanded', true);
                                        me._raiseEvent('0', item);
                                    }) //animate submenu into view
                            }
                        }
                        else {
                            $submenu.stop();
                            $submenu.css('top', top);

                            $popupElement.addClass(me.toThemeProperty('show'));


                            if (!$.jqx.browser.msie) {
                                //     $popupElement.css('opacity', 0.0);
                            }

                            if (item.level > 0) {
                                $menuElement.addClass(me.toThemeProperty('jqx-fill-state-pressed'));
                                $menuElement.addClass(me.toThemeProperty('jqx-menu-item-selected'));
                                var $arrowSpan = $(item.arrow);
                                if ($arrowSpan.length > 0) {
                                    $arrowSpan.removeClass();
                                    if (item.openHorizontalDirection != 'left') {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right') + '-selected'));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                                    }
                                    else {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('left') + '-selected'));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('left')));
                                    }
                                }
                            }
                            else {
                                $menuElement.addClass(me.toThemeProperty('jqx-fill-state-pressed'));
                                $menuElement.addClass(me.toThemeProperty('jqx-menu-item-top-selected'));
                                var $arrowSpan = $(item.arrow);
                                if ($arrowSpan.length > 0) {
                                    $arrowSpan.removeClass();
                                    if (item.openHorizontalDirection != 'left') {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right') + '-selected'));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                                    }
                                    else {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('left') + '-selected'));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('left')));
                                    }
                                }
                            }
                            if (!$.jqx.browser.msie) {
                                //      $popupElement.animate({ opacity: 1 }, 2 * me.animationShowDuration, me.easing,
                                //   function () {

                                // })
                            }
                            if (me.animationShowDuration == 0) {
                                $submenu.css({ left: left });
                                me._raiseEvent('0', item);
                                item.isOpen = true;
                                $.jqx.aria($(item.element), 'aria-expanded', true);
                            }
                            else {
                                $submenu.animate({ left: left }, me.animationShowDuration, me.easing, function () {
                                    me._raiseEvent('0', item);
                                    item.isOpen = true;
                                    $.jqx.aria($(item.element), 'aria-expanded', true);
                                }) //animate submenu into view
                            }
                        }
                    }
                }, this.animationShowDelay);
            }
        },

        _getDir: function (dir) {
            switch (dir) {
                case 'left':
                    return !this.rtl ? 'left' : 'right';
                case 'right':
                    return this.rtl ? 'left' : 'right';
            }
            return 'left';
        },


        _applyOrientation: function (mode, oldmode) {
            var me = this;
            var maxHeight = 0;
            me.host.removeClass(me.toThemeProperty('jqx-menu-horizontal'));
            me.host.removeClass(me.toThemeProperty('jqx-menu-vertical'));
            me.host.removeClass(me.toThemeProperty('jqx-menu'));
            me.host.removeClass(me.toThemeProperty('jqx-widget'));
            me.host.addClass(me.toThemeProperty('jqx-widget'));
            me.host.addClass(me.toThemeProperty('jqx-menu'));

            if (mode != undefined && oldmode != undefined && oldmode == 'popup') {
                if (me.host.parent().length > 0 && me.host.parent().parent().length > 0 && me.host.parent().parent()[0] == document.body) {
                    var oldHost = $.data(document.body, 'jqxMenuOldHost' + me.element.id);
                    if (oldHost != null) {
                        var $popupElementparent = me.host.closest('div.jqx-menu-wrapper')
                        $popupElementparent.remove();
                        $popupElementparent.appendTo(oldHost);
                        me.host.css('display', 'block');
                        me.host.css('visibility', 'visible');
                        $popupElementparent.css('display', 'block');
                        $popupElementparent.css('visibility', 'visible');
                    }
                }
            }
            else if (mode == undefined && oldmode == undefined) {
                $.data(document.body, 'jqxMenuOldHost' + me.element.id, me.host.parent()[0]);
            }

            if (me.autoOpenPopup) {
                if (me.mode == 'popup') {
                    me.addHandler($(document), 'contextmenu.' + me.element.id, function (e) {
                        return false;
                    });

                    me.addHandler($(document), 'mousedown.menu' + me.element.id, function (event) {
                        me._openContextMenu(event);
                    });
                }
                else {
                    me.removeHandler($(document), 'contextmenu.' + me.element.id);
                    me.removeHandler($(document), 'mousedown.menu' + me.element.id);
                }
            }
            else {
                me.removeHandler($(document), 'contextmenu.' + me.element.id);
                me.removeHandler($(document), 'mousedown.menu' + me.element.id);
                me.addHandler($(document), 'contextmenu.' + me.element.id, function (e) {
                    if (e.target && e.target.className.indexOf && e.target.className.indexOf('jqx-menu') >= 0) {
                        return false;
                    }
                });
            }

            if (me.rtl) {
                me.host.addClass(me.toThemeProperty('jqx-rtl'));
            }

            switch (me.mode) {
                case 'horizontal':
                    me.host.addClass(me.toThemeProperty('jqx-widget-header'));
                    me.host.addClass(me.toThemeProperty('jqx-menu-horizontal'));

                    $.each(me.items, function () {
                        var item = this;
                        var $element = $(item.element);

                        var $arrowSpan = $(item.arrow);
                        $arrowSpan.removeClass();

                        if (item.hasItems && item.level > 0) {
                            var $arrowSpan = $('<span style="border: none; background-color: transparent;" id="arrow' + $element[0].id + '"></span>');
                            $arrowSpan.prependTo($element);
                            $arrowSpan.css('float', me._getDir('right'));
                            $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right')));
                            $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                            item.arrow = $arrowSpan[0];
                        }

                        if (item.level == 0) {
                            $(item.element).css('float', me._getDir('left'));
                            if (!item.ignoretheme && item.hasItems && me.showTopLevelArrows) {
                                var $arrowSpan = $('<span style="border: none; background-color: transparent;" id="arrow' + $element[0].id + '"></span>');
                                var ie7 = $.jqx.browser.msie && $.jqx.browser.version < 8;

                                if (item.arrow == null) {
                                    if (!ie7) {
                                        $arrowSpan.prependTo($element);
                                    }
                                    else {
                                        $arrowSpan.appendTo($element);
                                    }
                                } else {
                                    $arrowSpan = $(item.arrow);
                                }
                                if (item.openVerticalDirection == 'down') {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-down'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-down'));
                                }
                                else {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-up'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-up'));
                                }

                                $arrowSpan.css('visibility', 'inherit');

                                if (!ie7) {
                                    $arrowSpan.css('display', 'block');
                                    $arrowSpan.css('float', 'right');
                                }
                                else {
                                    $arrowSpan.css('display', 'inline-block');
                                }

                                item.arrow = $arrowSpan[0];
                            }
                            else if (!item.ignoretheme && item.hasItems && !me.showTopLevelArrows) {
                                if (item.arrow != null) {
                                    var $arrowSpan = $(item.arrow);
                                    $arrowSpan.remove();
                                    item.arrow = null;
                                }
                            }
                            maxHeight = Math.max(maxHeight, $element.height());
                        }
                    });
                    break;
                case 'vertical':
                case 'popup':
                case 'simple':
                    me.host.addClass(me.toThemeProperty('jqx-menu-vertical'));

                    $.each(me.items, function () {
                        var item = this;
                        var $element = $(item.element);
                        if (item.hasItems && !item.ignoretheme) {
                            if (item.arrow) {
                                $(item.arrow).remove();
                            }
                            if (me.mode == 'simple') return true;

                            var $arrowSpan = $('<span style="border: none; background-color: transparent;" id="arrow' + $element[0].id + '"></span>');

                            $arrowSpan.prependTo($element);
                            $arrowSpan.css('float', 'right');

                            if (item.level == 0) {
                                $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-top-' + me._getDir('right')));
                                $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                            }
                            else {
                                $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right')));
                                $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                            }
                            item.arrow = $arrowSpan[0];
                        }
                        $element.css('float', 'none');
                    });

                    if (me.mode == 'popup') {
                        me.host.addClass(me.toThemeProperty('jqx-widget-content'));
                        me.host.wrap('<div tabindex=0 class="jqx-menu-wrapper" style="z-index:' + me.popupZIndex + '; border: none; background-color: transparent; padding: 0px; margin: 0px; position: absolute; top: 0; left: 0; display: block; visibility: visible;"></div>')
                        var $popupElementparent = me.host.closest('div.jqx-menu-wrapper')
                        me.host.addClass(me.toThemeProperty('jqx-popup'));
                        $popupElementparent[0].id = "menuWrapper" + me.element.id;
                        $popupElementparent.appendTo($(document.body));
                        me.addHandler($popupElementparent, 'keydown', function (event) {
                            return me.handleKeyDown(event);
                        });
                    }
                    else {
                        me.host.addClass(me.toThemeProperty('jqx-widget-header'));
                    }

                    if (me.mode == 'popup') {
                        var height = me.host.height();
                        me.host.css('position', 'absolute');
                        me.host.css('top', '0');
                        me.host.css('left', '0');
                        if (me.mode != "simple") {
                            me.host.height(height);
                            me.host.css('display', 'none');
                        }
                    }
                    break;
            }
            var isTouchDevice = me.isTouchDevice();
            if (me.autoCloseOnClick) {
                me.removeHandler($(document), 'mousedown.menu' + me.element.id, me._closeAfterClick);
                me.addHandler($(document), 'mousedown.menu' + me.element.id, me._closeAfterClick, me);
                if (isTouchDevice) {
                    me.removeHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.menu' + me.element.id, me._closeAfterClick, me);
                    me.addHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.menu' + me.element.id, me._closeAfterClick, me);
                }
            }
        },

        _getBodyOffset: function () {
            var top = 0;
            var left = 0;
            if ($('body').css('border-top-width') != '0px') {
                top = parseInt($('body').css('border-top-width'));
                if (isNaN(top)) top = 0;
            }
            if ($('body').css('border-left-width') != '0px') {
                left = parseInt($('body').css('border-left-width'));
                if (isNaN(left)) left = 0;
            }
            return { left: left, top: top };
        },

        _getOffset: function (object) {
            //       var scrollTop = $(window).scrollTop();
            //       var scrollLeft = $(window).scrollLeft();
            var isSafari = $.jqx.mobile.isSafariMobileBrowser();

            var offset = $(object).coord(true);
            var top = offset.top;
            var left = offset.left;

            if ($('body').css('border-top-width') != '0px') {
                top = parseInt(top) + this._getBodyOffset().top;
            }
            if ($('body').css('border-left-width') != '0px') {
                left = parseInt(left) + this._getBodyOffset().left;
            }

            var windowsPhone = $.jqx.mobile.isWindowsPhone();
            var touchDevice = $.jqx.mobile.isTouchDevice();

            if (this.hasTransform || (isSafari != null && isSafari) || windowsPhone || touchDevice) {
                var point = { left: $.jqx.mobile.getLeftPos(object), top: $.jqx.mobile.getTopPos(object) };
                return point;
            }
            else return { left: left, top: top };
        },

        _isRightClick: function (e) {
            var rightclick;
            if (!e) var e = window.event;
            if (e.which) rightclick = (e.which == 3);
            else if (e.button) rightclick = (e.button == 2);
            return rightclick;
        },

        _openContextMenu: function (e) {
            var me = this;
            var rightclick = me._isRightClick(e);

            if (rightclick) {
                me.open(parseInt(e.clientX) + 5, parseInt(e.clientY) + 5);
            }
        },

        // closes a context menu.
        close: function () {
            var me = this;
            if (!this.element) {
                return;
            }

            var opened = $.data(this.element, 'contextMenuOpened' + this.element.id);
            if (opened) {
                var host = this.host;
                me.host.removeClass('jqx-popup-show');

                $.each(me.items, function () {
                    var item = this;
                    if (item.hasItems) {
                        me._closeItem(me, item);
                    }
                });

                $.each(me.items, function () {
                    var item = this;
                    if (item.isOpen == true) {
                        var $submenu = $(item.subMenuElement);
                        var $popupElement = $submenu.closest('div.jqx-menu-popup')
                        $popupElement.hide(this.animationHideDuration);

                    }
                });

                this.host.hide(this.animationHideDuration);
                $.data(me.element, 'contextMenuOpened' + this.element.id, false);
                me._raiseEvent('1', me);
                me._raiseEvent('5');
            }
        },

        // @param String. Horizontal offset
        // @param String. Vertical Offset
        // opens a context menu.
        open: function (left, top) {
            if (this.mode == 'popup') {
                var duration = 0;
                if (this.host.css('display') == 'block') {
                    this.close();
                    duration = this.animationHideDuration;
                }

                var me = this;

                if (left == undefined || left == null) left = 0;
                if (top == undefined || top == null) top = 0;

                setTimeout(function () {
                    me.host.show(me.animationShowDuration);
                    me.host.css('visibility', 'visible');
                    me.host.addClass('jqx-popup-show');
                    $.data(me.element, 'contextMenuOpened' + me.element.id, true);
                    me._raiseEvent('0', me);
                    me._raiseEvent('4', { left: left, top: top });
                    me.host.css('z-index', me.popupZIndex);

                    if (left != undefined && top != undefined) {
                        me.host.css({ 'left': left, 'top': top });
                    }
                    me.focus();
                }, duration);
            }
        },

        _renderHover: function ($menuElement, item, isTouchDevice) {
            var me = this;
            if (!item.ignoretheme) {
                this.addHandler($menuElement, 'mouseenter', function () {
                    me.hoveredItem = item;
                    if (!item.disabled && !item.separator && me.enableHover && !me.disabled) {
                        if (item.level > 0) {
                            $menuElement.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                            $menuElement.addClass(me.toThemeProperty('jqx-menu-item-hover'));
                        }
                        else {
                            $menuElement.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                            $menuElement.addClass(me.toThemeProperty('jqx-menu-item-top-hover'));
                        }
                    }
                });
                this.addHandler($menuElement, 'mouseleave', function () {
                    if (!item.disabled && !item.separator && me.enableHover && !me.disabled) {
                        if (item.level > 0) {
                            $menuElement.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                            $menuElement.removeClass(me.toThemeProperty('jqx-menu-item-hover'));
                        }
                        else {
                            $menuElement.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                            $menuElement.removeClass(me.toThemeProperty('jqx-menu-item-top-hover'));
                        }
                    }
                });
            }
        },

        _closeAfterClick: function (event) {
            var me = event != null ? event.data : this;
            var matches = false;
            if (me.autoCloseOnClick) {
                $.each($(event.target).parents(), function () {
                    if (this.className.indexOf) {
                        if (this.className.indexOf('jqx-menu') != -1) {
                            matches = true;
                            return false;
                        }
                    }
                });

                if (!matches) {
                    event.data = me;
                    me._closeAll(event);
                }
            }
        },

        _autoSizeHorizontalMenuItems: function () {
            var me = this;
            if (me.autoSizeMainItems && this.mode == "horizontal") {
                var maxHeight = this.maxHeight;
                if (parseInt(maxHeight) > parseInt(this.host.height())) {
                    maxHeight = parseInt(this.host.height());
                }
                maxHeight = parseInt(this.host.height());

                // align vertically the items.
                $.each(this.items, function () {
                    var item = this;
                    var $element = $(item.element);
                    if (item.level == 0 && maxHeight > 0) {
                        var childrenHeight = $element.children().length > 0 ? parseInt($element.children().height()) : $element.height();
                        // vertically align content.
                        var $ul = me.host.find('ul:first');
                        var paddingOffset = parseInt($ul.css('padding-top'));
                        var marginOffset = parseInt($ul.css('margin-top'));
                        //   var borderOffset = parseInt(me.host.css('border-top-width'));
                        var height = maxHeight - 2 * (marginOffset + paddingOffset);
                        var newPadding = parseInt(height) / 2 - childrenHeight / 2;
                        var topPadding = parseInt(newPadding);
                        var bottomPadding = parseInt(newPadding);
                        $element.css('padding-top', topPadding);
                        $element.css('padding-bottom', bottomPadding);

                        if (parseInt($element.outerHeight()) > height) {
                            var offset = 1;
                            $element.css('padding-top', topPadding - offset);
                            topPadding = topPadding - offset;
                        }
                    }
                });
            }
            $.each(this.items, function () {
                var item = this;
                var $element = $(item.element);
                if (item.hasItems && item.level > 0) {
                    if (item.arrow) {
                        var $arrowSpan = $(item.arrow);
                        var height = $(item.element).height();
                        if (height > 15) {
                            $arrowSpan.css('margin-top', (height - 15) / 2);
                        }
                    }
                }
            });
        },

        _nextVisibleItem: function (item, level) {
            if (item == null || item == undefined)
                return null;

            var currentItem = item;
            while (currentItem != null) {
                currentItem = currentItem.nextItem;
                if (this._isVisible(currentItem) && !currentItem.disabled && currentItem.type !== "separator") {
                    if (this.minimized) {
                        return currentItem;
                    }

                    if (level != undefined) {
                        if (currentItem && currentItem.level != level)
                            continue;
                    }

                    return currentItem;
                }
            }

            return null;
        },

        _prevVisibleItem: function (item, level) {
            if (item == null || item == undefined)
                return null;

            var currentItem = item;
            while (currentItem != null) {
                currentItem = currentItem.prevItem;
                if (this._isVisible(currentItem) && !currentItem.disabled && currentItem.type !== "separator") {
                    if (this.minimized) {
                        return currentItem;
                    }

                    if (level != undefined) {
                        if (currentItem && currentItem.level != level)
                            continue;
                    }
                    return currentItem;
                }
            }

            return null;
        },

        _parentItem: function (item) {
            if (item == null || item == undefined)
                return null;

            var parent = item.parentElement;
            if (!parent) return null;
            var parentItem = null;

            $.each(this.items, function () {
                if (this.element == parent) {
                    parentItem = this;
                    return false;
                }
            });

            return parentItem;
        },

        _isElementVisible: function (element) {
            if (element == null)
                return false;

            if ($(element).css('display') != 'none' && $(element).css('visibility') != 'hidden') {
                return true;
            }

            return false;
        },

        _isVisible: function (item) {
            if (item == null || item == undefined)
                return false;

            if (!this._isElementVisible(item.element))
                return false;

            var currentItem = this._parentItem(item);

            if (currentItem == null)
                return true;

            if (this.minimized)
                return true;

            if (currentItem != null) {
                if (!this._isElementVisible(currentItem.element)) {
                    return false;
                }

                if (currentItem.isOpen || this.minimized) {
                    while (currentItem != null) {
                        currentItem = this._parentItem(currentItem);
                        if (currentItem != null && !this._isElementVisible(currentItem.element)) {
                            return false;
                        }

                        if (currentItem != null && !currentItem.isOpen)
                            return false;
                    }
                }
                else {
                    return false;
                }
            }

            return true;
        },

        _render: function (mode, oldMode) {
            if (this.disabled) {
                this.host.addClass(this.toThemeProperty('jqx-fill-state-disabled'));
                this.host.addClass(this.toThemeProperty('jqx-menu-disabled'));
            }
            if (this.host.attr('tabindex') == undefined) {
                this.host.attr('tabindex', 0);
            }
            var zIndex = this.popupZIndex;
            var popupElementoffset = [5, 5];
            var me = this;
            $.data(me.element, 'animationHideDelay', me.animationHideDelay);
            var isTouchDevice = this.isTouchDevice();

            var WP = isTouchDevice && ($.jqx.mobile.isWindowsPhone() || navigator.userAgent.indexOf('Touch') >= 0);
            var WPTablet = false;
            if (navigator.platform.toLowerCase().indexOf('win') != -1) {
                if (navigator.userAgent.indexOf('Windows Phone') >= 0 || navigator.userAgent.indexOf('WPDesktop') >= 0 || navigator.userAgent.indexOf('IEMobile') >= 0 || navigator.userAgent.indexOf('ZuneWP7') >= 0) {
                    this.touchDevice = true;
                }
                else {
                    if (navigator.userAgent.indexOf('Touch') >= 0) {
                        var supported = ('MSPointerDown' in window);
                        if (supported || $.jqx.mobile.isWindowsPhone() || navigator.userAgent.indexOf('ARM') >= 0) {
                            WPTablet = true;
                            WP = true;
                            me.clickToOpen = true;
                            me.autoCloseOnClick = false;
                            me.enableHover = false;
                        }
                    }
                }
            }
            $.data(document.body, 'menuel', this);

            this.hasTransform = $.jqx.utilities.hasTransform(this.host);

            this._applyOrientation(mode, oldMode);
            this.removeHandler(this.host, 'blur');
            this.removeHandler(this.host, 'focus');
            this.addHandler(this.host, 'blur', function (event) {
                if (me.keyboardNavigation) {
                    if (me.activeItem) {
                        if (me.mode === "popup") {
                            if (document.activeElement && document.activeElement.className.indexOf('jqx-menu-wrapper') >= 0) {
                                return;
                            }
                        }
                        $(me.activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                        me.activeItem = null;
                    }
                }
            });
            this.addHandler(this.host, 'focus', function (event) {
                if (me.keyboardNavigation) {
                    if (!me.activeItem) {
                        if (me.hoveredItem) {
                            $(me.hoveredItem.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                            me.activeItem = me.hoveredItem;
                        }
                        else {
                            var setActiveItem = function () {
                                if (!$.jqx.isHidden($(me.items[0].element))) {
                                    $(me.items[0].element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = me.items[0];
                                }
                                else {
                                    var item = me._nextVisibleItem(me.items[0], 0);
                                    if (item) {
                                        $(item.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                        me.activeItem = item;
                                    }
                                }
                            }

                            if (!me.activeItem) {
                                setActiveItem();
                            }
                            else {
                                if (!$.jqx.isHidden($(me.activeItem.element))) {
                                    $(me.activeItem.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                }
                                else {
                                    $(me.activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    setActiveItem();
                                }
                            }
                        }
                    }
                }
            });
            this.removeHandler(this.host, 'keydown.menu' + this.element.id);
            me.handleKeyDown = function (event) {
                if (me.keyboardNavigation) {
                    if (event.target.nodeName.toLowerCase() === "input") {
                        return true;
                    }

                    var activeItem = null;
                    var selectedItem = null;

                    $.each(me.items, function () {
                        var item = this;
                        if (this.disabled)
                            return true;

                        if (this.element.className.indexOf('pressed') >= 0) {
                            selectedItem = this;
                        }

                        if (this.element.className.indexOf('focus') >= 0) {
                            activeItem = this;
                            return false;
                        }
                    });


                    if (!activeItem && selectedItem) {
                        activeItem = selectedItem;
                        return false;
                    }
                    if (!activeItem) {
                        $(me.items[0].element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                        me.activeItem = me.items[0];
                        activeItem = me.activeItem;
                        return false;
                    }

                    var handled = false;
                    if (event.keyCode == 27) {
                        event.data = me;
                        me._closeAll(event);
                        if (activeItem) {
                            var item = activeItem;
                            while (item != null) {
                                if (item.parentItem) {
                                    item = item.parentItem;
                                }
                                else {
                                    $(me.activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = item;
                                    $(me.activeItem.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    item = item.parentItem;
                                }
                            }
                        }
                        handled = true;
                    }

                    if (event.keyCode == 13) {
                        if (activeItem) {
                            handled = true;
                            me._raiseEvent('2', { item: activeItem.element, event: event, type: "keyboard" });

                            var anchor = activeItem.anchor != null ? $(activeItem.anchor) : null;

                            if (anchor != null && anchor.length > 0) {
                                var href = anchor.attr('href');
                                var target = anchor.attr('target');
                                if (href != null) {
                                    if (target != null) {
                                        window.open(href, target);
                                    }
                                    else {
                                        window.location = href;
                                    }
                                }

                            }
                            event.preventDefault();
                            event.stopPropagation();
                            $(activeItem.element).focus();
                        }
                    }

                    var getSiblings = function (activeItem) {
                        if (activeItem == null)
                            return new Array();

                        var siblings = new Array();
                        var index = 0;
                        for (var i = 0; i < me.items.length; i++) {
                            if (me.items[i].parentId == activeItem.parentId) {
                                siblings[index++] = me.items[i];
                            }
                        }
                        return siblings;
                    }

                    var arrowKey = "";
                    switch (event.keyCode) {
                        case 40:
                            arrowKey = "down";
                            break;
                        case 38:
                            arrowKey = "up";
                            break;
                        case 39:
                            arrowKey = "right";
                            break;
                        case 37:
                            arrowKey = "left";
                            break;
                    }

                    if (activeItem && activeItem.openHorizontalDirection === "left" && arrowKey === "left") {
                        arrowKey = "right";
                    }
                    if (activeItem && activeItem.openHorizontalDirection === "left" && arrowKey === "right") {
                        arrowKey = "left";
                    }
                    if (activeItem && activeItem.openVerticalDirection === "top" && arrowKey === "top") {
                        arrowKey = "bottom";
                    }
                    if (activeItem && activeItem.openVerticalDirection === "top" && arrowKey === "bottom") {
                        arrowKey = "top";
                    }

                    if (me.rtl) {
                        if (arrowKey === "right")
                            arrowKey = "left";
                        else if (arrowKey === "left")
                            arrowKey = "right";
                    }


                    if (arrowKey === "right" && !me.minimized) {
                        if (event.altKey && (activeItem.level != 0 && activeItem.hasItems || me.mode != "horizontal")) {
                            me._openItem(me, activeItem);
                        }
                        else {
                            var itemToFocus = me._nextVisibleItem(activeItem, 0);
                            var subItem = me._nextVisibleItem(activeItem);
                            var siblings = getSiblings(subItem);

                            if (!itemToFocus) {
                                itemToFocus = subItem;
                            }

                            if (itemToFocus && ((itemToFocus.parentId === activeItem.parentId && itemToFocus.level == 0 && me.mode == "horizontal") || (subItem.id == siblings[0].id && subItem.level != 0))) {
                                if (subItem.id == siblings[0].id && ((activeItem.level != 0) || (activeItem.level == 0 && me.mode != "horizontal"))) {
                                    itemToFocus = subItem;
                                }

                                $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = itemToFocus;
                            }
                        }

                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (arrowKey === "left" && !me.minimized) {
                        if (event.altKey && ((activeItem.level != 0 && me.mode !== "horizontal") || (activeItem.level > 1 && me.mode === "horizontal") || (activeItem.level == 1 && activeItem.hasItems && me.mode === "horizontal"))) {
                            if (activeItem.hasItems) {
                                me._closeItem(me, activeItem);
                            }
                            else {
                                if (activeItem.parentItem) {
                                    me._closeItem(me, activeItem.parentItem);
                                    $(activeItem.parentItem.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = activeItem.parentItem;
                                }
                            }
                        }
                        else {
                            var itemToFocus = me._prevVisibleItem(activeItem, 0);
                            var currentItemToFocus = activeItem.parentItem;

                            if (itemToFocus && (itemToFocus.parentId === activeItem.parentId && itemToFocus.level == 0 && me.mode == "horizontal")) {
                                $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = itemToFocus;
                            }
                            else if (!(currentItemToFocus && currentItemToFocus.level == 0 && me.mode == "horizontal") && currentItemToFocus && currentItemToFocus.level == activeItem.level - 1) {
                                $(currentItemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = currentItemToFocus;
                            }

                        }
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (arrowKey === "down") {
                        if (event.altKey) {
                            if (activeItem.level == 0 && activeItem.hasItems) {
                                me._openItem(me, activeItem);
                            }
                            if (me.minimized) {
                                if (me.minimizedHidden) {
                                    me.minimizedItem.trigger('click');
                                }
                            }
                        }
                        else {
                            var itemToFocus = me._nextVisibleItem(activeItem, activeItem.level);
                            var siblings = getSiblings(itemToFocus);
                            if (me.minimized && itemToFocus) {
                                $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = itemToFocus;
                            }
                            else {
                                if (itemToFocus && (itemToFocus.parentId === activeItem.parentId || (itemToFocus.id == siblings[0].id && me.mode == "horizontal"))) {
                                    if (!(itemToFocus.level == 0 && me.mode == "horizontal")) {
                                        $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                        $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                        me.activeItem = itemToFocus;
                                    }
                                }
                                if (me.mode === "horizontal" && activeItem.level === 0 && activeItem.isOpen && activeItem.hasItems) {
                                    var itemToFocus = me._nextVisibleItem(activeItem);
                                    $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = itemToFocus;
                                }
                            }
                        }

                        event.preventDefault();
                        event.stopPropagation();
                    }
                    else if (arrowKey === "up") {
                        if (event.altKey) {
                            if (activeItem.parentItem && activeItem.parentItem.level == 0) {
                                me._closeItem(me, activeItem.parentItem);
                                $(activeItem.parentItem.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = activeItem.parentItem;
                            }
                            else if (activeItem.parentItem === null && activeItem.level === 0 && me.mode === "horizontal") {
                                me._closeItem(me, activeItem);
                            }
                            if (me.minimized) {
                                if (!me.minimizedHidden) {
                                    me.minimizedItem.trigger('click');
                                }
                            }
                        }
                        else {
                            var itemToFocus = me._prevVisibleItem(activeItem, activeItem.level);
                            var siblings = getSiblings(activeItem);

                            if (me.minimized && itemToFocus) {
                                $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = itemToFocus;
                            }
                            else {
                                if (itemToFocus && (itemToFocus.parentId === activeItem.parentId || (itemToFocus.id == activeItem.parentId && itemToFocus.level == 0 && me.mode == "horizontal"))) {
                                    if (!(itemToFocus.level == 0 && me.mode === "horizontal" && activeItem.level === 0)) {
                                        $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                        $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                        me.activeItem = itemToFocus;
                                    }
                                }
                                else if (activeItem && activeItem.id == siblings[0].id && activeItem.parentItem && activeItem.parentItem.level === 0 && me.mode === "horizontal") {
                                    var itemToFocus = activeItem.parentItem;
                                    $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = itemToFocus;
                                }
                            }
                        }
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (event.keyCode == 9) {
                        var itemToFocus = event.shiftKey ? me._prevVisibleItem(activeItem) : me._nextVisibleItem(activeItem);

                        if (itemToFocus) {
                            $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                            $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                            me.activeItem = itemToFocus;
                            event.preventDefault();
                            event.stopPropagation();
                        }
                        else if (me.lockFocus) {
                            var siblings = new Array();
                            var index = 0;
                            for (var i = 0; i < me.items.length; i++) {
                                if (me.items[i] == activeItem)
                                    continue;

                                if (me.items[i].parentId == activeItem.parentId) {
                                    siblings[index++] = me.items[i];
                                }
                            }

                            if (siblings.length > 0) {
                                if (event.shiftKey) {
                                    $(siblings[siblings.length - 1].element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = siblings[siblings.length - 1];
                                }
                                else {
                                    $(siblings[0].element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = siblings[0];
                                }
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                            }
                            event.preventDefault();
                            event.stopPropagation();
                        }
                        else if (activeItem) {
                            $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                            me.activeItem = null;
                        }
                    }
                }
                else {
                    return true;
                }
            }
            this.addHandler(this.host, 'keydown.menu' + this.element.id, function (event) {
                me.handleKeyDown(event);
            });

            if (me.enableRoundedCorners) {
                this.host.addClass(me.toThemeProperty('jqx-rc-all'));
            }

            $.each(this.items, function () {
                var item = this;
                var $menuElement = $(item.element);
                $menuElement.attr('role', 'menuitem');
                if (me.enableRoundedCorners) {
                    $menuElement.addClass(me.toThemeProperty('jqx-rc-all'));
                }

                me.removeHandler($menuElement, 'click');
                me.addHandler($menuElement, 'click', function (e) {
                    if (item.disabled)
                        return;

                    if (me.disabled)
                        return;

                    if (me.keyboardNavigation) {
                        if (me.activeItem) {
                            $(me.activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                        }
                        me.activeItem = item;
                        $(item.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                        if (me.minimized) {
                            e.stopPropagation();
                        }
                    }

                    me._raiseEvent('2', { type: "mouse", item: item.element, event: e });

                    if (!me.autoOpen) {
                        if (item.level > 0) {
                            if (me.autoCloseOnClick && !isTouchDevice && !me.clickToOpen) {
                                e.data = me;
                                me._closeAll(e);
                            }
                        }
                    }
                    else if (me.autoCloseOnClick && !isTouchDevice && !me.clickToOpen) {
                        if (item.closeOnClick) {
                            e.data = me;
                            me._closeAll(e);
                        }
                    }
                    if (isTouchDevice && me.autoCloseOnClick) {
                        e.data = me;
                        if (!item.hasItems) {
                            me._closeAll(e);
                        }
                    }

                    if (e.target.tagName != 'A' && e.target.tagName != 'a') {
                        var anchor = item.anchor != null ? $(item.anchor) : null;

                        if (anchor != null && anchor.length > 0) {
                            var href = anchor.attr('href');
                            var target = anchor.attr('target');
                            if (href != null) {
                                if (target != null) {
                                    window.open(href, target);
                                }
                                else {
                                    window.location = href;
                                }
                            }
                        }
                    }
                });

                me.removeHandler($menuElement, 'mouseenter');
                me.removeHandler($menuElement, 'mouseleave');

                if (!WP && me.mode != 'simple') {
                    me._renderHover($menuElement, item, isTouchDevice);
                }
                if (item.subMenuElement != null) {
                    var $submenu = $(item.subMenuElement);
                    if (me.mode == 'simple') {
                        $submenu.show();
                        return true;
                    }
                    $submenu.wrap('<div class="jqx-menu-popup ' + me.toThemeProperty('jqx-menu-popup') + '" style="border: none; background-color: transparent; z-index:' + zIndex + '; padding: 0px; margin: 0px; position: absolute; top: 0; left: 0; display: block; visibility: hidden;"><div style="background-color: transparent; border: none; position:absolute; overflow:hidden; left: 0; top: 0; right: 0; width: 100%; height: 100%;"></div></div>')
                    $submenu.css({ overflow: 'hidden', position: 'absolute', left: 0, display: 'inherit', top: -$submenu.outerHeight() })
                    $submenu.data('timer', {});
                    if (item.level > 0) {
                        $submenu.css('left', -$submenu.outerWidth());
                    }
                    else if (me.mode == 'horizontal') {
                        $submenu.css('left', 0);
                    }

                    zIndex++;
                    var $popupElement = $(item.subMenuElement).closest('div.jqx-menu-popup').css({ width: parseInt($(item.subMenuElement).outerWidth()) + parseInt(popupElementoffset[0]) + 'px', height: parseInt($(item.subMenuElement).outerHeight()) + parseInt(popupElementoffset[1]) + 'px' })
                    var $popupElementparent = $menuElement.closest('div.jqx-menu-popup')

                    if ($popupElementparent.length > 0) {
                        var oldsubleftmargin = $submenu.css('margin-left');
                        var oldsubrightmargin = $submenu.css('margin-right');
                        var oldsubleftpadding = $submenu.css('padding-left');
                        var oldsubrightpadding = $submenu.css('padding-right');

                        $popupElement.addClass('horizontal');
                        $popupElement.appendTo($popupElementparent)

                        $submenu.css('margin-left', oldsubleftmargin);
                        $submenu.css('margin-right', oldsubrightmargin);
                        $submenu.css('padding-left', oldsubleftpadding);
                        $submenu.css('padding-right', oldsubrightpadding);
                    }
                    else {
                        var oldsubleftmargin = $submenu.css('margin-left');
                        var oldsubrightmargin = $submenu.css('margin-right');
                        var oldsubleftpadding = $submenu.css('padding-left');
                        var oldsubrightpadding = $submenu.css('padding-right');

                        if (me.mode === 'horizontal') {
                            $popupElement.addClass('top');
                        }
                        else {
                            $popupElement.addClass('horizontal');
                        }
                        $popupElement.appendTo($(document.body));
                        $submenu.css('margin-left', oldsubleftmargin);
                        $submenu.css('margin-right', oldsubrightmargin);
                        $submenu.css('padding-left', oldsubleftpadding);
                        $submenu.css('padding-right', oldsubrightpadding);
                    }

                    if (!me.clickToOpen) {
                        if (isTouchDevice || WP) {
                            me.removeHandler($menuElement, $.jqx.mobile.getTouchEventName('touchstart'));
                            me.addHandler($menuElement, $.jqx.mobile.getTouchEventName('touchstart'), function (event) {
                                clearTimeout($submenu.data('timer').hide)
                                if ($submenu != null) {
                                    $submenu.stop();
                                }

                                if (item.level == 0 && !item.isOpen && me.mode != "popup") {
                                    event.data = me;
                                    me._closeAll(event);
                                }

                                if (!item.isOpen) {
                                    me._openItem(me, item);
                                }
                                else {
                                    me._closeItem(me, item, true);
                                }
                                return false;
                            });
                        }

                        if (!WP) {
                            me.addHandler($menuElement, 'mouseenter', function () {
                                if (me.autoOpen || (item.level > 0 && !me.autoOpen)) {
                                    clearTimeout($submenu.data('timer').hide)
                                }

                                if (item.parentId && item.parentId != 0) {
                                    if (me.menuElements[item.parentId]) {
                                        var openedStateOfParent = me.menuElements[item.parentId].isOpen;
                                        if (!openedStateOfParent) {
                                            return;
                                        }
                                    }
                                }

                                if (me.autoOpen || (item.level > 0 && !me.autoOpen)) {
                                    me._openItem(me, item);
                                }
                                return false;
                            });

                            me.addHandler($menuElement, 'mousedown', function () {
                                if (!me.autoOpen && item.level == 0) {
                                    clearTimeout($submenu.data('timer').hide)
                                    if ($submenu != null) {
                                        $submenu.stop();
                                    }

                                    if (!item.isOpen) {
                                        me._openItem(me, item);
                                    }
                                    else {
                                        me._closeItem(me, item, true);
                                    }
                                }
                            });

                            me.addHandler($menuElement, 'mouseleave', function (event) {
                                if (me.autoCloseOnMouseLeave) {
                                    clearTimeout($submenu.data('timer').hide)
                                    var $subMenu = $(item.subMenuElement);
                                    var position = { left: parseInt(event.pageX), top: parseInt(event.pageY) };
                                    var subMenuBounds = {
                                        left: parseInt($subMenu.coord().left), top: parseInt($subMenu.coord().top),
                                        width: parseInt($subMenu.outerWidth()), height: parseInt($subMenu.outerHeight())
                                    };

                                    var closeItem = true;
                                    if (subMenuBounds.left - 5 <= position.left && position.left <= subMenuBounds.left + subMenuBounds.width + 5) {
                                        if (subMenuBounds.top <= position.top && position.top <= subMenuBounds.top + subMenuBounds.height) {
                                            closeItem = false;
                                        }
                                    }

                                    if (closeItem) {
                                        me._closeItem(me, item, true);
                                    }
                                }
                            });

                            me.removeHandler($popupElement, 'mouseenter');
                            me.addHandler($popupElement, 'mouseenter', function () {
                                clearTimeout($submenu.data('timer').hide)
                            });

                            me.removeHandler($popupElement, 'mouseleave');
                            me.addHandler($popupElement, 'mouseleave', function (e) {
                                if (me.autoCloseOnMouseLeave) {
                                    clearTimeout($submenu.data('timer').hide)
                                    clearTimeout($submenu.data('timer').show);
                                    if ($submenu != null) {
                                        $submenu.stop();
                                    }
                                    me._closeItem(me, item, true);
                                }
                            });
                        }
                    }
                    else {
                        me.removeHandler($menuElement, 'mousedown');
                        me.addHandler($menuElement, 'mousedown', function (event) {

                            clearTimeout($submenu.data('timer').hide)
                            if ($submenu != null) {
                                $submenu.stop();
                            }

                            if (item.level == 0 && !item.isOpen) {
                                event.data = me;
                                me._closeAll(event);
                            }

                            if (!item.isOpen) {
                                me._openItem(me, item);
                            }
                            else {
                                me._closeItem(me, item, true);
                            }
                        });
                    }
                }
            });

            if (this.mode == "simple") {
                this._renderSimpleMode()
            }

            this._autoSizeHorizontalMenuItems();
            this._raiseEvent('3', this);
        },

        _renderSimpleMode: function () {
            this.host.show();
        },

        createID: function () {
            var id = Math.random() + '';
            id = id.replace('.', '');
            id = '99' + id;
            id = id / 1;
            while (this.items[id]) {
                id = Math.random() + '';
                id = id.replace('.', '');
                id = id / 1;
            }
            return 'menuItem' + id;
        },

        _createMenu: function (uiObject, refresh) {
            if (uiObject == null)
                return;

            if (refresh == undefined) {
                refresh = true;
            }
            if (refresh == null) {
                refresh = true;
            }

            var self = this;

            $(uiObject).addClass('jqx-menu-ul');

            var liTags = $(uiObject).find('li');
            var k = 0;
            this.itemMapping = new Array();

            for (var index = 0; index < liTags.length; index++) {
                var listItem = liTags[index];
                var $listItem = $(listItem);

                if (listItem.className.indexOf('jqx-menu') == -1 && this.autoGenerate == false)
                    continue;

                var id = listItem.id;
                if (!id) {
                    id = this.createID();
                }

                if (refresh) {
                    listItem.id = id;
                    this.items[k] = new $.jqx._jqxMenu.jqxMenuItem();
                    this.menuElements[id] = this.items[k];
                }

                k += 1;
                var parentId = 0;
                var me = this;
                var children = $listItem.children();
                children.each(function () {
                    if (!refresh) {
                        this.className = "";

                        if (me.autoGenerate) {
                            $(me.items[k - 1].subMenuElement)[0].className = "";
                            if (!me.minimized) {
                                $(me.items[k - 1].subMenuElement).addClass(me.toThemeProperty('jqx-widget-content'));
                            }
                            $(me.items[k - 1].subMenuElement).addClass(me.toThemeProperty('jqx-menu-dropdown'));
                            $(me.items[k - 1].subMenuElement).addClass(me.toThemeProperty('jqx-popup'));
                        }
                    }

                    if (this.className.indexOf('jqx-menu-dropdown') != -1) {
                        if (refresh) {
                            me.items[k - 1].subMenuElement = this;
                        }
                        return false;
                    }
                    else if (me.autoGenerate && (this.tagName == 'ul' || this.tagName == 'UL')) {
                        if (refresh) {
                            me.items[k - 1].subMenuElement = this;
                        }
                        this.className = "";
                        if (!me.minimized) {
                            $(this).addClass(me.toThemeProperty('jqx-widget-content'));
                        }
                        $(this).addClass(me.toThemeProperty('jqx-menu-dropdown'));
                        $(this).addClass(me.toThemeProperty('jqx-popup'));
                        $(this).attr('role', 'menu');
                        if (me.rtl) {
                            $(this).addClass(me.toThemeProperty('jqx-rc-l'));
                        }
                        else {
                            $(this).addClass(me.toThemeProperty('jqx-rc-r'));
                        }
                        $(this).addClass(me.toThemeProperty('jqx-rc-b'));

                        return false;
                    }
                });

                var parents = $listItem.parents();
                parents.each(function () {
                    if (this.className.indexOf('jqx-menu-item') != -1) {
                        parentId = this.id;
                        return false;
                    }
                    else if (me.autoGenerate && (this.tagName == 'li' || this.tagName == 'LI')) {
                        parentId = this.id;
                        return false;
                    }

                });

                var separator = false;
                var type = listItem.getAttribute('type');
                var ignoretheme = listItem.getAttribute('ignoretheme') || listItem.getAttribute('data-ignoretheme');

                if (ignoretheme) {
                    if (ignoretheme == 'true' || ignoretheme == true) {
                        ignoretheme = true;
                    }
                }
                else ignoretheme = false;

                if (!type) {
                    type = listItem.type;
                }
                else {
                    if (type == 'separator') {
                        var separator = true;
                    }
                }

                if (!separator) {
                    if (parentId) {
                        type = 'sub';
                    }
                    else type = 'top';
                }

                var menuItem = this.items[k - 1];
                if (refresh) {
                    menuItem.id = id;
                    menuItem.parentId = parentId;
                    menuItem.type = type;
                    menuItem.separator = separator;
                    menuItem.element = liTags[index];
                    var anchor = $listItem.children('a');
                    menuItem.disabled = listItem.getAttribute('item-disabled') == "true" ? true : false;

                    menuItem.level = $listItem.parents('li').length;
                    menuItem.anchor = anchor.length > 0 ? anchor : null;
                    if (menuItem.anchor) {
                        $(menuItem.anchor).attr('tabindex', -1);
                    }
                }
                menuItem.ignoretheme = ignoretheme;

                var parentItem = this.menuElements[parentId];
                if (parentItem != null) {
                    if (parentItem.ignoretheme) {
                        menuItem.ignoretheme = parentItem.ignoretheme;
                        ignoretheme = parentItem.ignoretheme;
                    }
                    menuItem.parentItem = parentItem;
                    menuItem.parentElement = parentItem.element;
                }

                if (this.autoGenerate) {
                    if (type == 'separator') {
                        $listItem.removeClass();
                        $listItem.addClass(this.toThemeProperty('jqx-menu-item-separator'));
                        $listItem.attr('role', 'separator');
                    }
                    else {
                        if (!ignoretheme) {
                            if ($listItem[0].className.indexOf("jqx-grid-menu-item-touch") >= 0) {
                                $listItem[0].className = this.toThemeProperty('jqx-grid-menu-item-touch');
                            }
                            else {
                                $listItem[0].className = "";
                            }

                            if (this.rtl) {
                                $listItem.addClass(this.toThemeProperty('jqx-rtl'));
                            }
                            if (menuItem.level > 0 && !me.minimized) {
                                $listItem.addClass(this.toThemeProperty('jqx-item'));
                                $listItem.addClass(this.toThemeProperty('jqx-menu-item'));
                            }
                            else {
                                $listItem.addClass(this.toThemeProperty('jqx-item'));
                                $listItem.addClass(this.toThemeProperty('jqx-menu-item-top'));
                            }
                        }
                    }
                }
                if (menuItem.disabled) {
                    $listItem.addClass(me.toThemeProperty('jqx-menu-item-disabled'));
                    $listItem.addClass(me.toThemeProperty('jqx-fill-state-disabled'));
                }

                this.itemMapping[index] = { element: liTags[index], item: menuItem };
                this.itemMapping["id" + liTags[index].id] = this.itemMapping[index];

                if (refresh && !ignoretheme) {
                    menuItem.hasItems = $listItem.find('li').length > 0;
                    if (menuItem.hasItems) {
                        if (menuItem.element) {
                            $.jqx.aria($(menuItem.element), "aria-haspopup", true);
                            if (!menuItem.subMenuElement.id) menuItem.subMenuElement.id = $.jqx.utilities.createId();
                            $.jqx.aria($(menuItem.element), "aria-owns", menuItem.subMenuElement.id);
                        }
                    }
                }
            }

            for (var i = 0; i < liTags.length; i++) {
                var listTag = liTags[i];
                if (this.itemMapping["id" + listTag.id]) {
                    var menuItem = this.itemMapping["id" + listTag.id].item;
                    if (!menuItem)
                        continue;

                    menuItem.prevItem = null;
                    menuItem.nextItem = null;
                    if (i > 0) {
                        if (this.itemMapping["id" + liTags[i - 1].id]) {
                            menuItem.prevItem = this.itemMapping["id" + liTags[i - 1].id].item;
                        }
                    }

                    if (i < liTags.length - 1) {
                        if (this.itemMapping["id" + liTags[i + 1].id]) {
                            menuItem.nextItem = this.itemMapping["id" + liTags[i + 1].id].item;
                        }
                    }
                }
            }
        },

        destroy: function () {
            var me = this;
            $.jqx.utilities.resize(me.host, null, true);
            var wrapper = me.host.closest('div.jqx-menu-wrapper');
            me.removeHandler(wrapper, 'keydown');
            wrapper.remove();
            me.removeHandler($("#menuWrapper" + me.element.id), 'keydown');
            $("#menuWrapper" + me.element.id).remove();
            me.removeHandler(me.host, 'keydown');
            me.removeHandler(me.host, 'focus');
            me.removeHandler(me.host, 'blur');
            me.removeHandler($(document), 'mousedown.menu' + me.element.id, me._closeAfterClick);
            me.removeHandler($(document), 'mouseup.menu' + me.element.id, me._closeAfterClick);
            me.removeHandler($(document), 'contextmenu.' + me.element.id);
            me.removeHandler(me.host, 'contextmenu.' + me.element.id);

            $.data(document.body, 'jqxMenuOldHost' + me.element.id, null);
            if (me.isTouchDevice()) {
                me.removeHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.menu' + me.element.id, me._closeAfterClick, this);
            }

            if ($(window).off) {
                $(window).off('resize.menu' + me.element.id);
            }
            $.each(me.items, function () {
                var item = this;
                var $menuElement = $(item.element);
                me.removeHandler($menuElement, 'click');
                me.removeHandler($menuElement, 'selectstart');
                me.removeHandler($menuElement, 'mouseenter');
                me.removeHandler($menuElement, 'mouseleave');
                me.removeHandler($menuElement, 'mousedown');
                me.removeHandler($menuElement, 'mouseleave');
                var $submenu = $(item.subMenuElement);
                var $popupElement = $submenu.closest('div.jqx-menu-popup');
                $popupElement.remove();
                delete this.subMenuElement;
                delete this.element;
            });
            $.data(document.body, 'menuel', null);
            delete me.menuElements;
            me.items = new Array();
            delete me.items;
            var vars = $.data(me.element, "jqxMenu");
            if (vars) {
                delete vars.instance;
            }

            me.host.removeClass();
            me.host.remove();
            delete me.host;
            delete me.element;
        },

        _raiseEvent: function (id, arg) {
            if (arg == undefined)
                arg = { owner: null };

            var evt = this.events[id];
            var args = arg;
            args.owner = this;

            var event = new $.Event(evt);
            if (id == '2') {
                args = arg.item;
                args.owner = this;
                args.clickType = arg.type;
                $.extend(event, arg.event);
                event.type = 'itemclick';
            }

            event.owner = this;
            event.args = args;
            var result = this.host.trigger(event);
            return result;
        },

        propertiesChangedHandler: function (object, key, value) {
            if (value.width && value.height && Object.keys(value).length == 2) {
                object._setSize();
                if (object.mode === "popup") {
                    var $popupElementparent = this.host.closest('div.jqx-menu-wrapper');
                    $popupElementparent[key](value);
                    var id = this.host[0].id;
                    $("#" + id)[key](value);
                }
            }
        },

        propertyChangedHandler: function (object, key, oldvalue, value) {
            if (this.isInitialized == undefined || this.isInitialized == false)
                return;

            if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                return;
            }

            if (key == "disabled") {
                if (object.disabled) {
                    object.host.addClass(object.toThemeProperty('jqx-fill-state-disabled'));
                    object.host.addClass(object.toThemeProperty('jqx-menu-disabled'));
                }
                else {
                    object.host.removeClass(object.toThemeProperty('jqx-fill-state-disabled'));
                    object.host.removeClass(object.toThemeProperty('jqx-menu-disabled'));
                }
            }

            if (value == oldvalue)
                return;

            if (key == 'touchMode') {
                this._isTouchDevice = null;
                object._render(value, oldvalue);
            }

            if (key === "width" || key === "height") {
                object._setSize();
                if (object.mode === "popup") {
                    var $popupElementparent = this.host.closest('div.jqx-menu-wrapper');
                    $popupElementparent[key](value);
                    var id = this.host[0].id;
                    $("#" + id)[key](value);
                }
                return;
            }
            if (key == 'source') {
                if (object.source != null) {
                    var html = object.loadItems(object.source);
                    object.element.innerHTML = html;
                    var innerElement = object.host.find('ul:first');
                    if (innerElement.length > 0) {
                        object.refresh();
                        object._createMenu(innerElement[0]);
                        object._render();
                    }
                }
            }

            if (key == 'autoCloseOnClick') {
                if (value == false) {
                    object.removeHandler($(document), 'mousedown.menu' + this.element.id, object._closeAll);
                }
                else {
                    object.addHandler($(document), 'mousedown.menu' + this.element.id, object, object._closeAll);
                }
            }
            else if (key == 'mode' || key == 'width' || key == 'height' || key == 'showTopLevelArrows') {
                object.refresh();

                if (key == 'mode') {
                    object._render(value, oldvalue);
                }
                else object._applyOrientation();
            }
            else if (key == 'theme') {
                $.jqx.utilities.setTheme(oldvalue, value, object.host);
            }
        }
    });
})(jqxBaseFramework);

(function ($) {
    $.jqx._jqxMenu.jqxMenuItem = function (id, parentId, type) {
        var menuItem =
        {
            // gets the id.
            id: id,
            // gets the parent id.
            parentId: parentId,
            // gets the parent item instance.
            parentItem: null,
            // gets the anchor element.
            anchor: null,
            // gets the type
            type: type,
            // gets whether the item is disabled.
            disabled: false,
            // gets the item's level.
            level: 0,
            // gets a value whether the item is opened.
            isOpen: false,
            // has sub elements.
            hasItems: false,
            // li element
            element: null,
            subMenuElement: null,
            // arrow element.
            arrow: null,
            // left, right, center
            openHorizontalDirection: 'right',
            // up, down, center
            openVerticalDirection: 'down',
            closeOnClick: true
        }
        return menuItem;
    }; //
})(jqxBaseFramework);
})();



/***/ }),

/***/ 7995:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {

    $.jqx.jqxWidget("jqxNumberInput", "", {});

    $.extend($.jqx._jqxNumberInput.prototype, {

        defineInstance: function () {
            var settings = {
                // Type: Number
                // Default: null
                // Gets or sets the input's value.
                value: 0,
                // Type: Number
                // Default: 0
                // Gets or sets the input's number.
                decimal: 0,
                // Type: Number
                // Default= 0
                // Gets or sets the input's minimum value.
                min: -99999999,
                // Type: Number
                // Default: 0
                // Gets or sets the input's maximum value.
                max: 99999999,
                //Type: Number.
                //Default: 0.
                //Sets width of the input in pixels. Only positive values have effect.
                width: 200,
                //Type: String,
                //Default: Invalid value.
                validationMessage: "Invalid value",
                //Type: Number.
                //Default: 0.
                //Sets height of the input in pixels.
                height: 25,
                // Sets the alignment.
                textAlign: "right",
                // Type: Bool
                // Default: false
                // Sets the readOnly state of the input.
                readOnly: false,
                // Type: Char
                // Default: "_"
                // Sets the prompt char displayed when an editable char is empty.
                // Possible Values: "_", "?", "#".
                promptChar: "_",
                // Type: Number
                // Default: 2
                // Indicates the number of decimal places to use in numeric values.
                decimalDigits: 2,
                // Type= Char
                // Default: '.'
                // Gets or sets the char to use as the decimal separator in numeric values.
                decimalSeparator: ".",
                // Type= Char
                // Default: ","
                // Gets or sets the string that separates groups of digits to the left of the
                // decimal in numeric values.
                groupSeparator: ",",
                // Type: Number
                // Default: '3'
                // Gets or sets the number of digits in each group to the left of the decimal in numeric values.
                groupSize: 3,
                // Type: String
                // Default: empty
                // Gets or sets the string to use as currency or percentage symbol.
                symbol: '',
                // Type: Bool
                // Default: "left"
                // Gets or sets the position of the symbol in the input.
                symbolPosition: "left",
                // Type: Number
                // Default: 8
                // Gets or sets the digits in the input
                digits: 8,
                // Type: Bool
                // Default: false
                // Gets or sets whether the decimal is negative.
                negative: false,
                // Type: Bool
                // Default: false
                // Gets or sets the string to use as negative symbol.
                negativeSymbol: '-',
                // Type: Bool
                // Default: false
                // Gets or sets whether the widget is disabled.
                disabled: false,
                // Type: String
                // Default: advanced
                // Gets or sets the input mode. When the mode is simple, the text is formatted after editing. When the mode is advanced, the text is formatted while the user is in edit mode.
                // Available values: [simple, advanced]
                inputMode: 'advanced',
                // Type: Boolean
                // Default: false
                // shows the spin buttons.
                spinButtons: false,
                // Type: Number
                // Default: 18
                // Sets the spin buttons width
                spinButtonsWidth: 18,
                // Type: Number
                // Default: 1
                // sets the spin button step.
                spinButtonsStep: 1,
                // validates the value to be in the min-max range when the user leaves the input.
                autoValidate: true,
                // none, advanced or simple
                spinMode: 'advanced',
                enableMouseWheel: true,
                touchMode: "auto",
                allowNull: true,
                placeHolder: "",
                changeType: null,
                template: "",
                rtl: false,
                hint: true,
                // NumberInput events.
                events:
                    [
                        'valueChanged',
                        'textchanged',
                        'mousedown',
                        'mouseup',
                        'keydown',
                        'keyup',
                        'keypress',
                        'change'
                    ],
                aria:
                {
                    "aria-valuenow": { name: "decimal", type: "number" },
                    "aria-valuemin": { name: "min", type: "number" },
                    "aria-valuemax": { name: "max", type: "number" },
                    "aria-disabled": { name: "disabled", type: "boolean" }
                },
                invalidArgumentExceptions:
                    [
                        'invalid argument exception'
                    ]
            };
            if (this === $.jqx._jqxNumberInput.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        // creates the number input's instance.
        createInstance: function (args) {
            if (this.promptChar === "") {
                this.promptChar = " ";
            }
            var _val = this.host.attr('value');
            if (_val != undefined) {
                this.decimal = _val;
            }

            if (this.decimal === 0) {
                if (this.value != null) {
                    this.decimal = this.value;
                }
                else if (this.value === null && this.decimal !== 0) {
                    this.value = this.decimal;
                }
            }

            var that = this;
            that._createFromInput("jqxNumberInput");

            this.render();
        },

        _updateHint: function () {
            var that = this;

            if (!that.hint) {
                return;
            }

            if (that.isMaterialized()) {
                setTimeout(function () {
                    if (that.numberInput[0].value.length === 0) {
                        that.element.removeAttribute('hint');
                        if (that.label && that.label[0]) {
                            that.label[0].innerHTML = that.placeHolder;
                        }
                    }
                    else {
                        that.element.setAttribute('hint', true);
                    }
                });
            }
        },

        _createFromInput: function (name) {
            var that = this;
            if (that.element.nodeName.toLowerCase() == "input") {
                that.field = that.element;
                if (that.field.className) {
                    that._className = that.field.className;
                }

                var properties = {
                    'title': that.field.title
                };

                if (that.field.value) {
                    that.decimal = parseFloat(that.field.value);
                }
                if (that.field.getAttribute('min')) {
                    var min = (that.field.getAttribute('min'));
                    that.min = parseFloat(min);
                }
                if (that.field.getAttribute('step')) {
                    var step = (that.field.getAttribute('step'));
                    that.spinButtonsStep = parseFloat(step);
                }
                if (that.field.getAttribute('max')) {
                    var max = (that.field.getAttribute('max'));
                    that.max = parseFloat(max);
                }
                if (that.field.id.length) {
                    properties.id = that.field.id.replace(/[^\w]/g, '_') + "_" + name;
                }
                else {
                    properties.id = $.jqx.utilities.createId() + "_" + name;
                }

                var wrapper = $("<div></div>", properties);
                wrapper[0].style.cssText = that.field.style.cssText;
                if (!that.width) {
                    that.width = $(that.field).width();
                }
                if (!that.height) {
                    that.height = $(that.field).outerHeight();
                }
                $(that.field).hide().after(wrapper);
                var data = that.host.data();
                that.host = wrapper;
                that.host.data(data);
                that.element = wrapper[0];
                that.element.id = that.field.id;
                that.field.id = properties.id;
                if (that._className) {
                    that.host.addClass(that._className);
                    $(that.field).removeClass(that._className);
                }

                if (that.field.tabIndex) {
                    var tabIndex = that.field.tabIndex;
                    that.field.tabIndex = -1;
                    that.element.tabIndex = tabIndex;
                }
            }
        },

        _doTouchHandling: function () {
            var me = this;
            var savedValue = me.savedValue;
            if (!me.parsing) me.parsing = true;
            if (me.parsing) {
                if (me.numberInput.val() && me.numberInput.val().indexOf('-') == 0) {
                    me.setvalue('negative', true);
                }
                else {
                    me.setvalue('negative', false);
                }
                var value = me.numberInput.val();
                for (var i = 0; i < value.length - 1; i++) {
                    var ch = value.substring(i, i + 1);
                    if (isNaN(parseFloat(ch)) && me.symbol.toString().indexOf(ch) === -1 && ch != "%" && ch != "$" && ch != '.' && ch != ',' && ch != '-') {
                        me.numberInput[0].value = savedValue;
                        me.parsing = false;
                        return;
                    }
                }

                me.ValueString = me.GetValueString(me.numberInput.val(), me.decimalSeparator, me.decimalSeparator != '');
                //me.ValueString = new Number(me.ValueString).toFixed(me.decimalDigits);
                me._parseDecimalInSimpleMode();
                me.decimal = me.ValueString;
                var isNegative = me.getvalue('negative');
                if (isNegative) {
                    me.decimal = "-" + me.ValueString;
                }

                me.parsing = false;
            }
        },

        render: function () {
            this.host
                .attr({
                    role: "spinbutton"
                });
            this.host.attr('data-role', 'input');
            $.jqx.aria(this);
            $.jqx.aria(this, "aria-multiline", false);

            var me = this;

            if (this.officeMode || (this.theme && this.theme.indexOf('office') != -1)) {
                if (this.spinButtonsWidth == 18) this.spinButtonsWidth = 15;
            }

            if ($.jqx.mobile.isTouchDevice() || this.touchMode === true) {
                this.inputMode = 'textbox';
                this.spinMode = 'simple';

            }

            if (this.decimalSeparator == '') this.decimalSeparator = ' ';
            this.host.addClass(this.toThemeProperty('jqx-input'));
            this.host.addClass(this.toThemeProperty('jqx-rc-all'));
            this.host.addClass(this.toThemeProperty('jqx-widget'));
            this.host.addClass(this.toThemeProperty('jqx-widget-content'));
            this.host.addClass(this.toThemeProperty('jqx-numberinput'));

            if (this.spinButtons) {
                this._spinButtons();
            }
            else {
                this.numberInput = $("<input style='border:none;' autocomplete='off' type='textarea'/>").appendTo(this.host);
                this.numberInput.addClass(this.toThemeProperty('jqx-input-content'));
                this.numberInput.addClass(this.toThemeProperty('jqx-widget-content'));
            }

            if ($.jqx.mobile.isTouchDevice() || this.touchMode === true) {
                this.numberInput.attr('inputmode', 'decimal');
            }

            if (!this.isMaterialized()) {
                this.numberInput.attr('placeholder', this.placeHolder);
            }

            var name = this.host.attr('name');
            if (name) {
                this.numberInput.attr('name', name);
            }
            if (this.host.attr('tabindex')) {
                this.numberInput.attr('tabindex', this.host.attr('tabindex'));
                this.host.removeAttr('tabindex');
            }

            if ($.jqx.mobile.isTouchDevice() || this.touchMode === true || this.inputMode == 'textbox') {
                var me = this;
                me.savedValue = "";

                //    this.numberInput.attr('type', 'number');
                this.addHandler(this.numberInput, 'focus', function () {
                    me.savedValue = me.numberInput[0].value;
                });

                this.addHandler(this.numberInput, 'change', function () {
                    me._doTouchHandling();
                });
            }

            var vars = $.data(this.host[0], 'jqxNumberInput');
            vars.jqxNumberInput = this;
            var me = this;

            if (this.host.parents('form').length > 0) {
                this.addHandler(this.host.parents('form'), 'reset', function () {
                    setTimeout(function () {
                        me.setDecimal(0);
                    }, 10);
                });
            }

            this.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                if (value) {
                    instance.numberInput.addClass(self.toThemeProperty('jqx-input-disabled'));
                    instance.numberInput.attr("disabled", true);
                }
                else {
                    instance.host.removeClass(self.toThemeProperty('jqx-input-disabled'));
                    instance.numberInput.attr("disabled", false);
                }

                if (instance.spinButtons && instance.host.jqxRepeatButton) {
                    instance.upbutton.jqxRepeatButton({ disabled: value });
                    instance.downbutton.jqxRepeatButton({ disabled: value });
                }
            }

            if (this.disabled) {
                this.numberInput.addClass(this.toThemeProperty('jqx-input-disabled'));
                this.numberInput.attr("disabled", true);
                this.host.addClass(this.toThemeProperty('jqx-fill-state-disabled'));
            }

            this.selectedText = "";
            this.decimalSeparatorPosition = -1;

            var id = this.element.id;
            var el = this.element;
            var self = this;

            this.oldValue = this._value();

            this.items = new Array();
            var value = this.value;
            var decimal = this.decimal;
            this._initializeLiterals();
            this._render();

            this.setDecimal(value !== null ? decimal : null);
            var me = this;
            setTimeout(function () {
                //           me._render(false);
            }
                , 100);

            this._addHandlers();
            $.jqx.utilities.resize(this.host, function () {
                me._render();
            });
        },

        refresh: function (initialRefresh) {
            if (!initialRefresh) {
                this._render();
            }
        },

        wheel: function (event, self) {
            if (!self.enableMouseWheel) {
                return;
            }
            self.changeType = "mouse";
            var delta = 0;
            if (!event) /* For IE. */
                event = window.event;

            if (event.originalEvent && event.originalEvent.wheelDelta) {
                event.wheelDelta = event.originalEvent.wheelDelta;
            }

            if (event.wheelDelta) { /* IE/Opera. */
                delta = event.wheelDelta / 120;
            } else if (event.detail) { /** Mozilla case. */
                delta = -event.detail / 3;
            }

            if (delta) {
                var result = self._handleDelta(delta);
                if (event.preventDefault)
                    event.preventDefault();

                if (event.originalEvent != null) {
                    event.originalEvent.mouseHandled = true;
                }

                if (event.stopPropagation != undefined) {
                    event.stopPropagation();
                }

                if (result) {
                    result = false;
                    event.returnValue = result;
                    return result;
                }
                else {
                    return false;
                }
            }

            if (event.preventDefault)
                event.preventDefault();
            event.returnValue = false;
        },

        _handleDelta: function (delta) {
            if (delta < 0) {
                this.spinDown();
            }
            else this.spinUp();
            return true;
        },

        _addHandlers: function () {
            var self = this;
            this.addHandler(this.numberInput, 'paste',
                function (e) {
                    var selection = self._selection();
                    e.preventDefault();
                    if (e.originalEvent.clipboardData) {
                        var content = (e.originalEvent || e).clipboardData.getData('text/plain');
                    }
                    else if (window.clipboardData) {
                        var content = window.clipboardData.getData('Text');
                    }
                    this.selectedText = content;
                    $.data(document.body, "jqxSelection", this.selectedText);
                    if (self.inputMode != "simple") {
                        self._pasteSelectedText();
                    }
                    else self.val(content);
                    setTimeout(function () {
                        self._setSelectionStart(selection.start);
                    });
                });
            this.addHandler(this.numberInput, 'mousedown',
                function (event) {
                    return self._raiseEvent(2, event)
                });

            this._mousewheelfunc = this._mousewheelfunc || function (event) {
                if (!self.editcell) {
                    self.wheel(event, self);
                    return false;
                }
            };

            this.removeHandler(this.host, 'mousewheel', this._mousewheelfunc);
            this.addHandler(this.host, 'mousewheel', this._mousewheelfunc);
            var oldval = "";

            this.addHandler(this.numberInput, 'focus',
                function (event) {
                    $.data(self.numberInput, "selectionstart", self._selection().start);
                    self.host.addClass(self.toThemeProperty('jqx-fill-state-focus'));
                    if (self.spincontainer) {
                        self.spincontainer.addClass(self.toThemeProperty('jqx-numberinput-focus'));
                    }
                    oldval = self.numberInput.val();
                    self._savedValue = self.decimal;
                });

            this.addHandler(this.numberInput, 'blur',
                function (event) {
                    if (self.inputMode == 'simple') {
                        self._exitSimpleInputMode(event, self, false, oldval);
                    }
                    if (self.autoValidate) {
                        var val = parseFloat(self.decimal);
                        var isNegative = self.getvalue('negative');
                        if (isNegative && self.decimal > 0) {
                            val = -parseFloat(self.decimal);
                        }

                        if (val > self.max) {
                            self._disableSetSelection = true;
                            self.setDecimal(self.max);
                            self._disableSetSelection = false;
                        }
                        if (val < self.min) {
                            self._disableSetSelection = true;
                            self.setDecimal(self.min);
                            self._disableSetSelection = false;
                        }
                    }

                    self.host.removeClass(self.toThemeProperty('jqx-fill-state-focus'));
                    if (self.spincontainer) {
                        self.spincontainer.removeClass(self.toThemeProperty('jqx-numberinput-focus'));
                    }
                    if (self.numberInput.val() != oldval) {
                        self._raiseEvent(7, event);
                        $.jqx.aria(self, "aria-valuenow", self.decimal);
                        self.element.value = self.decimal;
                    }
                    return true;
                });

            this.addHandler(this.numberInput, 'mouseup',
                function (event) {
                    return self._raiseEvent(3, event)
                });

            this.addHandler(this.numberInput, 'keydown',
                function (event) {
                    self.changeType = "keyboard";

                    return self._raiseEvent(4, event)
                });

            this.addHandler(this.numberInput, 'keyup',
                function (event) {
                    return self._raiseEvent(5, event)
                });

            this.addHandler(this.numberInput, 'keypress',
                function (event) {
                    return self._raiseEvent(6, event)
                });
        },

        focus: function () {
            try {
                this.numberInput.focus();
            }
            catch (error) {
            }
        },

        blur: function () {
            try {
                this.numberInput.blur();
            }
            catch (error) {
            }
        },

        _removeHandlers: function () {
            var self = this;
            this.removeHandler(this.numberInput, 'mousedown');
            var isOperaMini = $.jqx.mobile.isOperaMiniMobileBrowser();
            if (isOperaMini) {
                this.removeHandler($(document), 'click.' + this.element.id, self._exitSimpleInputMode, self);
            }

            this.removeHandler(this.numberInput, 'paste');
            this.removeHandler(this.numberInput, 'focus');
            this.removeHandler(this.numberInput, 'blur');
            this.removeHandler(this.numberInput, 'mouseup');
            this.removeHandler(this.numberInput, 'keydown');
            this.removeHandler(this.numberInput, 'keyup');
            this.removeHandler(this.numberInput, 'keypress');
        },

        //[optimize]
        _spinButtons: function () {
            if (this.host.jqxRepeatButton) {
                if (!this.numberInput) {
                    this.numberInput = $("<input autocomplete='off' style='border: none; position: relative; float: left;' type='textarea'/>");
                    this.numberInput.appendTo(this.host);
                    this.numberInput.addClass(this.toThemeProperty('jqx-input-content'));
                    this.numberInput.addClass(this.toThemeProperty('jqx-widget-content'));
                }
                else {
                    this.numberInput.css('float', 'left');
                }

                if (this.spincontainer) {
                    if (this.upbutton) {
                        this.upbutton.jqxRepeatButton('destroy');
                    }
                    if (this.downbutton) {
                        this.downbutton.jqxRepeatButton('destroy');
                    }

                    this.spincontainer.remove();
                }

                this.spincontainer = $('<div style="float: right; height: 100%; overflow: hidden; position: relative;"></div>');
                if (this.rtl) {
                    this.spincontainer.css('float', 'right');
                    this.numberInput.css('float', 'right');
                    this.spincontainer.css('left', '-1px');
                }
                this.host.append(this.spincontainer);
                this.upbutton = $('<div style="overflow: hidden; padding: 0px; margin-left: -1px; position: relative;"><div></div></div>');
                this.spincontainer.append(this.upbutton);
                this.upbutton.jqxRepeatButton({ overrideTheme: true, disabled: this.disabled, roundedCorners: 'top-right' });
                this.downbutton = $('<div style="overflow: hidden; padding: 0px; margin-left: -1px; position: relative;"><div></div></div>');
                this.spincontainer.append(this.downbutton);
                this.downbutton.jqxRepeatButton({ overrideTheme: true, disabled: this.disabled, roundedCorners: 'bottom-right' });

                if (this.template) {
                    this.upbutton.addClass(this.toThemeProperty("jqx-" + this.template))
                    this.downbutton.addClass(this.toThemeProperty("jqx-" + this.template))
                }

                var me = this;

                this.downbutton.addClass(this.toThemeProperty('jqx-fill-state-normal jqx-action-button'));
                this.upbutton.addClass(this.toThemeProperty('jqx-fill-state-normal jqx-action-button'));
                this.upbutton.addClass(this.toThemeProperty('jqx-rc-tr'));
                this.downbutton.addClass(this.toThemeProperty('jqx-rc-br'));

                this.addHandler(this.downbutton, 'mouseup', function (event) {
                    if (!me.disabled) {
                        me.downbutton.removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                        me._downArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-down-selected'));
                    }
                });

                this.addHandler(this.upbutton, 'mouseup', function (event) {
                    if (!me.disabled) {
                        me.upbutton.removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                        me._upArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-up-selected'));
                    }
                });

                this.removeHandler($(document), 'mouseup.' + this.element.id);
                this.addHandler($(document), 'mouseup.' + this.element.id, function (event) {
                    me.upbutton.removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                    me._upArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-up-selected'));
                    me.downbutton.removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                    me._downArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-down-selected'));
                });

                this.addHandler(this.downbutton, 'mousedown', function (event) {
                    if (!me.disabled) {
                        if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                            me._inputSelection = me._selection();
                        }

                        me.downbutton.addClass(me.toThemeProperty('jqx-fill-state-pressed'));
                        me._downArrow.addClass(me.toThemeProperty('jqx-icon-arrow-down-selected'));
                        event.preventDefault();
                        event.stopPropagation();
                        return false;
                    }
                });

                this.addHandler(this.upbutton, 'mousedown', function (event) {
                    if (!me.disabled) {
                        if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                            me._inputSelection = me._selection();
                        }

                        me.upbutton.addClass(me.toThemeProperty('jqx-fill-state-pressed'));
                        me._upArrow.addClass(me.toThemeProperty('jqx-icon-arrow-up-selected'));
                        event.preventDefault();
                        event.stopPropagation();
                        return false;
                    }
                });

                this.addHandler(this.upbutton, 'mouseenter', function (event) {
                    me.upbutton.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                    me._upArrow.addClass(me.toThemeProperty('jqx-icon-arrow-up-hover'));
                });
                this.addHandler(this.upbutton, 'mouseleave', function (event) {
                    me.upbutton.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                    me._upArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-up-hover'));
                });

                this.addHandler(this.downbutton, 'mouseenter', function (event) {
                    me.downbutton.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                    me._downArrow.addClass(me.toThemeProperty('jqx-icon-arrow-down-hover'));
                });
                this.addHandler(this.downbutton, 'mouseleave', function (event) {
                    me.downbutton.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                    me._downArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-down-hover'));
                });

                this.upbutton.css('border-width', '0px');
                this.downbutton.css('border-width', '0px');

                if (this.disabled) {
                    this.upbutton[0].disabled = true;
                    this.downbutton[0].disabled = true;
                }
                else {
                    this.upbutton[0].disabled = false;
                    this.downbutton[0].disabled = false;
                }

                this.spincontainer.addClass(this.toThemeProperty('jqx-input'));
                this.spincontainer.addClass(this.toThemeProperty('jqx-rc-r'));
                this.spincontainer.css('border-width', '0px');
                if (!this.rtl) {
                    this.spincontainer.css('border-left-width', '1px');
                }
                else {
                    this.spincontainer.css('border-right-width', '1px');
                }

                this._upArrow = this.upbutton.find('div');
                this._downArrow = this.downbutton.find('div');

                this._upArrow.addClass(this.toThemeProperty('jqx-icon-arrow-up'));
                this._downArrow.addClass(this.toThemeProperty('jqx-icon-arrow-down'));
                this._upArrow.addClass(this.toThemeProperty('jqx-input-icon'));
                this._downArrow.addClass(this.toThemeProperty('jqx-input-icon'));
                var me = this;
                this._upArrow.hover(function () {
                    if (!me.disabled) {
                        me._upArrow.addClass(me.toThemeProperty('jqx-icon-arrow-up-hover'));
                    }
                }, function () {
                    me._upArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-up-hover'));
                });
                this._downArrow.hover(function () {
                    if (!me.disabled) {
                        me._downArrow.addClass(me.toThemeProperty('jqx-icon-arrow-down-hover'));
                    }
                }, function () {
                    me._downArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-down-hover'));
                });


                var isTouchDevice = $.jqx.mobile.isTouchDevice();
                var eventname = 'click';
                if (isTouchDevice) {
                    eventname = $.jqx.mobile.getTouchEventName('touchstart');
                }

                if (isTouchDevice) {
                    this.addHandler(this.downbutton, 'click', function (event) {
                        me.spinDown();
                    });
                    this.addHandler(this.upbutton, 'click', function (event) {
                        me.spinUp();
                    });
                }

                this.addHandler(this.downbutton, eventname, function (event) {
                    if (!isTouchDevice) {
                        if (me._selection().start == 0) {
                            me._setSelectionStart(me.numberInput.val().length);
                        }

                        if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                            me._setSelectionStart(me._inputSelection.start);
                        }
                    }
                    else {
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    me.spinDown();
                    return false;
                });
                this.addHandler(this.upbutton, eventname, function (event) {
                    if (!isTouchDevice) {
                        if (me._selection().start == 0) {
                            me._setSelectionStart(me.numberInput.val().length);
                        }
                        if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                            me._setSelectionStart(me._inputSelection.start);
                        }
                    }
                    else {
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    me.spinUp();
                    return false;
                });
            } else {
                throw new Error("jqxNumberInput: Missing reference to jqxbuttons.js.");
            }
        },

        spinDown: function () {
            var me = this;

            var oldDecimal = this.decimal;

            if (me.spinMode == 'none')
                return;

            if (this.decimal == null) {
                this.setDecimal(0);
                return;
            }

            var isNegative = this.getvalue('negative');
            var negativeOffset = isNegative ? -1 : 0;

            if ($.jqx.mobile.isTouchDevice() || this.inputMode == 'textbox') {
                me._doTouchHandling();
            }

            if (!me.disabled) {
                var selection = this._selection();
                var olddecimal = this.decimal;

                var decimal = this.getDecimal();
                if (decimal < this.min) {
                    decimal = this.min;
                    this.setDecimal(this.min);
                    this._setSelectionStart(selection.start);
                    this.spinDown();
                    return;
                }
                else if (decimal > this.max) {
                    decimal = this.max;
                    this.setDecimal(this.max);
                    this._setSelectionStart(selection.start);
                    this.spinDown();
                    return;
                }

                if (me.spinButtonsStep < 0) me.spinButtonsStep = 1;

                var dec = parseInt(me.decimal) - me.spinButtonsStep;
                dec = dec.toString().length;
                var validvalue = negativeOffset + dec <= me.digits + me.decimalDigits;

                if (me.spinMode != 'advanced' || me.decimalDigits === 0) {
                    if (decimal - me.spinButtonsStep >= me.min && validvalue) {
                        var multiple = 1;
                        for (i = 0; i < me.decimalDigits; i++) {
                            multiple = multiple * 10;
                        }

                        var newvalue = (multiple * decimal) - (multiple * me.spinButtonsStep);
                        newvalue = newvalue / multiple;
                        newvalue = this._parseDecimalValueToEditorValue(newvalue);
                        me.setDecimal(newvalue);
                    }
                }
                else {
                    var values = this._getspindecimal();
                    var separator = this._getSeparatorPosition();

                    var decimal = parseFloat(values.decimal);
                    if (me.spinButtonsStep < 0) me.spinButtonsStep = 1;

                    var dec = parseInt(decimal) - me.spinButtonsStep;
                    dec = dec.toString().length;
                    var validvalue = negativeOffset + dec <= me.digits;
                    var multiple = 1;

                    var separatorindex = values.decimal.indexOf(".");
                    if (separatorindex != -1) {
                        var divide = values.decimal.length - separatorindex - 1;
                        var multiple = 1;
                        for (var i = 0; i < divide; i++) {
                            multiple = multiple * 10;
                        }
                        decimal -= new Number(me.spinButtonsStep / multiple);
                        decimal = decimal.toFixed(divide);
                        var separatorindex = decimal.toString().indexOf(".");
                        if (separatorindex == -1) {
                            decimal = decimal.toString() + '.';
                        }
                        var result = decimal.toString() + values.afterdecimal;
                        result = new Number(result);
                        result = result.toFixed(me.decimalDigits);
                        if (result >= me.min) {
                            result = this._parseDecimalValueToEditorValue(result);
                            me.setDecimal(result);
                        }
                    }
                    else {
                        if (decimal - me.spinButtonsStep >= me.min && validvalue) {
                            var newvalue = (multiple * decimal) - (multiple * me.spinButtonsStep);
                            newvalue = newvalue / multiple;
                            var result = newvalue.toString() + values.afterdecimal;
                            if (result >= me.min) {
                                result = this._parseDecimalValueToEditorValue(result);
                                me.setDecimal(result);
                            }
                        }
                    }
                }

                if (result == undefined || this.inputMode != 'simple') {
                    var isNegative = this.getvalue('negative');
                    if (negativeOffset == 0 && isNegative) {
                        this._setSelectionStart(selection.start + 1);
                    }
                    else {
                        this._setSelectionStart(selection.start);
                    }

                    me.savedValue = me.numberInput[0].value;
                    if (oldDecimal != this.decimal) {
                        if ($.jqx.mobile.isTouchDevice()) {
                            this._raiseEvent(0, {});
                        }
                        this._raiseEvent(7, {});
                    }

                    $.jqx.aria(this, "aria-valuenow", this.decimal);
                    return;
                }

                result = this.decimal.toString();
                var isNegative = this.getvalue('negative');
                if (negativeOffset == 0 && isNegative) {
                    this._setSelectionStart(selection.start + 1);
                }
                else {
                    if ((result != undefined && (olddecimal == undefined || olddecimal.toString().length == result.length))) {
                        this._setSelectionStart(selection.start);
                    }
                    else {
                        if (isNegative) {
                            this._setSelectionStart(selection.start + 1);
                        }
                        else {
                            this._setSelectionStart(selection.start - 1);
                        }
                    }
                }
                if (oldDecimal != this.decimal) {
                    if ($.jqx.mobile.isTouchDevice()) {
                        this._raiseEvent(0, {});
                    }
                    this._raiseEvent(7, {});
                }
                $.jqx.aria(this, "aria-valuenow", this.decimal);
            }
        },

        _getspindecimal: function () {
            var selection = this._selection();
            var decimalString = "";
            var separatorPosition = this._getSeparatorPosition();
            var visibleItems = this._getVisibleItems();
            var prefix = this._getHiddenPrefixCount();
            var text = this.numberInput.val();

            if (this.numberInput.val().length == selection.start && selection.length == 0) {
                this._setSelection(selection.start, selection.start + 1);
                selection = this._selection();
            }

            var issimple = this.inputMode != 'advanced';
            var selectionStart = selection.start;

            if (selectionStart === 0) {
                selectionStart++;
            }

            if (selectionStart === 1 && this.symbolPosition === "left" && this.symbol !== "") {
                selectionStart += this.symbol.length;
            }

            for (var i = 0; i < selectionStart; i++) {
                if (issimple) {
                    var literal = text.substring(i, i + 1);
                    var isDigit = (!isNaN(parseInt(literal)));
                    if (isDigit) {
                        decimalString += literal;
                    }
                    if (literal == this.decimalSeparator) {
                        decimalString += literal;
                    }
                    continue;
                }

                if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                    decimalString += visibleItems[i].character;
                }
                else if (!visibleItems[i].canEdit && this.decimalSeparatorPosition != -1 && visibleItems[i] == visibleItems[this.decimalSeparatorPosition - prefix]) {
                    if (decimalString.length == 0) {
                        decimalString = "0";
                    }

                    decimalString += visibleItems[i].character;
                }

            }

            var afterdecimal = "";
            for (var i = selectionStart; i < visibleItems.length; i++) {
                if (issimple) {
                    var literal = text.substring(i, i + 1);
                    var isDigit = (!isNaN(parseInt(literal)));
                    if (isDigit) {
                        afterdecimal += literal;
                    }
                    if (literal == this.decimalSeparator) {
                        afterdecimal += literal;
                    }
                    continue;
                }

                if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                    afterdecimal += visibleItems[i].character;
                }
                else if (!visibleItems[i].canEdit && this.decimalSeparatorPosition != -1 && visibleItems[i] == visibleItems[this.decimalSeparatorPosition - prefix]) {
                    afterdecimal += visibleItems[i].character;
                }
            }
            var isNegative = this.getvalue('negative');
            var d = isNegative ? "-" + this._parseDecimalValue(decimalString).toString() : this._parseDecimalValue(decimalString).toString();
            return { decimal: d, afterdecimal: this._parseDecimalValue(afterdecimal) };
        },

        _parseDecimalValue: function (number) {
            if (this.decimalSeparator != '.') {
                var start = number.toString().indexOf(this.decimalSeparator);
                if (start >= 0) {
                    var result = number.toString().substring(0, start) + '.' + number.toString().substring(start + 1);
                    return result;
                }
            }
            return number;
        },

        _parseDecimalValueToEditorValue: function (number) {
            if (this.decimalSeparator != '.') {
                var start = number.toString().indexOf(".");
                if (start >= 0) {
                    var result = number.toString().substring(0, start) + this.decimalSeparator + number.toString().substring(start + 1);
                    return result;
                }
            }
            return number;
        },

        spinUp: function () {
            var me = this;
            var oldDecimal = this.decimal;
            if (me.spinMode == 'none')
                return;

            if (this.decimal == null) {
                this.setDecimal(0);
                return;
            }

            if ($.jqx.mobile.isTouchDevice() || this.inputMode == 'textbox') {
                me._doTouchHandling();
            }

            var isNegative = this.getvalue('negative');
            var negativeOffset = isNegative ? -1 : 0;

            if (!me.disabled) {
                var selection = this._selection();
                var olddecimal = me.decimal;
                var decimal = me.getDecimal();
                if (decimal < this.min) {
                    decimal = this.min;
                    this.setDecimal(this.min);
                    this._setSelectionStart(selection.start);
                    this.spinUp();
                    return;
                }
                else if (decimal > this.max) {
                    decimal = this.max;
                    this.setDecimal(this.max);
                    this._setSelectionStart(selection.start);
                    this.spinUp();
                    return;
                }
                if (me.spinButtonsStep < 0) me.spinButtonsStep = 1;

                var dec = parseInt(me.decimal) + me.spinButtonsStep;
                dec = dec.toString().length;
                var validvalue = negativeOffset + dec <= me.digits + me.decimalDigits;

                if (me.spinMode != 'advanced' || me.decimalDigits === 0) {
                    if (decimal + me.spinButtonsStep <= me.max && validvalue) {
                        var multiple = 1;
                        for (var i = 0; i < me.decimalDigits; i++) {
                            multiple = multiple * 10;
                        }

                        var newvalue = (multiple * decimal) + (multiple * me.spinButtonsStep);
                        newvalue = newvalue / multiple;
                        newvalue = this._parseDecimalValueToEditorValue(newvalue);
                        me.setDecimal(newvalue);
                    }
                }
                else {
                    var values = this._getspindecimal();
                    var separator = this._getSeparatorPosition();

                    var decimal = parseFloat(values.decimal);
                    if (me.spinButtonsStep < 0) me.spinButtonsStep = 1;

                    var dec = parseInt(decimal) + me.spinButtonsStep;
                    dec = dec.toString().length;
                    var validvalue = negativeOffset + dec <= me.digits;
                    var multiple = 1;

                    var separatorindex = values.decimal.indexOf(".");
                    if (separatorindex != -1) {
                        var divide = values.decimal.length - separatorindex - 1;
                        var multiple = 1;
                        for (var i = 0; i < divide; i++) {
                            multiple = multiple * 10;
                        }
                        decimal += new Number(me.spinButtonsStep / multiple);
                        decimal = decimal.toFixed(divide);
                        var separatorindex = decimal.toString().indexOf(".");
                        if (separatorindex == -1) {
                            decimal = decimal.toString() + '.';
                        }
                        var result = decimal.toString() + values.afterdecimal;
                        result = new Number(result);
                        result = result.toFixed(me.decimalDigits);
                        var number = new Number(result).toFixed(me.decimalDigits);

                        if (number <= me.max) {
                            result = this._parseDecimalValueToEditorValue(result);
                            me.setDecimal(result);
                        }
                        else result = undefined;
                    }
                    else {
                        if (decimal + me.spinButtonsStep <= me.max && validvalue) {
                            var newvalue = (multiple * decimal) + (multiple * me.spinButtonsStep);

                            newvalue = newvalue / multiple;
                            var result = newvalue.toString() + values.afterdecimal;
                            var number = new Number(result).toFixed(me.decimalDigits);
                            if (number <= me.max) {
                                result = this._parseDecimalValueToEditorValue(result);
                                if (isNegative && result.indexOf('-') == -1) {
                                    if (values.decimal != '-0') {
                                        result = '-' + result;
                                    }
                                }
                                me.setDecimal(result);
                            }
                            else {
                                result = undefined;
                            }
                        }
                    }
                }

                if (result == undefined || this.inputMode != 'simple') {
                    this._setSelectionStart(selection.start);
                    me.savedValue = me.numberInput[0].value;
                    if (oldDecimal != this.decimal) {
                        if ($.jqx.mobile.isTouchDevice()) {
                            this._raiseEvent(0, {});
                        }
                        this._raiseEvent(7, {});
                    }
                    $.jqx.aria(this, "aria-valuenow", this.decimal);
                    return;
                }

                result = this.decimal.toString();
                var isNegative = this.getvalue('negative');
                if (negativeOffset == -1 && !isNegative) {
                    this._setSelectionStart(-1 + selection.start);
                }
                else {
                    if ((result != undefined && (olddecimal == undefined || olddecimal.toString().length == result.length))) {
                        this._setSelectionStart(selection.start);
                    }
                    else {
                        if (isNegative) {
                            this._setSelectionStart(selection.start);
                        }
                        else {
                            this._setSelectionStart(1 + selection.start);
                        }
                    }
                }
                if (oldDecimal != this.decimal) {
                    if ($.jqx.mobile.isTouchDevice()) {
                        this._raiseEvent(0, {});
                    }
                    this._raiseEvent(7, {});
                }
                $.jqx.aria(this, "aria-valuenow", this.decimal);
            }
        },

        _exitSimpleInputMode: function (event, self, checkbounds, oldvalue) {
            if (self == undefined) {
                self = event.data;
            }

            if (self == null) return;

            if (checkbounds == undefined) {
                if (event.target != null && self.element != null) {
                    if ((event.target.id != undefined && event.target.id.toString().length > 0 && self.host.find('#' + event.target.id).length > 0) || event.target == self.element) {
                        return;
                    }
                }

                var offset = self.host.offset();
                var left = offset.left;
                var top = offset.top;
                var width = self.host.width();
                var height = self.host.height();

                var targetOffset = $(event.target).offset();
                if (targetOffset.left >= left && targetOffset.left <= left + width)
                    if (targetOffset.top >= top && targetOffset.top <= top + height) {
                        return;
                    }
            }

            if ($.jqx.mobile.isOperaMiniBrowser()) {
                self.numberInput.attr("readonly", true);
            }

            if (self.disabled || self.readOnly)
                return;

            var enteredMode = $.data(self.numberInput, "simpleInputMode");
            if (enteredMode == null) return;

            $.data(self.numberInput, "simpleInputMode", null);
            this._parseDecimalInSimpleMode();
            return false;
        },

        _getDecimalInSimpleMode: function () {
            var val = this.decimal;
            if (this.decimalSeparator != '.') {
                var indx = val.toString().indexOf(this.decimalSeparator);
                if (indx > 0) {
                    var prefix = val.toString().substring(0, indx);
                    var val = prefix + "." + val.toString().substring(indx + 1);
                }
            }
            return val;
        },

        _parseDecimalInSimpleMode: function (refreshValue) {
            var self = this;
            var isNegative = self.getvalue('negative');
            var decimal = this.ValueString;
            if (decimal == undefined) {
                decimal = this.GetValueString(this.numberInput.val(), this.decimalSeparator, this.decimalSeparator != "");
            }
            if (this.decimalSeparator != '.') {
                var indx = decimal.toString().indexOf(".");
                if (indx > 0) {
                    var prefix = decimal.toString().substring(0, indx);
                    var val = prefix + this.decimalSeparator + decimal.toString().substring(indx + 1);
                    decimal = val;
                }
            }

            var string = isNegative ? "-" : '';
            if (this.symbolPosition == 'left') {
                string += this.symbol;
            }
            var leadingDigitsCount = this.digits % this.groupSize;
            if (leadingDigitsCount == 0) {
                leadingDigitsCount = this.groupSize;
            }

            var decimalString = decimal.toString();
            if (decimalString.indexOf('-') >= 0) {
                decimalString = decimalString.substring(decimalString.indexOf('-') + 1);
            }

            string += decimalString;

            if (this.symbolPosition == 'right') {
                string += this.symbol;
            }

            if (refreshValue != false) {
                self.numberInput.val(string);
            }
        },

        //[optimize]
        _enterSimpleInputMode: function (event, self) {
            if (self == undefined) {
                self = event.data;
            }

            var selection = this._selection();

            if (self == null) return;
            var isNegative = self.getvalue('negative');

            var decimal = self.decimal;
            if (isNegative) {
                if (decimal > 0)
                    decimal = -decimal;
            }

            self.numberInput.val(decimal);
            $.data(self.numberInput, "simpleInputMode", true);

            if ($.jqx.mobile.isOperaMiniBrowser()) {
                self.numberInput.attr("readonly", false);
            }
            this._parseDecimalInSimpleMode();
            this._setSelectionStart(selection.start);
        },

        setvalue: function (name, value) {
            if (this[name] !== undefined) {
                if (name == 'decimal') {
                    this._setDecimal(value);
                }
                else {
                    this[name] = value;
                    this.propertyChangedHandler(this, name, value, value);
                }
            }
        },

        getvalue: function (name) {
            if (name == 'decimal') {
                if (this.negative != undefined && this.negative == true) {
                    if (this.decimal.toString().indexOf(',')) {
                        return -Math.abs(this.decimal.toString().replace(/,/, '.'));
                    }

                    return -Math.abs(this[name]);
                }
            }

            if (name in this) {
                return this[name]
            }

            return null;
        },

        // gets the intput's value.
        _getString: function () {
            var s = "";
            for (var i = 0; i < this.items.length; i++) {
                var character = this.items[i].character;
                s += character;
            }

            return s;
        },

        //[optimize]
        _literal: function (letter, regExpression, editable, separator) {
            return { character: letter, regex: regExpression, canEdit: editable, isSeparator: separator };
        },

        //[optimize]
        _initializeLiterals: function () {
            if (this.inputMode == 'textbox') return;
            // add the negative symbol.
            var index = 0;
            var negativeSymbolLength = this.negativeSymbol.length;
            for (var i = 0; i < negativeSymbolLength; i++) {
                var character = this.negativeSymbol.substring(i, i + 1);
                var regex = "";
                var canEdit = false;
                var literal = null;
                if (this.negative) {
                    literal = this._literal(character, regex, canEdit, false);
                }
                else {
                    literal = this._literal('', regex, canEdit, false);
                }

                this.items[index] = literal;
                index++;
            }

            // add the currency or percentage symbol.
            var symbolLength = this.symbol.length;
            if (this.symbolPosition == 'left') {
                for (i = 0; i < symbolLength; i++) {
                    var character = this.symbol.substring(i, i + 1);
                    var regex = "";
                    var canEdit = false;
                    var literal = this._literal(character, regex, canEdit, false);
                    this.items[index] = literal;
                    index++;
                }
            }

            var leadingDigitsCount = this.digits % this.groupSize;
            if (leadingDigitsCount == 0) {
                leadingDigitsCount = this.groupSize;
            }

            // add the digits and group separators.
            for (var i = 0; i < this.digits; i++) {
                var character = this.promptChar;
                var regex = "\\d";
                var canEdit = true;

                var literal = this._literal(character, regex, canEdit, false);
                this.items[index] = literal;
                index++;

                if (i < this.digits - 1 && this.groupSeparator != undefined && this.groupSeparator.length > 0) {
                    leadingDigitsCount--;
                    if (leadingDigitsCount == 0) {
                        leadingDigitsCount = this.groupSize;
                        var separatorLiteral = this._literal(this.groupSeparator, "", false, false);
                        this.items[index] = separatorLiteral;
                        index++;
                    }
                }
                else if (i == this.digits - 1) {
                    literal.character = 0;
                }
            }
            this.decimalSeparatorPosition = -1;

            // add the digits decimal separator and the decimal digits.
            if (this.decimalDigits != undefined && this.decimalDigits > 0) {
                var character = this.decimalSeparator;
                if (character.length == 0) {
                    character = ".";
                }

                var literal = this._literal(character, "", false, true);
                this.items[index] = literal;
                this.decimalSeparatorPosition = index;
                index++;

                for (var i = 0; i < this.decimalDigits; i++) {
                    var decimalCharacter = 0;
                    var regex = "\\d";
                    var decimalDigit = this._literal(decimalCharacter, regex, true, false);
                    this.items[index] = decimalDigit;
                    index++;
                }
            }

            // add the currency or percentage symbol.
            if (this.symbolPosition == 'right') {
                for (var i = 0; i < symbolLength; i++) {
                    var character = this.symbol.substring(i, i + 1);
                    var regex = "";
                    var canEdit = false;
                    var literal = this._literal(character, regex, canEdit);
                    this.items[index] = literal;
                    index++;
                }
            }
        },

        //[optimize]
        _match: function (character, regex) {
            var regExpr = new RegExp(regex, "i");
            return regExpr.test(character);
        },

        //[optimize]
        _raiseEvent: function (id, arg) {
            var evt = this.events[id];
            var args = {};
            args.owner = this;
            if (this.host.css('display') == 'none') {
                return true;
            }

            var key = arg.charCode ? arg.charCode : arg.keyCode ? arg.keyCode : 0;
            var result = true;
            var isreadOnly = this.readOnly;
            var me = this;

            if (id == 3 || id == 2) {
                if (!this.disabled) {
                    if (this.inputMode != 'simple' && this.inputMode != 'textbox') {
                        this._handleMouse(arg);
                    }
                    else {
                        //       this._enterSimpleInputMode(null, me);
                        return true;
                    }
                }
            }

            if (id == 0) {
                var decimalValue = this.getvalue('decimal');
                if ((this.max < decimalValue) || (this.min > decimalValue)) {
                    this.host.addClass(this.toThemeProperty("jqx-input-invalid"));
                }
                else {
                    this.host.removeClass(this.toThemeProperty("jqx-input-invalid"));
                    this.host.addClass(this.toThemeProperty("jqx-input"));
                    this.host.addClass(this.toThemeProperty("jqx-rc-all"));
                }
            }

            var event = new $.Event(evt);
            event.owner = this;
            args.value = this.getvalue('decimal');
            args.text = this.numberInput.val();

            event.args = args;
            if (id == 7) {
                args.type = this.changeType;
                this.changeType = null;
            }
            if (evt != undefined) {
                if (id != 4 && id != 5 && id != 6) {
                    result = this.host.trigger(event);
                }
            }
            var me = this;
            // key down
            if (this.inputMode == 'textbox')
                return result;

            if (this.inputMode != 'simple') {
                if (id == 4) {
                    if (isreadOnly || this.disabled) {
                        return false;
                    }

                    result = me._handleKeyDown(arg, key);
                }
                // key up
                else if (id == 5) {
                    if (isreadOnly || this.disabled) {
                        result = false;
                    }
                }
                else if (id == 6) {
                    if (isreadOnly || this.disabled) {
                        return false;
                    }
                    result = me._handleKeyPress(arg, key);
                }
            }
            else {
                if (id == 4 || id == 5 || id == 6) {
                    if ($.jqx.mobile.isTouchDevice() || this.touchMode === true) {
                        return true;
                    }

                    if (isreadOnly || this.disabled) {
                        return false;
                    }

                    var letter = String.fromCharCode(key);
                    var digit = parseInt(letter);
                    var allowInput = true;
                    if (!arg.ctrlKey && !arg.shiftKey && !arg.metaKey) {
                        if (key >= 65 && key <= 90) {
                            allowInput = false;
                        }
                    }

                    if (id == 6 && $.jqx.browser.opera != undefined) {
                        if (key == 8)
                            return false;
                    }
                    if (allowInput) {
                        if (id == 4) {
                            allowInput = me._handleSimpleKeyDown(arg, key);
                        }

                        if (key == 107) {
                            var isNegative = me.getvalue('negative');

                            if (isNegative) {
                                me.setvalue('negative', false);
                                me.decimal = me.ValueString;
                                me._parseDecimalInSimpleMode();
                                me._setSelectionStart(selection.start + 1);
                                me._raiseEvent(0, me.value);
                                me._raiseEvent(1, me.numberInput.val());
                            }
                        }

                        if (key == 189 || key == 45 || key == 109 || key == 173) {
                            var selection = me._selection();
                            if (id == 4) {
                                var isNegative = me.getvalue('negative');
                                if (isNegative == false) {
                                    me.setvalue('negative', true);
                                }
                                else {
                                    me.setvalue('negative', false);
                                }
                                me.decimal = me.ValueString;
                                me._parseDecimalInSimpleMode();
                                if (!isNegative) {
                                    me._setSelectionStart(selection.start + 1);
                                }
                                else {
                                    me._setSelectionStart(selection.start - 1);
                                }
                                allowInput = false;
                                me._raiseEvent(0, me.value);
                                me._raiseEvent(1, me.numberInput.val());
                            }
                        }

                        var ctrlKey = args.ctrlKey || args.metaKey;
                        if (!$.jqx.browser.msie) {
                            var e = arg;
                            if ((ctrlKey && key == 99 /* firefox */) || (ctrlKey && key == 67) /* opera */ ||
                                (ctrlKey && key == 122 /* firefox */) || (ctrlKey && key == 90) /* opera */ ||
                                (ctrlKey && key == 118 /* firefox */) || (ctrlKey && key == 86) /* opera */ || (e.shiftKey && key == 45)) {
                                if ($.jqx.browser.webkit || $.jqx.browser.chrome) {
                                    me._handleSimpleKeyDown(arg, key);
                                }
                                if (key == 67)
                                    return true;
                                return false;
                            }
                        }

                        if ((ctrlKey && key == 97 /* firefox */) || (ctrlKey && key == 65) /* opera */) {
                            return true;
                        }

                        if (id == 6 && allowInput) {
                            var specialKey = this._isSpecialKey(key);
                            return specialKey;
                        }
                    }

                    return allowInput;
                }
            }

            return result;
        },

        GetSelectionInValue: function (selectionPosition, text, separator, hasSeparator) {
            var selectionInValue = 0;

            for (var i = 0; i < text.length; i++) {
                if (i >= selectionPosition)
                    break;

                var literal = text.substring(i, i + 1);
                var isDigit = (!isNaN(parseInt(literal)));

                if (isDigit || (hasSeparator && text.substring(i, i + 1) == separator)) {
                    selectionInValue++;
                }
            }

            return selectionInValue;
        },

        GetSelectionLengthInValue: function (selectionPosition, selectionLength, text, separator) {
            var selectionInValue = 0;

            for (var i = 0; i < text.length; i++) {
                if (i >= selectionPosition + selectionLength)
                    break;

                var literal = text.substring(i, i + 1);
                var isDigit = (!isNaN(parseInt(literal)));

                if (selectionLength > 0 && i >= selectionPosition && isDigit || (i >= selectionPosition && text[i].toString() == separator)) {
                    selectionInValue++;
                }
            }

            return selectionInValue;
        },

        GetInsertTypeByPositionInValue: function (positionInValue, separator, text, hasSeparator) {
            var insertType = "before";
            var valueString = this.GetValueString(text, separator, hasSeparator);
            var digitsToSeparator = this.GetDigitsToSeparator(0, valueString, separator);

            if (positionInValue > digitsToSeparator) {
                insertType = 'after';
            }

            return insertType;
        },

        RemoveRange: function (start, length, text, separatorChar, updateText, insert) {
            var decimalPossibleChars = this.digits;
            var selectionStart = start;
            var selectionLength = length;
            var removedDigits = 0;
            var value = this.decimal;
            var selection = this._selection();
            //   var text = this.numberInput.val();
            var separatorChar = this.decimalSeparator;
            var hasSeparator = separatorChar != '';

            if (selectionLength == 0 && this.ValueString.length < this.decimalPossibleChars - 1)
                return removedDigits;

            var separatorPosition = this.GetSeparatorPositionInText(separatorChar, text);

            if (!updateText) {
                separatorPosition = this.GetSeparatorPositionInText(separatorChar, text);
            }

            if (separatorPosition < 0 && !hasSeparator && text.length > 1) {
                separatorPosition = text.length;
            }

            if (separatorPosition == -1)
                separatorPosition = text.length;

            var separatorOffset = hasSeparator ? 1 : 0;

            if (length < 2 && insert == true) {
                var valueDigits = this.ValueString.length - this.decimalDigits - separatorOffset;
                if ((valueDigits) == decimalPossibleChars && start + length < separatorPosition) {
                    selectionLength++;
                }
            }


            var newTextString = "";
            for (var i = 0; i < text.length; i++) {
                if (i < selectionStart || i >= selectionStart + selectionLength) {
                    newTextString += text.substring(i, i + 1);
                    continue;
                }
                else {
                    var literal = text.substring(i, i + 1);
                    if (literal == separatorChar) {
                        newTextString += separatorChar;
                        continue;
                    }
                    else {
                        var literal = text.substring(i, i + 1);
                        if (this.symbol && this.symbol != "" && this.symbol.indexOf(literal) >= 0)
                            continue;

                        if (i > separatorPosition) {
                            newTextString += "0";
                            continue;
                        }
                    }
                }

                var literal = text.substring(i, i + 1);
                var isDigit = (!isNaN(parseInt(literal)));

                if (isDigit) {
                    removedDigits++;
                }
            }

            if (newTextString.length == 0) {
                newTextString = "0";
            }

            if (updateText) {
                this.numberInput.val(newTextString);
            }
            else {
                this.ValueString = newTextString;
            }

            var ch = newTextString.substring(0, 1);
            if (ch == separatorChar && isNaN(parseInt(ch))) {
                var res = '0' + newTextString;
                newTextString = res;
            }

            this.ValueString = this.GetValueString(newTextString, separatorChar, hasSeparator);

            this.decimal = this.ValueString;
            this._parseDecimalInSimpleMode();

            this._setSelectionStart(selectionStart);
            return removedDigits;
        },

        InsertDigit: function (digit, position) {
            if (typeof this.digits != 'number') {
                this.digits = parseInt(this.digits);
            }

            if (typeof this.decimalDigits != 'number') {
                this.decimalDigits = parseInt(this.decimalDigits);
            }

            var decimalPossibleChars = 1 + this.digits;

            var selection = this._selection();
            var isNegative = this.getvalue('negative');
            var increased = false;

            if (selection.start == 0 && this.symbol != '' && this.symbolPosition == 'left') {
                this._setSelectionStart(selection.start + 1);
                selection = this._selection();
                increased = true;
            }

            if ((isNegative && increased) || (isNegative && !increased && selection.start == 0)) {
                this._setSelectionStart(selection.start + 1);
                selection = this._selection();
            }

            var selectionChar = this.numberInput.val().substring(selection.start, selection.start + 1);
            var text = this.numberInput.val();
            var separatorChar = this.decimalSeparator;
            var hasSeparator = separatorChar != '' && this.decimalDigits > 0;

            if (selectionChar == this.symbol && this.symbolPosition == 'right') {
                if (this.decimalDigits == 0) {
                    this.ValueString = this.GetValueString(text, separatorChar, hasSeparator);
                    if (this.ValueString.length >= decimalPossibleChars)
                        return;
                }
                else {
                    return;
                }
            }

            this.ValueString = this.GetValueString(text, separatorChar, hasSeparator);
            if (this.ValueString == "") {
                this.ValueString = new Number(0).toFixed(this.decimalDigits);
            }

            var value = this.ValueString;

            if (this.decimalDigits > 0 && position >= value.length) {
                position = value.length - 1;
            }

            var valueChar = '';
            if (position < value.length) {
                valueChar = value.substring(position, position + 1);
            }

            var shouldReplace = false;
            var decrementedPosition = false;

            var type = this.GetInsertTypeByPositionInValue(position, separatorChar, text, hasSeparator);

            if (type == 'after') {
                shouldReplace = true;
            }

            var separatorOffset = hasSeparator ? 1 : 0;

            if (valueChar != separatorChar && (this.ValueString.length - this.decimalDigits - separatorOffset) >= decimalPossibleChars - 1) {
                shouldReplace = true;
            }
            if (valueChar === "0" && this.ValueString.length === 1 && this.decimalDigits === 0) {
                shouldReplace = true;
            }

            var isdecimal = false;

            var separatoroffset = hasSeparator ? 1 : 0;

            if (!shouldReplace && this.ValueString && this.ValueString.length >= this.digits + this.decimalDigits + separatoroffset) {
                return;
            }

            if (shouldReplace && valueChar != separatorChar) {
                if (isdecimal)
                    position++;

                var before = value.substring(0, position);
                if (before.length == value.length) {
                    if (this.ValueString.length >= this.digits + this.decimalDigits + separatoroffset)
                        return;
                }

                var current = digit;
                var after = "";

                if (position + 1 < value.length) {
                    after = value.substring(position + 1);
                }

                var result = before + current + after;
                this.ValueString = result;
            }
            else {
                var before = value.substring(0, position);
                var current = digit;
                var after = value.substring(position);
                var result = before + current + after;

                if (value.substring(0, 1) == '0' && value.substring(1, 2) == separatorChar) {
                    result = current + value.substring(1);
                    if (valueChar == separatorChar) {
                        this._setSelectionStart(selection.start - 1);
                        selection = this._selection();
                    }
                }
                this.ValueString = result;
            }

            if (isNegative) {
                this.decimal = "-" + this.ValueString;
            }
            else this.decimal = this.ValueString;

            this._parseDecimalInSimpleMode();
            var start = selection.start;
            start += 1;

            this._setSelectionStart(start);

            this.value = this.decimal;

            this._raiseEvent(0, this.value);
            this._raiseEvent(1, this.numberInput.val());
        },

        GetStringToSeparator: function (text, separator, hasSeparator) {
            var res = "";
            var pointSeparator = separator;
            var separatorInText = this.GetSeparatorPositionInText(separator, text);
            var newString = text.subString(0, separatorInText);
            res = this.GetValueString(newString, separator, hasSeparator);

            return res;
        },

        GetSeparatorPositionInText: function (separator, text) {
            var decimalPointPos = -1;

            for (var i = 0; i < text.length; i++) {
                if (text.substring(i, i + 1) == separator) {
                    decimalPointPos = i;
                    break;
                }
            }
            return decimalPointPos;
        },

        GetValueString: function (text, separator, hasSeparator) {
            var res = "";

            for (var i = 0; i < text.length; i++) {
                var literal = text.substring(i, i + 1);
                var isDigit = (!isNaN(parseInt(literal)));
                if (isDigit) {
                    res += literal;
                }
                if (literal == separator) {
                    res += separator;
                }
            }

            return res;
        },

        Backspace: function () {
            var selection = this._selection();
            var initialselection = this._selection();
            var text = this.numberInput.val();

            if (selection.start == 0 && selection.length == 0)
                return;

            this.isBackSpace = true;

            var literal = text.substring[selection.start, selection.start + 1];
            var isDigit = (!isNaN(parseInt(literal)));
            if (selection.start > 0 && selection.length == 0) {
                this._setSelectionStart(selection.start - 1);
                var selection = this._selection();
            }

            this.Delete();
            this._setSelectionStart(initialselection.start - 1);
            this.isBackSpace = false;
        },

        Delete: function (deleteWithoutSelection) {
            var selection = this._selection();
            var text = this.numberInput.val();
            if (selection.start === 0 && text.substring(0, 1) == "-") {
                this.setvalue('negative', false);
                var selection = this._selection();
                var text = this.numberInput.val();
            }

            var selectionStart = selection.start;

            if (selection.start > 0 && text.substring(0, 1) == "-") {
                selectionStart--;
                selection.start = selectionStart;
            }

            var selectionLength = selection.length;
            selectionLength = Math.max(selectionLength, 1);

            this.ValueString = this.GetValueString(text, this.decimalSeparator, this.decimalSeparator != '');
            if (selectionStart > this.ValueString.indexOf(this.decimalSeparator) && this.decimalDigits > 0) {
                selectionStart++;
            }
            var offset = 0;
            if (this.symbol) {
                if (this.symbolPosition == "left") {
                    offset--;
                }
                if (this.negative)
                    offset--;
            }
            this.RemoveRange(selection.start + offset, selectionLength, this.ValueString, ".", false);
            var literal = this.ValueString.substring(0, 1);
            var isDigit = (!isNaN(parseInt(literal)));
            if (!isDigit) {
                this.ValueString = '0' + this.ValueString;
            }
            this.decimal = this.ValueString;
            this._parseDecimalInSimpleMode();
            this._setSelectionStart(selectionStart);
            this.value = this.decimal;
            this._raiseEvent(0, this.value);
            this._raiseEvent(1, this.numberInput.val());
        },

        insertsimple: function (insertion) {
            var selection = this._selection();
            var text = this.numberInput.val();

            if (selection.start == text.length && this.decimal != null && this.decimalDigits > 0)
                return;

            var oldValue = this.decimal;

            var separatorChar = this.decimalSeparator;
            this.ValueString = this.GetValueString(text, separatorChar, separatorChar != '');

            var positionInValue = this.GetSelectionInValue(selection.start, text, separatorChar, separatorChar != '');
            var lengthInValue = this.GetSelectionLengthInValue(selection.start, selection.length, text, separatorChar);

            var digitsToSeparator = this.GetDigitsToSeparator(0, this.ValueString, separatorChar);
            var decrementPositionInValue = false;

            if (this.decimalDigits > 0 && positionInValue >= this.ValueString.length) {
                positionInValue--;
            }

            if (this.ValueString == "") {
                this.ValueString = new Number(0).toFixed(this.decimalDigits);
                this.ValueString = this.ValueString.replace(".", separatorChar);
                this.RemoveRange(selection.start, lengthInValue, this.ValueString, separatorChar, false, true);
                this.InsertDigit(insertion, 0, selection);
                return;
            }

            this.RemoveRange(selection.start, lengthInValue, this.ValueString, separatorChar, false, true);
            this.InsertDigit(insertion, positionInValue, selection);
        },

        GetDigitsToSeparator: function (digitsToSeparator, valueString, separator) {
            if (separator == undefined) separator = '.';

            if (valueString.indexOf(separator) < 0) {
                return valueString.length;
            }

            for (var i = 0; i < valueString.length; i++) {
                if (valueString.substring(i, i + 1) == separator) {
                    digitsToSeparator = i;
                    break;
                }
            }
            return digitsToSeparator;
        },

        _handleSimpleKeyDown: function (e, key) {
            var selection = this._selection();
            var ctrlKey = e.ctrlKey || e.metaKey;

            if ((key == 8 || key == 46) && ctrlKey) {
                this.setDecimal(null);
                return false;
            }

            if (selection.start >= 0 && selection.start < this.items.length) {
                var letter = String.fromCharCode(key);
            }

            if (key === 27) {
                this.setDecimal(this._savedValue);
                var position = this.GetSeparatorPositionInText(this.decimalSeparator, this.numberInput.val());
                if (position != -1) {
                    this._setSelectionStart(position);
                }

                e.preventDefault();
            }

            if (this.rtl && key == 37) {
                var shift = e.shiftKey;
                var offset = shift ? 1 : 0;
                if (shift) {
                    this._setSelection(selection.start + 1 - offset, selection.start + selection.length + 1);
                }
                else {
                    this._setSelection(selection.start + 1 - offset, selection.start + 1);
                }

                return false;
            }
            else if (this.rtl && key == 39) {
                var shift = e.shiftKey;
                var offset = shift ? 1 : 0;
                if (shift) {
                    this._setSelection(selection.start - 1, selection.length + offset + selection.start - 1);
                }
                else {
                    this._setSelection(selection.start - 1, selection.start - 1);
                }
                return false;
            }

            // handle backspace.
            if (key == 8) {
                this.Backspace();
                return false;
            }

            if (key == 190 || key == 110) {
                var position = this.GetSeparatorPositionInText(this.decimalSeparator, this.numberInput.val());
                if (position != -1) {
                    this._setSelectionStart(position + 1);
                }
                return false;
            }

            if (key == 188 && this.groupSeparator === ',') {
                var value = this.numberInput.val();
                for (i = selection.start; i < value.length; i++) {
                    if (value[i] == this.groupSeparator) {
                        this._setSelectionStart(1 + i);
                        break;
                    }
                }

                return false;
            }

            // allow Ctrl+C (copy)
            var ctrlKey = e.ctrlKey || e.metaKey;
            if ((ctrlKey && key == 99 /* firefox */) || (ctrlKey && key == 67) /* opera */) {
                var selection = this._selection();
                var text = "";
                var input = this.numberInput.val();
                if (selection.start > 0 || selection.length > 0) {
                    for (var i = selection.start; i < selection.end; i++) {
                        text += input.substring(i, i + 1);
                    }
                }
                $.data(document.body, "jqxSelection", text);
                if ($.jqx.browser.msie) {
                    window.clipboardData.setData("Text", text);
                }
                else {
                    var me = this;
                    var copyFrom = $('<textarea style="position: absolute; left: -1000px; top: -1000px;"/>');
                    copyFrom.val(text);
                    $('body').append(copyFrom);
                    copyFrom.select();
                    setTimeout(function () {
                        document.designMode = 'off';
                        copyFrom.select();
                        copyFrom.remove();
                        me.focus();
                    }, 100);
                }
                this.savedText = text;
                return true;
            }
            // allow Ctrl+Z (undo)
            if ((ctrlKey && key == 122 /* firefox */) || (ctrlKey && key == 90) /* opera */) return false;
            // allow or deny Ctrl+V (paste), Shift+Ins
            if ((ctrlKey && key == 118 /* firefox */) || (ctrlKey && key == 86) /* opera */
                || (e.shiftKey && key == 45)) {
                if ($.jqx.browser.msie && !this.savedText) {
                    this.savedText = window.clipboardData.getData("Text");
                }
                if (this.savedText != null && this.savedText.length > 0) {
                    this.val(this.savedText);
                    //for (var i = 0; i < this.savedText.length; i++) {
                    //    var digit = parseInt(this.savedText.substring(i, i + 1));
                    //    if (!isNaN(digit)) {
                    //        this.insertsimple(digit);
                    //    }
                    //}
                }
                else {
                    this.val($.data(document.body, "jqxSelection"));
                }
                return false;
            }

            var letter = String.fromCharCode(key);
            var digit = parseInt(letter);
            if (key >= 96 && key <= 105) {
                digit = key - 96;
                key = key - 48;
            }

            if (!isNaN(digit)) {
                var me = this;
                this.insertsimple(digit);

                return false;
            }


            // handle del.
            if (key == 46) {
                this.Delete();
                return false;
            }

            if (key == 38) {
                this.spinUp();
                return false;
            }
            else if (key == 40) {
                this.spinDown();
                return false;
            }

            var specialKey = this._isSpecialKey(key);

            if (!$.jqx.browser.mozilla)
                return true;

            return specialKey;
        },

        //[optimize]
        _getEditRange: function () {
            var start = 0;
            var end = 0;

            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].canEdit) {
                    start = i;
                    break;
                }
            }

            for (i = this.items.length - 1; i >= 0; i--) {
                if (this.items[i].canEdit) {
                    end = i;
                    break;
                }
            }

            return { start: start, end: end }
        },

        //[optimize]
        _getVisibleItems: function () {
            var visibleItems = new Array();
            var k = 0;
            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].character.toString().length > 0) {
                    visibleItems[k] = this.items[i];
                    k++;
                }
            }

            return visibleItems;
        },

        //[optimize]
        _hasEmptyVisibleItems: function () {
            var visibleItems = this._getVisibleItems();
            for (var i = 0; i < visibleItems.length; i++) {
                if (visibleItems[i].canEdit && visibleItems[i].character == this.promptChar) {
                    return true;
                }
            }

            return false;
        },

        //[optimize]
        _getFirstVisibleNonEmptyIndex: function () {
            var visibleItems = this._getVisibleItems();
            for (var i = 0; i < visibleItems.length; i++) {
                if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                    return i;
                }
            }
        },

        //[optimize]
        _handleMouse: function (e, args) {
            var selection = this._selection();
            if (selection.length <= 1) {
                var firstItemIndex = this._getFirstVisibleNonEmptyIndex();
                if (selection.start < firstItemIndex) {
                    this._setSelectionStart(firstItemIndex);
                }
            }
        },

        _insertKey: function (key) {
            this.numberInput[0].focus();
            var letter = String.fromCharCode(key);
            var charDigit = parseInt(letter);
            if (isNaN(charDigit))
                return;

            var emptyDigits = 0;
            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].character.length == 0) {
                    emptyDigits++;
                }
            }

            var selection = this._selection();

            var rootElement = this;
            if (selection.start >= 0 && selection.start <= this.items.length) {
                var selectedTextDeleted = false
                var firstItemIndex = this._getFirstVisibleNonEmptyIndex();
                if (selection.start < firstItemIndex && selection.length == 0) {
                    if (!isNaN(letter) || letter == ' ') {
                        this._setSelectionStart(firstItemIndex);
                        selection = this._selection();
                    }
                }

                var firstEditableIndex = this._getFirstEditableItemIndex();
                var lastEditableIndex = this._getLastEditableItemIndex();

                if (this.value === null) {
                    firstEditableIndex = lastEditableIndex = 0;
                }

                var visibleItems = this._getVisibleItems();
                $.each(visibleItems, function (i, value) {
                    if (selection.start > i && i != visibleItems.length - 1)
                        return;

                    var item = visibleItems[i];
                    if (i > lastEditableIndex) {
                        item = visibleItems[lastEditableIndex];
                    }

                    if (isNaN(letter) || letter == ' ' || letter == '' || !item)
                        return;

                    if (!item.canEdit) {
                        return;
                    }
                    var separatorPosition = rootElement._getSeparatorPosition();

                    if (rootElement._match(letter, item.regex)) {
                        if (!selectedTextDeleted && selection.length > 0) {
                            for (var j = selection.start + emptyDigits; j < selection.end + emptyDigits; j++) {
                                if (rootElement.items[j].canEdit) {
                                    if (j > separatorPosition) {
                                        rootElement.items[j].character = '0';
                                    }
                                    else {
                                        rootElement.items[j].character = rootElement.promptChar;
                                    }
                                }
                            }

                            var text = rootElement._getString();
                            //           rootElement.inputValue(text);
                            selectedTextDeleted = true;
                        }

                        var separatorPosition = rootElement._getSeparatorPosition();
                        var hasEmptyItems = rootElement._hasEmptyVisibleItems();
                        if (rootElement.decimal == null) {
                            selection.start = separatorPosition - 1;
                            if (selection.start < 0)
                                selection.start = 0;
                            selection.end = selection.start;
                        }

                        if (selection.start <= separatorPosition && hasEmptyItems) {
                            var limit = i;
                            if (rootElement.decimalSeparatorPosition == -1 && selection.start == separatorPosition) {
                                limit = i + 1;
                            }
                            if (rootElement.decimal == null) {
                                limit = selection.start;
                            }

                            var numberString = "";
                            for (var p = 0; p < limit; p++) {
                                if (visibleItems[p].canEdit && visibleItems[p].character != rootElement.promptChar) {
                                    numberString += visibleItems[p].character;
                                }
                            }

                            numberString += letter;
                            var offset = rootElement.decimal < 1 ? 1 : 0;

                            if (selection.start == separatorPosition && rootElement.decimalSeparatorPosition != -1) {
                                numberString += rootElement.decimalSeparator;
                                offset = 0;
                            }


                            for (var p = limit + offset; p < visibleItems.length; p++) {
                                if (visibleItems[p].character == rootElement.decimalSeparator && visibleItems[p].isSeparator) {
                                    numberString += visibleItems[p].character;
                                }
                                else if (visibleItems[p].canEdit && visibleItems[p].character != rootElement.promptChar) {
                                    numberString += visibleItems[p].character;
                                }
                            }

                            if (rootElement.decimalSeparator != '.') {
                                numberString = rootElement._parseDecimalValue(numberString);
                            }

                            numberString = parseFloat(numberString).toString();
                            numberString = new Number(numberString);
                            numberString = numberString.toFixed(rootElement.decimalDigits);
                            if (rootElement.decimalSeparator != '.') {
                                numberString = rootElement._parseDecimalValueToEditorValue(numberString);
                            }

                            rootElement.setvalue('decimal', numberString);

                            var text = rootElement._getString();

                            if (selection.end < separatorPosition) {
                                rootElement._setSelectionStart(selection.end + offset);
                            }
                            else {
                                rootElement._setSelectionStart(selection.end);
                            }

                            if (selection.length >= 1) {
                                rootElement._setSelectionStart(selection.end);
                            }

                            if (selection.length == rootElement.numberInput.val().length) {
                                var selectBeforeSeparator = rootElement._moveCaretToDecimalSeparator();
                                var separatorOffset = rootElement.decimalSeparatorPosition >= 0 ? 1 : 0;
                                rootElement._setSelectionStart(selectBeforeSeparator - separatorOffset);
                            }
                        }
                        else {
                            if (selection.start < separatorPosition || selection.start > separatorPosition) {
                                if (rootElement.numberInput.val().length == selection.start && rootElement.decimalSeparatorPosition != -1) {
                                    return false;
                                }
                                else if (rootElement.numberInput.val().length == selection.start && rootElement.decimalSeparatorPosition == -1 && !hasEmptyItems) {
                                    return false;
                                }

                                var numberString = "";
                                var addedSeparator = false;
                                for (var p = 0; p < i; p++) {
                                    if (visibleItems[p].canEdit && visibleItems[p].character != rootElement.promptChar) {
                                        numberString += visibleItems[p].character;
                                    }
                                    if (visibleItems[p].character == rootElement.decimalSeparator && visibleItems[p].isSeparator) {
                                        numberString += visibleItems[p].character;
                                        addedSeparator = true;
                                    }
                                }

                                numberString += letter;
                                var offset = rootElement.decimal < 1 ? 1 : 0;

                                if (!addedSeparator && selection.start == separatorPosition - 1) {
                                    numberString += rootElement.decimalSeparator;
                                    addedSeparator = true;
                                }

                                for (var p = i + 1; p < visibleItems.length; p++) {
                                    if (!addedSeparator && visibleItems[p].character == rootElement.decimalSeparator && visibleItems[p].isSeparator) {
                                        numberString += visibleItems[p].character;
                                    }
                                    else if (visibleItems[p].canEdit && visibleItems[p].character != rootElement.promptChar) {
                                        numberString += visibleItems[p].character;
                                    }
                                }

                                rootElement.setvalue('decimal', numberString);

                                var text = rootElement._getString();

                                if (rootElement.decimalSeparatorPosition < 0 && item == visibleItems[lastEditableIndex]) {
                                    rootElement._setSelectionStart(i);

                                    return false;
                                }

                                var symbolstartposition = text.indexOf(rootElement.symbol);
                                var sel = !rootElement.getvalue('negative') ? 0 : 1;
                                if (symbolstartposition <= sel) symbolstartposition = text.length;

                                // Do not move caret, if it's after the symbol.
                                if (selection.start < symbolstartposition) {
                                    rootElement._setSelectionStart(i + 1);
                                }
                                else rootElement._setSelectionStart(i);

                                if (selection.length >= 1) {
                                    //             rootElement._setSelectionStart(selection.end);
                                }

                                if (selection.length == rootElement.numberInput.val().length) {
                                    var selectBeforeSeparator = rootElement._moveCaretToDecimalSeparator();
                                    rootElement._setSelectionStart(selectBeforeSeparator - 1);
                                }
                            }
                        }
                        return false;
                    }
                });
            }
        },

        //[optimize]
        _handleKeyPress: function (e, key) {
            var selection = this._selection();
            var rootElement = this;
            var ctrlKey = e.ctrlKey || e.metaKey;
            if ((ctrlKey && key == 97 /* firefox */) || (ctrlKey && key == 65) /* opera */) {
                return true;
            }

            if (key == 8) {
                if (selection.start > 0) {
                    rootElement._setSelectionStart(selection.start);
                }
                return false;
            }

            if (key == 46) {
                if (selection.start < this.items.length) {
                    rootElement._setSelectionStart(selection.start);
                }

                return false;
            }

            if (!$.jqx.browser.mozilla) {
                if (key == 45 || key == 173 || key == 109 || key == 189) {
                    var isNegative = this.getvalue('negative');
                    if (isNegative == false) {
                        this.setvalue('negative', true);
                    }
                    else {
                        this.setvalue('negative', false);
                    }
                }
            }

            if ($.jqx.browser.msie) {
                this._insertKey(key);
            }

            var specialKey = this._isSpecialKey(key);
            return specialKey;
        },

        //[optimize]
        _deleteSelectedText: function () {
            var selection = this._selection();
            var decimalString = "";
            var separatorPosition = this._getSeparatorPosition();
            var visibleItems = this._getVisibleItems();
            var prefix = this._getHiddenPrefixCount();

            if (this.numberInput.val().length == selection.start && selection.length == 0) {
                this._setSelection(selection.start, selection.start + 1);
                selection = this._selection();
            }

            for (var i = 0; i < selection.start; i++) {
                if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                    decimalString += visibleItems[i].character;
                }
                else if (!visibleItems[i].canEdit && this.decimalSeparatorPosition != -1 && visibleItems[i] == visibleItems[this.decimalSeparatorPosition - prefix]) {
                    if (decimalString.length == 0) {
                        decimalString = "0";
                    }

                    decimalString += visibleItems[i].character;
                }
            }

            for (var i = selection.start; i < selection.end; i++) {
                if (i > separatorPosition && this.decimalSeparatorPosition != -1) {
                    if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                        decimalString += "0";
                    }
                }
                else if (!visibleItems[i].canEdit && this.decimalSeparatorPosition != -1 && visibleItems[i] == visibleItems[this.decimalSeparatorPosition - prefix]) {
                    if (decimalString.length == 0) {
                        decimalString = "0";
                    }

                    decimalString += visibleItems[i].character;
                }
            }

            for (var i = selection.end; i < visibleItems.length; i++) {
                if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                    decimalString += visibleItems[i].character;
                }
                else if (!visibleItems[i].canEdit && this.decimalSeparatorPosition != -1 && visibleItems[i] == visibleItems[this.decimalSeparatorPosition - prefix]) {
                    if (decimalString.length == 0) {
                        decimalString = "0";
                    }

                    decimalString += visibleItems[i].character;
                }
            }

            this.setvalue('decimal', decimalString);
            return selection.length > 0;
        },

        _restoreInitialState: function () {
            var suffix = parseInt(this.decimalDigits);

            // add the first digit + the decimal separator.
            if (suffix > 0) {
                suffix += 2;
            }

            for (var k = this.items.length - 1; k > this.items.length - 1 - suffix; k--) {
                if (!this.items[k]) {
                    break;
                }

                if (this.items[k].canEdit && this.items[k].character == this.promptChar) {
                    this.items[k].character = 0;
                }
            }
        },

        clear: function () {
            this.setDecimal(0);
        },

        // clears the decimal value.
        clearDecimal: function () {
            if (this.inputMode == 'textbox') {
                this.numberInput.val();
                return;
            }

            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].canEdit) {
                    this.items[i].character = this.promptChar;
                }
            }

            this._restoreInitialState();
        },

        //[optimize]
        _saveSelectedText: function () {
            var selection = this._selection();
            var text = "";
            var visibleItems = this._getVisibleItems();

            if (selection.start > 0 || selection.length > 0) {
                for (var i = selection.start; i < selection.end; i++) {
                    if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                        text += visibleItems[i].character;
                    }
                    else if (visibleItems[i].isSeparator) {
                        text += visibleItems[i].character;
                    }
                }
            }
            if ($.jqx.browser.msie) {
                window.clipboardData.setData("Text", text);
            }

            return text;
        },

        _pasteSelectedText: function () {
            var selection = this._selection();
            var text = "";
            var k = 0;

            this.selectedText = $.data(document.body, "jqxSelection");
            if (window.clipboardData) {
                var clipboardText = window.clipboardData.getData("Text");
                if (clipboardText != this.selectedText && clipboardText.length > 0) {
                    this.selectedText = window.clipboardData.getData("Text");
                    if (this.selectedText == null || this.selectedText == undefined)
                        return;
                }
            }
            var newSelection = selection.start;
            var visibleItems = this._getVisibleItems();
            if (this.selectedText != null) {
                for (var t = 0; t < this.selectedText.length; t++) {
                    var number = parseInt(this.selectedText[t]);
                    if (!isNaN(number)) {
                        var numberCode = 48 + number;
                        this._insertKey(numberCode);
                    }
                }
            }
        },

        _getHiddenPrefixCount: function () {
            var length = 0;

            if (!this.negative) {
                length++;
            }

            if (this.symbolPosition == "left") {
                for (var i = 0; i < this.symbol.length; i++) {
                    if (this.symbol.substring(i, i + 1) == '') {
                        length++;
                    }
                }
            }
            return length;
        },

        //[optimize]
        _getEditableItem: function () {
            var selection = this._selection();

            for (var i = 0; i < this.items.length; i++) {
                if (i < selection.start) {
                    if (this.items[i].canEdit && this.items[i].character != this.promptChar) {
                        return this.items[i];
                    }
                }
            }

            return null;
        },

        //[optimize]
        _getEditableItems: function () {
            var editableItems = new Array();
            var k = 0;

            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].canEdit) {
                    editableItems[k] = this.items[i];
                    k++;
                }
            }

            return editableItems;
        },

        //[optimize]
        _getValidSelectionStart: function (selectionStart) {
            for (var i = this.items.length - 1; i >= 0; i--) {
                if (this.items[i].canEdit && this.items[i].character != this.promptChar) {
                    return i;
                }
            }

            return -1;
        },

        //[optimize]
        _getEditableItemIndex: function (afterCaret) {
            var selection = this._selection();
            var prefix = this._getHiddenPrefixCount();
            var visibleItems = this._getVisibleItems();

            var index = selection.start;
            var editableIndex = -1;
            for (var i = 0; i < index; i++) {
                if (i < visibleItems.length && visibleItems[i].canEdit) {
                    editableIndex = i + prefix;
                }
            }

            if (editableIndex == -1 && selection.length > 0) {
                index = selection.end;
                for (i = 0; i < index; i++) {
                    if (i < visibleItems.length && visibleItems[i].canEdit) {
                        editableIndex = i + prefix;
                        break;
                    }
                }
            }

            return editableIndex;
        },

        //[optimize]
        _getEditableItemByIndex: function (index) {
            for (var k = 0; k < this.items.length; k++) {
                if (k > index) {
                    if (this.items[k].canEdit && this.items[k].character != this.promptChar) {
                        return k;
                    }
                }
            }

            return -1;
        },

        //[optimize]
        _getFirstEditableItemIndex: function () {
            var visibleItems = this._getVisibleItems();
            for (var m = 0; m < visibleItems.length; m++) {
                if (visibleItems[m].character != this.promptChar && visibleItems[m].canEdit && visibleItems[m].character != '0')
                    return m;
            }

            return -1;
        },

        //[optimize]
        _getLastEditableItemIndex: function () {
            var visibleItems = this._getVisibleItems();
            for (var m = visibleItems.length - 1; m >= 0; m--) {
                if (visibleItems[m].character != this.promptChar && visibleItems[m].canEdit)
                    return m;
            }

            return -1;
        },

        //[optimize]
        _moveCaretToDecimalSeparator: function () {
            for (var i = this.items.length - 1; i >= 0; i--) {
                if (this.items[i].character == this.decimalSeparator && this.items[i].isSeparator) {
                    if (!this.negative) {
                        this._setSelectionStart(i);
                        return i;
                    }
                    else {
                        this._setSelectionStart(i + 1);
                        return i;
                    }
                    break;
                }
            }

            return this.numberInput.val().length;
        },

        //[optimize]
        _handleBackspace: function () {
            var selection = this._selection();
            var prefix = this._getHiddenPrefixCount();
            var editableItemIndex = this._getEditableItemIndex() - prefix;
            var firstItemIndex = this._getFirstVisibleNonEmptyIndex();
            var negative = false;
            if (this.negative) {
                negative = true;
                if (firstItemIndex >= editableItemIndex + 1 || selection.start == 0) {
                    this.setvalue("negative", false);
                    if (selection.length == 0) {
                        this._setSelectionStart(selection.start - 1);
                        var selection = this._selection();
                    }
                }
            }

            if (editableItemIndex >= 0) {
                if (selection.length == 0 && editableItemIndex != -1) {
                    this._setSelection(editableItemIndex, editableItemIndex + 1);
                }

                var deleteAfterSeparator = selection.start > this._getSeparatorPosition() + 1 && this.decimalSeparatorPosition > 0;
                if (deleteAfterSeparator) {
                    selection = this._selection();
                }

                var deletedText = this._deleteSelectedText();
                if (selection.length < 1 || deleteAfterSeparator) {
                    this._setSelectionStart(selection.start);
                }
                else if (selection.length >= 1) {
                    this._setSelectionStart(selection.end);
                }

                if (selection.length == this.numberInput.val().length || negative) {
                    var selectBeforeSeparator = this._moveCaretToDecimalSeparator();
                    this._setSelectionStart(selectBeforeSeparator - 1);
                    if (negative) {
                        this._setSelectionStart(selection.start);
                    }
                }
            }
            else {
                this._setSelectionStart(selection.start);
            }
        },

        //[optimize]
        _handleKeyDown: function (e, key) {
            var selection = this._selection();
            var ctrlKey = e.ctrlKey || e.metaKey;

            if ((key == 8 || key == 46) && ctrlKey) {
                this.setDecimal(null);
                return false;
            }

            if (this.rtl && key == 37) {
                var shift = e.shiftKey;
                var offset = shift ? 1 : 0;
                if (shift) {
                    this._setSelection(selection.start + 1 - offset, selection.start + selection.length + 1);
                }
                else {
                    this._setSelection(selection.start + 1 - offset, selection.start + 1);
                }

                return false;
            }
            else if (this.rtl && key == 39) {
                var shift = e.shiftKey;
                var offset = shift ? 1 : 0;
                if (shift) {
                    this._setSelection(selection.start - 1, selection.length + offset + selection.start - 1);
                }
                else {
                    this._setSelection(selection.start - 1, selection.start - 1);
                }
                return false;
            }

            if ((ctrlKey && key == 97 /* firefox */) || (ctrlKey && key == 65) /* opera */) {
                return true;
            } // allow Ctrl+X (cut)
            if ((ctrlKey && key == 120 /* firefox */) || (ctrlKey && key == 88) /* opera */) {
                this.selectedText = this._saveSelectedText(e);
                $.data(document.body, "jqxSelection", this.selectedText);
                this._handleBackspace();
                return false;
            }
            // allow Ctrl+C (copy)
            if ((ctrlKey && key == 99 /* firefox */) || (ctrlKey && key == 67) /* opera */) {
                this.selectedText = this._saveSelectedText(e);
                $.data(document.body, "jqxSelection", this.selectedText);
                return false;
            }
            // allow Ctrl+Z (undo)
            if ((ctrlKey && key == 122 /* firefox */) || (ctrlKey && key == 90) /* opera */) return false;
            // allow or deny Ctrl+V (paste), Shift+Ins
            if ((ctrlKey && key == 118 /* firefox */) || (ctrlKey && key == 86) /* opera */
                || (e.shiftKey && key == 45)) {
                this._pasteSelectedText();
                return false;
            }
            if (selection.start >= 0 && selection.start < this.items.length) {
                var letter = String.fromCharCode(key);
                var item = this.items[selection.start];
            }

            // handle backspace.
            if (key == 8) {
                this._handleBackspace();
                return false;
            }

            if (key == 190 || key == 110) {
                this._moveCaretToDecimalSeparator();
                return false;
            }

            if (key === 188 && this.decimalSeparator === ',') {
                this._moveCaretToDecimalSeparator();
                return false;
            }

            if (key == 188 && this.groupSeparator === ',') {
                var value = this.numberInput.val();
                for (var i = selection.start; i < value.length; i++) {
                    if (value[i] == this.groupSeparator) {
                        this._setSelectionStart(1 + i);
                        break;
                    }
                }

                return false;
            }

            if ($.jqx.browser.msie == null) {
                var letter = String.fromCharCode(key);
                var digit = parseInt(letter);
                if (key >= 96 && key <= 105) {
                    digit = key - 96;
                    key = key - 48;
                }

                if (!isNaN(digit)) {
                    var me = this;
                    me._insertKey(key);
                    return false;
                }
            }

            // handle del.
            if (key == 46) {
                var visibleItems = this._getVisibleItems();
                if (selection.start < visibleItems.length) {
                    var offset = visibleItems[selection.start].canEdit == false ? 2 : 1;
                    if (selection.start == 0) {
                        if (this.negative) {
                            this.setvalue("negative", false);
                            if (selection.length == 0) {
                                this._setSelectionStart(0);
                            }
                            var selection = this._selection();
                            if (selection.length == 0) {
                                return false;
                            }
                        }
                    }

                    if (selection.length == 0) {
                        this._setSelection(selection.start + offset, selection.start + offset + selection.length);
                    }

                    this._handleBackspace();

                    if (new Number(this.decimal) < 1 || selection.start > this._getSeparatorPosition()) {
                        this._setSelectionStart(selection.end + offset);
                    }
                    else if (selection.start + 1 < this.decimalSeparatorPosition) {
                        this._setSelectionStart(selection.end + offset);
                    }
                }
                return false;
            }

            if (key == 38) {
                this.spinUp();
                return false;
            }
            else if (key == 40) {
                this.spinDown();
                return false;
            }

            if (key === 27) {
                this.setDecimal(this._savedValue);
                this._setSelectionStart(selection.end);

                e.preventDefault();
            }

            var specialKey = this._isSpecialKey(key);

            if ($.jqx.browser.mozilla) {
                if (key == 45 || key == 173 || key == 109 || key == 189) {
                    var isNegative = this.getvalue('negative');
                    if (isNegative == false) {
                        this.setvalue('negative', true);
                    }
                    else {
                        this.setvalue('negative', false);
                    }
                }
            }

            if (!$.jqx.browser.mozilla)
                return true;

            return specialKey;
        },

        _isSpecialKey: function (key) {
            if (key != 8 /* backspace */ &&
                key != 9 /* tab */ &&
                key != 13 /* enter */ &&
                key != 35 /* end */ &&
                key != 36 /* home */ &&
                key != 37 /* left */ &&
                key != 39 /* right */ &&
                key != 27 /* right */ &&
                key != 46 /* del */
            ) {
                return false;
            }

            return true;
        },

        //[optimize]
        _selection: function () {
            try {
                if ('selectionStart' in this.numberInput[0]) {
                    var e = this.numberInput[0];
                    var selectionLength = e.selectionEnd - e.selectionStart;
                    return { start: e.selectionStart, end: e.selectionEnd, length: selectionLength, text: e.value };
                }
                else {
                    var r = document.selection.createRange();
                    if (r == null) {
                        return { start: 0, end: e.value.length, length: 0 }
                    }

                    var re = this.numberInput[0].createTextRange();
                    var rc = re.duplicate();
                    re.moveToBookmark(r.getBookmark());
                    rc.setEndPoint('EndToStart', re);
                    var selectionLength = r.text.length;

                    return { start: rc.text.length, end: rc.text.length + r.text.length, length: selectionLength, text: r.text };
                }
            }
            catch (error) {
                return { start: 0, end: 0, length: 0 };
            }
        },

        selectAll: function () {
            var textbox = this.numberInput;
            setTimeout(function () {
                if ('selectionStart' in textbox[0]) {
                    textbox[0].focus();
                    textbox[0].setSelectionRange(0, textbox[0].value.length);
                }
                else {
                    var range = textbox[0].createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', textbox[0].value.length);
                    range.moveStart('character', 0);
                    range.select();
                }
            }, 10);
        },

        _setSelection: function (start, end) {
            if (this._disableSetSelection == true) return;
            var isTouchDevice = $.jqx.mobile.isTouchDevice();
            if (isTouchDevice || this.touchMode == true)
                return;

            try {
                if ('selectionStart' in this.numberInput[0]) {
                    this.numberInput[0].focus();
                    this.numberInput[0].setSelectionRange(start, end);
                }
                else {
                    var range = this.numberInput[0].createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', end);
                    range.moveStart('character', start);
                    range.select();
                }
            }
            catch (error) {
            }
        },

        _setSelectionStart: function (start) {
            this._setSelection(start, start);
            $.data(this.numberInput, "selectionstart", start);
        },

        resize: function (width, height) {
            this.width = width;
            this.height = height;
            this._render(false);
        },

        _render: function (refreshValue) {
            var leftBorder = parseInt(this.host.css("border-left-width"));
            var rightBorder = parseInt(this.host.css("border-left-width"));
            var topBorder = parseInt(this.host.css("border-left-width"));
            var bottomBorder = parseInt(this.host.css("border-left-width"));
            this.numberInput.css("padding-top", '0px');
            this.numberInput.css("padding-bottom", '0px');

            var computedStyle = window.getComputedStyle(this.element);
            var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
            var boxSizing = computedStyle.boxSizing;

            if (boxSizing === 'border-box' || isNaN(borderSize)) {
                borderSize = 0;
            }

            if (this.width != null && this.width.toString().indexOf("px") != -1) {
                this.element.style.width = parseInt(this.width) - borderSize + 'px';
            }
            else if (this.width != undefined && !isNaN(this.width)) {
                this.element.style.width = parseInt(this.width) - borderSize + 'px';
            }

            if (this.height != null && this.height.toString().indexOf("px") != -1) {
                this.element.style.height = parseInt(this.height) - borderSize + 'px';
            }
            else if (this.height != undefined && !isNaN(this.height)) {
                this.element.style.height = parseInt(this.height) - borderSize + 'px';
            };

            var width = this.host.width();
            var height = this.host.height();

            this.numberInput.css({
                "border-left-width": 0,
                "border-right-width": 0,
                "border-bottom-width": 0,
                "border-top-width": 0
            });
            if (isNaN(topBorder))
                topBorder = 1;
            if (isNaN(rightBorder))
                rightBorder = 1;
            if (isNaN(bottomBorder))
                bottomBorder = 1;
            if (isNaN(leftBorder))
                leftBorder = 1;

            this.numberInput.css("text-align", this.textAlign);
            var fontSize = this.numberInput.css("font-size");
            if ("" == fontSize) fontSize = 13;
            this.numberInput.css('height', parseInt(fontSize) + 4 + 'px');
            this.numberInput.css('width', width - 2);

            var top = height - 2 * topBorder - parseInt(fontSize) - 2;
            if (isNaN(top)) top = 0;
            if (top < 0) top = 0;
            if (this.spinButtons && this.spincontainer) {
                width -= parseInt(this.spinButtonsWidth - 2);
                var touchDevice = $.jqx.mobile.isTouchDevice();
                if (!touchDevice && this.touchMode !== true) {
                    this.spincontainer.width(this.spinButtonsWidth);
                    this.upbutton.width(this.spinButtonsWidth + 2);
                    this.downbutton.width(this.spinButtonsWidth + 2);
                    this.upbutton.height('50%');
                    this.downbutton.height('50%');
                    this.spincontainer.width(this.spinButtonsWidth);
                }
                else {
                    this.spincontainer.width(2 * (this.spinButtonsWidth));
                    width -= this.spinButtonsWidth;
                    this.upbutton.height('100%');
                    this.downbutton.height('100%');
                    this.downbutton.css('float', 'left');
                    this.upbutton.css('float', 'right');
                    this.upbutton.width(this.spinButtonsWidth);
                    this.downbutton.width(1 + this.spinButtonsWidth);
                }

                this._upArrow.height('100%');
                this._downArrow.height('100%');
                this.numberInput.css('width', width - 6);
                this.numberInput.css('margin-right', '2px');
            }

            var topPadding = top / 2;

            // fix for MSIE 6 and 7. These browsers double the top padding for some reason...
            if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                topPadding = top / 4;
            }

            this.numberInput.css("padding-left", '0px');
            this.numberInput.css("padding-right", '0px');
            this.numberInput.css("padding-top", Math.round(topPadding) + 'px');
            this.numberInput.css("padding-bottom", Math.round(topPadding) + 'px');

            if (refreshValue == undefined || refreshValue == true) {
                this.numberInput.val(this._getString())
                if (this.inputMode != 'advanced') {
                    this._parseDecimalInSimpleMode();
                }
            }

            this._addBarAndLabel(this.numberInput);
            this._updateHint();
        },

        _addBarAndLabel: function (host) {
            var that = this;

            if (that.bar !== null || that.label !== null) {
                return;
            }

            var label = $("<label></label");

            if (this.hint) {
                label[0].innerHTML = this.placeHolder;
            }

            label.addClass(that.toThemeProperty('jqx-input-label'));
            host.after(label);
            that.label = label;

            var bar = $("<span></span>");
            host.after(bar);
            bar.addClass(that.toThemeProperty('jqx-input-bar'));

            if (that.spinButtons) {
                bar.css('top', that.host.height());
            }
            else {
                bar.css('top', '0px');
            }
            that.bar = bar;

            if (that.template) {
                that.bar.addClass(that.toThemeProperty("jqx-" + that.template));
                that.label.addClass(that.toThemeProperty("jqx-" + that.template));
            }

        },

        destroy: function () {
            this._removeHandlers();
            this.host.remove();
        },

        // gets or sets the input's text value including the formatting characters.
        inputValue: function (newValue) {
            if (newValue === undefined) {
                return this._value();
            }

            this.propertyChangedHandler(this, "value", this._value, newValue);
            this._refreshValue();
            return this;
        },

        // gets the input's value.
        _value: function () {
            var value = this.numberInput.val();
            return value;
        },

        val: function (decimal) {
            if (decimal !== undefined && typeof decimal != 'object' || decimal === null) {
                if (decimal === null) {
                    this.setDecimal(null);
                    return;
                }
                else {
                    var value = decimal;

                    if (value < 0) {
                        this.setDecimal(value);
                        return;
                    }
                    else {
                        this.setvalue('negative', false);
                    }

                    value = value.toString();
                    if (value.indexOf(this.symbol) > -1) {
                        // remove currency symbol
                        value = value.replace(this.symbol, "");
                    }

                    var replaceAll = function (text, stringToFind, stringToReplace) {
                        var temp = text;
                        if (stringToFind == stringToReplace) return text;

                        var index = temp.indexOf(stringToFind);
                        while (index != -1) {
                            temp = temp.replace(stringToFind, stringToReplace);
                            index = temp.indexOf(stringToFind)
                        }

                        return temp;
                    }

                    value = value.replace(this.decimalSeparator, ".");
                    value = replaceAll(value, this.groupSeparator, "");

                    var val = "";
                    for (var t = 0; t < value.length; t++) {
                        var ch = value.substring(t, t + 1);
                        if (ch === "-") val += "-";
                        if (ch === ".") val += ".";
                        if (ch.match(/^[0-9]+$/) != null) {
                            val += ch;
                        }
                    }

                    value = val;
                    value = value.replace(/ /g, "");
                    value = value.replace('.', this.decimalSeparator);

                    this._setDecimal(value);
                }
            }
            else return this.getDecimal();
        },

        getDecimal: function () {
            if (this.decimal == null)
                return null;

            if (this.inputMode == 'simple') {
                this._parseDecimalInSimpleMode(false);
                this.decimal = this._getDecimalInSimpleMode(this.decimal);
            }

            if (this.decimal == "") return 0;

            var isNegative = this.getvalue('negative');
            if (isNegative && this.decimal > 0) {
                return -parseFloat(this.decimal);
            }

            return parseFloat(this.decimal);
        },

        setDecimal: function (value) {
            var currentValue = value;
            if (this.decimalSeparator != '.') {
                if (value === null) {
                    this._setDecimal(value);
                }
                else {
                    var decimalValue = value;
                    if (typeof (value) != "number") {
                        value = value.toString();
                        var separatorIndex = value.indexOf('.');
                        if (separatorIndex != -1) {
                            var prefix = value.substring(0, separatorIndex);
                            var suffix = value.substring(separatorIndex + 1);
                            decimalValue = prefix + "." + suffix;
                            if (prefix.indexOf('-') != -1)
                                prefix = prefix.substring(1);

                            if (this.inputMode != "advanced")
                                value = prefix + "." + suffix;
                            else
                                value = prefix + this.decimalSeparator + suffix;
                        }
                        else {
                            var separatorIndex = value.indexOf(this.decimalSeparator);
                            if (separatorIndex != -1) {
                                var prefix = value.substring(0, separatorIndex);
                                var suffix = value.substring(separatorIndex + 1);
                                decimalValue = prefix + "." + suffix;
                                if (prefix.indexOf('-') != -1)
                                    prefix = prefix.substring(1);
                                if (this.inputMode != "advanced")
                                    value = prefix + "." + suffix;
                                else
                                    value = prefix + this.decimalSeparator + suffix;
                            }
                        }
                    }

                    if (decimalValue < 0)
                        this.setvalue('negative', true);
                    else {
                        this.setvalue('negative', false);
                    }

                    if (value === null) {
                        this._setDecimal(value);
                    }
                    else {
                        this._setDecimal(Math.abs(value));
                    }
                }
            }
            else {
                if (value < 0)
                    this.setvalue('negative', true);
                else {
                    this.setvalue('negative', false);
                }
                if (value === null) {
                    this._setDecimal(value);
                }
                else {
                    this._setDecimal(Math.abs(value));
                }
            }

            if (currentValue == null) {
                this.numberInput.val("");
            }

            this._updateHint();
        },

        // sets the input's decimal value.
        _setDecimal: function (value) {
            if (!this.allowNull && value == null) {
                this.decimal = 0;
                value = 0;
            }

            if (value == null) {
                this.decimal = null;
                this.value = null;
                this.clearDecimal();
                this._refreshValue();
                this.decimal = null;
                this.value = null;
                this.ValueString = "";
                return;
            }

            if (value.toString().indexOf('e') != -1) {
                value = new Number(value).toFixed(this.decimalDigits).toString();
            }

            this.clearDecimal();
            var decimalString = value.toString();
            var numberPartString = "";
            var decimalPartString = "";
            var addToNumberPart = true;

            if (decimalString.length == 0) {
                decimalString = "0";
            }

            for (var i = 0; i < decimalString.length; i++) {
                if (typeof (value) == "number") {
                    if (decimalString.substring(i, i + 1) == ".") {
                        addToNumberPart = false;
                        continue;
                    }
                }
                else {
                    if (decimalString.substring(i, i + 1) == this.decimalSeparator) {
                        addToNumberPart = false;
                        continue;
                    }
                }
                if (addToNumberPart) {
                    numberPartString += decimalString.substring(i, i + 1);
                }
                else {
                    decimalPartString += decimalString.substring(i, i + 1);
                }
            }

            if (numberPartString.length > 0) {
                numberPartString = parseFloat(numberPartString).toString();
            }

            var digitsBeforeSeparator = this.digits;
            if (digitsBeforeSeparator < numberPartString.length) {
                numberPartString = numberPartString.substr(0, digitsBeforeSeparator);
            }

            var k = 0;
            var separatorPosition = this._getSeparatorPosition();
            var hiddenTextLength = this._getHiddenPrefixCount();
            separatorPosition = separatorPosition + hiddenTextLength;

            for (var i = separatorPosition; i >= 0; i--) {
                if (i < this.items.length && this.items[i].canEdit) {
                    if (k < numberPartString.length) {
                        this.items[i].character = numberPartString.substring(numberPartString.length - k - 1, numberPartString.length - k);
                        k++;
                    }
                }
            }

            k = 0;
            for (var i = separatorPosition; i < this.items.length; i++) {
                if (this.items[i].canEdit) {
                    if (k < decimalPartString.length) {
                        this.items[i].character = decimalPartString.substring(k, k + 1);
                        k++;
                    }
                }
            }

            this._refreshValue();

            if (this.decimalSeparator == '.') {
                this.ValueString = new Number(value).toFixed(this.decimalDigits);
            }
            else {
                var indx = value.toString().indexOf(this.decimalSeparator);
                if (indx > 0) {
                    var prefix = value.toString().substring(0, indx);
                    var val = prefix + "." + value.toString().substring(indx + 1);
                    this.ValueString = new Number(val).toFixed(this.decimalDigits);
                }
                else {
                    this.ValueString = new Number(value).toFixed(this.decimalDigits);
                }
            }

            if (this.inputMode != 'advanced') {
                this._parseDecimalInSimpleMode();
                this._raiseEvent(1, this.ValueString);
            }
            if (this.inputMode == 'textbox') {
                this.decimal = this.ValueString;
                var isNegative = this.getvalue('negative');
                if (isNegative) {
                    this.decimal = "-" + this.ValueString;
                }
            }

            var value = this.val();
            if (value < this.min || value > this.max) {
                this.host.addClass('jqx-input-invalid');
            }
            else {
                this.host.removeClass('jqx-input-invalid');
            }
            this._updateHint();
        },

        //[optimize]
        _getSeparatorPosition: function () {
            var hiddenTextLength = this._getHiddenPrefixCount();
            if (this.decimalSeparatorPosition > 0)
                return this.decimalSeparatorPosition - hiddenTextLength;

            return this.items.length - hiddenTextLength;
        },

        _setTheme: function () {
            this.host.removeClass();
            this.host.addClass(this.toThemeProperty('jqx-input'));
            this.host.addClass(this.toThemeProperty('jqx-rc-all'));
            this.host.addClass(this.toThemeProperty('jqx-widget'));
            this.host.addClass(this.toThemeProperty('jqx-widget-content'));
            this.host.addClass(this.toThemeProperty('jqx-numberinput'));

            if (this.spinButtons) {
                this.downbutton.removeClass();
                this.upbutton.removeClass();
                this.downbutton.addClass(this.toThemeProperty('jqx-scrollbar-button-state-normal'));
                this.upbutton.addClass(this.toThemeProperty('jqx-scrollbar-button-state-normal'));
                this._upArrow.removeClass();
                this._downArrow.removeClass();
                this._upArrow.addClass(this.toThemeProperty('jqx-icon-arrow-up'));
                this._downArrow.addClass(this.toThemeProperty('jqx-icon-arrow-down'));

            }
            this.numberInput.removeClass();
            this.numberInput.addClass(this.toThemeProperty('jqx-input-content'));
        },

        propertiesChangedHandler: function (object, oldValues, newValues) {
            if (newValues && newValues.width && newValues.height && Object.keys(newValues).length == 2) {
                object._render();
            }
        },

        // sets a property.
        propertyChangedHandler: function (object, key, oldvalue, value) {


            if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                return;
            }

            if (key == "template") {
                object.upbutton.removeClass(object.toThemeProperty("jqx-" + object.template))
                object.downbutton.removeClass(object.toThemeProperty("jqx-" + object.template))
                object.upbutton.addClass(object.toThemeProperty("jqx-" + object.template))
                object.downbutton.addClass(object.toThemeProperty("jqx-" + object.template))
            }

            if (key == 'digits' || key == 'groupSize' || key == 'decimalDigits') {
                if (value < 0) {
                    throw new Exception(this.invalidArgumentExceptions[0]);
                }
            }

            if (key == "placeHolder") {
                if (!object.isMaterialized()) {
                    object.numberInput.attr('placeholder', object.placeHolder);
                }
                else if (object.hint) {
                    object.label[0].innerHTML = object.placeHolder;
                }
            }

            if (key === 'theme') {
                $.jqx.utilities.setTheme(oldvalue, value, object.host);
            }

            if (key == "digits") {
                if (value != oldvalue) {
                    object.digits = parseInt(value);
                }
            }

            if (key == "min" || key == "max") {
                $.jqx.aria(object, "aria-value" + key, value.toString());
                object._refreshValue();
            }

            if (key == "decimalDigits") {
                if (value != oldvalue) {
                    object.decimalDigits = parseInt(value);
                }
            }

            if (key == "decimalSeparator" || key == "digits" || key == "symbol" || key == "symbolPosition" || key == "groupSize" || key == "groupSeparator" || key == "decimalDigits" || key == "negativeSymbol") {
                var decimal = object.decimal;

                if (key == 'decimalSeparator' && value == '') {
                    value = ' ';
                }

                if (oldvalue != value) {
                    var selection = object._selection();
                    object.items = new Array();
                    object._initializeLiterals();
                    object.value = object._getString();
                    object._refreshValue();
                    object._setDecimal(decimal);
                }
            }
            if (key == "rtl") {
                if (object.rtl) {
                    if (object.spincontainer) {
                        object.spincontainer.css('float', 'right');
                        object.spincontainer.css('border-right-width', '1px');
                    }
                    object.numberInput.css('float', 'right');
                }
                else {
                    if (object.spincontainer) {
                        object.spincontainer.css('float', 'right');
                        object.spincontainer.css('border-right-width', '1px');
                    }
                    object.numberInput.css('float', 'left');
                }
            }
            if (key == "spinButtons") {
                if (object.spincontainer) {
                    if (!value) {
                        object.spincontainer.css('display', 'none');
                    }
                    else {
                        object.spincontainer.css('display', 'block');
                    }
                    object._render();
                }
                else {
                    object._spinButtons();
                }
            }
            if (key === "touchMode") {
                object.inputMode = 'textbox';
                object.spinMode = 'simple';

                object.render();
            }
            if (key == "negative" && object.inputMode == 'advanced') {
                var selection = object._selection();
                var offset = 0;

                if (value) {
                    object.items[0].character = object.negativeSymbol[0];
                    offset = 1;
                }
                else {
                    object.items[0].character = "";
                    offset = -1;
                }

                object._refreshValue();
                if (object.isInitialized) {
                    object._setSelection(selection.start + offset, selection.end + offset);
                }
            }

            if (key == "decimal") {
                object.value = value;
                object.setDecimal(value);
            }

            if (key === "value") {
                object.value = value;
                object.setDecimal(value);
                object._raiseEvent(1, value);
            }

            if (key == "textAlign") {
                object.textAlign = value;
                object._render();
            }

            if (key == "disabled") {
                object.numberInput.attr("disabled", value);
                if (object.disabled) {
                    object.host.addClass(object.toThemeProperty('jqx-fill-state-disabled'));
                }
                else {
                    object.host.removeClass(object.toThemeProperty('jqx-fill-state-disabled'));
                }
                $.jqx.aria(object, "aria-disabled", value.toString());
            }

            if (key == "readOnly") {
                object.readOnly = value;
            }

            if (key == "promptChar") {
                for (var i = 0; i < object.items.length; i++) {
                    if (object.items[i].character == object.promptChar) {
                        object.items[i].character = value;
                    }
                }

                object.promptChar = value;
            }

            if (key == "width") {
                object.width = value;
                object._render();
            }
            else if (key == "height") {
                object.height = value;
                object._render();
            }
        },

        _value: function () {
            var val = this.value;
            return val;
        },

        _refreshValue: function () {
            var value = this.value;
            var k = 0;

            if (this.inputMode === 'textbox') {
                return;
            }

            this.value = this._getString();
            value = this.value;

            var decimalValue = "";
            for (var i = 0; i < this.items.length; i++) {
                var item = this.items[i];

                if (item.canEdit && item.character != this.promptChar) {
                    decimalValue += item.character;
                }

                if (i == this.decimalSeparatorPosition) {
                    decimalValue += ".";
                }
            }

            this.decimal = decimalValue;

            var hasChange = false;

            if (this.oldValue !== value) {
                this.oldValue = value;
                this._raiseEvent(0, value);
                hasChange = true;
            }

            if (this.inputMode != 'simple') {
                this.numberInput.val(value);
                if (hasChange) {
                    this._raiseEvent(1, value);
                }
            }

            if (value == null) {
                this.numberInput.val("");
            }
        }
    });
})(jqxBaseFramework);
})();



/***/ }),

/***/ 4240:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {
    $.jqx.jqxWidget("jqxScrollBar", "", {});

    $.extend($.jqx._jqxScrollBar.prototype, {

        defineInstance: function () {
            var settings = {
                // Type: Number
                // Default: null
                // Sets the scrollbar height.
                height: null,
                // Type: Number
                // Default: null
                // Sets the scrollbar width.
                width: null,
                // Type: Number
                // Default: false. This means that the scrollbar is horizontally oriented by default.
                // Sets the scrollbar orientation.
                vertical: false,
                // Type: Number
                // Default: 0
                // Sets the minimum scroll value.
                min: 0,
                // Type: Number
                // Default: 0
                // Sets the maximum scroll value.
                max: 1000,
                // Type: Number
                // Default: 0
                // Sets the scroll value. The value can be between min and max.
                value: 0,
                // Type: Number
                // Default: 0
                // Sets the scroll step when any arrow button is clicked.
                step: 10,
                // Type: Number
                // Default: 0
                // Sets the scroll step when the user clicks on the empty scroll space between arrow button and thumb.
                largestep: 50,
                // Type: Number
                // Default: 10
                // sets the thumb's minimum size.
                thumbMinSize: 10,
                // Type: Number
                // Default: 0
                // sets the thumb's size.
                thumbSize: 0,
                // Type: Number or 'auto'
                // Default: 'auto'
                // sets the thumb's drag step.
                thumbStep: 'auto',
                // Type: String
                // Default: 'all'
                // sets the rounded corners string.
                roundedCorners: 'all',
                // Type: Boolean
                // Default: true
                // Sets whether the scroll buttons are visible.
                showButtons: true,
                // Type: Boolean
                // Default: false
                // Sets whether the scrollbar is disabled or not.
                disabled: false,
                // Sets whether the scrollbar is on touch device.
                touchMode: 'auto',
                touchModeStyle: 'auto',
                thumbTouchSize: 0,
                // disable jquery trigger function. It is very slow if you call it on mouse move. This could improve performance.
                _triggervaluechanged: true,
                rtl: false,
                areaDownCapture: false,
                areaUpCapture: false,
                _initialLayout: false,
                offset: 0, reference: 0, velocity: 0, frame: 0, timestamp: 0, ticker: null, amplitude: 0, target: 0

            };
            if (this === $.jqx._jqxScrollBar.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        createInstance: function (args) {
            this.render();
        }, // createInstance

        render: function () {
            this._mouseup = new Date();
            var self = this;
            var html = "<div id='jqxScrollOuterWrap' style='box-sizing: content-box; width:100%; height: 100%; align:left; border: 0px; valign:top; position: relative;'>" +
                "<div id='jqxScrollWrap' style='box-sizing: content-box; width:100%; height: 100%; left: 0px; top: 0px; align:left; valign:top; position: absolute;'>" +
                "<div id='jqxScrollBtnUp' style='box-sizing: content-box; align:left; valign:top; left: 0px; top: 0px; position: absolute;'><div></div></div>" +
                "<div id='jqxScrollAreaUp' style='box-sizing: content-box; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='jqxScrollThumb' style='box-sizing: content-box; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='jqxScrollAreaDown' style='box-sizing: content-box; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='jqxScrollBtnDown' style='box-sizing: content-box; align:left; valign:top; left: 0px; top: 0px; position: absolute;'><div></div></div>" +
                "</div>" +
                "</div>";

            if ($.jqx.utilities && $.jqx.utilities.scrollBarButtonsVisibility == "hidden") {
                this.showButtons = false;
            }

            if (self.WinJS) {
                MSApp.execUnsafeLocalFunction(function () {
                    self.host.html(html);
                });
            }
            else {
                this.element.innerHTML = html;
            }

            if (this.width != undefined && parseInt(this.width) > 0) {
                this.host.width(parseInt(this.width));
            }

            if (this.height != undefined && parseInt(this.height) > 0) {
                this.host.height(parseInt(this.height));
            }
            this.isPercentage = false;
            if (this.width != null && this.width.toString().indexOf("%") != -1) {
                this.host.width(this.width);
                this.isPercentage = true;
            }

            if (this.height != null && this.height.toString().indexOf("%") != -1) {
                this.host.height(this.height);
                this.isPercentage = true;
            }
            if (this.isPercentage) {
                var that = this;
                $.jqx.utilities.resize(this.host, function () {
                    that._arrange();
                }, false);
            }
            this.thumbCapture = false;
            this.scrollOuterWrap = $(this.element.firstChild);
            this.scrollWrap = $(this.scrollOuterWrap[0].firstChild);
            this.btnUp = $(this.scrollWrap[0].firstChild);
            this.areaUp = $(this.btnUp[0].nextSibling);
            this.btnThumb = $(this.areaUp[0].nextSibling);
            this.arrowUp = $(this.btnUp[0].firstChild);
            this.areaDown = $(this.btnThumb[0].nextSibling);
            this.btnDown = $(this.areaDown[0].nextSibling);
            this.arrowDown = $(this.btnDown[0].firstChild);

            var elID = this.element.id;
            this.btnUp[0].id = "jqxScrollBtnUp" + elID;
            this.btnDown[0].id = "jqxScrollBtnDown" + elID;
            this.btnThumb[0].id = "jqxScrollThumb" + elID;
            this.areaUp[0].id = "jqxScrollAreaUp" + elID;
            this.areaDown[0].id = "jqxScrollAreaDown" + elID;
            this.scrollWrap[0].id = "jqxScrollWrap" + elID;
            this.scrollOuterWrap[0].id = "jqxScrollOuterWrap" + elID;

            if (!this.host.jqxRepeatButton) {
                throw new Error('jqxScrollBar: Missing reference to jqxbuttons.js.');
                return;
            }

            this.btnUp.jqxRepeatButton({ _ariaDisabled: true, overrideTheme: true, disabled: this.disabled });
            this.btnDown.jqxRepeatButton({ _ariaDisabled: true, overrideTheme: true, disabled: this.disabled });
            this.btnDownInstance = $.data(this.btnDown[0], 'jqxRepeatButton').instance;
            this.btnUpInstance = $.data(this.btnUp[0], 'jqxRepeatButton').instance;

            this.areaUp.jqxRepeatButton({ _scrollAreaButton: true, _ariaDisabled: true, overrideTheme: true });
            this.areaDown.jqxRepeatButton({ _scrollAreaButton: true, _ariaDisabled: true, overrideTheme: true });
            this.btnThumb.jqxButton({ _ariaDisabled: true, overrideTheme: true, disabled: this.disabled });
            this.propertyChangeMap['value'] = function (instance, key, oldVal, value) {
                if (!(isNaN(value))) {
                    if (oldVal != value) {
                        instance.setPosition(parseFloat(value), true);
                    }
                }
            }

            this.propertyChangeMap['width'] = function (instance, key, oldVal, value) {
                if (instance.width != undefined && parseInt(instance.width) > 0) {
                    instance.host.width(parseInt(instance.width));
                    instance._arrange();
                }
            }

            this.propertyChangeMap['height'] = function (instance, key, oldVal, value) {
                if (instance.height != undefined && parseInt(instance.height) > 0) {
                    instance.host.height(parseInt(instance.height));
                    instance._arrange();
                }
            }

            this.propertyChangeMap['theme'] = function (instance, key, oldVal, value) {
                instance.setTheme();
            }

            this.propertyChangeMap['max'] = function (instance, key, oldVal, value) {
                if (!(isNaN(value))) {
                    if (oldVal != value) {
                        instance.max = parseInt(value);
                        if (instance.min > instance.max)
                            instance.max = instance.min + 1;

                        instance._arrange();
                        instance.setPosition(instance.value);
                    }
                }
            }

            this.propertyChangeMap['min'] = function (instance, key, oldVal, value) {
                if (!(isNaN(value))) {
                    if (oldVal != value) {
                        instance.min = parseInt(value);
                        if (instance.min > instance.max)
                            instance.max = instance.min + 1;

                        instance._arrange();
                        instance.setPosition(instance.value);
                    }
                }
            }

            this.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                if (oldVal != value) {
                    if (value) {
                        instance.host.addClass(instance.toThemeProperty('jqx-fill-state-disabled'));
                    }
                    else {
                        instance.host.removeClass(instance.toThemeProperty('jqx-fill-state-disabled'));
                    }
                    instance.btnUp.jqxRepeatButton('disabled', instance.disabled);
                    instance.btnDown.jqxRepeatButton('disabled', instance.disabled);
                    instance.btnThumb.jqxButton('disabled', instance.disabled);
                }
            }

            this.propertyChangeMap['touchMode'] = function (instance, key, oldVal, value) {
                if (oldVal != value) {
                    instance._updateTouchBehavior();
                    if (value === true) {
                        instance.showButtons = false;
                        instance.refresh();
                    }
                    else if (value === false) {
                        instance.showButtons = true;
                        instance.refresh();
                    }
                }
            }

            this.propertyChangeMap['rtl'] = function (instance, key, oldVal, value) {
                if (oldVal != value) {
                    instance.refresh();
                }
            }

            this.buttonUpCapture = false;
            this.buttonDownCapture = false;
            this._updateTouchBehavior();
            this.setPosition(this.value);
            this._addHandlers();
            this.setTheme();
        },

        resize: function (width, height) {
            this.width = width;
            this.height = height;
            this._arrange();
        },

        _updateTouchBehavior: function () {
            this.isTouchDevice = $.jqx.mobile.isTouchDevice();
            if (this.touchMode == true) {
                if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                    this.setTheme();
                    return;
                }

                this.isTouchDevice = true;
                $.jqx.mobile.setMobileSimulator(this.btnThumb[0]);
                this._removeHandlers();
                this._addHandlers();
                this.setTheme();
            }
            else if (this.touchMode == false) {
                this.isTouchDevice = false;
            }
        },

        _addHandlers: function () {
            var self = this;

            var touchSupport = false;
            try {
                if (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
                    touchSupport = true;
                    this._touchSupport = true;
                }
            }
            catch (err) {
            }

            if (self.isTouchDevice || touchSupport) {
                this.addHandler(this.btnThumb, $.jqx.mobile.getTouchEventName('touchend'), function (event) {
                    var btnThumbPressedClass = self.vertical ? self.toThemeProperty('jqx-scrollbar-thumb-state-pressed') : self.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal');
                    var btnThumbPressedFillClass = self.toThemeProperty('jqx-fill-state-pressed');
                    self.btnThumb.removeClass(btnThumbPressedClass);
                    self.btnThumb.removeClass(btnThumbPressedFillClass);
                    if (!self.disabled) self.handlemouseup(self, event);
                    return false;
                });

                this.addHandler(this.btnThumb, $.jqx.mobile.getTouchEventName('touchstart'), function (event) {
                    if (!self.disabled) {
                        if (self.touchMode == true) {
                            event.clientX = event.originalEvent.clientX;
                            event.clientY = event.originalEvent.clientY;
                        }
                        else {
                            var e = event;
                            if (e.originalEvent.touches && e.originalEvent.touches.length) {
                                event.clientX = e.originalEvent.touches[0].clientX;
                                event.clientY = e.originalEvent.touches[0].clientY;
                            }
                            else {
                                event.clientX = event.originalEvent.clientX;
                                event.clientY = event.originalEvent.clientY;
                            }
                        }

                        self.handlemousedown(event);
                        if (event.preventDefault) {
                            event.preventDefault();
                        }
                    }
                });

                $.jqx.mobile.touchScroll(this.element, self.max, function (left, top, dx, dy, event) {
                    if (self.host.css('visibility') == 'visible') {
                        if (event) {
                            if (self.touchMode == true) {
                                event.clientX = event.originalEvent.clientX;
                                event.clientY = event.originalEvent.clientY;
                            }
                            else {
                                var e = event;
                                if (e.originalEvent.touches && e.originalEvent.touches.length) {
                                    event.clientX = e.originalEvent.touches[0].clientX;
                                    event.clientY = e.originalEvent.touches[0].clientY;
                                }
                                else {
                                    event.clientX = event.originalEvent.clientX;
                                    event.clientY = event.originalEvent.clientY;
                                }
                            }
                        }

                        var btnThumbPressedClass = self.vertical ? self.toThemeProperty('jqx-scrollbar-thumb-state-pressed') : self.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal');
                        self.btnThumb.addClass(btnThumbPressedClass);
                        self.btnThumb.addClass(self.toThemeProperty('jqx-fill-state-pressed'));
                        self.thumbCapture = true;
                        self.element.setAttribute('touched', '');
                        self.handlemousemove(event);
                    }
                }, self.element.id, self.host, self.host);
            }


            if (!this.isTouchDevice) {
                try {
                    if (document.referrer != "" || window.frameElement) {
                        if (window.top != null && window.top != window.self) {
                            var parentLocation = null;
                            if (window.parent && document.referrer) {
                                parentLocation = document.referrer;
                            }

                            if (parentLocation && parentLocation.indexOf(document.location.host) != -1) {
                                var eventHandle = function (event) {
                                    if (!self.disabled) self.handlemouseup(self, event);
                                };

                                if (window.top.document.addEventListener) {
                                    window.top.document.addEventListener('mouseup', eventHandle, false);

                                } else if (window.top.document.attachEvent) {
                                    window.top.document.attachEvent("on" + 'mouseup', eventHandle);
                                }
                            }
                        }
                    }
                }
                catch (error) {
                }
                var eventNames = 'click mouseup mousedown';

                this.addHandler(this.btnDown, eventNames, function (event) {
                    var step = self.step;

                    if (Math.abs(self.max - self.min) <= step)
                        step = 1;

                    if (self.rtl && !self.vertical)
                        step = -self.step;

                    switch (event.type) {
                        case 'click':

                            if (self.buttonDownCapture && !self.isTouchDevice) {
                                if (!self.disabled)
                                    self.setPosition(self.value + step)
                            }
                            else if (!self.disabled && self.isTouchDevice) {
                                self.setPosition(self.value + step);
                            }
                            break;
                        case 'mouseup':
                            if (!self.btnDownInstance.base.disabled && self.buttonDownCapture) {
                                self.buttonDownCapture = false;
                                self.btnDown.removeClass(self.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                                self.btnDown.removeClass(self.toThemeProperty('jqx-fill-state-pressed'));
                                self._removeArrowClasses('pressed', 'down');
                                self.handlemouseup(self, event);

                                self.setPosition(self.value + step)
                                return false;
                            }
                            break;
                        case 'mousedown':
                            if (!self.btnDownInstance.base.disabled) {
                                self.buttonDownCapture = true;
                                self.btnDown.addClass(self.toThemeProperty('jqx-fill-state-pressed'));
                                self.btnDown.addClass(self.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                                self._addArrowClasses('pressed', 'down');
                                return false;
                            }
                            break;
                    }
                });

                this.addHandler(this.btnUp, eventNames, function (event) {
                    var step = self.step;

                    if (Math.abs(self.max - self.min) <= step)
                        step = 1;

                    if (self.rtl && !self.vertical)
                        step = -self.step;

                    switch (event.type) {
                        case 'click':
                            if (self.buttonUpCapture && !self.isTouchDevice) {
                                if (!self.disabled) {
                                    self.setPosition(self.value - step);
                                }
                            }
                            else if (!self.disabled && self.isTouchDevice) {
                                self.setPosition(self.value - step);
                            }
                            break;
                        case 'mouseup':
                            if (!self.btnUpInstance.base.disabled && self.buttonUpCapture) {
                                self.buttonUpCapture = false;
                                self.btnUp.removeClass(self.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                                self.btnUp.removeClass(self.toThemeProperty('jqx-fill-state-pressed'));
                                self._removeArrowClasses('pressed', 'up');
                                self.handlemouseup(self, event);

                                self.setPosition(self.value - step)
                                return false;
                            }
                            break;
                        case 'mousedown':
                            if (!self.btnUpInstance.base.disabled) {
                                self.buttonUpCapture = true;
                                self.btnUp.addClass(self.toThemeProperty('jqx-fill-state-pressed'));
                                self.btnUp.addClass(self.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                                self._addArrowClasses('pressed', 'up');
                                return false;
                            }
                            break;
                    }
                });
            }

            var eventName = 'click';
            if (this.isTouchDevice) {
                eventName = $.jqx.mobile.getTouchEventName('touchend');
            }

            this.addHandler(this.areaUp, eventName, function (event) {
                if (!self.disabled) {
                    var step = self.largestep;
                    if (self.rtl && !self.vertical) {
                        step = -self.largestep;
                    }

                    var canSetPosition = true;
                    var thumbOffset = self.btnThumb.offset();
                    if (!self.vertical) {
                        if (self.areaClickOffset.x >= thumbOffset.left) {
                            canSetPosition = false;
                        }
                    }
                    else {
                        if (self.areaClickOffset.y >= thumbOffset.top) {
                            canSetPosition = false;
                        }
                    }

                    if (canSetPosition) {
                        self.setPosition(self.value - step);
                    }
                    return false;
                }
            });
            this.addHandler(this.areaDown, eventName, function (event) {
                if (!self.disabled) {
                    var step = self.largestep;
                    if (self.rtl && !self.vertical) {
                        step = -self.largestep;
                    }

                    var canSetPosition = true;
                    var thumbOffset = self.btnThumb.offset();
                    if (!self.vertical) {
                        if (self.areaClickOffset.x <= thumbOffset.left) {
                            canSetPosition = false;
                        }
                    }
                    else {
                        if (self.areaClickOffset.y <= thumbOffset.top) {
                            canSetPosition = false;
                        }
                    }

                    if (canSetPosition) {
                        self.setPosition(self.value + step);
                    }
                    return false;
                }
            });
            this.addHandler(this.areaUp, 'mousedown', function (event) {
                if (!self.disabled) {
                    self.areaUpCapture = true;
                    self.areaClickOffset = { x: event.pageX, y: event.pageY };
                    return false;
                }
            });
            this.addHandler(this.areaDown, 'mousedown', function (event) {
                if (!self.disabled) {
                    self.areaDownCapture = true;
                    self.areaClickOffset = { x: event.pageX, y: event.pageY };
                    return false;
                }
            });

            this.addHandler(this.btnThumb, 'mousedown dragstart', function (event) {
                if (event.type === "dragstart")
                    return false;

                if (!self.disabled) {
                    self.handlemousedown(event);
                }
                if (event.preventDefault) {
                    event.preventDefault();
                }
            });

            this.addHandler($(document), 'mouseup.' + this.element.id, function (event) {
                if (!self.disabled) self.handlemouseup(self, event);
            });

            if (!this.isTouchDevice) {
                this.mousemoveFunc = function (event) {
                    if (!self.disabled) {
                        self.handlemousemove(event);
                    }
                }

                this.addHandler($(document), 'mousemove.' + this.element.id, this.mousemoveFunc);
                this.addHandler($(document), 'mouseleave.' + this.element.id, function (event) { if (!self.disabled) self.handlemouseleave(event); });
                this.addHandler($(document), 'mouseenter.' + this.element.id, function (event) { if (!self.disabled) self.handlemouseenter(event); });

                if (!self.disabled) {
                    this.addHandler(this.btnUp, 'mouseenter mouseleave', function (event) {
                        if (event.type === "mouseenter") {
                            if (!self.disabled && !self.btnUpInstance.base.disabled && self.touchMode != true) {
                                self.btnUp.addClass(self.toThemeProperty('jqx-scrollbar-button-state-hover'));
                                self.btnUp.addClass(self.toThemeProperty('jqx-fill-state-hover'));
                                self._addArrowClasses('hover', 'up');
                            }
                        }
                        else {
                            if (!self.disabled && !self.btnUpInstance.base.disabled && self.touchMode != true) {
                                self.btnUp.removeClass(self.toThemeProperty('jqx-scrollbar-button-state-hover'));
                                self.btnUp.removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                                self._removeArrowClasses('hover', 'up');
                            }
                        }
                    });

                    var thumbHoverClass = self.toThemeProperty('jqx-scrollbar-thumb-state-hover');
                    if (!self.vertical) {
                        thumbHoverClass = self.toThemeProperty('jqx-scrollbar-thumb-state-hover-horizontal');
                    }

                    this.addHandler(this.btnThumb, 'mouseenter mouseleave', function (event) {
                        if (event.type === "mouseenter") {
                            if (!self.disabled && self.touchMode != true) {
                                self.btnThumb.addClass(thumbHoverClass);
                                self.btnThumb.addClass(self.toThemeProperty('jqx-fill-state-hover'));
                            }
                        }
                        else {
                            if (!self.disabled && self.touchMode != true) {
                                self.btnThumb.removeClass(thumbHoverClass);
                                self.btnThumb.removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                            }
                        }
                    });

                    this.addHandler(this.btnDown, 'mouseenter mouseleave', function (event) {
                        if (event.type === "mouseenter") {
                            if (!self.disabled && !self.btnDownInstance.base.disabled && self.touchMode != true) {
                                self.btnDown.addClass(self.toThemeProperty('jqx-scrollbar-button-state-hover'));
                                self.btnDown.addClass(self.toThemeProperty('jqx-fill-state-hover'));
                                self._addArrowClasses('hover', 'down');
                            }
                        }
                        else {
                            if (!self.disabled && !self.btnDownInstance.base.disabled && self.touchMode != true) {
                                self.btnDown.removeClass(self.toThemeProperty('jqx-scrollbar-button-state-hover'));
                                self.btnDown.removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                                self._removeArrowClasses('hover', 'down');
                            }
                        }
                    });
                }
            }
        },

        destroy: function () {
            var btnUp = this.btnUp;
            var btnDown = this.btnDown;
            var btnThumb = this.btnThumb;
            var elWrap = this.scrollWrap;
            var areaUp = this.areaUp;
            var areaDown = this.areaDown;

            this.arrowUp.remove();
            delete this.arrowUp;
            this.arrowDown.remove();
            delete this.arrowDown;

            areaDown.removeClass();
            areaUp.removeClass();
            btnDown.removeClass();
            btnUp.removeClass();
            btnThumb.removeClass();

            btnUp.jqxRepeatButton('destroy');
            btnDown.jqxRepeatButton('destroy');
            areaUp.jqxRepeatButton('destroy');
            areaDown.jqxRepeatButton('destroy');
            btnThumb.jqxButton('destroy');
            var vars = $.data(this.element, "jqxScrollBar");

            this._removeHandlers();
            this.btnUp = null;
            this.btnDown = null;
            this.scrollWrap = null;
            this.areaUp = null;
            this.areaDown = null;
            this.scrollOuterWrap = null;
            delete this.mousemoveFunc;
            delete this.btnDownInstance;
            delete this.btnUpInstance;
            delete this.scrollOuterWrap;
            delete this.scrollWrap;
            delete this.btnDown;
            delete this.areaDown;
            delete this.areaUp;
            delete this.btnDown;
            delete this.btnUp;
            delete this.btnThumb;
            delete this.propertyChangeMap['value'];
            delete this.propertyChangeMap['min'];
            delete this.propertyChangeMap['max'];
            delete this.propertyChangeMap['touchMode'];
            delete this.propertyChangeMap['disabled'];
            delete this.propertyChangeMap['theme'];
            delete this.propertyChangeMap;
            if (vars) {
                delete vars.instance;
            }
            this.host.removeData();
            this.host.remove();
            delete this.host;
            delete this.set;
            delete this.get;
            delete this.call;
            delete this.element;
        },

        _removeHandlers: function () {
            this.removeHandler(this.btnUp, 'mouseenter');
            this.removeHandler(this.btnDown, 'mouseenter');
            this.removeHandler(this.btnThumb, 'mouseenter');
            this.removeHandler(this.btnUp, 'mouseleave');
            this.removeHandler(this.btnDown, 'mouseleave');
            this.removeHandler(this.btnThumb, 'mouseleave');
            this.removeHandler(this.btnUp, 'click');
            this.removeHandler(this.btnDown, 'click');
            this.removeHandler(this.btnDown, 'mouseup');
            this.removeHandler(this.btnUp, 'mouseup');
            this.removeHandler(this.btnDown, 'mousedown');
            this.removeHandler(this.btnUp, 'mousedown');
            this.removeHandler(this.areaUp, 'mousedown');
            this.removeHandler(this.areaDown, 'mousedown');
            this.removeHandler(this.areaUp, 'click');
            this.removeHandler(this.areaDown, 'click');
            this.removeHandler(this.btnThumb, 'mousedown');
            this.removeHandler(this.btnThumb, 'dragstart');
            this.removeHandler($(document), 'mouseup.' + this.element.id);
            if (!this.mousemoveFunc) {
                this.removeHandler($(document), 'mousemove.' + this.element.id);
            }
            else {
                this.removeHandler($(document), 'mousemove.' + this.element.id, this.mousemoveFunc);
            }

            this.removeHandler($(document), 'mouseleave.' + this.element.id);
            this.removeHandler($(document), 'mouseenter.' + this.element.id);
            var self = this;
        },

        _addArrowClasses: function (state, button) {
            if (state == 'pressed') state = 'selected';
            if (state != '') {
                state = '-' + state;
            }

            if (this.vertical) {
                if (button == 'up' || button == undefined) {
                    this.arrowUp.addClass(this.toThemeProperty("jqx-icon-arrow-up" + state));
                }

                if (button == 'down' || button == undefined) {
                    this.arrowDown.addClass(this.toThemeProperty("jqx-icon-arrow-down" + state));
                }
            }
            else {
                if (button == 'up' || button == undefined) {
                    this.arrowUp.addClass(this.toThemeProperty("jqx-icon-arrow-left" + state));
                }

                if (button == 'down' || button == undefined) {
                    this.arrowDown.addClass(this.toThemeProperty("jqx-icon-arrow-right" + state));
                }
            }
        },

        _removeArrowClasses: function (state, button) {
            if (state == 'pressed') state = 'selected';
            if (state != '') {
                state = '-' + state;
            }

            if (this.vertical) {
                if (button == 'up' || button == undefined) {
                    this.arrowUp.removeClass(this.toThemeProperty("jqx-icon-arrow-up" + state));
                }

                if (button == 'down' || button == undefined) {
                    this.arrowDown.removeClass(this.toThemeProperty("jqx-icon-arrow-down" + state));
                }
            }
            else {
                if (button == 'up' || button == undefined) {
                    this.arrowUp.removeClass(this.toThemeProperty("jqx-icon-arrow-left" + state));
                }

                if (button == 'down' || button == undefined) {
                    this.arrowDown.removeClass(this.toThemeProperty("jqx-icon-arrow-right" + state));
                }
            }
        },

        setTheme: function () {
            var btnUp = this.btnUp;
            var btnDown = this.btnDown;
            var btnThumb = this.btnThumb;
            var elWrap = this.scrollWrap;
            var areaUp = this.areaUp;
            var areaDown = this.areaDown;
            var arrowUp = this.arrowUp;
            var arrowDown = this.arrowDown;

            this.scrollWrap[0].className = this.toThemeProperty('jqx-reset');
            this.scrollOuterWrap[0].className = this.toThemeProperty('jqx-reset');

            var areaClassName = this.toThemeProperty('jqx-reset');
            this.areaDown[0].className = areaClassName;
            this.areaUp[0].className = areaClassName;

            var hostClass = this.toThemeProperty('jqx-scrollbar') + " " + this.toThemeProperty('jqx-widget') + " " + this.toThemeProperty('jqx-widget-content');
            this.host.addClass(hostClass);
            if (this.isTouchDevice) {
                this.host.addClass(this.toThemeProperty('jqx-scrollbar-mobile'));
            }

            btnDown[0].className = this.toThemeProperty('jqx-scrollbar-button-state-normal');
            btnUp[0].className = this.toThemeProperty('jqx-scrollbar-button-state-normal');

            var thumbClass = "";
            if (this.vertical) {
                arrowUp[0].className = areaClassName + " " + this.toThemeProperty("jqx-icon-arrow-up");
                arrowDown[0].className = areaClassName + " " + this.toThemeProperty("jqx-icon-arrow-down");
                thumbClass = this.toThemeProperty('jqx-scrollbar-thumb-state-normal');
            }
            else {
                arrowUp[0].className = areaClassName + " " + this.toThemeProperty("jqx-icon-arrow-left");
                arrowDown[0].className = areaClassName + " " + this.toThemeProperty("jqx-icon-arrow-right");
                thumbClass = this.toThemeProperty('jqx-scrollbar-thumb-state-normal-horizontal');
            }
            thumbClass += " " + this.toThemeProperty('jqx-fill-state-normal');

            btnThumb[0].className = thumbClass;

            if (this.disabled) {
                elWrap.addClass(this.toThemeProperty('jqx-fill-state-disabled'));
                elWrap.removeClass(this.toThemeProperty('jqx-scrollbar-state-normal'));
            }
            else {
                elWrap.addClass(this.toThemeProperty('jqx-scrollbar-state-normal'));
                elWrap.removeClass(this.toThemeProperty('jqx-fill-state-disabled'));
            }

            if (this.roundedCorners == 'all') {
                this.host.addClass(this.toThemeProperty('jqx-rc-all'));
                if (this.vertical) {
                    var rct = $.jqx.cssroundedcorners('top');
                    rct = this.toThemeProperty(rct);
                    btnUp.addClass(rct);

                    var rcb = $.jqx.cssroundedcorners('bottom');
                    rcb = this.toThemeProperty(rcb);
                    btnDown.addClass(rcb);

                }
                else {
                    var rcl = $.jqx.cssroundedcorners('left');
                    rcl = this.toThemeProperty(rcl);
                    btnUp.addClass(rcl);

                    var rcr = $.jqx.cssroundedcorners('right');
                    rcr = this.toThemeProperty(rcr);
                    btnDown.addClass(rcr);
                }
            }
            else {
                var rc = $.jqx.cssroundedcorners(this.roundedCorners);
                rc = this.toThemeProperty(rc);
                btnUp.addClass(rc);
                btnDown.addClass(rc);
            }

            var rc = $.jqx.cssroundedcorners(this.roundedCorners);
            rc = this.toThemeProperty(rc);
            if (!btnThumb.hasClass(rc)) {
                btnThumb.addClass(rc);
            }
            if (btnUp.css('display') === 'none') {
                this.showButtons = false;
                this.touchModeStyle = true;
                btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-normal-touch'));
            }

            if (this.isTouchDevice && this.touchModeStyle != false) {
                this.showButtons = false;
                btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-normal-touch'));
            }
        },

        // returns true, if the user is dragging the thumb or the increase or decrease button is pressed.
        isScrolling: function () {
            if (this.thumbCapture == undefined || this.buttonDownCapture == undefined || this.buttonUpCapture == undefined || this.areaDownCapture == undefined || this.areaUpCapture == undefined)
                return false;

            return this.thumbCapture || this.buttonDownCapture || this.buttonUpCapture || this.areaDownCapture || this.areaUpCapture;
        },

        track: function () {
            var now, elapsed, delta, v;

            now = Date.now();
            elapsed = now - this.timestamp;
            this.timestamp = now;
            delta = this.offset - this.frame;
            this.frame = this.offset;
            v = 1000 * delta / (1 + elapsed);
            this.velocity = 0.2 * v + 0.2 * this.velocity;
        },

        handlemousedown: function (event) {
            if (this.thumbCapture == undefined || this.thumbCapture == false) {
                this.thumbCapture = true;
                var btnThumb = this.btnThumb;
                if (btnThumb != null) {
                    btnThumb.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                    if (this.vertical) {
                        btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-pressed'));
                    }
                    else {
                        btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal'));
                    }
                    this.element.setAttribute('touched', '');
                }
            }

            var that = this;
            function tap(e) {
                that.reference = parseInt(that.btnThumb[0].style.top);
                that.offset = parseInt(that.btnThumb[0].style.top);
                if (!that.vertical) {
                    that.reference = parseInt(that.btnThumb[0].style.left);
                    that.offset = parseInt(that.btnThumb[0].style.left);
                }

                that.velocity = that.amplitude = 0;
                that.frame = that.offset;
                that.timestamp = Date.now();
                clearInterval(that.ticker);
                that.ticker = setInterval(function () {
                    that.track();
                }, 100);
            }
            if (this.thumbCapture && $.jqx.scrollAnimation) {
                tap(event);
            }
            this.dragStartX = event.clientX;
            this.dragStartY = event.clientY;
            this.dragStartValue = this.value;
        },

        toggleHover: function (event, element) {
            //element.toggleClass('jqx-fill-state-hover');
        },

        refresh: function () {
            this._arrange();
        },

        _setElementPosition: function (element, x, y) {
            if (!isNaN(x)) {
                if (parseInt(element[0].style.left) != parseInt(x)) {
                    element[0].style.left = x + 'px';
                }
            }
            if (!isNaN(y)) {
                if (parseInt(element[0].style.top) != parseInt(y)) {
                    element[0].style.top = y + 'px';
                }
            }
        },

        _setElementTopPosition: function (element, y) {
            if (!isNaN(y)) {
                element[0].style.top = y + 'px';
            }
        },

        _setElementLeftPosition: function (element, x) {
            if (!isNaN(x)) {
                element[0].style.left = x + 'px';
            }
        },

        handlemouseleave: function (event) {
            var btnUp = this.btnUp;
            var btnDown = this.btnDown;

            if (this.buttonDownCapture || this.buttonUpCapture) {
                btnUp.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                btnDown.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                this._removeArrowClasses('pressed');
            }

            if (this.thumbCapture != true)
                return;

            var btnThumb = this.btnThumb;
            var btnThumbPressedClass = this.vertical ? this.toThemeProperty('jqx-scrollbar-thumb-state-pressed') : this.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal');
            btnThumb.removeClass(btnThumbPressedClass);
            btnThumb.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
            this.element.removeAttribute('touched');
        },

        handlemouseenter: function (event) {
            var btnUp = this.btnUp;
            var btnDown = this.btnDown;

            if (this.buttonUpCapture) {
                btnUp.addClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                btnUp.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this._addArrowClasses('pressed', 'up');
                this.element.setAttribute('touched', '');
            }

            if (this.buttonDownCapture) {
                btnDown.addClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                btnDown.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this._addArrowClasses('pressed', 'down');
                this.element.setAttribute('touched', '');
            }

            if (this.thumbCapture != true)
                return;

            var btnThumb = this.btnThumb;
            if (this.vertical) {
                btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-pressed'));
            }
            else {
                btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal'));
            }
            btnThumb.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
            this.element.setAttribute('touched', '');
        },

        handlemousemove: function (event) {
            var btnUp = this.btnUp;
            var btnDown = this.btnDown;
            var which = 0;

            if (btnDown == null || btnUp == null)
                return;

            if (btnUp != null && btnDown != null && this.buttonDownCapture != undefined && this.buttonUpCapture != undefined) {
                if (this.buttonDownCapture && event.which == which) {
                    btnDown.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                    btnDown.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                    this._removeArrowClasses('pressed', 'down');

                    this.buttonDownCapture = false;
                }
                else if (this.buttonUpCapture && event.which == which) {
                    btnUp.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                    btnUp.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                    this._removeArrowClasses('pressed', 'up');
                    this.buttonUpCapture = false;
                }
            }

            if (this.thumbCapture != true)
                return false;

            var btnThumb = this.btnThumb;

            if (event.which == which && !this.isTouchDevice && !this._touchSupport) {
                this.thumbCapture = false;
                this._arrange();
                var btnThumbPressedClass = this.vertical ? this.toThemeProperty('jqx-scrollbar-thumb-state-pressed') : this.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal');
                btnThumb.removeClass(btnThumbPressedClass);
                btnThumb.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                return true;
            }

            if (event.preventDefault != undefined) {
                event.preventDefault();
            }

            if (event.originalEvent != null) {
                event.originalEvent.mouseHandled = true;
            }

            if (event.stopPropagation != undefined) {
                event.stopPropagation();
            }

            var diff = 0;

            try {
                if (!this.vertical) {
                    diff = event.clientX - this.dragStartX;
                }
                else {
                    diff = event.clientY - this.dragStartY;
                }

                var btnAndThumbSize = this._btnAndThumbSize;
                if (!this._btnAndThumbSize) {
                    btnAndThumbSize = (this.vertical) ?
                        btnUp.height() + btnDown.height() + btnThumb.height() :
                        btnUp.width() + btnDown.width() + btnThumb.width();
                }

                var ratio = (this.max - this.min) / (this.scrollBarSize - btnAndThumbSize);
                if (this.thumbStep == 'auto') {
                    diff *= ratio;
                }
                else {
                    diff *= ratio;
                    if (Math.abs(this.dragStartValue + diff - this.value) >= parseInt(this.thumbStep)) {
                        var step = Math.round(parseInt(diff) / this.thumbStep) * this.thumbStep;
                        if (this.rtl && !this.vertical) {
                            this.setPosition(this.dragStartValue - step);
                        }
                        else {
                            this.setPosition(this.dragStartValue + step);
                        }
                        return false;
                    }
                    else {
                        return false;
                    }
                }

                var step = diff;
                if (this.rtl && !this.vertical) {
                    step = -diff;
                }

                this.setPosition(this.dragStartValue + step);
                this.offset = parseInt(btnThumb[0].style.left);
                if (this.vertical) {
                    this.offset = parseInt(btnThumb[0].style.top);
                }
            }
            catch (error) {
                alert(error);
            }

            return false;
        },

        handlemouseup: function (self, event) {
            var prevent = false;

            if (this.thumbCapture) {
                this.thumbCapture = false;

                var btnThumb = this.btnThumb;
                var btnThumbPressedClass = this.vertical ? this.toThemeProperty('jqx-scrollbar-thumb-state-pressed') : this.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal');
                btnThumb.removeClass(btnThumbPressedClass);
                btnThumb.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this.element.removeAttribute('touched');

                prevent = true;
                this._mouseup = new Date();
                if ($.jqx.scrollAnimation) {
                    var that = this;
                    function autoScroll() {
                        var elapsed, delta;
                        if (that.amplitude) {
                            elapsed = Date.now() - that.timestamp;
                            delta = -that.amplitude * Math.exp(-elapsed / 325);
                            if (delta > 0.5 || delta < -0.5) {
                                var ratio = (that.max - that.min) / (that.scrollBarSize - that._btnAndThumbSize);
                                var newValue = ratio * (that.target + delta)
                                var step = newValue;
                                if (that.rtl && !that.vertical) {
                                    step = -newValue;
                                }

                                that.setPosition(that.dragStartValue + step);
                                requestAnimationFrame(autoScroll);
                            } else {
                                var ratio = (that.max - that.min) / (that.scrollBarSize - that._btnAndThumbSize);
                                var newValue = ratio * (that.target + delta)
                                var step = newValue;
                                if (that.rtl && !that.vertical) {
                                    step = -newValue;
                                }

                                that.setPosition(that.dragStartValue + step);
                            }
                        }
                    }
                    clearInterval(this.ticker);
                    if (this.velocity > 25 || this.velocity < -25) {
                        this.amplitude = 0.8 * this.velocity;
                        this.target = Math.round(this.offset + this.amplitude);
                        if (!this.vertical) {
                            this.target -= this.reference;
                        }
                        else {
                            this.target -= this.reference;
                        }

                        this.timestamp = Date.now();
                        requestAnimationFrame(autoScroll);
                    }
                }
            }

            this.areaDownCapture = this.areaUpCapture = false;
            if (this.buttonUpCapture || this.buttonDownCapture) {
                var btnUp = this.btnUp;
                var btnDown = this.btnDown;

                this.buttonUpCapture = false;
                this.buttonDownCapture = false;
                btnUp.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                btnDown.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                btnUp.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                btnDown.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this._removeArrowClasses('pressed');
                this.element.removeAttribute('touched');

                prevent = true;
                this._mouseup = new Date();
            }

            if (prevent) {
                if (event.preventDefault != undefined) {
                    event.preventDefault();
                }

                if (event.originalEvent != null) {
                    event.originalEvent.mouseHandled = true;
                }

                if (event.stopPropagation != undefined) {
                    event.stopPropagation();
                }
            }
        },

        // sets the value.
        // @param Number. Sets the ScrollBar's value.
        setPosition: function (position, update) {
            var element = this.element;

            if (position == undefined || position == NaN)
                position = this.min;

            if (position >= this.max) {
                position = this.max;
            }

            if (position < this.min) {
                position = this.min;
            }

            if (this.value !== position || update == true) {
                if (position == this.max) {
                    var completeEvent = new $.Event('complete');
                    this.host.trigger(completeEvent);
                }
                var oldvalue = this.value;
                if (this._triggervaluechanged) {
                    var event = new $.Event('valueChanged');
                    event.previousValue = this.value;
                    event.currentValue = position;
                }

                this.value = position;
                this._positionelements();
                //this._arrange();

                if (this._triggervaluechanged) {
                    this.host.trigger(event);
                }

                if (this.valueChanged) {
                    this.valueChanged({ currentValue: this.value, previousvalue: oldvalue });
                }
            }

            return position;
        },

        val: function (value) {
            var isEmpty = function (obj) {
                for (var key in obj) {
                    if (obj.hasOwnProperty(key))
                        return false;
                }
                if (typeof value == "number")
                    return false;
                if (typeof value == "date")
                    return false;
                if (typeof value == "boolean")
                    return false;
                if (typeof value == "string")
                    return false;

                return true;
            }
            if (isEmpty(value) || arguments.length == 0) {
                return this.value;
            }
            else {
                this.setPosition(value);
                return value;
            }
        },

        _getThumbSize: function (scrollAreaSize) {
            var positions = this.max - this.min;

            var size = 0;
            if (positions > 1) {
                size = (scrollAreaSize / (positions + scrollAreaSize) * scrollAreaSize);
            }
            else if (positions == 1) {
                size = scrollAreaSize - 1;
            }
            else if (positions == 0)
                size = scrollAreaSize;

            if (this.thumbSize > 0) {
                size = this.thumbSize;
            }

            if (size < this.thumbMinSize)
                size = this.thumbMinSize;

            return Math.min(size, scrollAreaSize);
        },

        _positionelements: function () {
            var element = this.element;
            var elAreaUp = this.areaUp;
            var elAreaDown = this.areaDown;
            var elBtnUp = this.btnUp;
            var elBtnDown = this.btnDown;
            var elThumb = this.btnThumb;
            var elWrap = this.scrollWrap;

            var height = this._height ? this._height : this.host.height();
            var width = this._width ? this._width : this.host.width();

            var btnSize = (!this.vertical) ? height : width;
            if (!this.showButtons) {
                btnSize = 0;
            }

            var scrollBarSize = (!this.vertical) ? width : height;
            this.scrollBarSize = scrollBarSize;
            var thumbSize = this._getThumbSize(scrollBarSize - 2 * btnSize);
            thumbSize = Math.floor(thumbSize);

            if (thumbSize < this.thumbMinSize)
                thumbSize = this.thumbMinSize;

            if (height == NaN || height < 10)
                height = 10;

            if (width == NaN || width < 10)
                width = 10;

            btnSize += 2;
            this.btnSize = btnSize;

            var btnAndThumbSize = this._btnAndThumbSize;

            if (!this._btnAndThumbSize) {
                var btnAndThumbSize = (this.vertical) ?
                    2 * this.btnSize + elThumb.outerHeight() :
                    2 * this.btnSize + elThumb.outerWidth();

                btnAndThumbSize = Math.round(btnAndThumbSize);
            }

            var upAreaSize = (scrollBarSize - btnAndThumbSize) / (this.max - this.min) * (this.value - this.min);
            if (this.rtl && !this.vertical) {
                upAreaSize = (scrollBarSize - btnAndThumbSize) / (this.max - this.min) * (this.max - this.value - this.min);
            }

            upAreaSize = Math.round(upAreaSize);
            if (upAreaSize < 0) {
                upAreaSize = 0;
            }
            if (this.vertical) {
                var newDownSize = scrollBarSize - upAreaSize - btnAndThumbSize;
                if (newDownSize < 0) newDownSize = 0;
                elAreaDown[0].style.height = newDownSize + 'px';
                elAreaUp[0].style.height = upAreaSize + 'px';

                this._setElementTopPosition(elAreaUp, btnSize);
                this._setElementTopPosition(elThumb, btnSize + upAreaSize);
                this._setElementTopPosition(elAreaDown, btnSize + upAreaSize + thumbSize);
            }
            else {
                elAreaUp[0].style.width = upAreaSize + 'px';
                if (scrollBarSize - upAreaSize - btnAndThumbSize >= 0) {
                    elAreaDown[0].style.width = scrollBarSize - upAreaSize - btnAndThumbSize + 'px';
                }
                else {
                    elAreaDown[0].style.width = '0px';
                }

                this._setElementLeftPosition(elAreaUp, btnSize);
                this._setElementLeftPosition(elThumb, btnSize + upAreaSize);
                this._setElementLeftPosition(elAreaDown, 2 + btnSize + upAreaSize + thumbSize);
            }
        },

        _arrange: function () {
            var self = this;
            if (self._initialLayout) {
                self._initialLayout = false;
                return;
            }

            if (self.min > self.max) {
                var tmp = self.min;
                self.min = self.max;
                self.max = tmp;
            }

            if (self.min < 0) {
                var diff = self.max - self.min;
                self.min = 0;
                self.max = diff;
            }

            var element = self.element;
            var elAreaUp = self.areaUp;
            var elAreaDown = self.areaDown;
            var elBtnUp = self.btnUp;
            var elBtnDown = self.btnDown;
            var elThumb = self.btnThumb;
            var elWrap = self.scrollWrap;

            var height = parseInt(self.element.style.height);
            var width = parseInt(self.element.style.width);
            if (self.isPercentage) {
                var height = self.host.height();
                var width = self.host.width();
            }

            if (isNaN(height)) height = 0;
            if (isNaN(width)) width = 0;

            self._width = width;
            self._height = height;
            var btnSize = (!self.vertical) ? height : width;
            if (!self.showButtons) {
                btnSize = 0;
            }

            elBtnUp[0].style.width = btnSize + 'px';
            elBtnUp[0].style.height = btnSize + 'px';
            elBtnDown[0].style.width = btnSize + 'px';
            elBtnDown[0].style.height = btnSize + 'px';

            if (self.vertical) {
                elWrap[0].style.width = width + 2 + 'px';
            }
            else {
                elWrap[0].style.height = height + 2 + 'px';
            }

            // position the up button
            self._setElementPosition(elBtnUp, 0, 0);

            var btnSizeAndBorder = btnSize + 2;

            // position the down button
            if (self.vertical) {
                self._setElementPosition(elBtnDown, 0, height - btnSizeAndBorder);
            }
            else {
                self._setElementPosition(elBtnDown, width - btnSizeAndBorder, 0);
            }

            var scrollBarSize = (!self.vertical) ? width : height;
            self.scrollBarSize = scrollBarSize;
            var thumbSize = self._getThumbSize(scrollBarSize - 2 * btnSizeAndBorder);
            thumbSize = Math.floor(thumbSize - 2);

            if (thumbSize < self.thumbMinSize)
                thumbSize = self.thumbMinSize;

            var touchStyle = false;
            if (self.isTouchDevice && self.touchModeStyle != false) {
                touchStyle = true;
            }

            if (!self.vertical) {
                elThumb[0].style.width = thumbSize + 'px';
                elThumb[0].style.height = height + 'px';
                if (touchStyle && self.thumbTouchSize !== 0) {
                    elThumb.css({ height: self.thumbTouchSize + 'px' });
                    elThumb.css('margin-top', (self.host.height() - self.thumbTouchSize) / 2);
                }
            }
            else {
                elThumb[0].style.width = width + 'px';
                elThumb[0].style.height = thumbSize + 'px';

                if (touchStyle && self.thumbTouchSize !== 0) {
                    elThumb.css({ width: self.thumbTouchSize + 'px' });
                    elThumb.css('margin-left', (self.host.width() - self.thumbTouchSize) / 2);
                }
            }

            if (height == NaN || height < 10)
                height = 10;

            if (width == NaN || width < 10)
                width = 10;

            //btnSize += 2;
            self.btnSize = btnSize;

            var btnAndThumbSize = (self.vertical) ?
                2 * btnSizeAndBorder + (2 + parseInt(elThumb[0].style.height)) :
                2 * btnSizeAndBorder + (2 + parseInt(elThumb[0].style.width));

            btnAndThumbSize = Math.round(btnAndThumbSize);
            self._btnAndThumbSize = btnAndThumbSize;

            var upAreaSize = (scrollBarSize - btnAndThumbSize) / (self.max - self.min) * (self.value - self.min);
            if (self.rtl && !self.vertical)
                upAreaSize = (scrollBarSize - btnAndThumbSize) / (self.max - self.min) * (self.max - self.value - self.min);

            upAreaSize = Math.round(upAreaSize);

            if (isNaN(upAreaSize) || upAreaSize < 0 || upAreaSize === -Infinity || upAreaSize === Infinity)
                upAreaSize = 0;

            if (self.vertical) {
                var newAreaHeight = (scrollBarSize - upAreaSize - btnAndThumbSize);
                if (newAreaHeight < 0)
                    newAreaHeight = 0;

                elAreaDown[0].style.height = newAreaHeight + 'px';
                elAreaDown[0].style.width = width + 'px';
                elAreaUp[0].style.height = upAreaSize + 'px';
                elAreaUp[0].style.width = width + 'px';

                var hostHeight = parseInt(self.element.style.height);
                if (self.isPercentage)
                    hostHeight = self.host.height();

                elThumb[0].style.visibility = 'inherit';

                if (hostHeight - 3 * parseInt(btnSize) < 0 || hostHeight < btnAndThumbSize)
                    elThumb[0].style.visibility = 'hidden';

                self._setElementPosition(elAreaUp, 0, btnSizeAndBorder);
                self._setElementPosition(elThumb, 0, btnSizeAndBorder + upAreaSize);
                self._setElementPosition(elAreaDown, 0, btnSizeAndBorder + upAreaSize + thumbSize);
            }
            else {
                if (upAreaSize > 0) {
                    elAreaUp[0].style.width = upAreaSize + 'px';
                }
                if (height > 0) {
                    elAreaUp[0].style.height = height + 'px';
                }

                var newAreaWidth = (scrollBarSize - upAreaSize - btnAndThumbSize);
                if (newAreaWidth < 0)
                    newAreaWidth = 0;

                elAreaDown[0].style.width = newAreaWidth + 'px';
                elAreaDown[0].style.height = height + 'px';

                var hostWidth = parseInt(self.element.style.width);
                if (self.isPercentage)
                    hostWidth = self.host.width();

                elThumb[0].style.visibility = 'inherit';
                if ((hostWidth - 3 * parseInt(btnSize) < 0) || (hostWidth < btnAndThumbSize))
                    elThumb[0].style.visibility = 'hidden';

                self._setElementPosition(elAreaUp, btnSizeAndBorder, 0);
                self._setElementPosition(elThumb, btnSizeAndBorder + upAreaSize, 0);
                self._setElementPosition(elAreaDown, btnSizeAndBorder + upAreaSize + thumbSize, 0);
            }
        }
    }); // jqxScrollBar
})(jqxBaseFramework);
})();




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/* harmony import */ var _jqxcore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5459);
/* harmony import */ var _jqxcore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jqxcore__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jqxdata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4198);
/* harmony import */ var _jqxdata__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jqxdata__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jqxdata_export__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3907);
/* harmony import */ var _jqxdata_export__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jqxdata_export__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jqxexport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(714);
/* harmony import */ var _jqxexport__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jqxexport__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jqxbuttons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7351);
/* harmony import */ var _jqxbuttons__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jqxbuttons__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _jqxbuttongroup__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7196);
/* harmony import */ var _jqxbuttongroup__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_jqxbuttongroup__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _jqxscrollbar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4240);
/* harmony import */ var _jqxscrollbar__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_jqxscrollbar__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _jqxmenu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1610);
/* harmony import */ var _jqxmenu__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_jqxmenu__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _jqxlistbox__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1062);
/* harmony import */ var _jqxlistbox__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_jqxlistbox__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _jqxdropdownlist__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(5868);
/* harmony import */ var _jqxdropdownlist__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_jqxdropdownlist__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _jqxcombobox__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(4720);
/* harmony import */ var _jqxcombobox__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_jqxcombobox__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _jqxnumberinput__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(7995);
/* harmony import */ var _jqxnumberinput__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_jqxnumberinput__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _jqxformattedinput__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(1282);
/* harmony import */ var _jqxformattedinput__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_jqxformattedinput__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _globalization_globalize__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(2497);
/* harmony import */ var _globalization_globalize__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_globalization_globalize__WEBPACK_IMPORTED_MODULE_13__);














})();

/******/ })()
;