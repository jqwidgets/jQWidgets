
/* Release Date: Sep-17-2024 
Copyright (c) 2011-2024 jQWidgets. 
License: https://jqwidgets.com/license/ */


/******/ (() => { // webpackBootstrap
var __webpack_exports__ = {};

/* Release Date: Sep-17-2024 
Copyright (c) 2011-2024 jQWidgets. 
License: https://jqwidgets.com/license/ */


/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 2497:
/***/ ((module) => {

/* tslint:disable */
/* eslint-disable */
/* tslint:disable */
/* eslint-disable */
(function() {
	if (typeof document === 'undefined') { 
		return;
	}
/*!
 * Globalize
 *
 * http://github.com/jquery/globalize
 *
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */

(function( window, undefined ) {
if (document.Globalize) {
    return;
}

var Globalize,
	// private variables
	regexHex,
	regexInfinity,
	regexParseFloat,
	regexTrim,
	// private JavaScript utility functions
	arrayIndexOf,
	endsWith,
	extend,
	isArray,
	isFunction,
	isObject,
	startsWith,
	trim,
	truncate,
	zeroPad,
	// private Globalization utility functions
	appendPreOrPostMatch,
	expandFormat,
	formatDate,
	formatNumber,
	getTokenRegExp,
	getEra,
	getEraYear,
	parseExact,
	parseNegativePattern;

// Global variable (Globalize) or CommonJS module (globalize)
Globalize = function( cultureSelector ) {
	return new Globalize.prototype.init( cultureSelector );
};

if ( true ) {
	// Assume CommonJS
	module.exports = Globalize;
} else {}

Globalize.cultures = {};

Globalize.prototype = {
	constructor: Globalize,
	init: function( cultureSelector ) {
		this.cultures = Globalize.cultures;
		this.cultureSelector = cultureSelector;

		return this;
	}
};
Globalize.prototype.init.prototype = Globalize.prototype;

// 1. When defining a culture, all fields are required except the ones stated as optional.
// 2. Each culture should have a ".calendars" object with at least one calendar named "standard"
//    which serves as the default calendar in use by that culture.
// 3. Each culture should have a ".calendar" object which is the current calendar being used,
//    it may be dynamically changed at any time to one of the calendars in ".calendars".
Globalize.cultures[ "default" ] = {
	// A unique name for the culture in the form <language code>-<country/region code>
	name: "en",
	// the name of the culture in the english language
	englishName: "English",
	// the name of the culture in its own language
	nativeName: "English",
	// whether the culture uses right-to-left text
	isRTL: false,
	// "language" is used for so-called "specific" cultures.
	// For example, the culture "es-CL" means "Spanish, in Chili".
	// It represents the Spanish-speaking culture as it is in Chili,
	// which might have different formatting rules or even translations
	// than Spanish in Spain. A "neutral" culture is one that is not
	// specific to a region. For example, the culture "es" is the generic
	// Spanish culture, which may be a more generalized version of the language
	// that may or may not be what a specific culture expects.
	// For a specific culture like "es-CL", the "language" field refers to the
	// neutral, generic culture information for the language it is using.
	// This is not always a simple matter of the string before the dash.
	// For example, the "zh-Hans" culture is netural (Simplified Chinese).
	// And the "zh-SG" culture is Simplified Chinese in Singapore, whose lanugage
	// field is "zh-CHS", not "zh".
	// This field should be used to navigate from a specific culture to it's
	// more general, neutral culture. If a culture is already as general as it
	// can get, the language may refer to itself.
	language: "en",
	// numberFormat defines general number formatting rules, like the digits in
	// each grouping, the group separator, and how negative numbers are displayed.
	numberFormat: {
		// [negativePattern]
		// Note, numberFormat.pattern has no "positivePattern" unlike percent and currency,
		// but is still defined as an array for consistency with them.
		//   negativePattern: one of "(n)|-n|- n|n-|n -"
		pattern: [ "-n" ],
		// number of decimal places normally shown
		decimals: 2,
		// string that separates number groups, as in 1,000,000
		",": ",",
		// string that separates a number from the fractional portion, as in 1.99
		".": ".",
		// array of numbers indicating the size of each number group.
		// TODO: more detailed description and example
		groupSizes: [ 3 ],
		// symbol used for positive numbers
		"+": "+",
		// symbol used for negative numbers
		"-": "-",
		// symbol used for NaN (Not-A-Number)
		"NaN": "NaN",
		// symbol used for Negative Infinity
		negativeInfinity: "-Infinity",
		// symbol used for Positive Infinity
		positiveInfinity: "Infinity",
		percent: {
			// [negativePattern, positivePattern]
			//   negativePattern: one of "-n %|-n%|-%n|%-n|%n-|n-%|n%-|-% n|n %-|% n-|% -n|n- %"
			//   positivePattern: one of "n %|n%|%n|% n"
			pattern: [ "-n %", "n %" ],
			// number of decimal places normally shown
			decimals: 2,
			// array of numbers indicating the size of each number group.
			// TODO: more detailed description and example
			groupSizes: [ 3 ],
			// string that separates number groups, as in 1,000,000
			",": ",",
			// string that separates a number from the fractional portion, as in 1.99
			".": ".",
			// symbol used to represent a percentage
			symbol: "%"
		},
		currency: {
			// [negativePattern, positivePattern]
			//   negativePattern: one of "($n)|-$n|$-n|$n-|(n$)|-n$|n-$|n$-|-n $|-$ n|n $-|$ n-|$ -n|n- $|($ n)|(n $)"
			//   positivePattern: one of "$n|n$|$ n|n $"
			pattern: [ "($n)", "$n" ],
			// number of decimal places normally shown
			decimals: 2,
			// array of numbers indicating the size of each number group.
			// TODO: more detailed description and example
			groupSizes: [ 3 ],
			// string that separates number groups, as in 1,000,000
			",": ",",
			// string that separates a number from the fractional portion, as in 1.99
			".": ".",
			// symbol used to represent currency
			symbol: "$"
		}
	},
	// calendars defines all the possible calendars used by this culture.
	// There should be at least one defined with name "standard", and is the default
	// calendar used by the culture.
	// A calendar contains information about how dates are formatted, information about
	// the calendar's eras, a standard set of the date formats,
	// translations for day and month names, and if the calendar is not based on the Gregorian
	// calendar, conversion functions to and from the Gregorian calendar.
	calendars: {
		standard: {
			// name that identifies the type of calendar this is
			name: "Gregorian_USEnglish",
			// separator of parts of a date (e.g. "/" in 11/05/1955)
			"/": "/",
			// separator of parts of a time (e.g. ":" in 05:44 PM)
			":": ":",
			// the first day of the week (0 = Sunday, 1 = Monday, etc)
			firstDay: 0,
			days: {
				// full day names
				names: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
				// abbreviated day names
				namesAbbr: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
				// shortest day names
				namesShort: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ]
			},
			months: {
				// full month names (13 months for lunar calendards -- 13th month should be "" if not lunar)
				names: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", "" ],
				// abbreviated month names
				namesAbbr: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "" ]
			},
			// AM and PM designators in one of these forms:
			// The usual view, and the upper and lower case versions
			//   [ standard, lowercase, uppercase ]
			// The culture does not use AM or PM (likely all standard date formats use 24 hour time)
			//   null
			AM: [ "AM", "am", "AM" ],
			PM: [ "PM", "pm", "PM" ],
			eras: [
				// eras in reverse chronological order.
				// name: the name of the era in this culture (e.g. A.D., C.E.)
				// start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
				// offset: offset in years from gregorian calendar
				{
					"name": "A.D.",
					"start": null,
					"offset": 0
				}
			],
			// when a two digit year is given, it will never be parsed as a four digit
			// year greater than this year (in the appropriate era for the culture)
			// Set it as a full year (e.g. 2029) or use an offset format starting from
			// the current year: "+19" would correspond to 2029 if the current year 2010.
			twoDigitYearMax: 2029,
			// set of predefined date and time patterns used by the culture
			// these represent the format someone in this culture would expect
			// to see given the portions of the date that are shown.
			patterns: {
				// short date pattern
				d: "M/d/yyyy",
				// long date pattern
				D: "dddd, MMMM dd, yyyy",
				// short time pattern
				t: "h:mm tt",
				// long time pattern
				T: "h:mm:ss tt",
				// long date, short time pattern
				f: "dddd, MMMM dd, yyyy h:mm tt",
				// long date, long time pattern
				F: "dddd, MMMM dd, yyyy h:mm:ss tt",
				// month/day pattern
				M: "MMMM dd",
				// month/year pattern
				Y: "yyyy MMMM",
				// S is a sortable format that does not vary by culture
				S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss"
			}
			// optional fields for each calendar:
			/*
			monthsGenitive:
				Same as months but used when the day preceeds the month.
				Omit if the culture has no genitive distinction in month names.
				For an explaination of genitive months, see http://blogs.msdn.com/michkap/archive/2004/12/25/332259.aspx
			convert:
				Allows for the support of non-gregorian based calendars. This convert object is used to
				to convert a date to and from a gregorian calendar date to handle parsing and formatting.
				The two functions:
					fromGregorian( date )
						Given the date as a parameter, return an array with parts [ year, month, day ]
						corresponding to the non-gregorian based year, month, and day for the calendar.
					toGregorian( year, month, day )
						Given the non-gregorian year, month, and day, return a new Date() object
						set to the corresponding date in the gregorian calendar.
			*/
		}
	},
	// For localized strings
	messages: {}
};

Globalize.cultures[ "default" ].calendar = Globalize.cultures[ "default" ].calendars.standard;

Globalize.cultures.en = Globalize.cultures[ "default" ];

Globalize.cultureSelector = "en";

//
// private variables
//

regexHex = /^0x[a-f0-9]+$/i;
regexInfinity = /^[+\-]?infinity$/i;
regexParseFloat = /^[+\-]?\d*\.?\d*(e[+\-]?\d+)?$/;
regexTrim = /^\s+|\s+$/g;

//
// private JavaScript utility functions
//

arrayIndexOf = function( array, item ) {
	if ( array.indexOf ) {
		return array.indexOf( item );
	}
	for ( var i = 0, length = array.length; i < length; i++ ) {
		if ( array[i] === item ) {
			return i;
		}
	}
	return -1;
};

endsWith = function( value, pattern ) {
	return value.substr( value.length - pattern.length ) === pattern;
};

extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction(target) ) {
		target = {};
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( isObject(copy) || (copyIsArray = isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && isArray(src) ? src : [];

					} else {
						clone = src && isObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

isArray = Array.isArray || function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Array]";
};

isFunction = function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Function]";
};

isObject = function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Object]";
};

startsWith = function( value, pattern ) {
	return value.indexOf( pattern ) === 0;
};

trim = function( value ) {
	return ( value + "" ).replace( regexTrim, "" );
};

truncate = function( value ) {
	if ( isNaN( value ) ) {
		return NaN;
	}
	return Math[ value < 0 ? "ceil" : "floor" ]( value );
};

zeroPad = function( str, count, left ) {
	var l;
	for ( l = str.length; l < count; l += 1 ) {
		str = ( left ? ("0" + str) : (str + "0") );
	}
	return str;
};

//
// private Globalization utility functions
//

appendPreOrPostMatch = function( preMatch, strings ) {
	// appends pre- and post- token match strings while removing escaped characters.
	// Returns a single quote count which is used to determine if the token occurs
	// in a string literal.
	var quoteCount = 0,
		escaped = false;
	for ( var i = 0, il = preMatch.length; i < il; i++ ) {
		var c = preMatch.charAt( i );
		switch ( c ) {
			case "\'":
				if ( escaped ) {
					strings.push( "\'" );
				}
				else {
					quoteCount++;
				}
				escaped = false;
				break;
			case "\\":
				if ( escaped ) {
					strings.push( "\\" );
				}
				escaped = !escaped;
				break;
			default:
				strings.push( c );
				escaped = false;
				break;
		}
	}
	return quoteCount;
};

expandFormat = function( cal, format ) {
	// expands unspecified or single character date formats into the full pattern.
	format = format || "F";
	var pattern,
		patterns = cal.patterns,
		len = format.length;
	if ( len === 1 ) {
		pattern = patterns[ format ];
		if ( !pattern ) {
			throw "Invalid date format string \'" + format + "\'.";
		}
		format = pattern;
	}
	else if ( len === 2 && format.charAt(0) === "%" ) {
		// %X escape format -- intended as a custom format string that is only one character, not a built-in format.
		format = format.charAt( 1 );
	}
	return format;
};

formatDate = function( value, format, culture ) {
	var cal = culture.calendar,
		convert = cal.convert,
		ret;

	if ( !format || !format.length || format === "i" ) {
		if ( culture && culture.name.length ) {
			if ( convert ) {
				// non-gregorian calendar, so we cannot use built-in toLocaleString()
				ret = formatDate( value, cal.patterns.F, culture );
			}
			else {
				var eraDate = new Date( value.getTime() ),
					era = getEra( value, cal.eras );
				eraDate.setFullYear( getEraYear(value, cal, era) );
				ret = eraDate.toLocaleString();
			}
		}
		else {
			ret = value.toString();
		}
		return ret;
	}

	var eras = cal.eras,
		sortable = format === "s";
	format = expandFormat( cal, format );

	// Start with an empty string
	ret = [];
	var hour,
		zeros = [ "0", "00", "000" ],
		foundDay,
		checkedDay,
		dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,
		quoteCount = 0,
		tokenRegExp = getTokenRegExp(),
		converted;

	//function padZeros( num, c ) {
	//	var r, s = num + "";
	//	if ( c > 1 && s.length < c ) {
	//		r = ( zeros[c - 2] + s);
	//		return r.substr( r.length - c, c );
	//	}
	//	else {
	//		r = s;
	//	}
	//	return r;
	//}

	function padZeros(num, c) {
	    if (num < 0) {
	        return "-" + padZeros(-num, c);
	    }
	    var r, s = num + "";
	    if (c > 1 && s.length < c) {
	        r = (zeros[c - 2] + s);
	        return r.substr(r.length - c, c);
	    }
	    else {
	        r = s;
	    }
	    return r;
	}

	function hasDay() {
		if ( foundDay || checkedDay ) {
			return foundDay;
		}
		foundDay = dayPartRegExp.test( format );
		checkedDay = true;
		return foundDay;
	}

	function getPart( date, part ) {
		if ( converted ) {
			return converted[ part ];
		}
		switch ( part ) {
			case 0:
				return date.getFullYear();
			case 1:
				return date.getMonth();
			case 2:
				return date.getDate();
			default:
				throw "Invalid part value " + part;
		}
	}

	if ( !sortable && convert ) {
		converted = convert.fromGregorian( value );
	}

	for ( ; ; ) {
		// Save the current index
		var index = tokenRegExp.lastIndex,
			// Look for the next pattern
			ar = tokenRegExp.exec( format );

		// Append the text before the pattern (or the end of the string if not found)
		var preMatch = format.slice( index, ar ? ar.index : format.length );
		quoteCount += appendPreOrPostMatch( preMatch, ret );

		if ( !ar ) {
			break;
		}

		// do not replace any matches that occur inside a string literal.
		if ( quoteCount % 2 ) {
			ret.push( ar[0] );
			continue;
		}

		var current = ar[ 0 ],
			clength = current.length;

		switch ( current ) {
			case "ddd":
				//Day of the week, as a three-letter abbreviation
			case "dddd":
				// Day of the week, using the full name
				var names = ( clength === 3 ) ? cal.days.namesAbbr : cal.days.names;
				ret.push( names[value.getDay()] );
				break;
			case "d":
				// Day of month, without leading zero for single-digit days
			case "dd":
				// Day of month, with leading zero for single-digit days
				foundDay = true;
				ret.push(
					padZeros( getPart(value, 2), clength )
				);
				break;
			case "MMM":
				// Month, as a three-letter abbreviation
			case "MMMM":
				// Month, using the full name
				var part = getPart( value, 1 );
				ret.push(
					( cal.monthsGenitive && hasDay() ) ?
					( cal.monthsGenitive[ clength === 3 ? "namesAbbr" : "names" ][ part ] ) :
					( cal.months[ clength === 3 ? "namesAbbr" : "names" ][ part ] )
				);
				break;
			case "M":
				// Month, as digits, with no leading zero for single-digit months
			case "MM":
				// Month, as digits, with leading zero for single-digit months
				ret.push(
					padZeros( getPart(value, 1) + 1, clength )
				);
				break;
			case "y":
				// Year, as two digits, but with no leading zero for years less than 10
			case "yy":
				// Year, as two digits, with leading zero for years less than 10
			case "yyyy":
				// Year represented by four full digits
				part = converted ? converted[ 0 ] : getEraYear( value, cal, getEra(value, eras), sortable );
				if ( clength < 4 ) {
					part = part % 100;
				}
				ret.push(
					padZeros( part, clength )
				);
				break;
			case "h":
				// Hours with no leading zero for single-digit hours, using 12-hour clock
			case "hh":
				// Hours with leading zero for single-digit hours, using 12-hour clock
				hour = value.getHours() % 12;
				if ( hour === 0 ) hour = 12;
				ret.push(
					padZeros( hour, clength )
				);
				break;
			case "H":
				// Hours with no leading zero for single-digit hours, using 24-hour clock
			case "HH":
				// Hours with leading zero for single-digit hours, using 24-hour clock
				ret.push(
					padZeros( value.getHours(), clength )
				);
				break;
			case "m":
				// Minutes with no leading zero for single-digit minutes
			case "mm":
				// Minutes with leading zero for single-digit minutes
				ret.push(
					padZeros( value.getMinutes(), clength )
				);
				break;
			case "s":
				// Seconds with no leading zero for single-digit seconds
			case "ss":
				// Seconds with leading zero for single-digit seconds
				ret.push(
					padZeros( value.getSeconds(), clength )
				);
				break;
			case "t":
				// One character am/pm indicator ("a" or "p")
			case "tt":
				// Multicharacter am/pm indicator
				part = value.getHours() < 12 ? ( cal.AM ? cal.AM[0] : " " ) : ( cal.PM ? cal.PM[0] : " " );
				ret.push( clength === 1 ? part.charAt(0) : part );
				break;
			case "f":
				// Deciseconds
			case "ff":
				// Centiseconds
			case "fff":
				// Milliseconds
				ret.push(
					padZeros( value.getMilliseconds(), 3 ).substr( 0, clength )
				);
				break;
			case "z":
				// Time zone offset, no leading zero
			case "zz":
				// Time zone offset with leading zero
				hour = value.getTimezoneOffset() / 60;
				ret.push(
					( hour <= 0 ? "+" : "-" ) + padZeros( Math.floor(Math.abs(hour)), clength )
				);
				break;
			case "zzz":
				// Time zone offset with leading zero
				hour = value.getTimezoneOffset() / 60;
				ret.push(
					( hour <= 0 ? "+" : "-" ) + padZeros( Math.floor(Math.abs(hour)), 2 ) +
					// Hard coded ":" separator, rather than using cal.TimeSeparator
					// Repeated here for consistency, plus ":" was already assumed in date parsing.
					":" + padZeros( Math.abs(value.getTimezoneOffset() % 60), 2 )
				);
				break;
			case "g":
			case "gg":
				if ( cal.eras ) {
					ret.push(
						cal.eras[ getEra(value, eras) ].name
					);
				}
				break;
		case "/":
			ret.push( cal["/"] );
			break;
		default:
			throw "Invalid date format pattern \'" + current + "\'.";
		}
	}
	return ret.join( "" );
};

// formatNumber
(function() {
	var expandNumber;

	expandNumber = function( number, precision, formatInfo ) {
		var groupSizes = formatInfo.groupSizes,
			curSize = groupSizes[ 0 ],
			curGroupIndex = 1,
			factor = Math.pow( 10, precision ),
			rounded = Math.round( number * factor ) / factor;

		if ( !isFinite(rounded) ) {
			rounded = number;
		}
		number = rounded;

		var numberString = number+"",
			right = "",
			split = numberString.split( /e/i ),
			exponent = split.length > 1 ? parseInt( split[1], 10 ) : 0;
		numberString = split[ 0 ];
		split = numberString.split( "." );
		numberString = split[ 0 ];
		right = split.length > 1 ? split[ 1 ] : "";

		var l;
		if ( exponent > 0 ) {
			right = zeroPad( right, exponent, false );
			numberString += right.slice( 0, exponent );
			right = right.substr( exponent );
		}
		else if ( exponent < 0 ) {
			exponent = -exponent;
			numberString = zeroPad( numberString, exponent + 1, true );
			right = numberString.slice( -exponent, numberString.length ) + right;
			numberString = numberString.slice( 0, -exponent );
		}

		if ( precision > 0 ) {
			right = formatInfo[ "." ] +
				( (right.length > precision) ? right.slice(0, precision) : zeroPad(right, precision) );
		}
		else {
			right = "";
		}

		var stringIndex = numberString.length - 1,
			sep = formatInfo[ "," ],
			ret = "";

		while ( stringIndex >= 0 ) {
			if ( curSize === 0 || curSize > stringIndex ) {
				return numberString.slice( 0, stringIndex + 1 ) + ( ret.length ? (sep + ret + right) : right );
			}
			ret = numberString.slice( stringIndex - curSize + 1, stringIndex + 1 ) + ( ret.length ? (sep + ret) : "" );

			stringIndex -= curSize;

			if ( curGroupIndex < groupSizes.length ) {
				curSize = groupSizes[ curGroupIndex ];
				curGroupIndex++;
			}
		}

		return numberString.slice( 0, stringIndex + 1 ) + sep + ret + right;
	};

	formatNumber = function( value, format, culture ) {
		if ( !isFinite(value) ) {
			if ( value === Infinity ) {
				return culture.numberFormat.positiveInfinity;
			}
			if ( value === -Infinity ) {
				return culture.numberFormat.negativeInfinity;
			}
			return culture.numberFormat.NaN;
		}
		if ( !format || format === "i" ) {
			return culture.name.length ? value.toLocaleString() : value.toString();
		}
		format = format || "D";

		var nf = culture.numberFormat,
			number = Math.abs( value ),
			precision = -1,
			pattern;
		if ( format.length > 1 ) precision = parseInt( format.slice(1), 10 );

		var current = format.charAt( 0 ).toUpperCase(),
			formatInfo;

		switch ( current ) {
			case "D":
				pattern = "n";
				number = truncate( number );
				if ( precision !== -1 ) {
					number = zeroPad( "" + number, precision, true );
				}
				if ( value < 0 ) number = "-" + number;
				break;
			case "N":
				formatInfo = nf;
				/* falls through */
			case "C":
				formatInfo = formatInfo || nf.currency;
				/* falls through */
			case "P":
				formatInfo = formatInfo || nf.percent;
				pattern = value < 0 ? formatInfo.pattern[ 0 ] : ( formatInfo.pattern[1] || "n" );
				if ( precision === -1 ) precision = formatInfo.decimals;
				number = expandNumber( number * (current === "P" ? 100 : 1), precision, formatInfo );
				break;
			default:
				throw "Bad number format specifier: " + current;
		}

		var patternParts = /n|\$|-|%/g,
			ret = "";
		for ( ; ; ) {
			var index = patternParts.lastIndex,
				ar = patternParts.exec( pattern );

			ret += pattern.slice( index, ar ? ar.index : pattern.length );

			if ( !ar ) {
				break;
			}

			switch ( ar[0] ) {
				case "n":
					ret += number;
					break;
				case "$":
					ret += nf.currency.symbol;
					break;
				case "-":
					// don't make 0 negative
					if ( /[1-9]/.test(number) ) {
						ret += nf[ "-" ];
					}
					break;
				case "%":
					ret += nf.percent.symbol;
					break;
			}
		}

		return ret;
	};

}());

getTokenRegExp = function() {
	// regular expression for matching date and time tokens in format strings.
	return (/\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g);
};

getEra = function( date, eras ) {
	if ( !eras ) return 0;
	var start, ticks = date.getTime();
	for ( var i = 0, l = eras.length; i < l; i++ ) {
		start = eras[ i ].start;
		if ( start === null || ticks >= start ) {
			return i;
		}
	}
	return 0;
};

getEraYear = function( date, cal, era, sortable ) {
	var year = date.getFullYear();
	if ( !sortable && cal.eras ) {
		// convert normal gregorian year to era-shifted gregorian
		// year by subtracting the era offset
		year -= cal.eras[ era ].offset;
	}
	return year;
};

// parseExact
(function() {
	var expandYear,
		getDayIndex,
		getMonthIndex,
		getParseRegExp,
		outOfRange,
		toUpper,
		toUpperArray;

	expandYear = function( cal, year ) {
		// expands 2-digit year into 4 digits.
		if ( year < 100 ) {
			var now = new Date(),
				era = getEra( now ),
				curr = getEraYear( now, cal, era ),
				twoDigitYearMax = cal.twoDigitYearMax;
			twoDigitYearMax = typeof twoDigitYearMax === "string" ? new Date().getFullYear() % 100 + parseInt( twoDigitYearMax, 10 ) : twoDigitYearMax;
			year += curr - ( curr % 100 );
			if ( year > twoDigitYearMax ) {
				year -= 100;
			}
		}
		return year;
	};

	getDayIndex = function	( cal, value, abbr ) {
		var ret,
			days = cal.days,
			upperDays = cal._upperDays;
		if ( !upperDays ) {
			cal._upperDays = upperDays = [
				toUpperArray( days.names ),
				toUpperArray( days.namesAbbr ),
				toUpperArray( days.namesShort )
			];
		}
		value = toUpper( value );
		if ( abbr ) {
			ret = arrayIndexOf( upperDays[1], value );
			if ( ret === -1 ) {
				ret = arrayIndexOf( upperDays[2], value );
			}
		}
		else {
			ret = arrayIndexOf( upperDays[0], value );
		}
		return ret;
	};

	getMonthIndex = function( cal, value, abbr ) {
		var months = cal.months,
			monthsGen = cal.monthsGenitive || cal.months,
			upperMonths = cal._upperMonths,
			upperMonthsGen = cal._upperMonthsGen;
		if ( !upperMonths ) {
			cal._upperMonths = upperMonths = [
				toUpperArray( months.names ),
				toUpperArray( months.namesAbbr )
			];
			cal._upperMonthsGen = upperMonthsGen = [
				toUpperArray( monthsGen.names ),
				toUpperArray( monthsGen.namesAbbr )
			];
		}
		value = toUpper( value );
		var i = arrayIndexOf( abbr ? upperMonths[1] : upperMonths[0], value );
		if ( i < 0 ) {
			i = arrayIndexOf( abbr ? upperMonthsGen[1] : upperMonthsGen[0], value );
		}
		return i;
	};

	getParseRegExp = function( cal, format ) {
		// converts a format string into a regular expression with groups that
		// can be used to extract date fields from a date string.
		// check for a cached parse regex.
		var re = cal._parseRegExp;
		if ( !re ) {
			cal._parseRegExp = re = {};
		}
		else {
			var reFormat = re[ format ];
			if ( reFormat ) {
				return reFormat;
			}
		}

		// expand single digit formats, then escape regular expression characters.
		var expFormat = expandFormat( cal, format ).replace( /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\\\$1" ),
			regexp = [ "^" ],
			groups = [],
			index = 0,
			quoteCount = 0,
			tokenRegExp = getTokenRegExp(),
			match;

		// iterate through each date token found.
		while ( (match = tokenRegExp.exec(expFormat)) !== null ) {
			var preMatch = expFormat.slice( index, match.index );
			index = tokenRegExp.lastIndex;

			// don't replace any matches that occur inside a string literal.
			quoteCount += appendPreOrPostMatch( preMatch, regexp );
			if ( quoteCount % 2 ) {
				regexp.push( match[0] );
				continue;
			}

			// add a regex group for the token.
			var m = match[ 0 ],
				len = m.length,
				add;
			switch ( m ) {
				case "dddd": case "ddd":
				case "MMMM": case "MMM":
				case "gg": case "g":
					add = "(\\D+)";
					break;
				case "tt": case "t":
					add = "(\\D*)";
					break;
				case "yyyy":
				case "fff":
				case "ff":
				case "f":
					add = "(\\d{" + len + "})";
					break;
				case "dd": case "d":
				case "MM": case "M":
				case "yy": case "y":
				case "HH": case "H":
				case "hh": case "h":
				case "mm": case "m":
				case "ss": case "s":
					add = "(\\d\\d?)";
					break;
				case "zzz":
					add = "([+-]?\\d\\d?:\\d{2})";
					break;
				case "zz": case "z":
					add = "([+-]?\\d\\d?)";
					break;
				case "/":
					add = "(\\/)";
					break;
				default:
					throw "Invalid date format pattern \'" + m + "\'.";
			}
			if ( add ) {
				regexp.push( add );
			}
			groups.push( match[0] );
		}
		appendPreOrPostMatch( expFormat.slice(index), regexp );
		regexp.push( "$" );

		// allow whitespace to differ when matching formats.
		var regexpStr = regexp.join( "" ).replace( /\s+/g, "\\s+" ),
			parseRegExp = { "regExp": regexpStr, "groups": groups };

		// cache the regex for this format.
		return re[ format ] = parseRegExp;
	};

	outOfRange = function( value, low, high ) {
		return value < low || value > high;
	};

	toUpper = function( value ) {
		// "he-IL" has non-breaking space in weekday names.
		return value.split( "\u00A0" ).join( " " ).toUpperCase();
	};

	toUpperArray = function( arr ) {
		var results = [];
		for ( var i = 0, l = arr.length; i < l; i++ ) {
			results[ i ] = toUpper( arr[i] );
		}
		return results;
	};

	parseExact = function( value, format, culture ) {
		// try to parse the date string by matching against the format string
		// while using the specified culture for date field names.
		value = trim( value );
		var cal = culture.calendar,
			// convert date formats into regular expressions with groupings.
			// use the regexp to determine the input format and extract the date fields.
			parseInfo = getParseRegExp( cal, format ),
			match = new RegExp( parseInfo.regExp ).exec( value );
		if ( match === null ) {
			return null;
		}
		// found a date format that matches the input.
		var groups = parseInfo.groups,
			era = null, year = null, month = null, date = null, weekDay = null,
			hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,
			pmHour = false;
		// iterate the format groups to extract and set the date fields.
		for ( var j = 0, jl = groups.length; j < jl; j++ ) {
			var matchGroup = match[ j + 1 ];
			if ( matchGroup ) {
				var current = groups[ j ],
					clength = current.length,
					matchInt = parseInt( matchGroup, 10 );
				switch ( current ) {
					case "dd": case "d":
						// Day of month.
						date = matchInt;
						// check that date is generally in valid range, also checking overflow below.
						if ( outOfRange(date, 1, 31) ) return null;
						break;
					case "MMM": case "MMMM":
						month = getMonthIndex( cal, matchGroup, clength === 3 );
						if ( outOfRange(month, 0, 11) ) return null;
						break;
					case "M": case "MM":
						// Month.
						month = matchInt - 1;
						if ( outOfRange(month, 0, 11) ) return null;
						break;
					case "y": case "yy":
					case "yyyy":
						year = clength < 4 ? expandYear( cal, matchInt ) : matchInt;
						if ( outOfRange(year, 0, 9999) ) return null;
						break;
					case "h": case "hh":
						// Hours (12-hour clock).
						hour = matchInt;
						if ( hour === 12 ) hour = 0;
						if ( outOfRange(hour, 0, 11) ) return null;
						break;
					case "H": case "HH":
						// Hours (24-hour clock).
						hour = matchInt;
						if ( outOfRange(hour, 0, 23) ) return null;
						break;
					case "m": case "mm":
						// Minutes.
						min = matchInt;
						if ( outOfRange(min, 0, 59) ) return null;
						break;
					case "s": case "ss":
						// Seconds.
						sec = matchInt;
						if ( outOfRange(sec, 0, 59) ) return null;
						break;
					case "tt": case "t":
						// AM/PM designator.
						// see if it is standard, upper, or lower case PM. If not, ensure it is at least one of
						// the AM tokens. If not, fail the parse for this format.
						pmHour = cal.PM && ( matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2] );
						if (
							!pmHour && (
								!cal.AM || ( matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2] )
							)
						) return null;
						break;
					case "f":
						// Deciseconds.
					case "ff":
						// Centiseconds.
					case "fff":
						// Milliseconds.
						msec = matchInt * Math.pow( 10, 3 - clength );
						if ( outOfRange(msec, 0, 999) ) return null;
						break;
					case "ddd":
						// Day of week.
					case "dddd":
						// Day of week.
						weekDay = getDayIndex( cal, matchGroup, clength === 3 );
						if ( outOfRange(weekDay, 0, 6) ) return null;
						break;
					case "zzz":
						// Time zone offset in +/- hours:min.
						var offsets = matchGroup.split( /:/ );
						if ( offsets.length !== 2 ) return null;
						hourOffset = parseInt( offsets[0], 10 );
						if ( outOfRange(hourOffset, -12, 13) ) return null;
						var minOffset = parseInt( offsets[1], 10 );
						if ( outOfRange(minOffset, 0, 59) ) return null;
						tzMinOffset = ( hourOffset * 60 ) + ( startsWith(matchGroup, "-") ? -minOffset : minOffset );
						break;
					case "z": case "zz":
						// Time zone offset in +/- hours.
						hourOffset = matchInt;
						if ( outOfRange(hourOffset, -12, 13) ) return null;
						tzMinOffset = hourOffset * 60;
						break;
					case "g": case "gg":
						var eraName = matchGroup;
						if ( !eraName || !cal.eras ) return null;
						eraName = trim( eraName.toLowerCase() );
						for ( var i = 0, l = cal.eras.length; i < l; i++ ) {
							if ( eraName === cal.eras[i].name.toLowerCase() ) {
								era = i;
								break;
							}
						}
						// could not find an era with that name
						if ( era === null ) return null;
						break;
				}
			}
		}
		var result = new Date(), defaultYear, convert = cal.convert;
		defaultYear = convert ? convert.fromGregorian( result )[ 0 ] : result.getFullYear();
		if ( year === null ) {
			year = defaultYear;
		}
		else if ( cal.eras ) {
			// year must be shifted to normal gregorian year
			// but not if year was not specified, its already normal gregorian
			// per the main if clause above.
			year += cal.eras[( era || 0 )].offset;
		}
		// set default day and month to 1 and January, so if unspecified, these are the defaults
		// instead of the current day/month.
		if ( month === null ) {
			month = 0;
		}
		if ( date === null ) {
			date = 1;
		}
		// now have year, month, and date, but in the culture's calendar.
		// convert to gregorian if necessary
		if ( convert ) {
			result = convert.toGregorian( year, month, date );
			// conversion failed, must be an invalid match
			if ( result === null ) return null;
		}
		else {
			// have to set year, month and date together to avoid overflow based on current date.
			result.setFullYear( year, month, date );
			// check to see if date overflowed for specified month (only checked 1-31 above).
			if ( result.getDate() !== date ) return null;
			// invalid day of week.
			if ( weekDay !== null && result.getDay() !== weekDay ) {
				return null;
			}
		}
		// if pm designator token was found make sure the hours fit the 24-hour clock.
		if ( pmHour && hour < 12 ) {
			hour += 12;
		}
		result.setHours( hour, min, sec, msec );
		if ( tzMinOffset !== null ) {
			// adjust timezone to utc before applying local offset.
			var adjustedMin = result.getMinutes() - ( tzMinOffset + result.getTimezoneOffset() );
			// Safari limits hours and minutes to the range of -127 to 127.  We need to use setHours
			// to ensure both these fields will not exceed this range.	adjustedMin will range
			// somewhere between -1440 and 1500, so we only need to split this into hours.
			result.setHours( result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60 );
		}
		return result;
	};
}());

parseNegativePattern = function( value, nf, negativePattern ) {
	var neg = nf[ "-" ],
		pos = nf[ "+" ],
		ret;
	switch ( negativePattern ) {
		case "n -":
			neg = " " + neg;
			pos = " " + pos;
			/* falls through */
		case "n-":
			if ( endsWith(value, neg) ) {
				ret = [ "-", value.substr(0, value.length - neg.length) ];
			}
			else if ( endsWith(value, pos) ) {
				ret = [ "+", value.substr(0, value.length - pos.length) ];
			}
			break;
		case "- n":
			neg += " ";
			pos += " ";
			/* falls through */
		case "-n":
			if ( startsWith(value, neg) ) {
				ret = [ "-", value.substr(neg.length) ];
			}
			else if ( startsWith(value, pos) ) {
				ret = [ "+", value.substr(pos.length) ];
			}
			break;
		case "(n)":
			if ( startsWith(value, "(") && endsWith(value, ")") ) {
				ret = [ "-", value.substr(1, value.length - 2) ];
			}
			break;
	}
	return ret || [ "", value ];
};

//
// public instance functions
//

Globalize.prototype.findClosestCulture = function( cultureSelector ) {
	return Globalize.findClosestCulture.call( this, cultureSelector );
};

Globalize.prototype.format = function( value, format, cultureSelector ) {
	return Globalize.format.call( this, value, format, cultureSelector );
};

Globalize.prototype.localize = function( key, cultureSelector ) {
	return Globalize.localize.call( this, key, cultureSelector );
};

Globalize.prototype.parseInt = function( value, radix, cultureSelector ) {
	return Globalize.parseInt.call( this, value, radix, cultureSelector );
};

Globalize.prototype.parseFloat = function( value, radix, cultureSelector ) {
	return Globalize.parseFloat.call( this, value, radix, cultureSelector );
};

Globalize.prototype.culture = function( cultureSelector ) {
	return Globalize.culture.call( this, cultureSelector );
};

//
// public singleton functions
//

Globalize.addCultureInfo = function( cultureName, baseCultureName, info ) {

	var base = {},
		isNew = false;

	if ( typeof cultureName !== "string" ) {
		// cultureName argument is optional string. If not specified, assume info is first
		// and only argument. Specified info deep-extends current culture.
		info = cultureName;
		cultureName = this.culture().name;
		base = this.cultures[ cultureName ];
	} else if ( typeof baseCultureName !== "string" ) {
		// baseCultureName argument is optional string. If not specified, assume info is second
		// argument. Specified info deep-extends specified culture.
		// If specified culture does not exist, create by deep-extending default
		info = baseCultureName;
		isNew = ( this.cultures[ cultureName ] == null );
		base = this.cultures[ cultureName ] || this.cultures[ "default" ];
	} else {
		// cultureName and baseCultureName specified. Assume a new culture is being created
		// by deep-extending an specified base culture
		isNew = true;
		base = this.cultures[ baseCultureName ];
	}

	this.cultures[ cultureName ] = extend(true, {},
		base,
		info
	);
	// Make the standard calendar the current culture if it's a new culture
	if ( isNew ) {
		this.cultures[ cultureName ].calendar = this.cultures[ cultureName ].calendars.standard;
	}
};

Globalize.findClosestCulture = function( name ) {
	var match;
	if ( !name ) {
		return this.findClosestCulture( this.cultureSelector ) || this.cultures[ "default" ];
	}
	if ( typeof name === "string" ) {
		name = name.split( "," );
	}
	if ( isArray(name) ) {
		var lang,
			cultures = this.cultures,
			list = name,
			i, l = list.length,
			prioritized = [];
		for ( i = 0; i < l; i++ ) {
			name = trim( list[i] );
			var pri, parts = name.split( ";" );
			lang = trim( parts[0] );
			if ( parts.length === 1 ) {
				pri = 1;
			}
			else {
				name = trim( parts[1] );
				if ( name.indexOf("q=") === 0 ) {
					name = name.substr( 2 );
					pri = parseFloat( name );
					pri = isNaN( pri ) ? 0 : pri;
				}
				else {
					pri = 1;
				}
			}
			prioritized.push({ lang: lang, pri: pri });
		}
		prioritized.sort(function( a, b ) {
			if ( a.pri < b.pri ) {
				return 1;
			} else if ( a.pri > b.pri ) {
				return -1;
			}
			return 0;
		});
		// exact match
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			match = cultures[ lang ];
			if ( match ) {
				return match;
			}
		}

		// neutral language match
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			do {
				var index = lang.lastIndexOf( "-" );
				if ( index === -1 ) {
					break;
				}
				// strip off the last part. e.g. en-US => en
				lang = lang.substr( 0, index );
				match = cultures[ lang ];
				if ( match ) {
					return match;
				}
			}
			while ( 1 );
		}

		// last resort: match first culture using that language
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			for ( var cultureKey in cultures ) {
				var culture = cultures[ cultureKey ];
				if ( culture.language == lang ) {
					return culture;
				}
			}
		}
	}
	else if ( typeof name === "object" ) {
		return name;
	}
	return match || null;
};

Globalize.format = function( value, format, cultureSelector ) {
	var culture = this.findClosestCulture( cultureSelector );
	if ( value instanceof Date ) {
		value = formatDate( value, format, culture );
	}
	else if ( typeof value === "number" ) {
		value = formatNumber( value, format, culture );
	}
	return value;
};

Globalize.localize = function( key, cultureSelector ) {
	return this.findClosestCulture( cultureSelector ).messages[ key ] ||
		this.cultures[ "default" ].messages[ key ];
};

Globalize.parseDate = function( value, formats, culture ) {
	culture = this.findClosestCulture( culture );

	var date, prop, patterns;
	if ( formats ) {
		if ( typeof formats === "string" ) {
			formats = [ formats ];
		}
		if ( formats.length ) {
			for ( var i = 0, l = formats.length; i < l; i++ ) {
				var format = formats[ i ];
				if ( format ) {
					date = parseExact( value, format, culture );
					if ( date ) {
						break;
					}
				}
			}
		}
	} else {
		patterns = culture.calendar.patterns;
		for ( prop in patterns ) {
			date = parseExact( value, patterns[prop], culture );
			if ( date ) {
				break;
			}
		}
	}

	return date || null;
};

Globalize.parseInt = function( value, radix, cultureSelector ) {
	return truncate( Globalize.parseFloat(value, radix, cultureSelector) );
};

Globalize.parseFloat = function( value, radix, cultureSelector ) {
	// radix argument is optional
	if ( typeof radix !== "number" ) {
		cultureSelector = radix;
		radix = 10;
	}

	var culture = this.findClosestCulture( cultureSelector );
	var ret = NaN,
		nf = culture.numberFormat;

	if ( value.indexOf(culture.numberFormat.currency.symbol) > -1 ) {
		// remove currency symbol
		value = value.replace( culture.numberFormat.currency.symbol, "" );
		// replace decimal seperator
		value = value.replace( culture.numberFormat.currency["."], culture.numberFormat["."] );
	}

	//Remove percentage character from number string before parsing
	if ( value.indexOf(culture.numberFormat.percent.symbol) > -1){
		value = value.replace( culture.numberFormat.percent.symbol, "" );
	}

	// remove spaces: leading, trailing and between - and number. Used for negative currency pt-BR
	value = value.replace( / /g, "" );

	// allow infinity or hexidecimal
	if ( regexInfinity.test(value) ) {
		ret = parseFloat( value );
	}
	else if ( !radix && regexHex.test(value) ) {
		ret = parseInt( value, 16 );
	}
	else {

		// determine sign and number
		var signInfo = parseNegativePattern( value, nf, nf.pattern[0] ),
			sign = signInfo[ 0 ],
			num = signInfo[ 1 ];

		// #44 - try parsing as "(n)"
		if ( sign === "" && nf.pattern[0] !== "(n)" ) {
			signInfo = parseNegativePattern( value, nf, "(n)" );
			sign = signInfo[ 0 ];
			num = signInfo[ 1 ];
		}

		// try parsing as "-n"
		if ( sign === "" && nf.pattern[0] !== "-n" ) {
			signInfo = parseNegativePattern( value, nf, "-n" );
			sign = signInfo[ 0 ];
			num = signInfo[ 1 ];
		}

		sign = sign || "+";

		// determine exponent and number
		var exponent,
			intAndFraction,
			exponentPos = num.indexOf( "e" );
		if ( exponentPos < 0 ) exponentPos = num.indexOf( "E" );
		if ( exponentPos < 0 ) {
			intAndFraction = num;
			exponent = null;
		}
		else {
			intAndFraction = num.substr( 0, exponentPos );
			exponent = num.substr( exponentPos + 1 );
		}
		// determine decimal position
		var integer,
			fraction,
			decSep = nf[ "." ],
			decimalPos = intAndFraction.indexOf( decSep );
		if ( decimalPos < 0 ) {
			integer = intAndFraction;
			fraction = null;
		}
		else {
			integer = intAndFraction.substr( 0, decimalPos );
			fraction = intAndFraction.substr( decimalPos + decSep.length );
		}
		// handle groups (e.g. 1,000,000)
		var groupSep = nf[ "," ];
		integer = integer.split( groupSep ).join( "" );
		var altGroupSep = groupSep.replace( /\u00A0/g, " " );
		if ( groupSep !== altGroupSep ) {
			integer = integer.split( altGroupSep ).join( "" );
		}
		// build a natively parsable number string
		var p = sign + integer;
		if ( fraction !== null ) {
			p += "." + fraction;
		}
		if ( exponent !== null ) {
			// exponent itself may have a number patternd
			var expSignInfo = parseNegativePattern( exponent, nf, "-n" );
			p += "e" + ( expSignInfo[0] || "+" ) + expSignInfo[ 1 ];
		}
		if ( regexParseFloat.test(p) ) {
			ret = parseFloat( p );
		}
	}
	return ret;
};

Globalize.culture = function( cultureSelector ) {
	// setter
	if ( typeof cultureSelector !== "undefined" ) {
		this.cultureSelector = cultureSelector;
	}
	// getter
	return this.findClosestCulture( cultureSelector ) || this.cultures[ "default" ];
};

document.Globalize = Globalize;
}(this));
})();

/***/ }),

/***/ 7196:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {

    $.jqx.jqxWidget("jqxButtonGroup", "", {});

    $.extend($.jqx._jqxButtonGroup.prototype, {
        defineInstance: function () {
            var settings =
            {
                //Possible values: checkbox, radio, default
                mode: 'default',
                roundedCorners: true,
                disabled: false,
                enableHover: false,
                orientation: 'horizontal',
                width: null,
                height: null,
                _eventsMap: {
                    'mousedown': $.jqx.mobile.getTouchEventName('touchstart'),
                    'mouseup': $.jqx.mobile.getTouchEventName('touchend')
                },
                _events: ['selected', 'unselected', 'buttonclick'],
                _buttonId: {},
                _selected: null,
                _pressed: null,
                rtl: false,
                template: "",
                _baseId: 'group_button',
                aria:
                {
                    "aria-disabled": { name: "disabled", type: "boolean" }
                }
            };
            if (this === $.jqx._jqxButtonGroup.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        createInstance: function (args) {
            var that = this;
            that._isTouchDevice = $.jqx.mobile.isTouchDevice();
            $.jqx.aria(that);
            that._baseId = that._baseId + that.element.id;
            that.addHandler(that.host, 'selectstart', function (event) {
                if (!that.disabled) {
                    event.preventDefault();
                }
            });
        },

        refresh: function () {
            var that = this;
            if (that.width) {
                if (that.width.toString() && that.width.toString().indexOf('%') >= 0) {
                    that.element.style.width = that.width;
                }
                else {
                    that.host.width(that.width);
                }
            }
            if (that.height) that.host.height(that.height);
            that._refreshButtons();
        },

        render: function () {
            this.refresh();
        },

        resize: function () {
            this.refresh();
        },

        _getEvent: function (event) {
            var that = this;
            if (that._isTouchDevice) {
                var e = that._eventsMap[event] || event;
                e += "." + that.element.id;
                return e;
            }
            event += "." + that.element.id;
            return event;
        },

        _refreshButtons: function () {
            var that = this;
            if (that.lastElement)
                that.lastElement.remove();

            that.lastElement = $("<div style='clear: both;'></div>");
            var children = that.host.children(),
                count = children.length,
                current;

            switch (that.mode) {
                case "radio":
                    that.host.attr('role', 'radiogroup');
                    break;
                case "checkbox":
                case "default":
                    that.host.attr('role', 'group');
                    break;
            }

            var width = new Number(100 / count).toFixed(2);
            for (var i = 0; i < count; i += 1) {
                current = $(children[i]);
                if (that.width) {
                    if (that.orientation === "horizontal") {
                        current.css('width', width + '%');
                        current.css('box-sizing', 'border-box');
                        current.css('-moz-box-sizing', 'border-box');
                        current.css('white-space', 'nowrap');
                        current.css('text-overflow', 'ellipsis');
                        current.css('overflow', 'hidden');
                    }
                    else {
                        current.css('box-sizing', 'border-box');
                        current.css('-moz-box-sizing', 'border-box');
                        current.css('width', '100%');
                    }
                }

                that._refreshButton(current, i, count);
            }
            that.lastElement.appendTo(that.host);
        },

        _refreshButton: function (btn, counter, count) {
            (function (btn) {
                var that = this;
                btn = that._render(btn);
                that._removeStyles(btn);
                that._addStyles(btn, counter, count);
                that._performLayout(btn);
                that._removeButtonListeners(btn);
                that._addButtonListeners(btn);
                that._handleButtonId(btn, counter);

                if (that.mode === "radio") {
                    btn.attr('role', 'radio');
                }
                else {
                    btn.attr('role', 'button');
                }
                btn.attr('disabled', that.disabled);
                if (that.disabled) {
                    btn.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
                }
                else {
                    btn.removeClass(that.toThemeProperty('jqx-fill-state-disabled'));
                }
            }).apply(this, [btn]);
        },

        destroy: function (removeFromDom) {
            var that = this;
            var children = that.host.children(),
            count = children.length,
            current;

            for (var i = 0; i < count; i += 1) {
                current = $(children[i]);
                that._removeStyles(current);
                that._removeButtonListeners(current);
            }

            if (removeFromDom !== false) {
                that.host.remove();
            }
        },

        _render: function (btn) {
            var that = this;
            if (btn[0].tagName.toLowerCase() === 'button') {
                return that._renderFromButton(btn);
            } else {
                return that._renderButton(btn);
            }
        },

        _renderButton: function (btn) {
            var content;
            btn.wrapInner('<div/>');
            return btn;
        },

        _removeStyles: function (btn) {
            var that = this;
            var tp = that.toThemeProperty;
            that.host.removeClass('jqx-widget');
            that.host.removeClass('jqx-rc-all');
            btn.removeClass(tp.call(this, 'jqx-fill-state-normal'));
            btn.removeClass(tp.call(this, 'jqx-group-button-normal'));
            btn.removeClass(tp.call(this, 'jqx-rc-tl'));
            btn.removeClass(tp.call(this, 'jqx-rc-bl'));
            btn.removeClass(tp.call(this, 'jqx-rc-tr'));
            btn.removeClass(tp.call(this, 'jqx-rc-br'));
            btn.css('margin-left', 0);
        },

        _addStyles: function (btn, counter, count) {
            var that = this;
            var tp = this.toThemeProperty;
            that.host.addClass(tp.call(this, 'jqx-widget'));
            that.host.addClass(tp.call(this, 'jqx-rc-all'));
            that.host.addClass(tp.call(this, 'jqx-buttongroup'));
            btn.addClass(tp.call(this, 'jqx-button'));
            btn.addClass(tp.call(this, 'jqx-group-button-normal'));
            btn.addClass(tp.call(this, 'jqx-fill-state-normal'));
            if (that.template) {
                btn.addClass(tp.call(this, 'jqx-' + that.template));
            }
            if (that.roundedCorners) {
                if (counter === 0) {
                    that._addRoundedCorners(btn, true);
                } else if (counter === count - 1) {
                    that._addRoundedCorners(btn, false);
                }
            }
            if (that.orientation === 'horizontal') {
                btn.css('margin-left', -parseInt(btn.css('border-left-width'), 10));
            }
            else {
                btn.css('margin-top', -parseInt(btn.css('border-left-width'), 10));
            }
        },

        _addRoundedCorners: function (button, left) {
            var that = this;
            var tp = that.toThemeProperty;
            if (that.orientation === 'horizontal') {
                if (left) {
                    button.addClass(tp.call(this, 'jqx-rc-tl'));
                    button.addClass(tp.call(this, 'jqx-rc-bl'));
                } else {
                    button.addClass(tp.call(this, 'jqx-rc-tr'));
                    button.addClass(tp.call(this, 'jqx-rc-br'));
                }
            }
            else {
                if (left) {
                    button.addClass(tp.call(this, 'jqx-rc-tl'));
                    button.addClass(tp.call(this, 'jqx-rc-tr'));
                } else {
                    button.addClass(tp.call(this, 'jqx-rc-bl'));
                    button.addClass(tp.call(this, 'jqx-rc-br'));
                }
            }
        },

        _centerContent: function (content, parent) {
            content.css({
                'margin-top': (parent.height() - content.height()) / 2,
                'margin-left': (parent.width() - content.width()) / 2
            });
            return content;
        },

        _renderFromButton: function (btn) {
            var content = btn.val();
            if (content === "") {
                content = btn.html();
            }

            var div;
            var id = btn[0].id;
            btn.wrap('<div/>');
            div = btn.parent();
            div.attr('style', btn.attr('style'));
            btn.remove();
            $.jqx.utilities.html(div, content);
            div[0].id = id;
            return div;
        },

        _performLayout: function (btn) {
            if (this.orientation === 'horizontal') {
                if (this.rtl) {
                    btn.css('float', 'right');
                }
                else {
                    btn.css('float', 'left');
                }
            }
            else {
                btn.css('float', 'none');
            }

            this._centerContent($(btn.children()), btn);
        },

        _mouseEnterHandler: function (e) {
            var self = e.data.self,
                btn = $(e.currentTarget);
            if (self._isDisabled(btn) || !self.enableHover) {
                return;
            }
            var tp = self.toThemeProperty;
            btn.addClass(tp.call(self, 'jqx-group-button-hover'));
            btn.addClass(tp.call(self, 'jqx-fill-state-hover'));
        },

        _mouseLeaveHandler: function (e) {
            var self = e.data.self,
                btn = $(e.currentTarget);
            if (self._isDisabled(btn) || !self.enableHover) {
                return;
            }
            var tp = self.toThemeProperty;
            btn.removeClass(tp.call(self, 'jqx-group-button-hover'));
            btn.removeClass(tp.call(self, 'jqx-fill-state-hover'));
        },

        _mouseDownHandler: function (e) {
            var self = e.data.self,
                btn = $(e.currentTarget);
            if (self._isDisabled(btn)) {
                return;
            }
            self._pressed = btn;
            var tp = self.toThemeProperty;
            btn.addClass(tp.call(self, 'jqx-group-button-pressed'));
            btn.addClass(tp.call(self, 'jqx-fill-state-pressed'));
        },

        _mouseUpHandler: function (e) {
            var self = e.data.self,
                btn = $(e.currentTarget);
            if (self._isDisabled(btn)) {
                return;
            }
            self._handleSelection(btn);
            self._pressed = null;
            btn = self._buttonId[btn[0].id];
            self._raiseEvent(2, { index: btn.num, button: btn.btn });
        },

        _isDisabled: function (btn) {
            if (!btn || !btn[0]) {
                return false;
            }
            return this._buttonId[btn[0].id].disabled;
        },

        _documentUpHandler: function (e) {
            var self = e.data.self,
                pressedButton = self._pressed;
            if (pressedButton && !self._buttonId[pressedButton[0].id].selected) {
                pressedButton.removeClass(self.toThemeProperty('jqx-fill-state-pressed'));
                self._pressed = null;
            }
        },

        _addButtonListeners: function (btn) {
            var that = this;
            var ah = that.addHandler;
            var ge = that._getEvent;

            ah(btn, ge.call(that, 'mouseenter'), that._mouseEnterHandler, { self: that });
            ah(btn, ge.call(that, 'mouseleave'), that._mouseLeaveHandler, { self: that });
            ah(btn, ge.call(that, 'mousedown'), that._mouseDownHandler, { self: that });
            ah(btn, ge.call(that, 'mouseup'), that._mouseUpHandler, { self: that });
            ah($(document), ge.call(that, 'mouseup'), that._documentUpHandler, { self: that });
        },

        _removeButtonListeners: function (btn) {
            var that = this;
            var rh = that.removeHandler;
            var ge = that._getEvent;
            rh(btn, ge.call(that, 'mouseenter'), that._mouseEnterHandler);
            rh(btn, ge.call(that, 'mouseleave'), that._mouseLeaveHandler);
            rh(btn, ge.call(that, 'mousedown'), that._mouseDownHandler);
            rh(btn, ge.call(that, 'mouseup'), that._mouseUpHandler);
            rh($(document), ge.call(that, 'mouseup'), that._documentUpHandler);
        },

        _handleSelection: function (btn) {
            var that = this;
            if (that.mode === 'radio') {
                that._handleRadio(btn);
            } else if (that.mode === 'checkbox') {
                that._handleCheckbox(btn);
            } else {
                that._handleDefault(btn);
            }
        },

        _handleRadio: function (btn) {
            var that = this;
            var selected = that._getSelectedButton();
            if (selected && selected.btn[0].id !== btn[0].id) {
                that._unselectButton(selected.btn, true);
            }
            for (var data in that._buttonId) {
                that._buttonId[data].selected = true;
                that._unselectButton(that._buttonId[data].btn, false);
            }

            that._selectButton(btn, true);
        },

        _handleCheckbox: function (btn) {
            var that = this;
            var btnInfo = that._buttonId[btn[0].id];
            if (btnInfo.selected) {
                that._unselectButton(btnInfo.btn, true);
            } else {
                that._selectButton(btn, true);
            }
        },

        _handleDefault: function (btn) {
            var that = this;
            that._selectButton(btn, false);
            for (var data in that._buttonId) {
                that._buttonId[data].selected = true;
                that._unselectButton(that._buttonId[data].btn, false);
            }
        },

        _getSelectedButton: function () {
            var that = this;
            for (var data in that._buttonId) {
                if (that._buttonId[data].selected) {
                    return that._buttonId[data];
                }
            }
            return null;
        },

        _getSelectedButtons: function () {
            var that = this;
            var selected = [];
            for (var data in that._buttonId) {
                if (that._buttonId[data].selected) {
                    selected.push(that._buttonId[data].num);
                }
            }
            return selected;
        },

        _getButtonByIndex: function (index) {
            var that = this;
            var current;
            for (var data in that._buttonId) {
                if (that._buttonId[data].num === index) {
                    return that._buttonId[data];
                }
            }
            return null;
        },

        _selectButton: function (btn, raiseEvent) {
            var that = this;
            var btnInfo = that._buttonId[btn[0].id];
            if (btnInfo.selected) {
                return;
            }
            var tp = that.toThemeProperty;
            btnInfo.btn.addClass(tp.call(this, 'jqx-group-button-pressed'));
            btnInfo.btn.addClass(tp.call(this, 'jqx-fill-state-pressed'));
            btnInfo.selected = true;
            if (raiseEvent) {
                that._raiseEvent(0, { index: btnInfo.num, button: btnInfo.btn });
            }
            $.jqx.aria(btnInfo.btn, 'aria-checked', true);
        },

        _unselectButton: function (btn, raiseEvent) {
            var that = this;
            var btnInfo = that._buttonId[btn[0].id];
            if (!btnInfo.selected) {
                return;
            }
            var tp = that.toThemeProperty;
            btnInfo.btn.removeClass(tp.call(this, 'jqx-group-button-pressed'));
            btnInfo.btn.removeClass(tp.call(this, 'jqx-fill-state-pressed'));
            btnInfo.selected = false;
            if (raiseEvent) {
                that._raiseEvent(1, { index: btnInfo.num, button: btnInfo.btn });
            }
            $.jqx.aria(btnInfo.btn, 'aria-checked', false);
        },

        setSelection: function (index) {
            var that = this;
            if (index === -1) {
                that.clearSelection();
                return;
            }

            if (that.mode === 'checkbox') {
                if (typeof index === 'number') {
                    that._setSelection(index);
                } else {
                    for (var i = 0; i < index.length; i += 1) {
                        that._setSelection(index[i]);
                    }
                }
            } else if (typeof index === 'number' && that.mode === 'radio') {
                that._setSelection(index);
            }
        },

        _setSelection: function (index) {
            var that = this;
            var btn = that._getButtonByIndex(index);
            if (btn) {
                that._handleSelection(btn.btn);
            }
        },

        getSelection: function () {
            var that = this;
            if (that.mode === 'radio') {
                if (that._getSelectedButton()) {
                    return that._getSelectedButton().num;
                }
            } else if (that.mode === 'checkbox') {
                return that._getSelectedButtons();
            }
            return undefined;
        },

        disable: function () {
            var that = this;
            that.disabled = true;
            var current;
            for (var btn in that._buttonId) {
                current = that._buttonId[btn];
                that.disableAt(current.num);
            }
            $.jqx.aria(that, "aria-disabled", true);
        },

        enable: function () {
            var that = this;
            that.disabled = false;
            var current;
            for (var btn in that._buttonId) {
                current = that._buttonId[btn];
                that.enableAt(current.num);
            }
            $.jqx.aria(that, "aria-disabled", false);
        },

        disableAt: function (index) {
            var that = this;
            var btn = that._getButtonByIndex(index);
            if (!btn.disabled) {
                btn.disabled = true;
                btn.btn.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
            }
        },

        enableAt: function (index) {
            var that = this;
            var btn = that._getButtonByIndex(index);
            if (btn.disabled) {
                btn.disabled = false;
                btn.btn.removeClass(that.toThemeProperty('jqx-fill-state-disabled'));
            }
        },

        _handleButtonId: function (btn, number) {
            var id = btn[0].id,
                btnId = { btn: btn, num: number, selected: false },
                widgetId;
            if (!id) {
                id = this._baseId + btn.index();
            }
            btn[0].id = id;
            this._buttonId[id] = btnId;
            return id;
        },

        _raiseEvent: function (id, data) {
            var event = $.Event(this._events[id]);
            event.args = data;
            return this.host.trigger(event);
        },

        _unselectAll: function () {
            for (var data in this._buttonId) {
                this._unselectButton(this._buttonId[data].btn, false);
            }
        },

        clearSelection: function () {
            this._unselectAll();
        },

        propertyChangedHandler: function (object, key, oldvalue, value) {
            if (key === 'theme' && value !== null) {
                $.jqx.utilities.setTheme(oldvalue, value, object.host);
            }

            if (key === 'rtl') {
                object.refresh();
            }
            if (key === "template") {
                object.refresh();
            }
            if (key === 'mode') {
                object._unselectAll();
                object.refresh();
                return;
            } else if (key === 'disabled') {
                if (value) {
                    object.disable();
                } else {
                    object.enable();
                }
            } else {
                object.refresh();
            }
        }
    });
})(jqxBaseFramework);
})();



/***/ }),

/***/ 7351:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {
        $.jqx.cssroundedcorners = function (value) {
            var cssMap = {
                'all': 'jqx-rc-all',
                'top': 'jqx-rc-t',
                'bottom': 'jqx-rc-b',
                'left': 'jqx-rc-l',
                'right': 'jqx-rc-r',
                'top-right': 'jqx-rc-tr',
                'top-left': 'jqx-rc-tl',
                'bottom-right': 'jqx-rc-br',
                'bottom-left': 'jqx-rc-bl'
            };

            for (var prop in cssMap) {
                if (!cssMap.hasOwnProperty(prop))
                    continue;

                if (value == prop)
                    return cssMap[prop];
            }
        }

        $.jqx.jqxWidget("jqxButton", "", {});

        $.extend($.jqx._jqxButton.prototype, {
            defineInstance: function () {
                var settings = {
                    type: '',
                    cursor: 'arrow',
                    // rounds the button corners.
                    roundedCorners: 'all',
                    // enables / disables the button
                    disabled: false,
                    // sets height to the button.
                    height: null,
                    // sets width to the button.
                    width: null,
                    overrideTheme: false,
                    enableHover: true,
                    enableDefault: true,
                    enablePressed: true,
                    imgPosition: "center",
                    imgSrc: "",
                    imgWidth: 16,
                    imgHeight: 16,
                    value: null,
                    textPosition: "",
                    textImageRelation: "overlay",
                    rtl: false,
                    _ariaDisabled: false,
                    _scrollAreaButton: false,
                    // "primary", "inverse", "danger", "info", "success", "warning", "link"
                    template: "default",
                    aria:
                    {
                        "aria-disabled": { name: "disabled", type: "boolean" }
                    }
                }
                if (this === $.jqx._jqxButton.prototype) {
                    return settings;
                }
                $.extend(true, this, settings);
                return settings;
            },

            _addImage: function (name) {
                var that = this;
                if (that.element.nodeName.toLowerCase() == "input" || that.element.nodeName.toLowerCase() == "button" || that.element.nodeName.toLowerCase() == "div") {
                    if (!that._img) {
                        that.field = that.element;
                        if (that.field.className) {
                            that._className = that.field.className;
                        }

                        var properties = {
                            'title': that.field.title
                        };

                        var value = null;
                        if (that.field.getAttribute('value')) {
                            var value = that.field.getAttribute('value');
                        }
                        else if (that.element.nodeName.toLowerCase() != "input") {
                            var value = that.element.innerHTML;
                        }
                        if (that.value) {
                            value = that.value;
                        }
                        if (that.field.id.length) {
                            properties.id = that.field.id.replace(/[^\w]/g, '_') + "_" + name;
                        }
                        else {
                            properties.id = $.jqx.utilities.createId() + "_" + name;
                        }


                        var wrapper = document.createElement('div');
                        wrapper.id = properties.id;
                        wrapper.title = properties.title;
                        wrapper.style.cssText = that.field.style.cssText;
                        wrapper.style.boxSizing = 'border-box';

                        var img = document.createElement("img");
                        img.setAttribute('src', that.imgSrc);
                        img.setAttribute('width', that.imgWidth);
                        img.setAttribute('height', that.imgHeight);
                        wrapper.appendChild(img);
                        that._img = img;

                        var text = document.createElement('span');
                        if (value) {
                            text.innerHTML = value;
                            that.value = value;
                        }
                        wrapper.appendChild(text);
                        that._text = text;

                        that.field.style.display = "none";
                        if (that.field.parentNode) {
                            that.field.parentNode.insertBefore(wrapper, that.field.nextSibling);
                        }

                        var data = that.host.data();
                        that.host = $(wrapper);
                        that.host.data(data);
                        that.element = wrapper;
                        that.element.id = that.field.id;
                        that.field.id = properties.id;
                        var elementObj = new $(that.element);
                        var fieldObj = new $(that.field);
                        if (that._className) {
                            elementObj.addClass(that._className);
                            fieldObj.removeClass(that._className);
                        }

                        if (that.field.tabIndex) {
                            var tabIndex = that.field.tabIndex;
                            that.field.tabIndex = -1;
                            that.element.tabIndex = tabIndex;
                        }
                    }
                    else {
                        that._img.setAttribute('src', that.imgSrc);
                        that._img.setAttribute('width', that.imgWidth);
                        that._img.setAttribute('height', that.imgHeight);
                        that._text.innerHTML = that.value;
                    }
                    if (!that.imgSrc) {
                        that._img.style.display = "none";
                    }
                    else {
                        that._img.style.display = "inline";
                    }

                    if (!that.value) {
                        that._text.style.display = "none";
                    }
                    else {
                        that._text.style.display = "inline";
                    }

                    that._positionTextAndImage();
                }
            },

            _positionTextAndImage: function () {
                var that = this;
                var width = that.element.offsetWidth;
                var height = that.element.offsetHeight;

                var imgWidth = that.imgWidth;
                var imgHeight = that.imgHeight;
                if (that.imgSrc == "") {
                    imgWidth = 0;
                    imgHeight = 0;
                }

                var textWidth = that._text.offsetWidth;
                var textHeight = that._text.offsetHeight;
                var offset = 4;
                var edgeOffset = 4;
                var factorIncrease = 4;
                var w = 0;
                var h = 0;
                switch (that.textImageRelation) {
                    case "imageBeforeText":
                    case "textBeforeImage":
                        w = imgWidth + textWidth + 2 * factorIncrease + offset + 2 * edgeOffset;
                        h = Math.max(imgHeight, textHeight) + 2 * factorIncrease + offset + 2 * edgeOffset;
                        break;
                    case "imageAboveText":
                    case "textAboveImage":
                        w = Math.max(imgWidth, textWidth) + 2 * factorIncrease;
                        h = imgHeight + textHeight + offset + 2 * factorIncrease + 2 * edgeOffset;
                        break;
                    case "overlay":
                        w = Math.max(imgWidth, textWidth) + 2 * factorIncrease;
                        h = Math.max(imgHeight, textHeight) + 2 * factorIncrease;
                        break;
                }

                if (!that.width) {
                    that.element.style.width = w + "px";
                    width = w;
                }

                if (!that.height) {
                    that.element.style.height = h + "px";
                    height = h;
                }

                that._img.style.position = 'absolute';
                that._text.style.position = 'absolute';
                that.element.style.position = 'relative';
                that.element.style.overflow = 'hidden';

                var textRect = {};
                var imageRect = {};

                var drawElement = function (element, drawArea, pos, w, h) {
                    if (drawArea.width < w) drawArea.width = w;
                    if (drawArea.height < h) drawArea.height = h;

                    switch (pos) {
                        case "left":
                            element.style.left = drawArea.left + "px";
                            element.style.top = drawArea.top + drawArea.height / 2 - h / 2 + "px";;
                            break;
                        case "topLeft":
                            element.style.left = drawArea.left + "px";
                            element.style.top = drawArea.top + "px";
                            break;
                        case "bottomLeft":
                            element.style.left = drawArea.left + "px";
                            element.style.top = drawArea.top + drawArea.height - h + "px";
                            break;
                        default:
                        case "center":
                            element.style.left = drawArea.left + drawArea.width / 2 - w / 2 + "px";
                            element.style.top = drawArea.top + drawArea.height / 2 - h / 2 + "px";
                            break;
                        case "top":
                            element.style.left = drawArea.left + drawArea.width / 2 - w / 2 + "px";
                            element.style.top = drawArea.top + "px";
                            break;
                        case "bottom":
                            element.style.left = drawArea.left + drawArea.width / 2 - w / 2 + "px";
                            element.style.top = drawArea.top + drawArea.height - h + "px";
                            break;
                        case "right":
                            element.style.left = drawArea.left + drawArea.width - w + "px";
                            element.style.top = drawArea.top + drawArea.height / 2 - h / 2 + "px";;
                            break;
                        case "topRight":
                            element.style.left = drawArea.left + drawArea.width - w + "px";
                            element.style.top = drawArea.top + "px";
                            break;
                        case "bottomRight":
                            element.style.left = drawArea.left + drawArea.width - w + "px";
                            element.style.top = drawArea.top + drawArea.height - h + "px";
                            break;
                    }
                }

                var left = 0;
                var top = 0;
                var right = width;
                var bottom = height;
                var middle = (right - left) / 2;
                var center = (bottom - top) / 2;
                var img = that._img;
                var text = that._text;
                var rectHeight = bottom - top;
                var rectWidth = right - left;
                left += edgeOffset;
                top += edgeOffset;
                right = right - edgeOffset - 2;
                rectWidth = rectWidth - 2 * edgeOffset - 2;
                rectHeight = rectHeight - 2 * edgeOffset - 2;

                switch (that.textImageRelation) {
                    case "imageBeforeText":

                        switch (that.imgPosition) {
                            case "left":
                            case "topLeft":
                            case "bottomLeft":
                                imageRect = { left: left, top: top, width: left + imgWidth, height: rectHeight };
                                textRect = { left: left + imgWidth + offset, top: top, width: rectWidth - imgWidth - offset, height: rectHeight };
                                break;
                            case "center":
                            case "top":
                            case "bottom":
                                imageRect = { left: middle - textWidth / 2 - imgWidth / 2 - offset / 2, top: top, width: imgWidth, height: rectHeight };
                                textRect = { left: imageRect.left + imgWidth + offset, top: top, width: right - imageRect.left - imgWidth - offset, height: rectHeight };
                                break;
                            case "right":
                            case "topRight":
                            case "bottomRight":
                                imageRect = { left: right - textWidth - imgWidth - offset, top: top, width: imgWidth, height: rectHeight };
                                textRect = { left: imageRect.left + imgWidth + offset, top: top, width: right - imageRect.left - imgWidth - offset, height: rectHeight };
                                break;

                        }
                        drawElement(img, imageRect, that.imgPosition, imgWidth, imgHeight);
                        drawElement(text, textRect, that.textPosition, textWidth, textHeight);

                        break;
                    case "textBeforeImage":

                        switch (that.textPosition) {
                            case "left":
                            case "topLeft":
                            case "bottomLeft":
                                textRect = { left: left, top: top, width: left + textWidth, height: rectHeight };
                                imageRect = { left: left + textWidth + offset, top: top, width: rectWidth - textWidth - offset, height: rectHeight };
                                break;
                            case "center":
                            case "top":
                            case "bottom":
                                textRect = { left: middle - textWidth / 2 - imgWidth / 2 - offset / 2, top: top, width: textWidth, height: rectHeight };
                                imageRect = { left: textRect.left + textWidth + offset, top: top, width: right - textRect.left - textWidth - offset, height: rectHeight };
                                break;
                            case "right":
                            case "topRight":
                            case "bottomRight":
                                textRect = { left: right - textWidth - imgWidth - offset, top: top, width: textWidth, height: rectHeight };
                                imageRect = { left: textRect.left + textWidth + offset, top: top, width: right - textRect.left - textWidth - offset, height: rectHeight };
                                break;

                        }
                        drawElement(img, imageRect, that.imgPosition, imgWidth, imgHeight);
                        drawElement(text, textRect, that.textPosition, textWidth, textHeight);

                        break;
                    case "imageAboveText":

                        switch (that.imgPosition) {
                            case "topRight":
                            case "top":
                            case "topLeft":
                                imageRect = { left: left, top: top, width: rectWidth, height: imgHeight };
                                textRect = { left: left, top: top + imgHeight + offset, width: rectWidth, height: rectHeight - imgHeight - offset };
                                break;
                            case "left":
                            case "center":
                            case "right":
                                imageRect = { left: left, top: center - imgHeight / 2 - textHeight / 2 - offset / 2, width: rectWidth, height: imgHeight };
                                textRect = { left: left, top: imageRect.top + offset + imgHeight, width: rectWidth, height: rectHeight - imageRect.top - offset - imgHeight };
                                break;
                            case "bottomLeft":
                            case "bottom":
                            case "bottomRight":
                                imageRect = { left: left, top: bottom - imgHeight - textHeight - offset, width: rectWidth, height: imgHeight };
                                textRect = { left: left, top: imageRect.top + offset + imgHeight, width: rectWidth, height: textHeight };
                                break;

                        }
                        drawElement(img, imageRect, that.imgPosition, imgWidth, imgHeight);
                        drawElement(text, textRect, that.textPosition, textWidth, textHeight);
                        break;
                    case "textAboveImage":
                        switch (that.textPosition) {
                            case "topRight":
                            case "top":
                            case "topLeft":
                                textRect = { left: left, top: top, width: rectWidth, height: textHeight };
                                imageRect = { left: left, top: top + textHeight + offset, width: rectWidth, height: rectHeight - textHeight - offset };
                                break;
                            case "left":
                            case "center":
                            case "right":
                                textRect = { left: left, top: center - imgHeight / 2 - textHeight / 2 - offset / 2, width: rectWidth, height: textHeight };
                                imageRect = { left: left, top: textRect.top + offset + textHeight, width: rectWidth, height: rectHeight - textRect.top - offset - textHeight };
                                break;
                            case "bottomLeft":
                            case "bottom":
                            case "bottomRight":
                                textRect = { left: left, top: bottom - imgHeight - textHeight - offset, width: rectWidth, height: textHeight };
                                imageRect = { left: left, top: textRect.top + offset + textHeight, width: rectWidth, height: imgHeight };
                                break;

                        }
                        drawElement(img, imageRect, that.imgPosition, imgWidth, imgHeight);
                        drawElement(text, textRect, that.textPosition, textWidth, textHeight);

                        break;
                    case "overlay":
                    default:
                        textRect = { left: left, top: top, width: rectWidth, height: rectHeight };
                        imageRect = { left: left, top: top, width: rectWidth, height: rectHeight };

                        drawElement(img, imageRect, that.imgPosition, imgWidth, imgHeight);
                        drawElement(text, textRect, that.textPosition, textWidth, textHeight);

                        break;
                }
            },

            createInstance: function (args) {
                var that = this;
                that._setSize();

                var isMaterial = that.isMaterialized();

                that.buttonObj = new $(that.element);

                if (that.imgSrc != "" || that.textPosition != "" || (that.element.value && that.element.value.indexOf("<") >= 0) || that.value != null) {
                    that.refresh();
                    that._addImage("jqxButton");
                    that.buttonObj = new $(that.element);
                }

                if (!that._ariaDisabled) {
                    that.element.setAttribute('role', 'button');
                }
                if (that.type !== '') {
                    that.element.setAttribute('type', that.type);
                }
                if (!that.overrideTheme) {
                    that.buttonObj.addClass(that.toThemeProperty($.jqx.cssroundedcorners(that.roundedCorners)));
                    if (that.enableDefault) {
                        that.buttonObj.addClass(that.toThemeProperty('jqx-button'));
                    }
                    that.buttonObj.addClass(that.toThemeProperty('jqx-widget'));
                }

                that.isTouchDevice = $.jqx.mobile.isTouchDevice();
                if (!that._ariaDisabled) {
                    $.jqx.aria(this);
                }

                if (that.cursor != 'arrow') {
                    if (!that.disabled) {
                        that.element.style.cursor = that.cursor;
                    }
                    else {
                        that.element.style.cursor = "arrow";
                    }
                }

                var eventNames = 'mouseenter mouseleave mousedown focus blur';
                if (that._scrollAreaButton) {
                    var eventNames = 'mousedown';
                }

                if (that.isTouchDevice) {
                    that.addHandler(that.host, $.jqx.mobile.getTouchEventName('touchstart'), function (event) {
                        that.isPressed = true;
                        that.refresh();
                    });
                    that.addHandler($(document), $.jqx.mobile.getTouchEventName('touchend') + "." + that.element.id, function (event) {
                        that.isPressed = false;
                        that.refresh();
                    });
                }

                that.addHandler(that.host, eventNames, function (event) {
                    switch (event.type) {
                        case 'mouseenter':
                            if (!that.isTouchDevice) {
                                if (!that.disabled && that.enableHover) {
                                    that.isMouseOver = true;
                                    that.refresh();
                                }
                            }
                            break;
                        case 'mouseleave':
                            if (!that.isTouchDevice) {
                                if (!that.disabled && that.enableHover) {
                                    that.isMouseOver = false;
                                    that.refresh();
                                }
                            }
                            break;
                        case 'mousedown':
                            if (!that.disabled) {
                                that.isPressed = true;
                                that.refresh();
                            }
                            break;
                        case 'focus':
                            if (!that.disabled) {
                                that.isFocused = true;
                                that.refresh();
                            }
                            break;
                        case 'blur':
                            if (!that.disabled) {
                                that.isFocused = false;
                                that.refresh();
                            }
                            break;
                    }
                });

                that.mouseupfunc = function (event) {
                    if (!that.disabled) {
                        if (that.isPressed || that.isMouseOver) {
                            that.isPressed = false;
                            that.refresh();
                        }
                    }
                }

                that.addHandler(document, 'mouseup.button' + that.element.id, that.mouseupfunc);

                try {
                    if (document.referrer != "" || window.frameElement) {
                        if (window.top != null && window.top != window.that) {
                            var parentLocation = '';
                            if (window.parent && document.referrer) {
                                parentLocation = document.referrer;
                            }

                            if (parentLocation.indexOf(document.location.host) != -1) {
                                if (window.top.document) {
                                    window.top.document.addEventListener('mouseup', that._topDocumentMouseupHandler);
                                }
                            }
                        }
                    }
                }
                catch (error) {
                }

                that.propertyChangeMap['roundedCorners'] = function (instance, key, oldVal, value) {
                    instance.buttonObj.removeClass(instance.toThemeProperty($.jqx.cssroundedcorners(oldVal)));
                    instance.buttonObj.addClass(instance.toThemeProperty($.jqx.cssroundedcorners(value)));
                };
                that.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    if (oldVal != value) {
                        instance.refresh();
                        instance.element.setAttribute('disabled', value);
                        instance.element.disabled = value;
                        if (!value) {
                            instance.element.style.cursor = instance.cursor;
                        }
                        else {
                            instance.element.style.cursor = 'default';
                        }

                        $.jqx.aria(instance, "aria-disabled", instance.disabled);
                    }
                };
                that.propertyChangeMap['rtl'] = function (instance, key, oldVal, value) {
                    if (oldVal != value) {
                        instance.refresh();
                    }
                };
                that.propertyChangeMap['template'] = function (instance, key, oldVal, value) {
                    if (oldVal != value) {
                        instance.buttonObj.removeClass(instance.toThemeProperty("jqx-" + oldVal));
                        instance.refresh();
                    }
                };
                that.propertyChangeMap['theme'] = function (instance, key, oldVal, value) {
                    instance.buttonObj.removeClass(instance.element);

                    if (oldVal) {
                        instance.buttonObj.removeClass('jqx-button-' + oldVal);
                        instance.buttonObj.removeClass('jqx-widget-' + oldVal);
                        instance.buttonObj.removeClass('jqx-fill-state-normal-' + oldVal);
                        instance.buttonObj.removeClass(instance.toThemeProperty($.jqx.cssroundedcorners(instance.roundedCorners)) + '-' + oldVal);
                    }

                    if (instance.enableDefault) {
                        instance.buttonObj.addClass(instance.toThemeProperty('jqx-button'));
                    }
                    instance.buttonObj.addClass(instance.toThemeProperty('jqx-widget'));
                    if (!instance.overrideTheme) {
                        instance.buttonObj.addClass(instance.toThemeProperty($.jqx.cssroundedcorners(instance.roundedCorners)));
                    }
                    instance._oldCSSCurrent = null;
                    instance.refresh();
                };

                if (that.disabled) {
                    that.element.disabled = true;
                    that.element.setAttribute('disabled', 'true');
                }

                if (that.textPosition) {
                    $.jqx.utilities.resize(this.host, function () {
                        that._positionTextAndImage();
                    });
                }
            }, // createInstance

            resize: function (width, height) {
                this.width = width;
                this.height = height;
                this._setSize();
            },

            val: function (value) {
                var that = this;
                var input = that.host.find('input');
                if (input.length > 0) {
                    if (arguments.length == 0 || typeof (value) == "object") {
                        return input.val();
                    }
                    input.val(value);
                    that.refresh();
                    return input.val();
                }

                if (arguments.length == 0 || typeof (value) == "object") {
                    if (that.element.nodeName.toLowerCase() == "button") {
                        return $(that.element).text();
                    }
                    return that.element.value;
                }

                if (arguments.length > 0 && that._text) {
                    that._text.innerHTML = arguments[0];
                    that.refresh();

                    return;
                }
                else if (arguments.length > 0 && that.element.nodeName === 'DIV') {
                    that.element.innerHTML = arguments[0];
                    that.refresh();
                }

                that.element.value = arguments[0];
                if (that.element.nodeName.toLowerCase() == "button") {
                    $(that.element).html(arguments[0]);
                }

                that.refresh();
            },

            _setSize: function () {
                var that = this;
                var height = that.height;
                var width = that.width;

                if (height) {
                    if (!isNaN(height)) {
                        height = height + "px";
                    }
                    that.element.style.height = height;
                }

                if (width) {
                    if (!isNaN(width)) {
                        width = width + "px";
                    }
                    that.element.style.width = width;
                }
            },

            _removeHandlers: function () {
                var that = this;
                that.removeHandler(that.host, 'selectstart');
                that.removeHandler(that.host, 'click');
                that.removeHandler(that.host, 'focus');
                that.removeHandler(that.host, 'blur');
                that.removeHandler(that.host, 'mouseenter');
                that.removeHandler(that.host, 'mouseleave');
                that.removeHandler(that.host, 'mousedown');
                that.removeHandler($(document), 'mouseup.button' + that.element.id, that.mouseupfunc);
                if (that.isTouchDevice) {
                    that.removeHandler(that.host, $.jqx.mobile.getTouchEventName('touchstart'));
                    that.removeHandler($(document), $.jqx.mobile.getTouchEventName('touchend') + "." + that.element.id);
                }
                that.mouseupfunc = null;
                delete that.mouseupfunc;
            },

            focus: function () {
                this.host.focus();
            },

            destroy: function () {
                var that = this;
                that._removeHandlers();
                var vars = $.data(that.element, "jqxButton");
                if (vars) {
                    delete vars.instance;
                }
                that.host.removeClass();
                that.host.removeData();
                that.host.remove();
                delete that.set;
                delete that.get;
                delete that.call;
                delete that.element;
                delete that.host;
            },

            render: function () {
                this.refresh();
            },

            propertiesChangedHandler: function (object, oldValues, newValues) {
                if (newValues && newValues.width && newValues.height && Object.keys(newValues).length == 2) {
                    object._setSize();
                    object.refresh();
                }
            },

            propertyChangedHandler: function (object, key, oldvalue, value) {
                if (this.isInitialized == undefined || this.isInitialized == false)
                    return;

                if (value == oldvalue) {
                    return;
                }

                if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                    return;
                }

                if (key === "type") {
                    object.element.setAttribute('type', value);
                }
                if (key == "textImageRelation" || key == "textPosition" || key == "imgPosition") {
                    if (object._img) {
                        object._positionTextAndImage();
                    }
                    else object._addImage("jqxButton");
                }
                if (key == "imgSrc" || key == "imgWidth" || key == "imgHeight") {
                    object._addImage("jqxButton");
                }

                if (key === "value") {
                    object.val(value);
                }

                if (key == "width" || key == "height") {
                    object._setSize();
                    object.refresh();
                }
            },

            refresh: function () {
                var that = this;
                if (that.overrideTheme)
                    return;

                var cssFocused = that.toThemeProperty('jqx-fill-state-focus');
                var cssDisabled = that.toThemeProperty('jqx-fill-state-disabled');
                var cssNormal = that.toThemeProperty('jqx-fill-state-normal');

                if (!that.enableDefault) {
                    cssNormal = "";
                }

                var cssHover = that.toThemeProperty('jqx-fill-state-hover');
                var cssPressed = that.toThemeProperty('jqx-fill-state-pressed');
                var cssPressedHover = that.toThemeProperty('jqx-fill-state-pressed');
                if (!that.enablePressed) {
                    cssPressed = "";
                }
                var cssCurrent = '';

                if (!that.host) {
                    return;
                }

                that.element.disabled = that.disabled;

                if (that.disabled) {
                    if (that._oldCSSCurrent) {
                        that.buttonObj.removeClass(that._oldCSSCurrent);
                    }
                    cssCurrent = cssNormal + " " + cssDisabled;
                    if (that.template !== "default" && that.template !== "") {
                        cssCurrent += " " + "jqx-" + that.template;
                        if (that.theme != "") {
                            cssCurrent += " " + "jqx-" + that.template + "-" + that.theme;
                        }
                    }
                    that.buttonObj.addClass(cssCurrent);
                    that._oldCSSCurrent = cssCurrent;
                    return;
                }
                else {
                    if (that.isMouseOver && !that.isTouchDevice) {
                        if (that.isPressed)
                            cssCurrent = cssPressedHover;
                        else
                            cssCurrent = cssHover;
                    }
                    else {
                        if (that.isPressed)
                            cssCurrent = cssPressed;
                        else
                            cssCurrent = cssNormal;
                    }
                }

                if (that.isFocused) {
                    cssCurrent += " " + cssFocused;
                }

                if (that.template !== "default" && that.template !== "") {
                    cssCurrent += " " + "jqx-" + that.template;
                    if (that.theme != "") {
                        cssCurrent += " " + "jqx-" + that.template + "-" + that.theme;
                    }
                }

                if (cssCurrent != that._oldCSSCurrent) {
                    if (that._oldCSSCurrent) {
                        that.buttonObj.removeClass(that._oldCSSCurrent);
                    }
                    that.buttonObj.addClass(cssCurrent);
                    that._oldCSSCurrent = cssCurrent;
                }
                if (that.rtl) {
                    that.buttonObj.addClass(that.toThemeProperty('jqx-rtl'));
                    that.element.style.direction = 'rtl';
                }


                if (that.isMaterialized()) {
                    that.host.addClass('buttonRipple');
                }
            }
        });

        //// LinkButton
        $.jqx.jqxWidget("jqxLinkButton", "", {});

        $.extend($.jqx._jqxLinkButton.prototype, {
            defineInstance: function () {
                // enables / disables the button
                this.disabled = false;
                // sets height to the button.
                this.height = null;
                // sets width to the button.
                this.width = null;
                this.rtl = false;
                this.href = null;
            },

            createInstance: function (args) {
                var that = this;
                this.host.onselectstart = function () { return false; };
                this.host.attr('role', 'button');

                var height = this.height || this.element.offsetHeight;
                var width = this.width || this.element.offsetWidth;
                this.href = this.element.getAttribute('href');
                this.target = this.element.getAttribute('target');
                this.content = this.host.text();
                this.element.innerHTML = "";
                var wrapElement = document.createElement('input');
                wrapElement.type = "button";
                wrapElement.className = "jqx-wrapper " + this.toThemeProperty('jqx-reset');

                this._setSize(wrapElement, width, height);

                wrapElement.value = this.content;
                var helper = new $(this.element);
                helper.addClass(this.toThemeProperty('jqx-link'));
                this.element.style.color = 'inherit';
                this.element.appendChild(wrapElement);
                this._setSize(wrapElement, width, height);

                var param = args == undefined ? {} : args[0] || {};
                $(wrapElement).jqxButton(param);
                this.wrapElement = wrapElement;
                if (this.disabled) {
                    this.element.disabled = true;
                }

                this.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    instance.element.disabled = value;
                    instance.wrapElement.jqxButton({ disabled: value });
                }

                this.addHandler($(wrapElement), 'click', function (event) {
                    if (!this.disabled) {
                        that.onclick(event);
                    }
                    return false;
                });
            },

            _setSize: function (element, width, height) {
                var that = this;

                if (height) {
                    if (!isNaN(height)) {
                        height = height + "px";
                    }
                    element.style.height = height;
                }

                if (width) {
                    if (!isNaN(width)) {
                        width = width + "px";
                    }
                    element.style.width = width;
                }
            },


            onclick: function (event) {
                if (this.target != null) {
                    window.open(this.href, this.target);
                }
                else {
                    window.location = this.href;
                }
            }
        });
        //// End of LinkButton

        //// RepeatButton
        $.jqx.jqxWidget("jqxRepeatButton", "jqxButton", {});

        $.extend($.jqx._jqxRepeatButton.prototype, {
            defineInstance: function () {
                this.delay = 50;
            },

            createInstance: function (args) {
                var that = this;

                var isTouchDevice = $.jqx.mobile.isTouchDevice();

                var up = !isTouchDevice ? 'mouseup.' + this.base.element.id : 'touchend.' + this.base.element.id;
                var down = !isTouchDevice ? 'mousedown.' + this.base.element.id : 'touchstart.' + this.base.element.id;

                this.addHandler($(document), up, function (event) {
                    if (that.timeout != null) {
                        clearTimeout(that.timeout);
                        that.timeout = null;
                        that.refresh();
                    }
                    if (that.timer != undefined) {
                        clearInterval(that.timer);
                        that.timer = null;
                        that.refresh();
                    }
                });

                this.addHandler(this.base.host, down, function (event) {
                    if (that.timer != null) {
                        clearInterval(that.timer);
                    }

                    that.timeout = setTimeout(function () {
                        clearInterval(that.timer);
                        that.timer = setInterval(function (event) { that.ontimer(event); }, that.delay);
                    }, 150);
                });

                this.mousemovefunc = function (event) {
                    if (!isTouchDevice) {
                        if (event.which == 0) {
                            if (that.timer != null) {
                                clearInterval(that.timer);
                                that.timer = null;
                            }
                        }
                    }
                }

                this.addHandler(this.base.host, 'mousemove', this.mousemovefunc);
            },

            destroy: function () {
                var isTouchDevice = $.jqx.mobile.isTouchDevice();
                var up = !isTouchDevice ? 'mouseup.' + this.base.element.id : 'touchend.' + this.base.element.id;
                var down = !isTouchDevice ? 'mousedown.' + this.base.element.id : 'touchstart.' + this.base.element.id;
                this.removeHandler(this.base.host, 'mousemove', this.mousemovefunc);
                this.removeHandler(this.base.host, down);
                this.removeHandler($(document), up);
                this.timer = null;
                delete this.mousemovefunc;
                delete this.timer;
                var vars = $.data(this.base.element, "jqxRepeatButton");
                if (vars) {
                    delete vars.instance;
                }
                $(this.base.element).removeData();
                this.base.destroy();
                delete this.base;

            },

            stop: function () {
                clearInterval(this.timer);
                this.timer = null;
            },

            ontimer: function (event) {
                var event = new $.Event('click');
                if (this.base != null && this.base.host != null) {
                    this.base.host.trigger(event);
                }
            }
        });
        //// End of RepeatButton
        //// ToggleButton
        $.jqx.jqxWidget("jqxToggleButton", "jqxButton", {});

        $.extend($.jqx._jqxToggleButton.prototype, {
            defineInstance: function () {
                this.toggled = false;
                this.uiToggle = true;
                this.aria =
                {
                    "aria-checked": { name: "toggled", type: "boolean" },
                    "aria-disabled": { name: "disabled", type: "boolean" }
                };
            },

            createInstance: function (args) {
                var that = this;
                that.base.overrideTheme = true;
                that.isTouchDevice = $.jqx.mobile.isTouchDevice();
                $.jqx.aria(this);
                that.base.host.attr('role', 'checkbox');

                that.propertyChangeMap['roundedCorners'] = function (instance, key, oldVal, value) {
                    instance.base.buttonObj.removeClass(instance.toThemeProperty($.jqx.cssroundedcorners(oldVal)));
                    instance.base.buttonObj.addClass(instance.toThemeProperty($.jqx.cssroundedcorners(value)));
                };

                that.propertyChangeMap['toggled'] = function (instance, key, oldVal, value) {
                    instance.refresh();
                };
                that.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    instance.base.disabled = value;
                    instance.refresh();
                };

                that.addHandler(that.base.host, 'click', function (event) {
                    if (!that.base.disabled && that.uiToggle) {
                        that.toggle();
                    }
                });

                if (!that.isTouchDevice) {
                    that.addHandler(that.base.host, 'mouseenter', function (event) {
                        if (!that.base.disabled) {
                            that.refresh();
                        }
                    });

                    that.addHandler(that.base.host, 'mouseleave', function (event) {
                        if (!that.base.disabled) {
                            that.refresh();
                        }
                    });
                }

                that.addHandler(that.base.host, 'mousedown', function (event) {
                    if (!that.base.disabled) {
                        that.refresh();
                    }
                });

                that.addHandler($(document), 'mouseup.togglebutton' + that.base.element.id, function (event) {
                    if (!that.base.disabled) {
                        that.refresh();
                    }
                });
            },

            destroy: function () {
                this._removeHandlers();
                this.base.destroy();
            },

            _removeHandlers: function () {
                this.removeHandler(this.base.host, 'click');
                this.removeHandler(this.base.host, 'mouseenter');
                this.removeHandler(this.base.host, 'mouseleave');
                this.removeHandler(this.base.host, 'mousedown');
                this.removeHandler($(document), 'mouseup.togglebutton' + this.base.element.id);
            },

            toggle: function () {
                this.toggled = !this.toggled;
                this.refresh();
                $.jqx.aria(this, "aria-checked", this.toggled);
            },

            unCheck: function () {
                this.toggled = false;
                this.refresh();
            },

            check: function () {
                this.toggled = true;
                this.refresh();
            },

            refresh: function () {
                var that = this;
                var cssDisabled = that.base.toThemeProperty('jqx-fill-state-disabled');
                var cssNormal = that.base.toThemeProperty('jqx-fill-state-normal');
                if (!that.base.enableDefault) {
                    cssNormal = "";
                }
                var cssHover = that.base.toThemeProperty('jqx-fill-state-hover');
                var cssPressed = that.base.toThemeProperty('jqx-fill-state-pressed');
                var cssPressedHover = that.base.toThemeProperty('jqx-fill-state-pressed');
                var cssCurrent = '';
                that.base.element.disabled = that.base.disabled;

                if (that.base.disabled) {
                    cssCurrent = cssNormal + " " + cssDisabled;
                    that.base.buttonObj.addClass(cssCurrent);
                    return;
                }
                else {
                    if (that.base.isMouseOver && !that.isTouchDevice) {
                        if (that.base.isPressed || that.toggled)
                            cssCurrent = cssPressedHover;
                        else
                            cssCurrent = cssHover;
                    }
                    else {
                        if (that.base.isPressed || that.toggled)
                            cssCurrent = cssPressed;
                        else
                            cssCurrent = cssNormal;
                    }
                }

                if (that.base.template !== "default" && that.base.template !== "") {
                    cssCurrent += " " + "jqx-" + that.base.template;
                    if (that.base.theme != "") {
                        cssCurrent += " " + "jqx-" + that.template + "-" + that.base.theme;
                    }
                }

                if (that.base.buttonObj.hasClass(cssDisabled) && cssDisabled != cssCurrent) {
                    that.base.buttonObj.removeClass(cssDisabled);
                }

                if (that.base.buttonObj.hasClass(cssNormal) && cssNormal != cssCurrent) {
                    that.base.buttonObj.removeClass(cssNormal);
                }

                if (that.base.buttonObj.hasClass(cssHover) && cssHover != cssCurrent) {
                    that.base.buttonObj.removeClass(cssHover);
                }

                if (that.base.buttonObj.hasClass(cssPressed) && cssPressed != cssCurrent) {
                    that.base.buttonObj.removeClass(cssPressed);
                }

                if (that.base.buttonObj.hasClass(cssPressedHover) && cssPressedHover != cssCurrent) {
                    that.base.buttonObj.removeClass(cssPressedHover);
                }

                if (!that.base.buttonObj.hasClass(cssCurrent)) {
                    that.base.buttonObj.addClass(cssCurrent);
                }
            },

            _topDocumentMouseupHandler: function (event) {
                var that = this;
                that.isPressed = false;
                that.refresh();
            }
        });
        //// End of ToggleButton

    })(jqxBaseFramework);
})();



/***/ }),

/***/ 5725:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {

        $.jqx.jqxWidget("jqxCalendar", "", {});

        $.extend($.jqx._jqxCalendar.prototype, {
            defineInstance: function () {
                var settings = {
                    // enables or disables the Calendar control.
                    disabled: false,

                    // restricted dates
                    restrictedDates: new Array(),

                    // not available in this version.
                    multipleMonthRows: 1,

                    // not available in this version.
                    multipleMonthColumns: 1,

                    // Specifies the Calendar's minimum navigation date.
                    minDate: $.jqx._jqxDateTimeInput.getDateTime(new Date()),

                    // Specifies the Calendar's maximum navigation date.
                    maxDate: $.jqx._jqxDateTimeInput.getDateTime(new Date()),

                    min: new Date(1900, 0, 1),
                    max: new Date(2100, 0, 1),

                    navigationDelay: 400,
                    // Type: Number
                    // Default: 1
                    // Gets or sets the navigation step.
                    stepMonths: 1, // Number of months to step back/forward

                    // Type: Number
                    // Default: null
                    // Gets or sets the Calendar's width.
                    width: null,

                    // Type: height
                    // Default: null
                    // Gets or sets the Calendar's height.
                    height: null,

                    // Type: $.jqx._jqxDateTimeInput.getDateTime
                    // Default:  $.jqx._jqxDateTimeInput.getDateTime(new Date()), (Today)
                    // Gets or sets the Calendar's value.
                    value: $.jqx._jqxDateTimeInput.getDateTime(new Date()),

                    // Type: Number.
                    // Default: 0
                    // Gets or sets the first day of the week - Sunday : 0, Monday : 1, Tuesday : 2, Wednesday : 3, Thursday : 4, Friday : 5, Saturday : 6.
                    firstDayOfWeek: 0,

                    // Type: Boolean.
                    // Default: false.
                    // Shows or hides the week numbers.
                    showWeekNumbers: false,

                    // Type: Boolean.
                    // Default: true.
                    // Shows or hides the Day Names.
                    showDayNames: true,

                    // Type: Boolean
                    // Default: false
                    // Enables or disables the weekend highlight option.
                    enableWeekend: false,

                    // Type: Boolean
                    // Default: true
                    // Enables or disables the other month highlight.
                    enableOtherMonthDays: true,

                    // Type: Boolean
                    // Default: true
                    // Shows or hides the other month days.
                    showOtherMonthDays: true,

                    // Gets or sets the row header's width.
                    // Type: Number.
                    rowHeaderWidth: 25,

                    // Default: 20
                    // Gets or sets the column header's height.
                    // Type: Number.
                    columnHeaderHeight: 25,

                    // Default: 28
                    // Gets or sets the title's height.
                    // Type: Number.
                    titleHeight: 30,

                    // Type: String.
                    // Gets or sets the string format of the day names.
                    // Possible values: default, shortest, firstTwoLetters, firstLetter, full
                    dayNameFormat: 'firstTwoLetters',

                    monthNameFormat: 'default',

                    // Type: string.
                    // Represents the title format displayed between the navigation arrow.
                    titleFormat: ["MMMM yyyy", "yyyy", "yyyy", "yyyy"],
                    enableViews: true,
                    // Type: Boolean.
                    // Default: false
                    // Gets or sets the readonly state. In this state the user can navigate through the months, but is not allowed to select.
                    readOnly: false,

                    //Type: string
                    //Default: 'default'
                    //Gets or sets the calendar's culture.
                    culture: "default",

                    // Type: Boolean
                    // Default: true.
                    // Enables or disables the fast navigation when the user holds the mouse pressed over a navigation arrow.
                    enableFastNavigation: true,

                    // Type: Boolean
                    // Default: true
                    // Enables or disables the hover state.
                    enableHover: true,

                    // Type: Boolean
                    // Default: true
                    // When this property is true, click on other month date will automatically navigate to the previous or next month.
                    enableAutoNavigation: true,

                    // Type: Boolean
                    // Default: false
                    // enables or disabled the calendar tooltips.
                    enableTooltips: false,

                    // Type: String
                    // Back Button Text.
                    backText: "Back",
                    // Type: String
                    // Forward Button Text.
                    forwardText: "Forward",

                    // Type: Array
                    // Represents a collection of special calendar days.
                    specialDates: new Array(),
                    keyboardNavigation: true,
                    // Selects a range of dates.
                    selectionMode: 'default',
                    selectableDays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    todayString: 'Today',
                    clearString: 'Clear',
                    showFooter: false,
                    selection: { from: null, to: null },
                    canRender: true,
                    _checkForHiddenParent: true,
                    //Type: Number.
                    //Default: 0.
                    //Sets height of the calendar in pixels.
                    height: null,
                    rtl: false,
                    // month, year, decade
                    view: 'month',
                    views: ['month', 'year', 'decade'],
                    changing: null,
                    change: null,
                    localization: {
                        backString: "Back",
                        forwardString: "Forward",
                        todayString: "Today",
                        clearString: "Clear",
                        calendar: {
                            name: "Gregorian_USEnglish",
                            "/": "/",
                            // separator of parts of a time (e.g. ":" in 05:44 PM)
                            ":": ":",
                            // the first day of the week (0 : Sunday, 1 : Monday, etc)
                            firstDay: 0,
                            days: {
                                // full day names
                                names: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                                // abbreviated day names
                                namesAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                                // shortest day names
                                namesShort: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                            },
                            months: {
                                // full month names (13 months for lunar calendards -- 13th month should be "" if not lunar)
                                names: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""],
                                // abbreviated month names
                                namesAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""]
                            },
                            // AM and PM designators in one of these forms:
                            // The usual view, and the upper and lower case versions
                            //      [standard,lowercase,uppercase]
                            // The culture does not use AM or PM (likely all standard date formats use 24 hour time)
                            //      null
                            AM: ["AM", "am", "AM"],
                            PM: ["PM", "pm", "PM"],
                            eras: [
                                // eras in reverse chronological order.
                                // name: the name of the era in this culture (e.g. A.D., C.E.)
                                // start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
                                // offset: offset in years from gregorian calendar
                                { "name": "A.D.", "start": null, "offset": 0 }
                            ],
                            twoDigitYearMax: 2029,
                            patterns: {
                                // short date pattern
                                d: "M/d/yyyy",
                                // long date pattern
                                D: "dddd, MMMM dd, yyyy",
                                // short time pattern
                                t: "h:mm tt",
                                // long time pattern
                                T: "h:mm:ss tt",
                                // long date, short time pattern
                                f: "dddd, MMMM dd, yyyy h:mm tt",
                                // long date, long time pattern
                                F: "dddd, MMMM dd, yyyy h:mm:ss tt",
                                // month/day pattern
                                M: "MMMM dd",
                                // month/year pattern
                                Y: "yyyy MMMM",
                                // S is a sortable format that does not vary by culture
                                S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss",
                                // formatting of dates in MySQL DataBases
                                ISO: "yyyy-MM-dd hh:mm:ss"
                            }
                        }
                    },
                    // Calendar events.
                    events:
                        [
                            // occurs when the back button is clicked.
                            'backButtonClick',
                            // occurs when the forward button is clicked.
                            'nextButtonClick',
                            // occurs when the value is changed.
                            'valuechanged',
                            // occurs when the user clicks a cell.
                            'cellMouseDown',
                            // occurs when the user clicks a cell but is still holding the mouse key pressed.
                            'cellMouseUp',
                            // occurs when the user selects a cell.
                            'cellSelected',
                            // occurs when a cell is unselected. For example: user selects a cell and then selects another cell. The first selected cell is unselected.
                            'cellUnselected',
                            // occurs when the date is changed.
                            'change',
                            // occurs when the view is changed.
                            'viewChange'
                        ]
                };
                if (this === $.jqx._jqxCalendar.prototype) {
                    return settings;
                }
                $.extend(true, this, settings);

                this.minDate._setYear(1900);
                this.minDate._setMonth(1);
                this.minDate._setDay(1);
                this.minDate._setHours(0);
                this.minDate._setMinutes(0);
                this.minDate._setSeconds(0);
                this.minDate._setMilliseconds(0);
                this.maxDate._setYear(2100);
                this.maxDate._setMonth(1);
                this.maxDate._setDay(1);
                this.maxDate._setHours(0);
                this.maxDate._setMinutes(0);
                this.maxDate._setSeconds(0);
                this.maxDate._setMilliseconds(0);

                this.value._setHours(0);
                this.value._setMinutes(0);
                this.value._setSeconds(0);
                this.value._setMilliseconds(0);
                return settings;
            },

            _createFromInput: function (name) {
                var that = this;
                if (that.element.nodeName.toLowerCase() == "input") {
                    that.field = that.element;
                    if (that.field.className) {
                        that._className = that.field.className;
                    }

                    var properties = {
                        'title': that.field.title
                    };

                    if (that.field.value) {
                        properties.value = that.field.value;
                    }
                    if (that.field.checked) {
                        properties.checked = true;
                    }
                    if (that.field.id.length) {
                        properties.id = that.field.id.replace(/[^\w]/g, '_') + "_" + name;
                    }
                    else {
                        properties.id = $.jqx.utilities.createId() + "_" + name;
                    }
                    if (that.field.getAttribute('min')) {
                        var min = new Date(that.field.getAttribute('min'));
                        if (min != "Invalid Date") that.min = min;
                    }
                    if (that.field.getAttribute('max')) {
                        var max = new Date(that.field.getAttribute('max'));
                        if (max != "Invalid Date") that.max = max;
                    }
                    var wrapper = $("<div></div>", properties);
                    wrapper[0].style.cssText = that.field.style.cssText;
                    if (!that.width) {
                        that.width = $(that.field).width();
                    }
                    if (!that.height) {
                        that.height = $(that.field).outerHeight();
                    }
                    $(that.field).hide().after(wrapper);
                    var data = that.host.data();
                    that.host = wrapper;
                    that.host.data(data);
                    that.element = wrapper[0];
                    that.element.id = that.field.id;
                    that.field.id = properties.id;
                    if (that._className) {
                        that.host.addClass(that._className);
                        $(that.field).removeClass(that._className);
                    }

                    if (that.field.tabIndex) {
                        var tabIndex = that.field.tabIndex;
                        that.field.tabIndex = -1;
                        that.element.tabIndex = tabIndex;
                    }
                }
            },

            createInstance: function (args) {
                var that = this;
                that._createFromInput("jqxCalendar");

                if (that.isMaterialized()) {
                    var elementStyle = window.getComputedStyle(this.element);
                    var titleHeight = elementStyle.getPropertyValue('--jqx-calendar-title-height');
                    var columnHeaderHeight = elementStyle.getPropertyValue('--jqx-calendar-column-header-height');

                    if (titleHeight) {
                        this.titleHeight = parseInt(titleHeight);
                    }

                    if (columnHeaderHeight) {
                        this.columnHeaderHeight = parseInt(columnHeaderHeight);
                    }

                    if (this.theme === 'fluent') {
                        this.navigationDelay = 0;
                    }

                    setTimeout(function () {
                        that.refreshControl();
                    }, 200)
                }
                this.setCalendarSize();
                if (this.element.id === "") {
                    this.element.id = $.jqx.utilities.createId();
                }
                if ($.type(this.value) == "date") {
                    this.value = $.jqx._jqxDateTimeInput.getDateTime(this.value);
                }

                this.element.innerHTML = "";
                this.host.attr('data-role', 'calendar');
                var id = this.element.id;
                var me = this;
                this.propertyChangeMap['width'] = function (instance, key, oldVal, value) {
                    me.setCalendarSize();
                };

                this.propertyChangeMap['height'] = function (instance, key, oldVal, value) {
                    me.setCalendarSize();
                };

                if ($.global) {
                    $.global.preferCulture(this.culture);
                }

                if (this.culture != 'default') {
                    if ($.global) {
                        $.global.preferCulture(this.culture);
                        this.localization.calendar = $.global.culture.calendar;
                    }
                    else if (window.Globalize) {
                        var culture = window.Globalize.culture(this.culture);
                        this.localization.calendar = culture.calendar;
                    }
                    this.firstDayOfWeek = this.localization.calendar.firstDay;
                }
                if (this.localization.backString != "Back") {
                    this.backText = this.localization.backString;
                }
                if (this.localization.forwardString != "Forward") {
                    this.forwardText = this.localization.forwardString;
                }
                if (this.localization.todayString != "Today" && this.localization.todayString) {
                    this.todayString = this.localization.todayString;
                }
                if (this.localization.clearString != "Clear" && this.localization.clearString) {
                    this.clearString = this.localization.clearString;
                }
                if (this.localization.calendar && this.localization.calendar.firstDay != undefined && this.culture != "default") {
                    this.firstDayOfWeek = this.localization.calendar.firstDay;
                }

                this.setMaxDate(this.max, false);
                this.setMinDate(this.min, false);

                if (!this.host.attr('tabIndex')) {
                    this.host.attr('tabIndex', 0);
                }

                this.host.css('outline', 'none');
                this.host.addClass(this.toThemeProperty("jqx-calendar"));
                this.host.addClass(this.toThemeProperty("jqx-widget"));
                this.host.addClass(this.toThemeProperty("jqx-widget-content"));
                this.host.addClass(this.toThemeProperty("jqx-rc-all"));
                this._addInput();

                if (this.views.indexOf('month') == -1) this.view = "year";
                if (this.views.indexOf('year') == -1 && this.views.indexOf('month') == -1) this.view = "decade";

                this.addHandler(this.host, 'keydown',
                    function (event) {
                        var result = true;
                        if (me.keyboardNavigation) {
                            if (me._handleKey != undefined) {
                                result = me._handleKey(event);
                                if (!result) {
                                    if (event.stopPropagation) event.stopPropagation();
                                    if (event.preventDefault) event.preventDefault();
                                }
                            }
                        }
                        return result;
                    });

                var loaded = false;
                var myCalendar = this;

                var percentageSize = false;

                if (me.width != null && me.width.toString().indexOf("%") != -1) {
                    percentageSize = true;
                }

                if (me.height != null && me.height.toString().indexOf("%") != -1) {
                    percentageSize = true;
                }

                $.jqx.utilities.resize(this.host, function () {
                    var month = myCalendar.host.find("#View" + me.element.id);
                    if (!loaded) {
                        loaded = true;
                        myCalendar.render();
                    }
                    else myCalendar.refreshTitle(month);

                    if (percentageSize) {
                        if (me.refreshTimer) {
                            clearTimeout(me.refreshTimer);
                        }

                        me.refreshTimer = setTimeout(function () {
                            me.refreshControl();
                        }, 1);
                    }
                }, false, this._checkForHiddenParent);

                var calendarID = 'View';
                this.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    if (value) {
                        instance.host.addClass(me.toThemeProperty('jqx-fill-state-disabled'));
                    }
                    else {
                        instance.host.removeClass(me.toThemeProperty('jqx-fill-state-disabled'));
                    }
                    me.refreshControl();
                }
            },

            _addInput: function () {
                var name = this.host.attr('name');
                this.input = $("<input type='hidden'/>");
                this.host.append(this.input);
                if (name) {
                    this.input.attr('name', name);
                }
                this.input.val(this.getDate().toString());
            },

            setCalendarSize: function () {
                if (this.width != null && this.width.toString().indexOf("px") != -1) {
                    this.host.width(this.width);
                }
                else
                    if (this.width != undefined && !isNaN(this.width)) {
                        this.host.width(this.width);
                    }

                if (this.width != null && this.width.toString().indexOf("%") != -1) {
                    this.host.css('width', this.width);
                }

                if (this.height != null && this.height.toString().indexOf("px") != -1) {
                    this.host.height(this.height);
                }
                else if (this.height != undefined && !isNaN(this.height)) {
                    this.host.height(this.height);
                };

                if (this.height != null && this.height.toString().indexOf("%") != -1) {
                    this.host.css('height', this.height);
                }
            },

            _getYearAndMonthPart: function (date) {
                if (!date) {
                    return new Date(1900, 0, 1);
                }
                var newDate = new Date(date.getFullYear(), date.getMonth(), 1);
                return newDate;
            },

            _handleKey: function (event) {
                if (this.readOnly)
                    return true;

                var key = event.keyCode;
                var me = this;
                var selectedDate = this._getSelectedDate();
                if (selectedDate == undefined) {
                    if (this.view == "month" && (key == 37 || key == 38 || key == 39 || key == 40)) {
                        this.selectedDate = new Date(this.value.year, this.value.month - 1, 1);
                        this._selectDate(this.selectedDate, 'key');
                        selectedDate = this.selectedDate;
                    }
                    else {
                        return true;
                    }
                }

                if (event.altKey) {
                    return true;
                }

                if (this._animating)
                    return false;

                if (this.view != "month" && key == 13) {
                    var cell = this._getSelectedCell();
                    this._setDateAndSwitchViews(cell, event, "keyboard");
                }

                if (this.view == "year") {
                    var month = selectedDate.getMonth();
                    var minDate = this._getYearAndMonthPart(this.getMinDate());
                    var maxDate = this._getYearAndMonthPart(this.getMaxDate());

                    switch (key) {
                        case 37:
                            // previous
                            if (month == 0) {
                                var newDate = new Date(selectedDate.getFullYear() - 1, 11, 1);
                                if (newDate >= minDate) {
                                    this.selectedDate = newDate;
                                    this.navigateBackward();
                                }
                                else if (this.selectedDate != minDate) {
                                    this.selectedDate = minDate;
                                    this.navigateBackward();
                                }
                            }
                            else {
                                var newDate = new Date(selectedDate.getFullYear(), month - 1, 1)
                                if (newDate >= minDate) {
                                    this._selectDate(newDate, 'key');
                                }
                            }
                            return false;
                        case 38:
                            var newDate = new Date(selectedDate.getFullYear(), month - 4, 1);
                            if (newDate < minDate) {
                                newDate = minDate;
                            }

                            if (month - 4 < 0) {
                                this.selectedDate = newDate;
                                this.navigateBackward();
                            }
                            else {
                                this._selectDate(newDate, 'key');
                            }
                            return false;
                        case 40:
                            // down
                            var newDate = new Date(selectedDate.getFullYear(), month + 4, 1);
                            if (newDate > maxDate) {
                                newDate = maxDate;
                            }

                            if (month + 4 > 11) {
                                this.selectedDate = newDate;
                                this.navigateForward();
                            }
                            else {
                                this._selectDate(newDate, 'key');
                            }

                            return false;
                        case 39:
                            if (month == 11) {
                                var newDate = new Date(selectedDate.getFullYear() + 1, 0, 1);
                                if (newDate <= maxDate) {
                                    this.selectedDate = newDate;
                                    this.navigateForward();
                                }
                                else {
                                    if (this.selectedDate != maxDate) {
                                        this.selectedDate = maxDate;
                                        this.navigateForward();
                                    }
                                }
                            }
                            else {
                                var newDate = new Date(selectedDate.getFullYear(), month + 1, 1);
                                if (newDate <= maxDate) {
                                    this._selectDate(newDate, 'key');
                                }
                            }
                            // next
                            return false;
                    }
                    return true;
                }

                if (this.view == "decade") {
                    var startYear = this._renderStartDate.getFullYear();
                    var endYear = this._renderEndDate.getFullYear();
                    var fullYear = selectedDate.getFullYear();
                    var minYear = this.getMinDate().getFullYear();
                    var maxYear = this.getMaxDate().getFullYear();

                    switch (key) {
                        case 37:
                            // previous
                            if (fullYear - 1 >= minYear) {
                                if (fullYear <= startYear) {
                                    this.selectedDate = new Date(fullYear - 1, selectedDate.getMonth(), 1);
                                    this.navigateBackward();
                                }
                                else {
                                    this._selectDate(new Date(fullYear - 1, selectedDate.getMonth(), 1), 'key');
                                }
                            }
                            return false;
                        case 38:
                            // up
                            var newYear = fullYear - 4;
                            if (fullYear - 4 < minYear) newYear = minYear;

                            if (newYear < startYear) {
                                this.selectedDate = new Date(newYear, selectedDate.getMonth(), 1);
                                this.navigateBackward();
                            }
                            else {
                                this._selectDate(new Date(newYear, selectedDate.getMonth(), 1), 'key');
                            }
                            return false;
                        case 40:
                            // down
                            var newYear = fullYear + 4;
                            if (newYear > maxYear) newYear = maxYear;

                            if (newYear > endYear) {
                                this.selectedDate = new Date(newYear, selectedDate.getMonth(), 1);
                                this.navigateForward();
                            }
                            else {
                                this._selectDate(new Date(newYear, selectedDate.getMonth(), 1), 'key');
                            }

                            return false;
                        case 39:
                            // next
                            if (fullYear + 1 <= maxYear) {
                                if (fullYear == endYear) {
                                    this.selectedDate = new Date(fullYear + 1, selectedDate.getMonth(), 1);
                                    this.navigateForward();
                                }
                                else {
                                    this._selectDate(new Date(fullYear + 1, selectedDate.getMonth(), 1), 'key');
                                }
                            }
                            return false;
                    }

                    return true;
                }

                var date = new $.jqx._jqxDateTimeInput.getDateTime(selectedDate);
                var start = this.getViewStart();
                var end = this.getViewEnd();
                var oldDate = date;
                var monthInstance = $.data(this.element, "View" + this.element.id);
                if (monthInstance == undefined || monthInstance == null)
                    return true;

                if (key == 36) {
                    date._setDay(1);
                    if (this._isDisabled(date.dateTime)) {
                        return false;
                    }

                    this._selectDate(date.dateTime, 'key');
                    return false;
                }

                if (key == 35) {
                    var maxDays = this.value._daysInMonth(this.value.year, this.value.month);
                    date._setDay(maxDays);
                    if (this._isDisabled(date.dateTime)) {
                        return false;
                    }

                    this._selectDate(date.dateTime, 'key');
                    return false;
                }

                var step = 1;
                if (event.ctrlKey) step = 12;
                if (key == 34) {
                    var res = this.navigateForward(step);
                    if (res) {
                        date._addMonths(step);
                        if (this._isDisabled(date.dateTime)) {
                            return false;
                        }

                        this._selectDate(date.dateTime, 'key');
                    }
                    return false;
                }

                if (key == 33) {
                    var res = this.navigateBackward(step);
                    if (res) {
                        date._addMonths(-step);
                        if (this._isDisabled(date.dateTime)) {
                            return false;
                        }

                        this._selectDate(date.dateTime, 'key');
                    }
                    return false;
                }

                if (key == 38) {
                    date._addDays(-7);
                    if (date.dateTime < this.getMinDate())
                        return false;

                    if (date.dateTime < start) {
                        var res = this.navigateBackward();
                        if (!res)
                            return false;
                    }
                    if (this._isDisabled(date.dateTime)) {
                        return false;
                    }

                    this._selectDate(date.dateTime, 'key');
                    for (var i = 0; i < monthInstance.cells.length; i++) {
                        var cell = monthInstance.cells[i];
                        var cellDate = cell.getDate();
                        if (cell.isOtherMonth && cell.isSelected && cellDate <= date.dateTime) {
                            this.value.day = cellDate.getDate();
                            this.navigateBackward();
                            this._selectDate(date.dateTime, 'key');
                            break;
                        }
                    }
                    return false;
                }
                else if (key == 40) {
                    date._addDays(7);
                    if (date.dateTime > this.getMaxDate())
                        return false;

                    if (date.dateTime > end) {
                        var res = this.navigateForward();
                        if (!res)
                            return false;
                    }
                    if (this._isDisabled(date.dateTime)) {
                        return false;
                    }

                    this._selectDate(date.dateTime, 'key');
                    for (var i = 0; i < monthInstance.cells.length; i++) {
                        var cell = monthInstance.cells[i];
                        var cellDate = cell.getDate();
                        if (cell.isOtherMonth && cell.isSelected && cellDate >= date.dateTime) {
                            this.value.day = cellDate.getDate();
                            this.navigateForward();
                            this._selectDate(date.dateTime, 'key');
                            break;
                        }
                    }

                    return false;
                }

                if (key == 37) {
                    date._addDays(-1);
                    if (date.dateTime < this.getMinDate()) {
                        return false;
                    }

                    if (date.dateTime < start) {
                        var res = this.navigateBackward();
                        if (!res)
                            return false;
                    }
                    if (this._isDisabled(date.dateTime)) {
                        return false;
                    }

                    this._selectDate(date.dateTime, 'key');
                    for (var i = 0; i < monthInstance.cells.length; i++) {
                        var cell = monthInstance.cells[i];
                        var cellDate = cell.getDate();
                        if (cell.isOtherMonth && cell.isSelected && cellDate <= date.dateTime) {
                            if (date.dateTime < this.getMinDate() || date.dateTime > this.getMaxDate()) {
                                return false;
                            }
                            if (this._isDisabled(date.dateTime)) {
                                return false;
                            }

                            this.navigateBackward();
                            this._selectDate(date.dateTime, 'key');
                            break;
                        }
                    }

                    return false;
                }
                else if (key == 39) {
                    date._addDays(1);
                    if (date.dateTime > this.getMaxDate()) {
                        return false;
                    }

                    if (date.dateTime > end) {
                        var res = this.navigateForward();
                        if (!res)
                            return false;
                    }
                    if (this._isDisabled(date.dateTime)) {
                        return false;
                    }

                    this._selectDate(date.dateTime, 'key');
                    for (var i = 0; i < monthInstance.cells.length; i++) {
                        var cell = monthInstance.cells[i];
                        var cellDate = cell.getDate();
                        if (cell.isOtherMonth && cell.isSelected && cellDate >= date.dateTime) {
                            if (date.dateTime < this.getMinDate() || date.dateTime > this.getMaxDate()) {
                                return false;
                            }

                            this.navigateForward();
                            this._selectDate(date.dateTime, 'key');
                            break;
                        }
                    }
                    return false;
                }

                return true;
            },

            render: function () {
                if (!this.canRender) return;

                this.host.children().remove();
                var month = this._renderSingleCalendar("View" + this.element.id);
                var me = this;
                this.host.append(month);
            },

            // adds a special date to the calendar.
            // @param - Date.
            // @param - css class name(optional).
            // @param - string for the special date's tooltip(optional).
            addSpecialDate: function (date, className, tooltipContent) {
                if (this.multipleMonthRows == 1 && this.multipleMonthColumns == 1) {
                    var specialDatesLength = this.specialDates.length;
                    this.specialDates[specialDatesLength] = { Date: date, Class: className, Tooltip: tooltipContent };

                    this.refreshControl();
                }
            },

            refresh: function (initialRefresh) {
                var that = this;

                this.render();

                setTimeout(function () {
                    that.refreshControl();
                });
            },

            invalidate: function () {
                this.refreshControl();
            },

            refreshControl: function () {
                if (this.multipleMonthRows == 1 && this.multipleMonthColumns == 1) {
                    this.refreshSingleCalendar("View" + this.element.id, null);
                }
            },

            // gets the view's start date.
            getViewStart: function () {
                var visibleDate = this.getVisibleDate();
                var firstDay = this.getFirstDayOfWeek(visibleDate);
                return firstDay.dateTime;
            },

            // gets the view's end date.
            getViewEnd: function () {
                var start = this.getViewStart();
                var end = new $.jqx._jqxDateTimeInput.getDateTime(start);
                end._addDays(41);
                return end.dateTime;
            },

            refreshSingleCalendar: function (calendarID, parent) {
                if (!this.canRender) return;
                var month = this.host.find("#" + calendarID);
                var visibleDate = this.getVisibleDate();
                var firstDay = this.getFirstDayOfWeek(visibleDate);

                this.refreshCalendarCells(month, firstDay, calendarID);
                this.refreshTitle(month);
                this.refreshRowHeader(month, calendarID);
                if (this.selectedDate != undefined) {
                    this._selectDate(this.selectedDate);
                }

                var topPadding = parseInt(this.month.css('padding-top'));
                var h = this.host.height() - 2 * topPadding;

                var contentHeight = h - this.titleHeight - this.columnHeaderHeight;
                if (!this.showDayNames) {
                    contentHeight = this.month.height() - this.titleHeight;
                }
                if (this.showFooter) {
                    contentHeight -= 20;
                }

                var cellsTableElement = month.find("#cellsTable" + calendarID);
                var rowHeaderElement = month.find("#calendarRowHeader" + calendarID);
                cellsTableElement.height(contentHeight);
                rowHeaderElement.height(contentHeight);
            },

            refreshRowHeader: function (month, calendarID) {
                if (!this.showWeekNumbers)
                    return;

                var visibleDate = this.getVisibleDate();
                var firstDay = this.getFirstDayOfWeek(visibleDate);
                var dayOfWeek = firstDay.dayOfWeek;
                var weekOfYear = this.getWeekOfYear(firstDay);
                var newDate = new $.jqx._jqxDateTimeInput.getDateTime(new Date(firstDay.dateTime));
                newDate._addDays(5);
                newDate.dayOfWeek = newDate.dateTime.getDay();
                var newWeekOfYear = this.getWeekOfYear(newDate);

                var rowHeader = this.rowHeader.find('table');

                rowHeader.width(this.rowHeaderWidth);
                //   month.find("#calendarRowHeader" + month[0].id).append(rowHeader);
                var currentDate = firstDay;
                var rowHeaderCells = new Array();

                for (var i = 0; i < 6; i++) {
                    var weekString = weekOfYear.toString();
                    var cell = new $.jqx._jqxCalendar.cell(currentDate.dateTime);
                    var cellID = i + 1 + this.element.id;
                    var cellElement = $(rowHeader[0].rows[i].cells[0]);
                    cell.element = cellElement;
                    cell.row = i;
                    cell.column = 0;
                    var cellContent = cellElement.find("#headerCellContent" + cellID);
                    cellContent.addClass(this.toThemeProperty('jqx-calendar-row-cell'));
                    cellContent[0].innerHTML = weekOfYear;
                    rowHeaderCells[i] = cell;
                    currentDate = new $.jqx._jqxDateTimeInput.getDateTime(new Date(currentDate._addWeeks(1)));
                    weekOfYear = this.getWeekOfYear(currentDate);
                }

                var monthInstance = $.data(this.element, month[0].id);
                monthInstance.rowCells = rowHeaderCells;
                this._refreshOtherMonthRows(monthInstance, calendarID);
            },

            _refreshOtherMonthRows: function (month, calendarID) {
                if (this.showOtherMonthDays)
                    return;

                this._displayLastRow(true, calendarID);
                this._displayFirstRow(true, calendarID);

                var canDisplayFirstRow = false;
                var canDisplayLastRow = false;

                for (var i = 0; i < month.cells.length; i++) {
                    var cell = month.cells[i];
                    if (cell.isVisible && i < 7) {
                        canDisplayFirstRow = true;
                    }
                    else if (cell.isVisible && i >= month.cells.length - 7) {
                        canDisplayLastRow = true;
                    }
                }

                if (!canDisplayFirstRow) {
                    this._displayFirstRow(false, calendarID);
                }

                if (!canDisplayLastRow) {
                    this._displayLastRow(false, calendarID);
                }
            },

            _displayLastRow: function (show, calendarID) {
                var month = this.host.find("#" + calendarID);
                var calendarRowHeader = month.find("#calendarRowHeader" + month[0].id).find('table');
                var lastRow = null;
                if (this.showWeekNumbers) {
                    if (calendarRowHeader[0].cells) {
                        var lastRow = $(calendarRowHeader[0].rows[5]);
                    }
                }
                var lastMonthRow = $(month.find("#cellTable" + month[0].id)[0].rows[5]);
                if (show) {
                    if (this.showWeekNumbers && lastRow) {
                        lastRow.css('display', 'table-row');
                    }
                    lastMonthRow.css('display', 'table-row');
                }
                else {
                    if (this.showWeekNumbers && lastRow) {
                        lastRow.css('display', 'none');
                    }
                    lastMonthRow.css('display', 'none');
                }
            },

            _displayFirstRow: function (show, calendarID) {
                var month = this.host.find("#" + calendarID);
                var calendarRowHeader = month.find("#calendarRowHeader" + month[0].id).find('table');
                var firstRow = null;
                if (this.showWeekNumbers) {
                    if (calendarRowHeader[0].cells) {
                        var firstRow = $(calendarRowHeader[0].rows[0]);
                    }
                }
                var firstMonthRow = $(month.find("#cellTable" + month[0].id)[0].rows[0]);

                if (show) {
                    if (this.showWeekNumbers && firstRow) {
                        firstRow.css('display', 'table-row');
                    }
                    firstMonthRow.css('display', 'table-row');
                }
                else {
                    if (this.showWeekNumbers && firstRow) {
                        firstRow.css('display', 'none');
                    }
                    firstMonthRow.css('display', 'none');
                }
            },

            _renderSingleCalendar: function (calendarID, parent) {
                if (!this.canRender) return;

                var oldMonthElement = this.host.find("#" + calendarID.toString());
                if (oldMonthElement != null) {
                    oldMonthElement.remove();
                }

                var month = $("<div id='" + calendarID.toString() + "'></div>");

                var visibleDate = this.getVisibleDate();
                var firstDay = this.getFirstDayOfWeek(visibleDate);
                var endDay = new $.jqx._jqxDateTimeInput.getDateTime(firstDay.dateTime);
                endDay._addMonths(1);

                var monthInstance = $.jqx._jqxCalendar.monthView(firstDay, endDay, null, null, null, month);

                if (parent == undefined || parent == null) {
                    this.host.append(month);

                    month[0].style.width = "100%";
                    month[0].style.height = "100%";
                }
                else parent.append(month);

                $.data(this.element, calendarID, monthInstance);

                var topPadding = parseInt(month.css('padding-top'));
                var h = this.host.height() - 2 * topPadding;

                var contentHeight = h - this.titleHeight - this.columnHeaderHeight;
                if (!this.showDayNames) {
                    contentHeight = h - this.titleHeight;
                }
                if (this.showFooter) {
                    contentHeight -= 20;
                }

                if (this.rowHeaderWidth < 0) this.rowHeaderWidth = 0;
                if (this.columnHeaderHeight < 0) this.columnHeaderHeight = 0;
                if (this.titleHeight < 0) this.titleHeight = 0;

                var rowHeaderWidth = this.rowHeaderWidth;
                var columnHeaderHeight = this.columnHeaderHeight;

                if (!this.showWeekNumbers) {
                    rowHeaderWidth = 0;
                }

                if (!this.showDayNames) {
                    columnHeaderHeight = 0;
                }


                var title = "<div style='height:" + this.titleHeight + "px;'><table role='grid' style='margin: 0px; width: 100%; height: 100%; border-spacing: 0px;' cellspacing='0' cellpadding='0'><tr role='row' id='calendarTitle' width='100%'>" +
                    "<td role='gridcell' NOWRAP id='leftNavigationArrow'></td>" + "<td aria-live='assertive' aria-atomic='true' role='gridcell' align='center' NOWRAP id='calendarTitleHeader'></td>" + "<td role='gridcell' NOWRAP id='rightNavigationArrow'></td>" +
                    "</tr></table></div>";

                var monthStructure = "<table role='grid' class='" + this.toThemeProperty('jqx-calendar-month') + "' style='margin: 0px; border-spacing: 0px;' cellspacing='0' cellpadding='0'>" +
                    "<tr role='row' id='calendarHeader' height='" + columnHeaderHeight + "'>" +
                    "<td role='gridcell' id='selectCell' width='" + rowHeaderWidth + "'></td>" + "<td role='gridcell' colspan='2' style='border: none; padding-left: 2px; padding-right: 2px' id='calendarColumnHeader'></td>" +
                    "</tr>" +
                    "<tr role='row' id='calendarContent'>" +
                    "<td role='gridcell' id='calendarRowHeader' valign='top' height='" + contentHeight + "' width='" + rowHeaderWidth + "'></td>" + "<td role='gridcell' valign='top' colspan='2' style='padding-left: 2px; padding-right: 2px' id='cellsTable' height='" + contentHeight + "'></td>" +
                    "</tr>" +
                    "</table>"

                var footer = "<div id='footer' style='margin: 0px; display: none; height:" + footerHeight + "px;'><table style='width: 100%; height: 100%; border-spacing: 0px;' cellspacing='0' cellpadding='0'>" +
                    "<tr id='calendarFooter'>" +
                    "<td align='right' id='todayButton'></td>" + "<td align='left' colspan='2' id=doneButton></td>" +
                    "</tr>" + "</table></div>";


                month[0].innerHTML = title + monthStructure + footer;
                this.header = month.find('#calendarHeader');
                this.header[0].id = 'calendarHeader' + calendarID;
                this.header.addClass(this.toThemeProperty('calendar-header'));
                this.columnHeader = month.find('#calendarColumnHeader');
                this.columnHeader[0].id = 'calendarColumnHeader' + calendarID;
                this.table = month.find('#cellsTable');
                this.table[0].id = 'cellsTable' + calendarID;
                this.rowHeader = month.find('#calendarRowHeader');
                this.rowHeader[0].id = 'calendarRowHeader' + calendarID;
                this.selectCell = month.find('#selectCell');
                this.selectCell[0].id = 'selectCell' + calendarID;
                this.title = month.find('#calendarTitle');
                this.title[0].id = 'calendarTitle' + calendarID;
                this.leftButton = month.find('#leftNavigationArrow');
                this.leftButton[0].id = 'leftNavigationArrow' + calendarID;
                this.titleHeader = month.find('#calendarTitleHeader');
                this.titleHeader[0].id = 'calendarTitleHeader' + calendarID;
                this.rightButton = month.find('#rightNavigationArrow');
                this.rightButton[0].id = 'rightNavigationArrow' + calendarID;
                this.footer = month.find('#calendarFooter');
                this._footer = month.find('#footer');
                this._footer[0].id = 'footer' + calendarID
                this.footer[0].id = 'calendarFooter' + calendarID;
                this.todayButton = month.find('#todayButton');
                this.todayButton[0].id = 'todayButton' + calendarID;
                this.doneButton = month.find('#doneButton');
                this.doneButton[0].id = 'doneButton' + calendarID;

                this.title.addClass(this.toThemeProperty('jqx-calendar-title-container'));
                var footerHeight = 20;

                if (this.showFooter) {
                    this._footer.css('display', 'block');
                }

                //  month.find('td').css({ padding: 0, margin: 0, border: 'none' });
                month.find('tr').addClass(this.toThemeProperty('jqx-reset'));
                month.addClass(this.toThemeProperty("jqx-widget-content"));
                month.addClass(this.toThemeProperty("jqx-calendar-month-container"));
                this.month = month;
                this.selectCell.addClass(this.toThemeProperty('jqx-reset'));
                this.selectCell.addClass(this.toThemeProperty('jqx-calendar-top-left-header'));

                if (this.showWeekNumbers) {
                    this._renderRowHeader(month);
                }
                else {
                    this.table[0].colSpan = 3;
                    this.columnHeader[0].colSpan = 3;
                    this.rowHeader.css('display', 'none');
                    this.selectCell.css('display', 'none');
                }

                if (this.showFooter) {
                    this.footer.height(20);
                    var todayLink = $("<a href='javascript:;'>" + this.todayString + "</a>");
                    todayLink.appendTo(this.todayButton);
                    var clearLink = $("<a href='javascript:;'>" + this.clearString + "</a>");
                    clearLink.appendTo(this.doneButton);
                    clearLink.addClass(this.toThemeProperty('jqx-calendar-footer'));
                    todayLink.addClass(this.toThemeProperty('jqx-calendar-footer'));
                    var self = this;

                    var eventName = "mousedown";
                    if ($.jqx.mobile.isTouchDevice()) {
                        eventName = $.jqx.mobile.getTouchEventName('touchstart');
                    }

                    this.addHandler(todayLink, eventName, function () {
                        if (self.today) {
                            self.today();
                        }
                        else {
                            self.setDate(new Date(), 'mouse');
                        }
                        return false;
                    });
                    this.addHandler(clearLink, eventName, function () {
                        if (self.clear) {
                            self.clear();
                        }
                        else {
                            self.setDate(null, 'mouse');
                        }
                        return false;
                    });
                }

                if (this.view != "month") {
                    this.header.hide();
                }

                if (this.showDayNames && this.view == "month") {
                    this.renderColumnHeader(month);
                }

                this.oldView = this.view;
                this.renderCalendarCells(month, firstDay, calendarID)
                if (parent == undefined || parent == null) {
                    this.renderTitle(month);
                }
                this._refreshOtherMonthRows(monthInstance, calendarID);
                month.find('tbody').css({ border: 'none', background: 'transparent' });
                if (this.selectedDate != undefined) {
                    this._selectDate(this.selectedDate);
                }

                var me = this;
                this.addHandler(this.host, 'focus', function () {
                    me.focus();
                });

                return month;
            },

            _getTitleFormat: function () {
                switch (this.view) {
                    case 'month':
                        return this.titleFormat[0];
                    case 'year':
                        return this.titleFormat[1];
                    case 'decade':
                        return this.titleFormat[2];
                    case 'centuries':
                        return this.titleFormat[3];
                }
            },

            renderTitle: function (month) {
                var leftArrow = $("<div role='button' style='float: left;'></div>");
                var rightArrow = $("<div role='button' style='float: right;'></div>");
                var titleElement = this.title;
                titleElement.addClass(this.toThemeProperty("jqx-reset"));
                titleElement.addClass(this.toThemeProperty("jqx-widget-header"));
                titleElement.addClass(this.toThemeProperty("jqx-calendar-title-header"));
                var titleCells = titleElement.find('td');

                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                    if (titleCells.css('background-color') != 'transparent') {
                        var bgColor = titleElement.css('background-color');
                        titleCells.css('background-color', bgColor);
                    }
                    if (titleCells.css('background-image') != 'transparent') {
                        var bgImage = titleElement.css('background-image');
                        var bgRepeat = titleElement.css('background-repeat');
                        var bgPosition = titleElement.css('background-position');

                        titleCells.css('background-image', bgImage);
                        titleCells.css('background-repeat', bgRepeat);
                        titleCells.css('background-position', 'left center scroll');
                    }
                }
                else {
                    titleCells.css('background-color', 'transparent');
                }

                if (this.disabled) {
                    titleElement.addClass(this.toThemeProperty("jqx-calendar-title-header-disabled"));
                }

                leftArrow.addClass(this.toThemeProperty("jqx-calendar-title-navigation"));
                leftArrow.addClass(this.toThemeProperty("jqx-icon-arrow-left"));
                leftArrow[0].setAttribute('title', this.backText);
                leftArrow.appendTo(this.leftButton);
                var leftArrowElement = this.leftButton;

                rightArrow.addClass(this.toThemeProperty("jqx-calendar-title-navigation"));
                rightArrow.addClass(this.toThemeProperty("jqx-icon-arrow-right"));
                rightArrow.appendTo(this.rightButton);
                rightArrow[0].setAttribute('title', this.forwardText);
                var rightArrowElement = this.rightButton;

                if (this.enableTooltips) {
                    if ($(leftArrowElement).jqxTooltip) {
                        $(leftArrowElement).jqxTooltip({ name: this.element.id, position: 'mouse', theme: this.theme, content: this.backText });
                        $(rightArrowElement).jqxTooltip({ name: this.element.id, position: 'mouse', theme: this.theme, content: this.forwardText });
                    }
                }

                var titleHeader = this.titleHeader;
                var title = this._format(this.value.dateTime, this._getTitleFormat(), this.culture);
                if (this.view == "decade") {
                    var startText = this._format(this._renderStartDate, this._getTitleFormat(), this.culture);
                    var endText = this._format(this._renderEndDate, this._getTitleFormat(), this.culture);
                    title = startText + " - " + endText;
                }
                else if (this.view == "centuries") {
                    var startText = this._format(this._renderCenturyStartDate, this._getTitleFormat(), this.culture);
                    var endText = this._format(this._renderCenturyEndDate, this._getTitleFormat(), this.culture);
                    title = startText + " - " + endText;
                }

                var titleContent = $("<div style='background: transparent; margin: 0; padding: 0; border: none;'>" + title + "</div>");
                titleHeader.append(titleContent);
                titleContent.addClass(this.toThemeProperty('jqx-calendar-title-content'));

                var arrowWidth = parseInt(leftArrow.width());
                var headerWidth = month.width() - 2 * arrowWidth;
                var newContent = titleHeader.find(".jqx-calendar-title-content").width(headerWidth);

                $.data(leftArrow, 'navigateLeft', this);
                $.data(rightArrow, 'navigateRight', this);
                var isTouchDevice = $.jqx.mobile.isTouchDevice();

                if (!this.disabled) {
                    var me = this;
                    this.addHandler(titleHeader, 'mousedown',
                        function (event) {
                            if (me.enableViews) {
                                if (!me._viewAnimating && !me._animating) {
                                    var oldView = me.view;
                                    me.oldView = oldView;
                                    switch (me.view) {
                                        case 'month':
                                            me.view = "year";
                                            break;
                                        case 'year':
                                            me.view = "decade";
                                            break;
                                    }
                                    if (me.views.indexOf("year") == -1 && me.view == "year") {
                                        me.view = "decade";
                                    }
                                    if (me.views.indexOf("decade") == -1 && me.view == "decade") {
                                        me.view = oldView;
                                    }

                                    if (oldView != me.view) {
                                        var calendarID = "View" + me.element.id;
                                        var month = me.host.find("#" + calendarID);
                                        var visibleDate = me.getVisibleDate();
                                        var firstDay = me.getFirstDayOfWeek(visibleDate);
                                        me.renderCalendarCells(month, firstDay, calendarID, true);
                                        me.refreshTitle(month);
                                        me._raiseEvent('8');
                                    }
                                }
                                return false;
                            }
                        });

                    this.addHandler(leftArrow, 'mousedown',
                        function (event) {
                            if (!me._animating) {
                                $.data(leftArrow, 'navigateLeftRepeat', true);
                                var element = $.data(leftArrow, 'navigateLeft');
                                if (element.enableFastNavigation && !isTouchDevice) {
                                    element.startRepeat(element, leftArrow, true, me.navigationDelay + 200);
                                }
                                element.navigateBackward(me.stepMonths, 'arrow');
                                event.stopPropagation();
                                event.preventDefault();
                                return element._raiseEvent(0, event)
                            }
                            else return false;
                        });

                    this.addHandler(leftArrow, 'mouseup',
                        function (event) {
                            $.data(leftArrow, 'navigateLeftRepeat', false);
                        });

                    this.addHandler(leftArrow, 'mouseleave',
                        function (event) {
                            $.data(leftArrow, 'navigateLeftRepeat', false);
                        });

                    this.addHandler(rightArrow, 'mousedown',
                        function (event) {
                            if (!me._animating) {
                                $.data(rightArrow, 'navigateRightRepeat', true);
                                var element = $.data(rightArrow, 'navigateRight')

                                if (element.enableFastNavigation && !isTouchDevice) {
                                    element.startRepeat(element, rightArrow, false, me.navigationDelay + 200);
                                }
                                element.navigateForward(me.stepMonths, 'arrow');
                                event.stopPropagation();
                                event.preventDefault();
                                return element._raiseEvent(1, event)
                            }
                            else return false;
                        });

                    this.addHandler(rightArrow, 'mouseup',
                        function (event) {
                            $.data(rightArrow, 'navigateRightRepeat', false);
                        });

                    this.addHandler(rightArrow, 'mouseleave',
                        function (event) {
                            $.data(rightArrow, 'navigateRightRepeat', false);
                        });
                }
            },

            refreshTitle: function (month) {
                var title = this._format(this.value.dateTime, this._getTitleFormat(), this.culture);
                if (this.view == "decade") {
                    var startText = this._format(this._renderStartDate, this._getTitleFormat(), this.culture);
                    var endText = this._format(this._renderEndDate, this._getTitleFormat(), this.culture);
                    title = startText + " - " + endText;
                }
                else if (this.view == "centuries") {
                    var startText = this._format(this._renderCenturyStartDate, this._getTitleFormat(), this.culture);
                    var endText = this._format(this._renderCenturyEndDate, this._getTitleFormat(), this.culture);
                    title = startText + " - " + endText;
                }
                var titleHeader = this.titleHeader;
                if (this.titleHeader) {
                    var oldContent = titleHeader.find(".jqx-calendar-title-content");

                    var titleContent = $("<div style='background: transparent; margin: 0; padding: 0; border: none;'>" + title + "</div>");
                    titleHeader.append(titleContent);
                    titleContent.addClass(this.toThemeProperty('jqx-calendar-title-content'));

                    if (oldContent != null) {
                        oldContent.remove();
                    }
                }
            },

            startRepeat: function (element, navigationElement, isLeft, timeout) {
                var timeoutobj = window.setTimeout(function () {
                    var value = $.data(navigationElement, 'navigateLeftRepeat');
                    if (!isLeft) {
                        value = $.data(navigationElement, 'navigateRightRepeat');
                    }

                    if (value) {
                        if (timeout < 25) timeout = 25;

                        if (isLeft) {
                            element.navigateBackward(1, 'arrow');
                            element.startRepeat(element, navigationElement, true, timeout);
                        }
                        else {
                            element.navigateForward(1, 'arrow');
                            timeoutobj = element.startRepeat(element, navigationElement, false, timeout);
                        }
                    }
                    else {
                        window.clearTimeout(timeoutobj);
                        return;
                    }
                }, timeout);
            },

            // navigates (n) month(s) forward.
            // @param - Date
            navigateForward: function (step, type) {
                if (step == undefined || step == null) {
                    step = this.stepMonths;
                }
                var year = this.value.year;
                if (this.view == 'decade') {
                    year = this._renderStartDate.getFullYear() + 12;
                    if (this._renderEndDate.getFullYear() >= this.getMaxDate().getFullYear())
                        return;

                }
                else if (this.view == "year") {
                    year = this.value.year + 1;
                }
                else if (this.view == "centuries") {
                    year = this.value.year + 100;
                }

                if (this.view != "month") {
                    var maxYear = this.getMaxDate().getFullYear();
                    if (maxYear < year || year > maxYear) {
                        year = maxYear;
                    }
                    if (this.value.year == year) {
                        if (this.view === "decade") {
                            if (this.value.year > this._renderEndDate.getFullYear()) {
                                this.value.year = year;
                                this.value.month = 1;
                                this.value.day = 1;
                            }
                            else {
                                return;
                            }
                        }
                        else {
                            return;
                        }
                    }

                    this.value.year = year;
                    this.value.month = 1;
                    this.value.day = 1;
                }

                var day = this.value.day;
                var month = this.value.month;
                if (month + step <= 12) {
                    var maxDays = this.value._daysInMonth(this.value.year, this.value.month + step);
                    if (day > maxDays)
                        day = maxDays;
                }

                if (this.view == "month") {
                    var date = new Date(this.value.year, this.value.month - 1 + step, day);
                    if (type == 'arrow' && this.selectableDays.length == 7 && this.selectionMode != "range") {
                        this.selectedDate = new Date(this.value.year, this.value.month - 1 + step, 1);
                    }
                }
                else {
                    var date = new Date(this.value.year, this.value.month - 1, day)
                }

                return this.navigateTo(date);
            },

            // navigates (n) month(s) back.
            // @param - Number
            navigateBackward: function (step, type) {
                if (step == undefined || step == null) {
                    step = this.stepMonths;
                }

                var year = this.value.year;
                if (this.view == 'decade') {
                    year = this._renderStartDate.getFullYear() - 12;
                }
                else if (this.view == "year") {
                    year = this.value.year - 1;
                }
                else if (this.view == "centuries") {
                    year = this.value.year - 100;
                }

                if (this.view != "month") {
                    var minYear = this.getMinDate().getFullYear();
                    if (year < minYear) year = minYear;
                    if (this.view == "decade") {
                        if (this._renderStartDate) {
                            if (this._renderStartDate.getFullYear() == year) {
                                return;
                            }
                        }
                    }

                    // if (this.value.year == year) return;
                    this.value.year = year;
                    this.value.month = 1;
                    this.value.day = 1;
                }

                var day = this.value.day;
                var month = this.value.month;
                if (month - step >= 1) {
                    var maxDays = this.value._daysInMonth(this.value.year, this.value.month - step);
                    if (day > maxDays)
                        day = maxDays;
                }

                if (this.view == 'month') {
                    var date = new Date(this.value.year, this.value.month - 1 - step, day);
                    if (type == 'arrow' && this.selectableDays.length == 7 && this.selectionMode != "range") {
                        this.selectedDate = new Date(this.value.year, this.value.month - 1 - step, 1);
                    }
                }
                else {
                    var date = new Date(this.value.year, this.value.month - 1, day);
                }

                return this.navigateTo(date);
            },

            _isRestrictedRange: function (from, to) {
                if (from > to)
                    return true;

                var curr = from;
                while (curr.valueOf() <= to.valueOf()) {
                    if (this._isRestrictedDate(curr))
                        return true;

                    curr.setDate(curr.getDate() + 1);
                }

                return false;
            },

            _hasUnrestrictedRanges: function (from, to) {
                if (from > to)
                    return false;

                var curr = from;
                while (curr.valueOf() <= to.valueOf()) {
                    if (!this._isRestrictedDate(curr))
                        return true;

                    curr.setDate(curr.getDate() + 1);
                }

                return false;
            },

            _getNextUnrestrictedDay: function (from, to) {
                if (from > to)
                    return null;

                var curr = from;
                while (curr.valueOf() <= to.valueOf()) {
                    if (!this._isRestrictedDate(curr))
                        return curr;

                    curr.setDate(curr.getDate() + 1);
                }

                return null;
            },

            _isRestrictedDate: function (date) {
                var self = this;
                if (!$.isArray(self.restrictedDates))
                    return false;

                for (var i = 0; i < self.restrictedDates.length; i++) {
                    var dateCompare = self.restrictedDates[i];

                    if (typeof (dateCompare) == 'object' && dateCompare.from != undefined && dateCompare.to != undefined) {
                        var dateCompareFrom = dateCompare.from;
                        var dateCompareTo = dateCompare.to;

                        if (date.valueOf() >= dateCompareFrom.valueOf() && date.valueOf() <= dateCompareTo.valueOf()) {
                            return true;
                        }
                    }
                    else {
                        if (dateCompare.getMonth() == date.getMonth() &&
                            dateCompare.getDate() == date.getDate() &&
                            dateCompare.getFullYear() == date.getFullYear()
                        ) {
                            return true;
                        }
                    }
                }

                return false;
            },

            _isDisabled: function (date) {
                var dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                var day = date.getDay();
                var name = dayNames[day];
                if (this.selectableDays.indexOf(name) == -1)
                    return true;

                if (this._isRestrictedDate(date))
                    return true;

                return false;
            },

            refreshCalendarCells: function (month, firstDay, calendarID) {
                if (this.view == "year" || this.view == "decade" || this.view == 'centuries') {
                    this.refreshViews(month, firstDay, calendarID);
                    return;
                }
                var tableElement = this.table;
                var cellsTable = tableElement.find("#" + 'cellTable' + calendarID.toString());
                var currentDate = firstDay;
                var cells = new Array();
                var k = 0;
                var today = new $.jqx._jqxDateTimeInput.getDateTime(new Date());

                for (var i = 0; i < 6; i++) {
                    for (var j = 0; j < 7; j++) {
                        var cellRowID = i + 1;
                        var r = j;
                        if (this.rtl) r = 6 - r;
                        var cellColumnID = r + 1;
                        var cellID = "#cell" + cellRowID + cellColumnID + this.element.id;
                        var date = new Date(currentDate.dateTime.getFullYear(), currentDate.dateTime.getMonth(), currentDate.dateTime.getDate());
                        var cell = new $.jqx._jqxCalendar.cell(date);
                        var cellElement = $(cellsTable[0].rows[i].cells[cellColumnID - 1]);
                        cellElement[0].id = cellID.substring(1);

                        cell.element = cellElement;
                        cell.row = i;
                        cell.column = j;

                        cell.isVisible = true;
                        cell.isOtherMonth = false;
                        cell.isToday = false;
                        cell.isWeekend = false;
                        cell.isHighlighted = false;
                        cell.isSelected = false;

                        if (currentDate.month != this.value.month) {
                            cell.isOtherMonth = true;
                            cell.isVisible = this.showOtherMonthDays;
                        }

                        if (this._isRestrictedDate(date)) {
                            cell.isRestricted = true;
                            cell.isDisabled = true;
                        }

                        if (!cell.isDisabled) {
                            if (date < this.getMinDate() || date > this.getMaxDate() || this._isDisabled(date)) {
                                cell.isDisabled = true;
                            }
                        }

                        if (currentDate.month == today.month && currentDate.day == today.day && currentDate.year == today.year) {
                            cell.isToday = true;
                        }

                        if (currentDate.isWeekend()) {
                            cell.isWeekend = true;
                        }

                        $.data(this.element, "cellContent" + cellID.substring(1), cell);
                        $.data(this.element, cellID.substring(1), cell);
                        cells[k] = cell;
                        k++;
                        $.jqx.utilities.html(cellElement, currentDate.day);

                        this._applyCellStyle(cell, cellElement, cellElement);

                        currentDate = new $.jqx._jqxDateTimeInput.getDateTime(new Date(currentDate._addDays(1)));
                    }
                }

                var monthInstance = $.data(this.element, month[0].id);
                if (monthInstance != undefined && monthInstance != null) {
                    monthInstance.cells = cells;
                }
                this.renderedCells = cells;
                this._refreshOtherMonthRows(monthInstance, calendarID);
            },

            _getDecadeAndCenturiesData: function () {
                var renderYears = new Array();
                var renderDates = new Array();
                var length = this.getMaxDate().getFullYear() - this.getMinDate().getFullYear();
                if (length < 12) length = 12;
                var minDate = this.getMinDate();
                var maxDate = this.getMaxDate();
                var currentYear = this.value.dateTime.getFullYear();

                if (this.view == "decade") {
                    if (currentYear + 12 > maxDate.getFullYear()) {
                        currentYear = maxDate.getFullYear() - 11;
                    }
                    if (currentYear < minDate.getFullYear()) {
                        currentYear = minDate.getFullYear();
                    }
                    for (var i = 0; i < length; i++) {
                        var date = new Date(minDate.getFullYear() + i, 0, 1);
                        if (minDate.getFullYear() <= currentYear && currentYear <= date.getFullYear()) {
                            var renderStartDate = new Date(date.getFullYear(), date.getMonth(), 1);

                            for (var j = 0; j < 12; j++) {
                                var newDate = new Date(renderStartDate.getFullYear() + j, this.value.dateTime.getMonth(), this.value.dateTime.getDate());
                                var year = newDate.getFullYear();

                                if (minDate.getFullYear() <= year && year <= maxDate.getFullYear()) {
                                    renderYears.push(year);
                                    renderDates.push(newDate);
                                    if (j == 0) {
                                        this._renderStartDate = newDate;
                                    }
                                    this._renderEndDate = newDate;
                                }
                                else {
                                    renderYears.push(year);
                                    renderDates.push(newDate);
                                }

                            }

                            break;
                        }
                    }
                }
                else if (this.view == "centuries") {
                    for (var i = 0; i < length; i += 120) {
                        var date = new Date(minDate.getFullYear() + i + 120, 0, 1);

                        if (minDate.getFullYear() <= currentYear && currentYear <= date.getFullYear()) {
                            var renderStartDate = new Date(date.getFullYear() - 130, date.getMonth(), 1);

                            if (renderStartDate < minDate) {
                                renderStartDate = minDate;
                            }

                            for (var j = 0; j < 12; j++) {
                                var centuriesDate = new Date(renderStartDate.getFullYear() + j * 10, renderStartDate.getMonth(), 1);
                                if (renderStartDate.getFullYear() >= minDate.getFullYear() && centuriesDate.getFullYear() <= maxDate.getFullYear()) {
                                    renderYears.push("<span style='visibility: hidden;'>-</span>" + centuriesDate.getFullYear() + "-" + (centuriesDate.getFullYear() + 9));
                                    renderDates.push(centuriesDate);
                                    if (j == 0) {
                                        this._renderCenturyStartDate = centuriesDate;
                                    }
                                    this._renderCenturyEndDate = new Date(centuriesDate.getFullYear() + 9, 0, 1);
                                }
                            }
                            break;
                        }
                    }
                }
                return { years: renderYears, dates: renderDates };
            },

            refreshViews: function (month, firstDay, calendarID) {
                var me = this;
                var cells = new Array();
                var cellsTable = month.find('#cellTable' + calendarID.toString());

                var data = this._getDecadeAndCenturiesData();
                var renderYears = data.years;
                var renderDates = data.dates;

                var k = 0;
                var minDate = this.getMinDate();
                var maxDate = this.getMaxDate();

                for (var i = 0; i < 3; i++) {
                    for (var j = 0; j < 4; j++) {
                        var cellRowID = i + 1;
                        var r = j;
                        if (this.rtl) r = 3 - r;
                        var cellColumnID = r + 1;
                        var date = new Date(this.value.dateTime);
                        date.setDate(1);
                        date.setMonth(i * 4 + r);
                        var cell = new $.jqx._jqxCalendar.cell(date);
                        var row = cellsTable[0].rows["row" + (1 + i) + this.element.id];
                        var cellElement = $(row.cells[j]);

                        cell.isSelected = false;
                        cell.isVisible = true;
                        cell.element = cellElement;
                        cell.row = i;
                        cell.column = j;
                        cell.index = cells.length;
                        var text = "";
                        if (this.view == "year") {
                            var monthNames = this.localization.calendar.months.names;
                            var monthString = monthNames[i * 4 + r];

                            // Possible values: default, shortest, firstTwoLetters, firstLetter, full
                            switch (this.monthNameFormat) {
                                case 'default':
                                    monthString = this.localization.calendar.months.namesAbbr[i * 4 + r];
                                    break;
                                case 'shortest':
                                    monthString = this.localization.calendar.months.namesShort[i * 4 + r];
                                    break;
                                case 'firstTwoLetters':
                                    monthString = monthString.substring(0, 2);
                                    break;
                                case 'firstLetter':
                                    monthString = monthString.substring(0, 1);
                                    break;
                            }
                            text = monthString;
                        }
                        else if (this.view == "decade" || this.view == "centuries") {
                            text = renderYears[i * 4 + r];
                            if (undefined == text) {
                                text = "<span style='cursor: default; visibility: hidden;'>2013</span>";
                            }
                            cell.setDate(renderDates[i * 4 + r]);
                        }
                        var date = cell.getDate();
                        if (this.view == "year") {
                            if (date.getMonth() == this.getDate().getMonth() && date.getFullYear() == this.getDate().getFullYear()) {
                                cell.isSelected = true;
                            }
                        }
                        else {
                            if (date.getFullYear() == this.getDate().getFullYear()) {
                                cell.isSelected = true;
                            }
                        }

                        if (this.view == "year") {
                            if (this._getYearAndMonthPart(date) < this._getYearAndMonthPart(minDate))
                                cell.isDisabled = true;
                            if (this._getYearAndMonthPart(date) > this._getYearAndMonthPart(maxDate))
                                cell.isDisabled = true;
                        }
                        else {
                            if (date.getFullYear() < minDate.getFullYear())
                                cell.isDisabled = true;
                            if (date.getFullYear() > maxDate.getFullYear())
                                cell.isDisabled = true;
                        }

                        $.jqx.utilities.html(cellElement, text);
                        cells[k] = cell;
                        k++;
                    }
                }
                var monthInstance = $.data(this.element, month[0].id);
                if (monthInstance != undefined && monthInstance != null) {
                    monthInstance.cells = cells;
                }
                this.renderedCells = cells;
                this._applyCellStyles();
            },

            _createViewClone: function () {
                var table = this.host.find('.jqx-calendar-month');
                var viewClone = table.clone();
                viewClone.css('position', 'absolute');
                viewClone.css('top', table.position().top);
                viewClone.width(this.month.width());
                return viewClone;
            },

            _addCellsTable: function (tableElement, cellsTable) {
                var me = this;
                //            cellsTable.find('table').css({ background: 'none', padding: 0, margin: 0, border: 0 });
                //            cellsTable.find('td').css({ padding: 1, margin: 0 });
                //            cellsTable.find('tr').css({ background: 'none', padding: 0, margin: 0, border: 0 });

                var footerHeight = this.showFooter ? 20 : 0;
                if (this.view != "month") {
                    if (this.views.indexOf('month') === -1) {
                        cellsTable.height(this.host.height() - this.titleHeight);
                    }
                    else {
                        cellsTable.height(this.month.height() - this.titleHeight);
                    }
                }
                else {
                    cellsTable.height(this.month.height() - this.titleHeight - this.columnHeaderHeight - footerHeight);
                }

                this._viewAnimating = true;
                var container = this.host.find('.jqx-calendar-month-container');
                container.css('position', 'relative');
                var table = this.host.find('.jqx-calendar-month');
                var viewClone = this._createViewClone();
                container.append(viewClone);
                if (this.view != "month") {
                    this.header.fadeOut(0);
                    if (this.showWeekNumbers) {
                        this.rowHeader.fadeOut(0);
                    }
                    if (this.showFooter) {
                        this._footer.fadeOut(0);
                    }
                }
                else {
                    this.header.fadeIn(this.navigationDelay + 200);
                    if (this.showWeekNumbers) {
                        this.rowHeader.fadeIn(this.navigationDelay + 200);
                    }
                    if (this.showFooter) {
                        this._footer.fadeIn(this.navigationDelay + 200);
                    }
                }

                tableElement.children().remove();
                tableElement.append(cellsTable);

                this._animateViews(viewClone, cellsTable, function () {
                    if (!me.selectedDate && me.selectionMode != "range") {
                        me.selectedDate = me.renderedCells[0].getDate();
                    }
                    try {
                        me.renderedCells[0].element.focus();
                        setTimeout(function () {
                            me.renderedCells[0].element.focus();
                        }, 10);
                    }
                    catch (error) {
                    }

                    me._viewAnimating = false;
                });

                cellsTable.addClass(this.toThemeProperty("jqx-calendar-view"));
            },

            _animateViews: function (view1, view2, callback) {
                var me = this;
                me._viewAnimating = true;

                if (me.oldView == me.view) {
                    view1.remove();
                    view2.fadeOut(0);
                    view2.fadeIn(0);
                    callback();
                    return;
                }

                view1.fadeOut(this.navigationDelay + 100, function () {
                    view1.remove();
                });
                view2.fadeOut(0);
                view2.fadeIn(this.navigationDelay + 200, function () {
                    callback();
                });
            },

            focus: function () {
                if (this.disabled)
                    return;

                try {
                    if (this.renderedCells && this.renderedCells.length > 0) {
                        var me = this;
                        var focusChanged = false;
                        if (!me.selectedDate && me.selectionMode != 'range') {
                            this.setDate(new Date(), 'mouse');
                        }

                        this.element.focus();
                    }
                }
                catch (error) {
                }
            },

            renderViews: function (month, firstDay, calendarID) {
                var me = this;
                var cells = new Array();
                var cellsTable = $("<table role='grid' style='border-color: transparent; width: 100%; height: 100%;' cellspacing='2' cellpadding='0' id=" + 'cellTable' + calendarID.toString() + ">" +
                    "<tr role='row' id='row1" + this.element.id + "'>" +
                    "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" +
                    "</tr>" +
                    "<tr role='row' id='row2" + this.element.id + "'>" +
                    "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" +
                    "</tr>" +
                    "<tr role='row' id='row3" + this.element.id + "'>" +
                    "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" +
                    "</tr>" +
                    "</table>"
                );

                var container = this.host.find('.jqx-calendar-month-container');
                container.css('position', 'relative');
                var tableElement = month.find("#cellsTable" + month[0].id);
                tableElement[0].style.borderColor = "transparent";

                var data = this._getDecadeAndCenturiesData();
                var renderYears = data.years;
                var renderDates = data.dates;
                var k = 0;
                var minDate = this.getMinDate();
                var maxDate = this.getMaxDate();
                var valueDate = new Date(this.value.dateTime);
                valueDate.setDate(1);

                for (var i = 0; i < 3; i++) {
                    for (var j = 0; j < 4; j++) {
                        var cellRowID = i + 1;
                        var r = j;
                        if (this.rtl) r = 3 - r;
                        var cellColumnID = r + 1;
                        var row = cellsTable[0].rows["row" + (1 + i) + this.element.id];
                        var date = new Date(valueDate);
                        date.setMonth(i * 4 + r);
                        var cell = new $.jqx._jqxCalendar.cell(date);
                        var cellElement = $(row.cells[j]);
                        cell.isVisible = true;
                        cell.element = cellElement;
                        cell.row = i;
                        cell.column = j;
                        cell.index = cells.length;
                        cell.isSelected = false;

                        var text = "";
                        if (this.view == "year") {
                            if (date.getMonth() == this.getDate().getMonth() && date.getFullYear() == this.getDate().getFullYear()) {
                                cell.isSelected = true;
                            }
                            var monthNames = this.localization.calendar.months.names;
                            var monthString = monthNames[i * 4 + r];

                            // Possible values: default, shortest, firstTwoLetters, firstLetter, full
                            switch (this.monthNameFormat) {
                                case 'default':
                                    monthString = this.localization.calendar.months.namesAbbr[i * 4 + r];
                                    break;
                                case 'shortest':
                                    monthString = this.localization.calendar.months.namesShort[i * 4 + r];
                                    break;
                                case 'firstTwoLetters':
                                    monthString = monthString.substring(0, 2);
                                    break;
                                case 'firstLetter':
                                    monthString = monthString.substring(0, 1);
                                    break;
                            }
                            text = monthString;
                        }
                        else if (this.view == "decade" || this.view == "centuries") {
                            text = renderYears[i * 4 + r];
                            cell.setDate(renderDates[i * 4 + r]);
                            if (cell.getDate().getFullYear() == this.getDate().getFullYear()) {
                                cell.isSelected = true;
                            }
                            if (undefined == text) {
                                text = "<span style='cursor: default; visibility: hidden;'>2013</span>";
                            }
                        }

                        var date = cell.getDate();
                        if (this.view == "year") {
                            var nextMonth = new Date(date);
                            nextMonth.setDate(1);
                            nextMonth.setHours(0, 0, 0, 0);
                            nextMonth.setMonth(date.getMonth() + 1);
                            nextMonth = new Date(nextMonth.valueOf() - 1);

                            if (this._getYearAndMonthPart(date) < this._getYearAndMonthPart(minDate) ||
                                this._getYearAndMonthPart(date) > this._getYearAndMonthPart(maxDate) ||
                                !this._hasUnrestrictedRanges(date, nextMonth)) {
                                cell.isDisabled = true;
                            }
                        }
                        else {
                            var nextYear = new Date(date);
                            nextYear.setMonth(0);
                            nextYear.setDate(1);
                            nextYear.setHours(0, 0, 0, 0);

                            nextYear.setFullYear(date.getFullYear() + 1);
                            nextYear = new Date(nextYear.valueOf() - 1);

                            if (date.getFullYear() < minDate.getFullYear() ||
                                date.getFullYear() > maxDate.getFullYear() ||
                                !this._hasUnrestrictedRanges(date, nextYear)) {
                                cell.isDisabled = true;
                            }
                        }

                        $.jqx.utilities.html(cellElement, text);
                        cells[k] = cell;
                        k++;
                    }
                }
                $.each(cells, function () {
                    var element = this.element;
                    var cell = this;
                    if (!me.disabled) {
                        me.addHandler(element, 'mousedown',
                            function (event) {
                                me._setDateAndSwitchViews(cell, event, 'mouse');
                            });

                        me.addHandler(element, 'mouseover',
                            function (event) {
                                var renderCell = me.renderedCells[cell.index];
                                if (me.view != 'centuries' && renderCell.element.html().toLowerCase().indexOf('span') != -1) return;

                                renderCell.isHighlighted = true;
                                me._applyCellStyle(renderCell, renderCell.element, renderCell.element);
                            });

                        me.addHandler(element, 'mouseout',
                            function (event) {
                                var renderCell = me.renderedCells[cell.index];
                                if (me.view != 'centuries' && renderCell.element.html().toLowerCase().indexOf('span') != -1) return;

                                renderCell.isHighlighted = false;
                                me._applyCellStyle(renderCell, renderCell.element, renderCell.element);
                            });
                    }
                });

                var monthInstance = $.data(this.element, month[0].id);
                if (monthInstance != undefined && monthInstance != null) {
                    monthInstance.cells = cells;
                }
                this.renderedCells = cells;
                this._addCellsTable(tableElement, cellsTable);
                this._applyCellStyles();
            },

            _setDateAndSwitchViews: function (cell, event, type) {
                if (!this._viewAnimating && !this._animating) {
                    var oldDate = this.getDate();
                    var date = this.renderedCells[cell.index].getDate();
                    var day = this.value.dateTime.getDate();
                    var newDate = new Date(date);
                    if (this.views.indexOf('month') != -1) {
                        newDate.setDate(day);
                    }
                    else {
                        newDate.setDate(1);
                        date.setDate(1);
                    }

                    if (newDate.getMonth() == date.getMonth()) {
                        date = newDate;
                    }

                    var minDate = this.getMinDate();
                    var maxDate = this.getMaxDate();

                    if (this.view == "year") {
                        if (this._getYearAndMonthPart(date) < this._getYearAndMonthPart(minDate))
                            return;
                        if (this._getYearAndMonthPart(date) > this._getYearAndMonthPart(maxDate))
                            return;
                    }
                    else {
                        if (date.getFullYear() < minDate.getFullYear())
                            return;
                        if (date.getFullYear() > maxDate.getFullYear())
                            return;
                    }

                    if (this.selectionMode != "range") {
                        this._selectDate(date, type);
                    }
                    this.oldView = this.view;
                    switch (this.view) {
                        case "year":
                            this.view = 'month';
                            break;
                        case "decade":
                            this.view = 'year';
                            break;
                    }
                    if (this.views.indexOf('month') == -1) this.view = 'year';
                    if (this.views.indexOf('year') == -1) this.view = 'decade';

                    if (this.view == "year") {
                        if (this._getYearAndMonthPart(date) < this._getYearAndMonthPart(minDate))
                            date = minDate;

                        if (this._getYearAndMonthPart(date) > this._getYearAndMonthPart(maxDate))
                            date = maxDate;
                    }
                    else {
                        if (date.getFullYear() < minDate.getFullYear())
                            date = minDate;

                        if (date.getFullYear() > maxDate.getFullYear())
                            date = maxDate;
                    }

                    if (this.changing && (this.selectedDate && (this.selectedDate.getFullYear() != date.getFullYear() || this.selectedDate.getMonth() != date.getMonth() ||
                        this.selectedDate.getDate() != date.getDate()))) {
                        date = this.selectedDate;
                    }

                    this.value._setYear(date.getFullYear());
                    this.value._setDay(date.getDate());
                    this.value._setMonth(date.getMonth() + 1);
                    this.value._setDay(date.getDate());
                    var visibleDate = this.getVisibleDate();
                    var firstDay = this.getFirstDayOfWeek(visibleDate);
                    var calendarID = "View" + this.element.id;
                    this.renderCalendarCells(this.month, firstDay, calendarID, true);
                    this.refreshTitle(this.month);
                    if (this.showWeekNumbers) {
                        this.refreshRowHeader(this.month, calendarID);
                    }
                    if (this.views.length == 3) {
                        if (this.view == "month") {
                            if (this.selectionMode != "range") {
                                this._selectDate(this.selectedDate, 'view');
                            }
                            else {
                                var self = this;
                                $.each(this.renderedCells, function (index) {
                                    var cell = this;
                                    var cellDate = cell.getDate();
                                    var cellElement = $(cell.element);
                                    var cellContent = cellElement;
                                    if (cellElement.length == 0)
                                        return false;
                                    var getDatePart = function (date) {
                                        if (date == null) {
                                            return new Date();
                                        }

                                        var newDate = new Date();
                                        newDate.setHours(0, 0, 0, 0);
                                        newDate.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                                        return newDate;
                                    }

                                    if (!cell.isOtherMonth && getDatePart(cellDate).toString() == getDatePart(date).toString()) {
                                        self.value._setMonth(date.getMonth() + 1);
                                        self.value._setDay(date.getDate());
                                        self.value._setYear(date.getFullYear());
                                    }
                                    cell.isSelected = false;
                                    cell.isDisabled = false;

                                    if (getDatePart(cellDate) < getDatePart(self.selection.from) && self._clicks == 1) {
                                        cell.isDisabled = true;
                                    }
                                    if (self.getMaxDate() < cellDate) {
                                        cell.isDisabled = true;
                                    }
                                    if (self.getMinDate() > cellDate) {
                                        cell.isDisabled = true;
                                    }
                                    if (self._isDisabled(cellDate)) {
                                        cell.isDisabled = true;
                                    }

                                    if (!cell.isDisabled) {
                                        if (getDatePart(cellDate) >= getDatePart(self.selection.from) && getDatePart(cellDate) <= getDatePart(self.selection.to)) {
                                            cell.isSelected = true;
                                        }
                                    }
                                });
                                this._applyCellStyles();
                            }
                        }
                    }
                    if (this.view != "month") {
                        if (this.oldView == "year" || (this.views.indexOf("year") == -1 && this.view == "decade")) {
                            if (type != 'keyboard') {
                                this._raiseEvent('3');
                            }
                            this._raiseEvent('5', { selectionType: 'mouse' });
                        }
                    }
                    this._raiseEvent('8');
                }
            },

            renderCalendarCells: function (month, firstDay, calendarID, switchViews) {
                if (this.view == "year" || this.view == "decade" || this.view == 'centuries') {
                    this.renderViews(month, firstDay, calendarID);
                    return;
                }
                var cellsTable = $("<table role='grid' style='width: 100%; height: 100%; border-color: transparent;' cellspacing='2' cellpadding='1' id=" + 'cellTable' + calendarID.toString() + ">" +
                    "<tr role='row'>" +
                    "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" +
                    "</tr>" +
                    "<tr role='row'>" +
                    "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" +
                    "</tr>" +
                    "<tr role='row'>" +
                    "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" +
                    "</tr>" +
                    "<tr role='row'>" +
                    "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" +
                    "</tr>" +
                    "<tr role='row'>" +
                    "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" +
                    "</tr>" +
                    "<tr role='row'>" +
                    "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" +
                    "</tr>" +
                    "</table>"
                );

                var tableElement = this.table;
                tableElement[0].style.borderColor = "transparent";

                if (switchViews == undefined) {
                    var oldCellsTable = tableElement.find("#" + 'cellTable' + calendarID.toString());
                    if (oldCellsTable != null) {
                        oldCellsTable.remove();
                    }

                    tableElement.append(cellsTable);
                }

                var currentDate = firstDay;

                var startRow = this.showDayNames ? 1 : 0;
                var startColumn = this.showWeekNumbers ? 1 : 0;
                var cells = new Array();
                var k = 0;

                var cellWidth = (month.width() - this.rowHeaderWidth - 2) / 7;
                if (!this.showWeekNumbers) {
                    cellWidth = (month.width() - 2) / 7;
                }
                cellWidth = parseInt(cellWidth);
                var today = new $.jqx._jqxDateTimeInput.getDateTime(new Date());

                for (var i = 0; i < 6; i++) {
                    for (var j = 0; j < 7; j++) {
                        var cellRowID = i + 1;
                        var r = j;
                        if (this.rtl) r = 6 - r;
                        var cellColumnID = r + 1;
                        var cellID = "#cell" + cellRowID + cellColumnID + this.element.id;
                        var date = new Date(currentDate.dateTime.getFullYear(), currentDate.dateTime.getMonth(), currentDate.dateTime.getDate());
                        var cell = new $.jqx._jqxCalendar.cell(date);
                        var cellElement = $(cellsTable[0].rows[i].cells[cellColumnID - 1]);
                        cellElement[0].id = cellID.substring(1);

                        cell.isVisible = true;
                        cell.isDisabled = false;
                        if (currentDate.month != this.value.month) {
                            cell.isOtherMonth = true;
                            cell.isVisible = this.showOtherMonthDays;
                        }

                        if (this._isRestrictedDate(date)) {
                            cell.isRestricted = true;
                            cell.isDisabled = true;
                        }

                        if (!cell.isDisabled) {
                            if (date < this.getMinDate() || date > this.getMaxDate() || this._isDisabled(date)) {
                                cell.isDisabled = true;
                            }
                        }

                        if (currentDate.month == today.month && currentDate.day == today.day && currentDate.year == today.year) {
                            cell.isToday = true;
                        }

                        if (currentDate.isWeekend()) {
                            cell.isWeekend = true;
                        }

                        cell.element = cellElement;
                        cell.row = startRow;
                        cell.column = startColumn;
                        $.jqx.utilities.html(cellElement, currentDate.day);

                        currentDate = new $.jqx._jqxDateTimeInput.getDateTime(new Date(currentDate._addDays(1)));

                        $.data(this.element, "cellContent" + cellID.substring(1), cell);
                        $.data(this.element, "" + cellID.substring(1), cell);
                        var me = this;
                        if (me.isMaterialized()) {
                            $(cellElement).addClass('ripple');
                            $.jqx.ripple($(cellElement));
                        }
                        this.addHandler(cellElement, 'mousedown',
                            function (event) {
                                if (!me.readOnly && !me.disabled) {
                                    var content = $(event.target);
                                    var cell = $.data(me.element, content[0].id);

                                    var result = me._raiseEvent(3, event);
                                    if (cell != null && cell != undefined) {
                                        var date = cell.getDate();
                                        if (me.getMinDate() <= date && date <= me.getMaxDate()) {
                                            if (!cell.isDisabled) {
                                                if (cell.isOtherMonth && me.enableAutoNavigation) {
                                                    if (cell.row < 2)
                                                        me.navigateBackward();
                                                    else
                                                        me.navigateForward();
                                                    me._selectDate(cell.getDate(), 'mouse', event.shiftKey);
                                                }
                                                else {
                                                    var oldDate = new Date(me.getDate());
                                                    me._selectDate(cell.getDate(), 'mouse', event.shiftKey);
                                                    me.value._setYear(date.getFullYear());
                                                    me.value._setDay(1);
                                                    me.value._setMonth(date.getMonth() + 1);
                                                    me.value._setDay(date.getDate());
                                                    var table = me.host.find('.jqx-calendar-month');
                                                    table.stop();
                                                    table.css('margin-left', '0px');
                                                    var currentDate = me.getDate();
                                                    me._raiseEvent('2');
                                                    if (cell.isOtherMonth) {
                                                        me._raiseEvent('5', { selectionType: 'mouse' });
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    return false;
                                }
                            });

                        if (!me.disabled) {
                            var highlight = function (event, highlight) {
                                if (!me.readOnly) {
                                    var content = $(event.target);
                                    var cell = $.data(me.element, content[0].id);

                                    if (cell != null && cell != undefined) {
                                        var date = cell.getDate();
                                        if (me.getMinDate() <= date && date <= me.getMaxDate()) {
                                            cell.isHighlighted = highlight;
                                            me._applyCellStyle(cell, cell.element, content);
                                        }
                                    }
                                }
                            }

                            this.addHandler(cellElement, 'mouseenter',
                                function (event) {
                                    highlight(event, true);
                                    return false;
                                });

                            this.addHandler(cellElement, 'mouseleave',
                                function (event) {
                                    highlight(event, false);
                                    return false;
                                });
                        }

                        startColumn++;
                        cells[k] = cell;
                        k++;
                    }
                    startColumn = 0;
                    startRow++;
                }

                var monthInstance = $.data(this.element, month[0].id);
                if (monthInstance != undefined && monthInstance != null) {
                    monthInstance.cells = cells;
                }
                this.renderedCells = cells;
                if (switchViews != undefined) {
                    this._addCellsTable(tableElement, cellsTable);
                }
                this._applyCellStyles();
                this._refreshOtherMonthRows(monthInstance, calendarID);
            },

            // sets the maximum navigation date.
            // @param - Date
            setMaxDate: function (date, refresh) {
                if (date != null && typeof (date) == "string") {
                    date = new Date(date);
                    if (date == "Invalid Date")
                        return;
                }

                this.maxDate = $.jqx._jqxDateTimeInput.getDateTime(date);
                if (refresh !== false)
                    this.render();
            },

            // gets the maximum navigation date.
            getMaxDate: function () {
                if (this.maxDate != null && this.maxDate != undefined) {
                    return this.maxDate.dateTime;
                }

                return null;
            },

            // sets the minimum date.
            // @param - Date
            setMinDate: function (date, refresh) {
                if (date != null && typeof (date) == "string") {
                    date = new Date(date);
                    if (date == "Invalid Date")
                        return;
                }

                this.minDate = $.jqx._jqxDateTimeInput.getDateTime(date);
                if (refresh !== false)
                    this.render();
            },

            // gets the minimum date.
            getMinDate: function () {
                if (this.minDate != null && this.minDate != undefined) {
                    return this.minDate.dateTime;
                }

                return null;
            },


            // sets the calendar's date.
            // @param - Date
            navigateTo: function (date, reason) {
                if (this.view == 'month') {
                    var minDate = this.getMinDate();
                    var maxDate = new Date(this.getMaxDate().getFullYear(), this.getMaxDate().getMonth() + 1, this.getMaxDate().getDate());
                    if ((date < this._getYearAndMonthPart(minDate)) || (date > this._getYearAndMonthPart(maxDate))) {
                        return false;
                    }
                }
                else if (date && (date.getFullYear() < this.getMinDate().getFullYear() || date.getFullYear() > this.getMaxDate().getFullYear())) {
                    return false;
                }

                if (date == null) {
                    return false;
                }

                if (reason == undefined) {
                    var me = this;
                    if (this._animating) {
                        return;
                    }

                    this._animating = true;
                    var container = this.host.find('.jqx-calendar-month-container');
                    var animationContainer = $("<div></div>");

                    animationContainer[0].style.width = "100%";
                    animationContainer[0].style.height = "100%";
                    animationContainer[0].style.overflow = "hidden";
                    animationContainer[0].style.position = "relative";
                    animationContainer[0].style.left = "0px";
                    animationContainer[0].style.top = "-100%";
                    container.append(animationContainer);

                    if (this._viewClone) {
                        this._viewClone.stop();
                        this._viewClone.remove();
                    }
                    if (this._newViewClone) {
                        this._newViewClone.stop();
                        this._newViewClone.remove();
                    }

                    var table = this.host.find('.jqx-calendar-month');
                    table.stop();
                    table.css('margin-left', '0px');

                    var viewClone = table.clone();
                    this._viewClone = viewClone;
                    var value = new Date(this.value.dateTime);
                    this.value._setYear(date.getFullYear());
                    this.value._setDay(date.getDate());
                    this.value._setMonth(date.getMonth() + 1);

                    var topPadding = parseInt(this.month.css('padding-top'));


                    me.refreshControl();
                    animationContainer.css('overflow', 'hidden');
                    container.css('position', 'relative');
                    container.css('overflow', 'hidden');
                    viewClone.css('position', 'absolute');
                    viewClone.css('top', table.position().top - topPadding);

                    animationContainer.append(viewClone);
                    if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                        this.month.css('position', 'relative');
                        this.month.css('overflow', 'hidden');
                        this.table.css('position', 'relative');
                        this.table.css('overflow', 'hidden');
                    }

                    var width = -this.month.width();
                    if (date < value) {
                        if (this.view == "month" && date.getMonth() != value.getMonth()) {
                            width = this.month.width();
                        }
                        else if (date.getFullYear() != value.getFullYear()) {
                            width = this.month.width();
                        }
                    }

                    viewClone.animate({
                        marginLeft: parseInt(width) + 'px'
                    }, this.navigationDelay, function () {
                        viewClone.remove();
                    });
                    var newViewClone = table.clone();
                    this._newViewClone = newViewClone;
                    newViewClone.css('position', 'absolute');
                    newViewClone.css('top', table.position().top - topPadding);
                    animationContainer.append(newViewClone);
                    newViewClone.css('margin-left', -width);
                    table.css('visibility', 'hidden');
                    newViewClone.animate({
                        marginLeft: '0px'
                    }, this.navigationDelay, function () {
                        newViewClone.remove();
                        table.css('visibility', 'inherit');
                        animationContainer.remove();
                        me._animating = false;
                    });
                }
                else {
                    this.value._setYear(date.getFullYear());
                    this.value._setDay(date.getDate());
                    this.value._setMonth(date.getMonth() + 1);
                    var table = this.host.find('.jqx-calendar-month');
                    table.stop();
                    table.css('margin-left', '0px');

                    this.refreshControl();
                }


                this._raiseEvent('2');
                this._raiseEvent('8');
                return true;
            },

            // sets the calendar's date.
            // @param - Date
            setDate: function (date) {
                if (date != null && typeof (date) == "string") {
                    date = new Date(date);
                }

                if (this.canRender == false) {
                    this.canRender = true;
                    this.render();
                }
                this.navigateTo(date, 'api');
                this._selectDate(date);
                if (this.selectionMode == 'range') {
                    this._selectDate(date, 'mouse');
                }

                return true;
            },

            val: function (value) {
                if (arguments.length != 0) {
                    if (value == null)
                        this.setDate(null);

                    if (value instanceof Date)
                        this.setDate(value);

                    if (typeof (value) == "string") {
                        this.setDate(value);
                    }
                }
                return this.getDate();
            },

            // gets the calendar's date.
            getDate: function () {
                if (this.selectedDate == undefined)
                    return new Date();

                return this.selectedDate;
            },

            getValue: function () {
                if (this.value == undefined)
                    return new Date();

                return this.value.dateTime;
            },

            setRange: function (from, to) {
                if (this.canRender == false) {
                    this.canRender = true;
                    this.render();
                }

                this.navigateTo(from, 'api');
                this._selectDate(from, 'mouse');
                this._selectDate(to, 'mouse');
            },

            getRange: function () {
                return this.selection;
            },

            // selects a date.
            // @param - Date
            _selectDate: function (date, type, shift) {
                if (this.selectionMode == 'none')
                    return;

                if (type == null || type == undefined) type = 'none';
                if (shift == null || shift == undefined) shift = false;

                var monthInstance = $.data(this.element, "View" + this.element.id);
                if (monthInstance == undefined || monthInstance == null)
                    return;

                if (this.changing) {
                    if (date && this.selectedDate) {
                        if (this.selectedDate.getFullYear() != date.getFullYear() || this.selectedDate.getDate() != date.getDate() || this.selectedDate.getMonth() != date.getMonth())
                            var newDate = this.changing(this.selectedDate, date);
                        if (newDate) {
                            date = newDate;
                        }
                    }
                }

                var self = this;
                if (this.input) {
                    if (date != null) {
                        this.input.val(date.toString());
                    }
                    else this.input.val("");
                }
                var oldDate = this.selectedDate;
                this.selectedDate = date;

                if (this.view != "month") {
                    if (oldDate != date) {
                        this._raiseEvent(7, { selectionType: type });
                    }

                    $.each(this.renderedCells, function (index) {
                        var cell = this;
                        var cellDate = cell.getDate();
                        var cellElement = $(cell.element);
                        var cellContent = cellElement.find("#cellContent" + cellElement[0].id);
                        if (date == null) {
                            cell.isSelected = false;
                            cell.isDisabled = false;
                        }
                        else {
                            cell.isSelected = false;
                            if (cellDate) {
                                if ((cellDate.getMonth() == date.getMonth() && self.view == "year" && cellDate.getFullYear() == date.getFullYear()) || (self.view == "decade" && cellDate.getFullYear() == date.getFullYear())) {
                                    cell.isSelected = true;
                                    try {
                                        if (type != "none") {
                                            cell.element.focus();
                                        }
                                    }
                                    catch (error) {
                                    }
                                }
                            }
                        }
                        self._applyCellStyle(cell, cellElement, cellElement);
                    });
                    if (this.change) {
                        this.change(date);
                    }
                    return;
                }

                if (this.view == "month") {
                    if (this.selectionMode == "range" && type == "key") {
                        var visibleDate = this.getVisibleDate();
                        var firstDay = this.getFirstDayOfWeek(visibleDate);
                        this.refreshCalendarCells(this.month, firstDay, "View" + this.element.id);
                    }
                }

                var cellDisabledDefault = false;

                $.each(this.renderedCells, function (index) {
                    var cell = this;
                    var cellDate = cell.getDate();
                    var cellElement = $(cell.element);
                    var cellContent = cellElement;
                    if (cellElement.length == 0)
                        return false;


                    if (date == null) {
                        cell.isSelected = false;
                        cell.isDisabled = false;
                        if (index == 0) {
                            self.selection = { from: null, to: null };
                            self._raiseEvent('2');
                            self._raiseEvent('5', { selectionType: type });
                        }
                    }
                    else {
                        if (self.selectionMode != 'range' || type == 'key') {
                            if (cellDate.getDate() == date.getDate() && cellDate.getMonth() == date.getMonth() && cellDate.getFullYear() == date.getFullYear() && cell.isSelected) {
                                self._applyCellStyle(cell, cellElement, cellContent);
                                self._raiseEvent('5', { selectionType: type });
                                return;
                            }

                            if (cell.isSelected) {
                                self._raiseEvent('6', { selectionType: type });
                            }

                            cell.isSelected = false;
                            if (cellDate.getDate() == date.getDate() && cellDate.getMonth() == date.getMonth() && cellDate.getFullYear() == date.getFullYear()) {
                                cell.isSelected = true;
                                if (index == 0) {
                                    self.selection = { date: date };
                                }
                                try {
                                    if (type != "none") {
                                        cell.element.focus();
                                        self.host.focus();
                                    }
                                }
                                catch (error) {
                                }

                                if (!cell.isOtherMonth) {
                                    self.value._setMonth(date.getMonth() + 1);
                                    self.value._setDay(date.getDate());
                                    self.value._setYear(date.getFullYear());
                                    self._raiseEvent('2');
                                    self._raiseEvent('5', { selectionType: type });
                                }
                            }
                            if (self.selectionMode == 'range') {
                                self._clicks = 0;
                                self.selection = { from: date, to: date };
                            }
                        }
                        else if (self.selectionMode == 'range') {
                            if (type == "view") {
                                cell.isSelected = false;
                                cell.isDisabled = false;
                                if (self.getMaxDate() < cellDate) {
                                    cell.isDisabled = true;
                                }
                                if (self.getMinDate() > cellDate) {
                                    cell.isDisabled = true;
                                }

                                if (self._isRestrictedDate(cellDate)) {
                                    cell.isDisabled = true;
                                    cell.isRestricted = true;
                                }

                                if (!cell.isDisabled && self._isDisabled(cellDate)) {
                                    cell.isDisabled = true;
                                }

                                self._applyCellStyle(cell, cellElement, cellContent);
                                return true;
                            }

                            if (index == 0) {
                                if (type != 'none') {
                                    if (self._clicks == undefined) self._clicks = 0;
                                    self._clicks++;
                                    if (shift) {
                                        self._clicks++;
                                    }

                                    if (self._clicks == 1) {
                                        self.selection = { from: date, to: date };
                                    }
                                    else {
                                        var from = self.selection.from;
                                        var min = from <= date ? from : date;
                                        var max = from <= date ? date : from;
                                        if (min) {
                                            var start = new Date(min.getFullYear(), min.getMonth(), min.getDate());
                                        }
                                        if (max) {
                                            var end = new Date(max.getFullYear(), max.getMonth(), max.getDate(), 23, 59, 59);
                                        }
                                        self.selection = { from: start, to: end };
                                        self._clicks = 0;
                                    }
                                }
                                else {
                                    if (self.selection == null || self.selection.from == null) {
                                        self.selection = { from: date, to: date };
                                        if (self._clicks == undefined) self._clicks = 0;
                                        self._clicks++;
                                        if (self._clicks == 2) self._clicks = 0;
                                    }
                                }
                            }

                            var getDatePart = function (date) {
                                if (date == null) {
                                    return new Date();
                                }

                                var newDate = new Date();
                                newDate.setHours(0, 0, 0, 0);
                                newDate.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                                return newDate;
                            }

                            if (!cell.isOtherMonth && getDatePart(cellDate).toString() == getDatePart(date).toString()) {
                                self.value._setMonth(date.getMonth() + 1);
                                self.value._setDay(date.getDate());
                                self.value._setYear(date.getFullYear());
                                self._raiseEvent('2');
                                self._raiseEvent('5', { selectionType: type });
                            }
                            cell.isSelected = false;
                            cell.isDisabled = cellDisabledDefault;

                            if (getDatePart(cellDate) < getDatePart(self.selection.from) && self._clicks == 1) {
                                cell.isDisabled = true;
                            }
                            if (self.getMaxDate() < cellDate) {
                                cell.isDisabled = true;
                            }
                            if (self.getMinDate() > cellDate) {
                                cell.isDisabled = true;
                            }

                            if (self._isRestrictedDate(cellDate)) {
                                cell.isRestricted = true;
                                cell.isDisabled = true;
                            }

                            if (!cell.isDisabled && self._isDisabled(cellDate)) {
                                cell.isDisabled = true;
                            }

                            if (!cell.isDisabled) {
                                if (getDatePart(cellDate) >= getDatePart(self.selection.from) && getDatePart(cellDate) <= getDatePart(self.selection.to)) {
                                    cell.isSelected = true;
                                }
                            }
                            else if (!self.allowRestrictedDaysInRange && getDatePart(cellDate) >= getDatePart(self.selection.from) && self.selection.to == self.selection.from) {
                                // disable all cells after the first non-selectable cell in the sequence
                                cellDisabledDefault = true;
                            }
                        }
                    }

                    self._applyCellStyle(cell, cellElement, cellContent);
                });

                if (self.selectionMode == "range" && self._clicks == 0) {
                    self._raiseEvent(7, { selectionType: type });
                    return;
                }
                else if (self.selectionMode == "range")
                    return;

                if (oldDate != date) {
                    self._raiseEvent(7, { selectionType: type });
                    if (this.change) {
                        this.change(date);
                    }
                }
            },

            // gets the selected date.
            _getSelectedDate: function () {
                var monthInstance = $.data(this.element, "View" + this.element.id);
                if (monthInstance == undefined || monthInstance == null)
                    return;

                if (this.view != "month")
                    return this.selectedDate;

                for (var i = 0; i < monthInstance.cells.length; i++) {
                    var cell = monthInstance.cells[i];
                    var cellDate = cell.getDate();
                    if (cell.isSelected) {
                        return cellDate;
                    }
                }
                if (this.selectedDate) {
                    return this.selectedDate;
                }
            },

            // gets the selected cell.
            _getSelectedCell: function () {
                var monthInstance = $.data(this.element, "View" + this.element.id);
                if (monthInstance == undefined || monthInstance == null)
                    return;

                for (var i = 0; i < monthInstance.cells.length; i++) {
                    var cell = monthInstance.cells[i];
                    var cellDate = cell.getDate();
                    if (cell.isSelected) {
                        return cell;
                    }
                }
            },

            _applyCellStyle: function (cell, cellElement, cellContent) {
                var self = this;
                if (cellContent == null || (cellContent != null && cellContent.length == 0)) {
                    cellContent = cellElement;
                }

                var cssClassName = "";
                cssClassName = this.toThemeProperty("jqx-rc-all");
                cssClassName += " " + this.toThemeProperty("jqx-item");
                if (this.disabled || (cell.isDisabled && !cell.isRestricted)) {
                    cssClassName += " " + this.toThemeProperty("jqx-calendar-cell-disabled");
                    cssClassName += " " + this.toThemeProperty("jqx-fill-state-disabled");
                }

                if (!this.disabled && cell.isRestricted) {
                    cssClassName += " " + this.toThemeProperty("jqx-calendar-cell-restrictedDate");
                }

                if (cell.isOtherMonth && this.enableOtherMonthDays && cell.isVisible) {
                    cssClassName += " " + this.toThemeProperty("jqx-calendar-cell-othermonth");
                }

                if (cell.isWeekend && this.enableWeekend && cell.isVisible && cell.isVisible) {
                    cssClassName += " " + this.toThemeProperty("jqx-calendar-cell-weekend");
                }

                if (this.isMaterialized()) {
                    cssClassName += " ripple";
                }

                if (!cell.isVisible) {
                    cssClassName += " " + this.toThemeProperty("jqx-calendar-cell-hidden");
                }
                else {
                    cssClassName += " " + this.toThemeProperty("jqx-calendar-cell");
                    if (this.view != "month") {
                        if (cellContent.length > 0 && cellContent.html().toLowerCase().indexOf('span') != -1) {
                            cellContent.css('cursor', 'default');
                        }
                    }
                }

                cellContent.removeAttr('aria-selected');
                if (cell.isSelected && cell.isVisible) {
                    cssClassName += " " + this.toThemeProperty("jqx-calendar-cell-selected");
                    cssClassName += " " + this.toThemeProperty("jqx-fill-state-pressed");
                    cellContent.attr('aria-selected', true);
                    this.host.removeAttr("aria-activedescendant").attr("aria-activedescendant", cellContent[0].id);
                    var date = cell.getDate();
                    if (this._isDisabled(date)) {
                        cssClassName += " " + this.toThemeProperty("jqx-calendar-cell-selected-invalid");
                    }
                }

                if (cell.isHighlighted && cell.isVisible && this.enableHover) {
                    if (!cell.isDisabled) {
                        cssClassName += " " + this.toThemeProperty("jqx-calendar-cell-hover");
                        cssClassName += " " + this.toThemeProperty("jqx-fill-state-hover");
                    }
                }

                cssClassName += " " + this.toThemeProperty("jqx-calendar-cell-" + this.view);

                if (cell.isToday && cell.isVisible) {
                    cssClassName += " " + this.toThemeProperty("jqx-calendar-cell-today");
                }
                cellContent[0].className = cssClassName;

                if (this.specialDates.length > 0) {
                    var me = this;
                    $.each(this.specialDates, function () {
                        if (this.Class != undefined && this.Class != null && this.Class != '') {
                            cellContent.removeClass(this.Class);
                        }
                        else {
                            cellContent.removeClass(self.toThemeProperty("jqx-calendar-cell-specialDate"));
                        }

                        var date = cell.getDate();

                        if (date.getFullYear() == this.Date.getFullYear() && date.getMonth() == this.Date.getMonth() && date.getDate() == this.Date.getDate()) {
                            if (cell.tooltip == null && this.Tooltip != null) {
                                cell.tooltip = this.Tooltip;
                                if ($(cellContent).jqxTooltip) {
                                    var className = this.Class;
                                    $(cellContent).jqxTooltip({
                                        value: { cell: cell, specialDate: this.Date },
                                        name: me.element.id, content: this.Tooltip, position: 'mouse', theme: me.theme,
                                        opening: function (tooltip) {
                                            if (cellContent.hasClass(self.toThemeProperty("jqx-calendar-cell-specialDate"))) {
                                                return true;
                                            }
                                            if (cellContent.hasClass(className)) {
                                                return true;
                                            }
                                            return false;
                                        }
                                    });
                                }
                            }

                            cellContent.removeClass(self.toThemeProperty("jqx-calendar-cell-othermonth"));
                            cellContent.removeClass(self.toThemeProperty("jqx-calendar-cell-weekend"));

                            if (this.Class == undefined || this.Class == '') {
                                cellContent.addClass(self.toThemeProperty("jqx-calendar-cell-specialDate"));
                                return false;
                            }
                            else {
                                cellContent.addClass(this.Class);
                                return false;
                            }
                        }
                    }
                    );
                }
            },

            _applyCellStyles: function () {
                var monthInstance = $.data(this.element, "View" + this.element.id);
                if (monthInstance == undefined || monthInstance == null)
                    return;

                for (var i = 0; i < monthInstance.cells.length; i++) {
                    var cell = monthInstance.cells[i];
                    var cellElement = $(cell.element);
                    var cellContent = cellElement.find("#cellContent" + cellElement[0].id);
                    if (cellContent.length == 0) cellContent = cellElement;
                    this._applyCellStyle(cell, cellElement, cellContent);
                }
            },

            // gets the week of year by Date.
            getWeekOfYear: function (date) {
                var dateObj = new Date(date.dateTime);
                var dowOffset = this.firstDayOfWeek; //default dowOffset to zero
                var newYear = new Date(dateObj.getFullYear(), 0, 1);
                var day = newYear.getDay() - dowOffset; //the day of week the year begins on
                day = (day >= 0 ? day : day + 7);
                var daynum = Math.floor((dateObj.getTime() - newYear.getTime() -
                    (dateObj.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
                var weeknum;
                //if the year starts before the middle of a week
                if (day < 4) {
                    weeknum = Math.floor((daynum + day - 1) / 7) + 1;
                    if (weeknum > 52) {
                        var nYear = new Date(dateObj.getFullYear() + 1, 0, 1);
                        var nday = nYear.getDay() - dowOffset;
                        nday = nday >= 0 ? nday : nday + 7;
                        /*if the next year starts before the middle of
                          the week, it is week #1 of that year*/
                        weeknum = nday < 4 ? 1 : 53;
                    }
                }
                else {
                    weeknum = Math.floor((daynum + day - 1) / 7);
                }
                return weeknum;

                //var dayOfYear = date.dayOfYear(date.dateTime) - 1;
                //var week = date.dayOfWeek - (dayOfYear % 7);
                //var offset = ((week - this.firstDayOfWeek) + 14) % 7;
                //return Math.ceil((((dayOfYear + offset) / 7) + 1));
            },

            renderColumnHeader: function (month) {
                if (!this.showDayNames)
                    return;

                var columnHeader = $("<table role='grid' style='border-spacing: 0px; border-collapse: collapse; width: 100%; height: 100%;' cellspacing='0' cellpadding='1'>" +
                    "<tr role='row'>" +
                    "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" + "<td role='gridcell'></td>" +
                    "</tr>" +
                    "</table>"
                );
                columnHeader.find('table').addClass(this.toThemeProperty('jqx-reset'));
                columnHeader.find('tr').addClass(this.toThemeProperty('jqx-reset'));
                columnHeader.find('td').css({ background: 'transparent', padding: 1, margin: 0, border: 'none' });
                columnHeader.addClass(this.toThemeProperty("jqx-reset"));
                columnHeader.addClass(this.toThemeProperty("jqx-widget-content"));
                columnHeader.addClass(this.toThemeProperty("jqx-calendar-column-header"));
                this.columnHeader.append(columnHeader);

                var visibleDate = this.getVisibleDate();
                var firstDay = this.getFirstDayOfWeek(visibleDate);
                var dayOfWeek = firstDay.dayOfWeek;
                var weekOfYear = this.getWeekOfYear(firstDay);

                var day = this.firstDayOfWeek;
                var dayNames = this.localization.calendar.days.names;

                var columnHeaderCells = new Array();
                var currentDate = firstDay;
                var cellWidth = (month.width() - this.rowHeaderWidth - 2) / 7;
                if (!this.showWeekNumbers) {
                    cellWidth = (month.width() - 2) / 7;
                }

                for (var i = 0; i < 7; i++) {
                    var dayString = dayNames[day];
                    if (this.rtl) {
                        dayString = dayNames[6 - day];
                    }

                    // Possible values: default, shortest, firstTwoLetters, firstLetter, full
                    switch (this.dayNameFormat) {
                        case 'default':
                            dayString = this.localization.calendar.days.namesAbbr[day];
                            if (this.rtl) {
                                dayString = this.localization.calendar.days.namesAbbr[6 - day];
                            }
                            break;
                        case 'shortest':
                            dayString = this.localization.calendar.days.namesShort[day];
                            if (this.rtl) {
                                dayString = this.localization.calendar.days.namesShort[6 - day];
                            }
                            break;
                        case 'firstTwoLetters':
                            dayString = dayString.substring(0, 2);
                            break;
                        case 'firstLetter':
                            dayString = dayString.substring(0, 1);
                            break;
                    }

                    var cell = new $.jqx._jqxCalendar.cell(currentDate.dateTime);
                    var r = i + 1;

                    var cellID = r + this.element.id;
                    var cellElement = $(columnHeader[0].rows[0].cells[i]);

                    var oldI = i;

                    if (this.enableTooltips) {
                        if ($(cellElement).jqxTooltip) {
                            $(cellElement).jqxTooltip({
                                name: this.element.id, content: dayNames[day], theme: this.theme, position: 'mouse'
                            });
                        }
                    }

                    if (day >= 6) {
                        day = 0;
                    }
                    else {
                        day++;
                    }

                    i = oldI;
                    cell.element = cellElement;
                    cell.row = 0;
                    cell.column = i + 1;
                    var textWidth = this._textwidth(dayString);
                    var cellContent = "<div style='padding: 0; margin: 0; border: none; background: transparent;' id='columnCell" + cellID + "'>" + dayString + "</div>";
                    cellElement.append(cellContent);
                    cellElement.find("#columnCell" + cellID).addClass(this.toThemeProperty('jqx-calendar-column-cell'));
                    cellElement.width(cellWidth);
                    if (this.disabled) {
                        cellElement.find("#columnCell" + cellID).addClass(this.toThemeProperty('jqx-calendar-column-cell-disabled'));
                    }

                    if (textWidth > 0 && cellWidth > 0) {
                        while (textWidth > cellElement.width()) {
                            if (dayString.length == 0)
                                break;

                            dayString = dayString.substring(0, dayString.length - 1);
                            $.jqx.utilities.html(cellElement.find("#columnCell" + cellID), dayString);
                            textWidth = this._textwidth(dayString);
                        }
                    }

                    columnHeaderCells[i] = cell;
                    currentDate = new $.jqx._jqxDateTimeInput.getDateTime(new Date(currentDate._addDays(1)));
                }

                if (parseInt(this.columnHeader.width()) > parseInt(this.month.width())) {
                    this.columnHeader.width(this.month.width())
                }

                var monthInstance = $.data(this.element, month[0].id);
                monthInstance.columnCells = columnHeaderCells;
            },

            _format: function (date, format, culture) {
                var globalize = false;
                try {
                    if (window.Globalize != undefined) {
                        globalize = true;
                    }
                    else if (document.Globalize) {
                        window.Globalize = document.Globalize;
                        globalize = true;
                    }
                }
                catch (error) {
                    if (document.Globalize) {
                        window.Globalize = document.Globalize;
                        globalize = true;
                    }
                }
                if (document.Globalize) {
                    window.Globalize = document.Globalize;
                    globalize = true;
                }

                if ($.global) {
                    $.global.culture.calendar = this.localization.calendar;
                    return $.global.format(date, format, this.culture);
                }
                else if (globalize) {
                    try {
                        if (window.Globalize.cultures[this.culture]) {
                            window.Globalize.cultures[this.culture].calendar = this.localization.calendar;
                            return window.Globalize.format(date, format, this.culture);
                        }
                        else {
                            return window.Globalize.format(date, format, this.culture);
                        }
                    }
                    catch (error) {
                        return window.Globalize.format(date, format);
                    }
                }
                else if ($.jqx.dataFormat) {
                    return $.jqx.dataFormat.formatdate(date, format, this.localization.calendar);
                }
            },

            _textwidth: function (text) {
                var measureElement = $('<span>' + text + '</span>');
                measureElement.addClass(this.toThemeProperty('jqx-calendar-column-cell'));
                $(this.host).append(measureElement);
                var width = measureElement.width();
                measureElement.remove();
                return width;
            },

            _textheight: function (text) {
                var measureElement = $('<span>' + text + '</span>');
                $(this.host).append(measureElement);
                var height = measureElement.height();
                measureElement.remove();
                return height;
            },

            _renderRowHeader: function (month) {
                var visibleDate = this.getVisibleDate();
                var firstDay = this.getFirstDayOfWeek(visibleDate);
                var dayOfWeek = firstDay.dayOfWeek;
                var weekOfYear = this.getWeekOfYear(firstDay);
                var newDate = new $.jqx._jqxDateTimeInput.getDateTime(new Date(firstDay.dateTime));
                newDate._addDays(5);
                newDate.dayOfWeek = newDate.dateTime.getDay();
                var newWeekOfYear = this.getWeekOfYear(newDate);
                if (53 == weekOfYear && newDate.dateTime.getMonth() == 0)
                    weekOfYear = 1;

                var rowHeader = $("<table style='overflow: hidden; width: 100%; height: 100%;' cellspacing='0' cellpadding='1'>" +
                    "<tr>" +
                    "<td></td>" +
                    "</tr>" +
                    "<tr>" +
                    "<td/>" +
                    "</tr>" +
                    "<tr>" +
                    "<td/>" +
                    "</tr>" +
                    "<tr>" +
                    "<td/>" +
                    "</tr>" +
                    "<tr>" +
                    "<td/>" +
                    "</tr>" +
                    "<tr>" +
                    "<td/>" +
                    "</tr>" +
                    "</table>"
                );

                rowHeader.find('table').addClass(this.toThemeProperty('jqx-reset'));
                rowHeader.find('td').addClass(this.toThemeProperty('jqx-reset'));
                rowHeader.find('tr').addClass(this.toThemeProperty('jqx-reset'));
                rowHeader.addClass(this.toThemeProperty("jqx-calendar-row-header"));
                rowHeader.width(this.rowHeaderWidth);
                this.rowHeader.append(rowHeader);

                var currentDate = firstDay;
                var rowHeaderCells = new Array();

                for (var i = 0; i < 6; i++) {
                    var weekString = weekOfYear.toString();
                    var cell = new $.jqx._jqxCalendar.cell(currentDate.dateTime);
                    var cellID = i + 1 + this.element.id;
                    var cellElement = $(rowHeader[0].rows[i].cells[0]);
                    cell.element = cellElement;
                    cell.row = i;
                    cell.column = 0;
                    var cellContent = "<div style='background: transparent; border: none; padding: 0; margin: 0;' id ='headerCellContent" + cellID + "'>" + weekString + "</div>";
                    cellElement.append(cellContent);
                    cellElement.find("#headerCellContent" + cellID).addClass(this.toThemeProperty('jqx-calendar-row-cell'));
                    rowHeaderCells[i] = cell;
                    currentDate = new $.jqx._jqxDateTimeInput.getDateTime(new Date(currentDate._addWeeks(1)));
                    weekOfYear = this.getWeekOfYear(currentDate);
                }

                var monthInstance = $.data(this.element, month[0].id);
                monthInstance.rowCells = rowHeaderCells;
            },

            // gets the first week day.
            // @param - Date
            getFirstDayOfWeek: function (visibleDate) {
                var date = visibleDate;

                if (this.firstDayOfWeek < 0 || this.firstDayOfWeek > 6)
                    this.firstDayOfWeek = 6;

                var num = date.dayOfWeek - this.firstDayOfWeek;
                if (num <= 0) {
                    num += 7;
                }

                var newDate = $.jqx._jqxDateTimeInput.getDateTime(date._addDays(-num));
                return newDate;
            },

            // gets the visible date in the current month.
            getVisibleDate: function () {
                var visibleDate = new $.jqx._jqxDateTimeInput.getDateTime(new Date(this.value.dateTime));
                if (visibleDate < this.minDate) {
                    visibleDate = this.minDate;
                }

                if (visibleDate > this.maxDate) {
                    this.visibleDate = this.maxDate;
                }

                visibleDate.dateTime.setHours(0);
                var dayInMonth = visibleDate.day;
                var newVisibleDate = $.jqx._jqxDateTimeInput.getDateTime(visibleDate._addDays(-dayInMonth + 1));
                visibleDate = newVisibleDate;
                return visibleDate;
            },

            destroy: function (removeFromDom) {
                $.jqx.utilities.resize(this.host, null, true);
                this.host
                    .removeClass();

                if (removeFromDom != false) {
                    this.host.remove();
                }
            },

            _raiseEvent: function (id, arg) {
                if (arg == undefined)
                    arg = { owner: null };

                var evt = this.events[id];
                var args = arg ? arg : {};

                args.owner = this;
                var event = new $.Event(evt);
                event.owner = this;
                event.args = args;
                if (id == 0 || id == 1 || id == 2 || id == 3 || id == 4 || id == 5 || id == 6 || id == 7 || id == 8) {
                    event.args.date = event.args.selectedDate = this.getDate();
                    event.args.range = this.getRange();
                    var start = this.getViewStart();
                    var end = this.getViewEnd();
                    event.args.view = { from: start, to: end };
                }

                if (id == 7) {
                    var selectionType = args.selectionType;
                    if (!selectionType) selectionType = null;
                    if (selectionType == "key") {
                        selectionType = "keyboard";
                    }
                    if (selectionType == "none") {
                        selectionType = null;
                    }
                    args.type = selectionType;
                }
                var result = this.host.trigger(event);
                if (id == 0 || id == 1) {
                    result = false;
                }

                return result;
            },

            propertyMap: function (key) {
                if (key == "value") {
                    if (this.selectionMode != 'range') {
                        return this.getDate();
                    }
                    else return this.getRange();
                }
                return null;
            },

            _setSize: function () {
                var month = this.host.find("#View" + this.element.id);
                if (month.length > 0) {

                    this.setCalendarSize();

                    month[0].style.height = "100%";
                    month[0].style.width = "100%";
                    /*if (this.height != undefined && !isNaN(this.height)) {
                        month.height(this.height);
                    }
                    else if (this.height != null && this.height.toString().indexOf("px") != -1) {
                        month.height(this.height);
                    }
    
                    if (this.width != undefined && !isNaN(this.width)) {
                        month.width(this.width);
                    }
                    else if (this.width != null && this.width.toString().indexOf("px") != -1) {
                        month.width(this.width);
                    }*/

                    var contentHeight = this.month.height() - this.titleHeight - this.columnHeaderHeight;
                    var calendarID = "View" + this.element.id;
                    month.find('#cellsTable' + calendarID).height(contentHeight);
                    month.find('#calendarRowHeader' + calendarID).height(contentHeight);
                    this.refreshControl();
                }
            },

            resize: function () {
                this._setSize();
            },

            clear: function () {
                if (this.selectionMode == "range") {
                    this._clicks = 1;
                    this.setRange(null, null);
                    this._raiseEvent(7);
                }
                else {
                    this.setDate(null, 'mouse');
                }
                this._clicks = 0;
                this.selection = { from: null, to: null };
            },

            today: function () {
                if (this.selectionMode == 'range') {
                    this.setRange(new Date(), new Date());
                }
                else {
                    this.setDate(new Date(), 'mouse');
                }
            },

            propertiesChangedHandler: function (object, key, value) {
                if (value.width && value.height && Object.keys(value).length == 2) {
                    object._setSize();
                }
            },

            propertyChangedHandler: function (object, key, oldvalue, value) {
                if (this.isInitialized == undefined || this.isInitialized == false)
                    return;

                if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                    return;
                }

                if (key == "enableHover")
                    return;
                if (key == "keyboardNavigation")
                    return;

                if (key == 'localization') {
                    if (this.localization) {
                        if (this.localization.backString) {
                            this.backText = this.localization.backString;
                        }
                        if (this.localization.forwardString) {
                            this.forwardText = this.localization.forwardString;
                        }
                        if (this.localization.todayString) {
                            this.todayString = this.localization.todayString;
                        }
                        if (this.localization.clearString) {
                            this.clearString = this.localization.clearString;
                        }
                        this.firstDayOfWeek = this.localization.calendar.firstDay;
                    }
                }

                if (key == 'culture') {
                    try {
                        if ($.global) {
                            $.global.preferCulture(object.culture);
                            object.localization.calendar = $.global.culture.calendar;
                        }
                        else if (window.Globalize) {
                            var culture = window.Globalize.culture(object.culture);
                            object.localization.calendar = culture.calendar;
                        }
                        if (object.localization.calendar && object.localization.calendar.firstDay != undefined && object.culture != "default") {
                            object.firstDayOfWeek = object.localization.calendar.firstDay;
                        }
                    }
                    catch (error) {
                    }
                }
                if (key == "views") {
                    if (object.views.indexOf('month') == -1) object.view = "year";
                    if (object.views.indexOf('year') == -1 && object.views.indexOf('month') == -1) object.view = "decade";
                    object.render();
                    return;
                }

                if (key == "showFooter") {
                    object.render();
                }
                if (key == 'width' || key == 'height') {
                    object._setSize();
                    return;
                }
                else if (key == 'theme') {
                    $.jqx.utilities.setTheme(oldvalue, value, object.host);
                }
                else if (key == "rowHeaderWidth" || key == "showWeekNumbers") {
                    object.render();
                }
                else {
                    object.view = "month";
                    object.render();
                    object.refreshControl();
                }

                if (key === "firstDayOfWeek") {
                    object.refreshControl();

                }
            }
        });
    })(jqxBaseFramework);

    (function ($) {
        $.jqx._jqxCalendar.cell = function (date) {
            var cell =
            {
                dateTime: new $.jqx._jqxDateTimeInput.getDateTime(date),
                _date: date,
                getDate: function () {
                    return this._date;
                },
                setDate: function (date) {
                    this.dateTime = new $.jqx._jqxDateTimeInput.getDateTime(date);
                    this._date = date;
                },
                isToday: false,
                isWeekend: false,
                isOtherMonth: false,
                isVisible: true,
                isSelected: false,
                isHighlighted: false,
                element: null,
                row: -1,
                column: -1,
                tooltip: null
            };

            return cell;
        } // calendar cell

        $.jqx._jqxCalendar.monthView = function (startDate, endDate, cells, rowHeaderCells, columnHeaderCells, element) {
            var month =
            {
                start: startDate,
                end: endDate,
                cells: cells,
                rowCells: rowHeaderCells,
                columnCells: columnHeaderCells,
                element: element
            };

            return month;
        } // calendar month

    })(jqxBaseFramework);
})();



/***/ }),

/***/ 4545:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}
(function ($) {

    $.jqx.jqxWidget("jqxCheckBox", "", {});

    $.extend($.jqx._jqxCheckBox.prototype, {
        defineInstance: function () {
            var settings = {
                // Type: Number
                // Default: 250
                // Gets or sets the delay of the fade animation when the CheckBox is going to be opened.
                animationShowDelay: 300,
                // Type: Number
                // Default: 300
                // Gets or sets the delay of the fade animation when the CheckBox is going to be closed. 
                animationHideDelay: 300,
                // Type: Number.
                // Default: null.
                // Sets the width.
                width: null,
                // Type: Number.
                // Default: null.
                // Sets the height.
                height: null,
                // Type: String
                // Default: '16px'
                // Gets or sets the checkbox's size.
                boxSize: '16px',
                // Type: Bool and Null
                // Default: false
                // Gets or sets the ckeck state.
                // Possible Values: true, false and null.
                checked: false,
                // Type: Bool
                // Default: false
                // Gets or sets whether the checkbox has 3 states - checked, unchecked and indeterminate.
                hasThreeStates: false,
                // Type: Bool
                // Default: false
                // Gets whether the CheckBox is disabled.
                disabled: false,
                // Type: Bool
                // Default: true
                // Gets or sets whether the clicks on the container are handled as clicks on the check box.
                enableContainerClick: true,
                // Type: Bool
                // Default: true
                // Gets or sets whether the checkbox is locked. In this mode the user is not allowed to check/uncheck the checkbox.
                locked: false,
                // Type: String
                // Default: ''
                // Gets or sets the group name. When this property is set, the checkboxes in the same group behave as radio buttons.
                groupName: '',
                keyboardCheck: true,
                enableHover: true,
                hasInput: true,
                rtl: false,
                updated: null,
                disabledContainer: false,
                changeType: null,
                _canFocus: true,
                rippleEffect: true,
                aria:
                {
                    "aria-checked": { name: "checked", type: "boolean" },
                    "aria-disabled": { name: "disabled", type: "boolean" }
                },
                // 'checked' is triggered when the checkbox is checked.
                // 'unchecked' is triggered when the checkbox is unchecked.
                // 'indeterminate' is triggered when the checkbox's ckecked property is going to be null.
                // 'change' is triggered when the checkbox's state is changed.
                events:
                    [
                        'checked', 'unchecked', 'indeterminate', 'change'
                    ]
            };
            if (this === $.jqx._jqxCheckBox.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        createInstance: function (args) {
            var that = this;
            that._createFromInput("CheckBox");
            that.render();
        },

        _createFromInput: function (name) {
            var that = this;
            if (that.element.nodeName.toLowerCase() == "input") {
                that.field = that.element;
                if (that.field.className) {
                    that._className = that.field.className;
                }

                var properties = {
                    'title': that.field.title
                };

                if (that.field.value) {
                    properties.value = that.field.value;
                }
                if (that.field.checked) {
                    properties.checked = true;
                }
                if (that.field.id.length) {
                    properties.id = that.field.id.replace(/[^\w]/g, '_') + "_" + name;
                }
                else {
                    properties.id = $.jqx.utilities.createId() + "_" + name;
                }

                var textField = that.element.nextSibling;
                var hasTextField = false;
                if (textField && (textField.nodeName == "#text" || textField.nodeName == "span")) {
                    hasTextField = true;
                }
                var offsetWidth = 0;
                var wrapper = $("<div></div>", properties);
                if (hasTextField) {
                    wrapper.append(textField);
                    var f = $("<span>" + $(textField).text() + "</span>");
                    f.appendTo($(document.body))
                    offsetWidth += f.width();
                    f.remove();
                }
                wrapper[0].style.cssText = that.field.style.cssText;
                if (!that.width) {
                    that.width = $(that.field).width() + offsetWidth + 10;
                }
                if (!that.height) {
                    that.height = $(that.field).outerHeight() + 10;
                }
                $(that.field).hide().after(wrapper);
                var data = that.host.data();
                that.host = wrapper;
                that.host.data(data);
                that.element = wrapper[0];
                that.element.id = that.field.id;
                that.field.id = properties.id;
                if (that._className) {
                    that.host.addClass(that._className);
                    $(that.field).removeClass(that._className);
                }

                if (that.field.tabIndex) {
                    var tabIndex = that.field.tabIndex;
                    that.field.tabIndex = -1;
                    that.element.tabIndex = tabIndex;
                }
            }
        },

        _addInput: function () {
            if (this.hasInput) {
                if (this.input) this.input.remove();
                var name = this.host.attr('name');
                this.input = $("<input type='hidden'/>");
                this.host.append(this.input);
                if (name) {
                    this.input.attr('name', name);
                }
                this.input.val(this.checked);

                this.host.attr('role', 'checkbox');
                $.jqx.aria(this);
            }
        },

        render: function () {
            this.init = true;
            var me = this;
            this.setSize();
            this.propertyChangeMap['width'] = function (instance, key, oldVal, value) {
                me.setSize();
            };

            this.propertyChangeMap['height'] = function (instance, key, oldVal, value) {
                me.setSize();
            };
            this._removeHandlers();

            if (!this.width) this.host.css('overflow-x', 'visible');
            if (!this.height) this.host.css('overflow-y', 'visible');

            if (this.checkbox) {
                this.checkbox.remove();
                this.checkbox = null;
            }
            if (this.checkMark) {
                this.checkMark.remove();
                this.checkMark = null;
            }
            if (this.box) {
                this.box.remove();
                this.box = null;
            }
            if (this.clear) {
                this.clear.remove();
                this.clear = null;
            }

            if (this.boxSize == null) this.boxSize = 16;
            var boxSize = parseInt(this.boxSize) + 'px';
            var checkSize = "16px";
            var ml = Math.floor((parseInt(this.boxSize) - 16) / 2);
            var mt = ml;
            ml += "px";
            mt += "px";
            if (parseInt(this.boxSize) != 16) {
                this.checkbox = $('<div><div style="width: ' + boxSize + '; height: ' + boxSize + ';"><span style="position: relative; left: ' + ml + '; top: ' + mt + '; width: ' + checkSize + '; height: ' + checkSize + ';"></span></div></div>');
            }
            else {
                this.checkbox = $('<div><div style="width: ' + boxSize + '; height: ' + boxSize + ';"><span style="width: ' + boxSize + '; height: ' + boxSize + ';"></span></div></div>');
            }

            this.host.prepend(this.checkbox);
            if (!this.disabledContainer) {
                if (!this.host.attr('tabIndex')) {
                    this.host.attr('tabIndex', 0);
                }
                this.clear = $('<div style="clear: both;"></div>');
                this.host.append(this.clear);
            }

            this.checkMark = $(this.checkbox[0].firstChild.firstChild);//$(this.checkbox).find('span');
            this.box = this.checkbox;

            this.box.addClass(this.toThemeProperty('jqx-checkbox-default') + " " + this.toThemeProperty('jqx-fill-state-normal') + " " + this.toThemeProperty('jqx-rc-all'));

            if (this.disabled) {
                this.disable();
            }

            if (!this.disabledContainer) {
                this.host.addClass(this.toThemeProperty('jqx-widget'));
                this.host.addClass(this.toThemeProperty('jqx-checkbox'));
            }

            if (this.locked && !this.disabledContainer) {
                this.host.css('cursor', 'auto');
            }

            var checked = this.element.getAttribute('checked');
            if (checked == 'checked' || checked == 'true' || checked == true) {
                this.checked = true;
            }

            this._addInput();
            this._render();
            this._addHandlers();
            this.init = false;
            this._centerBox();

            if (this.isMaterialized()) {
                if (this.rippleEffect) {
                    $(this.checkbox).addClass('ripple');
                    $.jqx.ripple($(this.checkbox), this.host, "checkbox");
                }
            }
        },

        _centerBox: function () {
            if (this.height && this.height.toString().indexOf("%") == -1 && this.box) {
                var hostHeight = parseInt(this.height);
                this.host.css('line-height', hostHeight + "px");
                var top = hostHeight - parseInt(this.boxSize) - 1;
                top /= 2;
                this.box.css('margin-top', parseInt(top));
            }
        },

        refresh: function (initialRefresh) {
            if (!initialRefresh) {
                this.setSize();
                this._render();
            }
        },

        resize: function (width, height) {
            this.width = width;
            this.height = height;
            this.refresh();
        },

        setSize: function () {
            if (this.width != null && this.width.toString().indexOf("px") != -1) {
                this.host.width(this.width);
            }
            else if (this.width != undefined && !isNaN(this.width)) {
                this.host.width(this.width);
            }
            else if (this.width != null && this.width.toString().indexOf("%") != -1) {
                this.element.style.width = this.width;
            }

            if (this.height != null && this.height.toString().indexOf("px") != -1) {
                this.host.height(this.height);
            }
            else if (this.height != undefined && !isNaN(this.height)) {
                this.host.height(this.height);
            }
            else if (this.height != null && this.height.toString().indexOf("%") != -1) {
                this.element.style.height = this.height;
            }
            this._centerBox();
        },

        _addHandlers: function () {
            var me = this;

            var isTouchDevice = $.jqx.mobile.isTouchDevice();
            var eventName = 'mousedown';
            if (isTouchDevice) eventName = $.jqx.mobile.getTouchEventName('touchend');

            this.addHandler(this.box, eventName, function (event) {
                if (!me.disabled && !me.enableContainerClick && !me.locked) {
                    me.changeType = "mouse";
                    me.toggle();
                    if (me.updated) {
                        event.owner = me;
                        me.updated(event, me.checked, me.oldChecked);
                    }
                    if (event.preventDefault) {
                        event.preventDefault();
                    }
                    return false;
                }
            });

            if (!this.disabledContainer) {
                this.addHandler(this.host, 'keydown', function (event) {
                    if (!me.disabled && !me.locked && me.keyboardCheck) {
                        if (event.keyCode == 32) {
                            if (!me._canFocus) {
                                return true;
                            }
                            me.changeType = "keyboard";
                            me.toggle();
                            if (me.updated) {
                                event.owner = me;
                                me.updated(event, me.checked, me.oldChecked);
                            }
                            if (event.preventDefault) {
                                event.preventDefault();
                            }
                            return false;
                        }
                    }
                });

                this.addHandler(this.host, eventName, function (event) {
                    if (!me.disabled && me.enableContainerClick && !me.locked) {
                        me.clickTime = new Date();
                        me.changeType = "mouse";
                        me.toggle();
                        if (event.preventDefault) {
                            event.preventDefault();
                        }
                        if (me._canFocus) {
                            me.focus();
                        }
                        return false;
                    }
                });

                this.addHandler(this.host, 'selectstart', function (event) {
                    if (!me.disabled && me.enableContainerClick) {
                        if (event.preventDefault) {
                            event.preventDefault();
                        }
                        return false;
                    }
                });

                this.addHandler(this.host, 'mouseup', function (event) {
                    if (!me.disabled && me.enableContainerClick) {
                        if (event.preventDefault) {
                            event.preventDefault();
                        }
                    }
                });

                this.addHandler(this.host, 'focus', function (event) {
                    if (!me.disabled && !me.locked) {
                        if (!me._canFocus) {
                            return true;
                        }

                        if (me.enableHover) {
                            me.box.addClass(me.toThemeProperty('jqx-checkbox-hover'));
                        }
                        me.box.addClass(me.toThemeProperty('jqx-fill-state-focus'));
                        if (event.preventDefault) {
                            event.preventDefault();
                        }

                        $(me.checkbox).removeClass('active');
                        if (!me.clickTime || (me.clickTime && (new Date() - me.clickTime > 300))) {
                            $(me.checkbox).addClass('active');
                        }

                        me.hovered = true;
                        return false;
                    }
                });

                this.addHandler(this.host, 'blur', function (event) {
                    $(me.checkbox).removeClass('active');

                    if (!me.disabled && !me.locked) {
                        if (!me._canFocus) {
                            return true;
                        }
                        if (me.enableHover) {
                            me.box.removeClass(me.toThemeProperty('jqx-checkbox-hover'));
                        }
                        me.box.removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                        if (event.preventDefault) {
                            event.preventDefault();
                        }
                        me.hovered = false;
                        return false;
                    }
                });

                this.addHandler(this.host, 'mouseenter', function (event) {
                    if (me.locked) {
                        me.host.css('cursor', 'arrow')
                    }
                    if (me.enableHover) {
                        if (!me.disabled && me.enableContainerClick && !me.locked) {
                            me.box.addClass(me.toThemeProperty('jqx-checkbox-hover'));
                            me.box.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                            if (event.preventDefault) {
                                event.preventDefault();
                            }
                            me.hovered = true;
                            return false;
                        }
                    }
                });

                this.addHandler(this.host, 'mouseleave', function (event) {
                    if (me.enableHover) {
                        if (!me.disabled && me.enableContainerClick && !me.locked) {
                            me.box.removeClass(me.toThemeProperty('jqx-checkbox-hover'));
                            me.box.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                            if (event.preventDefault) {
                                event.preventDefault();
                            }
                            me.hovered = false;
                            return false;
                        }
                    }
                });

                this.addHandler(this.box, 'mouseenter', function () {
                    if (me.locked) {
                        return;
                    }

                    if (!me.disabled && !me.enableContainerClick) {
                        me.box.addClass(me.toThemeProperty('jqx-checkbox-hover'));
                        me.box.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                    }
                });

                this.addHandler(this.box, 'mouseleave', function () {
                    if (!me.disabled && !me.enableContainerClick) {
                        me.box.removeClass(me.toThemeProperty('jqx-checkbox-hover'));
                        me.box.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                    }
                });
            }
        },

        focus: function () {
            try {
                this.host.focus();
            }
            catch (error) {
            }
        },

        _removeHandlers: function () {
            var isTouchDevice = $.jqx.mobile.isTouchDevice();
            var eventName = 'mousedown';
            if (isTouchDevice) eventName = 'touchend';

            if (this.box) {
                this.removeHandler(this.box, eventName);
                this.removeHandler(this.box, 'mouseenter');
                this.removeHandler(this.box, 'mouseleave');
            }
            this.removeHandler(this.host, eventName);
            this.removeHandler(this.host, 'mouseup');
            this.removeHandler(this.host, 'selectstart');
            this.removeHandler(this.host, 'mouseenter');
            this.removeHandler(this.host, 'mouseleave');
            this.removeHandler(this.host, 'keydown');
            this.removeHandler(this.host, 'blur');
            this.removeHandler(this.host, 'focus');
        },

        _render: function () {
            if (!this.disabled) {
                if (this.enableContainerClick) {
                    this.host.css('cursor', 'pointer');
                }
                else
                    if (!this.init) {
                        this.host.css('cursor', 'auto');
                    }
            }
            else {
                this.disable();
            }
            if (this.rtl) {
                this.box.addClass(this.toThemeProperty('jqx-checkbox-rtl'));
                this.host.addClass(this.toThemeProperty('jqx-rtl'));
            }

            this.updateStates();
            this.host.attr("checked", this.checked);
        },

        _setState: function (checked, locked) {
            if (this.checked != checked) {
                this.checked = checked;
                if (this.checked) {
                    this.checkMark[0].className = this.toThemeProperty('jqx-checkbox-check-checked');
                }
                else if (this.checked == null) {
                    this.checkMark[0].className = this.toThemeProperty('jqx-checkbox-check-indeterminate');
                }
                else {
                    this.checkMark[0].className = "";
                }
            }
            if (locked === false || locked === true)
                this.locked = locked;

            if (checked) {
                this.element.setAttribute('checked', true);
            }
            else {
                this.element.removeAttribute("checked");
            }
        },

        val: function (value) {
            if (arguments.length == 0 || (value != null && typeof (value) == "object")) {
                return this.checked;
            }

            if (typeof value == "string") {
                if (value == "true") this.check();
                if (value == "false") this.uncheck();
                if (value == "") this.indeterminate();
            }
            else {
                if (value == true) this.check();
                if (value == false) this.uncheck();
                if (value == null) this.indeterminate();
            }
            return this.checked;
        },

        // checks the ckeckbox.
        check: function () {
            this.checked = true;
            var me = this;
            this.checkMark.removeClass();
            this.element.setAttribute('checked', true);

            if ($.jqx.browser.msie || this.animationShowDelay == 0) {
                this.checkMark.addClass(this.toThemeProperty('jqx-checkbox-check-checked'));
            }
            else {
                this.checkMark.addClass(this.toThemeProperty('jqx-checkbox-check-checked'));
                this.checkMark.css('opacity', 0);
                this.checkMark.stop().animate({ opacity: 1 }, this.animationShowDelay, function () {
                });
            }

            if (this.groupName != null && this.groupName.length > 0) {
                var checkboxes = $.find(this.toThemeProperty('.jqx-checkbox', true));
                $.each(checkboxes, function () {
                    var groupName = $(this).jqxCheckBox('groupName');
                    if (groupName == me.groupName && this != me.element) {
                        $(this).jqxCheckBox('uncheck')
                    }
                });
            }

            var changeType = this.changeType;

            this._raiseEvent('0', { checked: true });
            this.changeType = changeType;
            this._raiseEvent('3', { checked: true });
            if (this.input != undefined) {
                this.input.val(this.checked);
                $.jqx.aria(this, "aria-checked", this.checked);
                this.host.attr("checked", this.checked);
            }
        },

        // unchecks the checkbox.
        uncheck: function () {
            this.checked = false;
            var me = this;

            this.element.removeAttribute('checked');

            if ($.jqx.browser.msie || this.animationHideDelay == 0) {
                if (me.checkMark[0].className != "") {
                    me.checkMark[0].className = "";
                }
            }
            else {
                this.checkMark.css('opacity', 1);
                this.checkMark.stop().animate({ opacity: 0 }, this.animationHideDelay, function () {
                    if (me.checkMark[0].className != "") {
                        me.checkMark[0].className = "";
                    }
                });
            }

            var changeType = this.changeType;
            this._raiseEvent('1');
            this.changeType = changeType;
            this._raiseEvent('3', { checked: false });
            if (this.input != undefined) {
                this.input.val(this.checked);
                $.jqx.aria(this, "aria-checked", this.checked);
                this.host.attr("checked", this.checked);
            }
        },

        // sets the indeterminate state.
        indeterminate: function () {
            this.checked = null;
            this.checkMark.removeClass();

            if ($.jqx.browser.msie || this.animationShowDelay == 0) {
                this.checkMark.addClass(this.toThemeProperty('jqx-checkbox-check-indeterminate'));
            }
            else {
                this.checkMark.addClass(this.toThemeProperty('jqx-checkbox-check-indeterminate'));
                this.checkMark.css('opacity', 0);
                this.checkMark.stop().animate({ opacity: 1 }, this.animationShowDelay, function () {
                });
            }

            var changeType = this.changeType;
            this._raiseEvent('2');
            this._raiseEvent('3', { checked: null });
            if (this.input != undefined) {
                this.input.val(this.checked);
                $.jqx.aria(this, "aria-checked", "undefined");
                this.host.attr("checked", "undefined");
            }
        },

        // toggles the check state.
        toggle: function () {
            if (this.disabled)
                return;

            if (this.locked)
                return;

            if (this.groupName != null && this.groupName.length > 0) {
                if (this.checked != true) {
                    this.checked = true;
                    this.updateStates();
                }
                return;
            }

            this.oldChecked = this.checked;
            if (this.checked == true) {
                this.checked = this.hasThreeStates ? null : false;
            }
            else {
                this.checked = this.checked != null;
            }

            this.updateStates();
            if (this.input != undefined) {
                this.input.val(this.checked);
            }
        },

        // updates check states depending on the value of the 'checked' property.
        updateStates: function () {
            if (this.checked) {
                this.check();
            }
            else if (this.checked == false) {
                this.uncheck();
            }
            else if (this.checked == null) {
                this.indeterminate();
            }
        },

        // disables the checkbox.
        disable: function () {
            this.disabled = true;

            if (this.checked == true) {
                this.checkMark.addClass(this.toThemeProperty('jqx-checkbox-check-disabled'));
            }
            else if (this.checked == null) {
                this.checkMark.addClass(this.toThemeProperty('jqx-checkbox-check-indeterminate-disabled'));
            }
            this.box.addClass(this.toThemeProperty('jqx-checkbox-disabled-box'));
            this.host.addClass(this.toThemeProperty('jqx-checkbox-disabled'));
            this.host.addClass(this.toThemeProperty('jqx-fill-state-disabled'));
            this.box.addClass(this.toThemeProperty('jqx-checkbox-disabled'));
            $.jqx.aria(this, "aria-disabled", this.disabled);
        },

        // enables the checkbox.
        enable: function () {
            if (this.checked == true) {
                this.checkMark.removeClass(this.toThemeProperty('jqx-checkbox-check-disabled'));
            }
            else if (this.checked == null) {
                this.checkMark.removeClass(this.toThemeProperty('jqx-checkbox-check-indeterminate-disabled'));
            }
            this.box.removeClass(this.toThemeProperty('jqx-checkbox-disabled-box'));
            this.host.removeClass(this.toThemeProperty('jqx-checkbox-disabled'));
            this.host.removeClass(this.toThemeProperty('jqx-fill-state-disabled'));
            this.box.removeClass(this.toThemeProperty('jqx-checkbox-disabled'));
            this.disabled = false;
            $.jqx.aria(this, "aria-disabled", this.disabled);
        },

        destroy: function () {
            this.host.remove();
        },

        _raiseEvent: function (id, args) {
            if (this.init) return;
            var evt = this.events[id];
            var event = new $.Event(evt);
            event.owner = this;
            if (!args) args = {};
            args.type = this.changeType;
            this.changeType = null;

            event.args = args;

            try {
                var result = this.host.trigger(event);
            }
            catch (error) {

            }

            return result;
        },

        propertiesChangedHandler: function (object, key, value) {
            if (value.width && value.height && Object.keys(value).length == 2) {
                object.setSize();
            }
        },

        propertyChangedHandler: function (object, key, oldvalue, value) {
            if (this.isInitialized == undefined || this.isInitialized == false)
                return;

            if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                return;
            }

            if (key == "enableContainerClick" && !object.disabled && !object.locked) {
                if (value) {
                    object.host.css('cursor', 'pointer');
                }
                else object.host.css('cursor', 'auto');
            }

            if (key == "rtl") {
                if (value) {
                    object.box.addClass(object.toThemeProperty('jqx-checkbox-rtl'));
                    object.host.addClass(object.toThemeProperty('jqx-rtl'));
                }
                else {
                    object.box.removeClass(object.toThemeProperty('jqx-checkbox-rtl'));
                    object.host.removeClass(object.toThemeProperty('jqx-rtl'));
                }
            }

            if (key == "boxSize") {
                object.render();
            }

            if (key == 'theme') {
                $.jqx.utilities.setTheme(oldvalue, value, object.host);
            }

            if (key == 'checked') {
                if (value != oldvalue) {
                    switch (value) {
                        case true:
                            object.check();
                            break;
                        case false:
                            object.uncheck();
                            break;
                        case null:
                            object.indeterminate();
                            break;
                    }
                }
            }

            if (key == 'disabled') {
                if (value != oldvalue) {
                    if (value) {
                        object.disable();
                    } else object.enable();
                }
            }
        }
    });
})(jqxBaseFramework);
})();



/***/ }),

/***/ 4720:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }
    (function ($) {

        $.jqx.jqxWidget("jqxComboBox", "", {});

        $.extend($.jqx._jqxComboBox.prototype, {
            defineInstance: function () {
                var settings = {
                    // enables/disables the combobox.
                    disabled: false,
                    // gets or sets the listbox width.
                    width: 200,
                    // gets or sets the listbox height.
                    height: 25,
                    // Represents the collection of list items.
                    items: new Array(),
                    // Gets or sets the selected index.
                    selectedIndex: -1,
                    selectedItems: new Array(),
                    _selectedItems: new Array(),
                    // data source.
                    source: null,
                    autoItemsHeight: false,
                    // gets or sets the scrollbars size.
                    scrollBarSize: $.jqx.utilities.scrollBarSize,
                    // gets or sets the scrollbars size.
                    arrowSize: 17,
                    // enables/disables the hover state.
                    enableHover: true,
                    // enables/disables the selection.
                    enableSelection: true,
                    // gets the visible items. // this property is internal for the combobox.
                    visualItems: new Array(),
                    // gets the groups. // this property is internal for the combobox.
                    groups: new Array(),
                    // gets or sets whether the items width should be equal to the combobox's width.
                    equalItemsWidth: true,
                    // gets or sets the height of the ListBox Items. When the itemHeight:= - 1, each item's height is equal to its desired height.
                    itemHeight: -1,
                    // represents the combobox's events.
                    visibleItems: new Array(),
                    // emptry group's text.
                    hint: true,
                    emptyGroupText: 'Group',
                    emptyString: "",
                    ready: null,
                    // Type: Number
                    // Default: 100
                    // Showing Popup Animation's delay.
                    openDelay: 250,
                    // Type: Number
                    // Default: 200
                    // Hiding Popup Animation's delay.
                    closeDelay: 300,
                    // default, none
                    // Type: String.
                    // enables or disables the animation.
                    animationType: 'default',
                    // Type: String
                    // Default: auto ( the drop down takes the combobox's width.)
                    // Sets the popup's width.
                    dropDownWidth: 'auto',
                    // Type: String
                    // Default: 200px ( the height is 200px )
                    // Sets the popup's height.
                    dropDownHeight: '200px',
                    // Type: Boolean
                    // Default: false
                    // Sets the popup's height to be equal to the items summary height,
                    autoDropDownHeight: false,
                    // Type: Boolean
                    // Default: false
                    // Enables or disables the browser detection.
                    enableBrowserBoundsDetection: false,
                    dropDownHorizontalAlignment: 'left',
                    dropDownVerticalAlignment: 'bottom',
                    dropDownContainer: "default",
                    // Type: String
                    // Default: startswithignorecase
                    // Possible Values: 'none, 'contains', 'containsignorecase', 'equals', 'equalsignorecase', 'startswithignorecase', 'startswith', 'endswithignorecase', 'endswith'
                    searchMode: 'startswithignorecase',
                    autoComplete: false,
                    remoteAutoComplete: false,
                    remoteAutoCompleteDelay: 500,
                    selectionMode: "default",
                    minLength: 2,
                    displayMember: "",
                    valueMember: "",
                    groupMember: "",
                    searchMember: "",
                    keyboardSelection: true,
                    renderer: null,
                    autoOpen: false,
                    template: "",
                    checkboxes: false,
                    promptText: "",
                    placeHolder: "",
                    rtl: false,
                    listBox: null,
                    validateSelection: null,
                    showCloseButtons: true,
                    renderSelectedItem: null,
                    search: null,
                    popupZIndex: 2000,
                    searchString: null,
                    multiSelect: false,
                    showArrow: true,
                    _disabledItems: new Array(),
                    touchMode: 'auto',
                    autoBind: true,
                    aria:
                    {
                        "aria-disabled": { name: "disabled", type: "boolean" }
                    },
                    events:
                        [
                            // occurs when the combobox is opened.
                            'open',
                            // occurs when the combobox is closed.
                            'close',
                            // occurs when an item is selected.
                            'select',
                            // occurs when an item is unselected.
                            'unselect',
                            // occurs when the selection is changed.
                            'change',
                            // triggered when the user checks or unchecks an item.
                            'checkChange',
                            // triggered when the binding is completed.
                            'bindingComplete',
                            // triggered when a new item is added.
                            'itemAdd',
                            // triggered when a new item is removed.
                            'itemRemove',
                            // triggered when a new item is updated.
                            'itemUpdate'
                        ]
                };
                if (this === $.jqx._jqxComboBox.prototype) {
                    return settings;
                }
                $.extend(true, this, settings);
                return settings;
            },

            createInstance: function (args) {
                var that = this;
                this.host.attr('role', 'combobox');
                this.host.attr('aria-expanded', 'false');
                $.jqx.aria(this, "aria-autocomplete", "both");

                if ($.jqx._jqxListBox == null || $.jqx._jqxListBox == undefined) {
                    throw new Error("jqxComboBox: Missing reference to jqxlistbox.js.");
                }
                $.jqx.aria(this);

                if (that.isMaterialized()) {
                    var elementStyle = window.getComputedStyle(this.element);
                    var animation = elementStyle.getPropertyValue('--jqx-dropdown-animation');
                    var rowHeight = elementStyle.getPropertyValue('--jqx-list-item-height');
                    var arrowSize = elementStyle.getPropertyValue('--jqx-action-button-size');

                    if (arrowSize) {
                        this.arrowSize = parseInt(arrowSize);
                    }
                    else {
                        this.arrowSize = 25;
                    }

                    if (animation && this.animationType == "default") {
                        this.animationType = animation.trim();
                    }

                    if (rowHeight && this.itemHeight === -1) {
                        this.itemHeight = parseInt(rowHeight);
                    }
                }

                // prompt text is deprecated.
                if (this.promptText != "") {
                    this.placeHolder = this.promptText;
                }

                this.render();
            },

            render: function () {
                var that = this;
                var nodeName = that.element.nodeName.toLowerCase();
                if (nodeName == "select" || nodeName == "ul" || nodeName == "ol") {
                    that.field = that.element;
                    if (that.field.className) {
                        that._className = that.field.className;
                    }

                    var properties = {
                        'title': that.field.title
                    };

                    if (that.field.id.length) {
                        properties.id = that.field.id.replace(/[^\w]/g, '_') + "_jqxComboBox";
                    }
                    else {
                        properties.id = $.jqx.utilities.createId() + "_jqxComboBox";
                    }

                    var wrapper = $("<div></div>", properties);
                    if (!that.width) {
                        that.width = $(that.field).width();
                    }
                    if (!that.height) {
                        that.height = $(that.field).outerHeight();
                    }

                    that.element.style.cssText = that.field.style.cssText;
                    $(that.field).hide().after(wrapper);
                    var data = that.host.data();
                    that.host = wrapper;
                    that.host.data(data);
                    that.element = wrapper[0];
                    that.element.id = that.field.id;
                    that.field.id = properties.id;
                    if (that._className) {
                        that.host.addClass(that._className);
                        $(that.field).removeClass(that._className);
                    }

                    if (that.field.tabIndex) {
                        var tabIndex = that.field.tabIndex;
                        that.field.tabIndex = -1;
                        that.element.tabIndex = tabIndex;
                    }
                    if (that.field.innerHTML != "") {
                        var result = $.jqx.parseSourceTag(that.field);
                        that.source = result.items;
                        if (that.selectedIndex == -1)
                            that.selectedIndex = result.index;
                    }
                }
                else {
                    if (that.host.find('li').length > 0 || that.host.find('option').length > 0) {
                        var result = $.jqx.parseSourceTag(that.element);
                        that.source = result.items;
                    }
                }
                that.removeHandlers();
                that.isanimating = false;
                that.id = $.jqx.utilities.createId();
                that.element.innerHTML = "";
                var comboStructure = $("<div style='background-color: transparent; -webkit-appearance: none; outline: none; width:100%; height: 100%; padding: 0px; margin: 0px; border: 0px; position: relative;'>" +
                    "<div id='dropdownlistWrapper' style='padding: 0; margin: 0; border: none; background-color: transparent; float: left; width:100%; height: 100%; position: relative;'>" +
                    "<div id='dropdownlistContent' style='padding: 0; margin: 0; border-top: none; border-bottom: none; float: left; position: absolute;'></div>" +
                    "<div id='dropdownlistArrow' role='button' style='padding: 0; margin: 0; border-left-width: 1px; border-bottom-width: 0px; border-top-width: 0px; border-right-width: 0px; float: right; position: absolute;'></div>" +
                    "</div>" +
                    "</div>");
                that.comboStructure = comboStructure;
                if ($.jqx._jqxListBox == null || $.jqx._jqxListBox == undefined) {
                    throw "jqxComboBox: Missing reference to jqxlistbox.js.";
                }

                that.touch = $.jqx.mobile.isTouchDevice();
                if (that.touchMode === true) {
                    that.touch = true;
                }

                that.host.append(comboStructure);

                that.dropdownlistWrapper = that.host.find('#dropdownlistWrapper');
                that.dropdownlistArrow = that.host.find('#dropdownlistArrow');
                that.dropdownlistContent = that.host.find('#dropdownlistContent');
                that.dropdownlistContent.addClass(that.toThemeProperty('jqx-combobox-content'));
                that.dropdownlistContent.addClass(that.toThemeProperty('jqx-widget-content'));
                that.dropdownlistWrapper[0].id = "dropdownlistWrapper" + that.element.id;
                that.dropdownlistArrow[0].id = "dropdownlistArrow" + that.element.id;
                that.dropdownlistContent[0].id = "dropdownlistContent" + that.element.id;
                if (that.template) {
                    that.dropdownlistArrow.addClass(that.toThemeProperty("jqx-" + that.template + ""));
                }
                that.dropdownlistContent.append($('<input autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="box-sizing: border-box; margin: 0; padding: 0; padding-left: 3px; padding-right: 3px; border: 0;" type="textarea"/>'));
                that.input = that.dropdownlistContent.find('input');
                that.input.addClass(that.toThemeProperty('jqx-combobox-input'));
                that.input.addClass(that.toThemeProperty('jqx-widget-content'));
                that.input[0].setAttribute('aria-label', 'input');

                if (that.host.attr('tabindex')) {
                    that.input.attr('tabindex', that.host.attr('tabindex'));
                    that.host.removeAttr('tabindex');
                }


                var label = $("<label></label>");
                if (this.hint) {
                    label[0].innerHTML = this.placeHolder;
                }

                label.addClass(that.toThemeProperty('jqx-input-label'));
                that.dropdownlistWrapper.append(label);
                that.label = label;

                var bar = $("<span></span>");
                that.dropdownlistWrapper.append(bar);
                bar.addClass(that.toThemeProperty('jqx-input-bar'));
                that.bar = bar;

                var that = this;

                if (that.template) {
                    that.bar.addClass(that.toThemeProperty("jqx-" + that.template));
                    that.label.addClass(that.toThemeProperty("jqx-" + that.template));
                }

                that._addInput();
                if (that.rtl) {
                    that.input.css({ direction: "rtl" });
                    that.dropdownlistContent.addClass(that.toThemeProperty('jqx-combobox-content-rtl'));
                }

                try {
                    var listBoxID = 'listBox' + that.id;
                    var oldContainer = $($.find('#' + listBoxID));
                    if (oldContainer.length > 0) {
                        oldContainer.remove();
                    }
                    $.jqx.aria(this, "aria-owns", listBoxID);
                    $.jqx.aria(this, "aria-haspopup", true);
                    if (that.listBoxContainer) that.listBoxContainer.jqxListBox('destroy');
                    if (that.container) that.container.remove();
                    var container = $("<div style='overflow: hidden; border: none; background-color: transparent; position: absolute;' id='listBox" + that.id + "'><div id='innerListBox" + that.id + "'></div></div>");
                    container.hide();
                    if (that.dropDownContainer == "element") {
                        container.appendTo(that.host);
                    }
                    else {
                        container.appendTo(document.body);
                    }
                    container.addClass(that.toThemeProperty('jqx-listbox-container'));

                    that.container = container;
                    that.listBoxContainer = $($.find('#innerListBox' + that.id));

                    var width = that.width;
                    if (that.dropDownWidth != 'auto') {
                        width = that.dropDownWidth;
                    }

                    if (that.dropDownHeight == null) {
                        that.dropDownHeight = 200;
                    }

                    that.container.width(parseInt(width) + 25);
                    that.container.height(parseInt(that.dropDownHeight) + 25);
                    that._ready = false;

                    that.addHandler(that.listBoxContainer, 'bindingComplete', function (event) {
                        if (!that.listBox) {
                            that.listBox = $.data(that.listBoxContainer[0], "jqxListBox").instance;
                        }
                        if (!that._ready) {
                            if (that.ready) {
                                that.ready();
                            }
                            that._ready = true;
                        }
                        that._raiseEvent('6');
                    });
                    that.addHandler(that.listBoxContainer, 'itemAdd', function (event) {
                        that._raiseEvent('7', event.args);
                    });
                    that.addHandler(that.listBoxContainer, 'itemRemove', function (event) {
                        that._raiseEvent('8', event.args);
                    });
                    that.addHandler(that.listBoxContainer, 'itemUpdate', function (event) {
                        that._raiseEvent('9', event.args);
                    });

                    var initializing = true;
                    that.listBoxContainer.jqxListBox({
                        autoItemsHeight: that.autoItemsHeight,
                        _checkForHiddenParent: false, allowDrop: false, allowDrag: false,
                        checkboxes: that.checkboxes, emptyString: that.emptyString, autoBind: !that.remoteAutoComplete && that.autoBind,
                        renderer: that.renderer, rtl: that.rtl, itemHeight: that.itemHeight, selectedIndex: that.selectedIndex, incrementalSearch: false, width: width, scrollBarSize: that.scrollBarSize, autoHeight: that.autoDropDownHeight, height: that.dropDownHeight, groupMember: that.groupMember, searchMember: that.searchMember, displayMember: that.displayMember, valueMember: that.valueMember, source: that.source, theme: that.theme,
                        rendered: function () {
                            that.listBox = $.data(that.listBoxContainer[0], "jqxListBox").instance;
                            if (that.remoteAutoComplete) {
                                if (that.autoDropDownHeight) {
                                    that.container.height(that.listBox.virtualSize.height + 25);
                                    that.listBoxContainer.height(that.listBox.virtualSize.height);
                                    that.listBox._arrange();
                                }
                                else {
                                    that.listBox._arrange();
                                    that.listBox.ensureVisible(0);
                                    that.listBox._renderItems();
                                    that.container.height(that.listBoxContainer.height() + 25);
                                }

                                if (that.searchString != undefined && that.searchString.length >= that.minLength) {
                                    var items = that.listBoxContainer.jqxListBox('items');
                                    if (items) {
                                        if (items.length > 0) {
                                            if (!that.isOpened()) {
                                                that.open();
                                            }
                                        }
                                        else that.close();
                                    } else that.close();
                                }
                                else {
                                    that.close();
                                }
                            }
                            else {
                                that.renderSelection('mouse');
                                if (that.multiSelect) {
                                    that.doMultiSelect(false);
                                }
                            }

                            if (that.rendered) {
                                that.rendered();
                            }
                        }
                    });

                    if (that.dropDownContainer == "element") {
                        that.listBoxContainer.css({ position: 'absolute', top: 0, left: 0 });
                    }
                    else {
                        that.listBoxContainer.css({ position: 'absolute', zIndex: that.popupZIndex, top: 0, left: 0 });
                    }
                    that.listBoxContainer.css('border-top-width', '1px');
                    that.listBoxContainer.addClass(that.toThemeProperty('jqx-popup'));
                    if ($.jqx.browser.msie) {
                        that.listBoxContainer.addClass(that.toThemeProperty('jqx-noshadow'));
                    }
                    if (that.template) {
                        that.listBoxContainer.addClass(that.toThemeProperty("jqx-" + that.template + "-item"));
                    }

                    that.listBox = $.data(that.listBoxContainer[0], "jqxListBox").instance;
                    that.listBox.enableSelection = that.enableSelection;
                    that.listBox.enableHover = that.enableHover;
                    that.listBox.equalItemsWidth = that.equalItemsWidth;
                    that.listBox._arrange();
                    that.addHandler(that.listBoxContainer, 'unselect', function (event) {
                        if (!that.multiSelect) {
                            that._raiseEvent('3', { index: event.args.index, type: event.args.type, item: event.args.item });
                        }
                    });

                    that.addHandler(that.listBoxContainer, 'change', function (event) {
                        if (!that.multiSelect) {
                            that.selectedIndex = that.listBox.selectedIndex;
                            that._raiseEvent('4', { index: event.args.index, type: event.args.type, item: event.args.item });
                        }
                    });

                    if (that.animationType == 'none') {
                        that.container.css('display', 'none');
                    }
                    else {
                        that.container.hide();
                    }
                    initializing = false;
                }
                catch (e) {
                    throw e;
                }


                var that = this;
                that.input.attr('disabled', that.disabled);
                var ie7 = $.jqx.browser.msie && $.jqx.browser.version < 8;
                if (!ie7) {
                    if (that.isMaterialized() && that.hint) {
                        that.label[0].innerHTML = that.placeHolder;
                    }
                    else {
                        that.input.attr('placeholder', that.placeHolder);
                    }
                }

                that.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    if (value) {
                        instance.host.addClass(that.toThemeProperty('jqx-combobox-state-disabled'));
                        instance.host.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
                        instance.dropdownlistContent.addClass(that.toThemeProperty('jqx-combobox-content-disabled'));
                    }
                    else {
                        instance.host.removeClass(that.toThemeProperty('jqx-combobox-state-disabled'));
                        instance.host.removeClass(that.toThemeProperty('jqx-fill-state-disabled'));
                        instance.dropdownlistContent.removeClass(that.toThemeProperty('jqx-combobox-content-disabled'));
                    }
                    instance.input.attr('disabled', instance.disabled);
                    $.jqx.aria(instance, "aria-disabled", instance.disabled);
                    instance.input.attr('disabled', instance.disabled);
                }

                if (that.disabled) {
                    that.host.addClass(that.toThemeProperty('jqx-combobox-state-disabled'));
                    that.host.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
                    that.dropdownlistContent.addClass(that.toThemeProperty('jqx-combobox-content-disabled'));
                }

                that.host.addClass(that.toThemeProperty('jqx-combobox-state-normal'));
                that.host.addClass(that.toThemeProperty('jqx-combobox'));
                that.host.addClass(that.toThemeProperty('jqx-rc-all'));
                that.host.addClass(that.toThemeProperty('jqx-widget'));
                that.host.addClass(that.toThemeProperty('jqx-widget-content'));
                that.dropdownlistArrowIcon = $("<div></div>");
                if (that.dropDownVerticalAlignment == "top") {
                    that.dropdownlistArrowIcon.addClass(that.toThemeProperty('jqx-icon-arrow-up'));
                }
                else {
                    that.dropdownlistArrowIcon.addClass(that.toThemeProperty('jqx-icon-arrow-down'));
                }
                that.dropdownlistArrowIcon.addClass(that.toThemeProperty('jqx-icon'));
                that.dropdownlistArrow.append(that.dropdownlistArrowIcon);
                that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-combobox-arrow-normal'));
                that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-fill-state-normal'));
                that.dropdownlistArrow[0].setAttribute('aria-label', 'expand');

                if (!that.rtl) {
                    that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-rc-r'));
                }
                else {
                    that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-rc-l'));
                }

                that._setSize();
                that._updateHandlers();

                that.addHandler(that.input, 'paste.textchange', function (event) {
                    if (that._writeTimer) clearTimeout(that._writeTimer);
                    that._writeTimer = setTimeout(function () {
                        that.ctrlKey = false;

                        var foundMatch = that._search(event);
                        if (that.cinput && that.input) {
                            if (!that.displayMember) {
                                that.cinput[0].value = that.input[0].value;
                            }
                            else {
                                that._updateInputSelection();
                            }
                        }
                    }, 50);
                });

                that.addHandler(that.input, 'keyup.textchange', function (event) {
                    if (that._writeTimer) clearTimeout(that._writeTimer);
                    that._writeTimer = setTimeout(function () {
                        var foundMatch = that._search(event);
                        if (that.cinput && that.input) {
                            if (!that.displayMember) {
                                that.cinput[0].value = that.input[0].value;
                            }
                            else {
                                that._updateInputSelection();
                            }
                        }
                    }, 50);
                });

                // fix for IE7
                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                    if (that.host.parents('.jqx-window').length > 0) {
                        var zIndex = that.host.parents('.jqx-window').css('z-index');
                        container.css('z-index', zIndex + 10);
                        that.listBoxContainer.css('z-index', zIndex + 10);
                    }
                }

                if (that.checkboxes) {
                    that.input.attr('readonly', true);
                    $.jqx.aria(this, "aria-readonly", true);
                }
                else {
                    $.jqx.aria(this, "aria-readonly", false);
                }
                if (!that.remoteAutoComplete) {
                    that.searchString = "";
                }

                this.bar.css('top', this.host.height());
            },

            _addInput: function () {
                var name = this.host.attr('name');
                this.cinput = $("<input type='hidden'/>");
                this.host.append(this.cinput);
                if (name) {
                    this.cinput.attr('name', name);
                }
            },

            _updateInputSelection: function () {
                if (this.cinput) {
                    var selectedValues = new Array();
                    if (this.selectedIndex == -1) {
                        this.cinput.val("");
                    }
                    else {
                        var selectedItem = this.getSelectedItem();
                        if (selectedItem != null) {
                            this.cinput.val(selectedItem.value);
                            selectedValues.push(selectedItem.value);
                        }
                        else {
                            this.cinput.val(this.dropdownlistContent.text());
                        }
                    }

                    if (this.checkboxes || this.multiSelect) {
                        if (!this.multiSelect) {
                            var items = this.getCheckedItems();
                        }
                        else {
                            var items = this.getSelectedItems();
                        }

                        var str = "";
                        if (items != null) {
                            for (var i = 0; i < items.length; i++) {
                                if (i == items.length - 1) {
                                    str += items[i].value;
                                }
                                else {
                                    str += items[i].value + ",";
                                }
                                selectedValues.push(items[i].value);
                            }
                        }
                        this.cinput.val(str);
                    }
                    if (this.field && this.cinput) {
                        if (this.field.nodeName.toLowerCase() == "select") {
                            $.each(this.field, function (index, value) {
                                $(this).removeAttr('selected');
                                this.selected = selectedValues.indexOf(this.value) >= 0;
                                if (this.selected) {
                                    $(this).attr('selected', true);
                                }
                            });
                        }
                        else {
                            $.each(this.items, function (index, value) {
                                $(this.originalItem.originalItem).removeAttr('data-selected');
                                this.selected = selectedValues.indexOf(this.value) >= 0;
                                if (this.selected) {
                                    $(this.originalItem.originalItem).attr('data-selected', true);
                                }
                            });
                        }
                    }
                }
            },

            _search: function (event) {
                var that = this;

                if (event.keyCode == 9)
                    return;

                if (that.searchMode == 'none' || that.searchMode == null || that.searchMode == 'undefined') {
                    return;
                }

                if (event.keyCode == 16 || event.keyCode == 17 || event.keyCode == 20)
                    return;

                if (that.checkboxes) {
                    return;
                }

                if (that.multiSelect) {
                    var span = $("<span style='visibility: hidden; white-space: nowrap;'>" + document.createTextNode(that.input.val()) + "</span>");
                    span.addClass(that.toThemeProperty('jqx-widget'));
                    $(document.body).append(span);
                    var width = span.width() + 15;
                    span.remove();

                    if (width > that.host.width()) {
                        width = that.host.width();
                    }
                    if (width < 25) {
                        width = 25;
                    }

                    that.input.css('width', width + 'px');
                    if (that.selectedItems.length == 0) {
                        that.input.css('width', '100%');

                        if (!that.isMaterialized()) {
                            that.input.attr('placeholder', that.placeHolder);
                        }
                    }
                    else {
                        if (!that.isMaterialized()) {
                            that.input.attr('placeholder', "");
                        }
                    }

                    var top = parseInt(this._findPos(that.host[0])[1]) + parseInt(that.host.outerHeight()) - 1 + 'px';
                    var isMobileBrowser = false;// $.jqx.mobile.isSafariMobileBrowser() || $.jqx.mobile.isWindowsPhone();
                    if ((isMobileBrowser != null && isMobileBrowser)) {
                        top = $.jqx.mobile.getTopPos(this.element) + parseInt(that.host.outerHeight());
                        if ($('body').css('border-top-width') != '0px') {
                            top = parseInt(top) - this._getBodyOffset().top + 'px';
                        }
                    }

                    that.container.css('top', top);
                    var height = parseInt(that.host.height());
                    that.dropdownlistArrow.height(height);
                }

                if (!that.isanimating) {
                    if (event.altKey && event.keyCode == 38) {
                        that.hideListBox('altKey');
                        return false;
                    }

                    if (event.altKey && event.keyCode == 40) {
                        if (!that.isOpened()) {
                            that.showListBox('altKey');
                        }
                        return false;
                    }
                }

                if (event.keyCode == 37 || event.keyCode == 39)
                    return false;

                if (event.altKey || event.keyCode == 18)
                    return;

                if (event.keyCode >= 33 && event.keyCode <= 40) {
                    return;
                }

                if (event.ctrlKey || that.ctrlKey) {
                    if (event.keyCode != 88 && event.keyCode != 86) {
                        return;
                    }
                }

                var value = that.input.val();
                if (value.length == 0 && !that.autoComplete) {
                    that.listBox.searchString = that.input.val();
                    that.listBox.clearSelection();
                    that.hideListBox('search');
                    that.searchString = that.input.val();
                    return;
                }

                if (that.remoteAutoComplete) {
                    var that = this;
                    var clearListSelection = function () {
                        that.listBox.vScrollInstance.value = 0;
                    }

                    if (value.length >= that.minLength) {
                        if (!event.ctrlKey && !event.altKey) {
                            if (that.searchString != value) {
                                var source = that.listBoxContainer.jqxListBox('source');
                                if (source == null) {
                                    that.listBoxContainer.jqxListBox({ source: that.source });
                                }
                                if (that._searchTimer) {
                                    clearTimeout(that._searchTimer);
                                }
                                if (event.keyCode != 13 && event.keyCode != 27) {
                                    that._searchTimer = setTimeout(function () {
                                        clearListSelection();
                                        if (that.autoDropDownHeight) {
                                            that.listBox.autoHeight = true;
                                        }
                                        that.searchString = that.input.val();
                                        if (that.search != null) {
                                            that.search(that.input.val());
                                        }
                                        else {
                                            throw "'search' function is not defined";
                                        }

                                    }, that.remoteAutoCompleteDelay);
                                }
                            }
                            that.searchString = value;
                        }
                    }
                    else {
                        if (that._searchTimer) clearTimeout(that._searchTimer);
                        clearListSelection();
                        that.searchString = "";
                        that.search("");
                        that.listBoxContainer.jqxListBox({ source: null });
                    }
                    return;
                }

                var that = this;
                if (value === that.searchString) {
                    return;
                }

                if (!(event.keyCode == '27' || event.keyCode == '13')) {
                    var currentValue = that.input[0].value;
                    var matches = that._updateItemsVisibility(value);
                    var matchItems = matches.matchItems;
                    if (that.autoComplete && that.autoItemsHeight) {
                        that.input[0].value = currentValue;
                    }
                    var index = matches.index;
                    if (!that.autoComplete && !that.remoteAutoComplete) {
                        if (!that.multiSelect || (that.multiSelect && index >= 0)) {
                            that.listBox.selectIndex(index);
                            var isInView = that.listBox.isIndexInView(index);
                            if (!isInView) {
                                that.listBox.ensureVisible(index);
                            }
                            else {
                                that.listBox._renderItems();
                            }
                        }
                    }

                    if (that.autoComplete && matchItems.length === 0) {
                        that.hideListBox('search');
                    }
                }

                if (event.keyCode == '13') {
                    var isOpen = that.container.css('display') == 'block';
                    if (isOpen && !that.isanimating) {
                        that.hideListBox('keyboard');
                        that._oldvalue = that.listBox.selectedValue;
                        return;
                    }
                }
                else if (event.keyCode == '27') {
                    var isOpen = that.container.css('display') == 'block';
                    if (isOpen && !that.isanimating) {
                        if (!that.multiSelect) {
                            var item = that.listBox.getVisibleItem(that._oldvalue);
                            if (item) {
                                var that = this;
                                setTimeout(
                                    function () {
                                        if (that.autoComplete) {
                                            that._updateItemsVisibility("");
                                        }
                                        that.listBox.selectIndex(item.index);
                                        that.renderSelection('api');
                                    }, that.closeDelay);
                            }
                            else {
                                that.clearSelection();
                            }
                        }
                        else {
                            that.input.val("");
                            that.listBox.selectedValue = null;
                        }

                        that.hideListBox('keyboard');
                        that.renderSelection('api');
                        event.preventDefault();
                        return false;
                    }
                }
                else {
                    if (!that.isOpened() && !that.opening && !event.ctrlKey) {
                        if (that.listBox.visibleItems && that.listBox.visibleItems.length > 0) {
                            if (that.input.val() != that.searchString && that.searchString != undefined && index != -1) {
                                that.showListBox('search');
                            }
                        }
                    }
                    that.searchString = that.input.val();

                    if (that.searchString == "") {
                        if (!that.listBox.itemsByValue[""]) {
                            index = -1;
                            if (!that.multiSelect) {
                                that.clearSelection();
                            }
                        }
                    }

                    var item = that.listBox.getVisibleItem(index);

                    if (item != undefined) {
                        that._updateInputSelection();
                    }
                }
            },

            val: function (value) {
                if (!this.input) return "";
                var isEmpty = function (obj) {
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key))
                            return false;
                    }

                    if (typeof value == "number")
                        return false;
                    if (typeof value == "date")
                        return false;
                    if (typeof value == "boolean")
                        return false;
                    if (typeof value == "string")
                        return false;

                    return true;
                }

                if (isEmpty(value) || arguments.length == 0) {
                    var item = this.getSelectedItem();
                    if (item) {
                        return item.value;
                    }


                    return this.input.val();
                }
                else {
                    var item = this.getItemByValue(value);
                    if (item != null) {
                        this.selectItem(item);
                    }
                    else {
                        this.input.val(value);
                    }
                    return this.input.val();
                }
            },

            focus: function () {
                var that = this;
                var doFocus = function () {
                    that.input.focus();
                    var val = that.input.val();
                    that._setSelection(0, val.length);
                }
                doFocus();
                setTimeout(function () {
                    doFocus();
                }, 10);
            },

            _setSelection: function (start, end) {
                try {
                    if ('selectionStart' in this.input[0]) {
                        this.input[0].focus();
                        this.input[0].setSelectionRange(start, end);
                    }
                    else {
                        var range = this.input[0].createTextRange();
                        range.collapse(true);
                        range.moveEnd('character', end);
                        range.moveStart('character', start);
                        range.select();
                    }
                }
                catch (error) {
                }
            },

            setContent: function (value) {
                this.input.val(value);
            },

            // get all matches of a searched value.
            _updateItemsVisibility: function (value) {
                var items = this.getItems();
                if (items == undefined) {
                    return { index: -1, matchItem: new Array() }
                }

                var that = this;
                var index = -1;
                var matchItems = new Array();
                var newItemsIndex = 0;

                $.each(items, function (i) {
                    var itemValue = '';
                    if (!this.isGroup) {
                        if (this.searchLabel) {
                            itemValue = this.searchLabel;
                        }
                        else if (this.label) {
                            itemValue = this.label;
                        }
                        else if (this.value) {
                            itemValue = this.value;
                        }
                        else if (this.title) {
                            itemValue = this.title;
                        }
                        else itemValue = 'jqxItem';
                        itemValue = itemValue.toString();
                        var matches = false;
                        switch (that.searchMode) {
                            case 'containsignorecase':
                                matches = $.jqx.string.containsIgnoreCase(itemValue, value);
                                break;
                            case 'contains':
                                matches = $.jqx.string.contains(itemValue, value);
                                break;
                            case 'equals':
                                matches = $.jqx.string.equals(itemValue, value);
                                break;
                            case 'equalsignorecase':
                                matches = $.jqx.string.equalsIgnoreCase(itemValue, value);
                                break;
                            case 'startswith':
                                matches = $.jqx.string.startsWith(itemValue, value);
                                break;
                            case 'startswithignorecase':
                                matches = $.jqx.string.startsWithIgnoreCase(itemValue, value);
                                break;
                            case 'endswith':
                                matches = $.jqx.string.endsWith(itemValue, value);
                                break;
                            case 'endswithignorecase':
                                matches = $.jqx.string.endsWithIgnoreCase(itemValue, value);
                                break;
                        }

                        if (that.autoComplete && !matches) {
                            this.visible = false;
                        }

                        if (matches && that.autoComplete) {
                            matchItems[newItemsIndex++] = this;
                            this.visible = true;
                            index = this.visibleIndex;
                        }

                        if (value == '' && that.autoComplete) {
                            this.visible = true;
                            matches = false;
                        }

                        if (that.multiSelect) {
                            this.disabled = false;
                            if (that.selectedItems.indexOf(this.value) >= 0 || that._disabledItems.indexOf(this.value) >= 0) {
                                this.disabled = true;
                                matches = false;
                            }
                        }

                        if (!that.multiSelect) {
                            if (matches && !that.autoComplete) {
                                index = this.visibleIndex;
                                return false;
                            }
                        }
                        else {
                            if (matches && !that.autoComplete) {
                                if (index === -1) {
                                    index = this.visibleIndex;
                                }
                                return true;
                            }
                        }
                    }
                });
                this.listBox.searchString = value;
                var that = this;
                var selectFirstItem = function () {
                    if (that.multiSelect) return;
                    var nonDisabledIndex = 0;
                    var foundIndex = false;
                    var item = null;
                    for (var indx = 0; indx < that.listBox.items.length; indx++) {
                        that.listBox.selectedIndexes[indx] = -1;
                        if (!that.listBox.items[indx].disabled) {
                            if (foundIndex == false) {
                                item = that.listBox.items[indx];
                                nonDisabledIndex = item.visibleIndex;
                                foundIndex = true;
                            }
                        }
                    }
                    that.listBox.selectedIndex = -1;
                    that.listBox.selectedIndex = nonDisabledIndex;
                    that.listBox.selectedIndexes[nonDisabledIndex] = nonDisabledIndex;
                    if (that.listBox.visibleItems.length > 0) {
                        if (item) {
                            that.listBox.selectedValue = item.value;
                        }
                        else {
                            that.listBox.selectedValue = null;
                        }
                    }
                    else {
                        that.listBox.selectedValue = null;
                    }
                    that.listBox.ensureVisible(0);
                }

                if (!this.autoComplete) {
                    selectFirstItem();
                    return { index: index, matchItems: matchItems };
                }

                this.listBox.renderedVisibleItems = new Array();
                var vScrollValue = this.listBox.vScrollInstance.value;
                this.listBox.vScrollInstance.value = 0;
                this.listBox.visibleItems = new Array();
                this.listBox._renderItems();
                var selectedValue = this.listBox.selectedValue;
                var item = this.listBox.getItemByValue(selectedValue);
                if (!this.multiSelect) {
                    if (item) {
                        if (item.visible) {
                            this.listBox.selectedIndex = item.visibleIndex;
                            for (var indx = 0; indx < this.listBox.items.length; indx++) {
                                this.listBox.selectedIndexes[indx] = -1;
                            }
                            this.listBox.selectedIndexes[item.visibleIndex] = item.visibleIndex;
                        }
                        else {
                            for (var indx = 0; indx < this.listBox.items.length; indx++) {
                                this.listBox.selectedIndexes[indx] = -1;
                            }
                            this.listBox.selectedIndex = -1;
                        }
                    }
                }
                else {
                    selectFirstItem();
                }

                this.listBox._renderItems();
                var height = this.listBox._calculateVirtualSize().height;
                if (height < vScrollValue) {
                    vScrollValue = 0;
                    this.listBox.vScrollInstance.refresh();
                }
                if (this.autoDropDownHeight) {
                    this._disableSelection = true;
                    if (this.listBox.autoHeight != this.autoDropDownHeight) {
                        this.listBoxContainer.jqxListBox({ autoHeight: this.autoDropDownHeight });
                    }
                    this.container.height(height + 25);
                    this.listBox.invalidate();
                    this._disableSelection = false;
                }
                else {
                    if (height < parseInt(this.dropDownHeight)) {
                        var scrollOffset = this.listBox.hScrollBar[0].style.visibility == "hidden" ? 0 : 20;
                        this.listBox.height = scrollOffset + height;
                        this.container.height(height + 25 + scrollOffset);
                        this.listBox.invalidate();
                    }
                    else {
                        this.listBox.height = parseInt(this.dropDownHeight);
                        this.container.height(parseInt(this.dropDownHeight) + 25);
                        this.listBox.invalidate();
                    }
                }

                this.listBox.vScrollInstance.setPosition(vScrollValue);
                return { index: index, matchItems: matchItems };
            },

            // gets all items that match to a search value.
            findItems: function (value) {
                var items = this.getItems();
                var that = this;
                var index = 0;
                var matchItems = new Array();

                $.each(items, function (i) {
                    var itemValue = '';
                    if (!this.isGroup) {
                        if (this.label) {
                            itemValue = this.label;
                        }
                        else if (this.value) {
                            itemValue = this.value;
                        }
                        else if (this.title) {
                            itemValue = this.title;
                        }
                        else itemValue = 'jqxItem';

                        var matches = false;
                        switch (that.searchMode) {
                            case 'containsignorecase':
                                matches = $.jqx.string.containsIgnoreCase(itemValue, value);
                                break;
                            case 'contains':
                                matches = $.jqx.string.contains(itemValue, value);
                                break;
                            case 'equals':
                                matches = $.jqx.string.equals(itemValue, value);
                                break;
                            case 'equalsignorecase':
                                matches = $.jqx.string.equalsIgnoreCase(itemValue, value);
                                break;
                            case 'startswith':
                                matches = $.jqx.string.startsWith(itemValue, value);
                                break;
                            case 'startswithignorecase':
                                matches = $.jqx.string.startsWithIgnoreCase(itemValue, value);
                                break;
                            case 'endswith':
                                matches = $.jqx.string.endsWith(itemValue, value);
                                break;
                            case 'endswithignorecase':
                                matches = $.jqx.string.endsWithIgnoreCase(itemValue, value);
                                break;
                        }

                        if (matches) {
                            matchItems[index++] = this;
                        }
                    }
                });

                return matchItems;
            },

            //[optimize]
            _resetautocomplete: function () {
                $.each(this.listBox.items, function (i) {
                    this.visible = true;
                });
                this.listBox.vScrollInstance.value = 0;
                this.listBox._addItems();
                this.listBox.autoHeight = false;

                this.listBox.height = this.dropDownHeight;
                this.container.height(parseInt(this.dropDownHeight) + 25);
                this.listBoxContainer.height(parseInt(this.dropDownHeight));
                this.listBox._arrange();

                this.listBox._addItems();
                this.listBox._renderItems();
            },

            // gets all items.
            getItems: function () {
                var item = this.listBox.items;
                return item;
            },

            getVisibleItems: function () {
                return this.listBox.getVisibleItems();
            },

            _setSize: function () {
                var computedStyle = window.getComputedStyle(this.element);
                var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
                var boxSizing = computedStyle.boxSizing;

                if (boxSizing === 'border-box' || isNaN(borderSize)) {
                    borderSize = 0;
                }

                if (this.width != null && this.width.toString().indexOf("px") != -1) {
                    this.element.style.width = parseInt(this.width) - borderSize + 'px';
                }
                else if (this.width != undefined && !isNaN(this.width)) {
                    this.element.style.width = parseInt(this.width) - borderSize + 'px';
                }

                if (this.height != null && this.height.toString().indexOf("px") != -1) {
                    this.element.style.height = parseInt(this.height) - borderSize + 'px';
                }
                else if (this.height != undefined && !isNaN(this.height)) {
                    this.element.style.height = parseInt(this.height) - borderSize + 'px';
                };

                var isPercentage = false;
                if (this.width != null && this.width.toString().indexOf("%") != -1) {
                    isPercentage = true;
                    this.element.style.width = this.width;

                    if (borderSize > 0) {
                        this.host.css('box-sizing', 'border-box');
                    }
                }

                if (this.height != null && this.height.toString().indexOf("%") != -1) {
                    isPercentage = true;
                    this.element.style.height = this.height;
                }

                if (isPercentage) {
                    var that = this;
                    var width = this.host.width();
                    if (this.dropDownWidth != 'auto') {
                        width = this.dropDownWidth;
                    }
                    this.listBoxContainer.jqxListBox({ width: width });
                    this.container.width(parseInt(width) + 25);
                    this._arrange();
                }
                var that = this;

                var resizeFunc = function () {
                    if (that.multiSelect) {
                        that.host.height(that.height);
                    }

                    that._arrange();
                    if (that.multiSelect) {
                        that.host.height('auto');
                    }
                }

                that.oldWidth = that.host.width();
                that.oldHeight = that.host.height();
                $.jqx.utilities.resize(this.host, function () {
                    var w = that.host.width();
                    var h = that.host.height();

                    if (w != that.oldWidth || h != that.oldHeight) {
                        resizeFunc();
                        that.hideListBox('api');
                    }

                    that.oldWidth = w;
                    that.oldHeight = h;
                });
            },

            // returns true when the listbox is opened, otherwise returns false.
            isOpened: function () {
                var that = this;
                var openedListBox = $.data(document.body, "openedCombojqxListBox" + this.element.id);

                if (this.container.css('display') != 'block')
                    return false;

                if (openedListBox != null && openedListBox == that.listBoxContainer) {
                    return true;
                }

                return false;
            },

            _updateHandlers: function () {
                var that = this;
                var hovered = false;
                this.removeHandlers();

                if (this.multiSelect) {
                    this.addHandler(this.dropdownlistContent, 'click', function (event) {
                        if (event.target.href) return false;

                        that.input.focus();
                        setTimeout(function () {
                            that.input.focus();
                        }, 10);
                    });
                    this.addHandler(this.dropdownlistContent, 'focus', function (event) {
                        if (event.target.href) return false;

                        that.input.focus();
                        setTimeout(function () {
                            that.input.focus();
                        }, 10);
                    });
                }

                if (!this.touch) {
                    if (this.host.parents()) {
                        this.addHandler(this.host.parents(), 'scroll.combobox' + this.element.id, function (event) {
                            var opened = that.isOpened();
                            if (opened) {
                                that.close();
                            }
                        });
                    }

                    this.addHandler(this.host, 'mouseenter', function () {
                        if (!that.disabled && that.enableHover) {
                            hovered = true;
                            that.host.addClass(that.toThemeProperty('jqx-combobox-state-hover'));
                            if (that.dropDownVerticalAlignment == "top") {
                                that.dropdownlistArrowIcon.addClass(that.toThemeProperty('jqx-icon-arrow-up'));
                            }
                            else {
                                that.dropdownlistArrowIcon.addClass(that.toThemeProperty('jqx-icon-arrow-down-hover'));
                            }
                            that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-combobox-arrow-hover'));
                            that.dropdownlistArrow.addClass(that.toThemeProperty('jqx-fill-state-hover'));
                        }
                    });
                    this.addHandler(this.host, 'mouseleave', function () {
                        if (!that.disabled && that.enableHover) {
                            that.host.removeClass(that.toThemeProperty('jqx-combobox-state-hover'));
                            that.dropdownlistArrowIcon.removeClass(that.toThemeProperty('jqx-icon-arrow-down-hover'));
                            that.dropdownlistArrowIcon.removeClass(that.toThemeProperty('jqx-icon-arrow-up-hover'));
                            that.dropdownlistArrow.removeClass(that.toThemeProperty('jqx-combobox-arrow-hover'));
                            that.dropdownlistArrow.removeClass(that.toThemeProperty('jqx-fill-state-hover'));
                            hovered = false;
                        }
                    });
                }

                if (that.autoOpen) {
                    this.addHandler(this.host, 'mouseenter', function () {
                        var isOpened = that.isOpened();
                        if (!isOpened && that.autoOpen) {
                            that.open();
                            that.host.focus();
                        }
                    });

                    this.addHandler($(document), 'mousemove.' + that.id, function (event) {
                        var isOpened = that.isOpened();
                        if (isOpened && that.autoOpen) {
                            var offset = that.host.coord();
                            var top = offset.top;
                            var left = offset.left;
                            var popupOffset = that.container.coord();
                            var popupLeft = popupOffset.left;
                            var popupTop = popupOffset.top;

                            var canClose = true;

                            if (event.pageY >= top && event.pageY <= top + that.host.height() + 2) {
                                if (event.pageX >= left && event.pageX < left + that.host.width())
                                    canClose = false;
                            }
                            if (event.pageY >= popupTop && event.pageY <= popupTop + that.container.height() - 20) {
                                if (event.pageX >= popupLeft && event.pageX < popupLeft + that.container.width())
                                    canClose = false;
                            }

                            if (canClose) {
                                that.close();
                            }
                        }
                    });
                }

                var eventName = 'mousedown';
                if (this.touch) eventName = $.jqx.mobile.getTouchEventName('touchstart');

                var dropDownButtonClicked = function (event) {
                    if (!that.disabled) {
                        var isOpen = that.container.css('display') == 'block';
                        if (!that.isanimating) {
                            if (isOpen) {
                                that.hideListBox('api');
                                if (!$.jqx.mobile.isTouchDevice()) {
                                    that.input.focus();
                                    setTimeout(function () {
                                        that.input.focus();
                                    }, 10);
                                }
                                return true;
                            }
                            else {
                                if (that.autoDropDownHeight) {
                                    that.container.height(that.listBoxContainer.height() + 25);
                                    var autoheight = that.listBoxContainer.jqxListBox('autoHeight');
                                    if (!autoheight) {
                                        that.listBoxContainer.jqxListBox({ autoHeight: that.autoDropDownHeight })
                                        that.listBox._arrange();
                                        that.listBox.ensureVisible(0);
                                        that.listBox._renderItems();
                                        that.container.height(that.listBoxContainer.height() + 25);
                                    }
                                }
                                that.showListBox('api');
                                if (!$.jqx.mobile.isTouchDevice()) {
                                    setTimeout(function () {
                                        that.input.focus();
                                    }, 10);
                                }
                                else {
                                    return true;
                                }
                            }
                        }
                    }
                }

                this.addHandler(this.dropdownlistArrow, eventName,
                    function (event) {
                        dropDownButtonClicked(event);
                        //       return false;
                    });
                this.addHandler(this.dropdownlistArrowIcon, eventName,
                    function (event) {

                        //   dropDownButtonClicked(event);
                        //     return false;
                    });

                this.addHandler(this.host, 'focus', function () {
                    that.focus();
                });

                this.addHandler(this.input, 'focus', function (event) {
                    that.focused = true;
                    that.host.addClass(that.toThemeProperty('jqx-combobox-state-focus'));
                    that.host.addClass(that.toThemeProperty('jqx-fill-state-focus'));
                    that.bar.addClass('focused');
                    that.label.addClass('focused');

                    that.dropdownlistContent.addClass(that.toThemeProperty('jqx-combobox-content-focus'));
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }

                });
                this.addHandler(this.input, 'blur', function () {
                    that.focused = false;
                    that.bar.removeClass('focused');
                    that.label.removeClass('focused');

                    if (!that.isOpened() && !that.opening) {
                        if (that.selectionMode == "dropDownList") {
                            that._selectOldValue();
                        }

                        that.host.removeClass(that.toThemeProperty('jqx-combobox-state-focus'));
                        that.host.removeClass(that.toThemeProperty('jqx-fill-state-focus'));
                        that.dropdownlistContent.removeClass(that.toThemeProperty('jqx-combobox-content-focus'));
                    }
                    if (that._searchTimer) clearTimeout(that._searchTimer);
                });
                this.addHandler($(document), 'mousedown.' + this.id, that.closeOpenedListBox, { that: this, listbox: this.listBox, id: this.id });
                if (this.touch) {
                    this.addHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.' + this.id, that.closeOpenedListBox, { that: this, listbox: this.listBox, id: this.id });
                }

                this.addHandler(this.host, 'keydown', function (event) {
                    var isOpen = that.container.css('display') == 'block';
                    that.ctrlKey = event.ctrlKey;
                    if (that.host.css('display') == 'none') {
                        return true;
                    }

                    if (event.keyCode == '13' || event.keyCode == '9') {
                        if (isOpen && !that.isanimating) {
                            if (that.listBox.selectedIndex != -1) {
                                that.renderSelection('mouse');
                                var index = that.listBox.selectedIndex;
                                var item = that.listBox.getVisibleItem(index);
                                if (item) {
                                    that.listBox.selectedValue = item.value;
                                }
                                that._setSelection(that.input.val().length, that.input.val().length);
                                that.hideListBox('keyboard');
                            }
                            if (event.keyCode == '13') {
                                that._oldvalue = that.listBox.selectedValue;
                            }
                            if (!that.keyboardSelection) {
                                that._raiseEvent('2', { index: that.selectedIndex, type: 'keyboard', item: that.getItem(that.selectedIndex) });
                            }

                            if (event.keyCode == '9') return true;
                            return false;
                        }
                    }

                    if (event.keyCode == 115) {
                        if (!that.isanimating) {
                            if (!that.isOpened()) {
                                that.showListBox('keyboard');
                            }
                            else if (that.isOpened()) {
                                that.hideListBox('keyboard');
                            }
                        }
                        return false;
                    }

                    if (event.altKey) {
                        if (that.host.css('display') == 'block') {
                            if (!that.isanimating) {
                                if (event.keyCode == 38) {
                                    if (that.isOpened()) {
                                        that.hideListBox('altKey');
                                    }
                                }
                                else if (event.keyCode == 40) {
                                    if (!that.isOpened()) {
                                        that.showListBox('altKey');
                                    }
                                }
                            }
                        }
                    }

                    if (event.keyCode == '27' || event.keyCode == '9') {
                        if (that.isOpened() && !that.isanimating) {

                            if (event.keyCode == '27') {
                                if (!that.multiSelect) {
                                    var item = that.listBox.getItemByValue(that._oldvalue);
                                    if (item) {
                                        setTimeout(
                                            function () {
                                                if (that.autoComplete) {
                                                    that._updateItemsVisibility("");
                                                }
                                                that.listBox.selectIndex(item.index);
                                                that.renderSelection('api');
                                            }, that.closeDelay);
                                    }
                                    else {
                                        that.clearSelection();
                                    }
                                }
                                else {
                                    that.listBox.selectedValue = null;
                                    that.input.val("");
                                }
                            }
                            that.hideListBox('keyboard');


                            if (event.keyCode == '9')
                                return true;

                            that.renderSelection('api');
                            event.preventDefault();

                            return false;
                        }
                    }

                    var key = event.keyCode;

                    if (isOpen && !that.disabled && key != 8) {
                        return that.listBox._handleKeyDown(event);
                    }
                    else if (!that.disabled && !isOpen) {
                        var key = event.keyCode;
                        // arrow keys.
                        if (key == 33 || key == 34 || key == 35 || key == 36 || key == 38 || key == 40) {
                            return that.listBox._handleKeyDown(event);
                        }
                    }
                    if (key === 8 && that.multiSelect) {
                        if (that.input.val().length === 0) {
                            var lastItem = that.selectedItems[that.selectedItems.length - 1];
                            that.selectedItems.pop();
                            that._selectedItems.pop();
                            if (lastItem) {
                                that._raiseEvent('3', { index: lastItem.index, type: 'keyboard', item: lastItem });
                                that._raiseEvent('4', { index: lastItem.index, type: 'keyboard', item: lastItem });
                            }

                            that.listBox.selectedValue = null;
                            that.doMultiSelect();
                            return false;
                        }
                    }


                    if (that.isMaterialized() && that.hint) {
                        setTimeout(function () {
                            if (that.input[0].value.length === 0) {
                                that.element.removeAttribute('hint');
                                that.label[0].innerHTML = that.placeHolder;
                            }
                            else if (that.hint) {
                                that.element.setAttribute('hint', true);
                            }
                        });
                    }
                });

                this.addHandler(this.listBoxContainer, 'checkChange', function (event) {
                    that.renderSelection('mouse');
                    that._updateInputSelection();
                    that._raiseEvent(5, { label: event.args.label, value: event.args.value, checked: event.args.checked, item: event.args.item });
                });

                this.addHandler(this.listBoxContainer, 'select', function (event) {
                    if (!that.disabled) {
                        if (event.args.type != 'keyboard' || that.keyboardSelection) {
                            that.renderSelection(event.args.type);
                            if (!that.multiSelect) {
                                that._raiseEvent('2', { index: event.args.index, type: event.args.type, item: event.args.item });
                            }
                            if (event.args.type == 'mouse') {
                                that._oldvalue = that.listBox.selectedValue;

                                if (!that.checkboxes) {
                                    that.hideListBox('mouse');
                                    if (!that.touch) {
                                        that.input.focus();
                                    }
                                    else {
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                });
                if (this.listBox != null && this.listBox.content != null) {
                    this.addHandler(this.listBox.content, 'click', function (event) {
                        if (!that.disabled) {
                            if (that.listBox.itemswrapper) {
                                if (event.target === that.listBox.itemswrapper[0])
                                    return true;
                            }

                            if (event.target && event.target.className) {
                                if (event.target.className.indexOf('jqx-fill-state-disabled') >= 0) {
                                    return true;
                                }
                            }

                            that.renderSelection('mouse');
                            that._oldvalue = that.listBox.selectedValue;
                            if (!that.touch && !that.ishiding) {
                                if (!that.checkboxes) {
                                    that.hideListBox('mouse');
                                    that.input.focus();
                                }
                            }
                            if (that.touch === true) {
                                if (!that.checkboxes) {
                                    that.hideListBox('mouse');
                                }
                            }
                        }
                    });
                }
            },

            _selectOldValue: function () {
                var that = this;
                if (that.listBox.selectedIndex == -1) {
                    if (!that.multiSelect) {
                        var item = that.listBox.getItemByValue(that._oldvalue);
                        if (item) {
                            setTimeout(
                                function () {
                                    if (that.autoComplete) {
                                        that._updateItemsVisibility("");
                                    }
                                    that.listBox.selectIndex(item.index);
                                    that.renderSelection('api');
                                }, that.closeDelay);
                        }
                        else {
                            that.clearSelection();
                            that.listBox.selectIndex(0);
                            that.renderSelection('api');
                        }
                    }
                    else {
                        that.listBox.selectedValue = null;
                        that.input.val("");
                    }
                }
                else {
                    that.renderSelection('api');
                }
            },

            removeHandlers: function () {
                var that = this;
                if (this.dropdownlistWrapper != null) {
                    this.removeHandler(this.dropdownlistWrapper, 'mousedown');
                }

                if (this.dropdownlistContent) {
                    this.removeHandler(this.dropdownlistContent, 'click');
                    this.removeHandler(this.dropdownlistContent, 'focus');
                }
                this.removeHandler(this.host, 'keydown');
                this.removeHandler(this.host, 'focus');
                if (this.input != null) {
                    this.removeHandler(this.input, 'focus');
                    this.removeHandler(this.input, 'blur');
                }
                this.removeHandler(this.host, 'mouseenter');
                this.removeHandler(this.host, 'mouseleave');
                this.removeHandler($(document), 'mousemove.' + that.id);
                if (this.listBoxContainer) {
                    this.removeHandler(this.listBoxContainer, 'checkChange');
                    this.removeHandler(this.listBoxContainer, 'select');
                }
                if (this.host.parents()) {
                    this.removeHandler(this.host.parents(), 'scroll.combobox' + this.element.id);
                }
                if (this.dropdownlistArrowIcon && this.dropdownlistArrow) {
                    var eventName = 'mousedown';
                    if (this.touch) eventName = $.jqx.mobile.getTouchEventName('touchstart');
                    this.removeHandler(this.dropdownlistArrowIcon, eventName);
                    this.removeHandler(this.dropdownlistArrow, eventName);
                }
            },

            // gets an item by index.
            getItem: function (index) {
                var item = this.listBox.getItem(index);
                return item;
            },

            getItemByValue: function (value) {
                var item = this.listBox.getItemByValue(value);
                return item;
            },

            getVisibleItem: function (index) {
                var item = this.listBox.getVisibleItem(index);
                return item;
            },

            // renders the selection.
            renderSelection: function (type) {
                if (type == undefined || type == 'none') {
                    return;
                }

                if (this._disableSelection === true)
                    return;

                if (this.listBox == null)
                    return;

                if (this.multiSelect) {
                    return;
                }
                var item = this.listBox.visibleItems[this.listBox.selectedIndex];

                if (this.autoComplete && !this.checkboxes) {
                    if (this.listBox.selectedValue !== undefined) {
                        var item = this.getItemByValue(this.listBox.selectedValue);
                    }
                }

                if (this.checkboxes) {
                    var checkedItems = this.getCheckedItems();
                    if (checkedItems != null && checkedItems.length > 0) {
                        item = checkedItems[0];
                    }
                    else item = null;
                }

                if (this.hint) {
                    this.label[0].innerHTML = this.placeHolder;
                }

                if (item != null) {
                    if (this.hint) {
                        this.element.setAttribute('hint', true);
                    }
                }
                else {
                    this.element.removeAttribute('hint');
                }

                this.bar.css('top', this.host.height());

                if (item == null) {
                    var ie7 = $.jqx.browser.msie && $.jqx.browser.version < 8;
                    this.input.val("");
                    this.input.attr('value', '');
                    if (!ie7) {
                        if (this.isMaterialized()) {
                            this.label[0].innerHTML = this.placeHolder;
                            this.input.removeAttr('placeholder');
                        }
                        else {
                            this.input.attr('placeholder', this.placeHolder);
                        }
                    }
                    this._updateInputSelection();
                    return;
                }

                this.selectedIndex = this.listBox.selectedIndex;
                var spanElement = $('<span></span>');

                if (item.label != undefined && item.label != null && item.label.toString().length > 0) {
                    $.jqx.utilities.html(spanElement, item.label);
                }
                else if (item.value != undefined && item.value != null && item.value.toString().length > 0) {
                    $.jqx.utilities.html(spanElement, item.value);
                }
                else if (item.title != undefined && item.title != null && item.title.toString().length > 0) {
                    $.jqx.utilities.html(spanElement, item.title);
                }
                else {
                    $.jqx.utilities.html(spanElement, this.emptyString);
                }
                var spanHeight = spanElement.outerHeight();
                if (this.checkboxes) {
                    var items = this.getCheckedItems();
                    var str = "";
                    for (var i = 0; i < items.length; i++) {
                        if (i == items.length - 1) {
                            str += items[i].label;
                        }
                        else {
                            str += items[i].label + ", ";
                        }
                    }
                    this.input.val(str);
                }
                else {
                    this.input.val(spanElement.text());
                }
                spanElement.remove();
                this._updateInputSelection();
                if (this.renderSelectedItem) {
                    var result = this.renderSelectedItem(this.listBox.selectedIndex, item);
                    if (result != undefined) {
                        this.input[0].value = result;
                    }
                }
                this.input.attr('value', this.input.val());
                if (this.listBox && this.listBox._activeElement) {
                    $.jqx.aria(this, "aria-activedescendant", this.listBox._activeElement.id);
                }
            },

            dataBind: function () {
                this.listBoxContainer.jqxListBox({ source: this.source });
                this.renderSelection('mouse');
                if (this.source == null) {
                    this.clearSelection();
                }
            },

            clear: function () {
                this.listBoxContainer.jqxListBox({ source: null });
                this.clearSelection();
            },

            // clears the selection.
            clearSelection: function (render) {
                this.selectedIndex = -1;
                this.listBox.clearSelection();
                this.input.val("");
                if (this.multiSelect) {
                    this.listBox.selectedValue = "";
                    this.selectedItems = new Array();
                    this._selectedItems = new Array();
                    this.doMultiSelect(false);
                }
            },

            // unselects an item at specific index.
            // @param Number
            unselectIndex: function (index, render) {
                if (isNaN(index))
                    return;

                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                this.listBox.unselectIndex(index, render);
                this.renderSelection('mouse');
                if (this.multiSelect) {
                    if (index >= 0) {
                        var multiItem = this.getItem(index);

                        var indx = this.selectedItems.indexOf(multiItem.value);
                        if (indx >= 0) {
                            if (multiItem.value === this.listBox.selectedValue) {
                                this.listBox.selectedValue = null;
                            }

                            this.selectedItems.splice(indx, 1);
                            this._selectedItems.splice(indx, 1);
                        }
                    }
                    this.doMultiSelect(false);
                }
            },

            // selects an item at specific index.
            // @param Number
            selectIndex: function (index, ensureVisible, render, forceSelect) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                this.listBox.selectIndex(index, ensureVisible, render, forceSelect);
                this.renderSelection('mouse');
                this.selectedIndex = index;
                if (this.multiSelect) {
                    this.doMultiSelect();
                }
            },

            selectItem: function (item) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                if (this.listBox != undefined) {
                    this.listBox.selectedIndex = -1;
                    this.listBox.selectItem(item);
                    this.selectedIndex = this.listBox.selectedIndex;
                    this.renderSelection('mouse');
                    if (this.multiSelect) {
                        this.doMultiSelect(false);
                    }
                }
            },

            unselectItem: function (item) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                if (this.listBox != undefined) {
                    this.listBox.unselectItem(item);
                    this.renderSelection('mouse');
                    if (this.multiSelect) {
                        var multiItem = this.getItemByValue(item);
                        if (multiItem) {
                            var index = this.selectedItems.indexOf(multiItem.value);
                            if (index >= 0) {
                                if (multiItem.value === this.listBox.selectedValue) {
                                    this.listBox.selectedValue = null;
                                }

                                this.selectedItems.splice(index, 1);
                                this._selectedItems.splice(index, 1);
                            }
                        }

                        this.doMultiSelect(false);
                    }
                }
            },

            checkItem: function (item) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                if (this.listBox != undefined) {
                    this.listBox.checkItem(item);
                }
            },

            uncheckItem: function (item) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                if (this.listBox != undefined) {
                    this.listBox.uncheckItem(item);
                }
            },

            indeterminateItem: function (item) {
                if (this.autoComplete) {
                    this._updateItemsVisibility("");
                }

                if (this.listBox != undefined) {
                    this.listBox.indeterminateItem(item);
                }
            },

            getSelectedValue: function () {
                return this.listBox.selectedValue;
            },

            // gets the selected index.
            getSelectedIndex: function () {
                if (!this.multiSelect) {
                    return this.listBox.selectedIndex;
                }
                else {
                    if (this.remoteAutoComplete && this.multiSelect && this._selectedItems.length > 0)
                        return this.getSelectedItems()[0].index;

                    if (this._selectedItems && this._selectedItems.length > 0) {
                        return this.getSelectedItems()[0].index;
                    }
                }
            },

            // gets the selected item.
            getSelectedItem: function () {
                if (!this.multiSelect) {
                    return this.getVisibleItem(this.listBox.selectedIndex);
                }
                else {
                    if (this.remoteAutoComplete && this.multiSelect && this._selectedItems.length > 0)
                        return this.getSelectedItems()[0];

                    if (this._selectedItems && this._selectedItems.length > 0) {
                        return this.getSelectedItems()[0];
                    }
                    return null;
                }
            },

            // gets the selected items when multiselect is enabled.
            getSelectedItems: function () {
                if (this.remoteAutoComplete && this.multiSelect)
                    return this._selectedItems;

                var array = new Array();
                var that = this;
                $.each(this.selectedItems, function () {
                    var item = that.getItemByValue(this);
                    if (item) {
                        array.push(item);
                    }
                    else {
                        var item = that._selectedItems[this];
                        if (item) {
                            array.push(item);
                        }
                    }
                });
                return array;
            },

            getCheckedItems: function () {
                return this.listBox.getCheckedItems();
            },

            checkIndex: function (index) {
                this.listBox.checkIndex(index);
            },

            uncheckIndex: function (index) {
                this.listBox.uncheckIndex(index);
            },

            indeterminateIndex: function (index) {
                this.listBox.indeterminateIndex(index);
            },
            checkAll: function () {
                this.listBox.checkAll();
                this.renderSelection("mouse");
            },

            uncheckAll: function () {
                this.listBox.uncheckAll();
                this.renderSelection("mouse");
            },

            insertAt: function (item, index) {
                if (item == null)
                    return false;

                return this.listBox.insertAt(item, index);
            },

            addItem: function (item) {
                return this.listBox.addItem(item);
            },

            removeAt: function (index) {
                var result = this.listBox.removeAt(index);
                this.renderSelection('mouse');
                return result;
            },

            removeItem: function (item) {
                var result = this.listBox.removeItem(item);
                this.renderSelection('mouse');
                return result;
            },

            updateItem: function (item, oldItem) {
                var result = this.listBox.updateItem(item, oldItem);
                this.renderSelection('mouse');
                return result;
            },

            updateAt: function (item, index) {
                var result = this.listBox.updateAt(item, index);
                this.renderSelection('mouse');
                return result;
            },

            ensureVisible: function (index) {
                return this.listBox.ensureVisible(index);
            },

            disableAt: function (index) {
                var item = this.getVisibleItem(index);
                if (item) {
                    this._disabledItems.push(item.value);
                }
                return this.listBox.disableAt(index);
            },

            enableAt: function (index) {
                var item = this.getVisibleItem(index);
                if (item) {
                    this._disabledItems.splice(this._disabledItems.indexOf(item.value), 1);
                }
                return this.listBox.enableAt(index);
            },

            disableItem: function (item) {
                var item = this.getVisibleItem(item);
                if (item) {
                    this._disabledItems.push(item.value);
                }
                return this.listBox.disableItem(item);
            },

            enableItem: function (item) {
                var item = this.getVisibleItem(item);
                if (item) {
                    this._disabledItems.splice(this._disabledItems.indexOf(item.value), 1);
                }
                return this.listBox.enableItem(item);
            },

            _findPos: function (obj) {
                while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
                    obj = obj['nextSibling'];
                }
                if (obj) {
                    var position = $(obj).coord(true);
                    return [position.left, position.top];
                }
            },

            testOffset: function (element, offset, inputHeight) {
                var dpWidth = element.outerWidth();
                var dpHeight = element.outerHeight();
                var viewWidth = $(window).width() + $(window).scrollLeft();
                var viewHeight = $(window).height() + $(window).scrollTop();

                if (offset.left + dpWidth > viewWidth) {
                    if (dpWidth > this.host.width()) {
                        var hostLeft = this.host.coord().left;
                        var hOffset = dpWidth - this.host.width();
                        offset.left = hostLeft - hOffset + 2;
                    }
                }
                if (offset.left < 0) {
                    offset.left = parseInt(this.host.coord().left) + 'px'
                }

                offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                    Math.abs(dpHeight + inputHeight + 23) : 0);

                return offset;
            },

            open: function () {
                if (!this.isOpened() && !this.opening) {
                    this.showListBox('api');
                }
            },

            close: function () {
                if (this.isOpened()) {
                    this.hideListBox('api');
                }
            },

            _getBodyOffset: function () {
                var top = 0;
                var left = 0;
                if ($('body').css('border-top-width') != '0px') {
                    top = parseInt($('body').css('border-top-width'));
                    if (isNaN(top)) top = 0;
                }
                if ($('body').css('border-left-width') != '0px') {
                    left = parseInt($('body').css('border-left-width'));
                    if (isNaN(left)) left = 0;
                }
                return { left: left, top: top };
            },

            // shows the listbox.
            showListBox: function (mode) {
                if (this.listBox.items && this.listBox.items.length == 0)
                    return;

                if (mode == "search" && !this.autoComplete && !this.remoteAutoComplete) {
                    if (this.autoDropDownHeight) {
                        this.container.height(this.listBoxContainer.height() + 25);
                    }
                }
                this.element.setAttribute('opened', true);

                if (this.autoComplete || this.multiSelect && !this.remoteAutoComplete) {
                    if (mode != 'search') {
                        this._updateItemsVisibility("");

                        if (this.multiSelect) {
                            var visibleItems = this.getVisibleItems();
                            for (var i = 0; i < visibleItems.length; i++) {
                                if (!visibleItems[i].disabled) {
                                    this.ensureVisible(i);
                                    break;
                                }
                            }
                        }
                    }
                }
                if (this.remoteAutoComplete) {
                    this.listBox.clearSelection();
                }

                if (mode != 'search') {
                    this._oldvalue = this.listBox.selectedValue;
                }

                $.jqx.aria(this, "aria-expanded", true);

                if (this.dropDownWidth == 'auto' && this.width != null && this.width.indexOf && this.width.indexOf('%') != -1) {
                    if (this.listBox.host.width() != this.host.width()) {
                        var width = this.element.offsetWidth;
                        this.listBoxContainer.jqxListBox({ width: width });
                        this.listBoxContainer[0].style.width = width + "px";
                        this.container.width(parseInt(width) + 25);
                    }
                }
                if (this.dropDownWidth == 'auto' && this.host.css('border-left-width') === "0px") {
                    var width = this.element.offsetWidth;
                    this.listBoxContainer.jqxListBox({ width: width + 1 });
                    this.container.width(parseInt(width) + 25);
                }


                var that = this;
                var listBox = this.listBoxContainer;
                var listBoxInstance = this.listBox;
                var scrollPosition = $(window).scrollTop();
                var scrollLeftPosition = $(window).scrollLeft();
                var top = parseInt(this._findPos(this.host[0])[1]) + parseInt(this.host.outerHeight()) - 1 + 'px';
                var left, leftPos = parseInt(Math.round(this.host.coord(true).left));
                left = leftPos + 'px';
                if (this.dropDownContainer === 'element') {
                    top = parseInt(this.host.outerHeight()) - 1 + 'px';
                    left = 0;
                }
                var isMobileBrowser = $.jqx.mobile.isSafariMobileBrowser() || $.jqx.mobile.isWindowsPhone();
                this.ishiding = false;

                var hasTransform = $.jqx.utilities.hasTransform(this.host);

                if (hasTransform || (isMobileBrowser != null && isMobileBrowser)) {
                    left = $.jqx.mobile.getLeftPos(this.element);
                    top = $.jqx.mobile.getTopPos(this.element) + parseInt(this.host.outerHeight());
                    if ($('body').css('border-top-width') != '0px') {
                        top = parseInt(top) - this._getBodyOffset().top + 'px';
                    }
                    if ($('body').css('border-left-width') != '0px') {
                        left = parseInt(left) - this._getBodyOffset().left + 'px';
                    }
                }

                this.host.addClass(this.toThemeProperty('jqx-combobox-state-selected'));
                if (this.dropDownVerticalAlignment == "top") {
                    this.dropdownlistArrowIcon.addClass(this.toThemeProperty('jqx-icon-arrow-up-selected'));
                }
                else {
                    this.dropdownlistArrowIcon.addClass(this.toThemeProperty('jqx-icon-arrow-down-selected'));
                }
                this.dropdownlistArrow.addClass(this.toThemeProperty('jqx-combobox-arrow-selected'));
                this.dropdownlistArrow.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this.host.addClass(this.toThemeProperty('jqx-combobox-state-focus'));
                this.host.addClass(this.toThemeProperty('jqx-fill-state-focus'));
                this.dropdownlistContent.addClass(this.toThemeProperty('jqx-combobox-content-focus'));

                this.container.css('left', left);
                this.container.css('top', top);
                listBoxInstance._arrange();

                var closeAfterSelection = true;

                var positionChanged = false;

                if (this.dropDownHorizontalAlignment == 'right' || this.rtl) {
                    var containerWidth = this.container.outerWidth();
                    var containerLeftOffset = Math.abs(containerWidth - this.host.width());

                    if (containerWidth > this.host.width()) {
                        this.container.css('left', 25 + parseInt(Math.round(leftPos)) - containerLeftOffset + "px");
                    }
                    else this.container.css('left', 25 + parseInt(Math.round(leftPos)) + containerLeftOffset + "px");
                }

                if (this.dropDownVerticalAlignment == "top") {
                    var dpHeight = listBox.height();
                    positionChanged = true;

                    listBox.css('top', 23);
                    listBox.addClass(this.toThemeProperty('jqx-popup-up'));
                    var inputHeight = parseInt(this.host.outerHeight());
                    var t = parseInt(top) - Math.abs(dpHeight + inputHeight + 23);

                    this.container.css('top', t);
                }

                if (this.enableBrowserBoundsDetection) {
                    var newOffset = this.testOffset(listBox, { left: parseInt(this.container.css('left')), top: parseInt(top) }, parseInt(this.host.outerHeight()));
                    if (parseInt(this.container.css('top')) != newOffset.top) {
                        positionChanged = true;
                        listBox.css('top', 23);
                        listBox.addClass(this.toThemeProperty('jqx-popup-up'));
                    }
                    else listBox.css('top', 0);

                    this.container.css('top', newOffset.top);
                    this.container.css('top', newOffset.top);
                    if (parseInt(this.container.css('left')) != newOffset.left) {
                        this.container.css('left', newOffset.left);
                    }
                }

                if (this.animationType == 'none' || this.animationType === 'transform') {
                    this.container.css('display', 'block');
                    $.data(document.body, "openedCombojqxListBoxParent", that);
                    $.data(document.body, "openedCombojqxListBox" + that.element.id, listBox);
                    listBox.css('margin-top', 0);
                    listBox.css('opacity', 1);
                }
                else {
                    this.container.css('display', 'block');
                    var height = listBox.outerHeight();
                    listBox.stop();
                    if (this.animationType == 'fade') {
                        listBox.css('margin-top', 0);
                        listBox.css('opacity', 0);
                        listBox.animate({ 'opacity': 1 }, this.openDelay, function () {
                            that.isanimating = false;
                            that.opening = false;
                            $.data(document.body, "openedCombojqxListBoxParent", that);
                            $.data(document.body, "openedCombojqxListBox" + that.element.id, listBox);
                        });
                    }
                    else {
                        listBox.css('opacity', 1);
                        if (positionChanged) {
                            listBox.css('margin-top', height);
                        }
                        else {
                            listBox.css('margin-top', -height);
                        }
                        this.isanimating = true;
                        this.opening = true;
                        listBox.animate({ 'margin-top': 0 }, this.openDelay, function () {
                            that.isanimating = false;
                            that.opening = false;
                            $.data(document.body, "openedCombojqxListBoxParent", that);
                            $.data(document.body, "openedCombojqxListBox" + that.element.id, listBox);
                        });
                    }
                }
                listBoxInstance._renderItems();
                if (!positionChanged) {
                    this.host.addClass(this.toThemeProperty('jqx-rc-b-expanded'));
                    listBox.addClass(this.toThemeProperty('jqx-rc-t-expanded'));
                    this.dropdownlistArrow.addClass(this.toThemeProperty('jqx-rc-b-expanded'));
                }
                else {
                    this.host.addClass(this.toThemeProperty('jqx-rc-t-expanded'));
                    listBox.addClass(this.toThemeProperty('jqx-rc-b-expanded'));
                    this.dropdownlistArrow.addClass(this.toThemeProperty('jqx-rc-t-expanded'));
                }
                listBox.addClass(this.toThemeProperty('jqx-fill-state-focus'));

                this._raiseEvent('0', listBoxInstance);
                listBox.addClass(this.toThemeProperty('jqx-popup-show'));
            },

            doMultiSelect: function (setFocus) {
                if (this.checkboxes) {
                    this.multiSelect = false;
                }

                var that = this;
                if (!this.multiSelect) {
                    var buttons = that.dropdownlistContent.find('.jqx-button');
                    var eventName = 'mousedown';
                    if (this.touch) {
                        eventName = $.jqx.mobile.getTouchEventName('touchstart');
                    }
                    this.removeHandler(buttons, eventName);
                    this.removeHandler(buttons.find('.jqx-icon-close'), eventName);
                    buttons.remove();
                    var items = this.listBox.items;
                    if (!items) return;
                    for (var i = 0; i < items.length; i++) {
                        items[i].disabled = false;
                    }
                    this.listBox._renderItems();

                    this.selectedItems = new Array();
                    this._selectedItems = new Array();
                    return;
                }

                if (this.validateSelection) {
                    var result = this.validateSelection(this.listBox.selectedValue);
                    if (!result) {
                        return;
                    }
                }

                var oldItems = this.selectedItems;
                if (this.listBox.selectedValue) {
                    if (this.selectedItems.indexOf(this.listBox.selectedValue) === -1) {
                        var item = this.getItemByValue(this.listBox.selectedValue);
                        if (item && item.visible) {
                            this.selectedItems.push(this.listBox.selectedValue);
                            this._selectedItems.push(item);
                            this._raiseEvent('2', { index: item.index, item: item });
                            this._raiseEvent('4', { index: item.index, item: item });
                        }
                    }
                    this.listBox.selectedIndex = -1;
                }

                var items = this.listBox.items;
                if (!items) return;
                for (var i = 0; i < items.length; i++) {
                    items[i].disabled = false;
                    if (this.selectedItems.indexOf(items[i].value) >= 0 || this._disabledItems.indexOf(this.value) >= 0) {
                        items[i].disabled = true;
                    }
                }
                this.listBox._renderItems();

                this.searchString = "";
                this.input.val("");
                var items = "";
                var eventName = 'mousedown';

                var buttons = that.dropdownlistContent.find('.jqx-button');
                if (this.touch) {
                    eventName = $.jqx.mobile.getTouchEventName('touchstart');
                }
                this.removeHandler(buttons, eventName);
                this.removeHandler(buttons.find('.jqx-icon-close'), eventName);
                buttons.remove();

                that.input.detach();
                if (this.selectedItems.length > 0) {
                    that.input.css('width', '25px');
                    if (this.isMaterialized() && that.hint) {
                        that.label[0].innerHTML = this.placeHolder;
                    }
                    else {
                        that.input.attr('placeholder', "");
                    }
                }
                else {
                    that.input.css('width', '100%');
                    if (that.isMaterialized() && that.hint) {
                        that.label[0].innerHTML = this.placeHolder;
                    }
                    else {
                        that.input.attr('placeholder', this.placeHolder);
                    }
                }

                if (that.isMaterialized()) {
                    if (that.hint) {
                        setTimeout(function () {
                            if (that.selectedItems.length === 0) {
                                that.element.removeAttribute('hint');
                                that.label[0].innerHTML = that.placeHolder;
                            }
                            else {
                                if (that.hint) {
                                    that.element.setAttribute('hint', true);
                                }
                            }
                        });
                    }
                }

                $.each(this.selectedItems, function (index) {
                    var item = that.getItemByValue(this);
                    if (!item || that.remoteAutoComplete) {
                        item = that._selectedItems[index];
                    }

                    var group = $('<div style="overflow: hidden; float: left;"></div>');
                    group.addClass(that.toThemeProperty('jqx-button'));
                    group.addClass(that.toThemeProperty('jqx-combobox-multi-item'));
                    group.addClass(that.toThemeProperty('jqx-fill-state-normal'));
                    group.addClass(that.toThemeProperty('jqx-rc-all'));
                    if (item) {
                        var text = item.label;
                        if (that.renderSelectedItem) {
                            var result = that.renderSelectedItem(index, item);
                            if (result) text = result;
                        }

                        if (group[0].innerHTML == '') {
                            group[0].innerHTML = '<a data-value="' + item.value + '" style="float: left;" href="#">' + text + '</a>';
                        }
                        if (that.rtl) {
                            group[0].innerHTML = '<a data-value="' + item.value + '" style="float: right;" href="#">' + text + '</a>';
                        }
                        var fl = !that.rtl ? 'right' : 'left';

                        if (that.showCloseButtons) {
                            var closebutton = '<div style="position: relative; overflow: hidden; float: ' + fl + '; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 100%; top: 50%; margin-left: -18px; margin-top: -7px; float: none; width: 16px; height: 16px;" class="' + that.toThemeProperty('jqx-icon-close') + '"></div></div>';
                            if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                                closebutton = '<div style="position: relative; overflow: hidden; float: left; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 100%; top: 50%; margin-left: -18px; margin-top: -7px; float: none; width: 16px; height: 16px;" class="' + that.toThemeProperty('jqx-icon-close') + '"></div></div>';
                            }
                            if (that.rtl) {
                                var closebutton = '<div style="position: relative; overflow: hidden; float: ' + fl + '; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 0px; top: 50%; margin-top: -7px; float: none; width: 16px; height: 16px;" class="' + that.toThemeProperty('jqx-icon-close') + '"></div></div>';
                                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                                    closebutton = '<div style="position: relative; overflow: hidden; float: left; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 0px; top: 50%; margin-top: -7px; float: none; width: 16px; height: 16px;" class="' + that.toThemeProperty('jqx-icon-close') + '"></div></div>';
                                }
                            }

                            group[0].innerHTML += closebutton;
                        }
                    }
                    else {
                        if (group[0].innerHTML == '') {
                            group[0].innerHTML = '<a href="#"></a>';
                        }
                    }
                    that.dropdownlistContent.append(group);
                });
                that.dropdownlistContent.append(that.input);
                that.input.val("");
                if (setFocus !== false) {
                    that.input.focus();
                    setTimeout(function () {
                        that.input.focus();
                    }, 10);
                }
                var buttons = that.dropdownlistContent.find('.jqx-button');

                if (this.touchMode === true) eventName = "mousedown";
                this.addHandler(buttons, eventName, function (event) {
                    if (event.target.className.indexOf('jqx-icon-close') >= 0)
                        return true;

                    if (that.disabled) {
                        return true;
                    }

                    var text = $(event.target).attr('data-value');
                    var item = that.getItemByValue(text);
                    if (item) {
                        that.listBox.selectedValue = null;
                        that.listBox.clearSelection();
                    }
                    that.listBox.scrollTo(0, 0);
                    that.open();
                    if (event.preventDefault) {
                        event.preventDefault();
                    }
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    return false;
                });
                this.addHandler(buttons.find('.jqx-icon-close'), eventName, function (event) {
                    if (that.disabled) {
                        return;
                    }

                    var text = $(event.target).parent().parent().find('a').attr('data-value');
                    var item = that.getItemByValue(text);
                    if (item || (that.remoteAutoComplete && !item && that.selectedItems.indexOf(text) >= 0)) {
                        that.listBox.selectedValue = null;
                        var index = that.selectedItems.indexOf(text);
                        var indx = item && item.index >= 0 ? item.index : index;
                        if (index >= 0) {
                            that.selectedItems.splice(index, 1);
                            var selectedItem = that._selectedItems[index];
                            if (!selectedItem) {
                                selectedItem = item;
                            }
                            that._selectedItems.splice(index, 1);

                            that._raiseEvent('3', { index: indx, type: 'mouse', item: selectedItem });
                            that._raiseEvent('4', { index: indx, type: 'mouse', item: selectedItem });
                            that.doMultiSelect();
                        }
                        else {
                            for (var i = 0; i < that.selectedItems.length; i++) {
                                var selectedItem = that.selectedItems[i];
                                if (selectedItem == text) {
                                    that.selectedItems.splice(i, 1);
                                    that._selectedItems.splice(i, 1);
                                    that._raiseEvent('3', { index: indx, type: 'mouse', item: item });
                                    that._raiseEvent('4', { index: indx, type: 'mouse', item: item });
                                    that.doMultiSelect();
                                    break;
                                }
                            }
                        }
                    }
                });

                if (this.isMaterialized()) {
                    this.host.height(this.dropdownlistContent.height());
                }

                this.bar.css('top', this.host.height());
                that.dropdownlistArrow.height(this.host.height());
                that._updateInputSelection();
            },

            // hides the listbox.
            hideListBox: function (mode) {
                var listBox = this.listBoxContainer;
                var listBoxInstance = this.listBox;
                var container = this.container;
                if (this.container[0].style.display == 'none')
                    return;

                this.element.setAttribute('opened', false);

                $.jqx.aria(this, "aria-expanded", false);

                if (mode == "keyboard" || mode == "mouse") {
                    this.listBox.searchString = "";
                }
                listBox.removeClass('jqx-popup-show');

                if (mode == "keyboard" || mode == "mouse" && this.multiSelect) {
                    this.doMultiSelect();
                }

                var that = this;
                $.data(document.body, "openedCombojqxListBox" + this.element.id, null);
                if (this.animationType == 'none') {
                    this.opening = false;
                    this.container.css('display', 'none');
                }
                else if (this.animationType === 'transform') {
                    setTimeout(function () {
                        container.css('display', 'none');
                    }, this.closeDelay);
                }
                else {
                    if (!this.ishiding) {
                        var height = listBox.outerHeight();
                        listBox.css('margin-top', 0);
                        listBox.stop();
                        this.opening = false;
                        this.isanimating = true;
                        var animationValue = -height;
                        if (parseInt(this.container.coord().top) < parseInt(this.host.coord().top)) {
                            animationValue = height;
                        }
                        if (this.animationType == 'fade') {
                            listBox.css({ 'opacity': 1 });
                            listBox.animate({ 'opacity': 0 }, this.closeDelay, function () {
                                that.isanimating = false;
                                container.css('display', 'none');
                                that.ishiding = false;
                            });
                        }
                        else {
                            listBox.animate({ 'margin-top': animationValue }, this.closeDelay, function () {
                                that.isanimating = false;
                                container.css('display', 'none'); that.ishiding = false;
                            });
                        }
                    }
                }

                this.ishiding = true;
                this.host.removeClass(this.toThemeProperty('jqx-combobox-state-selected'));
                this.dropdownlistArrowIcon.removeClass(this.toThemeProperty('jqx-icon-arrow-down-selected'));
                this.dropdownlistArrowIcon.removeClass(this.toThemeProperty('jqx-icon-arrow-up-selected'));
                this.dropdownlistArrow.removeClass(this.toThemeProperty('jqx-combobox-arrow-selected'));
                this.dropdownlistArrow.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                if (!this.focused) {
                    this.host.removeClass(this.toThemeProperty('jqx-combobox-state-focus'));
                    this.host.removeClass(this.toThemeProperty('jqx-fill-state-focus'));
                    this.dropdownlistContent.removeClass(this.toThemeProperty('jqx-combobox-content-focus'));
                }
                this.host.removeClass(this.toThemeProperty('jqx-rc-b-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-rc-t-expanded'));
                this.host.removeClass(this.toThemeProperty('jqx-rc-t-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-rc-b-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-fill-state-focus'));
                this.dropdownlistArrow.removeClass(this.toThemeProperty('jqx-rc-t-expanded'));
                this.dropdownlistArrow.removeClass(this.toThemeProperty('jqx-rc-b-expanded'));

                this._raiseEvent('1', listBoxInstance);
            },

            /* Close popup if clicked elsewhere. */
            closeOpenedListBox: function (event) {
                var that = event.data.that;
                var $target = $(event.target);
                var openedListBox = event.data.listbox;
                if (openedListBox == null)
                    return true;

                if ($(event.target).ischildof(that.host)) {
                    return;
                }

                var dropdownlistInstance = that;

                var isListBox = false;
                $.each($target.parents(), function () {
                    if (this.className != 'undefined') {
                        if (this.className.indexOf) {
                            if (this.className.indexOf('jqx-listbox') != -1) {
                                isListBox = true;
                                return false;
                            }
                            if (this.className.indexOf('jqx-combobox') != -1) {
                                if (that.element.id == this.id) {
                                    isListBox = true;
                                }
                                return false;
                            }
                        }
                    }
                });

                if (openedListBox != null && !isListBox) {
                    if (that.isOpened()) {
                        that.hideListBox('api');
                        that.input.blur();
                    }
                }

                return true;
            },

            loadFromSelect: function (id) {
                this.listBox.loadFromSelect(id);
                this.clearSelection();
            },

            refresh: function (initialRefresh) {
                this._setSize();
                this._arrange();
                if (this.listBox) {
                    this.renderSelection();
                }
            },

            resize: function () {
                this._setSize();
                this._arrange();
            },

            _arrange: function () {
                var width = parseInt(this.host.width());
                var height = parseInt(this.host.height());

                var arrowHeight = this.arrowSize;
                var arrowWidth = this.arrowSize;

                var rightOffset = 1;
                if (!this.showArrow) {
                    arrowWidth = 0;
                    arrowHeight = 0;
                    this.dropdownlistArrow.hide();
                    rightOffset = 0;
                    this.host.css('cursor', 'arrow');
                    if (this.theme === "fluent") {
                        rightOffset = 1;
                    }
                }
                else {
                    if (this.dropdownlistArrow[0].style.display === "none") {
                        this.dropdownlistArrow.show();
                    }
                }
                var contentWidth = width - arrowWidth - 1 * rightOffset;
                if (contentWidth > 0) {
                    this.dropdownlistContent[0].style.width = contentWidth + 'px';
                }
                if (this.rtl) {
                    this.dropdownlistContent[0].style.width = (-1 + contentWidth + 'px');
                }

                this.dropdownlistContent[0].style.height = height + 'px';
                this.dropdownlistContent[0].style.left = '0px';
                this.dropdownlistContent[0].style.top = '0px';
                this.dropdownlistArrow[0].style.width = arrowWidth + 'px';
                this.dropdownlistArrow[0].style.height = height + 'px';
                this.dropdownlistArrow[0].style.left = 1 + contentWidth + 'px';

                this.input[0].style.width = '100%';

                if (!this.multiSelect) {
                    this.input.height(height);
                }

                var inputHeight = this.input.height();
                if (inputHeight == 0) {
                    inputHeight = parseInt(this.input.css('font-size')) + 3;
                }

                if (this.input[0].className.indexOf('jqx-rc-all') == -1) {
                    this.input.addClass(this.toThemeProperty('jqx-rc-all'));
                }

                var top = parseInt(height) / 2 - parseInt(inputHeight) / 2;
                if (top > 0) {
                    //      this.input[0].style.marginTop = parseInt(top) + "px";
                }

                if (this.rtl) {
                    this.dropdownlistArrow.css('left', '0px');
                    this.dropdownlistContent.css('left', this.dropdownlistArrow.width());
                    if ($.jqx.browser.msie && $.jqx.browser.version <= 8) {
                        this.dropdownlistContent.css('left', 1 + this.dropdownlistArrow.width());
                    }
                }
                if (this.multiSelect) {
                    this.input.css('float', 'left');
                    this.input.width(25);
                    this.dropdownlistWrapper.parent().css('height', 'auto');
                    this.dropdownlistContent.css('height', 'auto');
                    this.dropdownlistWrapper.css('height', 'auto');
                    this.dropdownlistContent.css('position', 'relative');
                    this.dropdownlistContent.css('cursor', 'text');
                    this.host.css('height', 'auto');
                    this.host.css('min-height', this.height);
                    this.dropdownlistContent.css('min-height', this.height);
                    var height = parseInt(this.host.height());
                    this.dropdownlistArrow.height(height);
                    var initialHeight = parseInt(this.host.css('min-height'));
                    var top = parseInt(initialHeight) / 2 - parseInt(inputHeight) / 2;
                    if (top > 0) {
                        this.input.css('margin-top', top);
                    }


                    if (this.isMaterialized()) {
                        this.host.height(this.dropdownlistContent.height());
                    }

                    this.bar.css('top', this.host.height());
                    this.dropdownlistArrow.height(this.host.height());
                }
            },

            destroy: function () {
                if (this.source && this.source.unbindBindingUpdate) {
                    this.source.unbindBindingUpdate(this.element.id);
                    this.source.unbindBindingUpdate(this.listBoxContainer[0].id);
                    this.source.unbindDownloadComplete(this.element.id);
                    this.source.unbindDownloadComplete(this.listBoxContainer[0].id);
                }
                $.jqx.utilities.resize(this.host, null, true);
                this.removeHandler(this.listBoxContainer, 'select');
                this.removeHandler(this.listBoxContainer, 'unselect');
                this.removeHandler(this.listBoxContainer, 'change');
                this.removeHandler(this.listBoxContainer, 'bindingComplete');
                this.removeHandler(this.dropdownlistWrapper, 'selectstart');
                this.removeHandler(this.dropdownlistWrapper, 'mousedown');
                this.removeHandler(this.host, 'keydown');
                this.removeHandler(this.listBoxContainer, 'select');
                this.removeHandler(this.listBox.content, 'click');
                this.removeHandlers();
                this.removeHandler(this.input, 'keyup.textchange');

                this.listBoxContainer.jqxListBox('destroy');
                this.listBoxContainer.remove();
                this.host.removeClass();
                this.removeHandler($(document), 'mousedown.' + this.id, this.closeOpenedListBox);
                if (this.touch) {
                    this.removeHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.' + this.id);
                }
                this.cinput.remove();
                delete this.cinput;
                this.dropdownlistArrow.remove();
                delete this.dropdownlistArrow;
                this.dropdownlistArrowIcon.remove();
                delete this.dropdownlistArrowIcon;
                delete this.dropdownlistWrapper;
                delete this.listBoxContainer;
                delete this.input;
                delete this.dropdownlistContent;
                delete this.comboStructure;
                this.container.remove();
                delete this.listBox;
                delete this.container;
                var vars = $.data(this.element, "jqxComboBox");
                if (vars) {
                    delete vars.instance;
                }
                this.host.removeData();
                this.host.remove();
                delete this.host;
                delete this.set;
                delete this.get;
                delete this.call;
                delete this.element;
            },

            //[optimize]
            _raiseEvent: function (id, arg) {
                if (arg == undefined)
                    arg = { owner: null };

                var evt = this.events[id];
                var args = arg;
                args.owner = this;

                var event = new $.Event(evt);
                event.owner = this;
                if (id == 2 || id == 3 || id == 4 || id == 5 || id == 6 || id == 7 || id == 8 || id == 9) {
                    event.args = arg;
                }

                var result = this.host.trigger(event);
                return result;
            },

            propertiesChangedHandler: function (object, key, value) {
                if (value.width && value.height && Object.keys(value).length == 2) {
                    object._setSize();
                    if (key == 'width') {
                        if (object.dropDownWidth == 'auto') {
                            var width = object.host.width();
                            object.listBoxContainer.jqxListBox({ width: width });
                            object.container.width(parseInt(width) + 25);
                        }
                    }
                    object._arrange();
                    object.close();
                }
            },

            propertyChangedHandler: function (object, key, oldvalue, value) {
                if (object.isInitialized == undefined || object.isInitialized == false)
                    return;

                if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                    return;
                }

                if (key == "template") {
                    object.listBoxContainer.removeClass(object.toThemeProperty("jqx-" + oldvalue + "-item"));
                    object.listBoxContainer.addClass(object.toThemeProperty("jqx-" + object.template + "-item"));
                    object.dropDownListArrow.removeClass(object.toThemeProperty("jqx-" + oldvalue + ""));
                    object.dropDownListArrow.addClass(object.toThemeProperty("jqx-" + object.template + ""));

                    var that = this;

                    that.bar.removeClass(that.toThemeProperty("jqx-" + oldvalue));
                    that.label.removeClass(that.toThemeProperty("jqx-" + oldvalue));
                    that.bar.addClass(that.toThemeProperty("jqx-" + that.template));
                    that.label.addClass(that.toThemeProperty("jqx-" + that.template));

                }

                if (key == "dropDownVerticalAlignment") {
                    object.close();
                    object.dropdownlistArrowIcon.removeClass(object.toThemeProperty('jqx-icon-arrow-up'));
                    object.dropdownlistArrowIcon.removeClass(object.toThemeProperty('jqx-icon-arrow-down'));
                    if (object.dropDownVerticalAlignment == "top") {
                        object.dropdownlistArrowIcon.addClass(object.toThemeProperty('jqx-icon-arrow-up'));
                    }
                    else {
                        object.dropdownlistArrowIcon.addClass(object.toThemeProperty('jqx-icon-arrow-down'));
                    }
                    object.listBoxContainer.css('top', 0);
                    object.listBoxContainer.removeClass(this.toThemeProperty('jqx-popup-up'));
                }

                if (key == "autoItemsHeight") {
                    object.listBoxContainer.jqxListBox({ autoItemsHeight: value });
                }

                if (key == "itemHeight") {
                    object.listBoxContainer.jqxListBox({ itemHeight: value });
                }

                if (key == "renderSelectedItem") {
                    object.renderSelection('mouse');
                }

                if (key == "renderer") {
                    object.listBoxContainer.jqxListBox({ renderer: value });
                }

                if (key == "enableSelection") {
                    object.listBoxContainer.jqxListBox({ enableSelection: value });
                }
                if (key == "enableHover") {
                    object.listBoxContainer.jqxListBox({ enableHover: value });
                }

                if (key === "touchMode") {
                    object.listBoxContainer.jqxListBox({ touchMode: value });
                    object.touch = $.jqx.mobile.isTouchDevice();
                    if (object.touchMode === true) {
                        object.touch = true;
                    }
                    object._updateHandlers();
                }

                if (key == "multiSelect") {
                    if (value) {
                        object.doMultiSelect(false);
                    }
                    else {
                        var items = object.listBox.items;
                        var selectedIndex = -1;
                        for (var i = 0; i < items.length; i++) {
                            items[i].disabled = false;
                            if (object.selectedItems.indexOf(items[i].value) >= 0 || object._disabledItems.indexOf(object.value) >= 0) {
                                items[i].disabled = true;
                                selectedIndex = items[i].index;
                            }
                        }
                        object.doMultiSelect(false);
                        object.listBox._renderItems();
                        if (!items) return;
                        object.listBox.selectedIndex = selectedIndex;
                        object.renderSelection('mouse');
                        object.dropdownlistWrapper.parent().css('height', '100%');
                        object.dropdownlistContent.css('height', '100');
                        object.dropdownlistWrapper.css('height', '100');
                        object.dropdownlistContent.css('position', 'relative');
                        object.host.css('min-height', null);
                        object._setSize();
                        object._arrange();
                    }
                }

                if (key == "showArrow") {
                    object._arrange();
                    if (object.multiSelect) {
                        object.doMultiSelect(false);
                    }
                }

                if (key == "placeHolder") {
                    if (object.isMaterialized()) {
                        object.label.innerHTML = object.placeHolder;
                    }
                    else {
                        object.input.attr('placeholder', object.placeHolder);
                    }
                }

                if (key == 'popupZIndex') {
                    object.listBoxContainer.css({ zIndex: object.popupZIndex });
                }

                if (key == 'promptText') {
                    object.placeHolder = value;
                }

                if (key == 'autoOpen') {
                    object._updateHandlers();
                }

                if (key == 'renderer') {
                    object.listBox.renderer = object.renderer;
                }
                if (key == 'itemHeight') {
                    object.listBox.itemHeight = value;
                }

                if (key == 'source') {
                    object.input.val("");
                    object.listBoxContainer.jqxListBox({ source: object.source });
                    object.renderSelection('mouse');
                    if (object.source == null) {
                        object.clearSelection();
                    }
                    if (object.multiSelect) {
                        object.selectedItems = new Array();
                        object._selectedItems = new Array();
                        object.doMultiSelect(false);
                    }
                }
                if (key == "rtl") {
                    if (value) {
                        object.dropdownlistArrow.css('float', 'left');
                        object.dropdownlistContent.css('float', 'right');
                    }
                    else {
                        object.dropdownlistArrow.css('float', 'right');
                        object.dropdownlistContent.css('float', 'left');
                    }
                    object.listBoxContainer.jqxListBox({ rtl: object.rtl });
                }
                if (key == "displayMember" || key == "valueMember") {
                    object.listBoxContainer.jqxListBox({ displayMember: object.displayMember, valueMember: object.valueMember });
                    object.renderSelection('mouse');
                }

                if (key == "autoDropDownHeight") {
                    object.listBoxContainer.jqxListBox({ autoHeight: object.autoDropDownHeight });
                    if (object.autoDropDownHeight) {
                        object.container.height(object.listBoxContainer.height() + 25);
                    }
                    else {
                        object.listBoxContainer.jqxListBox({ height: object.dropDownHeight });
                        object.container.height(parseInt(object.dropDownHeight) + 25);
                    }

                    object.listBox._arrange();
                    object.listBox._updatescrollbars();
                }

                if (key == "dropDownHeight") {
                    if (!object.autoDropDownHeight) {
                        object.listBoxContainer.jqxListBox({ height: object.dropDownHeight });
                        object.container.height(parseInt(object.dropDownHeight) + 25);
                    }
                }

                if (key == "dropDownWidth" || key == "scrollBarSize") {
                    var width = object.width;
                    if (object.dropDownWidth != 'auto') {
                        width = object.dropDownWidth;
                    }

                    object.listBoxContainer.jqxListBox({ width: width, scrollBarSize: object.scrollBarSize });
                    object.container.width(parseInt(width) + 25);
                }

                if (key == 'autoComplete') {
                    object._resetautocomplete();
                }

                if (key == "checkboxes") {
                    object.listBoxContainer.jqxListBox({ checkboxes: object.checkboxes });
                    if (object.checkboxes) {
                        object.input.attr('readonly', true);
                        $.jqx.aria(object, "aria-readonly", true);
                    }
                    else {
                        $.jqx.aria(object, "aria-readonly", false);
                    }
                }

                if (key == 'theme' && value != null) {
                    object.listBoxContainer.jqxListBox({ theme: value });
                    object.listBoxContainer.addClass(object.toThemeProperty('jqx-popup'));
                    if ($.jqx.browser.msie) {
                        object.listBoxContainer.addClass(object.toThemeProperty('jqx-noshadow'));
                    }
                    $.jqx.utilities.setTheme(oldvalue, value, object.host);
                }

                if (key == 'rtl') {
                    object.render();
                    object.refresh();
                }

                if (key == 'width' || key == 'height') {
                    object._setSize();
                    if (key == 'width') {
                        if (object.dropDownWidth == 'auto') {
                            var width = object.host.width();
                            object.listBoxContainer.jqxListBox({ width: width });
                            object.container.width(parseInt(width) + 25);
                        }
                    }
                    object._arrange();
                    object.close();
                }

                if (key == 'selectedIndex') {
                    object.listBox.selectIndex(value);
                    object.renderSelection('mouse');
                }
            }
        });
    })(jqxBaseFramework);
})();



/***/ }),

/***/ 5459:
/***/ ((module, exports, __nested_webpack_require_484139__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* tslint:disable */
/* eslint-disable */
(function () {
	if (typeof document === 'undefined') {
		return;
	}

	var oldBrowser = document.all && !document.addEventListener;
	if (!oldBrowser) {
		(function (window, undefined) {
			var
				rootJQXLite,
				readyList,
				document = window.document,
				location = window.location,
				navigator = window.navigator,
				_JQXLite = window.JQXLite,
				_$ = window.$,

				// Save a reference to some core methods
				core_push = Array.prototype.push,
				core_slice = Array.prototype.slice,
				core_indexOf = Array.prototype.indexOf,
				core_toString = Object.prototype.toString,
				core_hasOwn = Object.prototype.hasOwnProperty,
				core_trim = String.prototype.trim,

				// Define a local copy of JQXLite
				JQXLite = function (selector, context) {
					// The JQXLite object is actually just the init constructor 'enhanced'
					return new JQXLite.fn.init(selector, context, rootJQXLite);
				},

				// Used for matching numbers
				core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

				// Used for detecting and trimming whitespace
				core_rnotwhite = /\S/,
				core_rspace = /\s+/,

				// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
				rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

				// A simple way to check for HTML strings
				// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
				rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

				// Match a standalone tag
				rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

				// JSON RegExp
				rvalidchars = /^[\],:{}\s]*$/,
				rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
				rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
				rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

				// Matches dashed string for camelizing
				rmsPrefix = /^-ms-/,
				rdashAlpha = /-([\da-z])/gi,

				// Used by JQXLite.camelCase as callback to replace()
				fcamelCase = function (all, letter) {
					return (letter + "").toUpperCase();
				},

				// The ready event handler and self cleanup method
				DOMContentLoaded = function () {
					if (document.addEventListener) {
						document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
						JQXLite.ready();
					} else if (document.readyState === "complete") {
						// we're here because readyState === "complete" in oldIE
						// which is good enough for us to call the dom ready!
						document.detachEvent("onreadystatechange", DOMContentLoaded);
						JQXLite.ready();
					}
				},

				// [[Class]] -> type pairs
				class2type = {};

			JQXLite.fn = JQXLite.prototype = {
				constructor: JQXLite,
				init: function (selector, context, rootJQXLite) {
					var match, elem, ret, doc;

					// Handle $(""), $(null), $(undefined), $(false)
					if (!selector) {
						return this;
					}

					// Handle $(DOMElement)
					if (selector.nodeType) {
						this.context = this[0] = selector;
						this.length = 1;
						return this;
					}

					// Handle HTML strings
					if (typeof selector === "string") {
						if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
							// Assume that strings that start and end with <> are HTML and skip the regex check
							match = [null, selector, null];

						} else {
							match = rquickExpr.exec(selector);
						}

						// Match html or make sure no context is specified for #id
						if (match && (match[1] || !context)) {

							// HANDLE: $(html) -> $(array)
							if (match[1]) {
								context = context instanceof JQXLite ? context[0] : context;
								doc = (context && context.nodeType ? context.ownerDocument || context : document);

								// scripts is true for back-compat
								selector = JQXLite.parseHTML(match[1], doc, true);
								if (rsingleTag.test(match[1]) && JQXLite.isPlainObject(context)) {
									this.attr.call(selector, context, true);
								}

								return JQXLite.merge(this, selector);

								// HANDLE: $(#id)
							} else {
								elem = document.getElementById(match[2]);

								// Check parentNode to catch when Blackberry 4.6 returns
								// nodes that are no longer in the document #6963
								if (elem && elem.parentNode) {
									// Handle the case where IE and Opera return items
									// by name instead of ID
									if (elem.id !== match[2]) {
										return rootJQXLite.find(selector);
									}

									// Otherwise, we inject the element directly into the JQXLite object
									this.length = 1;
									this[0] = elem;
								}

								this.context = document;
								this.selector = selector;
								return this;
							}

							// HANDLE: $(expr, $(...))
						} else if (!context || context.jqx) {
							return (context || rootJQXLite).find(selector);

							// HANDLE: $(expr, context)
							// (which is just equivalent to: $(context).find(expr)
						} else {
							return this.constructor(context).find(selector);
						}

						// HANDLE: $(function)
						// Shortcut for document ready
					} else if (JQXLite.isFunction(selector)) {
						return rootJQXLite.ready(selector);
					}

					if (selector.selector !== undefined) {
						this.selector = selector.selector;
						this.context = selector.context;
					}

					return JQXLite.makeArray(selector, this);
				},

				// Start with an empty selector
				selector: "",

				// The current version of JQXLite being used
				jqx: "4.5.0",

				// The default length of a JQXLite object is 0
				length: 0,

				// The number of elements contained in the matched element set
				size: function () {
					return this.length;
				},

				toArray: function () {
					return core_slice.call(this);
				},

				// Get the Nth element in the matched element set OR
				// Get the whole matched element set as a clean array
				get: function (num) {
					return num == null ?

						// Return a 'clean' array
						this.toArray() :

						// Return just the object
						(num < 0 ? this[this.length + num] : this[num]);
				},

				// Take an array of elements and push it onto the stack
				// (returning the new matched element set)
				pushStack: function (elems, name, selector) {

					// Build a new JQXLite matched element set
					var ret = JQXLite.merge(this.constructor(), elems);

					// Add the old object onto the stack (as a reference)
					ret.prevObject = this;

					ret.context = this.context;

					if (name === "find") {
						ret.selector = this.selector + (this.selector ? " " : "") + selector;
					} else if (name) {
						ret.selector = this.selector + "." + name + "(" + selector + ")";
					}

					// Return the newly-formed element set
					return ret;
				},

				// Execute a callback for every element in the matched set.
				// (You can seed the arguments with an array of args, but this is
				// only used internally.)
				each: function (callback, args) {
					return JQXLite.each(this, callback, args);
				},

				ready: function (fn) {
					// Add the callback
					JQXLite.ready.promise().done(fn);

					return this;
				},

				eq: function (i) {
					i = +i;
					return i === -1 ?
						this.slice(i) :
						this.slice(i, i + 1);
				},

				first: function () {
					return this.eq(0);
				},

				last: function () {
					return this.eq(-1);
				},

				slice: function () {
					return this.pushStack(core_slice.apply(this, arguments),
						"slice", core_slice.call(arguments).join(","));
				},

				map: function (callback) {
					return this.pushStack(JQXLite.map(this, function (elem, i) {
						return callback.call(elem, i, elem);
					}));
				},

				end: function () {
					return this.prevObject || this.constructor(null);
				},

				// For internal use only.
				// Behaves like an Array's method, not like a JQXLite method.
				push: core_push,
				sort: [].sort,
				splice: [].splice
			};

			// Give the init function the JQXLite prototype for later instantiation
			JQXLite.fn.init.prototype = JQXLite.fn;

			JQXLite.extend = JQXLite.fn.extend = function () {
				var options, name, src, copy, copyIsArray, clone,
					target = arguments[0] || {},
					i = 1,
					length = arguments.length,
					deep = false;

				// Handle a deep copy situation
				if (typeof target === "boolean") {
					deep = target;
					target = arguments[1] || {};
					// skip the boolean and the target
					i = 2;
				}

				// Handle case when target is a string or something (possible in deep copy)
				if (typeof target !== "object" && !JQXLite.isFunction(target)) {
					target = {};
				}

				// extend JQXLite itself if only one argument is passed
				if (length === i) {
					target = this;
					--i;
				}

				for (; i < length; i++) {
					// Only deal with non-null/undefined values
					if ((options = arguments[i]) != null) {
						// Extend the base object
						for (name in options) {
							src = target[name];
							copy = options[name];

							// Prevent never-ending loop
							if (target === copy) {
								continue;
							}

							// Recurse if we're merging plain objects or arrays
							if (deep && copy && (JQXLite.isPlainObject(copy) || (copyIsArray = JQXLite.isArray(copy)))) {
								if (copyIsArray) {
									copyIsArray = false;
									clone = src && JQXLite.isArray(src) ? src : [];

								} else {
									clone = src && JQXLite.isPlainObject(src) ? src : {};
								}

								// Never move original objects, clone them
								target[name] = JQXLite.extend(deep, clone, copy);

								// Don't bring in undefined values
							} else if (copy !== undefined) {
								target[name] = copy;
							}
						}
					}
				}

				// Return the modified object
				return target;
			};

			JQXLite.extend({
				noConflict: function (deep) {
					if (window.$ === JQXLite) {
						window.$ = _$;
					}

					if (deep && window.JQXLite === JQXLite) {
						window.JQXLite = _JQXLite;
					}

					return JQXLite;
				},

				// Is the DOM ready to be used? Set to true once it occurs.
				isReady: false,

				// A counter to track how many items to wait for before
				// the ready event fires. See #6781
				readyWait: 1,

				// Hold (or release) the ready event
				holdReady: function (hold) {
					if (hold) {
						JQXLite.readyWait++;
					} else {
						JQXLite.ready(true);
					}
				},

				// Handle when the DOM is ready
				ready: function (wait) {

					// Abort if there are pending holds or we're already ready
					if (wait === true ? --JQXLite.readyWait : JQXLite.isReady) {
						return;
					}

					// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
					if (!document.body) {
						return setTimeout(JQXLite.ready, 1);
					}

					// Remember that the DOM is ready
					JQXLite.isReady = true;

					// If a normal DOM Ready event fired, decrement, and wait if need be
					if (wait !== true && --JQXLite.readyWait > 0) {
						return;
					}

					// If there are functions bound, to execute
					readyList.resolveWith(document, [JQXLite]);

					// Trigger any bound ready events
					if (JQXLite.fn.trigger) {
						JQXLite(document).trigger("ready").off("ready");
					}
				},

				// See test/unit/core.js for details concerning isFunction.
				// Since version 1.3, DOM methods and functions like alert
				// aren't supported. They return false on IE (#2968).
				isFunction: function (obj) {
					return JQXLite.type(obj) === "function";
				},

				isArray: Array.isArray || function (obj) {
					return JQXLite.type(obj) === "array";
				},

				isWindow: function (obj) {
					return obj != null && obj == obj.window;
				},

				isNumeric: function (obj) {
					return !isNaN(parseFloat(obj)) && isFinite(obj);
				},

				type: function (obj) {
					return obj == null ?
						String(obj) :
						class2type[core_toString.call(obj)] || "object";
				},

				isPlainObject: function (obj) {
					// Must be an Object.
					// Because of IE, we also have to check the presence of the constructor property.
					// Make sure that DOM nodes and window objects don't pass through, as well
					if (!obj || JQXLite.type(obj) !== "object" || obj.nodeType || JQXLite.isWindow(obj)) {
						return false;
					}

					try {
						// Not own constructor property must be Object
						if (obj.constructor &&
							!core_hasOwn.call(obj, "constructor") &&
							!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
							return false;
						}
					} catch (e) {
						// IE8,9 Will throw exceptions on certain host objects #9897
						return false;
					}

					// Own properties are enumerated firstly, so to speed up,
					// if last one is own, then all properties are own.

					var key;
					for (key in obj) { }

					return key === undefined || core_hasOwn.call(obj, key);
				},

				isEmptyObject: function (obj) {
					var name;
					for (name in obj) {
						return false;
					}
					return true;
				},

				error: function (msg) {
					throw new Error(msg);
				},

				// data: string of html
				// context (optional): If specified, the fragment will be created in this context, defaults to document
				// scripts (optional): If true, will include scripts passed in the html string
				parseHTML: function (data, context, scripts) {
					var parsed;
					if (!data || typeof data !== "string") {
						return null;
					}
					if (typeof context === "boolean") {
						scripts = context;
						context = 0;
					}
					context = context || document;

					// Single tag
					if ((parsed = rsingleTag.exec(data))) {
						return [context.createElement(parsed[1])];
					}

					parsed = JQXLite.buildFragment([data], context, scripts ? null : []);
					return JQXLite.merge([],
						(parsed.cacheable ? JQXLite.clone(parsed.fragment) : parsed.fragment).childNodes);
				},

				parseJSON: function (data) {
					if (!data || typeof data !== "string") {
						return null;
					}

					// Make sure leading/trailing whitespace is removed (IE can't handle it)
					data = JQXLite.trim(data);

					// Attempt to parse using the native JSON parser first
					if (window.JSON && window.JSON.parse) {
						return window.JSON.parse(data);
					}

					// Make sure the incoming data is actual JSON
					// Logic borrowed from http://json.org/json2.js
					if (rvalidchars.test(data.replace(rvalidescape, "@")
						.replace(rvalidtokens, "]")
						.replace(rvalidbraces, ""))) {

						return (new Function("return " + data))();

					}
					JQXLite.error("Invalid JSON: " + data);
				},

				// Cross-browser xml parsing
				parseXML: function (data) {
					var xml, tmp;
					if (!data || typeof data !== "string") {
						return null;
					}
					try {
						if (window.DOMParser) { // Standard
							tmp = new DOMParser();
							xml = tmp.parseFromString(data, "text/xml");
						} else { // IE
							xml = new ActiveXObject("Microsoft.XMLDOM");
							xml.async = "false";
							xml.loadXML(data);
						}
					} catch (e) {
						xml = undefined;
					}
					if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
						JQXLite.error("Invalid XML: " + data);
					}
					return xml;
				},

				noop: function () { },

				// Evaluates a script in a global context
				// Workarounds based on findings by Jim Driscoll
				// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
				globalEval: function (data) {
					if (data && core_rnotwhite.test(data)) {
						// We use execScript on Internet Explorer
						// We use an anonymous function so that context is window
						// rather than JQXLite in Firefox
						(window.execScript || function (data) {
							window["eval"].call(window, data);
						})(data);
					}
				},

				// Convert dashed to camelCase; used by the css and data modules
				// Microsoft forgot to hump their vendor prefix (#9572)
				camelCase: function (string) {
					return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
				},

				nodeName: function (elem, name) {
					return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
				},

				// args is for internal usage only
				each: function (obj, callback, args) {
					var name,
						i = 0,
						length = obj.length,
						isObj = length === undefined || JQXLite.isFunction(obj);

					if (args) {
						if (isObj) {
							for (name in obj) {
								if (callback.apply(obj[name], args) === false) {
									break;
								}
							}
						} else {
							for (; i < length;) {
								if (callback.apply(obj[i++], args) === false) {
									break;
								}
							}
						}

						// A special, fast, case for the most common use of each
					} else {
						if (isObj) {
							for (name in obj) {
								if (callback.call(obj[name], name, obj[name]) === false) {
									break;
								}
							}
						} else {
							for (; i < length;) {
								if (callback.call(obj[i], i, obj[i++]) === false) {
									break;
								}
							}
						}
					}

					return obj;
				},

				// Use native String.trim function wherever possible
				trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
					function (text) {
						return text == null ?
							"" :
							core_trim.call(text);
					} :

					// Otherwise use our own trimming functionality
					function (text) {
						return text == null ?
							"" :
							(text + "").replace(rtrim, "");
					},

				// results is for internal usage only
				makeArray: function (arr, results) {
					var type,
						ret = results || [];

					if (arr != null) {
						// The window, strings (and functions) also have 'length'
						// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
						type = JQXLite.type(arr);

						if (arr.length == null || type === "string" || type === "function" || type === "regexp" || JQXLite.isWindow(arr)) {
							core_push.call(ret, arr);
						} else {
							JQXLite.merge(ret, arr);
						}
					}

					return ret;
				},

				inArray: function (elem, arr, i) {
					var len;

					if (arr) {
						if (core_indexOf) {
							return core_indexOf.call(arr, elem, i);
						}

						len = arr.length;
						i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

						for (; i < len; i++) {
							// Skip accessing in sparse arrays
							if (i in arr && arr[i] === elem) {
								return i;
							}
						}
					}

					return -1;
				},

				merge: function (first, second) {
					var l = second.length,
						i = first.length,
						j = 0;

					if (typeof l === "number") {
						for (; j < l; j++) {
							first[i++] = second[j];
						}

					} else {
						while (second[j] !== undefined) {
							first[i++] = second[j++];
						}
					}

					first.length = i;

					return first;
				},

				grep: function (elems, callback, inv) {
					var retVal,
						ret = [],
						i = 0,
						length = elems.length;
					inv = !!inv;

					// Go through the array, only saving the items
					// that pass the validator function
					for (; i < length; i++) {
						retVal = !!callback(elems[i], i);
						if (inv !== retVal) {
							ret.push(elems[i]);
						}
					}

					return ret;
				},

				// arg is for internal usage only
				map: function (elems, callback, arg) {
					var value, key,
						ret = [],
						i = 0,
						length = elems.length,
						// jqx objects are treated as arrays
						isArray = elems instanceof JQXLite || length !== undefined && typeof length === "number" && ((length > 0 && elems[0] && elems[length - 1]) || length === 0 || JQXLite.isArray(elems));

					// Go through the array, translating each of the items to their
					if (isArray) {
						for (; i < length; i++) {
							value = callback(elems[i], i, arg);

							if (value != null) {
								ret[ret.length] = value;
							}
						}

						// Go through every key on the object,
					} else {
						for (key in elems) {
							value = callback(elems[key], key, arg);

							if (value != null) {
								ret[ret.length] = value;
							}
						}
					}

					// Flatten any nested arrays
					return ret.concat.apply([], ret);
				},

				// A global GUID counter for objects
				guid: 1,

				// Bind a function to a context, optionally partially applying any
				// arguments.
				proxy: function (fn, context) {
					var tmp, args, proxy;

					if (typeof context === "string") {
						tmp = fn[context];
						context = fn;
						fn = tmp;
					}

					// Quick check to determine if target is callable, in the spec
					// this throws a TypeError, but we will just return undefined.
					if (!JQXLite.isFunction(fn)) {
						return undefined;
					}

					// Simulated bind
					args = core_slice.call(arguments, 2);
					proxy = function () {
						return fn.apply(context, args.concat(core_slice.call(arguments)));
					};

					// Set the guid of unique handler to the same of original handler, so it can be removed
					proxy.guid = fn.guid = fn.guid || JQXLite.guid++;

					return proxy;
				},

				// Multifunctional method to get and set values of a collection
				// The value/s can optionally be executed if it's a function
				access: function (elems, fn, key, value, chainable, emptyGet, pass) {
					var exec,
						bulk = key == null,
						i = 0,
						length = elems.length;

					// Sets many values
					if (key && typeof key === "object") {
						for (i in key) {
							JQXLite.access(elems, fn, i, key[i], 1, emptyGet, value);
						}
						chainable = 1;

						// Sets one value
					} else if (value !== undefined) {
						// Optionally, function values get executed if exec is true
						exec = pass === undefined && JQXLite.isFunction(value);

						if (bulk) {
							// Bulk operations only iterate when executing function values
							if (exec) {
								exec = fn;
								fn = function (elem, key, value) {
									return exec.call(JQXLite(elem), value);
								};

								// Otherwise they run against the entire set
							} else {
								fn.call(elems, value);
								fn = null;
							}
						}

						if (fn) {
							for (; i < length; i++) {
								fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
							}
						}

						chainable = 1;
					}

					return chainable ?
						elems :

						// Gets
						bulk ?
							fn.call(elems) :
							length ? fn(elems[0], key) : emptyGet;
				},

				now: function () {
					return (new Date()).getTime();
				}
			});

			JQXLite.ready.promise = function (obj) {
				if (!readyList) {

					readyList = JQXLite.Deferred();

					// Catch cases where $(document).ready() is called after the browser event has already occurred.
					// we once tried to use readyState "interactive" here, but it caused issues like the one
					// discovered by ChrisS here: http://bugs.jqx.com/ticket/12282#comment:15
					if (document.readyState === "complete") {
						// Handle it asynchronously to allow scripts the opportunity to delay ready
						setTimeout(JQXLite.ready, 1);

						// Standards-based browsers support DOMContentLoaded
					} else if (document.addEventListener) {
						// Use the handy event callback
						document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);

						// A fallback to window.onload, that will always work
						window.addEventListener("load", JQXLite.ready, false);

						// If IE event model is used
					} else {
						// Ensure firing before onload, maybe late but safe also for iframes
						document.attachEvent("onreadystatechange", DOMContentLoaded);

						// A fallback to window.onload, that will always work
						window.attachEvent("onload", JQXLite.ready);

						// If IE and not a frame
						// continually check to see if the document is ready
						var top = false;

						try {
							top = window.frameElement == null && document.documentElement;
						} catch (e) { }

						if (top && top.doScroll) {
							(function doScrollCheck() {
								if (!JQXLite.isReady) {

									try {
										// Use the trick by Diego Perini
										// http://javascript.nwbox.com/IEContentLoaded/
										top.doScroll("left");
									} catch (e) {
										return setTimeout(doScrollCheck, 50);
									}

									// and execute any waiting functions
									JQXLite.ready();
								}
							})();
						}
					}
				}
				return readyList.promise(obj);
			};

			// Populate the class2type map
			JQXLite.each("Boolean Number String Function Array Date RegExp Object".split(" "), function (i, name) {
				class2type["[object " + name + "]"] = name.toLowerCase();
			});

			// All JQXLite objects should point back to these
			rootJQXLite = JQXLite(document);
			// String to Object options format cache
			var optionsCache = {};

			// Convert String-formatted options into Object-formatted ones and store in cache
			function createOptions(options) {
				var object = optionsCache[options] = {};
				JQXLite.each(options.split(core_rspace), function (_, flag) {
					object[flag] = true;
				});
				return object;
			}

			/*
			 * Create a callback list using the following parameters:
			 *
			 *	options: an optional list of space-separated options that will change how
			 *			the callback list behaves or a more traditional option object
			 *
			 * By default a callback list will act like an event callback list and can be
			 * "fired" multiple times.
			 *
			 * Possible options:
			 *
			 *	once:			will ensure the callback list can only be fired once (like a Deferred)
			 *
			 *	memory:			will keep track of previous values and will call any callback added
			 *					after the list has been fired right away with the latest "memorized"
			 *					values (like a Deferred)
			 *
			 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
			 *
			 *	stopOnFalse:	interrupt callings when a callback returns false
			 *
			 */
			JQXLite.Callbacks = function (options) {

				// Convert options from String-formatted to Object-formatted if needed
				// (we check in cache first)
				options = typeof options === "string" ?
					(optionsCache[options] || createOptions(options)) :
					JQXLite.extend({}, options);

				var // Last fire value (for non-forgettable lists)
					memory,
					// Flag to know if list was already fired
					fired,
					// Flag to know if list is currently firing
					firing,
					// First callback to fire (used internally by add and fireWith)
					firingStart,
					// End of the loop when firing
					firingLength,
					// Index of currently firing callback (modified by remove if needed)
					firingIndex,
					// Actual callback list
					list = [],
					// Stack of fire calls for repeatable lists
					stack = !options.once && [],
					// Fire callbacks
					fire = function (data) {
						memory = options.memory && data;
						fired = true;
						firingIndex = firingStart || 0;
						firingStart = 0;
						firingLength = list.length;
						firing = true;
						for (; list && firingIndex < firingLength; firingIndex++) {
							if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
								memory = false; // To prevent further calls using add
								break;
							}
						}
						firing = false;
						if (list) {
							if (stack) {
								if (stack.length) {
									fire(stack.shift());
								}
							} else if (memory) {
								list = [];
							} else {
								self.disable();
							}
						}
					},
					// Actual Callbacks object
					self = {
						// Add a callback or a collection of callbacks to the list
						add: function () {
							if (list) {
								// First, we save the current length
								var start = list.length;
								(function add(args) {
									JQXLite.each(args, function (_, arg) {
										var type = JQXLite.type(arg);
										if (type === "function") {
											if (!options.unique || !self.has(arg)) {
												list.push(arg);
											}
										} else if (arg && arg.length && type !== "string") {
											// Inspect recursively
											add(arg);
										}
									});
								})(arguments);
								// Do we need to add the callbacks to the
								// current firing batch?
								if (firing) {
									firingLength = list.length;
									// With memory, if we're not firing then
									// we should call right away
								} else if (memory) {
									firingStart = start;
									fire(memory);
								}
							}
							return this;
						},
						// Remove a callback from the list
						remove: function () {
							if (list) {
								JQXLite.each(arguments, function (_, arg) {
									var index;
									while ((index = JQXLite.inArray(arg, list, index)) > -1) {
										list.splice(index, 1);
										// Handle firing indexes
										if (firing) {
											if (index <= firingLength) {
												firingLength--;
											}
											if (index <= firingIndex) {
												firingIndex--;
											}
										}
									}
								});
							}
							return this;
						},
						// Control if a given callback is in the list
						has: function (fn) {
							return JQXLite.inArray(fn, list) > -1;
						},
						// Remove all callbacks from the list
						empty: function () {
							list = [];
							return this;
						},
						// Have the list do nothing anymore
						disable: function () {
							list = stack = memory = undefined;
							return this;
						},
						// Is it disabled?
						disabled: function () {
							return !list;
						},
						// Lock the list in its current state
						lock: function () {
							stack = undefined;
							if (!memory) {
								self.disable();
							}
							return this;
						},
						// Is it locked?
						locked: function () {
							return !stack;
						},
						// Call all callbacks with the given context and arguments
						fireWith: function (context, args) {
							args = args || [];
							args = [context, args.slice ? args.slice() : args];
							if (list && (!fired || stack)) {
								if (firing) {
									stack.push(args);
								} else {
									fire(args);
								}
							}
							return this;
						},
						// Call all the callbacks with the given arguments
						fire: function () {
							self.fireWith(this, arguments);
							return this;
						},
						// To know if the callbacks have already been called at least once
						fired: function () {
							return !!fired;
						}
					};

				return self;
			};
			JQXLite.extend({

				Deferred: function (func) {
					var tuples = [
						// action, add listener, listener list, final state
						["resolve", "done", JQXLite.Callbacks("once memory"), "resolved"],
						["reject", "fail", JQXLite.Callbacks("once memory"), "rejected"],
						["notify", "progress", JQXLite.Callbacks("memory")]
					],
						state = "pending",
						promise = {
							state: function () {
								return state;
							},
							always: function () {
								deferred.done(arguments).fail(arguments);
								return this;
							},
							then: function ( /* fnDone, fnFail, fnProgress */) {
								var fns = arguments;
								return JQXLite.Deferred(function (newDefer) {
									JQXLite.each(tuples, function (i, tuple) {
										var action = tuple[0],
											fn = fns[i];
										// deferred[ done | fail | progress ] for forwarding actions to newDefer
										deferred[tuple[1]](JQXLite.isFunction(fn) ?
											function () {
												var returned = fn.apply(this, arguments);
												if (returned && JQXLite.isFunction(returned.promise)) {
													returned.promise()
														.done(newDefer.resolve)
														.fail(newDefer.reject)
														.progress(newDefer.notify);
												} else {
													newDefer[action + "With"](this === deferred ? newDefer : this, [returned]);
												}
											} :
											newDefer[action]
										);
									});
									fns = null;
								}).promise();
							},
							// Get a promise for this deferred
							// If obj is provided, the promise aspect is added to the object
							promise: function (obj) {
								return obj != null ? JQXLite.extend(obj, promise) : promise;
							}
						},
						deferred = {};

					// Keep pipe for back-compat
					promise.pipe = promise.then;

					// Add list-specific methods
					JQXLite.each(tuples, function (i, tuple) {
						var list = tuple[2],
							stateString = tuple[3];

						// promise[ done | fail | progress ] = list.add
						promise[tuple[1]] = list.add;

						// Handle state
						if (stateString) {
							list.add(function () {
								// state = [ resolved | rejected ]
								state = stateString;

								// [ reject_list | resolve_list ].disable; progress_list.lock
							}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
						}

						// deferred[ resolve | reject | notify ] = list.fire
						deferred[tuple[0]] = list.fire;
						deferred[tuple[0] + "With"] = list.fireWith;
					});

					// Make the deferred a promise
					promise.promise(deferred);

					// Call given func if any
					if (func) {
						func.call(deferred, deferred);
					}

					// All done!
					return deferred;
				},

				// Deferred helper
				when: function (subordinate /* , ..., subordinateN */) {
					var i = 0,
						resolveValues = core_slice.call(arguments),
						length = resolveValues.length,

						// the count of uncompleted subordinates
						remaining = length !== 1 || (subordinate && JQXLite.isFunction(subordinate.promise)) ? length : 0,

						// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
						deferred = remaining === 1 ? subordinate : JQXLite.Deferred(),

						// Update function for both resolve and progress values
						updateFunc = function (i, contexts, values) {
							return function (value) {
								contexts[i] = this;
								values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
								if (values === progressValues) {
									deferred.notifyWith(contexts, values);
								} else if (!(--remaining)) {
									deferred.resolveWith(contexts, values);
								}
							};
						},

						progressValues, progressContexts, resolveContexts;

					// add listeners to Deferred subordinates; treat others as resolved
					if (length > 1) {
						progressValues = new Array(length);
						progressContexts = new Array(length);
						resolveContexts = new Array(length);
						for (; i < length; i++) {
							if (resolveValues[i] && JQXLite.isFunction(resolveValues[i].promise)) {
								resolveValues[i].promise()
									.done(updateFunc(i, resolveContexts, resolveValues))
									.fail(deferred.reject)
									.progress(updateFunc(i, progressContexts, progressValues));
							} else {
								--remaining;
							}
						}
					}

					// if we're not waiting on anything, resolve the master
					if (!remaining) {
						deferred.resolveWith(resolveContexts, resolveValues);
					}

					return deferred.promise();
				}
			});
			JQXLite.support = (function () {

				var support,
					all,
					a,
					select,
					opt,
					input,
					fragment,
					eventName,
					i,
					isSupported,
					clickFn,
					div = document.createElement("div");

				// Setup
				div.setAttribute("className", "t");
				div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

				// Support tests won't run in some limited or non-browser environments
				all = div.getElementsByTagName("*");
				a = div.getElementsByTagName("a")[0];
				if (!all || !a || !all.length) {
					return {};
				}

				// First batch of tests
				select = document.createElement("select");
				opt = select.appendChild(document.createElement("option"));
				input = div.getElementsByTagName("input")[0];

				a.style.cssText = "top:1px;float:left;opacity:.5";
				support = {
					// IE strips leading whitespace when .innerHTML is used
					leadingWhitespace: (div.firstChild.nodeType === 3),

					// Make sure that tbody elements aren't automatically inserted
					// IE will insert them into empty tables
					tbody: !div.getElementsByTagName("tbody").length,

					// Make sure that link elements get serialized correctly by innerHTML
					// This requires a wrapper element in IE
					htmlSerialize: !!div.getElementsByTagName("link").length,

					// Get the style information from getAttribute
					// (IE uses .cssText instead)
					style: /top/.test(a.getAttribute("style")),

					// Make sure that URLs aren't manipulated
					// (IE normalizes it by default)
					hrefNormalized: (a.getAttribute("href") === "/a"),

					// Make sure that element opacity exists
					// (IE uses filter instead)
					// Use a regex to work around a WebKit issue. See #5145
					opacity: /^0.5/.test(a.style.opacity),

					// Verify style float existence
					// (IE uses styleFloat instead of cssFloat)
					cssFloat: !!a.style.cssFloat,

					// Make sure that if no value is specified for a checkbox
					// that it defaults to "on".
					// (WebKit defaults to "" instead)
					checkOn: (input.value === "on"),

					// Make sure that a selected-by-default option has a working selected property.
					// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
					optSelected: opt.selected,

					// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
					getSetAttribute: div.className !== "t",

					// Tests for enctype support on a form (#6743)
					enctype: !!document.createElement("form").enctype,

					// Makes sure cloning an html5 element does not cause problems
					// Where outerHTML is undefined, this still works
					html5Clone: document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>",

					// JQXLite.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
					boxModel: (document.compatMode === "CSS1Compat"),

					// Will be defined later
					submitBubbles: true,
					changeBubbles: true,
					focusinBubbles: false,
					deleteExpando: true,
					noCloneEvent: true,
					inlineBlockNeedsLayout: false,
					shrinkWrapBlocks: false,
					reliableMarginRight: true,
					boxSizingReliable: true,
					pixelPosition: false
				};

				// Make sure checked status is properly cloned
				input.checked = true;
				support.noCloneChecked = input.cloneNode(true).checked;

				// Make sure that the options inside disabled selects aren't marked as disabled
				// (WebKit marks them as disabled)
				select.disabled = true;
				support.optDisabled = !opt.disabled;

				// Test to see if it's possible to delete an expando from an element
				// Fails in Internet Explorer
				try {
					delete div.test;
				} catch (e) {
					support.deleteExpando = false;
				}

				if (!div.addEventListener && div.attachEvent && div.fireEvent) {
					div.attachEvent("onclick", clickFn = function () {
						// Cloning a node shouldn't copy over any
						// bound event handlers (IE does this)
						support.noCloneEvent = false;
					});
					div.cloneNode(true).fireEvent("onclick");
					div.detachEvent("onclick", clickFn);
				}

				// Check if a radio maintains its value
				// after being appended to the DOM
				input = document.createElement("input");
				input.value = "t";
				input.setAttribute("type", "radio");
				support.radioValue = input.value === "t";

				input.setAttribute("checked", "checked");

				// #11217 - WebKit loses check when the name is after the checked attribute
				input.setAttribute("name", "t");

				div.appendChild(input);
				fragment = document.createDocumentFragment();
				fragment.appendChild(div.lastChild);

				// WebKit doesn't clone checked state correctly in fragments
				support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

				// Check if a disconnected checkbox will retain its checked
				// value of true after appended to the DOM (IE6/7)
				support.appendChecked = input.checked;

				fragment.removeChild(input);
				fragment.appendChild(div);

				// Technique from Juriy Zaytsev
				// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
				// We only care about the case where non-standard event systems
				// are used, namely in IE. Short-circuiting here helps us to
				// avoid an eval call (in setAttribute) which can cause CSP
				// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
				if (div.attachEvent) {
					for (i in {
						submit: true,
						change: true,
						focusin: true
					}) {
						eventName = "on" + i;
						isSupported = (eventName in div);
						if (!isSupported) {
							div.setAttribute(eventName, "return;");
							isSupported = (typeof div[eventName] === "function");
						}
						support[i + "Bubbles"] = isSupported;
					}
				}

				// Run tests that need a body at doc ready
				JQXLite(function () {
					var container, div, tds, marginDiv,
						divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
						body = document.getElementsByTagName("body")[0];

					if (!body) {
						// Return for frameset docs that don't have a body
						return;
					}

					container = document.createElement("div");
					container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
					body.insertBefore(container, body.firstChild);

					// Construct the test element
					div = document.createElement("div");
					container.appendChild(div);

					// Check if table cells still have offsetWidth/Height when they are set
					// to display:none and there are still other visible table cells in a
					// table row; if so, offsetWidth/Height are not reliable for use when
					// determining if an element has been hidden directly using
					// display:none (it is still safe to use offsets if a parent element is
					// hidden; don safety goggles and see bug #4512 for more information).
					// (only IE 8 fails this test)
					div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
					tds = div.getElementsByTagName("td");
					tds[0].style.cssText = "padding:0;margin:0;border:0;display:none";
					isSupported = (tds[0].offsetHeight === 0);

					tds[0].style.display = "";
					tds[1].style.display = "none";

					// Check if empty table cells still have offsetWidth/Height
					// (IE <= 8 fail this test)
					support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0);

					// Check box-sizing and margin behavior
					div.innerHTML = "";
					div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
					support.boxSizing = (div.offsetWidth === 4);
					support.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== 1);

					// NOTE: To any future maintainer, we've window.getComputedStyle
					// because jsdom on node.js will break without it.
					if (window.getComputedStyle) {
						support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== "1%";
						support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: "4px" }).width === "4px";

						// Check if div with explicit width and no margin-right incorrectly
						// gets computed margin-right based on width of container. For more
						// info see bug #3333
						// Fails in WebKit before Feb 2011 nightlies
						// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
						marginDiv = document.createElement("div");
						marginDiv.style.cssText = div.style.cssText = divReset;
						marginDiv.style.marginRight = marginDiv.style.width = "0";
						div.style.width = "1px";
						div.appendChild(marginDiv);
						support.reliableMarginRight =
							!parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
					}

					if (typeof div.style.zoom !== "undefined") {
						// Check if natively block-level elements act like inline-block
						// elements when setting their display to 'inline' and giving
						// them layout
						// (IE < 8 does this)
						div.innerHTML = "";
						div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
						support.inlineBlockNeedsLayout = (div.offsetWidth === 3);

						// Check if elements with layout shrink-wrap their children
						// (IE 6 does this)
						div.style.display = "block";
						div.style.overflow = "visible";
						div.innerHTML = "<div></div>";
						div.firstChild.style.width = "5px";
						support.shrinkWrapBlocks = (div.offsetWidth !== 3);

						container.style.zoom = 1;
					}

					// Null elements to avoid leaks in IE
					body.removeChild(container);
					container = div = tds = marginDiv = null;
				});

				// Null elements to avoid leaks in IE
				fragment.removeChild(div);
				all = a = select = opt = input = fragment = div = null;

				return support;
			})();
			var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
				rmultiDash = /([A-Z])/g;

			JQXLite.extend({
				cache: {},

				deletedIds: [],

				// Remove at next major release (1.9/2.0)
				uuid: 0,

				// Unique for each copy of JQXLite on the page
				// Non-digits removed to match rinlinejQuery
				expando: "JQXLite" + (JQXLite.fn.jqx + Math.random()).replace(/\D/g, ""),

				// The following elements throw uncatchable exceptions if you
				// attempt to add expando properties to them.
				noData: {
					"embed": true,
					// Ban all objects except for Flash (which handle expandos)
					"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
					"applet": true
				},

				hasData: function (elem) {
					elem = elem.nodeType ? JQXLite.cache[elem[JQXLite.expando]] : elem[JQXLite.expando];
					return !!elem && !isEmptyDataObject(elem);
				},

				data: function (elem, name, data, pvt /* Internal Use Only */) {
					if (!JQXLite.acceptData(elem)) {
						return;
					}

					var thisCache, ret,
						internalKey = JQXLite.expando,
						getByName = typeof name === "string",

						// We have to handle DOM nodes and JS objects differently because IE6-7
						// can't GC object references properly across the DOM-JS boundary
						isNode = elem.nodeType,

						// Only DOM nodes need the global JQXLite cache; JS object data is
						// attached directly to the object so GC can occur automatically
						cache = isNode ? JQXLite.cache : elem,

						// Only defining an ID for JS objects if its cache already exists allows
						// the code to shortcut on the same path as a DOM node with no cache
						id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;

					// Avoid doing any more work than we need to when trying to get data on an
					// object that has no data at all
					if ((!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined) {
						return;
					}

					if (!id) {
						// Only DOM nodes need a new unique ID for each element since their data
						// ends up in the global cache
						if (isNode) {
							elem[internalKey] = id = JQXLite.deletedIds.pop() || JQXLite.guid++;
						} else {
							id = internalKey;
						}
					}

					if (!cache[id]) {
						cache[id] = {};

						// Avoids exposing JQXLite metadata on plain JS objects when the object
						// is serialized using JSON.stringify
						if (!isNode) {
							cache[id].toJSON = JQXLite.noop;
						}
					}

					// An object can be passed to JQXLite.data instead of a key/value pair; this gets
					// shallow copied over onto the existing cache
					if (typeof name === "object" || typeof name === "function") {
						if (pvt) {
							cache[id] = JQXLite.extend(cache[id], name);
						} else {
							cache[id].data = JQXLite.extend(cache[id].data, name);
						}
					}

					thisCache = cache[id];

					// JQXLite data() is stored in a separate object inside the object's internal data
					// cache in order to avoid key collisions between internal data and user-defined
					// data.
					if (!pvt) {
						if (!thisCache.data) {
							thisCache.data = {};
						}

						thisCache = thisCache.data;
					}

					if (data !== undefined) {
						thisCache[JQXLite.camelCase(name)] = data;
					}

					// Check for both converted-to-camel and non-converted data property names
					// If a data property was specified
					if (getByName) {

						// First Try to find as-is property data
						ret = thisCache[name];

						// Test for null|undefined property data
						if (ret == null) {

							// Try to find the camelCased property
							ret = thisCache[JQXLite.camelCase(name)];
						}
					} else {
						ret = thisCache;
					}

					return ret;
				},

				removeData: function (elem, name, pvt /* Internal Use Only */) {
					if (!JQXLite.acceptData(elem)) {
						return;
					}

					var thisCache, i, l,

						isNode = elem.nodeType,

						// See JQXLite.data for more information
						cache = isNode ? JQXLite.cache : elem,
						id = isNode ? elem[JQXLite.expando] : JQXLite.expando;

					// If there is already no cache entry for this object, there is no
					// purpose in continuing
					if (!cache[id]) {
						return;
					}

					if (name) {

						thisCache = pvt ? cache[id] : cache[id].data;

						if (thisCache) {

							// Support array or space separated string names for data keys
							if (!JQXLite.isArray(name)) {

								// try the string as a key before any manipulation
								if (name in thisCache) {
									name = [name];
								} else {

									// split the camel cased version by spaces unless a key with the spaces exists
									name = JQXLite.camelCase(name);
									if (name in thisCache) {
										name = [name];
									} else {
										name = name.split(" ");
									}
								}
							}

							for (i = 0, l = name.length; i < l; i++) {
								delete thisCache[name[i]];
							}

							// If there is no data left in the cache, we want to continue
							// and let the cache object itself get destroyed
							if (!(pvt ? isEmptyDataObject : JQXLite.isEmptyObject)(thisCache)) {
								return;
							}
						}
					}

					// See JQXLite.data for more information
					if (!pvt) {
						delete cache[id].data;

						// Don't destroy the parent cache unless the internal data object
						// had been the only thing left in it
						if (!isEmptyDataObject(cache[id])) {
							return;
						}
					}

					// Destroy the cache
					if (isNode) {
						JQXLite.cleanData([elem], true);

						// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
					} else if (JQXLite.support.deleteExpando || cache != cache.window) {
						delete cache[id];

						// When all else fails, null
					} else {
						cache[id] = null;
					}
				},

				// For internal use only.
				_data: function (elem, name, data) {
					return JQXLite.data(elem, name, data, true);
				},

				// A method for determining if a DOM node can handle the data expando
				acceptData: function (elem) {
					var noData = elem.nodeName && JQXLite.noData[elem.nodeName.toLowerCase()];

					// nodes accept data unless otherwise specified; rejection can be conditional
					return !noData || noData !== true && elem.getAttribute("classid") === noData;
				}
			});

			JQXLite.fn.extend({
				data: function (key, value) {
					var parts, part, attr, name, l,
						elem = this[0],
						i = 0,
						data = null;

					// Gets all values
					if (key === undefined) {
						if (this.length) {
							data = JQXLite.data(elem);

							if (elem.nodeType === 1 && !JQXLite._data(elem, "parsedAttrs")) {
								attr = elem.attributes;
								for (l = attr.length; i < l; i++) {
									name = attr[i].name;

									if (!name.indexOf("data-")) {
										name = JQXLite.camelCase(name.substring(5));

										dataAttr(elem, name, data[name]);
									}
								}
								JQXLite._data(elem, "parsedAttrs", true);
							}
						}

						return data;
					}

					// Sets multiple values
					if (typeof key === "object") {
						return this.each(function () {
							JQXLite.data(this, key);
						});
					}

					parts = key.split(".", 2);
					parts[1] = parts[1] ? "." + parts[1] : "";
					part = parts[1] + "!";

					return JQXLite.access(this, function (value) {

						if (value === undefined) {
							data = this.triggerHandler("getData" + part, [parts[0]]);

							// Try to fetch any internally stored data first
							if (data === undefined && elem) {
								data = JQXLite.data(elem, key);
								data = dataAttr(elem, key, data);
							}

							return data === undefined && parts[1] ?
								this.data(parts[0]) :
								data;
						}

						parts[1] = value;
						this.each(function () {
							var self = JQXLite(this);

							self.triggerHandler("setData" + part, parts);
							JQXLite.data(this, key, value);
							self.triggerHandler("changeData" + part, parts);
						});
					}, null, value, arguments.length > 1, null, false);
				},

				removeData: function (key) {
					return this.each(function () {
						JQXLite.removeData(this, key);
					});
				}
			});

			function dataAttr(elem, key, data) {
				// If nothing was found internally, try to fetch any
				// data from the HTML5 data-* attribute
				if (data === undefined && elem.nodeType === 1) {

					var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();

					data = elem.getAttribute(name);

					if (typeof data === "string") {
						try {
							data = data === "true" ? true :
								data === "false" ? false :
									data === "null" ? null :
										// Only convert to a number if it doesn't change the string
										+data + "" === data ? +data :
											rbrace.test(data) ? JQXLite.parseJSON(data) :
												data;
						} catch (e) { }

						// Make sure we set the data so it isn't changed later
						JQXLite.data(elem, key, data);

					} else {
						data = undefined;
					}
				}

				return data;
			}

			// checks a cache object for emptiness
			function isEmptyDataObject(obj) {
				var name;
				for (name in obj) {

					// if the public data object is empty, the private is still empty
					if (name === "data" && JQXLite.isEmptyObject(obj[name])) {
						continue;
					}
					if (name !== "toJSON") {
						return false;
					}
				}

				return true;
			}
			JQXLite.extend({
				queue: function (elem, type, data) {
					var queue;

					if (elem) {
						type = (type || "fx") + "queue";
						queue = JQXLite._data(elem, type);

						// Speed up dequeue by getting out quickly if this is just a lookup
						if (data) {
							if (!queue || JQXLite.isArray(data)) {
								queue = JQXLite._data(elem, type, JQXLite.makeArray(data));
							} else {
								queue.push(data);
							}
						}
						return queue || [];
					}
				},

				dequeue: function (elem, type) {
					type = type || "fx";

					var queue = JQXLite.queue(elem, type),
						startLength = queue.length,
						fn = queue.shift(),
						hooks = JQXLite._queueHooks(elem, type),
						next = function () {
							JQXLite.dequeue(elem, type);
						};

					// If the fx queue is dequeued, always remove the progress sentinel
					if (fn === "inprogress") {
						fn = queue.shift();
						startLength--;
					}

					if (fn) {

						// Add a progress sentinel to prevent the fx queue from being
						// automatically dequeued
						if (type === "fx") {
							queue.unshift("inprogress");
						}

						// clear up the last queue stop function
						delete hooks.stop;
						fn.call(elem, next, hooks);
					}

					if (!startLength && hooks) {
						hooks.empty.fire();
					}
				},

				// not intended for public consumption - generates a queueHooks object, or returns the current one
				_queueHooks: function (elem, type) {
					var key = type + "queueHooks";
					return JQXLite._data(elem, key) || JQXLite._data(elem, key, {
						empty: JQXLite.Callbacks("once memory").add(function () {
							JQXLite.removeData(elem, type + "queue", true);
							JQXLite.removeData(elem, key, true);
						})
					});
				}
			});

			JQXLite.fn.extend({
				queue: function (type, data) {
					var setter = 2;

					if (typeof type !== "string") {
						data = type;
						type = "fx";
						setter--;
					}

					if (arguments.length < setter) {
						return JQXLite.queue(this[0], type);
					}

					return data === undefined ?
						this :
						this.each(function () {
							var queue = JQXLite.queue(this, type, data);

							// ensure a hooks for this queue
							JQXLite._queueHooks(this, type);

							if (type === "fx" && queue[0] !== "inprogress") {
								JQXLite.dequeue(this, type);
							}
						});
				},
				dequeue: function (type) {
					return this.each(function () {
						JQXLite.dequeue(this, type);
					});
				},
				// Based off of the plugin by Clint Helfers, with permission.
				// http://blindsignals.com/index.php/2009/07/jqx-delay/
				delay: function (time, type) {
					time = JQXLite.fx ? JQXLite.fx.speeds[time] || time : time;
					type = type || "fx";

					return this.queue(type, function (next, hooks) {
						var timeout = setTimeout(next, time);
						hooks.stop = function () {
							clearTimeout(timeout);
						};
					});
				},
				clearQueue: function (type) {
					return this.queue(type || "fx", []);
				},
				// Get a promise resolved when queues of a certain type
				// are emptied (fx is the type by default)
				promise: function (type, obj) {
					var tmp,
						count = 1,
						defer = JQXLite.Deferred(),
						elements = this,
						i = this.length,
						resolve = function () {
							if (!(--count)) {
								defer.resolveWith(elements, [elements]);
							}
						};

					if (typeof type !== "string") {
						obj = type;
						type = undefined;
					}
					type = type || "fx";

					while (i--) {
						tmp = JQXLite._data(elements[i], type + "queueHooks");
						if (tmp && tmp.empty) {
							count++;
							tmp.empty.add(resolve);
						}
					}
					resolve();
					return defer.promise(obj);
				}
			});
			var nodeHook, boolHook, fixSpecified,
				rclass = /[\t\r\n]/g,
				rreturn = /\r/g,
				rtype = /^(?:button|input)$/i,
				rfocusable = /^(?:button|input|object|select|textarea)$/i,
				rclickable = /^a(?:rea|)$/i,
				rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
				getSetAttribute = JQXLite.support.getSetAttribute;

			JQXLite.fn.extend({
				attr: function (name, value) {
					return JQXLite.access(this, JQXLite.attr, name, value, arguments.length > 1);
				},

				removeAttr: function (name) {
					return this.each(function () {
						JQXLite.removeAttr(this, name);
					});
				},

				prop: function (name, value) {
					return JQXLite.access(this, JQXLite.prop, name, value, arguments.length > 1);
				},

				removeProp: function (name) {
					name = JQXLite.propFix[name] || name;
					return this.each(function () {
						// try/catch handles cases where IE balks (such as removing a property on window)
						try {
							this[name] = undefined;
							delete this[name];
						} catch (e) { }
					});
				},

				addClass: function (value) {
					var classNames, i, l, elem,
						setClass, c, cl;

					if (JQXLite.isFunction(value)) {
						return this.each(function (j) {
							JQXLite(this).addClass(value.call(this, j, this.className));
						});
					}

					if (value && typeof value === "string") {
						classNames = value.split(core_rspace);

						for (i = 0, l = this.length; i < l; i++) {
							elem = this[i];

							if (elem.nodeType === 1) {
								if (!elem.className && classNames.length === 1) {
									elem.className = value;

								} else {
									setClass = " " + elem.className + " ";

									for (c = 0, cl = classNames.length; c < cl; c++) {
										if (setClass.indexOf(" " + classNames[c] + " ") < 0) {
											setClass += classNames[c] + " ";
										}
									}
									elem.className = JQXLite.trim(setClass);
								}
							}
						}
					}

					return this;
				},

				removeClass: function (value) {
					var removes, className, elem, c, cl, i, l;

					if (JQXLite.isFunction(value)) {
						return this.each(function (j) {
							JQXLite(this).removeClass(value.call(this, j, this.className));
						});
					}
					if ((value && typeof value === "string") || value === undefined) {
						removes = (value || "").split(core_rspace);

						for (i = 0, l = this.length; i < l; i++) {
							elem = this[i];
							if (elem.nodeType === 1 && elem.className) {

								className = (" " + elem.className + " ").replace(rclass, " ");

								// loop over each item in the removal list
								for (c = 0, cl = removes.length; c < cl; c++) {
									// Remove until there is nothing to remove,
									while (className.indexOf(" " + removes[c] + " ") >= 0) {
										className = className.replace(" " + removes[c] + " ", " ");
									}
								}
								elem.className = value ? JQXLite.trim(className) : "";
							}
						}
					}

					return this;
				},

				toggleClass: function (value, stateVal) {
					var type = typeof value,
						isBool = typeof stateVal === "boolean";

					if (JQXLite.isFunction(value)) {
						return this.each(function (i) {
							JQXLite(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
						});
					}

					return this.each(function () {
						if (type === "string") {
							// toggle individual class names
							var className,
								i = 0,
								self = JQXLite(this),
								state = stateVal,
								classNames = value.split(core_rspace);

							while ((className = classNames[i++])) {
								// check each className given, space separated list
								state = isBool ? state : !self.hasClass(className);
								self[state ? "addClass" : "removeClass"](className);
							}

						} else if (type === "undefined" || type === "boolean") {
							if (this.className) {
								// store className if set
								JQXLite._data(this, "__className__", this.className);
							}

							// toggle whole className
							this.className = this.className || value === false ? "" : JQXLite._data(this, "__className__") || "";
						}
					});
				},

				hasClass: function (selector) {
					var className = " " + selector + " ",
						i = 0,
						l = this.length;
					for (; i < l; i++) {
						if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
							return true;
						}
					}

					return false;
				},

				val: function (value) {
					var hooks, ret, isFunction,
						elem = this[0];

					if (!arguments.length) {
						if (elem) {
							hooks = JQXLite.valHooks[elem.type] || JQXLite.valHooks[elem.nodeName.toLowerCase()];

							if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
								return ret;
							}

							ret = elem.value;

							return typeof ret === "string" ?
								// handle most common string cases
								ret.replace(rreturn, "") :
								// handle cases where value is null/undef or number
								ret == null ? "" : ret;
						}

						return;
					}

					isFunction = JQXLite.isFunction(value);

					return this.each(function (i) {
						var val,
							self = JQXLite(this);

						if (this.nodeType !== 1) {
							return;
						}

						if (isFunction) {
							val = value.call(this, i, self.val());
						} else {
							val = value;
						}

						// Treat null/undefined as ""; convert numbers to string
						if (val == null) {
							val = "";
						} else if (typeof val === "number") {
							val += "";
						} else if (JQXLite.isArray(val)) {
							val = JQXLite.map(val, function (value) {
								return value == null ? "" : value + "";
							});
						}

						hooks = JQXLite.valHooks[this.type] || JQXLite.valHooks[this.nodeName.toLowerCase()];

						// If set returns undefined, fall back to normal setting
						if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
							this.value = val;
						}
					});
				}
			});

			JQXLite.extend({
				valHooks: {
					option: {
						get: function (elem) {
							// attributes.value is undefined in Blackberry 4.7 but
							// uses .value. See #6932
							var val = elem.attributes.value;
							return !val || val.specified ? elem.value : elem.text;
						}
					},
					select: {
						get: function (elem) {
							var value, option,
								options = elem.options,
								index = elem.selectedIndex,
								one = elem.type === "select-one" || index < 0,
								values = one ? null : [],
								max = one ? index + 1 : options.length,
								i = index < 0 ?
									max :
									one ? index : 0;

							// Loop through all the selected options
							for (; i < max; i++) {
								option = options[i];

								// oldIE doesn't update selected after form reset (#2551)
								if ((option.selected || i === index) &&
									// Don't return options that are disabled or in a disabled optgroup
									(JQXLite.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
									(!option.parentNode.disabled || !JQXLite.nodeName(option.parentNode, "optgroup"))) {

									// Get the specific value for the option
									value = JQXLite(option).val();

									// We don't need an array for one selects
									if (one) {
										return value;
									}

									// Multi-Selects return an array
									values.push(value);
								}
							}

							return values;
						},

						set: function (elem, value) {
							var values = JQXLite.makeArray(value);

							JQXLite(elem).find("option").each(function () {
								this.selected = JQXLite.inArray(JQXLite(this).val(), values) >= 0;
							});

							if (!values.length) {
								elem.selectedIndex = -1;
							}
							return values;
						}
					}
				},

				// Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
				attrFn: {},

				attr: function (elem, name, value, pass) {
					var ret, hooks, notxml,
						nType = elem.nodeType;

					// don't get/set attributes on text, comment and attribute nodes
					if (!elem || nType === 3 || nType === 8 || nType === 2) {
						return;
					}

					if (pass && JQXLite.isFunction(JQXLite.fn[name])) {
						return JQXLite(elem)[name](value);
					}

					// Fallback to prop when attributes are not supported
					if (typeof elem.getAttribute === "undefined") {
						return JQXLite.prop(elem, name, value);
					}

					notxml = nType !== 1 || !JQXLite.isXMLDoc(elem);

					// All attributes are lowercase
					// Grab necessary hook if one is defined
					if (notxml) {
						name = name.toLowerCase();
						hooks = JQXLite.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook);
					}

					if (value !== undefined) {

						if (value === null) {
							JQXLite.removeAttr(elem, name);
							return;

						} else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
							return ret;

						} else {
							elem.setAttribute(name, value + "");
							return value;
						}

					} else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
						return ret;

					} else {

						ret = elem.getAttribute(name);

						// Non-existent attributes return null, we normalize to undefined
						return ret === null ?
							undefined :
							ret;
					}
				},

				removeAttr: function (elem, value) {
					var propName, attrNames, name, isBool,
						i = 0;

					if (value && elem.nodeType === 1) {

						attrNames = value.split(core_rspace);

						for (; i < attrNames.length; i++) {
							name = attrNames[i];

							if (name) {
								propName = JQXLite.propFix[name] || name;
								isBool = rboolean.test(name);

								// See #9699 for explanation of this approach (setting first, then removal)
								// Do not do this for boolean attributes (see #10870)
								if (!isBool) {
									JQXLite.attr(elem, name, "");
								}
								elem.removeAttribute(getSetAttribute ? name : propName);

								// Set corresponding property to false for boolean attributes
								if (isBool && propName in elem) {
									elem[propName] = false;
								}
							}
						}
					}
				},

				attrHooks: {
					type: {
						set: function (elem, value) {
							// We can't allow the type property to be changed (since it causes problems in IE)
							if (rtype.test(elem.nodeName) && elem.parentNode) {
								JQXLite.error("type property can't be changed");
							} else if (!JQXLite.support.radioValue && value === "radio" && JQXLite.nodeName(elem, "input")) {
								// Setting the type on a radio button after the value resets the value in IE6-9
								// Reset value to it's default in case type is set after value
								// This is for element creation
								var val = elem.value;
								elem.setAttribute("type", value);
								if (val) {
									elem.value = val;
								}
								return value;
							}
						}
					},
					// Use the value property for back compat
					// Use the nodeHook for button elements in IE6/7 (#1954)
					value: {
						get: function (elem, name) {
							if (nodeHook && JQXLite.nodeName(elem, "button")) {
								return nodeHook.get(elem, name);
							}
							return name in elem ?
								elem.value :
								null;
						},
						set: function (elem, value, name) {
							if (nodeHook && JQXLite.nodeName(elem, "button")) {
								return nodeHook.set(elem, value, name);
							}
							// Does not return so that setAttribute is also used
							elem.value = value;
						}
					}
				},

				propFix: {
					tabindex: "tabIndex",
					readonly: "readOnly",
					"for": "htmlFor",
					"class": "className",
					maxlength: "maxLength",
					cellspacing: "cellSpacing",
					cellpadding: "cellPadding",
					rowspan: "rowSpan",
					colspan: "colSpan",
					usemap: "useMap",
					frameborder: "frameBorder",
					contenteditable: "contentEditable"
				},

				prop: function (elem, name, value) {
					var ret, hooks, notxml,
						nType = elem.nodeType;

					// don't get/set properties on text, comment and attribute nodes
					if (!elem || nType === 3 || nType === 8 || nType === 2) {
						return;
					}

					notxml = nType !== 1 || !JQXLite.isXMLDoc(elem);

					if (notxml) {
						// Fix name and attach hooks
						name = JQXLite.propFix[name] || name;
						hooks = JQXLite.propHooks[name];
					}

					if (value !== undefined) {
						if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
							return ret;

						} else {
							return (elem[name] = value);
						}

					} else {
						if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
							return ret;

						} else {
							return elem[name];
						}
					}
				},

				propHooks: {
					tabIndex: {
						get: function (elem) {
							// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
							// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
							var attributeNode = elem.getAttributeNode("tabindex");

							return attributeNode && attributeNode.specified ?
								parseInt(attributeNode.value, 10) :
								rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
									0 :
									undefined;
						}
					}
				}
			});

			// Hook for boolean attributes
			boolHook = {
				get: function (elem, name) {
					// Align boolean attributes with corresponding properties
					// Fall back to attribute presence where some booleans are not supported
					var attrNode,
						property = JQXLite.prop(elem, name);
					return property === true || typeof property !== "boolean" && (attrNode = elem.getAttributeNode(name)) && attrNode.nodeValue !== false ?
						name.toLowerCase() :
						undefined;
				},
				set: function (elem, value, name) {
					var propName;
					if (value === false) {
						// Remove boolean attributes when set to false
						JQXLite.removeAttr(elem, name);
					} else {
						// value is true since we know at this point it's type boolean and not false
						// Set boolean attributes to the same name and set the DOM property
						propName = JQXLite.propFix[name] || name;
						if (propName in elem) {
							// Only set the IDL specifically if it already exists on the element
							elem[propName] = true;
						}

						elem.setAttribute(name, name.toLowerCase());
					}
					return name;
				}
			};

			// IE6/7 call enctype encoding
			if (!JQXLite.support.enctype) {
				JQXLite.propFix.enctype = "encoding";
			}

			var rformElems = /^(?:textarea|input|select)$/i,
				rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
				rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
				rkeyEvent = /^key/,
				rmouseEvent = /^(?:mouse|contextmenu)|click/,
				rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
				hoverHack = function (events) {
					return JQXLite.event.special.hover ? events : events.replace(rhoverHack, "mouseenter$1 mouseleave$1");
				};

			/*
			 * Helper functions for managing events -- not part of the public interface.
			 * Props to Dean Edwards' addEvent library for many of the ideas.
			 */
			JQXLite.event = {

				add: function (elem, types, handler, data, selector) {

					var elemData, eventHandle, events,
						t, tns, type, namespaces, handleObj,
						handleObjIn, handlers, special;

					// Don't attach events to noData or text/comment nodes (allow plain objects tho)
					if (elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = JQXLite._data(elem))) {
						return;
					}

					// Caller can pass in an object of custom data in lieu of the handler
					if (handler.handler) {
						handleObjIn = handler;
						handler = handleObjIn.handler;
						selector = handleObjIn.selector;
					}

					// Make sure that the handler has a unique ID, used to find/remove it later
					if (!handler.guid) {
						handler.guid = JQXLite.guid++;
					}

					// Init the element's event structure and main handler, if this is the first
					events = elemData.events;
					if (!events) {
						elemData.events = events = {};
					}
					eventHandle = elemData.handle;
					if (!eventHandle) {
						elemData.handle = eventHandle = function (e) {
							// Discard the second event of a JQXLite.event.trigger() and
							// when an event is called after a page has unloaded
							return typeof JQXLite !== "undefined" && (!e || JQXLite.event.triggered !== e.type) ?
								JQXLite.event.dispatch.apply(eventHandle.elem, arguments) :
								undefined;
						};
						// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
						eventHandle.elem = elem;
					}

					// Handle multiple events separated by a space
					// JQXLite(...).bind("mouseover mouseout", fn);
					types = JQXLite.trim(hoverHack(types)).split(" ");
					for (t = 0; t < types.length; t++) {

						tns = rtypenamespace.exec(types[t]) || [];
						type = tns[1];
						namespaces = (tns[2] || "").split(".").sort();

						// If event changes its type, use the special event handlers for the changed type
						special = JQXLite.event.special[type] || {};

						// If selector defined, determine special event api type, otherwise given type
						type = (selector ? special.delegateType : special.bindType) || type;

						// Update special based on newly reset type
						special = JQXLite.event.special[type] || {};

						// handleObj is passed to all event handlers
						handleObj = JQXLite.extend({
							type: type,
							origType: tns[1],
							data: data,
							handler: handler,
							guid: handler.guid,
							selector: selector,
							needsContext: selector && JQXLite.expr.match.needsContext.test(selector),
							namespace: namespaces.join(".")
						}, handleObjIn);

						// Init the event handler queue if we're the first
						handlers = events[type];
						if (!handlers) {
							handlers = events[type] = [];
							handlers.delegateCount = 0;

							// Only use addEventListener/attachEvent if the special events handler returns false
							if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
								// Bind the global event handler to the element
								if (elem.addEventListener) {
									if (data && data.passive !== undefined) {
										elem.addEventListener(type, eventHandle, data);
									}
									else {
										elem.addEventListener(type, eventHandle, false);
									}
								} else if (elem.attachEvent) {
									elem.attachEvent("on" + type, eventHandle);
								}
							}
						}

						if (special.add) {
							special.add.call(elem, handleObj);

							if (!handleObj.handler.guid) {
								handleObj.handler.guid = handler.guid;
							}
						}

						// Add to the element's handler list, delegates in front
						if (selector) {
							handlers.splice(handlers.delegateCount++, 0, handleObj);
						} else {
							handlers.push(handleObj);
						}

						// Keep track of which events have ever been used, for event optimization
						JQXLite.event.global[type] = true;
					}

					// Nullify elem to prevent memory leaks in IE
					elem = null;
				},

				global: {},

				// Detach an event or set of events from an element
				remove: function (elem, types, handler, selector, mappedTypes) {

					var t, tns, type, origType, namespaces, origCount,
						j, events, special, eventType, handleObj,
						elemData = JQXLite.hasData(elem) && JQXLite._data(elem);

					if (!elemData || !(events = elemData.events)) {
						return;
					}

					// Once for each type.namespace in types; type may be omitted
					types = JQXLite.trim(hoverHack(types || "")).split(" ");
					for (t = 0; t < types.length; t++) {
						tns = rtypenamespace.exec(types[t]) || [];
						type = origType = tns[1];
						namespaces = tns[2];

						// Unbind all events (on this namespace, if provided) for the element
						if (!type) {
							for (type in events) {
								JQXLite.event.remove(elem, type + types[t], handler, selector, true);
							}
							continue;
						}

						special = JQXLite.event.special[type] || {};
						type = (selector ? special.delegateType : special.bindType) || type;
						eventType = events[type] || [];
						origCount = eventType.length;
						namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

						// Remove matching events
						for (j = 0; j < eventType.length; j++) {
							handleObj = eventType[j];

							if ((mappedTypes || origType === handleObj.origType) &&
								(!handler || handler.guid === handleObj.guid) &&
								(!namespaces || namespaces.test(handleObj.namespace)) &&
								(!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
								eventType.splice(j--, 1);

								if (handleObj.selector) {
									eventType.delegateCount--;
								}
								if (special.remove) {
									special.remove.call(elem, handleObj);
								}
							}
						}

						// Remove generic event handler if we removed something and no more handlers exist
						// (avoids potential for endless recursion during removal of special event handlers)
						if (eventType.length === 0 && origCount !== eventType.length) {
							if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
								JQXLite.removeEvent(elem, type, elemData.handle);
							}

							delete events[type];
						}
					}

					// Remove the expando if it's no longer used
					if (JQXLite.isEmptyObject(events)) {
						delete elemData.handle;

						// removeData also checks for emptiness and clears the expando if empty
						// so use it instead of delete
						JQXLite.removeData(elem, "events", true);
					}
				},

				// Events that are safe to short-circuit if no handlers are attached.
				// Native DOM events should not be added, they may have inline handlers.
				customEvent: {
					"getData": true,
					"setData": true,
					"changeData": true
				},

				trigger: function (event, data, elem, onlyHandlers) {
					// Don't do events on text and comment nodes
					if (elem && (elem.nodeType === 3 || elem.nodeType === 8)) {
						return;
					}

					// Event object or event type
					var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
						type = event.type || event,
						namespaces = [];

					// focus/blur morphs to focusin/out; ensure we're not firing them right now
					if (rfocusMorph.test(type + JQXLite.event.triggered)) {
						return;
					}

					if (type.indexOf("!") >= 0) {
						// Exclusive events trigger only for the exact event (no namespaces)
						type = type.slice(0, -1);
						exclusive = true;
					}

					if (type.indexOf(".") >= 0) {
						// Namespaced trigger; create a regexp to match event type in handle()
						namespaces = type.split(".");
						type = namespaces.shift();
						namespaces.sort();
					}

					if ((!elem || JQXLite.event.customEvent[type]) && !JQXLite.event.global[type]) {
						// No JQXLite handlers for this event type, and it can't have inline handlers
						return;
					}

					// Caller can pass in an Event, Object, or just an event type string
					event = typeof event === "object" ?
						// JQXLite.Event object
						event[JQXLite.expando] ? event :
							// Object literal
							new JQXLite.Event(type, event) :
						// Just the event type (string)
						new JQXLite.Event(type);

					event.type = type;
					event.isTrigger = true;
					event.exclusive = exclusive;
					event.namespace = namespaces.join(".");
					event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
					ontype = type.indexOf(":") < 0 ? "on" + type : "";

					// Handle a global trigger
					if (!elem) {

						// TODO: Stop taunting the data cache; remove global events and always attach to document
						cache = JQXLite.cache;
						for (i in cache) {
							if (cache[i].events && cache[i].events[type]) {
								JQXLite.event.trigger(event, data, cache[i].handle.elem, true);
							}
						}
						return;
					}

					// Clean up the event in case it is being reused
					event.result = undefined;
					if (!event.target) {
						event.target = elem;
					}

					// Clone any incoming data and prepend the event, creating the handler arg list
					data = data != null ? JQXLite.makeArray(data) : [];
					data.unshift(event);

					// Allow special events to draw outside the lines
					special = JQXLite.event.special[type] || {};
					if (special.trigger && special.trigger.apply(elem, data) === false) {
						return;
					}

					// Determine event propagation path in advance, per W3C events spec (#9951)
					// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
					eventPath = [[elem, special.bindType || type]];
					if (!onlyHandlers && !special.noBubble && !JQXLite.isWindow(elem)) {

						bubbleType = special.delegateType || type;
						cur = rfocusMorph.test(bubbleType + type) ? elem : elem.parentNode;
						for (old = elem; cur; cur = cur.parentNode) {
							eventPath.push([cur, bubbleType]);
							old = cur;
						}

						// Only add window if we got to document (e.g., not plain obj or detached DOM)
						if (old === (elem.ownerDocument || document)) {
							eventPath.push([old.defaultView || old.parentWindow || window, bubbleType]);
						}
					}

					// Fire handlers on the event path
					for (i = 0; i < eventPath.length && !event.isPropagationStopped(); i++) {

						cur = eventPath[i][0];
						event.type = eventPath[i][1];

						handle = (JQXLite._data(cur, "events") || {})[event.type] && JQXLite._data(cur, "handle");
						if (handle) {
							handle.apply(cur, data);
						}
						// Note that this is a bare JS function and not a JQXLite handler
						handle = ontype && cur[ontype];
						if (handle && JQXLite.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
							event.preventDefault();
						}
					}
					event.type = type;

					// If nobody prevented the default action, do it now
					if (!onlyHandlers && !event.isDefaultPrevented()) {

						if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) &&
							!(type === "click" && JQXLite.nodeName(elem, "a")) && JQXLite.acceptData(elem)) {

							// Call a native DOM method on the target with the same name name as the event.
							// Can't use an .isFunction() check here because IE6/7 fails that test.
							// Don't do default actions on window, that's where global variables be (#6170)
							// IE<9 dies on focus/blur to hidden element (#1486)
							if (ontype && elem[type] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !JQXLite.isWindow(elem)) {

								// Don't re-trigger an onFOO event when we call its FOO() method
								old = elem[ontype];

								if (old) {
									elem[ontype] = null;
								}

								// Prevent re-triggering of the same event, since we already bubbled it above
								JQXLite.event.triggered = type;
								elem[type]();
								JQXLite.event.triggered = undefined;

								if (old) {
									elem[ontype] = old;
								}
							}
						}
					}

					return event.result;
				},

				dispatch: function (event) {

					// Make a writable JQXLite.Event from the native event object
					event = JQXLite.event.fix(event || window.event);

					var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
						handlers = ((JQXLite._data(this, "events") || {})[event.type] || []),
						delegateCount = handlers.delegateCount,
						args = core_slice.call(arguments),
						run_all = !event.exclusive && !event.namespace,
						special = JQXLite.event.special[event.type] || {},
						handlerQueue = [];

					// Use the fix-ed JQXLite.Event rather than the (read-only) native event
					args[0] = event;
					event.delegateTarget = this;

					// Call the preDispatch hook for the mapped type, and let it bail if desired
					if (special.preDispatch && special.preDispatch.call(this, event) === false) {
						return;
					}

					// Determine handlers that should run if there are delegated events
					// Avoid non-left-click bubbling in Firefox (#3861)
					if (delegateCount && !(event.button && event.type === "click")) {

						for (cur = event.target; cur != this; cur = cur.parentNode || this) {

							// Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
							if (cur.disabled !== true || event.type !== "click") {
								selMatch = {};
								matches = [];
								for (i = 0; i < delegateCount; i++) {
									handleObj = handlers[i];
									sel = handleObj.selector;

									if (selMatch[sel] === undefined) {
										selMatch[sel] = handleObj.needsContext ?
											JQXLite(sel, this).index(cur) >= 0 :
											JQXLite.find(sel, this, null, [cur]).length;
									}
									if (selMatch[sel]) {
										matches.push(handleObj);
									}
								}
								if (matches.length) {
									handlerQueue.push({ elem: cur, matches: matches });
								}
							}
						}
					}

					// Add the remaining (directly-bound) handlers
					if (handlers.length > delegateCount) {
						handlerQueue.push({ elem: this, matches: handlers.slice(delegateCount) });
					}

					// Run delegates first; they may want to stop propagation beneath us
					for (i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++) {
						matched = handlerQueue[i];
						event.currentTarget = matched.elem;

						for (j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++) {
							handleObj = matched.matches[j];

							// Triggered event must either 1) be non-exclusive and have no namespace, or
							// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
							if (run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test(handleObj.namespace)) {

								event.data = handleObj.data;
								event.handleObj = handleObj;

								ret = ((JQXLite.event.special[handleObj.origType] || {}).handle || handleObj.handler)
									.apply(matched.elem, args);

								if (ret !== undefined) {
									event.result = ret;
									if (ret === false) {
										event.preventDefault();
										event.stopPropagation();
									}
								}
							}
						}
					}

					// Call the postDispatch hook for the mapped type
					if (special.postDispatch) {
						special.postDispatch.call(this, event);
					}

					return event.result;
				},

				// Includes some event props shared by KeyEvent and MouseEvent
				// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
				props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

				fixHooks: {},

				keyHooks: {
					props: "char charCode key keyCode".split(" "),
					filter: function (event, original) {

						// Add which for key events
						if (event.which == null) {
							event.which = original.charCode != null ? original.charCode : original.keyCode;
						}

						return event;
					}
				},

				mouseHooks: {
					props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
					filter: function (event, original) {
						var eventDoc, doc, body,
							button = original.button,
							fromElement = original.fromElement;

						// Calculate pageX/Y if missing and clientX/Y available
						if (event.pageX == null && original.clientX != null) {
							eventDoc = event.target.ownerDocument || document;
							doc = eventDoc.documentElement;
							body = eventDoc.body;

							event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
							event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
						}

						// Add relatedTarget, if necessary
						if (!event.relatedTarget && fromElement) {
							event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
						}

						// Add which for click: 1 === left; 2 === middle; 3 === right
						// Note: button is not normalized, so don't use it
						if (!event.which && button !== undefined) {
							event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
						}

						return event;
					}
				},

				fix: function (event) {
					if (event[JQXLite.expando]) {
						return event;
					}

					// Create a writable copy of the event object and normalize some properties
					var i, prop,
						originalEvent = event,
						fixHook = JQXLite.event.fixHooks[event.type] || {},
						copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

					event = JQXLite.Event(originalEvent);

					for (i = copy.length; i;) {
						prop = copy[--i];
						event[prop] = originalEvent[prop];
					}

					// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
					if (!event.target) {
						event.target = originalEvent.srcElement || document;
					}

					// Target should not be a text node (#504, Safari)
					if (event.target.nodeType === 3) {
						event.target = event.target.parentNode;
					}

					// For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
					event.metaKey = !!event.metaKey;

					return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
				},

				special: {
					load: {
						// Prevent triggered image.load events from bubbling to window.load
						noBubble: true
					},

					focus: {
						delegateType: "focusin"
					},
					blur: {
						delegateType: "focusout"
					},

					beforeunload: {
						setup: function (data, namespaces, eventHandle) {
							// We only want to do this special case on windows
							if (JQXLite.isWindow(this)) {
								this.onbeforeunload = eventHandle;
							}
						},

						teardown: function (namespaces, eventHandle) {
							if (this.onbeforeunload === eventHandle) {
								this.onbeforeunload = null;
							}
						}
					}
				},

				simulate: function (type, elem, event, bubble) {
					// Piggyback on a donor event to simulate a different one.
					// Fake originalEvent to avoid donor's stopPropagation, but if the
					// simulated event prevents default then we do the same on the donor.
					var e = JQXLite.extend(
						new JQXLite.Event(),
						event,
						{
							type: type,
							isSimulated: true,
							originalEvent: {}
						}
					);
					if (bubble) {
						JQXLite.event.trigger(e, null, elem);
					} else {
						JQXLite.event.dispatch.call(elem, e);
					}
					if (e.isDefaultPrevented()) {
						event.preventDefault();
					}
				}
			};

			// Some plugins are using, but it's undocumented/deprecated and will be removed.
			// The 1.7 special event interface should provide all the hooks needed now.
			JQXLite.event.handle = JQXLite.event.dispatch;

			JQXLite.removeEvent = document.removeEventListener ?
				function (elem, type, handle) {
					if (elem.removeEventListener) {
						elem.removeEventListener(type, handle, false);
					}
				} :
				function (elem, type, handle) {
					var name = "on" + type;

					if (elem.detachEvent) {

						// #8545, #7054, preventing memory leaks for custom events in IE6-8
						// detachEvent needed property on element, by name of that event, to properly expose it to GC
						if (typeof elem[name] === "undefined") {
							elem[name] = null;
						}

						elem.detachEvent(name, handle);
					}
				};

			JQXLite.Event = function (src, props) {
				// Allow instantiation without the 'new' keyword
				if (!(this instanceof JQXLite.Event)) {
					return new JQXLite.Event(src, props);
				}

				// Event object
				if (src && src.type) {
					this.originalEvent = src;
					this.type = src.type;

					// Events bubbling up the document may have been marked as prevented
					// by a handler lower down the tree; reflect the correct value.
					this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
						src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

					// Event type
				} else {
					this.type = src;
				}

				// Put explicitly provided properties onto the event object
				if (props) {
					JQXLite.extend(this, props);
				}

				// Create a timestamp if incoming event doesn't have one
				this.timeStamp = src && src.timeStamp || JQXLite.now();

				// Mark it as fixed
				this[JQXLite.expando] = true;
			};

			function returnFalse() {
				return false;
			}
			function returnTrue() {
				return true;
			}

			// JQXLite.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
			// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
			JQXLite.Event.prototype = {
				preventDefault: function () {
					this.isDefaultPrevented = returnTrue;

					var e = this.originalEvent;
					if (!e) {
						return;
					}

					// if preventDefault exists run it on the original event
					if (e.preventDefault) {
						e.preventDefault();

						// otherwise set the returnValue property of the original event to false (IE)
					} else {
						e.returnValue = false;
					}
				},
				stopPropagation: function () {
					this.isPropagationStopped = returnTrue;

					var e = this.originalEvent;
					if (!e) {
						return;
					}
					// if stopPropagation exists run it on the original event
					if (e.stopPropagation) {
						e.stopPropagation();
					}
					// otherwise set the cancelBubble property of the original event to true (IE)
					e.cancelBubble = true;
				},
				stopImmediatePropagation: function () {
					this.isImmediatePropagationStopped = returnTrue;
					this.stopPropagation();
				},
				isDefaultPrevented: returnFalse,
				isPropagationStopped: returnFalse,
				isImmediatePropagationStopped: returnFalse
			};

			// Create mouseenter/leave events using mouseover/out and event-time checks
			JQXLite.each({
				mouseenter: "mouseover",
				mouseleave: "mouseout"
			}, function (orig, fix) {
				JQXLite.event.special[orig] = {
					delegateType: fix,
					bindType: fix,

					handle: function (event) {
						var ret,
							target = this,
							related = event.relatedTarget,
							handleObj = event.handleObj,
							selector = handleObj.selector;

						// For mousenter/leave call the handler if related is outside the target.
						// NB: No relatedTarget if the mouse left/entered the browser window
						if (!related || (related !== target && !JQXLite.contains(target, related))) {
							event.type = handleObj.origType;
							ret = handleObj.handler.apply(this, arguments);
							event.type = fix;
						}
						return ret;
					}
				};
			});

			JQXLite.fn.extend({

				on: function (types, selector, data, fn, /*INTERNAL*/ one) {
					var origFn, type;

					// Types can be a map of types/handlers
					if (typeof types === "object") {
						// ( types-Object, selector, data )
						if (typeof selector !== "string") { // && selector != null
							// ( types-Object, data )
							data = data || selector;
							selector = undefined;
						}
						for (type in types) {
							this.on(type, selector, data, types[type], one);
						}
						return this;
					}

					if (data == null && fn == null) {
						// ( types, fn )
						fn = selector;
						data = selector = undefined;
					} else if (fn == null) {
						if (typeof selector === "string") {
							// ( types, selector, fn )
							fn = data;
							data = undefined;
						} else {
							// ( types, data, fn )
							fn = data;
							data = selector;
							selector = undefined;
						}
					}
					if (fn === false) {
						fn = returnFalse;
					} else if (!fn) {
						return this;
					}

					if (one === 1) {
						origFn = fn;
						fn = function (event) {
							// Can use an empty set, since event contains the info
							JQXLite().off(event);
							return origFn.apply(this, arguments);
						};
						// Use same guid so caller can remove using origFn
						fn.guid = origFn.guid || (origFn.guid = JQXLite.guid++);
					}
					return this.each(function () {
						JQXLite.event.add(this, types, fn, data, selector);
					});
				},

				off: function (types, selector, fn) {
					var handleObj, type;
					if (types && types.preventDefault && types.handleObj) {
						// ( event )  dispatched JQXLite.Event
						handleObj = types.handleObj;
						JQXLite(types.delegateTarget).off(
							handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
							handleObj.selector,
							handleObj.handler
						);
						return this;
					}
					if (typeof types === "object") {
						// ( types-object [, selector] )
						for (type in types) {
							this.off(type, selector, types[type]);
						}
						return this;
					}
					if (selector === false || typeof selector === "function") {
						// ( types [, fn] )
						fn = selector;
						selector = undefined;
					}
					if (fn === false) {
						fn = returnFalse;
					}
					return this.each(function () {
						JQXLite.event.remove(this, types, fn, selector);
					});
				},

				delegate: function (selector, types, data, fn) {
					return this.on(types, selector, data, fn);
				},
				undelegate: function (selector, types, fn) {
					// ( namespace ) or ( selector, types [, fn] )
					return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
				},

				trigger: function (type, data) {
					return this.each(function () {
						JQXLite.event.trigger(type, data, this);
					});
				},
				triggerHandler: function (type, data) {
					if (this[0]) {
						return JQXLite.event.trigger(type, data, this[0], true);
					}
				},

				toggle: function (fn) {
					// Save reference to arguments for access in closure
					var args = arguments,
						guid = fn.guid || JQXLite.guid++,
						i = 0,
						toggler = function (event) {
							// Figure out which function to execute
							var lastToggle = (JQXLite._data(this, "lastToggle" + fn.guid) || 0) % i;
							JQXLite._data(this, "lastToggle" + fn.guid, lastToggle + 1);

							// Make sure that clicks stop
							event.preventDefault();

							// and execute the function
							return args[lastToggle].apply(this, arguments) || false;
						};

					// link all the functions, so any of them can unbind this click handler
					toggler.guid = guid;
					while (i < args.length) {
						args[i++].guid = guid;
					}

					return this.click(toggler);
				},

				hover: function (fnOver, fnOut) {
					return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
				}
			});

			JQXLite.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
				"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
				"change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {

					// Handle event binding
					JQXLite.fn[name] = function (data, fn) {
						if (fn == null) {
							fn = data;
							data = null;
						}

						return arguments.length > 0 ?
							this.on(name, null, data, fn) :
							this.trigger(name);
					};

					if (rkeyEvent.test(name)) {
						JQXLite.event.fixHooks[name] = JQXLite.event.keyHooks;
					}

					if (rmouseEvent.test(name)) {
						JQXLite.event.fixHooks[name] = JQXLite.event.mouseHooks;
					}
				});
			/*!
			 * Sizzle CSS Selector Engine
			 * Copyright 2012 JQXLite Foundation and other contributors
			 * Released under the MIT license
			 * http://sizzlejs.com/
			 */
			(function (window, undefined) {

				var cachedruns,
					assertGetIdNotName,
					Expr,
					getText,
					isXML,
					contains,
					compile,
					sortOrder,
					hasDuplicate,
					outermostContext,

					baseHasDuplicate = true,
					strundefined = "undefined",

					expando = ("sizcache" + Math.random()).replace(".", ""),

					Token = String,
					document = window.document,
					docElem = document.documentElement,
					dirruns = 0,
					done = 0,
					pop = [].pop,
					push = [].push,
					slice = [].slice,
					// Use a stripped-down indexOf if a native one is unavailable
					indexOf = [].indexOf || function (elem) {
						var i = 0,
							len = this.length;
						for (; i < len; i++) {
							if (this[i] === elem) {
								return i;
							}
						}
						return -1;
					},

					// Augment a function for special use by Sizzle
					markFunction = function (fn, value) {
						fn[expando] = value == null || value;
						return fn;
					},

					createCache = function () {
						var cache = {},
							keys = [];

						return markFunction(function (key, value) {
							// Only keep the most recent entries
							if (keys.push(key) > Expr.cacheLength) {
								delete cache[keys.shift()];
							}

							// Retrieve with (key + " ") to avoid collision with native Object.prototype properties (see Issue #157)
							return (cache[key + " "] = value);
						}, cache);
					},

					classCache = createCache(),
					tokenCache = createCache(),
					compilerCache = createCache(),

					// Regex

					// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
					whitespace = "[\\x20\\t\\r\\n\\f]",
					// http://www.w3.org/TR/css3-syntax/#characters
					characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

					// Loosely modeled on CSS identifier characters
					// An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
					// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
					identifier = characterEncoding.replace("w", "w#"),

					// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
					operators = "([*^$|!~]?=)",
					attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
						"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

					// Prefer arguments not in parens/brackets,
					//   then attribute selectors and non-pseudos (denoted by :),
					//   then anything else
					// These preferences are here to reduce the number of selectors
					//   needing tokenize in the PSEUDO preFilter
					pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

					// For matchExpr.POS and matchExpr.needsContext
					pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
						"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",

					// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
					rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

					rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
					rcombinators = new RegExp("^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*"),
					rpseudo = new RegExp(pseudos),

					// Easily-parseable/retrievable ID or TAG or CLASS selectors
					rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

					rnot = /^:not/,
					rsibling = /[\x20\t\r\n\f]*[+~]/,
					rendsWithNot = /:not\($/,

					rheader = /h\d/i,
					rinputs = /input|select|textarea|button/i,

					rbackslash = /\\(?!\\)/g,

					matchExpr = {
						"ID": new RegExp("^#(" + characterEncoding + ")"),
						"CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
						"NAME": new RegExp("^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]"),
						"TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
						"ATTR": new RegExp("^" + attributes),
						"PSEUDO": new RegExp("^" + pseudos),
						"POS": new RegExp(pos, "i"),
						"CHILD": new RegExp("^:(only|nth|first|last)-child(?:\\(" + whitespace +
							"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
							"*(\\d+)|))" + whitespace + "*\\)|)", "i"),
						// For use in libraries implementing .is()
						"needsContext": new RegExp("^" + whitespace + "*[>+~]|" + pos, "i")
					},

					// Support

					// Used for testing something on an element
					assert = function (fn) {
						var div = document.createElement("div");

						try {
							return fn(div);
						} catch (e) {
							return false;
						} finally {
							// release memory in IE
							div = null;
						}
					},

					// Check if getElementsByTagName("*") returns only elements
					assertTagNameNoComments = assert(function (div) {
						div.appendChild(document.createComment(""));
						return !div.getElementsByTagName("*").length;
					}),

					// Check if getAttribute returns normalized href attributes
					assertHrefNotNormalized = assert(function (div) {
						div.innerHTML = "<a href='#'></a>";
						return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
							div.firstChild.getAttribute("href") === "#";
					}),

					// Check if attributes should be retrieved by attribute nodes
					assertAttributes = assert(function (div) {
						div.innerHTML = "<select></select>";
						var type = typeof div.lastChild.getAttribute("multiple");
						// IE8 returns a string for some attributes even when not present
						return type !== "boolean" && type !== "string";
					}),

					// Check if getElementsByClassName can be trusted
					assertUsableClassName = assert(function (div) {
						// Opera can't find a second classname (in 9.6)
						div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
						if (!div.getElementsByClassName || !div.getElementsByClassName("e").length) {
							return false;
						}

						// Safari 3.2 caches class attributes and doesn't catch changes
						div.lastChild.className = "e";
						return div.getElementsByClassName("e").length === 2;
					}),

					// Check if getElementById returns elements by name
					// Check if getElementsByName privileges form controls or returns elements by ID
					assertUsableName = assert(function (div) {
						// Inject content
						div.id = expando + 0;
						div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
						docElem.insertBefore(div, docElem.firstChild);

						// Test
						var pass = document.getElementsByName &&
							// buggy browsers will return fewer than the correct 2
							document.getElementsByName(expando).length === 2 +
							// buggy browsers will return more than the correct 0
							document.getElementsByName(expando + 0).length;
						assertGetIdNotName = !document.getElementById(expando);

						// Cleanup
						docElem.removeChild(div);

						return pass;
					});

				// If slice is not available, provide a backup
				try {
					slice.call(docElem.childNodes, 0)[0].nodeType;
				} catch (e) {
					slice = function (i) {
						var elem,
							results = [];
						for (; (elem = this[i]); i++) {
							results.push(elem);
						}
						return results;
					};
				}

				function Sizzle(selector, context, results, seed) {
					results = results || [];
					context = context || document;
					var match, elem, xml, m,
						nodeType = context.nodeType;

					if (!selector || typeof selector !== "string") {
						return results;
					}

					if (nodeType !== 1 && nodeType !== 9) {
						return [];
					}

					xml = isXML(context);

					if (!xml && !seed) {
						if ((match = rquickExpr.exec(selector))) {
							// Speed-up: Sizzle("#ID")
							if ((m = match[1])) {
								if (nodeType === 9) {
									elem = context.getElementById(m);
									// Check parentNode to catch when Blackberry 4.6 returns
									// nodes that are no longer in the document #6963
									if (elem && elem.parentNode) {
										// Handle the case where IE, Opera, and Webkit return items
										// by name instead of ID
										if (elem.id === m) {
											results.push(elem);
											return results;
										}
									} else {
										return results;
									}
								} else {
									// Context is not a document
									if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
										contains(context, elem) && elem.id === m) {
										results.push(elem);
										return results;
									}
								}

								// Speed-up: Sizzle("TAG")
							} else if (match[2]) {
								push.apply(results, slice.call(context.getElementsByTagName(selector), 0));
								return results;

								// Speed-up: Sizzle(".CLASS")
							} else if ((m = match[3]) && assertUsableClassName && context.getElementsByClassName) {
								push.apply(results, slice.call(context.getElementsByClassName(m), 0));
								return results;
							}
						}
					}

					// All others
					return select(selector.replace(rtrim, "$1"), context, results, seed, xml);
				}

				Sizzle.matches = function (expr, elements) {
					return Sizzle(expr, null, null, elements);
				};

				Sizzle.matchesSelector = function (elem, expr) {
					return Sizzle(expr, null, null, [elem]).length > 0;
				};

				// Returns a function to use in pseudos for input types
				function createInputPseudo(type) {
					return function (elem) {
						var name = elem.nodeName.toLowerCase();
						return name === "input" && elem.type === type;
					};
				}

				// Returns a function to use in pseudos for buttons
				function createButtonPseudo(type) {
					return function (elem) {
						var name = elem.nodeName.toLowerCase();
						return (name === "input" || name === "button") && elem.type === type;
					};
				}

				// Returns a function to use in pseudos for positionals
				function createPositionalPseudo(fn) {
					return markFunction(function (argument) {
						argument = +argument;
						return markFunction(function (seed, matches) {
							var j,
								matchIndexes = fn([], seed.length, argument),
								i = matchIndexes.length;

							// Match elements found at the specified indexes
							while (i--) {
								if (seed[(j = matchIndexes[i])]) {
									seed[j] = !(matches[j] = seed[j]);
								}
							}
						});
					});
				}

				/**
				 * Utility function for retrieving the text value of an array of DOM nodes
				 * @param {Array|Element} elem
				 */
				getText = Sizzle.getText = function (elem) {
					var node,
						ret = "",
						i = 0,
						nodeType = elem.nodeType;

					if (nodeType) {
						if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
							// Use textContent for elements
							// innerText usage removed for consistency of new lines (see #11153)
							if (typeof elem.textContent === "string") {
								return elem.textContent;
							} else {
								// Traverse its children
								for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
									ret += getText(elem);
								}
							}
						} else if (nodeType === 3 || nodeType === 4) {
							return elem.nodeValue;
						}
						// Do not include comment or processing instruction nodes
					} else {

						// If no nodeType, this is expected to be an array
						for (; (node = elem[i]); i++) {
							// Do not traverse comment nodes
							ret += getText(node);
						}
					}
					return ret;
				};

				isXML = Sizzle.isXML = function (elem) {
					// documentElement is verified for cases where it doesn't yet exist
					// (such as loading iframes in IE - #4833)
					var documentElement = elem && (elem.ownerDocument || elem).documentElement;
					return documentElement ? documentElement.nodeName !== "HTML" : false;
				};

				// Element contains another
				contains = Sizzle.contains = docElem.contains ?
					function (a, b) {
						var adown = a.nodeType === 9 ? a.documentElement : a,
							bup = b && b.parentNode;
						return a === bup || !!(bup && bup.nodeType === 1 && adown.contains && adown.contains(bup));
					} :
					docElem.compareDocumentPosition ?
						function (a, b) {
							return b && !!(a.compareDocumentPosition(b) & 16);
						} :
						function (a, b) {
							while ((b = b.parentNode)) {
								if (b === a) {
									return true;
								}
							}
							return false;
						};

				Sizzle.attr = function (elem, name) {
					var val,
						xml = isXML(elem);

					if (!xml) {
						name = name.toLowerCase();
					}
					if ((val = Expr.attrHandle[name])) {
						return val(elem);
					}
					if (xml || assertAttributes) {
						return elem.getAttribute(name);
					}
					val = elem.getAttributeNode(name);
					return val ?
						typeof elem[name] === "boolean" ?
							elem[name] ? name : null :
							val.specified ? val.value : null :
						null;
				};

				Expr = Sizzle.selectors = {

					// Can be adjusted by the user
					cacheLength: 50,

					createPseudo: markFunction,

					match: matchExpr,

					// IE6/7 return a modified href
					attrHandle: assertHrefNotNormalized ?
						{} :
						{
							"href": function (elem) {
								return elem.getAttribute("href", 2);
							},
							"type": function (elem) {
								return elem.getAttribute("type");
							}
						},

					find: {
						"ID": assertGetIdNotName ?
							function (id, context, xml) {
								if (typeof context.getElementById !== strundefined && !xml) {
									var m = context.getElementById(id);
									// Check parentNode to catch when Blackberry 4.6 returns
									// nodes that are no longer in the document #6963
									return m && m.parentNode ? [m] : [];
								}
							} :
							function (id, context, xml) {
								if (typeof context.getElementById !== strundefined && !xml) {
									var m = context.getElementById(id);

									return m ?
										m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
											[m] :
											undefined :
										[];
								}
							},

						"TAG": assertTagNameNoComments ?
							function (tag, context) {
								if (typeof context.getElementsByTagName !== strundefined) {
									return context.getElementsByTagName(tag);
								}
							} :
							function (tag, context) {
								var results = context.getElementsByTagName(tag);

								// Filter out possible comments
								if (tag === "*") {
									var elem,
										tmp = [],
										i = 0;

									for (; (elem = results[i]); i++) {
										if (elem.nodeType === 1) {
											tmp.push(elem);
										}
									}

									return tmp;
								}
								return results;
							},

						"NAME": assertUsableName && function (tag, context) {
							if (typeof context.getElementsByName !== strundefined) {
								return context.getElementsByName(name);
							}
						},

						"CLASS": assertUsableClassName && function (className, context, xml) {
							if (typeof context.getElementsByClassName !== strundefined && !xml) {
								return context.getElementsByClassName(className);
							}
						}
					},

					relative: {
						">": { dir: "parentNode", first: true },
						" ": { dir: "parentNode" },
						"+": { dir: "previousSibling", first: true },
						"~": { dir: "previousSibling" }
					},

					preFilter: {
						"ATTR": function (match) {
							match[1] = match[1].replace(rbackslash, "");

							// Move the given value to match[3] whether quoted or unquoted
							match[3] = (match[4] || match[5] || "").replace(rbackslash, "");

							if (match[2] === "~=") {
								match[3] = " " + match[3] + " ";
							}

							return match.slice(0, 4);
						},

						"CHILD": function (match) {
							/* matches from matchExpr["CHILD"]
								1 type (only|nth|...)
								2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
								3 xn-component of xn+y argument ([+-]?\d*n|)
								4 sign of xn-component
								5 x of xn-component
								6 sign of y-component
								7 y of y-component
							*/
							match[1] = match[1].toLowerCase();

							if (match[1] === "nth") {
								// nth-child requires argument
								if (!match[2]) {
									Sizzle.error(match[0]);
								}

								// numeric x and y parameters for Expr.filter.CHILD
								// remember that false/true cast respectively to 0/1
								match[3] = +(match[3] ? match[4] + (match[5] || 1) : 2 * (match[2] === "even" || match[2] === "odd"));
								match[4] = +((match[6] + match[7]) || match[2] === "odd");

								// other types prohibit arguments
							} else if (match[2]) {
								Sizzle.error(match[0]);
							}

							return match;
						},

						"PSEUDO": function (match) {
							var unquoted, excess;
							if (matchExpr["CHILD"].test(match[0])) {
								return null;
							}

							if (match[3]) {
								match[2] = match[3];
							} else if ((unquoted = match[4])) {
								// Only check arguments that contain a pseudo
								if (rpseudo.test(unquoted) &&
									// Get excess from tokenize (recursively)
									(excess = tokenize(unquoted, true)) &&
									// advance to the next closing parenthesis
									(excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

									// excess is a negative index
									unquoted = unquoted.slice(0, excess);
									match[0] = match[0].slice(0, excess);
								}
								match[2] = unquoted;
							}

							// Return only captures needed by the pseudo filter method (type and argument)
							return match.slice(0, 3);
						}
					},

					filter: {
						"ID": assertGetIdNotName ?
							function (id) {
								id = id.replace(rbackslash, "");
								return function (elem) {
									return elem.getAttribute("id") === id;
								};
							} :
							function (id) {
								id = id.replace(rbackslash, "");
								return function (elem) {
									var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
									return node && node.value === id;
								};
							},

						"TAG": function (nodeName) {
							if (nodeName === "*") {
								return function () { return true; };
							}
							nodeName = nodeName.replace(rbackslash, "").toLowerCase();

							return function (elem) {
								return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
							};
						},

						"CLASS": function (className) {
							var pattern = classCache[expando][className + " "];

							return pattern ||
								(pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
								classCache(className, function (elem) {
									return pattern.test(elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "");
								});
						},

						"ATTR": function (name, operator, check) {
							return function (elem, context) {
								var result = Sizzle.attr(elem, name);

								if (result == null) {
									return operator === "!=";
								}
								if (!operator) {
									return true;
								}

								result += "";

								return operator === "=" ? result === check :
									operator === "!=" ? result !== check :
										operator === "^=" ? check && result.indexOf(check) === 0 :
											operator === "*=" ? check && result.indexOf(check) > -1 :
												operator === "$=" ? check && result.substr(result.length - check.length) === check :
													operator === "~=" ? (" " + result + " ").indexOf(check) > -1 :
														operator === "|=" ? result === check || result.substr(0, check.length + 1) === check + "-" :
															false;
							};
						},

						"CHILD": function (type, argument, first, last) {

							if (type === "nth") {
								return function (elem) {
									var node, diff,
										parent = elem.parentNode;

									if (first === 1 && last === 0) {
										return true;
									}

									if (parent) {
										diff = 0;
										for (node = parent.firstChild; node; node = node.nextSibling) {
											if (node.nodeType === 1) {
												diff++;
												if (elem === node) {
													break;
												}
											}
										}
									}

									// Incorporate the offset (or cast to NaN), then check against cycle size
									diff -= last;
									return diff === first || (diff % first === 0 && diff / first >= 0);
								};
							}

							return function (elem) {
								var node = elem;

								switch (type) {
									case "only":
									case "first":
										while ((node = node.previousSibling)) {
											if (node.nodeType === 1) {
												return false;
											}
										}

										if (type === "first") {
											return true;
										}

										node = elem;

									/* falls through */
									case "last":
										while ((node = node.nextSibling)) {
											if (node.nodeType === 1) {
												return false;
											}
										}

										return true;
								}
							};
						},

						"PSEUDO": function (pseudo, argument) {
							// pseudo-class names are case-insensitive
							// http://www.w3.org/TR/selectors/#pseudo-classes
							// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
							// Remember that setFilters inherits from pseudos
							var args,
								fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
									Sizzle.error("unsupported pseudo: " + pseudo);

							// The user may use createPseudo to indicate that
							// arguments are needed to create the filter function
							// just as Sizzle does
							if (fn[expando]) {
								return fn(argument);
							}

							// But maintain support for old signatures
							if (fn.length > 1) {
								args = [pseudo, pseudo, "", argument];
								return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
									markFunction(function (seed, matches) {
										var idx,
											matched = fn(seed, argument),
											i = matched.length;
										while (i--) {
											idx = indexOf.call(seed, matched[i]);
											seed[idx] = !(matches[idx] = matched[i]);
										}
									}) :
									function (elem) {
										return fn(elem, 0, args);
									};
							}

							return fn;
						}
					},

					pseudos: {
						"not": markFunction(function (selector) {
							// Trim the selector passed to compile
							// to avoid treating leading and trailing
							// spaces as combinators
							var input = [],
								results = [],
								matcher = compile(selector.replace(rtrim, "$1"));

							return matcher[expando] ?
								markFunction(function (seed, matches, context, xml) {
									var elem,
										unmatched = matcher(seed, null, xml, []),
										i = seed.length;

									// Match elements unmatched by `matcher`
									while (i--) {
										if ((elem = unmatched[i])) {
											seed[i] = !(matches[i] = elem);
										}
									}
								}) :
								function (elem, context, xml) {
									input[0] = elem;
									matcher(input, null, xml, results);
									return !results.pop();
								};
						}),

						"has": markFunction(function (selector) {
							return function (elem) {
								return Sizzle(selector, elem).length > 0;
							};
						}),

						"contains": markFunction(function (text) {
							return function (elem) {
								return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
							};
						}),

						"enabled": function (elem) {
							return elem.disabled === false;
						},

						"disabled": function (elem) {
							return elem.disabled === true;
						},

						"checked": function (elem) {
							// In CSS3, :checked should return both checked and selected elements
							// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
							var nodeName = elem.nodeName.toLowerCase();
							return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
						},

						"selected": function (elem) {
							// Accessing this property makes selected-by-default
							// options in Safari work properly
							if (elem.parentNode) {
								elem.parentNode.selectedIndex;
							}

							return elem.selected === true;
						},

						"parent": function (elem) {
							return !Expr.pseudos["empty"](elem);
						},

						"empty": function (elem) {
							// http://www.w3.org/TR/selectors/#empty-pseudo
							// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
							//   not comment, processing instructions, or others
							// Thanks to Diego Perini for the nodeName shortcut
							//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
							var nodeType;
							elem = elem.firstChild;
							while (elem) {
								if (elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4) {
									return false;
								}
								elem = elem.nextSibling;
							}
							return true;
						},

						"header": function (elem) {
							return rheader.test(elem.nodeName);
						},

						"text": function (elem) {
							var type, attr;
							// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
							// use getAttribute instead to test this case
							return elem.nodeName.toLowerCase() === "input" &&
								(type = elem.type) === "text" &&
								((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type);
						},

						// Input types
						"radio": createInputPseudo("radio"),
						"checkbox": createInputPseudo("checkbox"),
						"file": createInputPseudo("file"),
						"password": createInputPseudo("password"),
						"image": createInputPseudo("image"),

						"submit": createButtonPseudo("submit"),
						"reset": createButtonPseudo("reset"),

						"button": function (elem) {
							var name = elem.nodeName.toLowerCase();
							return name === "input" && elem.type === "button" || name === "button";
						},

						"input": function (elem) {
							return rinputs.test(elem.nodeName);
						},

						"focus": function (elem) {
							var doc = elem.ownerDocument;
							return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
						},

						"active": function (elem) {
							return elem === elem.ownerDocument.activeElement;
						},

						// Positional types
						"first": createPositionalPseudo(function () {
							return [0];
						}),

						"last": createPositionalPseudo(function (matchIndexes, length) {
							return [length - 1];
						}),

						"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
							return [argument < 0 ? argument + length : argument];
						}),

						"even": createPositionalPseudo(function (matchIndexes, length) {
							for (var i = 0; i < length; i += 2) {
								matchIndexes.push(i);
							}
							return matchIndexes;
						}),

						"odd": createPositionalPseudo(function (matchIndexes, length) {
							for (var i = 1; i < length; i += 2) {
								matchIndexes.push(i);
							}
							return matchIndexes;
						}),

						"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
							for (var i = argument < 0 ? argument + length : argument; --i >= 0;) {
								matchIndexes.push(i);
							}
							return matchIndexes;
						}),

						"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
							for (var i = argument < 0 ? argument + length : argument; ++i < length;) {
								matchIndexes.push(i);
							}
							return matchIndexes;
						})
					}
				};

				function siblingCheck(a, b, ret) {
					if (a === b) {
						return ret;
					}

					var cur = a.nextSibling;

					while (cur) {
						if (cur === b) {
							return -1;
						}

						cur = cur.nextSibling;
					}

					return 1;
				}

				sortOrder = docElem.compareDocumentPosition ?
					function (a, b) {
						if (a === b) {
							hasDuplicate = true;
							return 0;
						}

						return (!a.compareDocumentPosition || !b.compareDocumentPosition ?
							a.compareDocumentPosition :
							a.compareDocumentPosition(b) & 4
						) ? -1 : 1;
					} :
					function (a, b) {
						// The nodes are identical, we can exit early
						if (a === b) {
							hasDuplicate = true;
							return 0;

							// Fallback to using sourceIndex (in IE) if it's available on both nodes
						} else if (a.sourceIndex && b.sourceIndex) {
							return a.sourceIndex - b.sourceIndex;
						}

						var al, bl,
							ap = [],
							bp = [],
							aup = a.parentNode,
							bup = b.parentNode,
							cur = aup;

						// If the nodes are siblings (or identical) we can do a quick check
						if (aup === bup) {
							return siblingCheck(a, b);

							// If no parents were found then the nodes are disconnected
						} else if (!aup) {
							return -1;

						} else if (!bup) {
							return 1;
						}

						// Otherwise they're somewhere else in the tree so we need
						// to build up a full list of the parentNodes for comparison
						while (cur) {
							ap.unshift(cur);
							cur = cur.parentNode;
						}

						cur = bup;

						while (cur) {
							bp.unshift(cur);
							cur = cur.parentNode;
						}

						al = ap.length;
						bl = bp.length;

						// Start walking down the tree looking for a discrepancy
						for (var i = 0; i < al && i < bl; i++) {
							if (ap[i] !== bp[i]) {
								return siblingCheck(ap[i], bp[i]);
							}
						}

						// We ended someplace up the tree so do a sibling check
						return i === al ?
							siblingCheck(a, bp[i], -1) :
							siblingCheck(ap[i], b, 1);
					};

				// Always assume the presence of duplicates if sort doesn't
				// pass them to our comparison function (as in Google Chrome).
				[0, 0].sort(sortOrder);
				baseHasDuplicate = !hasDuplicate;

				// Document sorting and removing duplicates
				Sizzle.uniqueSort = function (results) {
					var elem,
						duplicates = [],
						i = 1,
						j = 0;

					hasDuplicate = baseHasDuplicate;
					results.sort(sortOrder);

					if (hasDuplicate) {
						for (; (elem = results[i]); i++) {
							if (elem === results[i - 1]) {
								j = duplicates.push(i);
							}
						}
						while (j--) {
							results.splice(duplicates[j], 1);
						}
					}

					return results;
				};

				Sizzle.error = function (msg) {
					throw new Error("Syntax error, unrecognized expression: " + msg);
				};

				function tokenize(selector, parseOnly) {
					var matched, match, tokens, type,
						soFar, groups, preFilters,
						cached = tokenCache[expando][selector + " "];

					if (cached) {
						return parseOnly ? 0 : cached.slice(0);
					}

					soFar = selector;
					groups = [];
					preFilters = Expr.preFilter;

					while (soFar) {

						// Comma and first run
						if (!matched || (match = rcomma.exec(soFar))) {
							if (match) {
								// Don't consume trailing commas as valid
								soFar = soFar.slice(match[0].length) || soFar;
							}
							groups.push(tokens = []);
						}

						matched = false;

						// Combinators
						if ((match = rcombinators.exec(soFar))) {
							tokens.push(matched = new Token(match.shift()));
							soFar = soFar.slice(matched.length);

							// Cast descendant combinators to space
							matched.type = match[0].replace(rtrim, " ");
						}

						// Filters
						for (type in Expr.filter) {
							if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
								(match = preFilters[type](match)))) {

								tokens.push(matched = new Token(match.shift()));
								soFar = soFar.slice(matched.length);
								matched.type = type;
								matched.matches = match;
							}
						}

						if (!matched) {
							break;
						}
					}

					// Return the length of the invalid excess
					// if we're just parsing
					// Otherwise, throw an error or return tokens
					return parseOnly ?
						soFar.length :
						soFar ?
							Sizzle.error(selector) :
							// Cache the tokens
							tokenCache(selector, groups).slice(0);
				}

				function addCombinator(matcher, combinator, base) {
					var dir = combinator.dir,
						checkNonElements = base && combinator.dir === "parentNode",
						doneName = done++;

					return combinator.first ?
						// Check against closest ancestor/preceding element
						function (elem, context, xml) {
							while ((elem = elem[dir])) {
								if (checkNonElements || elem.nodeType === 1) {
									return matcher(elem, context, xml);
								}
							}
						} :

						// Check against all ancestor/preceding elements
						function (elem, context, xml) {
							// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
							if (!xml) {
								var cache,
									dirkey = dirruns + " " + doneName + " ",
									cachedkey = dirkey + cachedruns;
								while ((elem = elem[dir])) {
									if (checkNonElements || elem.nodeType === 1) {
										if ((cache = elem[expando]) === cachedkey) {
											return elem.sizset;
										} else if (typeof cache === "string" && cache.indexOf(dirkey) === 0) {
											if (elem.sizset) {
												return elem;
											}
										} else {
											elem[expando] = cachedkey;
											if (matcher(elem, context, xml)) {
												elem.sizset = true;
												return elem;
											}
											elem.sizset = false;
										}
									}
								}
							} else {
								while ((elem = elem[dir])) {
									if (checkNonElements || elem.nodeType === 1) {
										if (matcher(elem, context, xml)) {
											return elem;
										}
									}
								}
							}
						};
				}

				function elementMatcher(matchers) {
					return matchers.length > 1 ?
						function (elem, context, xml) {
							var i = matchers.length;
							while (i--) {
								if (!matchers[i](elem, context, xml)) {
									return false;
								}
							}
							return true;
						} :
						matchers[0];
				}

				function condense(unmatched, map, filter, context, xml) {
					var elem,
						newUnmatched = [],
						i = 0,
						len = unmatched.length,
						mapped = map != null;

					for (; i < len; i++) {
						if ((elem = unmatched[i])) {
							if (!filter || filter(elem, context, xml)) {
								newUnmatched.push(elem);
								if (mapped) {
									map.push(i);
								}
							}
						}
					}

					return newUnmatched;
				}

				function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
					if (postFilter && !postFilter[expando]) {
						postFilter = setMatcher(postFilter);
					}
					if (postFinder && !postFinder[expando]) {
						postFinder = setMatcher(postFinder, postSelector);
					}
					return markFunction(function (seed, results, context, xml) {
						var temp, i, elem,
							preMap = [],
							postMap = [],
							preexisting = results.length,

							// Get initial elements from seed or context
							elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

							// Prefilter to get matcher input, preserving a map for seed-results synchronization
							matcherIn = preFilter && (seed || !selector) ?
								condense(elems, preMap, preFilter, context, xml) :
								elems,

							matcherOut = matcher ?
								// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
								postFinder || (seed ? preFilter : preexisting || postFilter) ?

									// ...intermediate processing is necessary
									[] :

									// ...otherwise use results directly
									results :
								matcherIn;

						// Find primary matches
						if (matcher) {
							matcher(matcherIn, matcherOut, context, xml);
						}

						// Apply postFilter
						if (postFilter) {
							temp = condense(matcherOut, postMap);
							postFilter(temp, [], context, xml);

							// Un-match failing elements by moving them back to matcherIn
							i = temp.length;
							while (i--) {
								if ((elem = temp[i])) {
									matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
								}
							}
						}

						if (seed) {
							if (postFinder || preFilter) {
								if (postFinder) {
									// Get the final matcherOut by condensing this intermediate into postFinder contexts
									temp = [];
									i = matcherOut.length;
									while (i--) {
										if ((elem = matcherOut[i])) {
											// Restore matcherIn since elem is not yet a final match
											temp.push((matcherIn[i] = elem));
										}
									}
									postFinder(null, (matcherOut = []), temp, xml);
								}

								// Move matched elements from seed to results to keep them synchronized
								i = matcherOut.length;
								while (i--) {
									if ((elem = matcherOut[i]) &&
										(temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {

										seed[temp] = !(results[temp] = elem);
									}
								}
							}

							// Add elements to results, through postFinder if defined
						} else {
							matcherOut = condense(
								matcherOut === results ?
									matcherOut.splice(preexisting, matcherOut.length) :
									matcherOut
							);
							if (postFinder) {
								postFinder(null, results, matcherOut, xml);
							} else {
								push.apply(results, matcherOut);
							}
						}
					});
				}

				function matcherFromTokens(tokens) {
					var checkContext, matcher, j,
						len = tokens.length,
						leadingRelative = Expr.relative[tokens[0].type],
						implicitRelative = leadingRelative || Expr.relative[" "],
						i = leadingRelative ? 1 : 0,

						// The foundational matcher ensures that elements are reachable from top-level context(s)
						matchContext = addCombinator(function (elem) {
							return elem === checkContext;
						}, implicitRelative, true),
						matchAnyContext = addCombinator(function (elem) {
							return indexOf.call(checkContext, elem) > -1;
						}, implicitRelative, true),
						matchers = [function (elem, context, xml) {
							return (!leadingRelative && (xml || context !== outermostContext)) || (
								(checkContext = context).nodeType ?
									matchContext(elem, context, xml) :
									matchAnyContext(elem, context, xml));
						}];

					for (; i < len; i++) {
						if ((matcher = Expr.relative[tokens[i].type])) {
							matchers = [addCombinator(elementMatcher(matchers), matcher)];
						} else {
							matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

							// Return special upon seeing a positional matcher
							if (matcher[expando]) {
								// Find the next relative operator (if any) for proper handling
								j = ++i;
								for (; j < len; j++) {
									if (Expr.relative[tokens[j].type]) {
										break;
									}
								}
								return setMatcher(
									i > 1 && elementMatcher(matchers),
									i > 1 && tokens.slice(0, i - 1).join("").replace(rtrim, "$1"),
									matcher,
									i < j && matcherFromTokens(tokens.slice(i, j)),
									j < len && matcherFromTokens((tokens = tokens.slice(j))),
									j < len && tokens.join("")
								);
							}
							matchers.push(matcher);
						}
					}

					return elementMatcher(matchers);
				}

				function matcherFromGroupMatchers(elementMatchers, setMatchers) {
					var bySet = setMatchers.length > 0,
						byElement = elementMatchers.length > 0,
						superMatcher = function (seed, context, xml, results, expandContext) {
							var elem, j, matcher,
								setMatched = [],
								matchedCount = 0,
								i = "0",
								unmatched = seed && [],
								outermost = expandContext != null,
								contextBackup = outermostContext,
								// We must always have either seed elements or context
								elems = seed || byElement && Expr.find["TAG"]("*", expandContext && context.parentNode || context),
								// Nested matchers should use non-integer dirruns
								dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

							if (outermost) {
								outermostContext = context !== document && context;
								cachedruns = superMatcher.el;
							}

							// Add elements passing elementMatchers directly to results
							for (; (elem = elems[i]) != null; i++) {
								if (byElement && elem) {
									for (j = 0; (matcher = elementMatchers[j]); j++) {
										if (matcher(elem, context, xml)) {
											results.push(elem);
											break;
										}
									}
									if (outermost) {
										dirruns = dirrunsUnique;
										cachedruns = ++superMatcher.el;
									}
								}

								// Track unmatched elements for set filters
								if (bySet) {
									// They will have gone through all possible matchers
									if ((elem = !matcher && elem)) {
										matchedCount--;
									}

									// Lengthen the array for every element, matched or not
									if (seed) {
										unmatched.push(elem);
									}
								}
							}

							// Apply set filters to unmatched elements
							matchedCount += i;
							if (bySet && i !== matchedCount) {
								for (j = 0; (matcher = setMatchers[j]); j++) {
									matcher(unmatched, setMatched, context, xml);
								}

								if (seed) {
									// Reintegrate element matches to eliminate the need for sorting
									if (matchedCount > 0) {
										while (i--) {
											if (!(unmatched[i] || setMatched[i])) {
												setMatched[i] = pop.call(results);
											}
										}
									}

									// Discard index placeholder values to get only actual matches
									setMatched = condense(setMatched);
								}

								// Add matches to results
								push.apply(results, setMatched);

								// Seedless set matches succeeding multiple successful matchers stipulate sorting
								if (outermost && !seed && setMatched.length > 0 &&
									(matchedCount + setMatchers.length) > 1) {

									Sizzle.uniqueSort(results);
								}
							}

							// Override manipulation of globals by nested matchers
							if (outermost) {
								dirruns = dirrunsUnique;
								outermostContext = contextBackup;
							}

							return unmatched;
						};

					superMatcher.el = 0;
					return bySet ?
						markFunction(superMatcher) :
						superMatcher;
				}

				compile = Sizzle.compile = function (selector, group /* Internal Use Only */) {
					var i,
						setMatchers = [],
						elementMatchers = [],
						cached = compilerCache[expando][selector + " "];

					if (!cached) {
						// Generate a function of recursive functions that can be used to check each element
						if (!group) {
							group = tokenize(selector);
						}
						i = group.length;
						while (i--) {
							cached = matcherFromTokens(group[i]);
							if (cached[expando]) {
								setMatchers.push(cached);
							} else {
								elementMatchers.push(cached);
							}
						}

						// Cache the compiled function
						cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
					}
					return cached;
				};

				function multipleContexts(selector, contexts, results) {
					var i = 0,
						len = contexts.length;
					for (; i < len; i++) {
						Sizzle(selector, contexts[i], results);
					}
					return results;
				}

				function select(selector, context, results, seed, xml) {
					var i, tokens, token, type, find,
						match = tokenize(selector),
						j = match.length;

					if (!seed) {
						// Try to minimize operations if there is only one group
						if (match.length === 1) {

							// Take a shortcut and set the context if the root selector is an ID
							tokens = match[0] = match[0].slice(0);
							if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
								context.nodeType === 9 && !xml &&
								Expr.relative[tokens[1].type]) {

								context = Expr.find["ID"](token.matches[0].replace(rbackslash, ""), context, xml)[0];
								if (!context) {
									return results;
								}

								selector = selector.slice(tokens.shift().length);
							}

							// Fetch a seed set for right-to-left matching
							for (i = matchExpr["POS"].test(selector) ? -1 : tokens.length - 1; i >= 0; i--) {
								token = tokens[i];

								// Abort if we hit a combinator
								if (Expr.relative[(type = token.type)]) {
									break;
								}
								if ((find = Expr.find[type])) {
									// Search, expanding context for leading sibling combinators
									if ((seed = find(
										token.matches[0].replace(rbackslash, ""),
										rsibling.test(tokens[0].type) && context.parentNode || context,
										xml
									))) {

										// If seed is empty or no tokens remain, we can return early
										tokens.splice(i, 1);
										selector = seed.length && tokens.join("");
										if (!selector) {
											push.apply(results, slice.call(seed, 0));
											return results;
										}

										break;
									}
								}
							}
						}
					}

					// Compile and execute a filtering function
					// Provide `match` to avoid retokenization if we modified the selector above
					compile(selector, match)(
						seed,
						context,
						xml,
						results,
						rsibling.test(selector)
					);
					return results;
				}

				if (document.querySelectorAll) {
					(function () {
						var disconnectedMatch,
							oldSelect = select,
							rescape = /'|\\/g,
							rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

							// qSa(:focus) reports false when true (Chrome 21), no need to also add to buggyMatches since matches checks buggyQSA
							// A support test would require too much code (would include document ready)
							rbuggyQSA = [":focus"],

							// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
							// A support test would require too much code (would include document ready)
							// just skip matchesSelector for :active
							rbuggyMatches = [":active"],
							matches = docElem.matchesSelector ||
								docElem.mozMatchesSelector ||
								docElem.webkitMatchesSelector ||
								docElem.oMatchesSelector ||
								docElem.msMatchesSelector;

						// Build QSA regex
						// Regex strategy adopted from Diego Perini
						assert(function (div) {
							// Select is set to empty string on purpose
							// This is to test IE's treatment of not explictly
							// setting a boolean content attribute,
							// since its presence should be enough
							// http://bugs.jqx.com/ticket/12359
							div.innerHTML = "<select><option selected=''></option></select>";

							// IE8 - Some boolean attributes are not treated correctly
							if (!div.querySelectorAll("[selected]").length) {
								rbuggyQSA.push("\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)");
							}

							// Webkit/Opera - :checked should return selected option elements
							// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
							// IE8 throws error here (do not put tests after this one)
							if (!div.querySelectorAll(":checked").length) {
								rbuggyQSA.push(":checked");
							}
						});

						assert(function (div) {

							// Opera 10-12/IE9 - ^= $= *= and empty values
							// Should not select anything
							div.innerHTML = "<p test=''></p>";
							if (div.querySelectorAll("[test^='']").length) {
								rbuggyQSA.push("[*^$]=" + whitespace + "*(?:\"\"|'')");
							}

							// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
							// IE8 throws error here (do not put tests after this one)
							div.innerHTML = "<input type='hidden'/>";
							if (!div.querySelectorAll(":enabled").length) {
								rbuggyQSA.push(":enabled", ":disabled");
							}
						});

						// rbuggyQSA always contains :focus, so no need for a length check
						rbuggyQSA = /* rbuggyQSA.length && */ new RegExp(rbuggyQSA.join("|"));

						select = function (selector, context, results, seed, xml) {
							// Only use querySelectorAll when not filtering,
							// when this is not xml,
							// and when no QSA bugs apply
							if (!seed && !xml && !rbuggyQSA.test(selector)) {
								var groups, i,
									old = true,
									nid = expando,
									newContext = context,
									newSelector = context.nodeType === 9 && selector;

								// qSA works strangely on Element-rooted queries
								// We can work around this by specifying an extra ID on the root
								// and working up from there (Thanks to Andrew Dupont for the technique)
								// IE 8 doesn't work on object elements
								if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
									groups = tokenize(selector);

									if ((old = context.getAttribute("id"))) {
										nid = old.replace(rescape, "\\$&");
									} else {
										context.setAttribute("id", nid);
									}
									nid = "[id='" + nid + "'] ";

									i = groups.length;
									while (i--) {
										groups[i] = nid + groups[i].join("");
									}
									newContext = rsibling.test(selector) && context.parentNode || context;
									newSelector = groups.join(",");
								}

								if (newSelector) {
									try {
										push.apply(results, slice.call(newContext.querySelectorAll(
											newSelector
										), 0));
										return results;
									} catch (qsaError) {
									} finally {
										if (!old) {
											context.removeAttribute("id");
										}
									}
								}
							}

							return oldSelect(selector, context, results, seed, xml);
						};

						if (matches) {
							assert(function (div) {
								// Check to see if it's possible to do matchesSelector
								// on a disconnected node (IE 9)
								disconnectedMatch = matches.call(div, "div");

								// This should fail with an exception
								// Gecko does not error, returns false instead
								try {
									matches.call(div, "[test!='']:sizzle");
									rbuggyMatches.push("!=", pseudos);
								} catch (e) { }
							});

							// rbuggyMatches always contains :active and :focus, so no need for a length check
							rbuggyMatches = /* rbuggyMatches.length && */ new RegExp(rbuggyMatches.join("|"));

							Sizzle.matchesSelector = function (elem, expr) {
								// Make sure that attribute selectors are quoted
								expr = expr.replace(rattributeQuotes, "='$1']");

								// rbuggyMatches always contains :active, so no need for an existence check
								if (!isXML(elem) && !rbuggyMatches.test(expr) && !rbuggyQSA.test(expr)) {
									try {
										var ret = matches.call(elem, expr);

										// IE 9's matchesSelector returns false on disconnected nodes
										if (ret || disconnectedMatch ||
											// As well, disconnected nodes are said to be in a document
											// fragment in IE 9
											elem.document && elem.document.nodeType !== 11) {
											return ret;
										}
									} catch (e) { }
								}

								return Sizzle(expr, null, null, [elem]).length > 0;
							};
						}
					})();
				}

				// Deprecated
				Expr.pseudos["nth"] = Expr.pseudos["eq"];

				// Back-compat
				function setFilters() { }
				Expr.filters = setFilters.prototype = Expr.pseudos;
				Expr.setFilters = new setFilters();

				// Override sizzle attribute retrieval
				Sizzle.attr = JQXLite.attr;
				JQXLite.find = Sizzle;
				JQXLite.expr = Sizzle.selectors;
				JQXLite.expr[":"] = JQXLite.expr.pseudos;
				JQXLite.unique = Sizzle.uniqueSort;
				JQXLite.text = Sizzle.getText;
				JQXLite.isXMLDoc = Sizzle.isXML;
				JQXLite.contains = Sizzle.contains;


			})(window);
			var runtil = /Until$/,
				rparentsprev = /^(?:parents|prev(?:Until|All))/,
				isSimple = /^.[^:#\[\.,]*$/,
				rneedsContext = JQXLite.expr.match.needsContext,
				// methods guaranteed to produce a unique set when starting from a unique set
				guaranteedUnique = {
					children: true,
					contents: true,
					next: true,
					prev: true
				};

			JQXLite.fn.extend({
				find: function (selector) {
					var i, l, length, n, r, ret,
						self = this;

					if (typeof selector !== "string") {
						return JQXLite(selector).filter(function () {
							for (i = 0, l = self.length; i < l; i++) {
								if (JQXLite.contains(self[i], this)) {
									return true;
								}
							}
						});
					}

					ret = this.pushStack("", "find", selector);

					for (i = 0, l = this.length; i < l; i++) {
						length = ret.length;
						JQXLite.find(selector, this[i], ret);

						if (i > 0) {
							// Make sure that the results are unique
							for (n = length; n < ret.length; n++) {
								for (r = 0; r < length; r++) {
									if (ret[r] === ret[n]) {
										ret.splice(n--, 1);
										break;
									}
								}
							}
						}
					}

					return ret;
				},

				has: function (target) {
					var i,
						targets = JQXLite(target, this),
						len = targets.length;

					return this.filter(function () {
						for (i = 0; i < len; i++) {
							if (JQXLite.contains(this, targets[i])) {
								return true;
							}
						}
					});
				},

				not: function (selector) {
					return this.pushStack(winnow(this, selector, false), "not", selector);
				},

				filter: function (selector) {
					return this.pushStack(winnow(this, selector, true), "filter", selector);
				},

				is: function (selector) {
					return !!selector && (
						typeof selector === "string" ?
							// If this is a positional/relative selector, check membership in the returned set
							// so $("p:first").is("p:last") won't return true for a doc with two "p".
							rneedsContext.test(selector) ?
								JQXLite(selector, this.context).index(this[0]) >= 0 :
								JQXLite.filter(selector, this).length > 0 :
							this.filter(selector).length > 0);
				},

				closest: function (selectors, context) {
					var cur,
						i = 0,
						l = this.length,
						ret = [],
						pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
							JQXLite(selectors, context || this.context) :
							0;

					for (; i < l; i++) {
						cur = this[i];

						while (cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11) {
							if (pos ? pos.index(cur) > -1 : JQXLite.find.matchesSelector(cur, selectors)) {
								ret.push(cur);
								break;
							}
							cur = cur.parentNode;
						}
					}

					ret = ret.length > 1 ? JQXLite.unique(ret) : ret;

					return this.pushStack(ret, "closest", selectors);
				},

				// Determine the position of an element within
				// the matched set of elements
				index: function (elem) {

					// No argument, return index in parent
					if (!elem) {
						return (this[0] && this[0].parentNode) ? this.prevAll().length : -1;
					}

					// index in selector
					if (typeof elem === "string") {
						return JQXLite.inArray(this[0], JQXLite(elem));
					}

					// Locate the position of the desired element
					return JQXLite.inArray(
						// If it receives a JQXLite object, the first element is used
						elem.jqx ? elem[0] : elem, this);
				},

				add: function (selector, context) {
					var set = typeof selector === "string" ?
						JQXLite(selector, context) :
						JQXLite.makeArray(selector && selector.nodeType ? [selector] : selector),
						all = JQXLite.merge(this.get(), set);

					return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ?
						all :
						JQXLite.unique(all));
				},

				addBack: function (selector) {
					return this.add(selector == null ?
						this.prevObject : this.prevObject.filter(selector)
					);
				}
			});

			JQXLite.fn.andSelf = JQXLite.fn.addBack;

			// A painfully simple check to see if an element is disconnected
			// from a document (should be improved, where feasible).
			function isDisconnected(node) {
				return !node || !node.parentNode || node.parentNode.nodeType === 11;
			}

			function sibling(cur, dir) {
				do {
					cur = cur[dir];
				} while (cur && cur.nodeType !== 1);

				return cur;
			}

			JQXLite.each({
				parent: function (elem) {
					var parent = elem.parentNode;
					return parent && parent.nodeType !== 11 ? parent : null;
				},
				parents: function (elem) {
					return JQXLite.dir(elem, "parentNode");
				},
				parentsUntil: function (elem, i, until) {
					return JQXLite.dir(elem, "parentNode", until);
				},
				next: function (elem) {
					return sibling(elem, "nextSibling");
				},
				prev: function (elem) {
					return sibling(elem, "previousSibling");
				},
				nextAll: function (elem) {
					return JQXLite.dir(elem, "nextSibling");
				},
				prevAll: function (elem) {
					return JQXLite.dir(elem, "previousSibling");
				},
				nextUntil: function (elem, i, until) {
					return JQXLite.dir(elem, "nextSibling", until);
				},
				prevUntil: function (elem, i, until) {
					return JQXLite.dir(elem, "previousSibling", until);
				},
				siblings: function (elem) {
					return JQXLite.sibling((elem.parentNode || {}).firstChild, elem);
				},
				children: function (elem) {
					return JQXLite.sibling(elem.firstChild);
				},
				contents: function (elem) {
					return JQXLite.nodeName(elem, "iframe") ?
						elem.contentDocument || elem.contentWindow.document :
						JQXLite.merge([], elem.childNodes);
				}
			}, function (name, fn) {
				JQXLite.fn[name] = function (until, selector) {
					var ret = JQXLite.map(this, fn, until);

					if (!runtil.test(name)) {
						selector = until;
					}

					if (selector && typeof selector === "string") {
						ret = JQXLite.filter(selector, ret);
					}

					ret = this.length > 1 && !guaranteedUnique[name] ? JQXLite.unique(ret) : ret;

					if (this.length > 1 && rparentsprev.test(name)) {
						ret = ret.reverse();
					}

					return this.pushStack(ret, name, core_slice.call(arguments).join(","));
				};
			});

			JQXLite.extend({
				filter: function (expr, elems, not) {
					if (not) {
						expr = ":not(" + expr + ")";
					}

					return elems.length === 1 ?
						JQXLite.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] :
						JQXLite.find.matches(expr, elems);
				},

				dir: function (elem, dir, until) {
					var matched = [],
						cur = elem[dir];

					while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !JQXLite(cur).is(until))) {
						if (cur.nodeType === 1) {
							matched.push(cur);
						}
						cur = cur[dir];
					}
					return matched;
				},

				sibling: function (n, elem) {
					var r = [];

					for (; n; n = n.nextSibling) {
						if (n.nodeType === 1 && n !== elem) {
							r.push(n);
						}
					}

					return r;
				}
			});

			// Implement the identical functionality for filter and not
			function winnow(elements, qualifier, keep) {

				// Can't pass null or undefined to indexOf in Firefox 4
				// Set to 0 to skip string check
				qualifier = qualifier || 0;

				if (JQXLite.isFunction(qualifier)) {
					return JQXLite.grep(elements, function (elem, i) {
						var retVal = !!qualifier.call(elem, i, elem);
						return retVal === keep;
					});

				} else if (qualifier.nodeType) {
					return JQXLite.grep(elements, function (elem, i) {
						return (elem === qualifier) === keep;
					});

				} else if (typeof qualifier === "string") {
					var filtered = JQXLite.grep(elements, function (elem) {
						return elem.nodeType === 1;
					});

					if (isSimple.test(qualifier)) {
						return JQXLite.filter(qualifier, filtered, !keep);
					} else {
						qualifier = JQXLite.filter(qualifier, filtered);
					}
				}

				return JQXLite.grep(elements, function (elem, i) {
					return (JQXLite.inArray(elem, qualifier) >= 0) === keep;
				});
			}
			function createSafeFragment(document) {
				var list = nodeNames.split("|"),
					safeFrag = document.createDocumentFragment();

				if (safeFrag.createElement) {
					while (list.length) {
						safeFrag.createElement(
							list.pop()
						);
					}
				}
				return safeFrag;
			}

			var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
				"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
				rinlinejQuery = / JQXLite\d+="(?:null|\d+)"/g,
				rleadingWhitespace = /^\s+/,
				rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
				rtagName = /<([\w:]+)/,
				rtbody = /<tbody/i,
				rhtml = /<|&#?\w+;/,
				rnoInnerhtml = /<(?:script|style|link)/i,
				rnocache = /<(?:script|object|embed|option|style)/i,
				rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
				rcheckableType = /^(?:checkbox|radio)$/,
				// checked="checked" or checked
				rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
				rscriptType = /\/(java|ecma)script/i,
				rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
				wrapMap = {
					option: [1, "<select multiple='multiple'>", "</select>"],
					legend: [1, "<fieldset>", "</fieldset>"],
					thead: [1, "<table>", "</table>"],
					tr: [2, "<table><tbody>", "</tbody></table>"],
					td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
					col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
					area: [1, "<map>", "</map>"],
					_default: [0, "", ""]
				},
				safeFragment = createSafeFragment(document),
				fragmentDiv = safeFragment.appendChild(document.createElement("div"));

			wrapMap.optgroup = wrapMap.option;
			wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
			wrapMap.th = wrapMap.td;

			// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
			// unless wrapped in a div with non-breaking characters in front of it.
			if (!JQXLite.support.htmlSerialize) {
				wrapMap._default = [1, "X<div>", "</div>"];
			}

			JQXLite.fn.extend({
				text: function (value) {
					return JQXLite.access(this, function (value) {
						return value === undefined ?
							JQXLite.text(this) :
							this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
					}, null, value, arguments.length);
				},

				wrapAll: function (html) {
					if (JQXLite.isFunction(html)) {
						return this.each(function (i) {
							JQXLite(this).wrapAll(html.call(this, i));
						});
					}

					if (this[0]) {
						// The elements to wrap the target around
						var wrap = JQXLite(html, this[0].ownerDocument).eq(0).clone(true);

						if (this[0].parentNode) {
							wrap.insertBefore(this[0]);
						}

						wrap.map(function () {
							var elem = this;

							while (elem.firstChild && elem.firstChild.nodeType === 1) {
								elem = elem.firstChild;
							}

							return elem;
						}).append(this);
					}

					return this;
				},

				wrapInner: function (html) {
					if (JQXLite.isFunction(html)) {
						return this.each(function (i) {
							JQXLite(this).wrapInner(html.call(this, i));
						});
					}

					return this.each(function () {
						var self = JQXLite(this),
							contents = self.contents();

						if (contents.length) {
							contents.wrapAll(html);

						} else {
							self.append(html);
						}
					});
				},

				wrap: function (html) {
					var isFunction = JQXLite.isFunction(html);

					return this.each(function (i) {
						JQXLite(this).wrapAll(isFunction ? html.call(this, i) : html);
					});
				},

				unwrap: function () {
					return this.parent().each(function () {
						if (!JQXLite.nodeName(this, "body")) {
							JQXLite(this).replaceWith(this.childNodes);
						}
					}).end();
				},

				append: function () {
					return this.domManip(arguments, true, function (elem) {
						if (this.nodeType === 1 || this.nodeType === 11) {
							this.appendChild(elem);
						}
					});
				},

				prepend: function () {
					return this.domManip(arguments, true, function (elem) {
						if (this.nodeType === 1 || this.nodeType === 11) {
							this.insertBefore(elem, this.firstChild);
						}
					});
				},

				before: function () {
					if (!isDisconnected(this[0])) {
						return this.domManip(arguments, false, function (elem) {
							this.parentNode.insertBefore(elem, this);
						});
					}

					if (arguments.length) {
						var set = JQXLite.clean(arguments);
						return this.pushStack(JQXLite.merge(set, this), "before", this.selector);
					}
				},

				after: function () {
					if (!isDisconnected(this[0])) {
						return this.domManip(arguments, false, function (elem) {
							this.parentNode.insertBefore(elem, this.nextSibling);
						});
					}

					if (arguments.length) {
						var set = JQXLite.clean(arguments);
						return this.pushStack(JQXLite.merge(this, set), "after", this.selector);
					}
				},

				// keepData is for internal use only--do not document
				remove: function (selector, keepData) {
					var elem,
						i = 0;

					for (; (elem = this[i]) != null; i++) {
						if (!selector || JQXLite.filter(selector, [elem]).length) {
							if (!keepData && elem.nodeType === 1) {
								JQXLite.cleanData(elem.getElementsByTagName("*"));
								JQXLite.cleanData([elem]);
							}

							if (elem.parentNode) {
								elem.parentNode.removeChild(elem);
							}
						}
					}

					return this;
				},

				empty: function () {
					var elem,
						i = 0;

					for (; (elem = this[i]) != null; i++) {
						// Remove element nodes and prevent memory leaks
						if (elem.nodeType === 1) {
							JQXLite.cleanData(elem.getElementsByTagName("*"));
						}

						// Remove any remaining nodes
						while (elem.firstChild) {
							elem.removeChild(elem.firstChild);
						}
					}

					return this;
				},

				clone: function (dataAndEvents, deepDataAndEvents) {
					dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
					deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

					return this.map(function () {
						return JQXLite.clone(this, dataAndEvents, deepDataAndEvents);
					});
				},

				html: function (value) {
					return JQXLite.access(this, function (value) {
						var elem = this[0] || {},
							i = 0,
							l = this.length;

						if (value === undefined) {
							return elem.nodeType === 1 ?
								elem.innerHTML.replace(rinlinejQuery, "") :
								undefined;
						}

						// See if we can take a shortcut and just use innerHTML
						if (typeof value === "string" && !rnoInnerhtml.test(value) &&
							(JQXLite.support.htmlSerialize || !rnoshimcache.test(value)) &&
							(JQXLite.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
							!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

							value = value.replace(rxhtmlTag, "<$1></$2>");

							try {
								for (; i < l; i++) {
									// Remove element nodes and prevent memory leaks
									elem = this[i] || {};
									if (elem.nodeType === 1) {
										JQXLite.cleanData(elem.getElementsByTagName("*"));
										elem.innerHTML = value;
									}
								}

								elem = 0;

								// If using innerHTML throws an exception, use the fallback method
							} catch (e) { }
						}

						if (elem) {
							this.empty().append(value);
						}
					}, null, value, arguments.length);
				},

				replaceWith: function (value) {
					if (!isDisconnected(this[0])) {
						// Make sure that the elements are removed from the DOM before they are inserted
						// this can help fix replacing a parent with child elements
						if (JQXLite.isFunction(value)) {
							return this.each(function (i) {
								var self = JQXLite(this), old = self.html();
								self.replaceWith(value.call(this, i, old));
							});
						}

						if (typeof value !== "string") {
							value = JQXLite(value).detach();
						}

						return this.each(function () {
							var next = this.nextSibling,
								parent = this.parentNode;

							JQXLite(this).remove();

							if (next) {
								JQXLite(next).before(value);
							} else {
								JQXLite(parent).append(value);
							}
						});
					}

					return this.length ?
						this.pushStack(JQXLite(JQXLite.isFunction(value) ? value() : value), "replaceWith", value) :
						this;
				},

				detach: function (selector) {
					return this.remove(selector, true);
				},

				domManip: function (args, table, callback) {

					// Flatten any nested arrays
					args = [].concat.apply([], args);

					var results, first, fragment, iNoClone,
						i = 0,
						value = args[0],
						scripts = [],
						l = this.length;

					// We can't cloneNode fragments that contain checked, in WebKit
					if (!JQXLite.support.checkClone && l > 1 && typeof value === "string" && rchecked.test(value)) {
						return this.each(function () {
							JQXLite(this).domManip(args, table, callback);
						});
					}

					if (JQXLite.isFunction(value)) {
						return this.each(function (i) {
							var self = JQXLite(this);
							args[0] = value.call(this, i, table ? self.html() : undefined);
							self.domManip(args, table, callback);
						});
					}

					if (this[0]) {
						results = JQXLite.buildFragment(args, this, scripts);
						fragment = results.fragment;
						first = fragment.firstChild;

						if (fragment.childNodes.length === 1) {
							fragment = first;
						}

						if (first) {
							table = table && JQXLite.nodeName(first, "tr");

							// Use the original fragment for the last item instead of the first because it can end up
							// being emptied incorrectly in certain situations (#8070).
							// Fragments from the fragment cache must always be cloned and never used in place.
							for (iNoClone = results.cacheable || l - 1; i < l; i++) {
								callback.call(
									table && JQXLite.nodeName(this[i], "table") ?
										findOrAppend(this[i], "tbody") :
										this[i],
									i === iNoClone ?
										fragment :
										JQXLite.clone(fragment, true, true)
								);
							}
						}

						// Fix #11809: Avoid leaking memory
						fragment = first = null;

						if (scripts.length) {
							JQXLite.each(scripts, function (i, elem) {
								if (elem.src) {
									if (JQXLite.ajax) {
										JQXLite.ajax({
											url: elem.src,
											type: "GET",
											dataType: "script",
											async: false,
											global: false,
											"throws": true
										});
									} else {
										JQXLite.error("no ajax");
									}
								} else {
									JQXLite.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, ""));
								}

								if (elem.parentNode) {
									elem.parentNode.removeChild(elem);
								}
							});
						}
					}

					return this;
				}
			});

			function findOrAppend(elem, tag) {
				return elem.getElementsByTagName(tag)[0] || elem.appendChild(elem.ownerDocument.createElement(tag));
			}

			function cloneCopyEvent(src, dest) {

				if (dest.nodeType !== 1 || !JQXLite.hasData(src)) {
					return;
				}

				var type, i, l,
					oldData = JQXLite._data(src),
					curData = JQXLite._data(dest, oldData),
					events = oldData.events;

				if (events) {
					delete curData.handle;
					curData.events = {};

					for (type in events) {
						for (i = 0, l = events[type].length; i < l; i++) {
							JQXLite.event.add(dest, type, events[type][i]);
						}
					}
				}

				// make the cloned public data object a copy from the original
				if (curData.data) {
					curData.data = JQXLite.extend({}, curData.data);
				}
			}

			function cloneFixAttributes(src, dest) {
				var nodeName;

				// We do not need to do anything for non-Elements
				if (dest.nodeType !== 1) {
					return;
				}

				// clearAttributes removes the attributes, which we don't want,
				// but also removes the attachEvent events, which we *do* want
				if (dest.clearAttributes) {
					dest.clearAttributes();
				}

				// mergeAttributes, in contrast, only merges back on the
				// original attributes, not the events
				if (dest.mergeAttributes) {
					dest.mergeAttributes(src);
				}

				nodeName = dest.nodeName.toLowerCase();

				if (nodeName === "object") {
					// IE6-10 improperly clones children of object elements using classid.
					// IE10 throws NoModificationAllowedError if parent is null, #12132.
					if (dest.parentNode) {
						dest.outerHTML = src.outerHTML;
					}

					// This path appears unavoidable for IE9. When cloning an object
					// element in IE9, the outerHTML strategy above is not sufficient.
					// If the src has innerHTML and the destination does not,
					// copy the src.innerHTML into the dest.innerHTML. #10324
					if (JQXLite.support.html5Clone && (src.innerHTML && !JQXLite.trim(dest.innerHTML))) {
						dest.innerHTML = src.innerHTML;
					}

				} else if (nodeName === "input" && rcheckableType.test(src.type)) {
					// IE6-8 fails to persist the checked state of a cloned checkbox
					// or radio button. Worse, IE6-7 fail to give the cloned element
					// a checked appearance if the defaultChecked value isn't also set

					dest.defaultChecked = dest.checked = src.checked;

					// IE6-7 get confused and end up setting the value of a cloned
					// checkbox/radio button to an empty string instead of "on"
					if (dest.value !== src.value) {
						dest.value = src.value;
					}

					// IE6-8 fails to return the selected option to the default selected
					// state when cloning options
				} else if (nodeName === "option") {
					dest.selected = src.defaultSelected;

					// IE6-8 fails to set the defaultValue to the correct value when
					// cloning other types of input fields
				} else if (nodeName === "input" || nodeName === "textarea") {
					dest.defaultValue = src.defaultValue;

					// IE blanks contents when cloning scripts
				} else if (nodeName === "script" && dest.text !== src.text) {
					dest.text = src.text;
				}

				// Event data gets referenced instead of copied if the expando
				// gets copied too
				dest.removeAttribute(JQXLite.expando);
			}

			JQXLite.buildFragment = function (args, context, scripts) {
				var fragment, cacheable, cachehit,
					first = args[0];

				// Set context from what may come in as undefined or a JQXLite collection or a node
				// Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
				// also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
				context = context || document;
				context = !context.nodeType && context[0] || context;
				context = context.ownerDocument || context;

				// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
				// Cloning options loses the selected state, so don't cache them
				// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
				// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
				// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
				if (args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
					first.charAt(0) === "<" && !rnocache.test(first) &&
					(JQXLite.support.checkClone || !rchecked.test(first)) &&
					(JQXLite.support.html5Clone || !rnoshimcache.test(first))) {

					// Mark cacheable and look for a hit
					cacheable = true;
					fragment = JQXLite.fragments[first];
					cachehit = fragment !== undefined;
				}

				if (!fragment) {
					fragment = context.createDocumentFragment();
					JQXLite.clean(args, context, fragment, scripts);

					// Update the cache, but only store false
					// unless this is a second parsing of the same content
					if (cacheable) {
						JQXLite.fragments[first] = cachehit && fragment;
					}
				}

				return { fragment: fragment, cacheable: cacheable };
			};

			JQXLite.fragments = {};

			JQXLite.each({
				appendTo: "append",
				prependTo: "prepend",
				insertBefore: "before",
				insertAfter: "after",
				replaceAll: "replaceWith"
			}, function (name, original) {
				JQXLite.fn[name] = function (selector) {
					var elems,
						i = 0,
						ret = [],
						insert = JQXLite(selector),
						l = insert.length,
						parent = this.length === 1 && this[0].parentNode;

					if ((parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1) {
						insert[original](this[0]);
						return this;
					} else {
						for (; i < l; i++) {
							elems = (i > 0 ? this.clone(true) : this).get();
							JQXLite(insert[i])[original](elems);
							ret = ret.concat(elems);
						}

						return this.pushStack(ret, name, insert.selector);
					}
				};
			});

			function getAll(elem) {
				if (typeof elem.getElementsByTagName !== "undefined") {
					return elem.getElementsByTagName("*");

				} else if (typeof elem.querySelectorAll !== "undefined") {
					return elem.querySelectorAll("*");

				} else {
					return [];
				}
			}

			// Used in clean, fixes the defaultChecked property
			function fixDefaultChecked(elem) {
				if (rcheckableType.test(elem.type)) {
					elem.defaultChecked = elem.checked;
				}
			}

			JQXLite.extend({
				clone: function (elem, dataAndEvents, deepDataAndEvents) {
					var srcElements,
						destElements,
						i,
						clone;

					if (JQXLite.support.html5Clone || JQXLite.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) {
						clone = elem.cloneNode(true);

						// IE<=8 does not properly clone detached, unknown element nodes
					} else {
						fragmentDiv.innerHTML = elem.outerHTML;
						fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
					}

					if ((!JQXLite.support.noCloneEvent || !JQXLite.support.noCloneChecked) &&
						(elem.nodeType === 1 || elem.nodeType === 11) && !JQXLite.isXMLDoc(elem)) {
						// IE copies events bound via attachEvent when using cloneNode.
						// Calling detachEvent on the clone will also remove the events
						// from the original. In order to get around this, we use some
						// proprietary methods to clear the events. Thanks to MooTools
						// guys for this hotness.

						cloneFixAttributes(elem, clone);

						// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
						srcElements = getAll(elem);
						destElements = getAll(clone);

						// Weird iteration because IE will replace the length property
						// with an element if you are cloning the body and one of the
						// elements on the page has a name or id of "length"
						for (i = 0; srcElements[i]; ++i) {
							// Ensure that the destination node is not null; Fixes #9587
							if (destElements[i]) {
								cloneFixAttributes(srcElements[i], destElements[i]);
							}
						}
					}

					// Copy the events from the original to the clone
					if (dataAndEvents) {
						cloneCopyEvent(elem, clone);

						if (deepDataAndEvents) {
							srcElements = getAll(elem);
							destElements = getAll(clone);

							for (i = 0; srcElements[i]; ++i) {
								cloneCopyEvent(srcElements[i], destElements[i]);
							}
						}
					}

					srcElements = destElements = null;

					// Return the cloned set
					return clone;
				},

				clean: function (elems, context, fragment, scripts) {
					var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
						safe = context === document && safeFragment,
						ret = [];

					// Ensure that context is a document
					if (!context || typeof context.createDocumentFragment === "undefined") {
						context = document;
					}

					// Use the already-created safe fragment if context permits
					for (i = 0; (elem = elems[i]) != null; i++) {
						if (typeof elem === "number") {
							elem += "";
						}

						if (!elem) {
							continue;
						}

						// Convert html string into DOM nodes
						if (typeof elem === "string") {
							if (!rhtml.test(elem)) {
								elem = context.createTextNode(elem);
							} else {
								// Ensure a safe container in which to render the html
								safe = safe || createSafeFragment(context);
								div = context.createElement("div");
								safe.appendChild(div);

								// Fix "XHTML"-style tags in all browsers
								elem = elem.replace(rxhtmlTag, "<$1></$2>");

								// Go to html and back, then peel off extra wrappers
								tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
								wrap = wrapMap[tag] || wrapMap._default;
								depth = wrap[0];
								div.innerHTML = wrap[1] + elem + wrap[2];

								// Move to the right depth
								while (depth--) {
									div = div.lastChild;
								}

								// Remove IE's autoinserted <tbody> from table fragments
								if (!JQXLite.support.tbody) {

									// String was a <table>, *may* have spurious <tbody>
									hasBody = rtbody.test(elem);
									tbody = tag === "table" && !hasBody ?
										div.firstChild && div.firstChild.childNodes :

										// String was a bare <thead> or <tfoot>
										wrap[1] === "<table>" && !hasBody ?
											div.childNodes :
											[];

									for (j = tbody.length - 1; j >= 0; --j) {
										if (JQXLite.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
											tbody[j].parentNode.removeChild(tbody[j]);
										}
									}
								}

								// IE completely kills leading whitespace when innerHTML is used
								if (!JQXLite.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
									div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
								}

								elem = div.childNodes;

								// Take out of fragment container (we need a fresh div each time)
								div.parentNode.removeChild(div);
							}
						}

						if (elem.nodeType) {
							ret.push(elem);
						} else {
							JQXLite.merge(ret, elem);
						}
					}

					// Fix #11356: Clear elements from safeFragment
					if (div) {
						elem = div = safe = null;
					}

					// Reset defaultChecked for any radios and checkboxes
					// about to be appended to the DOM in IE 6/7 (#8060)
					if (!JQXLite.support.appendChecked) {
						for (i = 0; (elem = ret[i]) != null; i++) {
							if (JQXLite.nodeName(elem, "input")) {
								fixDefaultChecked(elem);
							} else if (typeof elem.getElementsByTagName !== "undefined") {
								JQXLite.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
							}
						}
					}

					// Append elements to a provided document fragment
					if (fragment) {
						// Special handling of each script element
						handleScript = function (elem) {
							// Check if we consider it executable
							if (!elem.type || rscriptType.test(elem.type)) {
								// Detach the script and store it in the scripts array (if provided) or the fragment
								// Return truthy to indicate that it has been handled
								return scripts ?
									scripts.push(elem.parentNode ? elem.parentNode.removeChild(elem) : elem) :
									fragment.appendChild(elem);
							}
						};

						for (i = 0; (elem = ret[i]) != null; i++) {
							// Check if we're done after handling an executable script
							if (!(JQXLite.nodeName(elem, "script") && handleScript(elem))) {
								// Append to fragment and handle embedded scripts
								fragment.appendChild(elem);
								if (typeof elem.getElementsByTagName !== "undefined") {
									// handleScript alters the DOM, so use JQXLite.merge to ensure snapshot iteration
									jsTags = JQXLite.grep(JQXLite.merge([], elem.getElementsByTagName("script")), handleScript);

									// Splice the scripts into ret after their former ancestor and advance our index beyond them
									ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
									i += jsTags.length;
								}
							}
						}
					}

					return ret;
				},

				cleanData: function (elems, /* internal */ acceptData) {
					var data, id, elem, type,
						i = 0,
						internalKey = JQXLite.expando,
						cache = JQXLite.cache,
						deleteExpando = JQXLite.support.deleteExpando,
						special = JQXLite.event.special;

					for (; (elem = elems[i]) != null; i++) {

						if (acceptData || JQXLite.acceptData(elem)) {

							id = elem[internalKey];
							data = id && cache[id];

							if (data) {
								if (data.events) {
									for (type in data.events) {
										if (special[type]) {
											JQXLite.event.remove(elem, type);

											// This is a shortcut to avoid JQXLite.event.remove's overhead
										} else {
											JQXLite.removeEvent(elem, type, data.handle);
										}
									}
								}

								// Remove cache only if it was not already removed by JQXLite.event.remove
								if (cache[id]) {

									delete cache[id];

									// IE does not allow us to delete expando properties from nodes,
									// nor does it have a removeAttribute function on Document nodes;
									// we must handle all of these cases
									if (deleteExpando) {
										delete elem[internalKey];

									} else if (elem.removeAttribute) {
										elem.removeAttribute(internalKey);

									} else {
										elem[internalKey] = null;
									}

									JQXLite.deletedIds.push(id);
								}
							}
						}
					}
				}
			});
			// Limit scope pollution from any deprecated API
			(function () {

				var matched, browser;

				// Use of JQXLite.browser is frowned upon.
				// More details: http://api.jqx.com/JQXLite.browser
				// JQXLite.uaMatch maintained for back-compat
				JQXLite.uaMatch = function (ua) {
					ua = ua.toLowerCase();

					var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
						/(webkit)[ \/]([\w.]+)/.exec(ua) ||
						/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
						/(msie) ([\w.]+)/.exec(ua) ||
						ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
						[];

					return {
						browser: match[1] || "",
						version: match[2] || "0"
					};
				};

				matched = JQXLite.uaMatch(navigator.userAgent);
				browser = {};

				if (matched.browser) {
					browser[matched.browser] = true;
					browser.version = matched.version;
				}

				// Chrome is Webkit, but Webkit is also Safari.
				if (browser.chrome) {
					browser.webkit = true;
				} else if (browser.webkit) {
					browser.safari = true;
				}

				JQXLite.browser = browser;

				JQXLite.sub = function () {
					function jQuerySub(selector, context) {
						return new jQuerySub.fn.init(selector, context);
					}
					JQXLite.extend(true, jQuerySub, this);
					jQuerySub.superclass = this;
					jQuerySub.fn = jQuerySub.prototype = this();
					jQuerySub.fn.constructor = jQuerySub;
					jQuerySub.sub = this.sub;
					jQuerySub.fn.init = function init(selector, context) {
						if (context && context instanceof JQXLite && !(context instanceof jQuerySub)) {
							context = jQuerySub(context);
						}

						return JQXLite.fn.init.call(this, selector, context, rootJQXLiteSub);
					};
					jQuerySub.fn.init.prototype = jQuerySub.fn;
					var rootJQXLiteSub = jQuerySub(document);
					return jQuerySub;
				};

			})();
			var curCSS, iframe, iframeDoc,
				ralpha = /alpha\([^)]*\)/i,
				ropacity = /opacity=([^)]*)/,
				rposition = /^(top|right|bottom|left)$/,
				// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
				// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
				rdisplayswap = /^(none|table(?!-c[ea]).+)/,
				rmargin = /^margin/,
				rnumsplit = new RegExp("^(" + core_pnum + ")(.*)$", "i"),
				rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"),
				rrelNum = new RegExp("^([-+])=(" + core_pnum + ")", "i"),
				elemdisplay = { BODY: "block" },

				cssShow = { position: "absolute", visibility: "hidden", display: "block" },
				cssNormalTransform = {
					letterSpacing: 0,
					fontWeight: 400
				},

				cssExpand = ["Top", "Right", "Bottom", "Left"],
				cssPrefixes = ["Webkit", "O", "Moz", "ms"],

				eventsToggle = JQXLite.fn.toggle;

			// return a css property mapped to a potentially vendor prefixed property
			function vendorPropName(style, name) {

				// shortcut for names that are not vendor prefixed
				if (name in style) {
					return name;
				}

				// check for vendor prefixed names
				var capName = name.charAt(0).toUpperCase() + name.slice(1),
					origName = name,
					i = cssPrefixes.length;

				while (i--) {
					name = cssPrefixes[i] + capName;
					if (name in style) {
						return name;
					}
				}

				return origName;
			}

			function isHidden(elem, el) {
				elem = el || elem;
				return JQXLite.css(elem, "display") === "none" || !JQXLite.contains(elem.ownerDocument, elem);
			}

			function showHide(elements, show) {
				var elem, display,
					values = [],
					index = 0,
					length = elements.length;

				for (; index < length; index++) {
					elem = elements[index];
					if (!elem.style) {
						continue;
					}
					values[index] = JQXLite._data(elem, "olddisplay");
					if (show) {
						// Reset the inline display of this element to learn if it is
						// being hidden by cascaded rules or not
						if (!values[index] && elem.style.display === "none") {
							elem.style.display = "";
						}

						// Set elements which have been overridden with display: none
						// in a stylesheet to whatever the default browser style is
						// for such an element
						if (elem.style.display === "" && isHidden(elem)) {
							values[index] = JQXLite._data(elem, "olddisplay", css_defaultDisplay(elem.nodeName));
						}
					} else {
						display = curCSS(elem, "display");

						if (!values[index] && display !== "none") {
							JQXLite._data(elem, "olddisplay", display);
						}
					}
				}

				// Set the display of most of the elements in a second loop
				// to avoid the constant reflow
				for (index = 0; index < length; index++) {
					elem = elements[index];
					if (!elem.style) {
						continue;
					}
					if (!show || elem.style.display === "none" || elem.style.display === "") {
						elem.style.display = show ? values[index] || "" : "none";
					}
				}

				return elements;
			}

			JQXLite.fn.extend({
				css: function (name, value) {
					return JQXLite.access(this, function (elem, name, value) {
						return value !== undefined ?
							JQXLite.style(elem, name, value) :
							JQXLite.css(elem, name);
					}, name, value, arguments.length > 1);
				},
				show: function () {
					return showHide(this, true);
				},
				hide: function () {
					return showHide(this);
				},
				toggle: function (state, fn2) {
					var bool = typeof state === "boolean";

					if (JQXLite.isFunction(state) && JQXLite.isFunction(fn2)) {
						return eventsToggle.apply(this, arguments);
					}

					return this.each(function () {
						if (bool ? state : isHidden(this)) {
							JQXLite(this).show();
						} else {
							JQXLite(this).hide();
						}
					});
				}
			});

			JQXLite.extend({
				// Add in style property hooks for overriding the default
				// behavior of getting and setting a style property
				cssHooks: {
					opacity: {
						get: function (elem, computed) {
							if (computed) {
								// We should always get a number back from opacity
								var ret = curCSS(elem, "opacity");
								return ret === "" ? "1" : ret;

							}
						}
					}
				},

				// Exclude the following css properties to add px
				cssNumber: {
					"fillOpacity": true,
					"fontWeight": true,
					"lineHeight": true,
					"opacity": true,
					"orphans": true,
					"widows": true,
					"zIndex": true,
					"zoom": true
				},

				// Add in properties whose names you wish to fix before
				// setting or getting the value
				cssProps: {
					// normalize float css property
					"float": JQXLite.support.cssFloat ? "cssFloat" : "styleFloat"
				},

				// Get and set the style property on a DOM Node
				style: function (elem, name, value, extra) {
					// Don't set styles on text and comment nodes
					if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
						return;
					}

					// Make sure that we're working with the right name
					var ret, type, hooks,
						origName = JQXLite.camelCase(name),
						style = elem.style;

					name = JQXLite.cssProps[origName] || (JQXLite.cssProps[origName] = vendorPropName(style, origName));

					// gets hook for the prefixed version
					// followed by the unprefixed version
					hooks = JQXLite.cssHooks[name] || JQXLite.cssHooks[origName];

					// Check if we're setting a value
					if (value !== undefined) {
						type = typeof value;

						// convert relative number strings (+= or -=) to relative numbers. #7345
						if (type === "string" && (ret = rrelNum.exec(value))) {
							value = (ret[1] + 1) * ret[2] + parseFloat(JQXLite.css(elem, name));
							// Fixes bug #9237
							type = "number";
						}

						// Make sure that NaN and null values aren't set. See: #7116
						if (value == null || type === "number" && isNaN(value)) {
							return;
						}

						// If a number was passed in, add 'px' to the (except for certain CSS properties)
						if (type === "number" && !JQXLite.cssNumber[origName]) {
							value += "px";
						}

						// If a hook was provided, use that value, otherwise just set the specified value
						if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
							// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
							// Fixes bug #5509
							try {
								style[name] = value;
							} catch (e) { }
						}

					} else {
						// If a hook was provided get the non-computed value from there
						if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
							return ret;
						}

						// Otherwise just get the value from the style object
						return style[name];
					}
				},

				css: function (elem, name, numeric, extra) {
					var val, num, hooks,
						origName = JQXLite.camelCase(name);

					// Make sure that we're working with the right name
					name = JQXLite.cssProps[origName] || (JQXLite.cssProps[origName] = vendorPropName(elem.style, origName));

					// gets hook for the prefixed version
					// followed by the unprefixed version
					hooks = JQXLite.cssHooks[name] || JQXLite.cssHooks[origName];

					// If a hook was provided get the computed value from there
					if (hooks && "get" in hooks) {
						val = hooks.get(elem, true, extra);
					}

					// Otherwise, if a way to get the computed value exists, use that
					if (val === undefined) {
						val = curCSS(elem, name);
					}

					//convert "normal" to computed value
					if (val === "normal" && name in cssNormalTransform) {
						val = cssNormalTransform[name];
					}

					// Return, converting to number if forced or a qualifier was provided and val looks numeric
					if (numeric || extra !== undefined) {
						num = parseFloat(val);
						return numeric || JQXLite.isNumeric(num) ? num || 0 : val;
					}
					return val;
				},

				// A method for quickly swapping in/out CSS properties to get correct calculations
				swap: function (elem, options, callback) {
					var ret, name,
						old = {};

					// Remember the old values, and insert the new ones
					for (name in options) {
						old[name] = elem.style[name];
						elem.style[name] = options[name];
					}

					ret = callback.call(elem);

					// Revert the old values
					for (name in options) {
						elem.style[name] = old[name];
					}

					return ret;
				}
			});

			// NOTE: To any future maintainer, we've window.getComputedStyle
			// because jsdom on node.js will break without it.
			if (window.getComputedStyle) {
				curCSS = function (elem, name) {
					var ret, width, minWidth, maxWidth,
						computed = window.getComputedStyle(elem, null),
						style = elem.style;

					if (computed) {

						// getPropertyValue is only needed for .css('filter') in IE9, see #12537
						ret = computed.getPropertyValue(name) || computed[name];

						if (ret === "" && !JQXLite.contains(elem.ownerDocument, elem)) {
							ret = JQXLite.style(elem, name);
						}

						// A tribute to the "awesome hack by Dean Edwards"
						// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
						// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
						// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
						if (rnumnonpx.test(ret) && rmargin.test(name)) {
							width = style.width;
							minWidth = style.minWidth;
							maxWidth = style.maxWidth;

							style.minWidth = style.maxWidth = style.width = ret;
							ret = computed.width;

							style.width = width;
							style.minWidth = minWidth;
							style.maxWidth = maxWidth;
						}
					}

					return ret;
				};
			} else if (document.documentElement.currentStyle) {
				curCSS = function (elem, name) {
					var left, rsLeft,
						ret = elem.currentStyle && elem.currentStyle[name],
						style = elem.style;

					// Avoid setting ret to empty string here
					// so we don't default to auto
					if (ret == null && style && style[name]) {
						ret = style[name];
					}

					// From the awesome hack by Dean Edwards
					// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

					// If we're not dealing with a regular pixel number
					// but a number that has a weird ending, we need to convert it to pixels
					// but not position css attributes, as those are proportional to the parent element instead
					// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
					if (rnumnonpx.test(ret) && !rposition.test(name)) {

						// Remember the original values
						left = style.left;
						rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

						// Put in the new values to get a computed value out
						if (rsLeft) {
							elem.runtimeStyle.left = elem.currentStyle.left;
						}
						style.left = name === "fontSize" ? "1em" : ret;
						ret = style.pixelLeft + "px";

						// Revert the changed values
						style.left = left;
						if (rsLeft) {
							elem.runtimeStyle.left = rsLeft;
						}
					}

					return ret === "" ? "auto" : ret;
				};
			}

			function setPositiveNumber(elem, value, subtract) {
				var matches = rnumsplit.exec(value);
				return matches ?
					Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") :
					value;
			}

			function augmentWidthOrHeight(elem, name, extra, isBorderBox) {
				var i = extra === (isBorderBox ? "border" : "content") ?
					// If we already have the right measurement, avoid augmentation
					4 :
					// Otherwise initialize for horizontal or vertical properties
					name === "width" ? 1 : 0,

					val = 0;

				for (; i < 4; i += 2) {
					// both box models exclude margin, so add it if we want it
					if (extra === "margin") {
						// we use JQXLite.css instead of curCSS here
						// because of the reliableMarginRight CSS hook!
						val += JQXLite.css(elem, extra + cssExpand[i], true);
					}

					// From this point on we use curCSS for maximum performance (relevant in animations)
					if (isBorderBox) {
						// border-box includes padding, so remove it if we want content
						if (extra === "content") {
							val -= parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0;
						}

						// at this point, extra isn't border nor margin, so remove border
						if (extra !== "margin") {
							val -= parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
						}
					} else {
						// at this point, extra isn't content, so add padding
						val += parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0;

						// at this point, extra isn't content nor padding, so add border
						if (extra !== "padding") {
							val += parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
						}
					}
				}

				return val;
			}

			function getWidthOrHeight(elem, name, extra) {

				// Start with offset property, which is equivalent to the border-box value
				var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
					valueIsBorderBox = true,
					isBorderBox = JQXLite.support.boxSizing && JQXLite.css(elem, "boxSizing") === "border-box";

				// some non-html elements return undefined for offsetWidth, so check for null/undefined
				// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
				// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
				if (val <= 0 || val == null) {
					// Fall back to computed then uncomputed css if necessary
					val = curCSS(elem, name);
					if (val < 0 || val == null) {
						val = elem.style[name];
					}

					// Computed unit is not pixels. Stop here and return.
					if (rnumnonpx.test(val)) {
						return val;
					}

					// we need the check for style in case a browser which returns unreliable values
					// for getComputedStyle silently falls back to the reliable elem.style
					valueIsBorderBox = isBorderBox && (JQXLite.support.boxSizingReliable || val === elem.style[name]);

					// Normalize "", auto, and prepare for extra
					val = parseFloat(val) || 0;
				}

				// use the active box-sizing model to add/subtract irrelevant styles
				return (val +
					augmentWidthOrHeight(
						elem,
						name,
						extra || (isBorderBox ? "border" : "content"),
						valueIsBorderBox
					)
				) + "px";
			}


			// Try to determine the default display value of an element
			function css_defaultDisplay(nodeName) {
				if (elemdisplay[nodeName]) {
					return elemdisplay[nodeName];
				}

				var elem = JQXLite("<" + nodeName + ">").appendTo(document.body),
					display = elem.css("display");
				elem.remove();

				// If the simple way fails,
				// get element's real default display by attaching it to a temp iframe
				if (display === "none" || display === "") {
					// Use the already-created iframe if possible
					iframe = document.body.appendChild(
						iframe || JQXLite.extend(document.createElement("iframe"), {
							frameBorder: 0,
							width: 0,
							height: 0
						})
					);

					// Create a cacheable copy of the iframe document on first call.
					// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
					// document to it; WebKit & Firefox won't allow reusing the iframe document.
					if (!iframeDoc || !iframe.createElement) {
						iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
						iframeDoc.write("<!doctype html><html><body>");
						iframeDoc.close();
					}

					elem = iframeDoc.body.appendChild(iframeDoc.createElement(nodeName));

					display = curCSS(elem, "display");
					document.body.removeChild(iframe);
				}

				// Store the correct default display
				elemdisplay[nodeName] = display;

				return display;
			}

			JQXLite.each(["height", "width"], function (i, name) {
				JQXLite.cssHooks[name] = {
					get: function (elem, computed, extra) {
						if (computed) {
							// certain elements can have dimension info if we invisibly show them
							// however, it must have a current display style that would benefit from this
							if (elem.offsetWidth === 0 && rdisplayswap.test(curCSS(elem, "display"))) {
								return JQXLite.swap(elem, cssShow, function () {
									return getWidthOrHeight(elem, name, extra);
								});
							} else {
								return getWidthOrHeight(elem, name, extra);
							}
						}
					},

					set: function (elem, value, extra) {
						return setPositiveNumber(elem, value, extra ?
							augmentWidthOrHeight(
								elem,
								name,
								extra,
								JQXLite.support.boxSizing && JQXLite.css(elem, "boxSizing") === "border-box"
							) : 0
						);
					}
				};
			});

			if (!JQXLite.support.opacity) {
				JQXLite.cssHooks.opacity = {
					get: function (elem, computed) {
						// IE uses filters for opacity
						return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
							(0.01 * parseFloat(RegExp.$1)) + "" :
							computed ? "1" : "";
					},

					set: function (elem, value) {
						var style = elem.style,
							currentStyle = elem.currentStyle,
							opacity = JQXLite.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
							filter = currentStyle && currentStyle.filter || style.filter || "";

						// IE has trouble with opacity if it does not have layout
						// Force it by setting the zoom level
						style.zoom = 1;

						// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
						if (value >= 1 && JQXLite.trim(filter.replace(ralpha, "")) === "" &&
							style.removeAttribute) {

							// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
							// if "filter:" is present at all, clearType is disabled, we want to avoid this
							// style.removeAttribute is IE Only, but so apparently is this code path...
							style.removeAttribute("filter");

							// if there there is no filter style applied in a css rule, we are done
							if (currentStyle && !currentStyle.filter) {
								return;
							}
						}

						// otherwise, set new filter values
						style.filter = ralpha.test(filter) ?
							filter.replace(ralpha, opacity) :
							filter + " " + opacity;
					}
				};
			}

			// These hooks cannot be added until DOM ready because the support test
			// for it is not run until after DOM ready
			JQXLite(function () {
				if (!JQXLite.support.reliableMarginRight) {
					JQXLite.cssHooks.marginRight = {
						get: function (elem, computed) {
							// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
							// Work around by temporarily setting element display to inline-block
							return JQXLite.swap(elem, { "display": "inline-block" }, function () {
								if (computed) {
									return curCSS(elem, "marginRight");
								}
							});
						}
					};
				}

				// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
				// getComputedStyle returns percent when specified for top/left/bottom/right
				// rather than make the css module depend on the offset module, we just check for it here
				if (!JQXLite.support.pixelPosition && JQXLite.fn.position) {
					JQXLite.each(["top", "left"], function (i, prop) {
						JQXLite.cssHooks[prop] = {
							get: function (elem, computed) {
								if (computed) {
									var ret = curCSS(elem, prop);
									// if curCSS returns percentage, fallback to offset
									return rnumnonpx.test(ret) ? JQXLite(elem).position()[prop] + "px" : ret;
								}
							}
						};
					});
				}

			});

			if (JQXLite.expr && JQXLite.expr.filters) {
				JQXLite.expr.filters.hidden = function (elem) {
					return (elem.offsetWidth === 0 && elem.offsetHeight === 0) || (!JQXLite.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS(elem, "display")) === "none");
				};

				JQXLite.expr.filters.visible = function (elem) {
					return !JQXLite.expr.filters.hidden(elem);
				};
			}

			// These hooks are used by animate to expand properties
			JQXLite.each({
				margin: "",
				padding: "",
				border: "Width"
			}, function (prefix, suffix) {
				JQXLite.cssHooks[prefix + suffix] = {
					expand: function (value) {
						var i,

							// assumes a single number if not a string
							parts = typeof value === "string" ? value.split(" ") : [value],
							expanded = {};

						for (i = 0; i < 4; i++) {
							expanded[prefix + cssExpand[i] + suffix] =
								parts[i] || parts[i - 2] || parts[0];
						}

						return expanded;
					}
				};

				if (!rmargin.test(prefix)) {
					JQXLite.cssHooks[prefix + suffix].set = setPositiveNumber;
				}
			});
			var r20 = /%20/g,
				rbracket = /\[\]$/,
				rCRLF = /\r?\n/g,
				rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
				rselectTextarea = /^(?:select|textarea)/i;

			JQXLite.fn.extend({
				serialize: function () {
					return JQXLite.param(this.serializeArray());
				},
				serializeArray: function () {
					return this.map(function () {
						return this.elements ? JQXLite.makeArray(this.elements) : this;
					})
						.filter(function () {
							return this.name && !this.disabled &&
								(this.checked || rselectTextarea.test(this.nodeName) ||
									rinput.test(this.type));
						})
						.map(function (i, elem) {
							var val = JQXLite(this).val();

							return val == null ?
								null :
								JQXLite.isArray(val) ?
									JQXLite.map(val, function (val, i) {
										return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
									}) :
									{ name: elem.name, value: val.replace(rCRLF, "\r\n") };
						}).get();
				}
			});

			//Serialize an array of form elements or a set of
			//key/values into a query string
			JQXLite.param = function (a, traditional) {
				var prefix,
					s = [],
					add = function (key, value) {
						// If value is a function, invoke it and return its value
						value = JQXLite.isFunction(value) ? value() : (value == null ? "" : value);
						s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
					};

				// Set traditional to true for JQXLite <= 1.3.2 behavior.
				if (traditional === undefined) {
					traditional = JQXLite.ajaxSettings && JQXLite.ajaxSettings.traditional;
				}

				// If an array was passed in, assume that it is an array of form elements.
				if (JQXLite.isArray(a) || (a.jqx && !JQXLite.isPlainObject(a))) {
					// Serialize the form elements
					JQXLite.each(a, function () {
						add(this.name, this.value);
					});

				} else {
					// If traditional, encode the "old" way (the way 1.3.2 or older
					// did it), otherwise encode params recursively.
					for (prefix in a) {
						buildParams(prefix, a[prefix], traditional, add);
					}
				}

				// Return the resulting serialization
				return s.join("&").replace(r20, "+");
			};

			function buildParams(prefix, obj, traditional, add) {
				var name;

				if (JQXLite.isArray(obj)) {
					// Serialize array item.
					JQXLite.each(obj, function (i, v) {
						if (traditional || rbracket.test(prefix)) {
							// Treat each array item as a scalar.
							add(prefix, v);

						} else {
							// If array item is non-scalar (array or object), encode its
							// numeric index to resolve deserialization ambiguity issues.
							// Note that rack (as of 1.0.0) can't currently deserialize
							// nested arrays properly, and attempting to do so may cause
							// a server error. Possible fixes are to modify rack's
							// deserialization algorithm or to provide an option or flag
							// to force array serialization to be shallow.
							buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
						}
					});

				} else if (!traditional && JQXLite.type(obj) === "object") {
					// Serialize object item.
					for (name in obj) {
						buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
					}

				} else {
					// Serialize scalar item.
					add(prefix, obj);
				}
			}


			// Create transport if the browser can provide an xhr
			if (JQXLite.support.ajax) {

				JQXLite.ajaxTransport(function (s) {
					// Cross domain only allowed if supported through XMLHttpRequest
					if (!s.crossDomain || JQXLite.support.cors) {

						var callback;

						return {
							send: function (headers, complete) {

								// Get a new xhr
								var handle, i,
									xhr = s.xhr();

								// Open the socket
								// Passing null username, generates a login popup on Opera (#2865)
								if (s.username) {
									xhr.open(s.type, s.url, s.async, s.username, s.password);
								} else {
									xhr.open(s.type, s.url, s.async);
								}

								// Apply custom fields if provided
								if (s.xhrFields) {
									for (i in s.xhrFields) {
										xhr[i] = s.xhrFields[i];
									}
								}

								// Override mime type if needed
								if (s.mimeType && xhr.overrideMimeType) {
									xhr.overrideMimeType(s.mimeType);
								}

								// X-Requested-With header
								// For cross-domain requests, seeing as conditions for a preflight are
								// akin to a jigsaw puzzle, we simply never set it to be sure.
								// (it can always be set on a per-request basis or even using ajaxSetup)
								// For same-domain requests, won't change header if already provided.
								if (!s.crossDomain && !headers["X-Requested-With"]) {
									headers["X-Requested-With"] = "XMLHttpRequest";
								}

								// Need an extra try/catch for cross domain requests in Firefox 3
								try {
									for (i in headers) {
										xhr.setRequestHeader(i, headers[i]);
									}
								} catch (_) { }

								// Do send the request
								// This may raise an exception which is actually
								// handled in JQXLite.ajax (so no try/catch here)
								xhr.send((s.hasContent && s.data) || null);

								// Listener
								callback = function (_, isAbort) {

									var status,
										statusText,
										responseHeaders,
										responses,
										xml;

									// Firefox throws exceptions when accessing properties
									// of an xhr when a network error occurred
									// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
									try {

										// Was never called and is aborted or complete
										if (callback && (isAbort || xhr.readyState === 4)) {

											// Only called once
											callback = undefined;

											// Do not keep as active anymore
											if (handle) {
												xhr.onreadystatechange = JQXLite.noop;
												if (xhrOnUnloadAbort) {
													delete xhrCallbacks[handle];
												}
											}

											// If it's an abort
											if (isAbort) {
												// Abort it manually if needed
												if (xhr.readyState !== 4) {
													xhr.abort();
												}
											} else {
												status = xhr.status;
												responseHeaders = xhr.getAllResponseHeaders();
												responses = {};
												xml = xhr.responseXML;

												// Construct response list
												if (xml && xml.documentElement /* #4958 */) {
													responses.xml = xml;
												}

												// When requesting binary data, IE6-9 will throw an exception
												// on any attempt to access responseText (#11426)
												try {
													responses.text = xhr.responseText;
												} catch (e) {
												}

												// Firefox throws an exception when accessing
												// statusText for faulty cross-domain requests
												try {
													statusText = xhr.statusText;
												} catch (e) {
													// We normalize with Webkit giving an empty statusText
													statusText = "";
												}

												// Filter status for non standard behaviors

												// If the request is local and we have data: assume a success
												// (success with no data won't get notified, that's the best we
												// can do given current implementations)
												if (!status && s.isLocal && !s.crossDomain) {
													status = responses.text ? 200 : 404;
													// IE - #1450: sometimes returns 1223 when it should be 204
												} else if (status === 1223) {
													status = 204;
												}
											}
										}
									} catch (firefoxAccessException) {
										if (!isAbort) {
											complete(-1, firefoxAccessException);
										}
									}

									// Call complete if needed
									if (responses) {
										complete(status, statusText, responses, responseHeaders);
									}
								};

								if (!s.async) {
									// if we're in sync mode we fire the callback
									callback();
								} else if (xhr.readyState === 4) {
									// (IE6 & IE7) if it's in cache and has been
									// retrieved directly we need to fire the callback
									setTimeout(callback, 0);
								} else {
									handle = ++xhrId;
									if (xhrOnUnloadAbort) {
										// Create the active xhrs callbacks list if needed
										// and attach the unload handler
										if (!xhrCallbacks) {
											xhrCallbacks = {};
											JQXLite(window).unload(xhrOnUnloadAbort);
										}
										// Add to list of active xhrs callbacks
										xhrCallbacks[handle] = callback;
									}
									xhr.onreadystatechange = callback;
								}
							},

							abort: function () {
								if (callback) {
									callback(0, 1);
								}
							}
						};
					}
				});
			}
			var fxNow, timerId,
				rfxtypes = /^(?:toggle|show|hide)$/,
				rfxnum = new RegExp("^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i"),
				rrun = /queueHooks$/,
				animationPrefilters = [defaultPrefilter],
				tweeners = {
					"*": [function (prop, value) {
						var end, unit,
							tween = this.createTween(prop, value),
							parts = rfxnum.exec(value),
							target = tween.cur(),
							start = +target || 0,
							scale = 1,
							maxIterations = 20;

						if (parts) {
							end = +parts[2];
							unit = parts[3] || (JQXLite.cssNumber[prop] ? "" : "px");

							// We need to compute starting value
							if (unit !== "px" && start) {
								// Iteratively approximate from a nonzero starting point
								// Prefer the current property, because this process will be trivial if it uses the same units
								// Fallback to end or a simple constant
								start = JQXLite.css(tween.elem, prop, true) || end || 1;

								do {
									// If previous iteration zeroed out, double until we get *something*
									// Use a string for doubling factor so we don't accidentally see scale as unchanged below
									scale = scale || ".5";

									// Adjust and apply
									start = start / scale;
									JQXLite.style(tween.elem, prop, start + unit);

									// Update scale, tolerating zero or NaN from tween.cur()
									// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
								} while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
							}

							tween.unit = unit;
							tween.start = start;
							// If a +=/-= token was provided, we're doing a relative animation
							tween.end = parts[1] ? start + (parts[1] + 1) * end : end;
						}
						return tween;
					}]
				};

			// Animations created synchronously will run synchronously
			function createFxNow() {
				setTimeout(function () {
					fxNow = undefined;
				}, 0);
				return (fxNow = JQXLite.now());
			}

			function createTweens(animation, props) {
				JQXLite.each(props, function (prop, value) {
					var collection = (tweeners[prop] || []).concat(tweeners["*"]),
						index = 0,
						length = collection.length;
					for (; index < length; index++) {
						if (collection[index].call(animation, prop, value)) {

							// we're done with this property
							return;
						}
					}
				});
			}

			function Animation(elem, properties, options) {
				var result,
					index = 0,
					tweenerIndex = 0,
					length = animationPrefilters.length,
					deferred = JQXLite.Deferred().always(function () {
						// don't match elem in the :animated selector
						delete tick.elem;
					}),
					tick = function () {
						var currentTime = fxNow || createFxNow(),
							remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
							// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
							temp = remaining / animation.duration || 0,
							percent = 1 - temp,
							index = 0,
							length = animation.tweens.length;

						for (; index < length; index++) {
							animation.tweens[index].run(percent);
						}

						deferred.notifyWith(elem, [animation, percent, remaining]);

						if (percent < 1 && length) {
							return remaining;
						} else {
							deferred.resolveWith(elem, [animation]);
							return false;
						}
					},
					animation = deferred.promise({
						elem: elem,
						props: JQXLite.extend({}, properties),
						opts: JQXLite.extend(true, { specialEasing: {} }, options),
						originalProperties: properties,
						originalOptions: options,
						startTime: fxNow || createFxNow(),
						duration: options.duration,
						tweens: [],
						createTween: function (prop, end, easing) {
							var tween = JQXLite.Tween(elem, animation.opts, prop, end,
								animation.opts.specialEasing[prop] || animation.opts.easing);
							animation.tweens.push(tween);
							return tween;
						},
						stop: function (gotoEnd) {
							var index = 0,
								// if we are going to the end, we want to run all the tweens
								// otherwise we skip this part
								length = gotoEnd ? animation.tweens.length : 0;

							for (; index < length; index++) {
								animation.tweens[index].run(1);
							}

							// resolve when we played the last frame
							// otherwise, reject
							if (gotoEnd) {
								deferred.resolveWith(elem, [animation, gotoEnd]);
							} else {
								deferred.rejectWith(elem, [animation, gotoEnd]);
							}
							return this;
						}
					}),
					props = animation.props;

				propFilter(props, animation.opts.specialEasing);

				for (; index < length; index++) {
					result = animationPrefilters[index].call(animation, elem, props, animation.opts);
					if (result) {
						return result;
					}
				}

				createTweens(animation, props);

				if (JQXLite.isFunction(animation.opts.start)) {
					animation.opts.start.call(elem, animation);
				}

				JQXLite.fx.timer(
					JQXLite.extend(tick, {
						anim: animation,
						queue: animation.opts.queue,
						elem: elem
					})
				);

				// attach callbacks from options
				return animation.progress(animation.opts.progress)
					.done(animation.opts.done, animation.opts.complete)
					.fail(animation.opts.fail)
					.always(animation.opts.always);
			}

			function propFilter(props, specialEasing) {
				var index, name, easing, value, hooks;

				// camelCase, specialEasing and expand cssHook pass
				for (index in props) {
					name = JQXLite.camelCase(index);
					easing = specialEasing[name];
					value = props[index];
					if (JQXLite.isArray(value)) {
						easing = value[1];
						value = props[index] = value[0];
					}

					if (index !== name) {
						props[name] = value;
						delete props[index];
					}

					hooks = JQXLite.cssHooks[name];
					if (hooks && "expand" in hooks) {
						value = hooks.expand(value);
						delete props[name];

						// not quite $.extend, this wont overwrite keys already present.
						// also - reusing 'index' from above because we have the correct "name"
						for (index in value) {
							if (!(index in props)) {
								props[index] = value[index];
								specialEasing[index] = easing;
							}
						}
					} else {
						specialEasing[name] = easing;
					}
				}
			}

			JQXLite.Animation = JQXLite.extend(Animation, {

				tweener: function (props, callback) {
					if (JQXLite.isFunction(props)) {
						callback = props;
						props = ["*"];
					} else {
						props = props.split(" ");
					}

					var prop,
						index = 0,
						length = props.length;

					for (; index < length; index++) {
						prop = props[index];
						tweeners[prop] = tweeners[prop] || [];
						tweeners[prop].unshift(callback);
					}
				},

				prefilter: function (callback, prepend) {
					if (prepend) {
						animationPrefilters.unshift(callback);
					} else {
						animationPrefilters.push(callback);
					}
				}
			});

			function defaultPrefilter(elem, props, opts) {
				var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
					anim = this,
					style = elem.style,
					orig = {},
					handled = [],
					hidden = elem.nodeType && isHidden(elem);

				// handle queue: false promises
				if (!opts.queue) {
					hooks = JQXLite._queueHooks(elem, "fx");
					if (hooks.unqueued == null) {
						hooks.unqueued = 0;
						oldfire = hooks.empty.fire;
						hooks.empty.fire = function () {
							if (!hooks.unqueued) {
								oldfire();
							}
						};
					}
					hooks.unqueued++;

					anim.always(function () {
						// doing this makes sure that the complete handler will be called
						// before this completes
						anim.always(function () {
							hooks.unqueued--;
							if (!JQXLite.queue(elem, "fx").length) {
								hooks.empty.fire();
							}
						});
					});
				}

				// height/width overflow pass
				if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opts.overflow = [style.overflow, style.overflowX, style.overflowY];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if (JQXLite.css(elem, "display") === "inline" &&
						JQXLite.css(elem, "float") === "none") {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if (!JQXLite.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName) === "inline") {
							style.display = "inline-block";

						} else {
							style.zoom = 1;
						}
					}
				}

				if (opts.overflow) {
					style.overflow = "hidden";
					if (!JQXLite.support.shrinkWrapBlocks) {
						anim.done(function () {
							style.overflow = opts.overflow[0];
							style.overflowX = opts.overflow[1];
							style.overflowY = opts.overflow[2];
						});
					}
				}


				// show/hide pass
				for (index in props) {
					value = props[index];
					if (rfxtypes.exec(value)) {
						delete props[index];
						toggle = toggle || value === "toggle";
						if (value === (hidden ? "hide" : "show")) {
							continue;
						}
						handled.push(index);
					}
				}

				length = handled.length;
				if (length) {
					dataShow = JQXLite._data(elem, "fxshow") || JQXLite._data(elem, "fxshow", {});
					if ("hidden" in dataShow) {
						hidden = dataShow.hidden;
					}

					// store state if its toggle - enables .stop().toggle() to "reverse"
					if (toggle) {
						dataShow.hidden = !hidden;
					}
					if (hidden) {
						JQXLite(elem).show();
					} else {
						anim.done(function () {
							JQXLite(elem).hide();
						});
					}
					anim.done(function () {
						var prop;
						JQXLite.removeData(elem, "fxshow", true);
						for (prop in orig) {
							JQXLite.style(elem, prop, orig[prop]);
						}
					});
					for (index = 0; index < length; index++) {
						prop = handled[index];
						tween = anim.createTween(prop, hidden ? dataShow[prop] : 0);
						orig[prop] = dataShow[prop] || JQXLite.style(elem, prop);

						if (!(prop in dataShow)) {
							dataShow[prop] = tween.start;
							if (hidden) {
								tween.end = tween.start;
								tween.start = prop === "width" || prop === "height" ? 1 : 0;
							}
						}
					}
				}
			}

			function Tween(elem, options, prop, end, easing) {
				return new Tween.prototype.init(elem, options, prop, end, easing);
			}
			JQXLite.Tween = Tween;

			Tween.prototype = {
				constructor: Tween,
				init: function (elem, options, prop, end, easing, unit) {
					this.elem = elem;
					this.prop = prop;
					this.easing = easing || "swing";
					this.options = options;
					this.start = this.now = this.cur();
					this.end = end;
					this.unit = unit || (JQXLite.cssNumber[prop] ? "" : "px");
				},
				cur: function () {
					var hooks = Tween.propHooks[this.prop];

					return hooks && hooks.get ?
						hooks.get(this) :
						Tween.propHooks._default.get(this);
				},
				run: function (percent) {
					var eased,
						hooks = Tween.propHooks[this.prop];

					if (this.options.duration) {
						this.pos = eased = JQXLite.easing[this.easing](
							percent, this.options.duration * percent, 0, 1, this.options.duration
						);
					} else {
						this.pos = eased = percent;
					}
					this.now = (this.end - this.start) * eased + this.start;

					if (this.options.step) {
						this.options.step.call(this.elem, this.now, this);
					}

					if (hooks && hooks.set) {
						hooks.set(this);
					} else {
						Tween.propHooks._default.set(this);
					}
					return this;
				}
			};

			Tween.prototype.init.prototype = Tween.prototype;

			Tween.propHooks = {
				_default: {
					get: function (tween) {
						var result;

						if (tween.elem[tween.prop] != null &&
							(!tween.elem.style || tween.elem.style[tween.prop] == null)) {
							return tween.elem[tween.prop];
						}

						// passing any value as a 4th parameter to .css will automatically
						// attempt a parseFloat and fallback to a string if the parse fails
						// so, simple values such as "10px" are parsed to Float.
						// complex values such as "rotate(1rad)" are returned as is.
						result = JQXLite.css(tween.elem, tween.prop, false, "");
						// Empty strings, null, undefined and "auto" are converted to 0.
						return !result || result === "auto" ? 0 : result;
					},
					set: function (tween) {
						// use step hook for back compat - use cssHook if its there - use .style if its
						// available and use plain properties where available
						if (JQXLite.fx.step[tween.prop]) {
							JQXLite.fx.step[tween.prop](tween);
						} else if (tween.elem.style && (tween.elem.style[JQXLite.cssProps[tween.prop]] != null || JQXLite.cssHooks[tween.prop])) {
							JQXLite.style(tween.elem, tween.prop, tween.now + tween.unit);
						} else {
							tween.elem[tween.prop] = tween.now;
						}
					}
				}
			};

			// Remove in 2.0 - this supports IE8's panic based approach
			// to setting things on disconnected nodes

			Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
				set: function (tween) {
					if (tween.elem.nodeType && tween.elem.parentNode) {
						tween.elem[tween.prop] = tween.now;
					}
				}
			};

			JQXLite.each(["toggle", "show", "hide"], function (i, name) {
				var cssFn = JQXLite.fn[name];
				JQXLite.fn[name] = function (speed, easing, callback) {
					return speed == null || typeof speed === "boolean" ||
						// special check for .toggle( handler, handler, ... )
						(!i && JQXLite.isFunction(speed) && JQXLite.isFunction(easing)) ?
						cssFn.apply(this, arguments) :
						this.animate(genFx(name, true), speed, easing, callback);
				};
			});

			JQXLite.fn.extend({
				fadeTo: function (speed, to, easing, callback) {

					// show any hidden elements after setting opacity to 0
					return this.filter(isHidden).css("opacity", 0).show()

						// animate to the value specified
						.end().animate({ opacity: to }, speed, easing, callback);
				},
				animate: function (prop, speed, easing, callback) {
					var empty = JQXLite.isEmptyObject(prop),
						optall = JQXLite.speed(speed, easing, callback),
						doAnimation = function () {
							// Operate on a copy of prop so per-property easing won't be lost
							var anim = Animation(this, JQXLite.extend({}, prop), optall);

							// Empty animations resolve immediately
							if (empty) {
								anim.stop(true);
							}
						};

					return empty || optall.queue === false ?
						this.each(doAnimation) :
						this.queue(optall.queue, doAnimation);
				},
				stop: function (type, clearQueue, gotoEnd) {
					var stopQueue = function (hooks) {
						var stop = hooks.stop;
						delete hooks.stop;
						stop(gotoEnd);
					};

					if (typeof type !== "string") {
						gotoEnd = clearQueue;
						clearQueue = type;
						type = undefined;
					}
					if (clearQueue && type !== false) {
						this.queue(type || "fx", []);
					}

					return this.each(function () {
						var dequeue = true,
							index = type != null && type + "queueHooks",
							timers = JQXLite.timers,
							data = JQXLite._data(this);

						if (index) {
							if (data[index] && data[index].stop) {
								stopQueue(data[index]);
							}
						} else {
							for (index in data) {
								if (data[index] && data[index].stop && rrun.test(index)) {
									stopQueue(data[index]);
								}
							}
						}

						for (index = timers.length; index--;) {
							if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
								timers[index].anim.stop(gotoEnd);
								dequeue = false;
								timers.splice(index, 1);
							}
						}

						// start the next in the queue if the last step wasn't forced
						// timers currently will call their complete callbacks, which will dequeue
						// but only if they were gotoEnd
						if (dequeue || !gotoEnd) {
							JQXLite.dequeue(this, type);
						}
					});
				}
			});

			// Generate parameters to create a standard animation
			function genFx(type, includeWidth) {
				var which,
					attrs = { height: type },
					i = 0;

				// if we include width, step value is 1 to do all cssExpand values,
				// if we don't include width, step value is 2 to skip over Left and Right
				includeWidth = includeWidth ? 1 : 0;
				for (; i < 4; i += 2 - includeWidth) {
					which = cssExpand[i];
					attrs["margin" + which] = attrs["padding" + which] = type;
				}

				if (includeWidth) {
					attrs.opacity = attrs.width = type;
				}

				return attrs;
			}

			// Generate shortcuts for custom animations
			JQXLite.each({
				slideDown: genFx("show"),
				slideUp: genFx("hide"),
				slideToggle: genFx("toggle"),
				fadeIn: { opacity: "show" },
				fadeOut: { opacity: "hide" },
				fadeToggle: { opacity: "toggle" }
			}, function (name, props) {
				JQXLite.fn[name] = function (speed, easing, callback) {
					return this.animate(props, speed, easing, callback);
				};
			});

			JQXLite.speed = function (speed, easing, fn) {
				var opt = speed && typeof speed === "object" ? JQXLite.extend({}, speed) : {
					complete: fn || !fn && easing ||
						JQXLite.isFunction(speed) && speed,
					duration: speed,
					easing: fn && easing || easing && !JQXLite.isFunction(easing) && easing
				};

				opt.duration = JQXLite.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
					opt.duration in JQXLite.fx.speeds ? JQXLite.fx.speeds[opt.duration] : JQXLite.fx.speeds._default;

				// normalize opt.queue - true/undefined/null -> "fx"
				if (opt.queue == null || opt.queue === true) {
					opt.queue = "fx";
				}

				// Queueing
				opt.old = opt.complete;

				opt.complete = function () {
					if (JQXLite.isFunction(opt.old)) {
						opt.old.call(this);
					}

					if (opt.queue) {
						JQXLite.dequeue(this, opt.queue);
					}
				};

				return opt;
			};

			JQXLite.easing = {
				linear: function (p) {
					return p;
				},
				swing: function (p) {
					return 0.5 - Math.cos(p * Math.PI) / 2;
				}
			};

			JQXLite.timers = [];
			JQXLite.fx = Tween.prototype.init;
			JQXLite.fx.tick = function () {
				var timer,
					timers = JQXLite.timers,
					i = 0;

				fxNow = JQXLite.now();

				for (; i < timers.length; i++) {
					timer = timers[i];
					// Checks the timer has not already been removed
					if (!timer() && timers[i] === timer) {
						timers.splice(i--, 1);
					}
				}

				if (!timers.length) {
					JQXLite.fx.stop();
				}
				fxNow = undefined;
			};

			JQXLite.fx.timer = function (timer) {
				if (timer() && JQXLite.timers.push(timer) && !timerId) {
					timerId = setInterval(JQXLite.fx.tick, JQXLite.fx.interval);
				}
			};

			JQXLite.fx.interval = 13;

			JQXLite.fx.stop = function () {
				clearInterval(timerId);
				timerId = null;
			};

			JQXLite.fx.speeds = {
				slow: 600,
				fast: 200,
				// Default speed
				_default: 400
			};

			// Back Compat <1.8 extension point
			JQXLite.fx.step = {};

			if (JQXLite.expr && JQXLite.expr.filters) {
				JQXLite.expr.filters.animated = function (elem) {
					return JQXLite.grep(JQXLite.timers, function (fn) {
						return elem === fn.elem;
					}).length;
				};
			}
			var rroot = /^(?:body|html)$/i;

			JQXLite.fn.offset = function (options) {
				if (arguments.length) {
					return options === undefined ?
						this :
						this.each(function (i) {
							JQXLite.offset.setOffset(this, options, i);
						});
				}

				var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
					box = { top: 0, left: 0 },
					elem = this[0],
					doc = elem && elem.ownerDocument;

				if (!doc) {
					return;
				}

				if ((body = doc.body) === elem) {
					return JQXLite.offset.bodyOffset(elem);
				}

				docElem = doc.documentElement;

				// Make sure it's not a disconnected DOM node
				if (!JQXLite.contains(docElem, elem)) {
					return box;
				}

				// If we don't have gBCR, just use 0,0 rather than error
				// BlackBerry 5, iOS 3 (original iPhone)
				if (typeof elem.getBoundingClientRect !== "undefined") {
					box = elem.getBoundingClientRect();
				}
				win = getWindow(doc);
				clientTop = docElem.clientTop || body.clientTop || 0;
				clientLeft = docElem.clientLeft || body.clientLeft || 0;
				scrollTop = win.pageYOffset || docElem.scrollTop;
				scrollLeft = win.pageXOffset || docElem.scrollLeft;
				return {
					top: box.top + scrollTop - clientTop,
					left: box.left + scrollLeft - clientLeft
				};
			};

			JQXLite.offset = {

				bodyOffset: function (body) {
					var top = body.offsetTop,
						left = body.offsetLeft;

					if (JQXLite.support.doesNotIncludeMarginInBodyOffset) {
						top += parseFloat(JQXLite.css(body, "marginTop")) || 0;
						left += parseFloat(JQXLite.css(body, "marginLeft")) || 0;
					}

					return { top: top, left: left };
				},

				setOffset: function (elem, options, i) {
					var position = JQXLite.css(elem, "position");

					// set position first, in-case top/left are set even on static elem
					if (position === "static") {
						elem.style.position = "relative";
					}

					var curElem = JQXLite(elem),
						curOffset = curElem.offset(),
						curCSSTop = JQXLite.css(elem, "top"),
						curCSSLeft = JQXLite.css(elem, "left"),
						calculatePosition = (position === "absolute" || position === "fixed") && JQXLite.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
						props = {}, curPosition = {}, curTop, curLeft;

					// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
					if (calculatePosition) {
						curPosition = curElem.position();
						curTop = curPosition.top;
						curLeft = curPosition.left;
					} else {
						curTop = parseFloat(curCSSTop) || 0;
						curLeft = parseFloat(curCSSLeft) || 0;
					}

					if (JQXLite.isFunction(options)) {
						options = options.call(elem, i, curOffset);
					}

					if (options.top != null) {
						props.top = (options.top - curOffset.top) + curTop;
					}
					if (options.left != null) {
						props.left = (options.left - curOffset.left) + curLeft;
					}

					if ("using" in options) {
						options.using.call(elem, props);
					} else {
						curElem.css(props);
					}
				}
			};


			JQXLite.fn.extend({
				isRendered: function () {
					var that = this;
					var element = this[0];
					if (element.parentNode == null || (element.offsetWidth === 0 || element.offsetHeight === 0)) {
						return false;
					}

					return true;
				},

				getSizeFromStyle: function () {
					var that = this;
					var width = null;
					var height = null;
					var element = this[0];
					var computedStyle;

					if (element.style.width) {
						width = element.style.width;
					}
					if (element.style.height) {
						height = element.style.height;
					}

					if (window.getComputedStyle) {
						computedStyle = getComputedStyle(element, null);
					}
					else {
						computedStyle = element.currentStyle;
					}

					if (computedStyle) {
						if (computedStyle.width) {
							width = computedStyle.width;
						}
						if (computedStyle.height) {
							height = computedStyle.height;
						}
					}
					if (width === '0px') width = 0;
					if (height === '0px') height = 0;
					if (width === null) width = 0;
					if (height === null) height = 0;

					return { width: width, height: height };
				},

				initAnimate: function () {

				},

				sizeStyleChanged: function (resizeFn) {
					var that = this;

					var watchedElementData;

					var checkForChanges = function (mutations) {
						var data = watchedElementData;
						if (mutations && mutations[0] && mutations[0].attributeName === 'style' && mutations[0].type === 'attributes') {
							if (data.element.offsetWidth !== data.offsetWidth ||
								data.element.offsetHeight !== data.offsetHeight) {
								data.offsetWidth = data.element.offsetWidth;
								data.offsetHeight = data.element.offsetHeight;
								if (that.isRendered()) {
									data.callback();
								}
							}
						}
					}

					watchedElementData = {
						element: that[0],
						offsetWidth: that[0].offsetWidth,
						offsetHeight: that[0].offsetHeight,
						callback: resizeFn
					};

					try {
						if (!that.elementStyleObserver) {
							that.elementStyleObserver = new MutationObserver(checkForChanges);
							that.elementStyleObserver.observe(that[0], {
								attributes: true,
								childList: false,
								characterData: false
							});

						}
					}
					catch (error) { }
				},

				position: function () {
					if (!this[0]) {
						return;
					}

					var elem = this[0],

						// Get *real* offsetParent
						offsetParent = this.offsetParent(),

						// Get correct offsets
						offset = this.offset(),
						parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

					// Subtract element margins
					// note: when an element has margin: auto the offsetLeft and marginLeft
					// are the same in Safari causing offset.left to incorrectly be 0
					offset.top -= parseFloat(JQXLite.css(elem, "marginTop")) || 0;
					offset.left -= parseFloat(JQXLite.css(elem, "marginLeft")) || 0;

					// Add offsetParent borders
					parentOffset.top += parseFloat(JQXLite.css(offsetParent[0], "borderTopWidth")) || 0;
					parentOffset.left += parseFloat(JQXLite.css(offsetParent[0], "borderLeftWidth")) || 0;

					// Subtract the two offsets
					return {
						top: offset.top - parentOffset.top,
						left: offset.left - parentOffset.left
					};
				},

				offsetParent: function () {
					return this.map(function () {
						var offsetParent = this.offsetParent || document.body;
						while (offsetParent && (!rroot.test(offsetParent.nodeName) && JQXLite.css(offsetParent, "position") === "static")) {
							offsetParent = offsetParent.offsetParent;
						}
						return offsetParent || document.body;
					});
				}
			});
			// Create scrollLeft and scrollTop methods
			JQXLite.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
				var top = /Y/.test(prop);

				JQXLite.fn[method] = function (val) {
					return JQXLite.access(this, function (elem, method, val) {
						var win = getWindow(elem);

						if (val === undefined) {
							return win ? (prop in win) ? win[prop] :
								win.document.documentElement[method] :
								elem[method];
						}

						if (win) {
							win.scrollTo(
								!top ? val : JQXLite(win).scrollLeft(),
								top ? val : JQXLite(win).scrollTop()
							);

						} else {
							elem[method] = val;
						}
					}, method, val, arguments.length, null);
				};
			});

			function getWindow(elem) {
				return JQXLite.isWindow(elem) ?
					elem :
					elem.nodeType === 9 ?
						elem.defaultView || elem.parentWindow :
						false;
			}
			// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
			JQXLite.each({ Height: "height", Width: "width" }, function (name, type) {
				JQXLite.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {
					// margin is only for outerHeight, outerWidth
					JQXLite.fn[funcName] = function (margin, value) {
						var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
							extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

						return JQXLite.access(this, function (elem, type, value) {
							var doc;

							if (JQXLite.isWindow(elem)) {
								// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
								// isn't a whole lot we can do. See pull request at this URL for discussion:
								// https://github.com/jqx/jqx/pull/764
								return elem.document.documentElement["client" + name];
							}

							// Get document width or height
							if (elem.nodeType === 9) {
								doc = elem.documentElement;

								// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
								// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
								return Math.max(
									elem.body["scroll" + name], doc["scroll" + name],
									elem.body["offset" + name], doc["offset" + name],
									doc["client" + name]
								);
							}

							return value === undefined ?
								// Get width or height on the element, requesting but not forcing parseFloat
								JQXLite.css(elem, type, value, extra) :

								// Set width or height on the element
								JQXLite.style(elem, type, value, extra);
						}, type, chainable ? margin : undefined, chainable, null);
					};
				});
			});
			// Expose JQXLite to the global object
			window.JQXLite = window.jqxHelper = JQXLite;

			// Expose JQXLite as an AMD module, but only for AMD loaders that
			// understand the issues with loading multiple versions of JQXLite
			// in a page that all might call define(). The loader will indicate
			// they have special allowances for multiple JQXLite versions by
			// specifying define.amd.JQXLite = true. Register as a named module,
			// since JQXLite can be concatenated with other files that may use define,
			// but not use a proper concatenation script that understands anonymous
			// AMD modules. A named AMD is safest and most robust way to register.
			// Lowercase jqx is used because AMD module names are derived from
			// file names, and JQXLite is normally delivered in a lowercase file name.
			// Do this after creating the global so that if an AMD module wants to call
			// noConflict to hide this version of JQXLite, it will work.
			if (  true && __nested_webpack_require_484139__.amdO.JQXLite) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () { return JQXLite; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			}

		})(window);
	}

	// jqxHelper
	(function (window) {
		if (window.jqxCore) {
			window.$$ = window.minQuery = window.JQXLite;

			if (!window.$) {
				window.$ = window.minQuery;
			}

			return;
		}

		if (window.jQuery) {
			if (window.jQuery.fn.extend) {
				window.jQuery.fn.stop = window.JQXLite.fn.stop;
				window.jQuery.fn.animate = window.JQXLite.fn.animate;

				var keys = Object.keys(window.JQXLite.fn);
				for (var index in keys) {
					var key = keys[index];
					if (window.jQuery.fn[key] == undefined) {
						window.jQuery.fn[key] = window.JQXLite.fn[key];
					}
				}
			}

			window.minQuery = window.JQXLite = window.jQuery;
			return;
		}

		if (!window.$) {
			window.$ = window.minQuery = window.JQXLite;
		}
		else {
			window.minQuery = window.JQXLite = window.$;
		}
	})(window);
	// End of jqxHelper

	JQXLite.generateID = function () {
		var S4 = function () {
			return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
		};

		var id = "";
		do {
			id = "jqx" + S4() + S4() + S4();
		} while ($('#' + id).length > 0);

		return id;
	}

	var jqxBaseFramework = window.jqxBaseFramework = window.minQuery || window.jQuery;

	(function ($) {

		$.jqx = $.jqx || {}
		window.jqx = $.jqx;

		var jqwidgets = {
			createInstance: function (selector, widgetName, params) {
				if (widgetName == 'jqxDataAdapter') {
					var source = params[0];
					var settings = params[1] || {};
					return new $.jqx.dataAdapter(source, settings);
				}

				$(selector)[widgetName](params || {});
				return $(selector)[widgetName]('getInstance');
			}
		};

		window.jqwidgets = jqwidgets;

		$.jqx.define = function (namespace, classname, baseclass) {
			namespace[classname] = function () {
				if (this.baseType) {
					this.base = new namespace[this.baseType]();
					this.base.defineInstance();
				}
				this.defineInstance();
				this.metaInfo();
			}

			namespace[classname].prototype.defineInstance = function () { };
			namespace[classname].prototype.metaInfo = function () { };
			namespace[classname].prototype.base = null;
			namespace[classname].prototype.baseType = undefined;

			if (baseclass && namespace[baseclass])
				namespace[classname].prototype.baseType = baseclass;
		}

		// method call
		$.jqx.invoke = function (object, args) {
			if (args.length == 0)
				return;

			var method = typeof (args) == Array || args.length > 0 ? args[0] : args;
			var methodArg = typeof (args) == Array || args.length > 1 ? Array.prototype.slice.call(args, 1) : $({}).toArray();

			while (object[method] == undefined && object.base != null) {
				if (object[method] != undefined && $.isFunction(object[method]))
					return object[method].apply(object, methodArg);

				if (typeof method == 'string') {
					var methodLowerCase = method.toLowerCase();
					if (object[methodLowerCase] != undefined && $.isFunction(object[methodLowerCase])) {
						return object[methodLowerCase].apply(object, methodArg);
					}
				}
				object = object.base;
			}

			if (object[method] != undefined && $.isFunction(object[method]))
				return object[method].apply(object, methodArg);

			if (typeof method == 'string') {
				var methodLowerCase = method.toLowerCase();
				if (object[methodLowerCase] != undefined && $.isFunction(object[methodLowerCase])) {
					return object[methodLowerCase].apply(object, methodArg);
				}
			}

			return;
		}

		$.jqx.getByPriority = function (arr) {
			var value = undefined;
			for (var i = 0; i < arr.length && value == undefined; i++) {
				if (value == undefined && arr[i] != undefined)
					value = arr[i];
			}

			return value;
		}

		$.jqx.hasProperty = function (obj, property) {
			if (typeof (property) == 'object') {
				for (var prop in property) {
					var o = obj;
					while (o) {
						if (o.hasOwnProperty(prop))
							return true;
						if (o.hasOwnProperty(prop.toLowerCase()))
							return true;
						o = o.base;
					}
					return false;
				}
			}
			else {
				while (obj) {
					if (obj.hasOwnProperty(property))
						return true;
					if (obj.hasOwnProperty(property.toLowerCase()))
						return true;
					obj = obj.base;
				}
			}

			return false;
		}

		$.jqx.hasFunction = function (object, args) {
			if (args.length == 0)
				return false;

			if (object == undefined)
				return false;

			var method = typeof (args) == Array || args.length > 0 ? args[0] : args;
			var methodArg = typeof (args) == Array || args.length > 1 ? Array.prototype.slice.call(args, 1) : {};

			while (object[method] == undefined && object.base != null) {
				if (object[method] && $.isFunction(object[method]))
					return true;

				if (typeof method == 'string') {
					var methodLowerCase = method.toLowerCase();
					if (object[methodLowerCase] && $.isFunction(object[methodLowerCase]))
						return true;
				}
				object = object.base;
			}

			if (object[method] && $.isFunction(object[method]))
				return true;

			if (typeof method == 'string') {
				var methodLowerCase = method.toLowerCase();
				if (object[methodLowerCase] && $.isFunction(object[methodLowerCase]))
					return true;
			}

			return false;
		}

		$.jqx.isPropertySetter = function (obj, args) {
			if (args.length == 1 && typeof (args[0]) == 'object')
				return true;

			if (args.length == 2 &&
				typeof (args[0]) == 'string' &&
				!$.jqx.hasFunction(obj, args)) {
				return true;
			}

			return false;
		}

		$.jqx.validatePropertySetter = function (obj, args, suppressException) {
			if (!$.jqx.propertySetterValidation)
				return true;

			if (args.length == 1 && typeof (args[0]) == 'object') {
				for (var i in args[0]) {
					var o = obj;
					while (!o.hasOwnProperty(i) && o.base)
						o = o.base;

					if (!o || !o.hasOwnProperty(i)) {
						if (!suppressException) {
							var hasLowerCase = o.hasOwnProperty(i.toString().toLowerCase());
							if (!hasLowerCase) {
								throw 'Invalid property: ' + i;
							}
							else return true;
						}
						return false;
					}
				}

				return true;
			}

			if (args.length != 2) {
				if (!suppressException)
					throw 'Invalid property: ' + args.length >= 0 ? args[0] : '';

				return false;
			}

			while (!obj.hasOwnProperty(args[0]) && obj.base)
				obj = obj.base;

			if (!obj || !obj.hasOwnProperty(args[0])) {
				if (!suppressException)
					throw 'Invalid property: ' + args[0];

				return false;
			}

			return true;
		}

		if (!Object.keys) {
			Object.keys = (function () {
				'use strict';
				var hasOwnProperty = Object.prototype.hasOwnProperty,
					hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),
					dontEnums = [
						'toString',
						'toLocaleString',
						'valueOf',
						'hasOwnProperty',
						'isPrototypeOf',
						'propertyIsEnumerable',
						'constructor'
					],
					dontEnumsLength = dontEnums.length;

				return function (obj) {
					if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
						throw new TypeError('Object.keys called on non-object');
					}

					var result = [], prop, i;

					for (prop in obj) {
						if (hasOwnProperty.call(obj, prop)) {
							result.push(prop);
						}
					}

					if (hasDontEnumBug) {
						for (i = 0; i < dontEnumsLength; i++) {
							if (hasOwnProperty.call(obj, dontEnums[i])) {
								result.push(dontEnums[i]);
							}
						}
					}
					return result;
				};
			}());
		}

		$.jqx.set = function (object, args) {
			var newValuesLength = 0;
			if (args.length == 1 && typeof (args[0]) == 'object') {
				if (object.isInitialized && Object.keys && Object.keys(args[0]).length > 1) {
					var element = !object.base ? object.element : object.base.element;
					var initArgs = $.data(element, object.widgetName).initArgs;
					if (initArgs && JSON && JSON.stringify && args[0] && initArgs[0]) {
						try {
							if (JSON.stringify(args[0]) == JSON.stringify(initArgs[0])) {
								var toReturn = true;
								$.each(args[0], function (key, value) {
									if (object[key] != value) {
										toReturn = false;
										return false;
									}
								});
								if (toReturn) {
									return;
								}
							}
						}
						catch (err) {
						}
					}
					object.batchUpdate = args[0];
					var oldValues = {};
					var newValues = {};
					$.each(args[0], function (key, value) {
						var obj = object;
						while (!obj.hasOwnProperty(key) && obj.base != null)
							obj = obj.base;

						if (obj.hasOwnProperty(key)) {
							if (object[key] != value) {
								oldValues[key] = object[key];
								newValues[key] = value;
								newValuesLength++;
							}
						}
						else if (obj.hasOwnProperty(key.toLowerCase())) {
							if (object[key.toLowerCase()] != value) {
								oldValues[key.toLowerCase()] = object[key.toLowerCase()];
								newValues[key.toLowerCase()] = value;
								newValuesLength++;
							}
						}
					});
					if (newValuesLength < 2) {
						object.batchUpdate = null;
					}
				}

				$.each(args[0], function (key, value) {
					var obj = object;
					while (!obj.hasOwnProperty(key) && obj.base != null)
						obj = obj.base;

					if (obj.hasOwnProperty(key)) {
						$.jqx.setvalueraiseevent(obj, key, value);
					}
					else if (obj.hasOwnProperty(key.toLowerCase())) {
						$.jqx.setvalueraiseevent(obj, key.toLowerCase(), value);
					}
					else if ($.jqx.propertySetterValidation)
						throw "jqxCore: invalid property '" + key + "'";
				});

				if (object.batchUpdate != null) {
					object.batchUpdate = null;
					if (object.propertiesChangedHandler && newValuesLength > 1) {
						object.propertiesChangedHandler(object, oldValues, newValues);
					}
				}
			}
			else if (args.length == 2) {
				while (!object.hasOwnProperty(args[0]) && object.base)
					object = object.base;

				if (object.hasOwnProperty(args[0])) {
					$.jqx.setvalueraiseevent(object, args[0], args[1]);
				}
				else if (object.hasOwnProperty(args[0].toLowerCase())) {
					$.jqx.setvalueraiseevent(object, args[0].toLowerCase(), args[1]);
				}
				else if ($.jqx.propertySetterValidation)
					throw "jqxCore: invalid property '" + args[0] + "'";
			}
		}

		$.jqx.setvalueraiseevent = function (object, key, value) {
			var oldVal = object[key];

			object[key] = value;

			if (!object.isInitialized)
				return;

			if (object.propertyChangedHandler != undefined)
				object.propertyChangedHandler(object, key, oldVal, value);

			if (object.propertyChangeMap != undefined && object.propertyChangeMap[key] != undefined)
				object.propertyChangeMap[key](object, key, oldVal, value);
		};

		$.jqx.get = function (object, args) {
			if (args == undefined || args == null)
				return undefined;

			if (object.propertyMap) {
				var newVal = object.propertyMap(args);
				if (newVal != null)
					return newVal;
			}

			if (object.hasOwnProperty(args))
				return object[args];

			if (object.hasOwnProperty(args.toLowerCase()))
				return object[args.toLowerCase()];

			var arg = undefined;
			if (typeof (args) == Array) {
				if (args.length != 1)
					return undefined;
				arg = args[0];
			}
			else if (typeof (args) == 'string')
				arg = args;

			while (!object.hasOwnProperty(arg) && object.base)
				object = object.base;

			if (object)
				return object[arg];

			return undefined;
		}

		$.jqx.serialize = function (obj) {
			var txt = '';
			if ($.isArray(obj)) {
				txt = '['
				for (var i = 0; i < obj.length; i++) {
					if (i > 0)
						txt += ', ';
					txt += $.jqx.serialize(obj[i]);
				}
				txt += ']';
			}
			else if (typeof (obj) == 'object') {
				txt = '{';
				var j = 0;
				for (var i in obj) {
					if (j++ > 0)
						txt += ', ';
					txt += i + ': ' + $.jqx.serialize(obj[i]);
				}
				txt += '}';
			}
			else
				txt = obj.toString();

			return txt;
		}

		$.jqx.propertySetterValidation = true;

		$.jqx.jqxWidgetProxy = function (controlName, element, args) {
			var host = $(element);
			var vars = $.data(element, controlName);
			if (vars == undefined) {
				return undefined;
			}

			var obj = vars.instance;

			if ($.jqx.hasFunction(obj, args))
				return $.jqx.invoke(obj, args);

			if ($.jqx.isPropertySetter(obj, args)) {
				if ($.jqx.validatePropertySetter(obj, args)) {
					$.jqx.set(obj, args);
					return undefined;
				}
			} else {
				if (typeof (args) == 'object' && args.length == 0)
					return;
				else if (typeof (args) == 'object' && args.length == 1 && $.jqx.hasProperty(obj, args[0]))
					return $.jqx.get(obj, args[0]);
				else if (typeof (args) == 'string' && $.jqx.hasProperty(obj, args[0]))
					return $.jqx.get(obj, args);
			}

			throw "jqxCore: Invalid parameter '" + $.jqx.serialize(args) + "' does not exist.";
			//      return undefined;
		}

		$.jqx.applyWidget = function (element, controlName, args, instance) {
			var WinJS = false;
			try {
				WinJS = window.MSApp != undefined;
			}
			catch (e) {
			}

			var host = $(element);
			if (!instance) {
				instance = new $.jqx['_' + controlName]();
			}
			else {
				instance.host = host;
				instance.element = element;
			}
			if (element.id == "") {
				element.id = $.jqx.utilities.createId();
			}

			var vars = { host: host, element: element, instance: instance, initArgs: args };

			instance.widgetName = controlName;
			$.data(element, controlName, vars);
			$.data(element, 'jqxWidget', vars.instance);

			var inits = new Array();
			var instance = vars.instance;
			while (instance) {
				instance.isInitialized = false;
				inits.push(instance);
				instance = instance.base;
			}
			inits.reverse();
			inits[0].theme = $.jqx.theme || '';

			$.jqx.jqxWidgetProxy(controlName, element, args);

			for (var i in inits) {
				instance = inits[i];
				if (i == 0) {
					instance.host = host;
					instance.element = element;
					instance.WinJS = WinJS;
				}
				if (instance != undefined) {
					if (instance.definedInstance) {
						instance.definedInstance();
					}
					if (instance.createInstance != null) {
						if (WinJS) {
							MSApp.execUnsafeLocalFunction(function () {
								instance.createInstance(args);
							});
						}
						else {
							instance.createInstance(args);
						}
					}
				}
			}

			for (var i in inits) {
				if (inits[i] != undefined) {
					inits[i].isInitialized = true;
				}
			}

			if (WinJS) {
				MSApp.execUnsafeLocalFunction(function () {
					vars.instance.refresh(true);
				});
			}
			else {
				vars.instance.refresh(true);
			}

		}

		$.jqx.jqxWidget = function (name, base, params) {

			var WinJS = false;
			try {
				var jqxArgs = Array.prototype.slice.call(params, 0);
			}
			catch (e) {
				var jqxArgs = '';
			}

			try {
				WinJS = window.MSApp != undefined;
			}
			catch (e) {
			}

			var controlName = name;

			var baseControl = '';
			if (base)
				baseControl = '_' + base;
			$.jqx.define($.jqx, '_' + controlName, baseControl);

			var widgets = new Array();

			if (!window[controlName]) {
				var serializeObject = function (data) {
					if (data == null) return "";
					var dataType = $.type(data);
					switch (dataType) {
						case "string":
						case "number":
						case "date":
						case "boolean":
						case "bool":
							if (data === null)
								return "";
							return data.toString()
					}

					var str = "";
					$.each(data, function (index, value) {
						var val = value;
						if (index > 0) str += ', ';
						str += "[";
						var m = 0;

						if ($.type(val) == "object") {
							for (var obj in val) {
								if (m > 0) str += ', ';
								str += '{' + obj + ":" + val[obj] + '}';
								m++;
							}
						}
						else {
							if (m > 0) str += ', ';
							str += '{' + index + ":" + val + '}';
							m++;
						}

						str += "]";
					});
					return str;
				}

				jqwidgets[controlName] = window[controlName] = function (selector, params) {
					var args = [];
					if (!params) {
						params = {};
					}
					args.push(params);

					var uid = selector;
					if ($.type(uid) === "object" && selector[0]) {
						uid = selector[0].id;
						if (uid === "") {
							uid = selector[0].id = $.jqx.utilities.createId();
						}
					} else if ($.type(selector) === "object" && selector && selector.nodeName) {
						uid = selector.id;
						if (uid === "") {
							uid = selector.id = $.jqx.utilities.createId();
						}
					}

					if (window.jqxWidgets && window.jqxWidgets[uid]) {
						if (params) {
							$.each(window.jqxWidgets[uid], function (index) {
								var data = $(this.element).data();
								if (data && data.jqxWidget) {
									$(this.element)[controlName](params);
								}
							});
						}
						if (window.jqxWidgets[uid].length == 1) {
							var data = $(window.jqxWidgets[uid][0].widgetInstance.element).data();
							if (data && data.jqxWidget) {
								return window.jqxWidgets[uid][0];
							}
						}

						var data = $(window.jqxWidgets[uid][0].widgetInstance.element).data();
						if (data && data.jqxWidget) {
							return window.jqxWidgets[uid];
						}
					}

					var elements = $(selector);
					if (elements.length === 0) {
						elements = $("<div></div>");
						if (controlName === "jqxInput" || controlName === "jqxPasswordInput" || controlName === "jqxMaskedInput") {
							elements = $("<input/>");
						}
						if (controlName === "jqxTextArea") {
							elements = $("<textarea></textarea>");
						}
						if (controlName === "jqxButton" || controlName === "jqxRepeatButton" || controlName === "jqxToggleButton") {
							elements = $("<button/>");
						}
						if (controlName === "jqxSplitter") {
							elements = $("<div><div>Panel 1</div><div>Panel 2</div></div>");
						}
						if (controlName === "jqxTabs") {
							elements = $("<div><ul><li>Tab 1</li><li>Tab 2</li></ul><div>Content 1</div><div>Content 2</div></div>");
						}
						if (controlName === "jqxRibbon") {
							elements = $("<div><ul><li>Tab 1</li><li>Tab 2</li></ul><div><div>Content 1</div><div>Content 2</div></div></div>");
						}
						if (controlName === "jqxDocking") {
							elements = $("<div><div><div><div>Title 1</div><div>Content 1</div></div></div></div>");
						}
						if (controlName === "jqxWindow") {
							elements = $("<div><div>Title 1</div><div>Content 1</div></div>");
						}
					}
					var instances = [];


					$.each(elements, function (index) {
						var element = elements[index];
						$.jqx.applyWidget(element, controlName, args, undefined);
						if (!widgets[controlName]) {
							var instance = $.data(element, 'jqxWidget');
							var properties = $.jqx["_" + controlName].prototype.defineInstance();
							var metaInfo = {};

							if ($.jqx["_" + controlName].prototype.metaInfo) {
								metaInfo = $.jqx["_" + controlName].prototype.metaInfo();
							}

							if (controlName == "jqxDockingLayout") {
								properties = $.extend(properties, $.jqx["_jqxLayout"].prototype.defineInstance());
							}
							if (controlName == "jqxToggleButton" || controlName == "jqxRepeatButton") {
								properties = $.extend(properties, $.jqx["_jqxButton"].prototype.defineInstance());
							}
							if (controlName == "jqxTreeGrid") {
								properties = $.extend(properties, $.jqx["_jqxDataTable"].prototype.defineInstance());
							}

							var widgetConstructor = function (element) {
								var instance = $.data(element, 'jqxWidget');
								this.widgetInstance = instance;
								var widget = $.extend(this, instance);
								widget.on = widget.addEventListener = function (eventName, callback) {
									widget.addHandler(!widget.base ? widget.host : widget.base.host, eventName, callback);
								}
								widget.off = widget.removeEventListener = function (eventName) {
									widget.removeHandler(!widget.base ? widget.host : widget.base.host, eventName);
								}

								for (var obj in instance) {
									if ($.type(instance[obj]) == "function") {
										widget[obj] = $.proxy(instance[obj], instance);
									}
								}
								return widget;
							}
							widgets[controlName] = widgetConstructor;

							// widget properties
							$.each(properties, function (property, currentValue) {
								Object.defineProperty(widgetConstructor.prototype, property, {
									get: function () {
										if (this.widgetInstance) {
											return this.widgetInstance[property];
										}
										return currentValue;
									},
									set: function (newValue) {
										if (this.widgetInstance && (this.widgetInstance[property] != newValue || property === "width" || property === "height")) {
											var key1 = this.widgetInstance[property];
											var key2 = newValue;
											var dataType1 = $.type(key1);
											var dataType2 = $.type(key2);
											var differentTypes = false;
											if (dataType1 != dataType2 || property === "source" || property === "width" || property === "height") {
												differentTypes = true;
											}
											if (differentTypes || (serializeObject(key1) != serializeObject(key2))) {
												var settings = {};
												settings[property] = newValue;
												if (this.widgetInstance.host) {
													this.widgetInstance.host[controlName](settings);
												}
												else {
													this.widgetInstance.base.host[controlName](settings);
												}
												this.widgetInstance[property] = newValue;
												if (this.widgetInstance.propertyUpdated) {
													this.widgetInstance.propertyUpdated(property, key1, newValue);
												}
											}
										}
									}
								});
							});
						}
						var instance = new widgets[controlName](element);

						instances.push(instance);
						if (!window.jqxWidgets) {
							window.jqxWidgets = new Array();
						}
						if (!window.jqxWidgets[uid]) {
							window.jqxWidgets[uid] = new Array();
						}
						window.jqxWidgets[uid].push(instance);
					});

					if (instances.length === 1)
						return instances[0];

					return instances;

				}
			}

			$.fn[controlName] = function () {
				var args = Array.prototype.slice.call(arguments, 0);

				if (args.length == 0 || (args.length == 1 && typeof (args[0]) == 'object')) {
					if (this.length == 0) {
						if (this.selector) {
							throw new Error('Invalid Selector - ' + this.selector + '! Please, check whether the used ID or CSS Class name is correct.');
						}
						else {
							throw new Error('Invalid Selector! Please, check whether the used ID or CSS Class name is correct.');
						}
					}

					return this.each(function () {
						var host = $(this);
						var element = this; // element == this == host[0]
						var vars = $.data(element, controlName);

						if (vars == null) {
							$.jqx.applyWidget(element, controlName, args, undefined);
						}
						else {
							$.jqx.jqxWidgetProxy(controlName, this, args);
						}
					}); // each
				}
				else {
					if (this.length == 0) {
						if (this.selector) {
							throw new Error('Invalid Selector - ' + this.selector + '! Please, check whether the used ID or CSS Class name is correct.');
						}
						else {
							throw new Error('Invalid Selector! Please, check whether the used ID or CSS Class name is correct.');
						}
					}

					var returnVal = null;

					var cnt = 0;
					this.each(function () {
						var result = $.jqx.jqxWidgetProxy(controlName, this, args);

						if (cnt == 0) {
							returnVal = result;
							cnt++;
						}
						else {
							if (cnt == 1) {
								var tmp = [];
								tmp.push(returnVal);
								returnVal = tmp;
							}
							returnVal.push(result);
						}
					}); // each
				}

				return returnVal;
			}

			try {
				$.extend($.jqx['_' + controlName].prototype, Array.prototype.slice.call(params, 0)[0]);
			}
			catch (e) {
			}

			$.extend($.jqx['_' + controlName].prototype, {
				toThemeProperty: function (propertyName, override) {
					return $.jqx.toThemeProperty(this, propertyName, override);
				},

				isMaterialized: function () {
					if (!this.theme) {
						return false;
					}

					if (this.theme === "fluent") {
						return true;
					}

					if (this.theme === "light") {
						return true;
					}


					if (this.theme === "dark") {
						return true;
					}

					if (this.theme === "deepblue") {
						return true;
					}

					if (this.theme.indexOf("material") >= 0) {
						return true;
					}
				},

				isModern: function () {
					if (!this.theme) {
						return false;
					}

					if (this.theme.indexOf("light") >= 0) {
						return true;
					}

					if (this.theme === "dark") {
						return true;
					}
				},

				_addBarAndLabel: function (host) {
					var that = this;

					var label = $("<label></label");
					label[0].innerHTML = this.placeHolder;
					label.addClass(that.toThemeProperty('jqx-input-label'));
					host.after(label);
					that.label = label;

					var bar = $("<span></span>");
					host.after(bar);
					bar.addClass(that.toThemeProperty('jqx-input-bar'));
					that.bar = bar;
					that.bar.css('top', this.host.height());
				}
			});

			$.jqx['_' + controlName].prototype.refresh = function () {
				if (this.base)
					this.base.refresh(true);
			}
			$.jqx['_' + controlName].prototype.createInstance = function () {
			}

			$.jqx.isPassiveSupported = function () {
				var that = this;

				if (that.supportsPassive !== undefined) {
					return that.supportsPassive;
				}

				that.supportsPassive = false;
				try {
					var opts = Object.defineProperty({
					}, 'passive', {
						// eslint-disable-next-line getter-return
						get: function () {
							that.supportsPassive = true;
						}
					});
					window.addEventListener('testPassive', null, opts);
					window.removeEventListener('testPassive', null, opts);
				}
				catch (e) {
					//
				}

				return that.supportsPassive;
			}

			$.jqx['_' + controlName].prototype.addEventHandler = function (event, fnHandler) {
				if (this.base) {
					this.base.host.on(event, fnHandler);
				}
				else {
					this.host.on(event, fnHandler);
				}
			}

			$.jqx['_' + controlName].prototype.removeEventHandler = function (event, fnHandler) {
				if (this.base) {
					this.base.host.off(event);
				}
				else {
					this.host.off(event);
				}
			}

			$.jqx['_' + controlName].prototype.applyTo = function (element, args) {
				if (!(args instanceof Array)) {
					var a = [];
					a.push(args);
					args = a;
				}

				$.jqx.applyWidget(element, controlName, args, this);
			}

			$.jqx['_' + controlName].prototype.getInstance = function () {
				return this;
			}
			$.jqx['_' + controlName].prototype.propertyChangeMap = {};

			$.jqx['_' + controlName].prototype.addHandler = function (source, events, func, data) {
				$.jqx.addHandler($(source), events, func, data);
			};

			$.jqx['_' + controlName].prototype.removeHandler = function (source, events, func) {
				$.jqx.removeHandler($(source), events, func);
			};

			$.jqx['_' + controlName].prototype.setOptions = function () {
				if (!this.host || !this.host.length || this.host.length != 1)
					return;

				return $.jqx.jqxWidgetProxy(controlName, this.host[0], arguments);
			};
		} // jqxWidget

		$.jqx.toThemeProperty = function (instance, propertyName, override) {
			if (instance.theme == '')
				return propertyName;

			var split = propertyName.split(' ');
			var result = '';
			for (var i = 0; i < split.length; i++) {
				if (i > 0)
					result += ' ';

				var key = split[i];

				if (override != null && override)
					result += key + '-' + instance.theme;
				else
					result += key + ' ' + key + '-' + instance.theme;
			}

			return result;
		}

		$.jqx.addHandler = function (source, eventsList, func, data) {
			var events = eventsList.split(' ');

			for (var i = 0; i < events.length; i++) {
				var event = events[i];

				if (window.addEventListener && source[0]) {
					switch (event) {
						case 'mousewheel':
							if ($.jqx.browser.mozilla) {
								source[0].addEventListener('DOMMouseScroll', func, $.jqx.isPassiveSupported() ? { passive: false } : false);
							}
							else {
								source[0].addEventListener('mousewheel', func, $.jqx.isPassiveSupported() ? { passive: false } : false);
							}
							continue;
						case 'mousemove':
							if (!data) {
								source[0].addEventListener('mousemove', func, false);
								continue;
							}
							break;
						case 'touchmove':
							if (!data) {
								source[0].addEventListener('touchmove', func, false);
								continue;
							}
							else if (data && data.passive) {
								source[0].addEventListener('touchmove', func, data);
								continue;
							}

							break;
					}
				}

				if (data == undefined || data == null) {
					if (source.on)
						source.on(event, func);
					else
						source.bind(event, func);
				}
				else {
					if (source.on)
						source.on(event, data, func);
					else
						source.bind(event, data, func);
				}
			} // for
		};

		$.jqx.removeHandler = function (source, eventsList, func) {
			if (!eventsList) {
				if (source.off)
					source.off();
				else
					source.unbind();
				return;
			}
			var events = eventsList.split(' ');

			for (var i = 0; i < events.length; i++) {
				var event = events[i];

				if (window.removeEventListener) {
					switch (event) {
						case 'mousewheel':
							if ($.jqx.browser.mozilla) {
								source[0].removeEventListener('DOMMouseScroll', func, false);
							}
							else {
								source[0].removeEventListener('mousewheel', func, false);
							}
							continue;
						case 'mousemove':
							if (func) {
								source[0].removeEventListener('mousemove', func, false);
								continue;
							}
							break;
						case 'touchmove':
							if (func) {
								source[0].removeEventListener('touchmove', func, false);
								continue;
							}
							break;
					}
				}

				if (event == undefined) {
					if (source.off)
						source.off();
					else
						source.unbind();
					continue;
				}

				if (func == undefined) {
					if (source.off)
						source.off(event);
					else
						source.unbind(event);
				}
				else {
					if (source.off)
						source.off(event, func);
					else
						source.unbind(event, func);
				}
			}
		};

		$.jqx.credits = $.jqx.credits || "";
		$.jqx.theme = $.jqx.theme || "";
		$.jqx.scrollAnimation = $.jqx.scrollAnimation || false;
		$.jqx.resizeDelay = $.jqx.resizeDelay || 10;

		$.jqx.ready = function () {
			$(window).trigger('jqxReady');
		}
		$.jqx.init = function () {
			$.each(arguments[0], function (index, value) {
				if (index == "theme") {
					$.jqx.theme = value;
				}
				if (index == "scrollBarSize") {
					$.jqx.utilities.scrollBarSize = value;
				}
				if (index == "touchScrollBarSize") {
					$.jqx.utilities.touchScrollBarSize = value;
				}
				if (index == "scrollBarButtonsVisibility") {
					$.jqx.utilities.scrollBarButtonsVisibility = value;
				}
			});
		}

		// Utilities
		$.jqx.utilities = $.jqx.utilities || {};
		$.extend($.jqx.utilities,
			{
				scrollBarSize: 13,
				touchScrollBarSize: 8,
				scrollBarButtonsVisibility: "visible",
				createId: function () {
					var S4 = function () {
						return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
					};
					return "jqxWidget" + S4() + S4() + S4();
				},

				setTheme: function (oldTheme, theme, element) {
					if (typeof element === 'undefined') {
						return;
					}

					if (!element[0].className.split) {
						return;
					}

					if (oldTheme === undefined) {
						oldTheme = '';
					}

					if (theme === undefined) {
						theme = '';
					}

					var classNames = element[0].className.split(' '),
						oldClasses = [], newClasses = [],
						children = element.children();
					for (var i = 0; i < classNames.length; i += 1) {
						if (classNames[i].indexOf(oldTheme) >= 0) {
							if (oldTheme.length > 0) {
								oldClasses.push(classNames[i]);
								newClasses.push(classNames[i].replace(oldTheme, theme));
							}
							else {
								newClasses.push(classNames[i].replace("-" + theme, "") + '-' + theme);
							}
						}
					}
					this._removeOldClasses(oldClasses, element);
					this._addNewClasses(newClasses, element);
					for (var i = 0; i < children.length; i += 1) {
						this.setTheme(oldTheme, theme, $(children[i]));
					}
				},

				_removeOldClasses: function (classes, element) {
					for (var i = 0; i < classes.length; i += 1) {
						element.removeClass(classes[i]);
					}
				},

				_addNewClasses: function (classes, element) {
					for (var i = 0; i < classes.length; i += 1) {
						element.addClass(classes[i]);
					}
				},

				getOffset: function (el) {
					var left = $.jqx.mobile.getLeftPos(el[0]);
					var top = $.jqx.mobile.getTopPos(el[0]);
					return { top: top, left: left };
				},

				resize: function (element, callback, destroy, checkForHidden) {
					if (checkForHidden === undefined) {
						checkForHidden = true;
					}

					var index = -1;
					var that = this;
					var getHiddenIndex = function (element) {
						if (!that.hiddenWidgets) {
							return -1;
						}

						var hiddenIndex = -1;
						for (var i = 0; i < that.hiddenWidgets.length; i++) {
							if (element.id) {
								if (that.hiddenWidgets[i].id == element.id) {
									hiddenIndex = i;
									break;
								}
							}
							else {
								if (that.hiddenWidgets[i].id == element[0].id) {
									hiddenIndex = i;
									break;
								}
							}
						}
						return hiddenIndex;
					}


					if (this.resizeHandlers) {
						for (var i = 0; i < this.resizeHandlers.length; i++) {
							if (element.id) {
								if (this.resizeHandlers[i].id == element.id) {
									index = i;
									break;
								}
							}
							else {
								if (this.resizeHandlers[i].id == element[0].id) {
									index = i;
									break;
								}
							}
						}

						if (destroy === true) {
							if (index != -1) {
								this.resizeHandlers.splice(index, 1);
								if (this.watchedElementData && this.watchedElementData.length > 0) {
									this.watchedElementData.splice(index, 1);
								}
							}

							if (this.resizeHandlers.length == 0) {
								var w = $(window);
								if (w.off) {
									w.off('resize.jqx');
									w.off('orientationchange.jqx');
									w.off('orientationchanged.jqx');
								}
								else {
									w.unbind('resize.jqx');
									w.unbind('orientationchange.jqx');
									w.unbind('orientationchanged.jqx');
								}
								this.resizeHandlers = null;
							}
							var hiddenIndex = getHiddenIndex(element);
							if (hiddenIndex != -1 && this.hiddenWidgets) {
								this.hiddenWidgets.splice(hiddenIndex, 1);
							}
							return;
						}
					}
					else if (destroy === true) {
						var hiddenIndex = getHiddenIndex(element);
						if (hiddenIndex != -1 && this.hiddenWidgets) {
							this.hiddenWidgets.splice(hiddenIndex, 1);
						}
						return;
					}
					var that = this;
					var doResize = function (isHidden, type) {
						if (!that.resizeHandlers)
							return;

						var getParentsCount = function (element) {
							var index = -1;
							var parent = element.parentNode;
							while (parent) {
								index++;
								parent = parent.parentNode;
							}
							return index;
						}

						var compare = function (value1, value2) {
							if (!value1.widget || !value2.widget)
								return 0;

							var parents1 = getParentsCount(value1.widget[0]);
							var parents2 = getParentsCount(value2.widget[0]);

							try {
								if (parents1 < parents2) { return -1; }
								if (parents1 > parents2) { return 1; }
							}
							catch (error) {
								var er = error;
							}

							return 0;
						};
						var handleHiddenWidgets = function (delay) {
							if (that.hiddenWidgets.length > 0) {
								that.hiddenWidgets.sort(compare);
								var updateHiddenWidgets = function () {
									var hasHiddenWidget = false;
									var currentHiddenWidgets = new Array();
									for (var p = 0; p < that.hiddenWidgets.length; p++) {
										var handler = that.hiddenWidgets[p];
										if ($.jqx.isHidden(handler.widget)) {
											hasHiddenWidget = true;
											currentHiddenWidgets.push(handler);
										}
										else {
											if (handler.callback) {
												handler.callback(type);
											}
										}
									}
									that.hiddenWidgets = currentHiddenWidgets;
									if (!hasHiddenWidget) {
										clearInterval(that.__resizeInterval);
									}
								}
								if (delay == false) {
									updateHiddenWidgets();
									if (that.__resizeInterval) clearInterval(that.__resizeInterval);
									return;
								}
								if (that.__resizeInterval) clearInterval(that.__resizeInterval);
								that.__resizeInterval = setInterval(function () {
									updateHiddenWidgets();
								}, 100);
							}
						}

						if (that.hiddenWidgets && that.hiddenWidgets.length > 0) {
							handleHiddenWidgets(false);
						}
						that.hiddenWidgets = new Array();
						that.resizeHandlers.sort(compare);
						for (var i = 0; i < that.resizeHandlers.length; i++) {
							var handler = that.resizeHandlers[i];
							var widget = handler.widget;
							var data = handler.data;
							if (!data) continue;
							if (!data.jqxWidget) continue;

							var width = data.jqxWidget.width;
							var height = data.jqxWidget.height;

							if (data.jqxWidget.base) {
								if (width == undefined) {
									width = data.jqxWidget.base.width;
								}
								if (height == undefined) {
									height = data.jqxWidget.base.height;
								}
							}

							if (width === undefined && height === undefined) {
								width = data.jqxWidget.element.style.width;
								height = data.jqxWidget.element.style.height;
							}

							var percentageSize = false;
							if (width != null && width.toString().indexOf("%") != -1) {
								percentageSize = true;
							}

							if (height != null && height.toString().indexOf("%") != -1) {
								percentageSize = true;
							}

							if ($.jqx.isHidden(widget)) {
								if (getHiddenIndex(widget) === -1) {
									if (percentageSize || isHidden === true) {
										if (handler.data.nestedWidget !== true) {
											that.hiddenWidgets.push(handler);
										}
									}
								}
							}
							else if (isHidden === undefined || isHidden !== true) {
								if (percentageSize) {
									handler.callback(type);
									if (that.watchedElementData) {
										for (var m = 0; m < that.watchedElementData.length; m++) {
											if (that.watchedElementData[m].element == data.jqxWidget.element) {
												that.watchedElementData[m].offsetWidth = data.jqxWidget.element.offsetWidth;
												that.watchedElementData[m].offsetHeight = data.jqxWidget.element.offsetHeight;
												break;
											}
										}
									}
									if (that.hiddenWidgets.indexOf(handler) >= 0) {
										that.hiddenWidgets.splice(that.hiddenWidgets.indexOf(handler), 1);
									}
								}
								if (data.jqxWidget.element) {
									var widgetClass = data.jqxWidget.element.className;
									if (widgetClass.indexOf('dropdownlist') >= 0 || widgetClass.indexOf('datetimeinput') >= 0 || widgetClass.indexOf('combobox') >= 0 || widgetClass.indexOf('menu') >= 0) {
										if (data.jqxWidget.isOpened) {
											var opened = data.jqxWidget.isOpened();
											if (opened) {
												if (type && type == "resize" && $.jqx.mobile.isTouchDevice())
													continue;

												data.jqxWidget.close();
											}
										}
									}
								}
							}
						};

						handleHiddenWidgets();
					}

					if (!this.resizeHandlers) {
						this.resizeHandlers = new Array();

						var w = $(window);
						if (w.on) {
							this._resizeTimer = null;
							this._initResize = null;
							w.on('resize.jqx', function (event) {
								if (that._resizeTimer != undefined) {
									clearTimeout(that._resizeTimer);
								}
								if (!that._initResize) {
									that._initResize = true;
									doResize(null, 'resize');
								}
								else {
									that._resizeTimer = setTimeout(function () {
										doResize(null, 'resize');
									}, $.jqx.resizeDelay);
								}
							});
							w.on('orientationchange.jqx', function (event) {
								doResize(null, 'orientationchange');
							});
							w.on('orientationchanged.jqx', function (event) {
								doResize(null, 'orientationchange');
							});
						}
						else {
							w.bind('resize.jqx', function (event) {
								doResize(null, 'orientationchange');
							});
							w.bind('orientationchange.jqx', function (event) {
								doResize(null, 'orientationchange');
							});
							w.bind('orientationchanged.jqx', function (event) {
								doResize(null, 'orientationchange');
							});
						}
					}
					var elementData = element.data();
					if (checkForHidden) {
						if (index === -1) {
							this.resizeHandlers.push({ id: element[0].id, widget: element, callback: callback, data: elementData });
						}
					}
					try {
						var width = elementData.jqxWidget.width;
						var height = elementData.jqxWidget.height;

						if (elementData.jqxWidget.base) {
							if (width == undefined) {
								width = elementData.jqxWidget.base.width;
							}
							if (height == undefined) {
								height = elementData.jqxWidget.base.height;
							}
						}

						if (width === undefined && height === undefined) {
							width = elementData.jqxWidget.element.style.width;
							height = elementData.jqxWidget.element.style.height;
						}

						var percentageSize = false;
						if (width != null && width.toString().indexOf("%") != -1) {
							percentageSize = true;
						}

						if (height != null && height.toString().indexOf("%") != -1) {
							percentageSize = true;
						}
						if (percentageSize) {
							if (!this.watchedElementData) {
								this.watchedElementData = [];
							}
							var that = this;
							var checkForChanges = function (mutations) {
								if (that.watchedElementData.forEach) {
									that.watchedElementData.forEach(function (data) {
										if (data.element.offsetWidth !== data.offsetWidth ||
											data.element.offsetHeight !== data.offsetHeight) {
											data.offsetWidth = data.element.offsetWidth;
											data.offsetHeight = data.element.offsetHeight;
											if (data.timer) {
												clearTimeout(data.timer);
											}
											data.timer = setTimeout(function () {
												if (!$.jqx.isHidden($(data.element))) {
													data.callback();
												}
												else {
													data.timer = setInterval(function () {
														if (!$.jqx.isHidden($(data.element))) {
															clearInterval(data.timer);
															data.callback();
														}
													}, 100);
												}
											});
										}
									});
								}
							};

							that.watchedElementData.push({
								element: element[0],
								offsetWidth: element[0].offsetWidth,
								offsetHeight: element[0].offsetHeight,
								callback: callback
							});
							if (!that.observer) {
								that.observer = new MutationObserver(checkForChanges);
								that.observer.observe(document.body, {
									attributes: true,
									childList: true,
									characterData: true
								});
							}
						}
					}
					catch (er) {
					}
					if ($.jqx.isHidden(element) && checkForHidden === true) {
						doResize(true);
					}
					$.jqx.resize = function () {
						doResize(null, 'resize');
					}
				},

				parseJSON: function (data) {
					if (!data || typeof data !== "string") {
						return null;
					}
					var rvalidchars = /^[\],:{}\s]*$/,
						rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
						rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
						rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g;

					// Make sure leading/trailing whitespace is removed (IE can't handle it)
					data = $.trim(data);

					// Attempt to parse using the native JSON parser first
					if (window.JSON && window.JSON.parse) {
						return window.JSON.parse(data);
					}

					// Make sure the incoming data is actual JSON
					// Logic borrowed from http://json.org/json2.js
					if (rvalidchars.test(data.replace(rvalidescape, "@")
						.replace(rvalidtokens, "]")
						.replace(rvalidbraces, ""))) {

						return (new Function("return " + data))();

					}
					throw new Error("Invalid JSON: " + data);
				},

				html: function (element, value) {
					if (!$(element).on || !$.access) {
						return $(element).html(value);
					}
					try {
						return $.access(element, function (value) {
							var elem = element[0] || {},
								i = 0,
								l = element.length;

							if (value === undefined) {
								return elem.nodeType === 1 ?
									elem.innerHTML.replace(rinlinejQuery, "") :
									undefined;
							}

							var rnoInnerhtml = /<(?:script|style|link)/i,
								nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
									"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
								rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
								rtagName = /<([\w:]+)/,
								rnocache = /<(?:script|object|embed|option|style)/i,
								rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
								rleadingWhitespace = /^\s+/,
								wrapMap = {
									option: [1, "<select multiple='multiple'>", "</select>"],
									legend: [1, "<fieldset>", "</fieldset>"],
									thead: [1, "<table>", "</table>"],
									tr: [2, "<table><tbody>", "</tbody></table>"],
									td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
									col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
									area: [1, "<map>", "</map>"],
									_default: [0, "", ""]
								};

							if (typeof value === "string" && !rnoInnerhtml.test(value) &&
								($.support.htmlSerialize || !rnoshimcache.test(value)) &&
								($.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
								!wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

								value = value.replace(rxhtmlTag, "<$1></$2>");

								try {
									for (; i < l; i++) {
										elem = this[i] || {};
										if (elem.nodeType === 1) {
											$.cleanData(elem.getElementsByTagName("*"));
											elem.innerHTML = value;
										}
									}

									elem = 0;
								} catch (e) { }
							}

							if (elem) {
								element.empty().append(value);
							}
						}, null, value, arguments.length);
					}
					catch (error) {
						return $(element).html(value);
					}
				},

				hasTransform: function (el) {
					var transform = "";
					transform = el.css('transform');

					if (transform == "" || transform == 'none') {
						transform = el.parents().css('transform');
						if (transform == "" || transform == 'none') {
							var browserInfo = $.jqx.utilities.getBrowser();
							if (browserInfo.browser == 'msie') {
								transform = el.css('-ms-transform');
								if (transform == "" || transform == 'none') {
									transform = el.parents().css('-ms-transform');
								}
							}
							else if (browserInfo.browser == 'chrome') {
								transform = el.css('-webkit-transform');
								if (transform == "" || transform == 'none') {
									transform = el.parents().css('-webkit-transform');
								}
							}
							else if (browserInfo.browser == 'opera') {
								transform = el.css('-o-transform');
								if (transform == "" || transform == 'none') {
									transform = el.parents().css('-o-transform');
								}
							}
							else if (browserInfo.browser == 'mozilla') {
								transform = el.css('-moz-transform');
								if (transform == "" || transform == 'none') {
									transform = el.parents().css('-moz-transform');
								}
							}
						} else {
							return transform != "" && transform != 'none';
						}
					}
					if (transform == "" || transform == 'none') {
						transform = $(document.body).css('transform');
					}
					return transform != "" && transform != 'none' && transform != null;
				},

				getBrowser: function () {
					var ua = navigator.userAgent.toLowerCase();

					var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
						/(webkit)[ \/]([\w.]+)/.exec(ua) ||
						/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
						/(msie) ([\w.]+)/.exec(ua) ||
						ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
						[];

					var obj = {
						browser: match[1] || "",
						version: match[2] || "0"
					};
					if (ua.indexOf("rv:11.0") >= 0 && ua.indexOf(".net4.0c") >= 0) {
						obj.browser = "msie";
						obj.version = "11";
						match[1] = "msie";
					}
					if (ua.indexOf("edge") >= 0) {
						obj.browser = "msie";
						obj.version = "12";
						match[1] = "msie";
					}
					obj[match[1]] = match[1];
					return obj;
				}
			});
		$.jqx.browser = $.jqx.utilities.getBrowser();
		$.jqx.isHidden = function (element) {
			if (!element || !element[0])
				return false;

			var w = element[0].offsetWidth, h = element[0].offsetHeight;
			if (w === 0 || h === 0)
				return true;
			else {
				return false;
			}
		};

		$.jqx.ariaEnabled = true;
		$.jqx.aria = function (that, property, value) {
			if (!$.jqx.ariaEnabled)
				return;

			if (property == undefined) {
				$.each(that.aria, function (index, value) {
					var attrValue = !that.base ? that.host.attr(index) : that.base.host.attr(index);
					if (attrValue != undefined && !$.isFunction(attrValue)) {
						var newValue = attrValue;
						switch (value.type) {
							case "number":
								newValue = new Number(attrValue);
								if (isNaN(newValue)) newValue = attrValue;
								break;
							case "boolean":
								newValue = attrValue == "true" ? true : false;
								break;
							case "date":
								newValue = new Date(attrValue);
								if (newValue == "Invalid Date" || isNaN(newValue)) newValue = attrValue;
								break;
						}

						that[value.name] = newValue;
					}
					else {
						var attrValue = that[value.name];
						if ($.isFunction(attrValue)) attrValue = that[value.name]();
						if (attrValue == undefined) attrValue = "";
						try {
							!that.base ? that.host.attr(index, attrValue.toString()) : that.base.host.attr(index, attrValue.toString());
						}
						catch (error) {
						}
					}
				});
			}
			else {
				try {
					if (that.host) {
						if (!that.base) {
							if (that.host) {
								if (that.element.setAttribute) {
									that.element.setAttribute(property, value.toString());
								}
								else {
									that.host.attr(property, value.toString());
								}
							}
							else {
								that.attr(property, value.toString());
							}
						}
						else {
							if (that.base.host) {
								that.base.host.attr(property, value.toString());
							}
							else {
								that.attr(property, value.toString());
							}
						}
					}
					else if (that.setAttribute) {
						that.setAttribute(property, value.toString());
					}
				}
				catch (error) {
				}
			}
		};

		if (!Array.prototype.indexOf) {
			Array.prototype.indexOf = function (elt /*, from*/) {
				var len = this.length;

				var from = Number(arguments[1]) || 0;
				from = (from < 0)
					? Math.ceil(from)
					: Math.floor(from);
				if (from < 0)
					from += len;

				for (; from < len; from++) {
					if (from in this &&
						this[from] === elt)
						return from;
				}
				return -1;
			};
		}

		$.jqx.mobile = $.jqx.mobile || {};
		$.jqx.position = function (event) {
			var left = parseInt(event.pageX);
			var top = parseInt(event.pageY);

			if ($.jqx.mobile.isTouchDevice()) {
				var touches = $.jqx.mobile.getTouches(event);
				var touch = touches[0];
				left = parseInt(touch.pageX);
				top = parseInt(touch.pageY);
			}
			return { left: left, top: top }
		}

		$.extend($.jqx.mobile,
			{
				_touchListener: function (e, me) {
					var createTouchEvent = function (name, e) {
						var event = document.createEvent('MouseEvents');

						event.initMouseEvent(
							name,
							e.bubbles,
							e.cancelable,
							e.view,
							e.detail,
							e.screenX,
							e.screenY,
							e.clientX,
							e.clientY,
							e.ctrlKey,
							e.altKey,
							e.shiftKey,
							e.metaKey,
							e.button,
							e.relatedTarget
						);
						event._pageX = e.pageX;
						event._pageY = e.pageY;

						return event;
					}

					var eventMap = { 'mousedown': 'touchstart', 'mouseup': 'touchend', 'mousemove': 'touchmove' };
					var event = createTouchEvent(eventMap[e.type], e);
					e.target.dispatchEvent(event);

					var fn = e.target['on' + eventMap[e.type]];
					if (typeof fn === 'function') fn(e);
				},

				setMobileSimulator: function (element, value) {
					if (this.isTouchDevice()) {
						return;
					}

					this.simulatetouches = true;
					if (value == false) {
						this.simulatetouches = false;
					}

					var eventMap = { 'mousedown': 'touchstart', 'mouseup': 'touchend', 'mousemove': 'touchmove' };

					var self = this;
					if (window.addEventListener) {
						var subscribeToEvents = function () {
							for (var key in eventMap) {
								if (element.addEventListener) {
									element.removeEventListener(key, self._touchListener);
									element.addEventListener(key, self._touchListener, false);
								}

								//  document.removeEventListener(key, self._touchListener);
								//  document.addEventListener(key, self._touchListener, false);
							}
						}

						if ($.jqx.browser.msie) {
							subscribeToEvents();
						}
						else {
							subscribeToEvents();
						}
					}
				},

				isTouchDevice: function () {
					if (this.touchDevice != undefined)
						return this.touchDevice;

					var txt = "Browser CodeName: " + navigator.appCodeName + "";
					txt += "Browser Name: " + navigator.appName + "";
					txt += "Browser Version: " + navigator.appVersion + "";
					txt += "Platform: " + navigator.platform + "";
					txt += "User-agent header: " + navigator.userAgent + "";

					if (navigator.maxTouchPoints > 1) {
						//return true;
					}

					if (txt.indexOf('Android') != -1)
						return true;

					if (txt.indexOf('IEMobile') != -1)
						return true;

					if (txt.indexOf('Windows Phone') != -1)
						return true;

					if (txt.indexOf('WPDesktop') != -1)
						return true;

					if (txt.indexOf('ZuneWP7') != -1)
						return true;

					if (txt.indexOf('BlackBerry') != -1 && txt.indexOf('Mobile Safari') != -1)
						return true;

					if (txt.indexOf('ipod') != -1)
						return true;

					if (txt.indexOf('nokia') != -1 || txt.indexOf('Nokia') != -1)
						return true;

					if (txt.indexOf('Chrome/17') != -1)
						return false;

					if (txt.indexOf('CrOS') != -1)
						return false;

					if (txt.indexOf('Opera') != -1 && txt.indexOf('Mobi') == -1 && txt.indexOf('Mini') == -1 && txt.indexOf('Platform: Win') != -1) {
						return false;
					}

					if (txt.indexOf("HybridDeviceTouch") != -1) {
						return true
					}

					if (txt.indexOf("HybridDeviceMouse") != -1) {
						return false
					}

					if (txt.indexOf('Opera') != -1 && txt.indexOf('Mobi') != -1 && txt.indexOf('Opera Mobi') != -1) {
						return true;
					}

					if (txt.indexOf('Mozilla/5.0 (X11; Linux x86_64)') != -1) {
						return false;
					}

					var deviceTypes = {
						ios: 'i(?:Pad|Phone|Pod)(?:.*)CPU(?: iPhone)? OS ',
						android: '(Android |HTC_|Silk/)',
						blackberry: 'BlackBerry(?:.*)Version\/',
						rimTablet: 'RIM Tablet OS ',
						webos: '(?:webOS|hpwOS)\/',
						bada: 'Bada\/'
					}

					// check for IPad, IPhone, IE and Chrome
					try {
						if (this.touchDevice != undefined)
							return this.touchDevice;

						this.touchDevice = false;
						for (var i in deviceTypes) {
							if (deviceTypes.hasOwnProperty(i)) {
								var prefix = deviceTypes[i];
								var match = txt.match(new RegExp('(?:' + prefix + ')([^\\s;]+)'));
								if (match) {
									if (i.toString() == "blackberry") {
										// handle touches through mouse pointer.
										this.touchDevice = false;
										return false;
									}

									this.touchDevice = true;
									return true;
								}
							}
						}

						var userAgent = navigator.userAgent;
						if (navigator.platform.toLowerCase().indexOf('win') != -1) {
							if (userAgent.indexOf('Windows Phone') >= 0 || userAgent.indexOf('WPDesktop') >= 0 || userAgent.indexOf('IEMobile') >= 0 || userAgent.indexOf('ZuneWP7') >= 0) {
								this.touchDevice = true;
								return true;
							}
							else {
								if (userAgent.indexOf('Touch') >= 0) {
									var supported = ('MSPointerDown' in window) || ('pointerdown' in window);
									if (supported) {
										this.touchDevice = true;
										return true;
									}
									if (userAgent.indexOf('ARM') >= 0) {
										this.touchDevice = true;
										return true;
									}

									this.touchDevice = false;
									return false;
								}
							}
						}

						if (navigator.platform.toLowerCase().indexOf('win') != -1) {
							this.touchDevice = false;
							return false;
						}
						if (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
							this.touchDevice = true;
						}
						return this.touchDevice;
					} catch (e) {
						this.touchDevice = false;
						return false;
					}
				},

				getLeftPos: function (inputObj) {
					var returnValue = inputObj.offsetLeft;
					while ((inputObj = inputObj.offsetParent) != null) {
						if (inputObj.tagName != 'HTML') {
							returnValue += inputObj.offsetLeft;
							if (document.all) returnValue += inputObj.clientLeft;
						}
					}
					return returnValue;
				},

				getTopPos: function (inputObj) {
					var returnValue = inputObj.offsetTop;
					var initialOffset = $(inputObj).coord();
					while ((inputObj = inputObj.offsetParent) != null) {
						if (inputObj.tagName != 'HTML') {
							returnValue += (inputObj.offsetTop - inputObj.scrollTop);
							if (document.all) returnValue += inputObj.clientTop;
						}
					}
					var agent = navigator.userAgent.toLowerCase();
					var wp8 = (agent.indexOf('windows phone') != -1 || agent.indexOf('WPDesktop') != -1 || agent.indexOf('ZuneWP7') != -1 || agent.indexOf('msie 9') != -1 || agent.indexOf('msie 11') != -1 || agent.indexOf('msie 10') != -1) && agent.indexOf('touch') != -1;
					if (wp8) {
						return initialOffset.top;
					}

					if (this.isSafariMobileBrowser()) {
						if (this.isSafari4MobileBrowser() && this.isIPadSafariMobileBrowser()) {
							return returnValue;
						}
						if (agent.indexOf('version/7') != -1) {
							return initialOffset.top;
						}
						if (agent.indexOf('version/6') != -1 || agent.indexOf('version/5') != -1) {
							returnValue = returnValue + $(window).scrollTop();
						}
						if (/(Android.*Chrome\/[.0-9]* (!?Mobile))/.exec(navigator.userAgent)) {
							return returnValue;
							//       return returnValue + $(window).scrollTop();
						}
						if (/(Android.*Chrome\/[.0-9]* Mobile)/.exec(navigator.userAgent)) {
							return returnValue;
							//        return returnValue + $(window).scrollTop();
						}

						return initialOffset.top;
					}

					return returnValue;
				},

				isChromeMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('android') != -1;
					return result;
				},

				isOperaMiniMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('opera mini') != -1 || agent.indexOf('opera mobi') != -1;
					return result;
				},

				isOperaMiniBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('opera mini') != -1;
					return result;
				},

				isNewSafariMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('ipad') != -1 || agent.indexOf('iphone') != -1 || agent.indexOf('ipod') != -1;
					result = result && (agent.indexOf('version/5') != -1);
					return result;
				},

				isSafari4MobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('ipad') != -1 || agent.indexOf('iphone') != -1 || agent.indexOf('ipod') != -1;
					result = result && (agent.indexOf('version/4') != -1);
					return result;
				},

				isWindowsPhone: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = (agent.indexOf('windows phone') != -1 || agent.indexOf('WPDesktop') != -1 || agent.indexOf('ZuneWP7') != -1 || agent.indexOf('msie 9') != -1 || agent.indexOf('msie 11') != -1 || agent.indexOf('msie 10') != -1 && agent.indexOf('touch') != -1);
					return result;
				},

				isSafariMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					if (/(Android.*Chrome\/[.0-9]* (!?Mobile))/.exec(navigator.userAgent)) {
						return true;
					}
					if (/(Android.*Chrome\/[.0-9]* Mobile)/.exec(navigator.userAgent)) {
						return true;
					}

					var result = agent.indexOf('ipad') != -1 || agent.indexOf('iphone') != -1 || agent.indexOf('ipod') != -1 || agent.indexOf('mobile safari') != -1;
					return result;
				},

				isIPadSafariMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('ipad') != -1;
					return result;
				},

				isMobileBrowser: function () {
					var agent = navigator.userAgent.toLowerCase();
					var result = agent.indexOf('ipad') != -1 || agent.indexOf('iphone') != -1 || agent.indexOf('android') != -1;
					return result;
				},

				// Get the touch points from this event
				getTouches: function (e) {
					if (e.originalEvent) {
						if (e.originalEvent.touches && e.originalEvent.touches.length) {
							return e.originalEvent.touches;
						} else if (e.originalEvent.changedTouches && e.originalEvent.changedTouches.length) {
							return e.originalEvent.changedTouches;
						}
					}

					if (!e.touches) {
						e.touches = new Array();
						e.touches[0] = e.originalEvent != undefined ? e.originalEvent : e;

						if (e.originalEvent != undefined && e.pageX)
							e.touches[0] = e;
						if (e.type == 'mousemove') e.touches[0] = e;
					}

					return e.touches;
				},

				getTouchEventName: function (name) {
					if (this.isWindowsPhone()) {

						var agent = navigator.userAgent.toLowerCase();
						if (agent.indexOf('windows phone 7') != -1) {
							if (name.toLowerCase().indexOf('start') != -1) return 'MSPointerDown';
							if (name.toLowerCase().indexOf('move') != -1) return 'MSPointerMove';
							if (name.toLowerCase().indexOf('end') != -1) return 'MSPointerUp';
						}
						if (name.toLowerCase().indexOf('start') != -1) return 'pointerdown';
						if (name.toLowerCase().indexOf('move') != -1) return 'pointermove';
						if (name.toLowerCase().indexOf('end') != -1) return 'pointerup';
					}
					else {
						return name;
					}
				},

				// Dispatches a fake mouse event from a touch event
				dispatchMouseEvent: function (name, touch, target) {
					if (this.simulatetouches)
						return;

					var e = document.createEvent('MouseEvent');
					e.initMouseEvent(name, true, true, touch.view, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
					if (target != null) {
						target.dispatchEvent(e);
					}
				},

				// Find the root node of this target
				getRootNode: function (target) {
					while (target.nodeType !== 1) {
						target = target.parentNode;
					}
					return target;
				},

				setTouchScroll: function (enable, key) {
					if (!this.enableScrolling) this.enableScrolling = [];
					this.enableScrolling[key] = enable;
				},

				touchScroll: function (element, scrollHeight, callback, key, horizontalScroll, verticalScroll) {
					if (element == null)
						return;

					var me = this;
					var scrollY = 0;
					var touchY = 0;
					var movedY = 0;
					var scrollX = 0;
					var touchX = 0;
					var movedX = 0;
					if (!this.scrolling) this.scrolling = [];
					this.scrolling[key] = false;
					var moved = false;
					var $element = $(element);
					var touchTags = ['select', 'input', 'textarea'];
					var touchStart = 0;
					var touchEnd = 0;
					if (!this.enableScrolling) this.enableScrolling = [];
					this.enableScrolling[key] = true;
					var key = key;
					var touchStartName = this.getTouchEventName('touchstart') + ".touchScroll";
					var touchEndName = this.getTouchEventName('touchend') + ".touchScroll";
					var touchMoveName = this.getTouchEventName('touchmove') + ".touchScroll";

					//            horizontalScroll.fadeOut(0);
					//            verticalScroll.fadeOut(0);

					var view, indicator, relative, xframe, xdelta,
						xmax, min, max, offset, reference, pressed, xform,
						jqxAnimations, xjqxAnimations, frame, timestamp, ticker,
						amplitude, target, xtarget, xreference, timeConstant;
					max = scrollHeight;
					var min = 0;
					var offset = 0;
					var xoffset = 0;
					var initialOffset = 0;
					var initialXOffset = 0;
					var xmax = horizontalScroll.jqxScrollBar('max');
					var timeConstant = 325; // ms

					function ypos(e) {
						// touch event
						if (e.targetTouches && (e.targetTouches.length >= 1)) {
							return e.targetTouches[0].clientY;
						}
						else if (e.originalEvent && e.originalEvent.clientY !== undefined) {
							return e.originalEvent.clientY;
						}
						else {
							var touches = me.getTouches(e);
							return touches[0].clientY;
						}

						// mouse event
						//    return e.clientY;
					}

					function xpos(e) {
						// touch event
						if (e.targetTouches && (e.targetTouches.length >= 1)) {
							return e.targetTouches[0].clientX;
						}
						else if (e.originalEvent && e.originalEvent.clientX !== undefined) {
							return e.originalEvent.clientX;
						}
						else {
							var touches = me.getTouches(e);
							return touches[0].clientX;
						}

						// mouse event
						//   return e.clientX;
					}

					var track = function () {
						var now, elapsed, delta, v;

						now = Date.now();
						elapsed = now - timestamp;
						timestamp = now;
						delta = offset - frame;
						var xdelta = xoffset - xframe;
						frame = offset;
						xframe = xoffset;
						pressed = true;
						v = 1000 * delta / (1 + elapsed);
						var xv = 1000 * xdelta / (1 + elapsed);
						jqxAnimations = 0.8 * v + 0.2 * jqxAnimations;
						xjqxAnimations = 0.8 * xv + 0.2 * xjqxAnimations;
					}

					var tapped = false;

					var touchStart = function (event) {
						if (!me.enableScrolling[key])
							return true;

						// Allow certain HTML tags to receive touch events
						if ($.inArray(event.target.tagName.toLowerCase(), touchTags) !== -1) {
							return;
						}
						offset = verticalScroll.jqxScrollBar('value');
						xoffset = horizontalScroll.jqxScrollBar('value');

						var touches = me.getTouches(event);
						var touch = touches[0];
						if (touches.length == 1) {
							me.dispatchMouseEvent('mousedown', touch, me.getRootNode(touch.target));
						}
						xmax = horizontalScroll.jqxScrollBar('max');
						max = verticalScroll.jqxScrollBar('max');
						function tap(e) {
							tapped = false;
							pressed = true;
							reference = ypos(e);
							xreference = xpos(e);
							jqxAnimations = amplitude = xjqxAnimations = 0;
							frame = offset;
							xframe = xoffset;
							timestamp = Date.now();
							clearInterval(ticker);
							ticker = setInterval(track, 100);
							initialOffset = offset;
							initialXOffset = xoffset;

							if (offset > 0 && offset < max && verticalScroll[0].style.visibility != "hidden") {
								//      e.preventDefault();
							}
							//    if (xoffset > 0 && xoffset < xmax && horizontalScroll[0].style.visibility != "hidden") {
							//        e.preventDefault();

							//      e.stopPropagation();
							//   e.stopPropagation();
							// return false;
						}

						tap(event);
						moved = false;
						touchY = touch.pageY;
						touchX = touch.pageX;
						if (me.simulatetouches) {
							if (touch._pageY != undefined) {
								touchY = touch._pageY;
								touchX = touch._pageX;
							}
						}
						me.scrolling[key] = true;
						scrollY = 0;
						scrollX = 0;
						return true;
					}

					if ($element.on) {
						$element.on(touchStartName, touchStart);
					}
					else {
						$element.bind(touchStartName, touchStart);
					}

					var scroll = function (top, event) {
						offset = (top > max) ? max : (top < min) ? min : top;
						callback(null, top, 0, 0, event);

						return (top > max) ? "max" : (top < min) ? "min" : "value";
					}

					var hscroll = function (left, event) {
						xoffset = (left > xmax) ? xmax : (left < min) ? min : left;
						callback(left, null, 0, 0, event);

						return (left > xmax) ? "max" : (left < min) ? "min" : "value";
					}

					function autoScroll() {
						var elapsed, delta;
						if (amplitude) {
							elapsed = Date.now() - timestamp;
							delta = -amplitude * Math.exp(-elapsed / timeConstant);
							if (delta > 0.5 || delta < -0.5) {
								scroll(target + delta);
								requestAnimationFrame(autoScroll);
							} else {
								scroll(target);
								//     verticalScroll.fadeOut('fast');
							}
						}
					}
					function hAutoScroll() {
						var elapsed, delta;
						if (amplitude) {
							elapsed = Date.now() - timestamp;
							delta = -amplitude * Math.exp(-elapsed / timeConstant);
							if (delta > 0.5 || delta < -0.5) {
								hscroll(xtarget + delta);
								requestAnimationFrame(hAutoScroll);
							} else {
								hscroll(xtarget);
								//        horizontalScroll.fadeOut('fast');
							}

						}
					}
					var touchMove = function (event) {
						if (!me.enableScrolling[key])
							return true;

						if (!me.scrolling[key]) {
							return true;
						}

						if (tapped) {
							event.preventDefault();
							event.stopPropagation();
						}

						var touches = me.getTouches(event);
						if (touches.length > 1) {
							return true;
						}

						var pageY = touches[0].pageY;
						var pageX = touches[0].pageX;

						if (me.simulatetouches) {
							if (touches[0]._pageY != undefined) {
								pageY = touches[0]._pageY;
								pageX = touches[0]._pageX;
							}
						}


						var dy = pageY - touchY;
						var dx = pageX - touchX;
						touchEnd = pageY;
						var touchHorizontalEnd = pageX;
						movedY = dy - scrollY;
						movedX = dx - scrollX;
						moved = true;
						scrollY = dy;
						scrollX = dx;

						var hScrollVisible = horizontalScroll != null ? horizontalScroll[0].style.visibility != 'hidden' : true;
						var vScrollVisible = verticalScroll != null ? verticalScroll[0].style.visibility != 'hidden' : true;


						function drag(e) {
							var y, delta, x;
							if (pressed) {
								y = ypos(e);
								x = xpos(e);
								delta = reference - y;
								xdelta = xreference - x;
								var dragged = "value";
								if (delta > 2 || delta < -2) {
									reference = y;
									dragged = scroll(offset + delta, e);
									track();

									if (dragged == "min" && initialOffset === 0) {
										return true;
									}
									if (dragged == "max" && initialOffset === max) {
										return true;
									}

									if (!vScrollVisible) {
										return true;
									}
									e.preventDefault();
									e.stopPropagation();
									tapped = true;

									return false;
								}
								else {
									if (xdelta > 2 || xdelta < -2) {
										xreference = x;
										dragged = hscroll(xoffset + xdelta, e);
										track();

										if (dragged == "min" && initialXOffset === 0) {
											return true;
										}
										if (dragged == "max" && initialXOffset === xmax) {
											return true;
										}

										if (!hScrollVisible) {
											return true;
										}
										tapped = true;
										e.preventDefault();
										e.stopPropagation();
										return false;
									}
								}
								e.preventDefault();
							}
						}

						if (hScrollVisible || vScrollVisible) {
							if ((hScrollVisible) || (vScrollVisible)) {
								drag(event);

								//      callback(-movedX * 1, -movedY * 1, dx, dy, event);
								//event.preventDefault();
								//event.stopPropagation();
								//if (event.preventManipulation) {
								//    event.preventManipulation();
								//}
								//return false;
							}
						}
					}

					if ($element.on) {
						$element.on(touchMoveName, touchMove);
					}
					else $element.bind(touchMoveName, touchMove);



					var touchCancel = function (event) {
						if (!me.enableScrolling[key])
							return true;

						var touch = me.getTouches(event)[0];
						if (!me.scrolling[key]) {
							return true;
						}

						pressed = false;
						clearInterval(ticker);
						if (jqxAnimations > 10 || jqxAnimations < -10) {
							amplitude = 0.8 * jqxAnimations;
							target = Math.round(offset + amplitude);
							timestamp = Date.now();
							requestAnimationFrame(autoScroll);
							//             verticalScroll.fadeIn(100);
						}
						else if (xjqxAnimations > 10 || xjqxAnimations < -10) {
							amplitude = 0.8 * xjqxAnimations;
							xtarget = Math.round(xoffset + amplitude);
							timestamp = Date.now();
							requestAnimationFrame(hAutoScroll);
							//          horizontalScroll.fadeIn(100);
						}
						else {
							//        horizontalScroll.fadeOut(100);
							//        verticalScroll.fadeOut(100);
						}

						me.scrolling[key] = false;
						if (moved) {
							me.dispatchMouseEvent('mouseup', touch, event.target);
						} else {
							var touch = me.getTouches(event)[0],
								t = me.getRootNode(touch.target);

							//        event.preventDefault();
							//         event.stopPropagation();
							// Dispatch fake mouse up and click events if this touch event did not move
							me.dispatchMouseEvent('mouseup', touch, t);
							me.dispatchMouseEvent('click', touch, t);
							return true;
						}
					}

					if (this.simulatetouches) {
						var windowBindFunc = $(window).on != undefined || $(window).bind;
						var windowMouseUp = function (event) {
							try {
								touchCancel(event);
							}
							catch (er) {
							}
							me.scrolling[key] = false;
						};
						$(window).on != undefined ? $(document).on('mouseup.touchScroll', windowMouseUp) : $(document).bind('mouseup.touchScroll', windowMouseUp);

						if (window.frameElement) {
							if (window.top != null) {
								var eventHandle = function (event) {
									try {
										touchCancel(event);
									}
									catch (er) {
									}
									me.scrolling[key] = false;
								};

								if (window.top.document) {
									$(window.top.document).on ? $(window.top.document).on('mouseup', eventHandle) : $(window.top.document).bind('mouseup', eventHandle);
								}
							}
						}

						var docBindFunc = $(document).on != undefined || $(document).bind;
						var touchEndFunc = function (event) {
							if (!me.scrolling[key]) {
								return true;
							}

							me.scrolling[key] = false;
							var touch = me.getTouches(event)[0],
								target = me.getRootNode(touch.target);

							// Dispatch fake mouse up and click events if this touch event did not move
							me.dispatchMouseEvent('mouseup', touch, target);
							me.dispatchMouseEvent('click', touch, target);
						};

						$(document).on != undefined ? $(document).on('touchend', touchEndFunc) : $(document).bind('touchend', touchEndFunc);
					}

					if ($element.on) {
						$element.on('dragstart', function (event) {
							event.preventDefault();
						});
						$element.on('selectstart', function (event) {
							event.preventDefault();
						});
					}
					$element.on ? $element.on(touchEndName + ' touchcancel.touchScroll', touchCancel) : $element.bind(touchEndName + ' touchcancel.touchScroll', touchCancel);
				}

			});

		$.jqx.cookie = $.jqx.cookie || {};
		$.extend($.jqx.cookie,
			{
				cookie: function (key, value, options) {
					// set cookie.
					if (arguments.length > 1 && String(value) !== "[object Object]") {
						options = $.extend({}, options);

						if (value === null || value === undefined) {
							options.expires = -1;
						}

						if (typeof options.expires === 'number') {
							var days = options.expires, t = options.expires = new Date();
							t.setDate(t.getDate() + days);
						}

						value = String(value);

						return (document.cookie = [
							encodeURIComponent(key), '=',
							options.raw ? value : encodeURIComponent(value),
							options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
							options.path ? '; path=' + options.path : '',
							options.domain ? '; domain=' + options.domain : '',
							options.secure ? '; secure' : ''
						].join(''));
					}
					// get cookie...
					options = value || {};
					var result, decode = options.raw ? function (s) { return s; } : decodeURIComponent;
					return (result = new RegExp('(?:^|; )' + encodeURIComponent(key) + '=([^;]*)').exec(document.cookie)) ? decode(result[1]) : null;
				}
			});

		// stringutilities
		$.jqx.string = $.jqx.string || {};
		$.extend($.jqx.string,
			{
				replace: function (text, stringToFind, stringToReplace) {
					if (stringToFind === stringToReplace) return this;
					var temp = text;
					var index = temp.indexOf(stringToFind);
					while (index != -1) {
						temp = temp.replace(stringToFind, stringToReplace);
						index = temp.indexOf(stringToFind);
					}
					return temp;
				},

				contains: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					return fullString.indexOf(value) != -1;
				},

				containsIgnoreCase: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					return fullString.toString().toUpperCase().indexOf(value.toString().toUpperCase()) != -1;
				},

				equals: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					fullString = this.normalize(fullString);

					if (value.length == fullString.length) {
						return fullString.slice(0, value.length) == value;
					}

					return false;
				},

				equalsIgnoreCase: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					fullString = this.normalize(fullString);

					if (value.length == fullString.length) {
						return fullString.toUpperCase().slice(0, value.length) == value.toUpperCase();
					}

					return false;
				},

				startsWith: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					return fullString.slice(0, value.length) == value;
				},

				startsWithIgnoreCase: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					return fullString.toUpperCase().slice(0, value.length) == value.toUpperCase();
				},

				normalize: function (fullString) {
					if (fullString.charCodeAt(fullString.length - 1) == 65279) {
						fullString = fullString.substring(0, fullString.length - 1);
					}

					return fullString;
				},

				endsWith: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					fullString = this.normalize(fullString);
					return fullString.slice(-value.length) == value;
				},

				endsWithIgnoreCase: function (fullString, value) {
					if (fullString == null || value == null)
						return false;

					fullString = this.normalize(fullString);

					return fullString.toUpperCase().slice(-value.length) == value.toUpperCase();
				}
			});

		if (!$.easing) {
			$.easing = {};
		}
		$.extend($.easing, {
			easeOutBack: function (x, t, b, c, d, s) {
				if (s == undefined) s = 1.70158;
				return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
			},
			easeInQuad: function (x, t, b, c, d) {
				return c * (t /= d) * t + b;
			},
			easeInOutCirc: function (x, t, b, c, d) {
				if ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
				return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
			},
			easeInOutSine: function (x, t, b, c, d) {
				return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
			},
			easeInCubic: function (x, t, b, c, d) {
				return c * (t /= d) * t * t + b;
			},
			easeOutCubic: function (x, t, b, c, d) {
				return c * ((t = t / d - 1) * t * t + 1) + b;
			},
			easeInOutCubic: function (x, t, b, c, d) {
				if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;
				return c / 2 * ((t -= 2) * t * t + 2) + b;
			},
			easeInSine: function (x, t, b, c, d) {
				return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
			},
			easeOutSine: function (x, t, b, c, d) {
				return c * Math.sin(t / d * (Math.PI / 2)) + b;
			},
			easeInOutSine: function (x, t, b, c, d) {
				return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
			}
		});
	})(jqxBaseFramework);

	(function ($) {
		if ($.event && $.event.special) {
			$.extend($.event.special,
				{
					"close": { noBubble: true },
					"open": { noBubble: true },
					"cellclick": { noBubble: true },
					"rowclick": { noBubble: true },
					"tabclick": { noBubble: true },
					"selected": { noBubble: true },
					"expanded": { noBubble: true },
					"collapsed": { noBubble: true },
					"valuechanged": { noBubble: true },
					"expandedItem": { noBubble: true },
					"collapsedItem": { noBubble: true },
					"expandingItem": { noBubble: true },
					"collapsingItem": { noBubble: true }
				});
		}
		if ($.fn.extend) {
			$.fn.extend({
				ischildof: function (filter_string) {
					if (!$(this).parents) {
						var result = filter_string.element.contains(this.element)
						return result;
					}

					var parents = $(this).parents().get();

					for (var j = 0; j < parents.length; j++) {
						if (typeof filter_string != "string") {
							var parent = parents[j];
							if (filter_string !== undefined) {
								if (parent == filter_string[0])
									return true;
							}
						}
						else {
							if (filter_string !== undefined) {
								if ($(parents[j]).is(filter_string)) {
									return true;
								}
							}
						}
					}

					return false;
				}
			});
		}

		$.fn.jqxProxy = function () {
			var widget = $(this).data().jqxWidget;
			var args = Array.prototype.slice.call(arguments, 0);
			var element = widget.element;
			if (!element) element = widget.base.element;
			return $.jqx.jqxWidgetProxy(widget.widgetName, element, args);
		}

		var originalVal = $.originalVal = $.fn.val;
		$.fn.val = function (value) {
			if (typeof value == 'undefined') {
				if ($(this).hasClass('jqx-widget') || $(this).hasClass('jqx-input-group')) {
					var widget = $(this).data().jqxWidget;
					if (widget && widget.val) {
						return widget.val();
					}
				}
				if (this[0] && this[0].tagName.toLowerCase().indexOf('angular') >= 0) {
					var widget = $(this).find('.jqx-widget').data().jqxWidget;
					if (widget && widget.val) {
						return widget.val();
					}

				}
				return originalVal.call(this);
			}
			else {
				if ($(this).hasClass('jqx-widget') || $(this).hasClass('jqx-input-group')) {
					var widget = $(this).data().jqxWidget;
					if (widget && widget.val) {
						if (arguments.length != 2) {
							return widget.val(value);
						}
						else {
							return widget.val(value, arguments[1]);
						}
					}
				}
				if (this[0] && this[0].tagName.toLowerCase().indexOf('angular') >= 0) {
					var widget = $(this).find('.jqx-widget').data().jqxWidget;
					if (widget && widget.val) {
						if (arguments.length != 2) {
							return widget.val(value);
						}
						else {
							return widget.val(value, arguments[1]);
						}
					}

				}

				return originalVal.call(this, value);
			}
		};

		if ($.fn.modal && $.fn.modal.Constructor) {
			$.fn.modal.Constructor.prototype.enforceFocus = function () {
				$(document)
					.off('focusin.bs.modal') // guard against infinite focus loop
					.on('focusin.bs.modal', $.proxy(function (e) {
						if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
							if ($(e.target).parents().hasClass('jqx-popup'))
								return true;
							this.$element.trigger('focus')
						}
					}, this));
			}
		}

		$.fn.coord = function (options) {
			var docElem, win,
				box = { top: 0, left: 0 },
				elem = this[0],
				doc = elem && elem.ownerDocument;
			if (!doc) {
				return;
			}
			docElem = doc.documentElement;
			if (!$.contains(docElem, elem)) {
				return box;
			}
			if (typeof elem.getBoundingClientRect !== undefined) {
				box = elem.getBoundingClientRect();
			}
			var getWindow = function (elem) {
				return $.isWindow(elem) ?
					elem :
					elem.nodeType === 9 ?
						elem.defaultView || elem.parentWindow :
						false;
			};

			win = getWindow(doc);
			var additionalLeftOffset = 0;
			var additionalTopOffset = 0;
			var agent = navigator.userAgent.toLowerCase();
			var result = agent.indexOf('ipad') != -1 || agent.indexOf('iphone') != -1;
			if (result) {
				// fix for iphone/ipad left offsets.
				additionalLeftOffset = 2;
			}
			if (true == options) {
				if (document.body.style.position != 'static' && document.body.style.position != '') {
					var coords = $(document.body).coord();
					additionalLeftOffset = -coords.left;
					additionalTopOffset = -coords.top;
				}
			}

			return {
				top: additionalTopOffset + box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
				left: additionalLeftOffset + box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
			};
		};

		$.jqx.ripplers = [];
		$.jqx.ripple = function (element, hostElement, hostElementType) {
			if (!hostElement) {
				hostElement = element;
			}

			var rippler = $(element);
			var mouseCaptured = false;

			rippler.append("<span class='ink'></span>");
			var ink = rippler.find('.ink');


			var hasRippler = false;

			for (var i = 0; i < $.jqx.ripplers.length; i++) {
				var ripplerItem = $.jqx.ripplers[i];

				if (ripplerItem.element[0] === element[0]) {
					hasRippler = true;
					break;
				}
			}

			if (!hasRippler) {
				$.jqx.ripplers.push({ ink: ink, element: element, hostElement: hostElement, hostElementType: hostElementType });
			}

			if (hostElementType === "checkbox" || hostElementType === "radiobutton") {

				// set .ink diametr
				var d = Math.max(rippler.outerWidth(), rippler.outerHeight());
				ink.css({ height: d, width: d });

				var x = rippler.width() / 2 - ink.width() / 2;
				var y = rippler.height() / 2 - ink.height() / 2;

				// set .ink position and add class .animate
				ink.css({
					top: y + 'px',
					left: x + 'px'
				});
			}

			// Ripple-effect animation
			if ($.jqx.ripplers.length === 1) {
				$(document).on('mouseup', function (e) {
					$.jqx.ripple.mouseCaptured = false;

					for (var i = 0; i < $.jqx.ripplers.length; i++) {
						var rippler = $.jqx.ripplers[i];

						rippler.ink.removeClass('active');
						rippler.element.removeClass('active');

						if (hostElementType !== "checkbox" && hostElementType !== "radiobutton") {
							if (rippler.ink.hasClass('animate')) {
								rippler.ink.removeClass('animate');
							}
						}
					}
				});
			}
			hostElement.off('mousedown.ripple');
			hostElement.on('mousedown.ripple', function (e) {
				var rippler = $(element);

				$.jqx.ripple.mouseCaptured = true;

				setTimeout(function () {
					// create .ink element if it doesn't exist

					if (rippler.find('.ink').length == 0) {
						rippler.append("<span class='ink'></span>");
					}

					var ink = rippler.find('.ink');

					// prevent quick double clicks
					ink.removeClass('animate');


					// set .ink diametr
					if (!ink.height() && !ink.width()) {
						var d = Math.max(rippler.outerWidth(), rippler.outerHeight());
						ink.css({ height: d, width: d });
					}

					if (hostElementType === "checkbox" || hostElementType === "radiobutton") {
						if (hostElementType === "checkbox") {
							if (hostElement.jqxCheckBox('disabled')) {
								return;
							}
						}

						if (hostElementType === "radiobutton") {
							if (hostElement.jqxRadioButton('disabled')) {
								return;
							}
						}

						// get click coordinates
						var x = rippler.width() / 2 - ink.width() / 2;
						var y = rippler.height() / 2 - ink.height() / 2;

						// set .ink position and add class .animate
						ink.css({
							top: y + 'px',
							left: x + 'px'
						}).addClass('animate');

						ink.on('animationend', function () {
							if ($.jqx.ripple.mouseCaptured) {
								ink.removeClass('animate')
								ink.addClass('active')
								element.addClass('active')
							}
						});

						return;
					}

					// get click coordinates
					var x = e.pageX - rippler.offset().left - ink.width() / 2;
					var y = e.pageY - rippler.offset().top - ink.height() / 2;

					// set .ink position and add class .animate
					ink.css({
						top: y + 'px',
						left: x + 'px'
					}).addClass('animate');
				});
			});
		}
	})(jqxBaseFramework);
})();




/***/ }),

/***/ 3907:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {
    var ArrayExporter = (function () {

        var exportModules = {},
            data, dataFields, styles, exporter, stylesArray, hierarchy, exportFormat, filename;

        function exportData(exporter, data, dataFields, styles, hierarchy, exportFormat, filename) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            that.hierarchy = hierarchy;
            that.exportFormat = exportFormat;
            that.filename = filename;

            exporter.beginFile(filename);
            exportHeader(exporter);
            exportContent(exporter);
            exporter.endFile(filename);
            return exporter.getFile();
        }

        function exportHeader(exporter) {
            var exportHeaders = true;
            $.each(dataFields, function () {
                if (this.hidden) {
                    exportHeaders = false;
                    return false;
                }
            });

            exporter.beginHeader(exportHeaders);
            var index = 0;
            for (var cellContent in dataFields) {
                if (dataFields[cellContent].columnsDataFields) {
                    cellContent = dataFields[cellContent].columnsDataFields[index].displayfield;
                }
                var style = getHeaderStyle(cellContent, dataFields[cellContent]);
                exporter.appendHeaderCell(dataFields[cellContent], cellContent, style, exportHeaders, index);
                index++;
            }
            exporter.endHeader(exportHeaders);
        }

        function exportContent(exporter) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            exporter.beginBody();
            if (that.hierarchy) {
                var exporHierarchy = function (data) {
                    for (var i = 0; i < data.length; i += 1) {
                        if (data[i] !== undefined) {
                            exporter.hierarchy = true;
                            exporter.beginRow(data[i].level);
                            exportRow(exporter, data[i], i, true);
                            if (data[i].records) {
                                exporter.beginRows(data[i].level);
                                exporHierarchy(data[i].records);
                                exporter.endRows(data[i].level);
                            }
                            exporter.endRow(data[i].level);
                        }
                    }
                }
                exporHierarchy(data);
                exporter.endBody();
                return;
            }

            for (var i = 0; i < data.length; i += 1) {
                if (data[i] !== undefined) {
                    exportRow(exporter, data[i], i);
                }
            }
            exporter.endBody();
        }

        function exportRow(exporter, data, rowId, hierarchy) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            var style;
            if (hierarchy != true) {
                exporter.beginRow();
            }
            var indx = 0;
            for (var column in dataFields) {
                if (dataFields[column].columnsDataFields) {
                    column = dataFields[column].columnsDataFields[indx].displayfield;
                }

                style = getRowCellStyle(rowId, column);
                if (style) {
                    if (style.level != undefined) {
                        if (style.index - 1 > data.level && style.index - 1 < style.maxLevel) {
                            indx++;
                            continue;
                        }
                    }
                    if (style.maxLevel != undefined) {
                        if (style.index - 1 == style.maxLevel) {
                            style = $.extend({}, style);
                            style.merge = style.maxLevel - data.level - 1;
                        }
                    }
                }
                if (data.level != undefined && data.label != undefined) {
                    if (that.exportFormat === "xml" || that.exportFormat === "json") {
                        var dataGroup = {};
                        dataGroup['text'] = "group";
                        exporter.appendBodyCell(data.label, dataGroup, style, data, indx, "group");
                        break;
                    }
                }

                if (data.hasOwnProperty(column)) {
                    exporter.appendBodyCell(data[column], dataFields[column], style, data, indx);
                }
                else {
                    exporter.appendBodyCell("", dataFields[column], style, data, indx);
                }
                indx++;
            }
            if (hierarchy != true) {
                exporter.endRow();
            }
        }

        function getHeaderStyle(columnName, dataField) {
            if (dataField.style) {
                return styles[dataField.style];
            }

            var rowStyles = getStylesArray();
            if (rowStyles.length > 0) {
                return rowStyles[0].style;
            }
            return null;
        }

        function getStylesArray() {
            if (!stylesArray) {
                stylesArray = new Array();
                $.each(styles, function (index, value) {
                    stylesArray[stylesArray.length] = { name: index, style: value };
                });
            }

            return stylesArray;
        }

        function getRowCellStyle(rowId, column) {
            var dataField = dataFields[column];
            if (dataField) {
                if (dataField.customCellStyles) {
                    var customStyle = dataField.customCellStyles[rowId];
                    if (customStyle) {
                        return styles[customStyle];
                    }
                }

                if (dataField.cellStyle) {
                    if (dataField.cellAltStyle) {
                        var styleId = rowId % 2;
                        if (styleId == 0)
                            return styles[dataField.cellStyle];
                        return styles[dataField.cellAltStyle];
                    }
                    return styles[dataField.cellStyle];
                }
                else {
                    var rowStyles = getStylesArray();
                    if (rowStyles.length > 0) {
                        var styleId = rowId % (rowStyles.length - 1);
                        var style = rowStyles[styleId + 1].style;
                        return style;
                    }
                }
            }
            return null;
        }

        function createHiddenInput(value, name, form) {
            var input = document.createElement('input');
            input.name = name;
            input.value = value;
            input.type = 'hidden';
            form.appendChild(input);
            return input;
        }

        function createHiddenTextArea(value, name, form) {
            var textArea = document.createElement('textarea');
            textArea.name = name;
            textArea.value = value;
            //      textArea.type = 'hidden';
            form.appendChild(textArea);
            return textArea;
        }

        function createForm(filename, format, content, exportServer, charset) {
            var form = document.createElement('form');
            createHiddenInput(filename, 'filename', form);
            createHiddenInput(format, 'format', form);
            createHiddenTextArea(content, 'content', form);
            if (exportServer == undefined || exportServer == '') {
                if (window && window.location.toString().indexOf('jqwidgets.com') >= 0) {
                    exportServer = 'https://jqwidgets.com/export_server/dataexport.php';
                }
                else {
                    exportServer = 'http://jquerygrid.net/export_server/dataexport.php';
                }
            }

            form.action = exportServer;
            form.method = 'post';
            if (charset) {
                form.acceptCharset = charset;
            }

            document.body.appendChild(form);
            return form;
        }

        exporter = function (inputData, inputDataFields, inputStyles, exportServer, hierarchy, exportFormat) {
            if (!(this instanceof ArrayExporter)) {
                return new ArrayExporter(inputData, inputDataFields, inputStyles, hierarchy, exportFormat);
            }
            data = inputData;
            dataFields = inputDataFields;
            styles = inputStyles;

            this.exportTo = function (format, hierarchy, exportFormat, filename) {
                format = format.toString().toLowerCase();
                var module = exportModules[format];
                if (typeof module === 'undefined') {
                    throw 'You can\'t export to ' + format + ' format.';
                }
                if (format === "pdf" && filename == undefined) {
                    var table = this.exportTo(format, hierarchy, format, "pdf");
                    if (!$.jqx.pdfExport) {
                        $.jqx.pdfExport =
                        {
                            orientation: "portrait",
                            paperSize: "a4"
                        }
                    }

                    var doc = new pdfDataExport($.jqx.pdfExport.orientation, 'pt', $.jqx.pdfExport.paperSize);
                    doc.cellInitialize();
                    var headerCells = $(table).find('th');
                    var tableRows = $(table).find('tr');
                    var rows = 0;
                    doc.setFontSize(13 * 72 / 96);
                    var totalWidth = 595;
                    switch ($.jqx.pdfExport.paperSize) {
                        case "legal":
                            var totalWidth = 612;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 1008;
                            }
                            break;
                        case "letter":
                            var totalWidth = 612;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 792;
                            }
                            break;
                        case "a3":
                            var totalWidth = 841;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 1190;
                            }
                            break;
                        case "a4":
                            var totalWidth = 595;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 842;
                            }
                            break;
                        case "a5":
                            var totalWidth = 420;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 595;
                            }
                            break
                    }
                    totalWidth -= 20;
                    var totalColumnsWidth = 0;
                    var columnWidths = [];
                    $.each(headerCells, function (index) {
                        var width = parseInt(this.style.width);
                        if (isNaN(width)) {
                            width = 25;
                        }
                        var widthPoints = width * 72 / 96;
                        columnWidths[index] = widthPoints;
                        totalColumnsWidth += widthPoints;
                    });

                    if (headerCells.length === 0) {
                        $.each(tableRows[0].cells, function (index) {
                            var width = parseInt(this.style.width);
                            if (isNaN(width)) {
                                width = totalWidth / tableRows[0].cells.length;
                            }
                            var widthPoints = width * 72 / 96;
                            columnWidths[index] = widthPoints;
                            totalColumnsWidth += widthPoints;
                        });
                    }

                    if (totalColumnsWidth > totalWidth) {
                        $.each(columnWidths, function (index) {
                            columnWidths[index] = (columnWidths[index] / totalColumnsWidth) * 100;
                            columnWidths[index] = columnWidths[index] * totalWidth / 100;
                        });
                    }

                    $.each(headerCells, function (index) {
                        var widthPoints = columnWidths[index];
                        var heightPoints = 25 * 72 / 96;
                        var textDimension = doc.getTextDimensions($(this).html());
                        var cellText = $(this).html();
                        if (textDimension.w + 3 > widthPoints) {
                            var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                            var newText = splitText[0];
                            if (newText.length > 3) {
                                cellText = newText.substring(0, newText.length - 3) + "...";
                            }
                            else cellText = newText.substring(0, 1) + "...";
                            var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                            var newText = splitText[0];
                            if (newText != cellText) {
                                cellText = newText;
                            }
                        }
                        doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                    });

                    rows++;
                    $.each(tableRows, function (index) {
                        if (index === 0) return true;
                        var rowCells = $(this).children();
                        var isTreeGrid = rowCells.length > headerCells.length && headerCells.length > 0;
                        if (isTreeGrid) {
                            var mergeLength = rowCells.length - headerCells.length;
                            var cellText = "";
                            var widthPoints = columnWidths[0];
                            var heightPoints = 25 * 72 / 96;
                            for (var i = 0; i <= mergeLength; i++) {
                                var cellHTML = rowCells[i].innerHTML;
                                if (cellHTML === "+" || cellHTML === "-") cellHTML = cellHTML + " ";
                                if (cellHTML === "&nbsp;") cellHTML = "   ";
                                cellText += cellHTML;
                            }
                            var textDimension = doc.getTextDimensions(cellText);
                            if (textDimension.w + 3 > widthPoints) {
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText.length > 3) {
                                    cellText = newText.substring(0, newText.length - 3) + "...";
                                }
                                else cellText = newText.substring(0, 1) + "...";
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText != cellText) {
                                    cellText = newText;
                                }
                            }

                            doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                            for (var i = mergeLength + 1; i < rowCells.length; i++) {
                                var index = i - mergeLength;
                                var widthPoints = columnWidths[index];
                                var heightPoints = 25 * 72 / 96;
                                var cellText = $(rowCells[i]).html();
                                var textDimension = doc.getTextDimensions($(rowCells[i]).html());
                                if (textDimension.w + 3 > widthPoints) {
                                    var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                    var newText = splitText[0];
                                    if (newText.length > 3) {
                                        cellText = newText.substring(0, newText.length - 3) + "...";
                                    }
                                    else cellText = newText.substring(0, 1) + "...";
                                    var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                    var newText = splitText[0];
                                    if (newText != cellText) {
                                        cellText = newText;
                                    }
                                }
                                doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                            }
                            rows++;
                            return true;
                        }

                        $.each(rowCells, function (index) {
                            var widthPoints = columnWidths[index];
                            var heightPoints = 25 * 72 / 96;
                            var cellText = $(this).html();
                            var textDimension = doc.getTextDimensions($(this).html());
                            if (textDimension.w + 3 > widthPoints) {
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText.length > 3) {
                                    cellText = newText.substring(0, newText.length - 3) + "...";
                                }
                                else cellText = newText.substring(0, 1) + "...";
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText != cellText) {
                                    cellText = newText;
                                }
                            }
                            doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                        }
                        );
                        rows++;
                    });
                    if ($.jqx.browser.msie && $.jqx.browser.version < 10) {
                        throw new Error("PDF export requires a browser with HTML5 support");
                        return;
                    }

                    return doc;
                }

                return exportData(module, data, dataFields, styles, hierarchy, exportFormat, filename);
            };

            this.exportToFile = function (format, filename, exportServer, charset, hierarchy) {
                if (format === "pdf") {
                    var table = this.exportTo(format, hierarchy, format, filename);
                    if (!$.jqx.pdfExport) {
                        $.jqx.pdfExport =
                        {
                            orientation: "portrait",
                            paperSize: "a4"
                        }
                    }

                    var doc = new pdfDataExport($.jqx.pdfExport.orientation, 'pt', $.jqx.pdfExport.paperSize);
                    if (charset == "utf-8" || charset == "UTF-8") {
                        doc.setFont("courier", "normal");
                    }

                    doc.cellInitialize();
                    var headerCells = $(table).find('th');
                    var tableRows = $(table).find('tr');
                    var rows = 0;
                    doc.setFontSize(13 * 72 / 96);
                    var totalWidth = 595;
                    switch ($.jqx.pdfExport.paperSize) {
                        case "legal":
                            var totalWidth = 612;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 1008;
                            }
                            break;
                        case "letter":
                            var totalWidth = 612;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 792;
                            }
                            break;
                        case "a3":
                            var totalWidth = 841;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 1190;
                            }
                            break;
                        case "a4":
                            var totalWidth = 595;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 842;
                            }
                            break;
                        case "a5":
                            var totalWidth = 420;
                            if ($.jqx.pdfExport.orientation !== "portrait") {
                                totalWidth = 595;
                            }
                            break
                    }
                    totalWidth -= 20;
                    var totalColumnsWidth = 0;
                    var columnWidths = [];
                    $.each(headerCells, function (index) {
                        var width = parseInt(this.style.width);
                        if (isNaN(width)) {
                            width = 25;
                        }
                        var widthPoints = width * 72 / 96;
                        columnWidths[index] = widthPoints;
                        totalColumnsWidth += widthPoints;
                    });

                    if (headerCells.length === 0) {
                        $.each(tableRows[0].cells, function (index) {
                            var width = parseInt(this.style.width);
                            if (isNaN(width)) {
                                width = totalWidth / tableRows[0].cells.length;
                            }
                            var widthPoints = width * 72 / 96;
                            columnWidths[index] = widthPoints;
                            totalColumnsWidth += widthPoints;
                        });
                    }

                    if (totalColumnsWidth > totalWidth) {
                        $.each(columnWidths, function (index) {
                            columnWidths[index] = (columnWidths[index] / totalColumnsWidth) * 100;
                            columnWidths[index] = columnWidths[index] * totalWidth / 100;
                        });
                    }

                    $.each(headerCells, function (index) {
                        var widthPoints = columnWidths[index];
                        var heightPoints = 25 * 72 / 96;
                        var textDimension = doc.getTextDimensions($(this).html());
                        var cellText = $(this).html();
                        if (textDimension.w + 3 > widthPoints) {
                            var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                            var newText = splitText[0];
                            if (newText.length > 3) {
                                cellText = newText.substring(0, newText.length - 3) + "...";
                            }
                            else cellText = newText.substring(0, 1) + "...";
                            var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                            var newText = splitText[0];
                            if (newText != cellText) {
                                cellText = newText;
                            }
                        }
                        doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                    });

                    rows++;
                    $.each(tableRows, function (index) {
                        if (index === 0) return true;
                        var rowCells = $(this).children();
                        var isTreeGrid = rowCells.length > headerCells.length && headerCells.length > 0;
                        if (isTreeGrid) {
                            var mergeLength = rowCells.length - headerCells.length;
                            var cellText = "";
                            var widthPoints = columnWidths[0];
                            var heightPoints = 25 * 72 / 96;
                            for (var i = 0; i <= mergeLength; i++) {
                                var cellHTML = rowCells[i].innerHTML;
                                if (cellHTML === "+" || cellHTML === "-") cellHTML = cellHTML + " ";
                                if (cellHTML === "&nbsp;") cellHTML = "   ";
                                cellText += cellHTML;
                            }
                            var textDimension = doc.getTextDimensions(cellText);
                            if (textDimension.w + 3 > widthPoints) {
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText.length > 3) {
                                    cellText = newText.substring(0, newText.length - 3) + "...";
                                }
                                else cellText = newText.substring(0, 1) + "...";
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText != cellText) {
                                    cellText = newText;
                                }
                            }

                            doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                            for (var i = mergeLength + 1; i < rowCells.length; i++) {
                                var index = i - mergeLength;
                                var widthPoints = columnWidths[index];
                                var heightPoints = 25 * 72 / 96;
                                var cellText = $(rowCells[i]).html();
                                if (cellText === "&nbsp;") cellText = "   ";

                                var textDimension = doc.getTextDimensions($(rowCells[i]).html());
                                if (textDimension.w + 3 > widthPoints) {
                                    var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                    var newText = splitText[0];
                                    if (newText.length > 3) {
                                        cellText = newText.substring(0, newText.length - 3) + "...";
                                    }
                                    else cellText = newText.substring(0, 1) + "...";
                                    var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                    var newText = splitText[0];
                                    if (newText != cellText) {
                                        cellText = newText;
                                    }
                                }
                                doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                            }
                            rows++;
                            return true;
                        }

                        $.each(rowCells, function (index) {
                            var widthPoints = columnWidths[index];
                            var heightPoints = 25 * 72 / 96;
                            var cellText = $(this).html();
                            if (cellText === "&nbsp;") cellText = "   ";

                            var textDimension = doc.getTextDimensions($(this).html());
                            if (textDimension.w + 3 > widthPoints) {
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText.length > 3) {
                                    cellText = newText.substring(0, newText.length - 3) + "...";
                                }
                                else cellText = newText.substring(0, 1) + "...";
                                var splitText = doc.splitTextToSize(cellText, widthPoints - 3);
                                var newText = splitText[0];
                                if (newText != cellText) {
                                    cellText = newText;
                                }
                            }
                            doc.cell(10, 10, widthPoints, heightPoints, cellText, rows);
                        }
                        );
                        rows++;
                    });
                    if ($.jqx.browser.msie && $.jqx.browser.version < 10) {
                        throw new Error("PDF export requires a browser with HTML5 support");
                        return;
                    }

                    doc.save(filename + ".pdf");
                    return;
                }

                var content = this.exportTo(format, hierarchy, format, filename),
                    form = createForm(filename, format, content, exportServer, charset);
                form.submit();
                document.body.removeChild(form);
            };

            this.exportToLocalFile = function (format, filename, hierarchy, exportFormat) {
                var content = this.exportTo(format, hierarchy, exportFormat);
                document.location.href = 'data:application/octet-stream;filename=' + filename + ',' + encodeURIComponent(content);
            };

        };

        exporter.extend = function (exportFormat, exporter) {
            if (exporter instanceof $.jqx.dataAdapter.DataExportModuleBase) {
                exportModules[exportFormat] = exporter;
            } else {
                throw 'The module ' + exportFormat + ' is not instance of DataExportModuleBase.';
            }
        };

        return exporter;

    }());

    $.jqx.dataAdapter.ArrayExporter = ArrayExporter;

})(jqxBaseFramework);


(function ($) {

    //Defines common interface for all modules used for exportation
    var DataExportModuleBase = function () {

        this.formatData = function (data, type, formatString, localization) {
            if (type === 'date') {
                var tmpdate = "";
                if (typeof data === 'string') {
                    tmpdate = $.jqx.dataFormat.tryparsedate(data);
                    data = tmpdate;
                }
                if (data === "" || data === null) return "";
                tmpdate = $.jqx.dataFormat.formatdate(data, formatString, localization);
                if ((tmpdate && tmpdate.toString() == "NaN") || tmpdate == null) return "";
                data = tmpdate;
            } else if (type === 'number' || type === 'float' || type === 'int' || type == 'integer') {
                if (data === "" || data === null) return "";

                if (!isNaN(new Number(data))) {
                    var tmpdata = $.jqx.dataFormat.formatnumber(data, formatString, localization);
                    if (tmpdata.toString() == "NaN") return "";
                    else data = tmpdata;
                }
            } else {
                data = data;
            }
            if (data === null) return "";
            return data;
        };

        this.getFormat = function (dataOptions) {
            var formatString = dataOptions ? dataOptions['formatString'] : "";
            var localization = dataOptions ? dataOptions['localization'] : "";
            var dataType = 'string';
            dataType = dataOptions ? dataOptions['type'] : 'string';

            if (dataType == 'number' || dataType == 'float') {
                if (!formatString) formatString = 'f2';
            }
            if (dataType == 'int' || dataType == 'integer') {
                if (!formatString) formatString = 'n0';
            }
            if (dataType == 'date') {
                if (!formatString) formatString = 'd';
            }
            return { type: dataType, formatString: formatString, localization: localization };
        };

        this.beginFile = function () {
            throw 'Not implemented!';
        };

        this.beginHeader = function () {
            throw 'Not implemented!';
        };

        this.appendHeaderCell = function () {
            throw 'Not implemented!';
        };

        this.endHeader = function () {
            throw 'Not implemented!';
        };

        this.beginBody = function () {
            throw 'Not implemented!';
        };

        this.beginRow = function () {
            throw 'Not implemented!';
        };

        this.beginRows = function () {
            throw 'Not implemented!';
        };

        this.endRows = function () {
            throw 'Not implemented!';
        };

        this.appendBodyCell = function () {
            throw 'Not implemented!';
        };

        this.endRow = function () {
            throw 'Not implemented!';
        };

        this.endBody = function () {
            throw 'Not implemented!';
        };

        this.endFile = function () {
            throw 'Not implemented!';
        };

        this.getFile = function () {
            throw 'Not implemented!';
        };
    }

    $.jqx.dataAdapter.DataExportModuleBase = DataExportModuleBase;

})(jqxBaseFramework);

//Extending the exporter with TSV and CSV exporters
(function ($) {

    //Value exporter. This object is common prototype for TSV and CVS.
    var SvExporter = function (inValueSeparator) {

        var file, valueSeparator, hasHeader;
        var rowIndex = 0;
        var me = this;

        this.beginFile = function () {
            file = '';
        };

        this.beginHeader = function () {
        };

        this.appendHeaderCell = function (data, fieldName, style, exportHeader, index) {
            if (style) {
                if (style.level != undefined) {
                    if (index < style.maxLevel) {
                        return;
                    }
                    else if (index === style.maxLevel) {
                        if (exportHeader) {
                            appendCell(data.text);
                        }
                        for (var i = 0; i < style.maxLevel; i++) {
                            appendCell("");
                        }
                        return;
                    }
                }
            }

            hasHeader = exportHeader;
            if (exportHeader) {
                appendCell(data.text);
            }
        };

        this.endHeader = function () {
            this.endRow();
        };

        this.beginBody = function () {
            rowIndex = 0;
        };

        this.beginRow = function () {
            if ((rowIndex > 0) || (rowIndex == 0 && hasHeader)) {
                file += '\n';
            }
            rowIndex++;
        };

        this.appendBodyCell = function (data, dataType, style, row, index) {
            if (style) {
                if (style.maxLevel != undefined) {
                    if (index === style.maxLevel) {
                        appendCell(data, dataType);
                        for (var i = 0; i < style.maxLevel - row.level - 1; i++) {
                            appendCell("", dataType);
                        }
                        return;
                    }
                }
            }
            appendCell(data, dataType);
        };

        this.endRow = function () {
            file = file.substring(0, file.length - 1);
        };

        this.endBody = function () {
        };

        this.endFile = function () {
        };

        this.getFile = function () {
            return file;
        };

        function prepareData(data, dataOptions) {
            if (dataOptions) {
                var format = me.getFormat(dataOptions);
                data = me.formatData(data, format.type, format.formatString, format.localization);
            }
            data = '"' + data + '"';
            return data;
        };

        function appendCell(data, dataOptions) {
            data = prepareData(data, dataOptions);
            file += data + inValueSeparator;
        };

    };

    SvExporter.prototype = new $.jqx.dataAdapter.DataExportModuleBase();

    var CsvExporter = function () { };
    CsvExporter.prototype = new SvExporter(',');

    var TsvExporter = function () { };
    TsvExporter.prototype = new SvExporter('\t');

    $.jqx.dataAdapter.ArrayExporter.extend('csv', new CsvExporter());
    $.jqx.dataAdapter.ArrayExporter.extend('tsv', new TsvExporter());

})(jqxBaseFramework);

//Extending the exporter with HTML exporter
(function ($) {

    var HtmlExporter = function () {
        var isPDF = false;
        var file;
        var hasHeader;
        var rowIndex = 0;

        this.setPDF = function () {
            isPDF = true;
        };

        this.beginFile = function (filename) {
            if (isPDF || filename == undefined) {
                file = '<table style="empty-cells: show;" cellspacing="0" cellpadding="2">';
            }
            else {
                file = '<html>\n\t<head>\n\t\t<title></title>\n' +
					   '\t\t<meta http-equiv=Content-type content=\"text/html; charset=UTF-8\">\n\t</head>\n\t<body>\n' +
					   '\t\t<table style="empty-cells: show;" cellspacing="0" cellpadding="2">';
            }
        };

        this.beginHeader = function () {
            if (isPDF) {
                file += '\n\t<thead><tr>';
            }
            else {
                file += '\n\t\t\t<thead>';
            }
        };

        this.appendHeaderCell = function (data, fieldName, style, exportHeader) {
            hasHeader = exportHeader;
            if (!exportHeader) return;

            if (isPDF) {
                file += '\n\t\t\t\t<th style="' + buildStyle(style) + '">' + data.text + '</th>';
            }
            else {
                if (style.disabled) return;

                if (style.merge) {
                    if (data.width) {
                        file += '\n\t\t\t\t<th colspan=' + (1 + style.merge) + ' style="width: ' + data.width + 'px; ' + buildStyle(style) + '">' + data.text + '</th>';
                    }
                    else {
                        file += '\n\t\t\t\t<th colspan=' + (1 + style.merge) + ' style="' + buildStyle(style) + '">' + data.text + '</th>';
                    }
                }
                else {
                    if (data.width) {
                        file += '\n\t\t\t\t<th style="width: ' + data.width + 'px; ' + buildStyle(style) + '">' + data.text + '</th>';
                    }
                    else {
                        file += '\n\t\t\t\t<th style="' + buildStyle(style) + '">' + data.text + '</th>';
                    }
                }
            }
        };

        this.endHeader = function () {
            if (isPDF) {
                file += '\n\t</tr></thead>';
            }
            else {
                file += '\n\t\t\t</thead>';
            }
        };

        this.beginBody = function () {
            if (isPDF) {
                file += '\n\t<tbody>';
            }
            else {
                file += '\n\t\t\t<tbody>';
            }
            rowIndex = 0;
        };

        this.beginRow = function () {
            if (isPDF) {
                file += '\n\t<tr>';
            }
            else {
                file += '\n\t\t\t\t<tr>';
            }
            rowIndex++;
        };

        this.appendBodyCell = function (data, dataOptions, style) {
            var format = this.getFormat(dataOptions);
            if (data === "") data = "&nbsp;";
            if (isPDF) {
                if (rowIndex == 1 && !hasHeader) {
                    file += '\n\t\t\t\t\t<td style="' + buildStyle(style) + ' border-top-width: 1px;">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                }
                else {
                    file += '\n\t\t\t\t\t<td style="' + buildStyle(style) + '">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                }
            }
            else {
                if (style.merge) {
                    if (rowIndex == 1 && !hasHeader) {
                        file += '\n\t\t\t\t\t<td colspan=' + (1 + style.merge) + ' style="' + buildStyle(style) + ' border-top-width: 1px;">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                    }
                    else {
                        file += '\n\t\t\t\t\t<td colspan=' + (1 + style.merge) + ' style="' + buildStyle(style) + '">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                    }
                }
                else {
                    if (rowIndex == 1 && !hasHeader) {
                        file += '\n\t\t\t\t\t<td style="' + buildStyle(style) + ' border-top-width: 1px;">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                    }
                    else {
                        file += '\n\t\t\t\t\t<td style="' + buildStyle(style) + '">' + this.formatData(data, format.type, format.formatString, format.localization) + '</td>';
                    }
                }
            }
        };

        this.endRow = function () {
            if (isPDF) {
                file += '\n\t</tr>';
            }
            else {
                file += '\n\t\t\t\t</tr>';
            }
        };

        this.endBody = function () {
            if (isPDF) {
                file += '\n\t</tbody>';
            }
            else {
                file += '\n\t\t\t</tbody>';
            }
        };

        this.endFile = function (filename) {
            if (isPDF || filename == undefined) {
                file += '\n</table>';
            }
            else {
                file += '\n\t\t</table>\n\t</body>\n</html>\n';
            }
        };

        this.getFile = function () {
            return file;
        };

        function buildStyle(styles) {
            var result = '';
            for (var style in styles) {
                if (styles.hasOwnProperty(style)) {
                    if (isPDF && style == 'font-size') {
                        styles[style] = '100%';
                    }
                    result += style + ':' + styles[style] + ';';
                }
            }
            return result;
        }
    }

    HtmlExporter.prototype = new $.jqx.dataAdapter.DataExportModuleBase();

    var TableExporter = function () { };
    TableExporter.prototype = new HtmlExporter();

    var PDFExporter = function () { };
    PDFExporter.prototype = new HtmlExporter();
    var exporter = new PDFExporter();

    $.jqx.dataAdapter.ArrayExporter.extend('html', new TableExporter());
    $.jqx.dataAdapter.ArrayExporter.extend('pdf', exporter);

})(jqxBaseFramework);

//Exporting to XLS format (MS Office Excel 2003)
(function ($) {

    var ExcelExporter = function () {

        var header, content, headerFields, headerStyles, existingStyles, styleCounter,
            styleBuilder = {

                style: '',

                stylesMap: {
                    'font': {
                        'color': 'Color',
                        'font-family': 'FontName',
                        'font-style': 'Italic',
                        'font-weight': 'Bold'
                    },
                    'interior': {
                        'background-color': 'Color',
                        'background': 'Color'
                    },
                    'alignment': {
                        'left': 'Left',
                        'center': 'Center',
                        'right': 'Right'
                    }
                },

                startStyle: function (styleName) {
                    this.style += '\n\t\t<Style ss:ID="' + styleName + '" ss:Name="' + styleName + '">';
                },

                buildAlignment: function (styles) {
                    if (styles['text-align']) {
                        var alignment = this.stylesMap['alignment'][styles['text-align']];
                        if (!alignment) {
                            alignment = "Left";
                        }
                        var style = '\n\t\t\t<Alignment ss:Vertical="Bottom" ss:Horizontal="' + alignment + '"/>';
                        this.style += style;
                    }
                },

                buildBorder: function (styles) {
                    if (styles['border-color']) {
                        var border = '\n\t\t\t<Borders>';
                        var bottomBorder = '\n\t\t\t\t<Border ss:Position="Bottom" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="' + styles['border-color'] + '"/>';
                        var leftBorder = '\n\t\t\t\t<Border ss:Position="Left" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="' + styles['border-color'] + '"/>';
                        var rightBorder = '\n\t\t\t\t<Border ss:Position="Right" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="' + styles['border-color'] + '"/>';
                        var topBorder = '\n\t\t\t\t<Border ss:Position="Top" ss:LineStyle="Continuous" ss:Weight="1" ss:Color="' + styles['border-color'] + '"/>';

                        border += bottomBorder;
                        border += leftBorder;
                        border += rightBorder;
                        border += topBorder;
                        border += '\n\t\t\t</Borders>';
                        this.style += border;
                    }
                },

                buildFont: function (styles) {
                    var map = this.stylesMap['font'],
                        font = '\n\t\t\t<Font ';
                    for (var prop in map) {
                        if (typeof styles[prop] !== 'undefined') {
                            if (prop === 'font-style' && styles[prop].toString().toLowerCase() === 'italic') {
                                font += 'ss:Italic="1" ';
                            } else if (prop === 'font-weight' && styles[prop].toString().toLowerCase() === 'bold') {
                                font += 'ss:Bold="1" ';
                            } else if (prop === 'color') {
                                font += 'ss:' + map[prop] + '="' + styles[prop] + '" ';
                            }
                        }
                    }
                    font += '/>';
                    this.style += font;
                },

                buildInterior: function (styles) {
                    var map = this.stylesMap['interior'],
                        interior = '\n\t\t\t<Interior ';
                    var hasInterior = false;
                    for (var prop in map) {
                        if (typeof styles[prop] !== 'undefined') {
                            interior += 'ss:' + map[prop] + '="' + styles[prop] + '" ';
                            hasInterior = true;
                        }
                    }
                    if (hasInterior)
                        interior += 'ss:Pattern="Solid"';

                    interior += '/>';
                    this.style += interior;
                },

                buildFormat: function (styles) {
                    if (styles['dataType'] == 'number' || styles['dataType'] == 'float' || styles['dataType'] == 'int' || styles['dataType'] == 'integer') {
                        var formatString = styles['formatString'];
                        if (formatString == "" || formatString.indexOf('n') != -1 || formatString.indexOf('N') != -1) {
                            this.style += '\n\t\t\t<NumberFormat ss:Format="0"/>';
                        }
                        else if (formatString == "f" || formatString == "F" || formatString == "D" || formatString.indexOf('d') != -1) {
                            this.style += '\n\t\t\t<NumberFormat ss:Format="#,##0.00_);[Red]\(#,##0.00\)"/>';
                        }
                        else if (formatString.indexOf('p') != -1 || formatString.indexOf('P') != -1) {
                            this.style += '\n\t\t\t<NumberFormat ss:Format="Percent"/>';
                        }
                        else if (formatString.indexOf('c') != -1 || formatString.indexOf('C') != -1) {
                            if (styles['currencysymbol'] && parseInt(styles['currencysymbol'].charCodeAt(0)) == 8364) {
                                this.style += '\n\t\t\t<NumberFormat ss:Format="Euro Currency"/>';
                            }
                            else {
                                this.style += '\n\t\t\t<NumberFormat ss:Format="Currency"/>';
                            }
                        }
                    }
                    else if (styles['dataType'] == 'date') {
                        this.style += '\n\t\t\t<NumberFormat ss:Format="Short Date"/>';
                    }
                },

                closeStyle: function () {
                    this.style += '\n\t\t</Style>';
                },

                toString: function () {
                    var temp = this.style;
                    this.style = '';
                    return temp;
                }
            };

        this.beginFile = function () {
            existingStyles = {};
            styleCounter = 0;
            header = '<?xml version="1.0"?>' +
                            '\n\t<?mso-application progid="Excel.Sheet"?> ' +
                            '\n\t<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" ' +
                            '\n\txmlns:o="urn:schemas-microsoft-com:office:office" ' +
                            '\n\txmlns:x="urn:schemas-microsoft-com:office:excel" ' +
                            '\n\txmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" ' +
                            '\n\txmlns:html="http://www.w3.org/TR/REC-html40"> ' +
                            '\n\t<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office"> ' +
                            '\n\t<Version>12.00</Version> ' +
                            '\n\t</DocumentProperties> ' +
                            '\n\t<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel"> ' +
                            '\n\t<WindowHeight>8130</WindowHeight> ' +
                            '\n\t<WindowWidth>15135</WindowWidth> ' +
                            '\n\t<WindowTopX>120</WindowTopX> ' +
                            '\n\t<WindowTopY>45</WindowTopY> ' +
                            '\n\t<ProtectStructure>False</ProtectStructure> ' +
                            '\n\t<ProtectWindows>False</ProtectWindows> ' +
                            '\n\t</ExcelWorkbook> ' +
                        '\n\t<Styles>';
        };

        this.beginHeader = function () {
            content = '\n\t<Worksheet ss:Name="Sheet1">\n\t\t<Table>';
            headerFields = [];
            headerStyles = [];
        };

        this.appendHeaderCell = function (data, fieldName, style) {
            var width = data.width != undefined ? data.width : data.text.length * 10;
            content += '\n\t\t\t<Column ss:Width="' + width + '"/>';
            headerFields.push(data);
            headerStyles.push(style);
        };

        this.endHeader = function (exportHeader) {
            if (exportHeader) {
                this.beginRow();
                for (var i = 0; i < headerFields.length; i += 1) {
                    if (headerStyles[i].disabled) continue;
                    appendCell.call(this, headerFields[i]['text'], null, headerStyles[i]);
                }
                this.endRow();
            }
        };

        this.beginBody = function () {
        };

        this.beginRow = function (level) {
            if (level != undefined) {
                content += '\n\t\t\t';
                for (var i = 0; i < level; i++) {
                    content += '\t';
                }
                content += '<Row>';
                return;
            }

            content += '\n\t\t\t<Row>';
        };

        this.beginRows = function (level) {
            content += '\n\t\t\t\t<Rows>';
        };

        this.appendBodyCell = function (data, dataType, style, row) {
            appendCell.call(this, data, dataType, style, row);
        };

        this.endRow = function (level) {
            if (level != undefined) {
                content += '\n\t\t\t';
                for (var i = 0; i < level; i++) {
                    content += '\t';
                }
                content += '</Row>';
                return;
            }

            content += '\n\t\t\t</Row>';
        };

        this.endRows = function (level) {
            if (level != undefined) {
                content += '\n\t\t\t';
                for (var i = 0; i < level; i++) {
                    content += '\t';
                }
                content += '</Rows>';
                return;
            }
        };

        this.endBody = function () {
            content += '\n\t\t</Table>';
        };

        this.endFile = function () {
            content += '\n\t</Worksheet>\n</Workbook>';
            header += '\n\t</Styles>';
        };

        this.getFile = function () {
            return header + content;
        };

        function appendCell(data, dataOptions, style, row) {
            var columnType = "String";

            var format = this.getFormat(dataOptions);

            if (data != null && data.toString().substring(0, 3) == "_AG") {
                data = data.toString().substring(3);
                columnType = "String";
            }
            else {
                if (format.type == 'date') {
                    var date = data;
                    data = this.formatData(data, format.type, format.formatString, format.localization);
                    if (data === null || data === "") {
                        data = "";
                        columnType = "String";
                    }
                    else {
                        data = date.toISOString();
                        columnType = "DateTime";
                    }
                }
                if (format.type == 'string') {
                    if (data === null || data === undefined) {
                        data = "";
                    }
                    else {
                        if (data.toString().indexOf('&') >= 0) {
                            data = data.toString().replace(/&/g, '&amp;');
                        }
                        if (data.toString().indexOf('>') >= 0) {
                            data = data.toString().replace(/>/g, '&gt;');
                        }
                        if (data.toString().indexOf('<') >= 0) {
                            data = data.toString().replace(/</g, '&lt;');
                        }
                        if (data.toString().indexOf('"') >= 0) {
                            data = data.toString().replace(/"/g, '&quot;');
                        }
                        if (data.toString().indexOf("'") >= 0) {
                            data = data.toString().replace(/'/g, '&apos;');
                        }
                    }
                }

                if (style.dataType == 'number' || style.dataType == 'float' || style.dataType == 'int' || style.dataType == 'integer') {
                    columnType = "Number";
                    data = parseFloat(data);
                    if (data === null || isNaN(data) || data === "") {
                        data = "";
                        columnType = "String";
                    }
                    if (data && columnType != "String" && data != "") {
                        if (dataOptions && dataOptions.formatString && dataOptions.formatString.indexOf('p') >= 0) {
                            data = data / 100;
                        }
                    }

                    style.currencysymbol = dataOptions.localization.currencysymbol;
                }
            }

            var styleId = getStyleId(style);
            if (style.merge) {
                content += '\n\t\t\t\t<Cell ss:MergeAcross="' + style.merge + '" ss:StyleID="' + styleId + '"><Data ss:Type="' + columnType + '">' + data + '</Data></Cell>';
            }
            else {
                content += '\n\t\t\t\t<Cell ss:StyleID="' + styleId + '"><Data ss:Type="' + columnType + '">' + data + '</Data></Cell>';
            }
        }

        function generateStyleId() {
            styleCounter += 1;
            return 'xls-style-' + styleCounter;
        }

        function findStyle(style) {
            for (var s in existingStyles) {
                if (isSubset(style, existingStyles[s]) && isSubset(existingStyles[s], style)) {
                    return s;
                }
            }
            return undefined;
        }

        function isSubset(first, second) {
            var subset = true;
            for (var p in first) {
                if (first[p] !== second[p]) {
                    subset = false;
                }
            }
            return subset;
        }

        function appendStyle(id, style) {
            styleBuilder.startStyle(id);
            styleBuilder.buildAlignment(style);
            styleBuilder.buildBorder(style);
            styleBuilder.buildFont(style);
            styleBuilder.buildInterior(style);
            styleBuilder.buildFormat(style);
            styleBuilder.closeStyle();
            header += styleBuilder.toString();
        }

        function getStyleId(style) {
            if (!style) {
                return '';
            }
            var id = findStyle(style);
            if (typeof id === 'undefined') {
                id = generateStyleId();
                existingStyles[id] = style;
                appendStyle(id, style);
            }
            return id;
        }
    }

    ExcelExporter.prototype = new $.jqx.dataAdapter.DataExportModuleBase();
    $.jqx.dataAdapter.ArrayExporter.extend('xls', new ExcelExporter());
})(jqxBaseFramework);

//Exporting to XML
(function ($) {

    var XmlExporter = function () {

        var file, headerFields, index;

        this.beginFile = function () {
            file = '<?xml version="1.0" encoding="UTF-8" ?>';
            file += '\n<table>';
        }

        this.beginHeader = function () {
            headerFields = [];
        }

        this.appendHeaderCell = function (data, fieldName) {
            headerFields.push(fieldName);
        }

        this.endHeader = function () {
        }

        this.beginBody = function (data, dataType) {
        }

        this.beginRow = function (level) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            if (level != undefined) {
                if (that.hierarchy) {
                    file += '\n\t';
                    for (var i = 0; i < level; i++) {
                        file += '\t\t';
                    }
                    file += '<row>';
                    index = 0;
                    return;
                }
            }

            file += '\n\t<row>';
            index = 0;
        }

        this.beginRows = function (level) {
            if (level != undefined) {
                file += '\n\t\t';
                for (var i = 0; i < level; i++) {
                    file += '\t\t';
                }
                file += '<rows>';
                index = 0;
                return;
            }
            file += '\n\t\t<rows>';
        }

        this.appendBodyCell = function (data, dataOptions, style, row, indx, group) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            var format = this.getFormat(dataOptions);
            data = this.formatData(data, format.type, format.formatString, format.localization);
            if (format.type == "string") {
                if (data.toString().indexOf('&') >= 0) {
                    data = data.toString().replace(/&/g, '&amp;');
                }
                if (data.toString().indexOf('>') >= 0) {
                    data = data.toString().replace(/>/g, '&gt;');
                }
                if (data.toString().indexOf('<') >= 0) {
                    data = data.toString().replace(/</g, '&lt;');
                }
                if (data.toString().indexOf('"') >= 0) {
                    data = data.toString().replace(/"/g, '&quot;');
                }
                if (data.toString().indexOf("'") >= 0) {
                    data = data.toString().replace(/'/g, '&apos;');
                }
            }
            if (row.level != undefined) {
                if (that.hierarchy) {
                    file += '\n\t\t';
                    for (var i = 0; i < row.level; i++) {
                        file += '\t\t';
                    }
                    if (group === undefined) {
                        file += '<' + headerFields[index] + '>' + data + '</' + headerFields[index] + '>';
                    }
                    else {
                        file += '<' + group + '>' + data + '</' + group + '>';
                    }
                }
                else {
                    if (group != undefined) {
                        file += '\n\t\t<' + group + '>' + data + '</' + group + '>';
                    }
                    else {
                        file += '\n\t\t<' + headerFields[index] + '>' + data + '</' + headerFields[index] + '>';
                    }
                }
            }
            else {
                file += '\n\t\t<' + headerFields[index] + '>' + data + '</' + headerFields[index] + '>';
            }
            index++;
        }

        this.endRow = function (level) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            if (level != undefined) {
                if (that.hierarchy) {
                    file += '\n\t';
                    for (var i = 0; i < level; i++) {
                        file += '\t\t';
                    }

                    file += '</row>';
                    index = 0;
                    return;
                }
            }
            file += '\n\t</row>';
            index = 0;
        }

        this.endRows = function (level) {
            if (level != undefined) {
                file += '\n\t\t';
                for (var i = 0; i < level; i++) {
                    file += '\t\t';
                }
                file += '</rows>';
                index = 0;
                return;
            }
            file += '\n\t\t</rows>';
        }

        this.endBody = function () {
        }

        this.endFile = function () {
            file += '\n</table>';
        }

        this.getFile = function () {
            return file;
        }
    }

    XmlExporter.prototype = new $.jqx.dataAdapter.DataExportModuleBase();
    $.jqx.dataAdapter.ArrayExporter.extend('xml', new XmlExporter());
})(jqxBaseFramework);


//Exporting to JSON
(function ($) {

    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        meta = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"': '\\"',
            '\\': '\\\\'
        };

    function quote(string) {
        return '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"';
    }

    function formatNumber(n) {
        return n < 10 ? '0' + n : n;
    }

    function stringifyDate(value) {
        var date;
        if (isFinite(value.valueOf())) {
            date = value.getUTCFullYear() + '-' + formatNumber(value.getUTCMonth() + 1) + '-' +
            formatNumber(value.getUTCDate()) + 'T' + formatNumber(value.getUTCHours()) + ':' +
            formatNumber(value.getUTCMinutes()) + ':' + formatNumber(value.getUTCSeconds()) + 'Z"';
        } else {
            date = 'null';
        }
        return date;
    }

    function stringifyArray(value) {
        var len = value.length,
            partial = [],
            i;
        for (i = 0; i < len; i++) {
            partial.push(str(i, value) || 'null');
        }

        return '[' + partial.join(',') + ']';
    }

    function stringifyObject(value) {
        var partial = [],
            i, v;
        for (i in value) {
            if (Object.prototype.hasOwnProperty.call(value, i)) {
                v = str(i, value);
                if (v) {
                    partial.push(quote(i) + ':' + v);
                }
            }
        }
        return '{' + partial.join(',') + '}';
    }

    function stringifyReference(value) {
        switch (Object.prototype.toString.call(value)) {
            case '[object Date]':
                return stringifyDate(value);
            case '[object Array]':
                return stringifyArray(value);
        }
        return stringifyObject(value);
    }

    function stringifyPrimitive(value, type) {
        switch (type) {
            case 'string':
                return quote(value);
            case 'number':
            case 'float':
            case 'integer':
            case 'int':
                return isFinite(value) ? value : 'null';
            case 'boolean':
                return value;
        }
        return 'null';
    }

    function str(key, holder) {
        var value = holder[key], type = typeof value;

        if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
            value = value.toJSON(key);
            type = typeof value;
        }
        if (/(number|float|int|integer|string|boolean)/.test(type) || (!value && type === 'object')) {
            return stringifyPrimitive(value, type);
        } else {
            return stringifyReference(value);
        }
    }

    function stringify(value) {
        if (window.JSON && typeof window.JSON.stringify === 'function') {
            return window.JSON.stringify(value);
        }

        return str("", { "": value });
    }

    var JsonExporter = function () {
        var me = this;
        this.prepareData = function (data, dataOptions) {
            if (dataOptions) {
                var format = me.getFormat(dataOptions);
                data = me.formatData(data, format.type, format.formatString, format.localization);
            }
            return data;
        }

        var file,
            content,
            currentCell,
            cellHierarchy = [],
            level = 0
        ;

        this.beginFile = function () {
            content = [];
        }

        this.beginHeader = function () {
        }

        this.appendHeaderCell = function (data) {
        }

        this.endHeader = function () {
        }

        this.beginBody = function (data, dataType) {
        }

        this.beginRow = function () {
            var that = this;

            if (!that) {
                that = window.jqx;
            }

            if (that.hierarchy || window.jqx.hierarchy) {
                cellHierarchy[level] = {};
            }
            else {
                currentCell = {};
            }
        }

        this.beginRows = function () {
            cellHierarchy[level].rows = [];
            level++;
            cellHierarchy[level] = {};
        }
        this.endRows = function () {
            level--;
        }

        this.appendBodyCell = function (data, dataType) {
            var that = this;

            if (!that) {
                that = window.jqx;
            }


            var text = this.prepareData(data, dataType);
            if (that.hierarchy || window.jqx.hierarchy) {
                cellHierarchy[level][dataType['text']] = text;
            }
            else {
                currentCell[dataType['text']] = text;
            }
        }

        this.endRow = function () {
            var that = this;

            if (!that) {
                that = window.jqx;
            }


            if (that.hierarchy || window.jqx.hierarchy) {
                if (level == 0) {
                    content.push(cellHierarchy[level]);
                }
                else {
                    cellHierarchy[level - 1].rows.push(cellHierarchy[level]);
                }
            }
            else {
                content.push(currentCell);
            }
        }

        this.endBody = function () {
        }

        this.endFile = function () {
            file = stringify(content);
        }

        this.getFile = function () {
            return file;
        }
    }

    JsonExporter.prototype = new $.jqx.dataAdapter.DataExportModuleBase();
    $.jqx.dataAdapter.ArrayExporter.extend('json', new JsonExporter());

})(jqxBaseFramework);


var pdfDataExport = window.jqxPdfDataExport = (function () {
    'use strict';
    if (typeof btoa === 'undefined') {
        window.btoa = function (data) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                b64a = b64.split(''),
                o1,
                o2,
                o3,
                h1,
                h2,
                h3,
                h4,
                bits,
                i = 0,
                ac = 0,
                enc = "",
                tmp_arr = [],
                r;

            do {
                o1 = data.charCodeAt(i++);
                o2 = data.charCodeAt(i++);
                o3 = data.charCodeAt(i++);

                bits = o1 << 16 | o2 << 8 | o3;

                h1 = bits >> 18 & 0x3f;
                h2 = bits >> 12 & 0x3f;
                h3 = bits >> 6 & 0x3f;
                h4 = bits & 0x3f;

                tmp_arr[ac++] = b64a[h1] + b64a[h2] + b64a[h3] + b64a[h4];
            } while (i < data.length);

            enc = tmp_arr.join('');
            r = data.length % 3;
            return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
        };
    }

    if (typeof atob === 'undefined') {
        window.atob = function (data) {

            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                o1,
                o2,
                o3,
                h1,
                h2,
                h3,
                h4,
                bits,
                i = 0,
                ac = 0,
                dec = "",
                tmp_arr = [];

            if (!data) {
                return data;
            }

            data += '';

            do { // unpack four hexets into three octets using index points in b64
                h1 = b64.indexOf(data.charAt(i++));
                h2 = b64.indexOf(data.charAt(i++));
                h3 = b64.indexOf(data.charAt(i++));
                h4 = b64.indexOf(data.charAt(i++));

                bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

                o1 = bits >> 16 & 0xff;
                o2 = bits >> 8 & 0xff;
                o3 = bits & 0xff;

                if (h3 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1);
                } else if (h4 === 64) {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2);
                } else {
                    tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
                }
            } while (i < data.length);
            dec = tmp_arr.join('');
            return dec;
        };
    }

    var getObjectLength = typeof Object.keys === 'function' ?
                function (object) {
                    return Object.keys(object).length;
                } :
                function (object) {
                    var i = 0, e;
                    for (e in object) {
                        if (object.hasOwnProperty(e)) {
                            i++;
                        }
                    }
                    return i;
                },

/**
PubSub implementation

@class
@name PubSub
*/
        PubSub = function (context) {
            /*
            @private
            @fieldOf PubSub
            */
            this.topics = {};
            /**
            Stores what will be `this` within the callback functions.

            @private
            @fieldOf PubSub#
            */
            this.context = context;
            /**
            Allows caller to emit an event and pass arguments to event listeners.
            @public
            @function
            @param topic {String} Name of the channel on which to voice this event
            @param args Any number of arguments you want to pass to the listeners of this event.
            @methodOf PubSub#
            @name publish
            */
            this.publish = function (topic, args) {
                if (this.topics[topic]) {
                    var currentTopic = this.topics[topic],
                        toremove = [],
                        fn,
                        i,
                        l,
                        pair,
                        emptyFunc = function () { };
                    args = Array.prototype.slice.call(arguments, 1);
                    for (i = 0, l = currentTopic.length; i < l; i++) {
                        pair = currentTopic[i]; // this is a [function, once_flag] array
                        fn = pair[0];
                        if (pair[1]) { /* 'run once' flag set */
                            pair[0] = emptyFunc;
                            toremove.push(i);
                        }
                        fn.apply(this.context, args);
                    }
                    for (i = 0, l = toremove.length; i < l; i++) {
                        currentTopic.splice(toremove[i], 1);
                    }
                }
            };
            /**
            Allows listener code to subscribe to channel and be called when data is available
            @public
            @function
            @param topic {String} Name of the channel on which to voice this event
            @param callback {Function} Executable (function pointer) that will be ran when event is voiced on this channel.
            @param once {Boolean} (optional. False by default) Flag indicating if the function is to be triggered only once.
            @returns {Object} A token object that cen be used for unsubscribing.
            @methodOf PubSub#
            @name subscribe
            */
            this.subscribe = function (topic, callback, once) {
                if (!this.topics[topic]) {
                    this.topics[topic] = [[callback, once]];
                } else {
                    this.topics[topic].push([callback, once]);
                }
                return {
                    "topic": topic,
                    "callback": callback
                };
            };
            /**
            Allows listener code to unsubscribe from a channel
            @public
            @function
            @param token {Object} A token object that was returned by `subscribe` method
            @methodOf PubSub#
            @name unsubscribe
            */
            this.unsubscribe = function (token) {
                if (this.topics[token.topic]) {
                    var currentTopic = this.topics[token.topic], i, l;

                    for (i = 0, l = currentTopic.length; i < l; i++) {
                        if (currentTopic[i][0] === token.callback) {
                            currentTopic.splice(i, 1);
                        }
                    }
                }
            };
        };


    /**
    @constructor
    @private
    */
    function pdfDataExport(orientation, unit, format, compressPdf) { /** String orientation, String unit, String format, Boolean compressed */

        // Default parameter values
        if (typeof orientation === 'undefined') {
            orientation = 'p';
        } else {
            orientation = orientation.toString().toLowerCase();
        }
        if (typeof unit === 'undefined') { unit = 'mm'; }
        if (typeof format === 'undefined') { format = 'a4'; }
        if (typeof compressPdf === 'undefined' && typeof zpipe === 'undefined') { compressPdf = false; }

        var format_as_string = format.toString().toLowerCase(),
            version = '0.9.0rc2',
            content = [],
            content_length = 0,
            compress = compressPdf,
            pdfVersion = '1.3', // PDF Version
            pageFormats = { // Size in pt of various paper formats
                'a3': [841.89, 1190.55],
                'a4': [595.28, 841.89],
                'a5': [420.94, 595.28],
                'letter': [612, 792],
                'legal': [612, 1008]
            },
            textColor = '0 g',
            drawColor = '0 G',
            page = 0,
            pages = [],
            objectNumber = 2, // 'n' Current object number
            outToPages = false, // switches where out() prints. outToPages true = push to pages obj. outToPages false = doc builder content
            offsets = [], // List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.
            fonts = {}, // collection of font objects, where key is fontKey - a dynamically created label for a given font.
            fontmap = {}, // mapping structure fontName > fontStyle > font key - performance layer. See addFont()
            activeFontSize = 16,
            activeFontKey, // will be string representing the KEY of the font as combination of fontName + fontStyle
            lineWidth = 0.200025, // 2mm
            pageHeight,
            pageWidth,
            k, // Scale factor
            documentProperties = { 'title': '', 'subject': '', 'author': '', 'keywords': '', 'creator': '' },
            lineCapID = 0,
            lineJoinID = 0,
            API = {},
            events = new PubSub(API),
            tmp,
            plugin,
            /////////////////////
            // Private functions
            /////////////////////
            // simplified (speedier) replacement for sprintf's %.2f conversion
            f2 = function (number) {
                return number.toFixed(2);
            },
            // simplified (speedier) replacement for sprintf's %.3f conversion
            f3 = function (number) {
                return number.toFixed(3);
            },
            // simplified (speedier) replacement for sprintf's %02d
            padd2 = function (number) {
                var n = (number).toFixed(0);
                if (number < 10) {
                    return '0' + n;
                } else {
                    return n;
                }
            },
            // simplified (speedier) replacement for sprintf's %02d
            padd10 = function (number) {
                var n = (number).toFixed(0);
                if (n.length < 10) {
                    return new Array(11 - n.length).join('0') + n;
                } else {
                    return n;
                }
            },
            out = function (string) {
                if (outToPages) { /* set by beginPage */
                    pages[page].push(string);
                } else {
                    content.push(string);
                    content_length += string.length + 1; // +1 is for '\n' that will be used to join contents of content
                }
            },
            newObject = function () {
                // Begin a new object
                objectNumber++;
                offsets[objectNumber] = content_length;
                out(objectNumber + ' 0 obj');
                return objectNumber;
            },
            putStream = function (str) {
                out('stream');
                out(str);
                out('endstream');
            },
            wPt,
            hPt,
            kids,
            i,
            putPages = function () {
                wPt = pageWidth * k;
                hPt = pageHeight * k;

                // outToPages = false as set in endDocument(). out() writes to content.

                var n, p, arr, uint, i, deflater, adler32;
                for (n = 1; n <= page; n++) {
                    newObject();
                    out('<</Type /Page');
                    out('/Parent 1 0 R');
                    out('/Resources 2 0 R');
                    out('/Contents ' + (objectNumber + 1) + ' 0 R>>');
                    out('endobj');

                    // Page content
                    p = pages[n].join('\n');
                    newObject();
                    if (compress) {
                        arr = [];
                        for (i = 0; i < p.length; ++i) {
                            arr[i] = p.charCodeAt(i);
                        }
                        adler32 = adler32cs.from(p);
                        deflater = new Deflater(6);
                        deflater.append(new Uint8Array(arr));
                        p = deflater.flush();
                        arr = [new Uint8Array([120, 156]), new Uint8Array(p),
                               new Uint8Array([adler32 & 0xFF, (adler32 >> 8) & 0xFF, (adler32 >> 16) & 0xFF, (adler32 >> 24) & 0xFF])];
                        p = '';
                        for (i in arr) {
                            if (arr.hasOwnProperty(i)) {
                                p += String.fromCharCode.apply(null, arr[i]);
                            }
                        }
                        out('<</Length ' + p.length + ' /Filter [/FlateDecode]>>');
                    } else {
                        out('<</Length ' + p.length + '>>');
                    }
                    putStream(p);
                    out('endobj');
                }
                offsets[1] = content_length;
                out('1 0 obj');
                out('<</Type /Pages');
                kids = '/Kids [';
                for (i = 0; i < page; i++) {
                    kids += (3 + 2 * i) + ' 0 R ';
                }
                out(kids + ']');
                out('/Count ' + page);
                out('/MediaBox [0 0 ' + f2(wPt) + ' ' + f2(hPt) + ']');
                out('>>');
                out('endobj');
            },
            putFont = function (font) {
                font.objectNumber = newObject();
                out('<</BaseFont/' + font.PostScriptName + '/Type/Font');
                if (typeof font.encoding === 'string') {
                    out('/Encoding/' + font.encoding);
                }
                out('/Subtype/Type1>>');
                out('endobj');
            },
            putFonts = function () {
                var fontKey;
                for (fontKey in fonts) {
                    if (fonts.hasOwnProperty(fontKey)) {
                        putFont(fonts[fontKey]);
                    }
                }
            },
            putXobjectDict = function () {
                // Loop through images, or other data objects
                events.publish('putXobjectDict');
            },
            putResourceDictionary = function () {
                out('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');
                out('/Font <<');
                // Do this for each font, the '1' bit is the index of the font
                var fontKey;
                for (fontKey in fonts) {
                    if (fonts.hasOwnProperty(fontKey)) {
                        out('/' + fontKey + ' ' + fonts[fontKey].objectNumber + ' 0 R');
                    }
                }
                out('>>');
                out('/XObject <<');
                putXobjectDict();
                out('>>');
            },
            putResources = function () {
                putFonts();
                events.publish('putResources');
                // Resource dictionary
                offsets[2] = content_length;
                out('2 0 obj');
                out('<<');
                putResourceDictionary();
                out('>>');
                out('endobj');
                events.publish('postPutResources');
            },
            addToFontDictionary = function (fontKey, fontName, fontStyle) {
                // this is mapping structure for quick font key lookup.
                // returns the KEY of the font (ex: "F1") for a given pair of font name and type (ex: "Arial". "Italic")
                var undef;
                if (fontmap[fontName] === undef) {
                    fontmap[fontName] = {}; // fontStyle is a var interpreted and converted to appropriate string. don't wrap in quotes.
                }
                fontmap[fontName][fontStyle] = fontKey;
            },
            /**
            FontObject describes a particular font as member of an instnace of pdfDataExport

            It's a collection of properties like 'id' (to be used in PDF stream),
            'fontName' (font's family name), 'fontStyle' (font's style variant label)

            @class
            @public
            @property id {String} PDF-document-instance-specific label assinged to the font.
            @property PostScriptName {String} PDF specification full name for the font
            @property encoding {Object} Encoding_name-to-Font_metrics_object mapping.
            @name FontObject
            */
            FontObject = {},
            addFont = function (PostScriptName, fontName, fontStyle, encoding) {
                var fontKey = 'F' + (getObjectLength(fonts) + 1).toString(10),
                    // This is FontObject
                    font = fonts[fontKey] = {
                        'id': fontKey,
                        // , 'objectNumber':   will be set by putFont()
                        'PostScriptName': PostScriptName,
                        'fontName': fontName,
                        'fontStyle': fontStyle,
                        'encoding': encoding,
                        'metadata': {}
                    };

                addToFontDictionary(fontKey, fontName, fontStyle);

                events.publish('addFont', font);

                return fontKey;
            },
            addFonts = function () {

                var HELVETICA = "helvetica",
                    TIMES = "times",
                    COURIER = "courier",
                    NORMAL = "normal",
                    BOLD = "bold",
                    ITALIC = "italic",
                    BOLD_ITALIC = "bolditalic",
                    encoding = 'StandardEncoding',
                    standardFonts = [
                        ['Helvetica', HELVETICA, NORMAL],
                        ['Helvetica-Bold', HELVETICA, BOLD],
                        ['Helvetica-Oblique', HELVETICA, ITALIC],
                        ['Helvetica-BoldOblique', HELVETICA, BOLD_ITALIC],
                        ['Courier', COURIER, NORMAL],
                        ['Courier-Bold', COURIER, BOLD],
                        ['Courier-Oblique', COURIER, ITALIC],
                        ['Courier-BoldOblique', COURIER, BOLD_ITALIC],
                        ['Times-Roman', TIMES, NORMAL],
                        ['Times-Bold', TIMES, BOLD],
                        ['Times-Italic', TIMES, ITALIC],
                        ['Times-BoldItalic', TIMES, BOLD_ITALIC]
                    ],
                    i,
                    l,
                    fontKey,
                    parts;
                for (i = 0, l = standardFonts.length; i < l; i++) {
                    var en = encoding;

                    fontKey = addFont(
                        standardFonts[i][0],
                        standardFonts[i][1],
                        standardFonts[i][2],
                        en
                    );

                    // adding aliases for standard fonts, this time matching the capitalization
                    parts = standardFonts[i][0].split('-');
                    addToFontDictionary(fontKey, parts[0], parts[1] || '');
                }

                events.publish('addFonts', { 'fonts': fonts, 'dictionary': fontmap });
            },
            /**

            @public
            @function
            @param text {String}
            @param flags {Object} Encoding flags.
            @returns {String} Encoded string
            */
            to8bitStream = function (text, flags) {

                var i, l, undef, sourceEncoding, encodingBlock, outputEncoding, newtext, isUnicode, ch, bch;

                if (flags === undef) {
                    flags = {};
                }

                sourceEncoding = flags.sourceEncoding ? sourceEncoding : 'Unicode';

                outputEncoding = flags.outputEncoding;

                // This 'encoding' section relies on font metrics format
                // attached to font objects by, among others,
                // "Willow Systems' standard_font_metrics plugin"
                // see pdfDataExport.plugin.standard_font_metrics.js for format
                // of the font.metadata.encoding Object.
                // It should be something like
                //   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}
                //   .widths = {0:width, code:width, ..., 'fof':divisor}
                //   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}
                if ((flags.autoencode || outputEncoding) &&
                        fonts[activeFontKey].metadata &&
                        fonts[activeFontKey].metadata[sourceEncoding] &&
                        fonts[activeFontKey].metadata[sourceEncoding].encoding
                        ) {
                    encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;

                    // each font has default encoding. Some have it clearly defined.
                    if (!outputEncoding && fonts[activeFontKey].encoding) {
                        outputEncoding = fonts[activeFontKey].encoding;
                    }

                    // Hmmm, the above did not work? var's try again, in different place.
                    if (!outputEncoding && encodingBlock.codePages) {
                        outputEncoding = encodingBlock.codePages[0]; // var's say, first one is the default
                    }

                    if (typeof outputEncoding === 'string') {
                        outputEncoding = encodingBlock[outputEncoding];
                    }
                    // we want output encoding to be a JS Object, where
                    // key = sourceEncoding's character code and
                    // value = outputEncoding's character code.
                    if (outputEncoding) {
                        isUnicode = false;
                        newtext = [];
                        for (i = 0, l = text.length; i < l; i++) {
                            ch = outputEncoding[text.charCodeAt(i)];
                            if (ch) {
                                newtext.push(
                                    String.fromCharCode(ch)
                                );
                            } else {
                                newtext.push(
                                    text[i]
                                );
                            }

                            // since we are looping over chars anyway, might as well
                            // check for residual unicodeness
                            if (newtext[i].charCodeAt(0) >> 8) { /* more than 255 */
                                isUnicode = true;
                            }
                        }
                        text = newtext.join('');
                    }
                }

                i = text.length;
                // isUnicode may be set to false above. Hence the triple-equal to undefined
                while (isUnicode === undef && i !== 0) {
                    if (text.charCodeAt(i - 1) >> 8) { /* more than 255 */
                        isUnicode = true;
                    }
                    i--;
                }
                if (!isUnicode) {
                    return text;
                } else {
                    newtext = flags.noBOM ? [] : [254, 255];
                    for (i = 0, l = text.length; i < l; i++) {
                        ch = text.charCodeAt(i);
                        bch = ch >> 8; // divide by 256
                        if (bch >> 8) { /* something left after dividing by 256 second time */
                            throw new Error("Character at position " + i.toString(10) + " of string '" + text + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
                        }
                        newtext.push(bch);
                        newtext.push(ch - (bch << 8));
                    }
                    return String.fromCharCode.apply(undef, newtext);
                }
            },
            // Replace '/', '(', and ')' with pdf-safe versions
            pdfEscape = function (text, flags) {
                // doing to8bitStream does NOT make this PDF display unicode text. For that
                // we also need to reference a unicode font and embed it - royal pain in the rear.

                // There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,
                // which JavaScript Strings are happy to provide. So, while we still cannot display
                // 2-byte characters property, at least CONDITIONALLY converting (entire string containing)
                // 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF
                // is still parseable.
                // This will allow immediate support for unicode in document properties strings.
                return to8bitStream(text, flags).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
            },
            putInfo = function () {
                out('/Producer (pdfDataExport ' + version + ')');
                if (documentProperties.title) {
                    out('/Title (' + pdfEscape(documentProperties.title) + ')');
                }
                if (documentProperties.subject) {
                    out('/Subject (' + pdfEscape(documentProperties.subject) + ')');
                }
                if (documentProperties.author) {
                    out('/Author (' + pdfEscape(documentProperties.author) + ')');
                }
                if (documentProperties.keywords) {
                    out('/Keywords (' + pdfEscape(documentProperties.keywords) + ')');
                }
                if (documentProperties.creator) {
                    out('/Creator (' + pdfEscape(documentProperties.creator) + ')');
                }
                var created = new Date();
                out('/CreationDate (D:' +
                    [
                        created.getFullYear(),
                        padd2(created.getMonth() + 1),
                        padd2(created.getDate()),
                        padd2(created.getHours()),
                        padd2(created.getMinutes()),
                        padd2(created.getSeconds())
                    ].join('') +
                    ')'
                    );
            },
            putCatalog = function () {
                out('/Type /Catalog');
                out('/Pages 1 0 R');
                // @TODO: Add zoom and layout modes
                out('/OpenAction [3 0 R /FitH null]');
                out('/PageLayout /OneColumn');
                events.publish('putCatalog');
            },
            putTrailer = function () {
                out('/Size ' + (objectNumber + 1));
                out('/Root ' + objectNumber + ' 0 R');
                out('/Info ' + (objectNumber - 1) + ' 0 R');
            },
            beginPage = function () {
                page++;
                // Do dimension stuff
                outToPages = true;
                pages[page] = [];
            },
            _addPage = function () {
                beginPage();
                // Set line width
                out(f2(lineWidth * k) + ' w');
                // Set draw color
                out(drawColor);
                // resurrecting non-default line caps, joins
                if (lineCapID !== 0) {
                    out(lineCapID.toString(10) + ' J');
                }
                if (lineJoinID !== 0) {
                    out(lineJoinID.toString(10) + ' j');
                }
                events.publish('addPage', { 'pageNumber': page });
            },
            /**
            Returns a document-specific font key - a label assigned to a
            font name + font type combination at the time the font was added
            to the font inventory.

            Font key is used as label for the desired font for a block of text
            to be added to the PDF document stream.
            @private
            @function
            @param fontName {String} can be undefined on "falthy" to indicate "use current"
            @param fontStyle {String} can be undefined on "falthy" to indicate "use current"
            @returns {String} Font key.
            */
            getFont = function (fontName, fontStyle) {
                var key, undef;

                if (fontName === undef) {
                    fontName = fonts[activeFontKey].fontName;
                }
                if (fontStyle === undef) {
                    fontStyle = fonts[activeFontKey].fontStyle;
                }

                try {
                    key = fontmap[fontName][fontStyle]; // returns a string like 'F3' - the KEY corresponding tot he font + type combination.
                } catch (e) {
                    key = undef;
                }
                if (!key) {
                    throw new Error("Unable to look up font label for font '" + fontName + "', '" + fontStyle + "'. Refer to getFontList() for available fonts.");
                }

                return key;
            },
            buildDocument = function () {

                outToPages = false; // switches out() to content
                content = [];
                offsets = [];

                // putHeader()
                out('%PDF-' + pdfVersion);

                putPages();

                putResources();

                // Info
                newObject();
                out('<<');
                putInfo();
                out('>>');
                out('endobj');

                // Catalog
                newObject();
                out('<<');
                putCatalog();
                out('>>');
                out('endobj');

                // Cross-ref
                var o = content_length, i;
                out('xref');
                out('0 ' + (objectNumber + 1));
                out('0000000000 65535 f ');
                for (i = 1; i <= objectNumber; i++) {
                    out(padd10(offsets[i]) + ' 00000 n ');
                }
                // Trailer
                out('trailer');
                out('<<');
                putTrailer();
                out('>>');
                out('startxref');
                out(o);
                out('%%EOF');

                outToPages = true;

                return content.join('\n');
            },
            getStyle = function (style) {
                // see Path-Painting Operators of PDF spec
                var op = 'S'; // stroke
                if (style === 'F') {
                    op = 'f'; // fill
                } else if (style === 'FD' || style === 'DF') {
                    op = 'B'; // both
                }
                return op;
            },

            /**
            Generates the PDF document.
            Possible values:
                datauristring (alias dataurlstring) - Data-Url-formatted data returned as string.
                datauri (alias datauri) - Data-Url-formatted data pushed into current window's location (effectively reloading the window with contents of the PDF).

            If `type` argument is undefined, output is raw body of resulting PDF returned as a string.

            @param {String} type A string identifying one of the possible output types.
            @param {Object} options An object providing some additional signalling to PDF generator.
            @function
            @returns {pdfDataExport}
            @methodOf pdfDataExport#
            @name output
            */
            output = function (type, options) {
                var undef, data, length, array, i, blob;
                switch (type) {
                    case undef:
                        return buildDocument();
                    case 'save':
                        if (navigator.getUserMedia) {
                            if (window.URL === undefined) {
                                return API.output('dataurlnewwindow');
                            } else if (window.URL.createObjectURL === undefined) {
                                return API.output('dataurlnewwindow');
                            }
                        }
                        data = buildDocument();

                        // Need to add the file to BlobBuilder as a Uint8Array
                        length = data.length;
                        array = new Uint8Array(new ArrayBuffer(length));

                        for (i = 0; i < length; i++) {
                            array[i] = data.charCodeAt(i);
                        }

                        blob = new Blob([array], { type: "application/pdf" });

                        saveAs(blob, options);
                        break;
                    case 'datauristring':
                    case 'dataurlstring':
                        return 'data:application/pdf;base64,' + btoa(buildDocument());
                    case 'datauri':
                    case 'dataurl':
                        document.location.href = 'data:application/pdf;base64,' + btoa(buildDocument());
                        break;
                    case 'dataurlnewwindow':
                        window.open('data:application/pdf;base64,' + btoa(buildDocument()));
                        break;
                    default:
                        throw new Error('Output type "' + type + '" is not supported.');
                }
                // @TODO: Add different output options
            };

        if (unit === 'pt') {
            k = 1;
        } else if (unit === 'mm') {
            k = 72 / 25.4;
        } else if (unit === 'cm') {
            k = 72 / 2.54;
        } else if (unit === 'in') {
            k = 72;
        } else {
            throw ('Invalid unit: ' + unit);
        }

        // Dimensions are stored as user units and converted to points on output
        if (pageFormats.hasOwnProperty(format_as_string)) {
            pageHeight = pageFormats[format_as_string][1] / k;
            pageWidth = pageFormats[format_as_string][0] / k;
        } else {
            try {
                pageHeight = format[1];
                pageWidth = format[0];
            } catch (err) {
                throw ('Invalid format: ' + format);
            }
        }

        if (orientation === 'p' || orientation === 'portrait') {
            orientation = 'p';
            if (pageWidth > pageHeight) {
                tmp = pageWidth;
                pageWidth = pageHeight;
                pageHeight = tmp;
            }
        } else if (orientation === 'l' || orientation === 'landscape') {
            orientation = 'l';
            if (pageHeight > pageWidth) {
                tmp = pageWidth;
                pageWidth = pageHeight;
                pageHeight = tmp;
            }
        } else {
            throw ('Invalid orientation: ' + orientation);
        }



        //---------------------------------------
        // Public API

        /*
        Object exposing internal API to plugins
        @public
        */
        API.internal = {
            'pdfEscape': pdfEscape,
            'getStyle': getStyle,
            /**
            Returns {FontObject} describing a particular font.
            @public
            @function
            @param fontName {String} (Optional) Font's family name
            @param fontStyle {String} (Optional) Font's style variation name (Example:"Italic")
            @returns {FontObject}
            */
            'getFont': function () { return fonts[getFont.apply(API, arguments)]; },
            'getFontSize': function () { return activeFontSize; },
            'btoa': btoa,
            'write': function (string1, string2, string3, etc) {
                out(
                    arguments.length === 1 ? string1 : Array.prototype.join.call(arguments, ' ')
                );
            },
            'getCoordinateString': function (value) {
                return f2(value * k);
            },
            'getVerticalCoordinateString': function (value) {
                return f2((pageHeight - value) * k);
            },
            'collections': {},
            'newObject': newObject,
            'putStream': putStream,
            'events': events,
            // ratio that you use in multiplication of a given "size" number to arrive to 'point'
            // units of measurement.
            // scaleFactor is set at initialization of the document and calculated against the stated
            // default measurement units for the document.
            // If default is "mm", k is the number that will turn number in 'mm' into 'points' number.
            // through multiplication.
            'scaleFactor': k,
            'pageSize': { 'width': pageWidth, 'height': pageHeight },
            'output': function (type, options) {
                return output(type, options);
            }
        };

        /**
        Adds (and transfers the focus to) new page to the PDF document.
        @function
        @returns {pdfDataExport}

        @methodOf pdfDataExport#
        @name addPage
         */
        API.addPage = function () {
            _addPage();
            return this;
        };

        var padz =
[
   "",
   "0",
   "00",
   "000",
   "0000"
];
        var pdfEscape16 = function (text, flags) {
            var ar = ["FEFF"];
            for (var i = 0, l = text.length, t; i < l; ++i) {
                t = text.charCodeAt(i).toString(16).toUpperCase();
                ar.push(padz[4 - t.length], t);
            }
            return ar.join("");
        };

        API.text16 = function (text, x, y, flags) {
            /**
            * Inserts something like this into PDF
            BT
            /F1 16 Tf % Font name + size
            16 TL % How many units down for next line in multiline text
            0 g % color
            28.35 813.54 Td % position
            (line one) Tj
            T* (line two) Tj
            T* (line three) Tj
            ET
            */

            var undef, _first, _second, _third, newtext, str, i;
            // Pre-August-2012 the order of arguments was function(x, y, text, flags)
            // in effort to make all calls have similar signature like
            // function(data, coordinates... , miscellaneous)
            // this method had its args flipped.
            // code below allows backward compatibility with old arg order.
            if (typeof text === 'number') {
                _first = y;
                _second = text;
                _third = x;

                text = _first;
                x = _second;
                y = _third;
            }

            // If there are any newlines in text, we assume
            // the user wanted to print multiple lines, so break the
            // text up into an array. If the text is already an array,
            // we assume the user knows what they are doing.
            if (typeof text === 'string' && text.match(/[\n\r]/)) {
                text = text.split(/\r\n|\r|\n/g);
            }

            if (typeof flags === 'undefined') {
                flags = { 'noBOM': true, 'autoencode': true };
            } else {

                if (flags.noBOM === undef) {
                    flags.noBOM = true;
                }

                if (flags.autoencode === undef) {
                    flags.autoencode = true;
                }

            }
            flags.autoencode = false;
            if (typeof text === 'string') {
                str = pdfEscape16(text, flags);
            } else if (text instanceof Array) { /* Array */
                // we don't want to destroy original text array, so cloning it
                newtext = text.concat();
                // we do array.join('text that must not be PDFescaped")
                // thus, pdfEscape each component separately
                for (i = newtext.length - 1; i !== -1; i--) {
                    newtext[i] = pdfEscape16(newtext[i], flags);
                }
                str = newtext.join("> Tj\nT* <");
            } else {
                throw new Error('Type of text must be string or Array. "' + text + '" is not recognized.');
            }
            // Using "'" ("go next line and render text" mark) would save space but would complicate our rendering code, templates

            // BT .. ET does NOT have default settings for Tf. You must state that explicitely every time for BT .. ET
            // if you want text transformation matrix (+ multiline) to work reliably (which reads sizes of things from font declarations)
            // Thus, there is NO useful, *reliable* concept of "default" font for a page.
            // The fact that "default" (reuse font used before) font worked before in basic cases is an accident
            // - readers dealing smartly with brokenness of jsPDF's markup.
            out(
                'BT\n/' +
                    activeFontKey + ' ' + activeFontSize + ' Tf\n' + // font face, style, size
                      activeFontSize + ' TL\n' + // line spacing
                     textColor +
                    '\n' + f2(x * k) + ' ' + f2((pageHeight - y) * k) + ' Td\n<' +
                    str +
                    '> Tj\nET'
            );

            return this;
        };
        /**
        Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.
        @function
        @param {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.
        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Object} flags Collection of settings signalling how the text must be encoded. Defaults are sane. If you think you want to pass some flags, you likely can read the source.
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name text
         */
        API.text = function (text, x, y, flags) {
            /**
             * Inserts something like this into PDF
                BT
                /F1 16 Tf  % Font name + size
                16 TL % How many units down for next line in multiline text
                0 g % color
                28.35 813.54 Td % position
                (line one) Tj
                T* (line two) Tj
                T* (line three) Tj
                ET
            */

            var undef, _first, _second, _third, newtext, str, i;
            if (typeof text === 'number') {
                _first = y;
                _second = text;
                _third = x;

                text = _first;
                x = _second;
                y = _third;
            }

            if (typeof text === 'string' && text.match(/[\n\r]/)) {
                text = text.split(/\r\n|\r|\n/g);
            }

            if (typeof flags === 'undefined') {
                flags = { 'noBOM': true, 'autoencode': true };
            } else {

                if (flags.noBOM === undef) {
                    flags.noBOM = true;
                }

                if (flags.autoencode === undef) {
                    flags.autoencode = true;
                }

            }

            if (typeof text === 'string') {
                str = pdfEscape(text, flags);
            } else if (text instanceof Array) {  /* Array */
                // we don't want to destroy  original text array, so cloning it
                newtext = text.concat();
                // we do array.join('text that must not be PDFescaped")
                // thus, pdfEscape each component separately
                for (i = newtext.length - 1; i !== -1; i--) {
                    newtext[i] = pdfEscape(newtext[i], flags);
                }
                str = newtext.join(") Tj\nT* (");
            } else {
                throw new Error('Type of text must be string or Array. "' + text + '" is not recognized.');
            }
            out(
             'BT\n/' +
                 activeFontKey + ' ' + activeFontSize + ' Tf\n' + // font face, style, size
                 activeFontSize + ' TL\n' + // line spacing
                 textColor +
                 '\n' + f2(x * k) + ' ' + f2((pageHeight - y) * k) + ' Td\n(' +
                 str +
                 ') Tj\nET'
         );
            return this;
        };

        API.line = function (x1, y1, x2, y2) {
            out(
                f2(x1 * k) + ' ' + f2((pageHeight - y1) * k) + ' m ' +
                    f2(x2 * k) + ' ' + f2((pageHeight - y2) * k) + ' l S'
            );
            return this;
        };

        /**
        Adds series of curves (straight lines or cubic bezier curves) to canvas, starting at `x`, `y` coordinates.
        All data points in `lines` are relative to last line origin.
        `x`, `y` become x1,y1 for first line / curve in the set.
        For lines you only need to specify [x2, y2] - (ending point) vector against x1, y1 starting point.
        For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.

        @example .lines([[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 212,110, 10) // line, line, bezier curve, line
        @param {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).
        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name lines
         */
        API.lines = function (lines, x, y, scale, style) {
            var undef, _first, _second, _third, scalex, scaley, i, l, leg, x2, y2, x3, y3, x4, y4;

            // Pre-August-2012 the order of arguments was function(x, y, lines, scale, style)
            // in effort to make all calls have similar signature like
            //   function(content, coordinateX, coordinateY , miscellaneous)
            // this method had its args flipped.
            // code below allows backward compatibility with old arg order.
            if (typeof lines === 'number') {
                _first = y;
                _second = lines;
                _third = x;

                lines = _first;
                x = _second;
                y = _third;
            }

            style = getStyle(style);
            scale = scale === undef ? [1, 1] : scale;

            // starting point
            out(f3(x * k) + ' ' + f3((pageHeight - y) * k) + ' m ');

            scalex = scale[0];
            scaley = scale[1];
            l = lines.length;
            //, x2, y2 // bezier only. In page default measurement "units", *after* scaling
            //, x3, y3 // bezier only. In page default measurement "units", *after* scaling
            // ending point for all, lines and bezier. . In page default measurement "units", *after* scaling
            x4 = x; // last / ending point = starting point for first item.
            y4 = y; // last / ending point = starting point for first item.

            for (i = 0; i < l; i++) {
                leg = lines[i];
                if (leg.length === 2) {
                    // simple line
                    x4 = leg[0] * scalex + x4; // here last x4 was prior ending point
                    y4 = leg[1] * scaley + y4; // here last y4 was prior ending point
                    out(f3(x4 * k) + ' ' + f3((pageHeight - y4) * k) + ' l');
                } else {
                    // bezier curve
                    x2 = leg[0] * scalex + x4; // here last x4 is prior ending point
                    y2 = leg[1] * scaley + y4; // here last y4 is prior ending point
                    x3 = leg[2] * scalex + x4; // here last x4 is prior ending point
                    y3 = leg[3] * scaley + y4; // here last y4 is prior ending point
                    x4 = leg[4] * scalex + x4; // here last x4 was prior ending point
                    y4 = leg[5] * scaley + y4; // here last y4 was prior ending point
                    out(
                        f3(x2 * k) + ' ' +
                            f3((pageHeight - y2) * k) + ' ' +
                            f3(x3 * k) + ' ' +
                            f3((pageHeight - y3) * k) + ' ' +
                            f3(x4 * k) + ' ' +
                            f3((pageHeight - y4) * k) + ' c'
                    );
                }
            }
            // stroking / filling / both the path
            out(style);
            return this;
        };

        /**
        Adds a rectangle to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} w Width (in units declared at inception of PDF document)
        @param {Number} h Height (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name rect
         */
        API.rect = function (x, y, w, h, style) {
            var op = getStyle(style);
            out([
                f2(x * k),
                f2((pageHeight - y) * k),
                f2(w * k),
                f2(-h * k),
                're',
                op
            ].join(' '));
            return this;
        };

        /**
        Adds a triangle to PDF

        @param {Number} x1 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y1 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} x2 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y2 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} x3 Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y3 Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name triangle
         */
        API.triangle = function (x1, y1, x2, y2, x3, y3, style) {
            this.lines(
                [
                    [x2 - x1, y2 - y1], // vector to point 2
                    [x3 - x2, y3 - y2], // vector to point 3
                    [x1 - x3, y1 - y3] // closing vector back to point 1
                ],
                x1,
                y1, // start of path
                [1, 1],
                style
            );
            return this;
        };

        /**
        Adds a rectangle with rounded corners to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} w Width (in units declared at inception of PDF document)
        @param {Number} h Height (in units declared at inception of PDF document)
        @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
        @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name roundedRect
        */
        API.roundedRect = function (x, y, w, h, rx, ry, style) {
            var MyArc = 4 / 3 * (Math.SQRT2 - 1);
            this.lines(
                [
                    [(w - 2 * rx), 0],
                    [(rx * MyArc), 0, rx, ry - (ry * MyArc), rx, ry],
                    [0, (h - 2 * ry)],
                    [0, (ry * MyArc), -(rx * MyArc), ry, -rx, ry],
                    [(-w + 2 * rx), 0],
                    [-(rx * MyArc), 0, -rx, -(ry * MyArc), -rx, -ry],
                    [0, (-h + 2 * ry)],
                    [0, -(ry * MyArc), (rx * MyArc), -ry, rx, -ry]
                ],
                x + rx,
                y, // start of path
                [1, 1],
                style
            );
            return this;
        };

        /**
        Adds an ellipse to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
        @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name ellipse
         */
        API.ellipse = function (x, y, rx, ry, style) {
            var op = getStyle(style),
                lx = 4 / 3 * (Math.SQRT2 - 1) * rx,
                ly = 4 / 3 * (Math.SQRT2 - 1) * ry;

            out([
                f2((x + rx) * k),
                f2((pageHeight - y) * k),
                'm',
                f2((x + rx) * k),
                f2((pageHeight - (y - ly)) * k),
                f2((x + lx) * k),
                f2((pageHeight - (y - ry)) * k),
                f2(x * k),
                f2((pageHeight - (y - ry)) * k),
                'c'
            ].join(' '));
            out([
                f2((x - lx) * k),
                f2((pageHeight - (y - ry)) * k),
                f2((x - rx) * k),
                f2((pageHeight - (y - ly)) * k),
                f2((x - rx) * k),
                f2((pageHeight - y) * k),
                'c'
            ].join(' '));
            out([
                f2((x - rx) * k),
                f2((pageHeight - (y + ly)) * k),
                f2((x - lx) * k),
                f2((pageHeight - (y + ry)) * k),
                f2(x * k),
                f2((pageHeight - (y + ry)) * k),
                'c'
            ].join(' '));
            out([
                f2((x + lx) * k),
                f2((pageHeight - (y + ry)) * k),
                f2((x + rx) * k),
                f2((pageHeight - (y + ly)) * k),
                f2((x + rx) * k),
                f2((pageHeight - y) * k),
                'c',
                op
            ].join(' '));
            return this;
        };

        /**
        Adds an circle to PDF

        @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
        @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
        @param {Number} r Radius (in units declared at inception of PDF document)
        @param {String} style (Defaults to active fill/stroke style) A string signalling if stroke, fill or both are to be applied.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name circle
         */
        API.circle = function (x, y, r, style) {
            return this.ellipse(x, y, r, r, style);
        };

        /**
        Adds a properties to the PDF document

        @param {Object} A property_name-to-property_value object structure.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setProperties
         */
        API.setProperties = function (properties) {
            // copying only those properties we can render.
            var property;
            for (property in documentProperties) {
                if (documentProperties.hasOwnProperty(property) && properties[property]) {
                    documentProperties[property] = properties[property];
                }
            }
            return this;
        };

        /**
        Sets font size for upcoming text elements.

        @param {Number} size Font size in points.
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setFontSize
         */
        API.setFontSize = function (size) {
            activeFontSize = size;
            return this;
        };

        /**
        Sets text font face, variant for upcoming text elements.
        See output of pdfDataExport.getFontList() for possible font names, styles.

        @param {String} fontName Font name or family. Example: "times"
        @param {String} fontStyle Font style or variant. Example: "italic"
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setFont
         */
        API.setFont = function (fontName, fontStyle) {
            activeFontKey = getFont(fontName, fontStyle);
            // if font is not found, the above line blows up and we never go further
            return this;
        };

        /**
        Switches font style or variant for upcoming text elements,
        while keeping the font face or family same.
        See output of pdfDataExport.getFontList() for possible font names, styles.

        @param {String} style Font style or variant. Example: "italic"
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setFontStyle
         */
        API.setFontStyle = API.setFontType = function (style) {
            var undef;
            activeFontKey = getFont(undef, style);
            // if font is not found, the above line blows up and we never go further
            return this;
        };

        /**
        Returns an object - a tree of fontName to fontStyle relationships available to
        active PDF document.

        @public
        @function
        @returns {Object} Like {'times':['normal', 'italic', ... ], 'arial':['normal', 'bold', ... ], ... }
        @methodOf pdfDataExport#
        @name getFontList
        */
        API.getFontList = function () {
            // TODO: iterate over fonts array or return copy of fontmap instead in case more are ever added.
            var list = {},
                fontName,
                fontStyle,
                tmp;

            for (fontName in fontmap) {
                if (fontmap.hasOwnProperty(fontName)) {
                    list[fontName] = tmp = [];
                    for (fontStyle in fontmap[fontName]) {
                        if (fontmap[fontName].hasOwnProperty(fontStyle)) {
                            tmp.push(fontStyle);
                        }
                    }
                }
            }

            return list;
        };

        /**
        Sets line width for upcoming lines.

        @param {Number} width Line width (in units declared at inception of PDF document)
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setLineWidth
         */
        API.setLineWidth = function (width) {
            out((width * k).toFixed(2) + ' w');
            return this;
        };

        /**
        Sets the stroke color for upcoming elements.

        Depending on the number of arguments given, Gray, RGB, or CMYK
        color space is implied.

        When only ch1 is given, "Gray" color space is implied and it
        must be a value in the range from 0.00 (solid black) to to 1.00 (white)
        if values are communicated as String types, or in range from 0 (black)
        to 255 (white) if communicated as Number type.
        The RGB-like 0-255 range is provided for backward compatibility.

        When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
        value must be in the range from 0.00 (minimum intensity) to to 1.00
        (max intensity) if values are communicated as String types, or
        from 0 (min intensity) to to 255 (max intensity) if values are communicated
        as Number types.
        The RGB-like 0-255 range is provided for backward compatibility.

        When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
        value must be a in the range from 0.00 (0% concentration) to to
        1.00 (100% concentration)

        Because JavaScript treats fixed point numbers badly (rounds to
        floating point nearest to binary representation) it is highly advised to
        communicate the fractional numbers as String types, not JavaScript Number type.

        @param {Number|String} ch1 Color channel value
        @param {Number|String} ch2 Color channel value
        @param {Number|String} ch3 Color channel value
        @param {Number|String} ch4 Color channel value

        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setDrawColor
         */
        API.setDrawColor = function (ch1, ch2, ch3, ch4) {
            var color;
            if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
                // Gray color space.
                if (typeof ch1 === 'string') {
                    color = ch1 + ' G';
                } else {
                    color = f2(ch1 / 255) + ' G';
                }
            } else if (ch4 === undefined) {
                // RGB
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, 'RG'].join(' ');
                } else {
                    color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'RG'].join(' ');
                }
            } else {
                // CMYK
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, ch4, 'K'].join(' ');
                } else {
                    color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'K'].join(' ');
                }
            }

            out(color);
            return this;
        };

        /**
        Sets the fill color for upcoming elements.

        Depending on the number of arguments given, Gray, RGB, or CMYK
        color space is implied.

        When only ch1 is given, "Gray" color space is implied and it
        must be a value in the range from 0.00 (solid black) to to 1.00 (white)
        if values are communicated as String types, or in range from 0 (black)
        to 255 (white) if communicated as Number type.
        The RGB-like 0-255 range is provided for backward compatibility.

        When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
        value must be in the range from 0.00 (minimum intensity) to to 1.00
        (max intensity) if values are communicated as String types, or
        from 0 (min intensity) to to 255 (max intensity) if values are communicated
        as Number types.
        The RGB-like 0-255 range is provided for backward compatibility.

        When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
        value must be a in the range from 0.00 (0% concentration) to to
        1.00 (100% concentration)

        Because JavaScript treats fixed point numbers badly (rounds to
        floating point nearest to binary representation) it is highly advised to
        communicate the fractional numbers as String types, not JavaScript Number type.

        @param {Number|String} ch1 Color channel value
        @param {Number|String} ch2 Color channel value
        @param {Number|String} ch3 Color channel value
        @param {Number|String} ch4 Color channel value

        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setFillColor
         */
        API.setFillColor = function (ch1, ch2, ch3, ch4) {
            var color;

            if (ch2 === undefined || (ch4 === undefined && ch1 === ch2 === ch3)) {
                // Gray color space.
                if (typeof ch1 === 'string') {
                    color = ch1 + ' g';
                } else {
                    color = f2(ch1 / 255) + ' g';
                }
            } else if (ch4 === undefined) {
                // RGB
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, 'rg'].join(' ');
                } else {
                    color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), 'rg'].join(' ');
                }
            } else {
                // CMYK
                if (typeof ch1 === 'string') {
                    color = [ch1, ch2, ch3, ch4, 'k'].join(' ');
                } else {
                    color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), 'k'].join(' ');
                }
            }

            out(color);
            return this;
        };

        /**
        Sets the text color for upcoming elements.
        If only one, first argument is given,
        treats the value as gray-scale color value.

        @param {Number} r Red channel color value in range 0-255
        @param {Number} g Green channel color value in range 0-255
        @param {Number} b Blue channel color value in range 0-255
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setTextColor
        */
        API.setTextColor = function (r, g, b) {
            if ((r === 0 && g === 0 && b === 0) || (typeof g === 'undefined')) {
                textColor = f3(r / 255) + ' g';
            } else {
                textColor = [f3(r / 255), f3(g / 255), f3(b / 255), 'rg'].join(' ');
            }
            return this;
        };

        /**
        Is an Object providing a mapping from human-readable to
        integer flag values designating the varieties of line cap
        and join styles.

        @returns {Object}
        @fieldOf pdfDataExport#
        @name CapJoinStyles
        */
        API.CapJoinStyles = {
            0: 0,
            'butt': 0,
            'but': 0,
            'bevel': 0,
            1: 1,
            'round': 1,
            'rounded': 1,
            'circle': 1,
            2: 2,
            'projecting': 2,
            'project': 2,
            'square': 2,
            'milter': 2
        };

        /**
        Sets the line cap styles
        See {pdfDataExport.CapJoinStyles} for variants

        @param {String|Number} style A string or number identifying the type of line cap
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setLineCap
        */
        API.setLineCap = function (style) {
            var id = this.CapJoinStyles[style];
            if (id === undefined) {
                throw new Error("Line cap style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            }
            lineCapID = id;
            out(id.toString(10) + ' J');

            return this;
        };

        /**
        Sets the line join styles
        See {pdfDataExport.CapJoinStyles} for variants

        @param {String|Number} style A string or number identifying the type of line join
        @function
        @returns {pdfDataExport}
        @methodOf pdfDataExport#
        @name setLineJoin
        */
        API.setLineJoin = function (style) {
            var id = this.CapJoinStyles[style];
            if (id === undefined) {
                throw new Error("Line join style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
            }
            lineJoinID = id;
            out(id.toString(10) + ' j');

            return this;
        };

        // Output is both an internal (for plugins) and external function
        API.output = output;

        /**
         * Saves as PDF document. An alias of pdfDataExport.output('save', 'filename.pdf')
         * @param  {String} filename The filename including extension.
         *
         * @function
         * @returns {pdfDataExport}
         * @methodOf pdfDataExport#
         * @name save
         */
        API.save = function (filename) {
            API.output('save', filename);
        };

        // applying plugins (more methods) ON TOP of built-in API.
        // this is intentional as we allow plugins to override
        // built-ins
        for (plugin in pdfDataExport.API) {
            if (pdfDataExport.API.hasOwnProperty(plugin)) {
                if (plugin === 'events' && pdfDataExport.API.events.length) {
                    (function (events, newEvents) {

                        // pdfDataExport.API.events is a JS Array of Arrays
                        // where each Array is a pair of event name, handler
                        // Events were added by plugins to the pdfDataExport instantiator.
                        // These are always added to the new instance and some ran
                        // during instantiation.

                        var eventname, handler_and_args, i;

                        for (i = newEvents.length - 1; i !== -1; i--) {
                            // subscribe takes 3 args: 'topic', function, runonce_flag
                            // if undefined, runonce is false.
                            // users can attach callback directly,
                            // or they can attach an array with [callback, runonce_flag]
                            // that's what the "apply" magic is for below.
                            eventname = newEvents[i][0];
                            handler_and_args = newEvents[i][1];
                            events.subscribe.apply(
                                events,
                                [eventname].concat(
                                    typeof handler_and_args === 'function' ?
                                            [handler_and_args] :
                                            handler_and_args
                                )
                            );
                        }
                    }(events, pdfDataExport.API.events));
                } else {
                    API[plugin] = pdfDataExport.API[plugin];
                }
            }
        }

        /////////////////////////////////////////
        // continuing initilisation of pdfDataExport Document object
        /////////////////////////////////////////


        // Add the first page automatically
        addFonts();
        activeFontKey = 'F1';
        _addPage();

        events.publish('initialized');

        return API;
    }

    /**
    pdfDataExport.API is a STATIC property of pdfDataExport class.
    pdfDataExport.API is an object you can add methods and properties to.
    The methods / properties you add will show up in new pdfDataExport objects.
    
    One property is prepopulated. It is the 'events' Object. Plugin authors can add topics, callbacks to this object. These will be reassigned to all new instances of pdfDataExport.
    Examples:
        pdfDataExport.API.events['initialized'] = function(){ 'this' is API object }
        pdfDataExport.API.events['addFont'] = function(added_font_object){ 'this' is API object }
    
    @static
    @public
    @memberOf pdfDataExport
    @name API
    
    @example
        pdfDataExport.API.mymethod = function(){
            // 'this' will be ref to internal API object. see pdfDataExport source
            // , so you can refer to built-in methods like so:
            //     this.line(....)
            //     this.text(....)
        }
        var pdfdoc = new pdfDataExport()
        pdfdoc.mymethod() // <- !!!!!!
    */
    pdfDataExport.API = { 'events': [] };

    return pdfDataExport;
}());

(function (pdfDataExportAPI) {
    'use strict';
    /*jslint browser:true */
    /*global document: false, pdfDataExport */

    var maxLn = 0,
        lnP = 0,
        fontName,
        fontSize,
        fontStyle,
        lastCellPos = { x: undefined, y: undefined, w: undefined, h: undefined, ln: undefined },
        pages = 1,
        newPage = false,
        setLastCellPosition = function (x, y, w, h, ln) {
            lastCellPos = { x: x, y: y, w: w, h: h, ln: ln };
        },
        getLastCellPosition = function () {
            return lastCellPos;
        },
        setMaxLn = function (x) {
            maxLn = x;
        },
        getMaxLn = function () {
            return maxLn;
        },
        setLnP = function (x) {
            lnP = x;
        },
        getLnP = function (x) {
            return lnP;
        };

    pdfDataExportAPI.getTextDimensions = function (txt) {
        fontName = this.internal.getFont().fontName;
        fontSize = this.internal.getFontSize();
        fontStyle = this.internal.getFont().fontStyle;

        // 1 pixel = 0.264583 mm and 1 mm = 72/25.4 point
        var px2pt = 0.264583 * 72 / 25.4,
            dimensions,
            text;

        text = document.createElement('font');
        text.id = "pdfDataExportCell";
        text.style.fontStyle = fontStyle;
        text.style.fontName = fontName;
        text.style.fontSize = fontSize + 'pt';
        text.innerHTML = txt;

        document.body.appendChild(text);

        dimensions = { w: (text.offsetWidth + 1) * px2pt, h: (text.offsetHeight + 1) * px2pt };

        document.body.removeChild(text);

        return dimensions;
    };

    pdfDataExportAPI.cellAddPage = function () {
        this.addPage();
        setLastCellPosition(undefined, undefined, undefined, undefined, undefined);
        newPage = true;
        pages += 1;
        setLnP(1);
    };

    pdfDataExportAPI.cellInitialize = function () {
        maxLn = 0;
        lastCellPos = { x: undefined, y: undefined, w: undefined, h: undefined, ln: undefined };
        pages = 1;
        newPage = false;
        setLnP(0);
    };

    pdfDataExportAPI.cell = function (x, y, w, h, txt, ln) {
        this.lnMod = this.lnMod === undefined ? 0 : this.lnMod;
        if (this.printingHeaderRow !== true && this.lnMod !== 0) {
            ln = ln + this.lnMod;
        }

        if ((((ln * h) + y + (h * 2)) / pages) >= this.internal.pageSize.height && pages === 1 && !newPage) {
            this.cellAddPage();

            if (this.printHeaders && this.tableHeaderRow) {
                this.printHeaderRow(ln);
                this.lnMod += 1;
                ln += 1;
            }
            if (getMaxLn() === 0) {
                setMaxLn(Math.round((this.internal.pageSize.height - (h * 2)) / h));
            }
        } else if (newPage && getLastCellPosition().ln !== ln && getLnP() === getMaxLn()) {
            this.cellAddPage();

            if (this.printHeaders && this.tableHeaderRow) {
                this.printHeaderRow(ln);
                this.lnMod += 1;
                ln += 1;
            }
        }

        var curCell = getLastCellPosition(),
            dim = this.getTextDimensions(txt),
            isNewLn = 1;
        if (curCell.x !== undefined && curCell.ln === ln) {
            x = curCell.x + curCell.w;
        }
        if (curCell.y !== undefined && curCell.y === y) {
            y = curCell.y;
        }
        if (curCell.h !== undefined && curCell.h === h) {
            h = curCell.h;
        }
        if (curCell.ln !== undefined && curCell.ln === ln) {
            ln = curCell.ln;
            isNewLn = 0;
        }
        if (newPage) {
            y = h * (getLnP() + isNewLn);
        } else {
            y = (y + (h * Math.abs(getMaxLn() * pages - ln - getMaxLn())));
        }
        this.rect(x, y, w, h);
        var match = /[--]/.test(txt);
        if (match) {
            this.text16(txt, x + 3, y + h - 3);
        }
        else {
            this.text(txt, x + 3, y + h - 3);
        }
        setLnP(getLnP() + isNewLn);
        setLastCellPosition(x, y, w, h, ln);
        return this;
    };

    /**
     * Return an array containing all of the owned keys of an Object
     * @type {Function}
     * @return {String[]} of Object keys
     */
    pdfDataExportAPI.getKeys = (typeof Object.keys === 'function')
        ? function (object) {
            if (!object) {
                return [];
            }
            return Object.keys(object);
        }
            : function (object) {
                var keys = [],
                    property;

                for (property in object) {
                    if (object.hasOwnProperty(property)) {
                        keys.push(property);
                    }
                }

                return keys;
            };

    /**
     * Return the maximum value from an array
     * @param array
     * @param comparisonFn
     * @returns {*}
     */
    pdfDataExportAPI.arrayMax = function (array, comparisonFn) {
        var max = array[0],
            i,
            ln,
            item;

        for (i = 0, ln = array.length; i < ln; i += 1) {
            item = array[i];

            if (comparisonFn) {
                if (comparisonFn(max, item) === -1) {
                    max = item;
                }
            } else {
                if (item > max) {
                    max = item;
                }
            }
        }

        return max;
    };

    /**
     * Create a table from a set of data.
     * @param {Object[]} data As array of objects containing key-value pairs
     * @param {String[]} [headers] Omit or null to auto-generate headers at a performance cost
     * @param {Object} [config.printHeaders] True to print column headers at the top of every page
     * @param {Object} [config.autoSize] True to dynamically set the column widths to match the widest cell value
     * @param {Object} [config.autoStretch] True to force the table to fit the width of the page
     */
    pdfDataExportAPI.table = function (data, headers, config) {

        var headerNames = [],
            headerPrompts = [],
            header,
            autoSize,
            printHeaders,
            autoStretch,
            i,
            ln,
            columnMatrix = {},
            columnWidths = {},
            columnData,
            column,
            columnMinWidths = [],
            j,
            tableHeaderConfigs = [],
            model,
            jln,
            func;

        /**
         * @property {Number} lnMod
         * Keep track of the current line number modifier used when creating cells
         */
        this.lnMod = 0;

        if (config) {
            autoSize = config.autoSize || false;
            printHeaders = this.printHeaders = config.printHeaders || true;
            autoStretch = config.autoStretch || true;
        }

        if (!data) {
            throw 'No data for PDF table';
        }

        // Set headers
        if (headers === undefined || (headers === null)) {

            // No headers defined so we derive from data
            headerNames = this.getKeys(data[0]);

        } else if (headers[0] && (typeof headers[0] !== 'string')) {

            // Split header configs into names and prompts
            for (i = 0, ln = headers.length; i < ln; i += 1) {
                header = headers[i];
                headerNames.push(header.name);
                headerPrompts.push(header.prompt);
            }

        } else {
            headerNames = headers;
        }

        if (config.autoSize) {

            // Create Columns Matrix

            func = function (rec) {
                return rec[header];
            };

            for (i = 0, ln = headerNames.length; i < ln; i += 1) {
                header = headerNames[i];

                columnMatrix[header] = data.map(
                    func
                );

                // get header width
                columnMinWidths.push(this.getTextDimensions(headerPrompts[i] || header).w);

                column = columnMatrix[header];

                // get cell widths
                for (j = 0, ln = column.length; j < ln; j += 1) {
                    columnData = column[j];

                    columnMinWidths.push(this.getTextDimensions(columnData).w);
                }

                // get final column width
                columnWidths[header] = pdfDataExportAPI.arrayMax(columnMinWidths);
            }
        }

        // -- Construct the table

        if (config.printHeaders) {

            // Construct the header row
            for (i = 0, ln = headerNames.length; i < ln; i += 1) {
                header = headerNames[i];
                tableHeaderConfigs.push([10, 10, columnWidths[header], 25, String(headerPrompts.length ? headerPrompts[i] : header)]);
            }

            // Store the table header config
            this.setTableHeaderRow(tableHeaderConfigs);

            // Print the header for the start of the table
            this.printHeaderRow(1);
        }

        // Construct the data rows
        for (i = 0, ln = data.length; i < ln; i += 1) {
            model = data[i];

            for (j = 0, jln = headerNames.length; j < jln; j += 1) {
                header = headerNames[j];
                this.cell(10, 10, columnWidths[header], 25, String(model[header]), i + 2);
            }
        }

        return this;
    };

    /**
     * Store the config for outputting a table header
     * @param {Object[]} config
     * An array of cell configs that would define a header row: Each config matches the config used by pdfDataExportAPI.cell
     * except the ln parameter is excluded
     */
    pdfDataExportAPI.setTableHeaderRow = function (config) {
        this.tableHeaderRow = config;
    };

    /**
     * Output the store header row
     * @param lineNumber The line number to output the header at
     */
    pdfDataExportAPI.printHeaderRow = function (lineNumber) {
        if (!this.tableHeaderRow) {
            throw 'Property tableHeaderRow does not exist.';
        }

        var tableHeaderCell,
            tmpArray,
            i,
            ln;

        this.printingHeaderRow = true;

        for (i = 0, ln = this.tableHeaderRow.length; i < ln; i += 1) {

            tableHeaderCell = this.tableHeaderRow[i];
            tmpArray = [].concat(tableHeaderCell);

            this.cell.apply(this, tmpArray.concat(lineNumber));
        }

        this.printingHeaderRow = false;
    };

}(pdfDataExport.API));


; (function (API) {
    'use strict'

    /**
    Returns an array of length matching length of the 'word' string, with each
    cell ocupied by the width of the char in that position.
    
    @function
    @param word {String}
    @param widths {Object}
    @param kerning {Object}
    @returns {Array}
    */
    var getCharWidthsArray = API.getCharWidthsArray = function (text, options) {

        if (!options) {
            options = {}
        }

        var widths = options.widths ? options.widths : this.internal.getFont().metadata.Unicode.widths
        , widthsFractionOf = widths.fof ? widths.fof : 1
        , kerning = options.kerning ? options.kerning : this.internal.getFont().metadata.Unicode.kerning
        , kerningFractionOf = kerning.fof ? kerning.fof : 1

        // console.log("widths, kergnings", widths, kerning)

        var i, l
        , char_code
        , char_width
        , prior_char_code = 0 // for kerning
        , default_char_width = widths[0] || widthsFractionOf
        , output = []

        for (i = 0, l = text.length; i < l; i++) {
            char_code = text.charCodeAt(i)
            output.push(
                (widths[char_code] || default_char_width) / widthsFractionOf +
                (kerning[char_code] && kerning[char_code][prior_char_code] || 0) / kerningFractionOf
            )
            prior_char_code = char_code
        }

        return output
    }
    var getArraySum = function (array) {
        var i = array.length
        , output = 0
        while (i) {
            ; i--;
            output += array[i]
        }
        return output
    }
    /**
    Returns a widths of string in a given font, if the font size is set as 1 point.
    
    In other words, this is "proportional" value. For 1 unit of font size, the length
    of the string will be that much.
    
    Multiply by font size to get actual width in *points*
    Then divide by 72 to get inches or divide by (72/25.6) to get 'mm' etc.
    
    @public
    @function
    @param
    @returns {Type}
    */
    var getStringUnitWidth = API.getStringUnitWidth = function (text, options) {
        return getArraySum(getCharWidthsArray.call(this, text, options))
    }

    /** 
    returns array of lines
    */
    var splitLongWord = function (word, widths_array, firstLineMaxLen, maxLen) {
        var answer = []

        // 1st, chop off the piece that can fit on the hanging line.
        var i = 0
        , l = word.length
        , workingLen = 0
        while (i !== l && workingLen + widths_array[i] < firstLineMaxLen) {
            workingLen += widths_array[i]
            ; i++;
        }
        // this is first line.
        answer.push(word.slice(0, i))

        // 2nd. Split the rest into maxLen pieces.
        var startOfLine = i
        workingLen = 0
        while (i !== l) {
            if (workingLen + widths_array[i] > maxLen) {
                answer.push(word.slice(startOfLine, i))
                workingLen = 0
                startOfLine = i
            }
            workingLen += widths_array[i]
            ; i++;
        }
        if (startOfLine !== i) {
            answer.push(word.slice(startOfLine, i))
        }

        return answer
    }

    // Note, all sizing inputs for this function must be in "font measurement units"
    // By default, for PDF, it's "point".
    var splitParagraphIntoLines = function (text, maxlen, options) {
        // at this time works only on Western scripts, ones with space char
        // separating the words. Feel free to expand.

        if (!options) {
            options = {}
        }

        var spaceCharWidth = getCharWidthsArray(' ', options)[0]

        var words = text.split(' ')

        var line = []
        , lines = [line]
        , line_length = options.textIndent || 0
        , separator_length = 0
        , current_word_length = 0
        , word
        , widths_array

        var i, l, tmp
        for (i = 0, l = words.length; i < l; i++) {
            word = words[i]
            widths_array = getCharWidthsArray(word, options)
            current_word_length = getArraySum(widths_array)

            if (line_length + separator_length + current_word_length > maxlen) {
                if (current_word_length > maxlen) {
                    // this happens when you have space-less long URLs for example.
                    // we just chop these to size. We do NOT insert hiphens
                    tmp = splitLongWord(word, widths_array, maxlen - (line_length + separator_length), maxlen)
                    // first line we add to existing line object
                    line.push(tmp.shift()) // it's ok to have extra space indicator there
                    // last line we make into new line object
                    line = [tmp.pop()]
                    // lines in the middle we apped to lines object as whole lines
                    while (tmp.length) {
                        lines.push([tmp.shift()]) // single fragment occupies whole line
                    }
                    current_word_length = getArraySum(widths_array.slice(word.length - line[0].length))
                } else {
                    // just put it on a new line
                    line = [word]
                }

                // now we attach new line to lines
                lines.push(line)

                line_length = current_word_length
                separator_length = spaceCharWidth

            } else {
                line.push(word)

                line_length += separator_length + current_word_length
                separator_length = spaceCharWidth
            }
        }

        var output = []
        for (i = 0, l = lines.length; i < l; i++) {
            output.push(lines[i].join(' '))
        }
        return output

    }

    /**
    Splits a given string into an array of strings. Uses 'size' value
    (in measurement units declared as default for the pdfDataExport instance)
    and the font's "widths" and "Kerning" tables, where availabe, to
    determine display length of a given string for a given font.
    
    We use character's 100% of unit size (height) as width when Width
    table or other default width is not available.
    
    @public
    @function
    @param text {String} Unencoded, regular JavaScript (Unicode, UTF-16 / UCS-2) string.
    @param size {Number} Nominal number, measured in units default to this instance of pdfDataExport.
    @param options {Object} Optional flags needed for chopper to do the right thing.
    @returns {Array} with strings chopped to size.
    */
    API.splitTextToSize = function (text, maxlen, options) {
        'use strict'

        if (!options) {
            options = {}
        }

        var fsize = options.fontSize || this.internal.getFontSize()
        , newOptions = (function (options) {
            var widths = { 0: 1 }
            , kerning = {}

            if (!options.widths || !options.kerning) {
                var f = this.internal.getFont(options.fontName, options.fontStyle)
                , encoding = 'Unicode'
                // NOT UTF8, NOT UTF16BE/LE, NOT UCS2BE/LE
                // Actual JavaScript-native String's 16bit char codes used.
                // no multi-byte logic here

                if (f.metadata[encoding]) {
                    return {
                        widths: f.metadata[encoding].widths || widths
                        , kerning: f.metadata[encoding].kerning || kerning
                    }
                }
            } else {
                return {
                    widths: options.widths
                    , kerning: options.kerning
                }
            }

            // then use default values
            return {
                widths: widths
                , kerning: kerning
            }
        }).call(this, options)

        // first we split on end-of-line chars
        var paragraphs
        if (text.match(/[\n\r]/)) {
            paragraphs = text.split(/\r\n|\r|\n/g)
        } else {
            paragraphs = [text]
        }

        // now we convert size (max length of line) into "font size units"
        // at present time, the "font size unit" is always 'point'
        // 'proportional' means, "in proportion to font size"
        var fontUnit_maxLen = 1.0 * this.internal.scaleFactor * maxlen / fsize
        // at this time, fsize is always in "points" regardless of the default measurement unit of the doc.
        // this may change in the future?
        // until then, proportional_maxlen is likely to be in 'points'

        // If first line is to be indented (shorter or longer) than maxLen 
        // we indicate that by using CSS-style "text-indent" option.
        // here it's in font units too (which is likely 'points')
        // it can be negative (which makes the first line longer than maxLen)
        newOptions.textIndent = options.textIndent ?
            options.textIndent * 1.0 * this.internal.scaleFactor / fsize :
            0

        var i, l
        , output = []
        for (i = 0, l = paragraphs.length; i < l; i++) {
            output = output.concat(
                splitParagraphIntoLines(
                    paragraphs[i]
                    , fontUnit_maxLen
                    , newOptions
                )
            )
        }

        return output
    }

})(pdfDataExport.API);


; (function (pdfDataExportAPI) {
    'use strict'

    var namespace = 'addImage_'

    var getJpegSize = function (imgData) {
        'use strict'
        var width, height;
        // Verify we have a valid jpeg header 0xff,0xd8,0xff,0xe0,?,?,'J','F','I','F',0x00
        if (!imgData.charCodeAt(0) === 0xff ||
            !imgData.charCodeAt(1) === 0xd8 ||
            !imgData.charCodeAt(2) === 0xff ||
            !imgData.charCodeAt(3) === 0xe0 ||
            !imgData.charCodeAt(6) === 'J'.charCodeAt(0) ||
            !imgData.charCodeAt(7) === 'F'.charCodeAt(0) ||
            !imgData.charCodeAt(8) === 'I'.charCodeAt(0) ||
            !imgData.charCodeAt(9) === 'F'.charCodeAt(0) ||
            !imgData.charCodeAt(10) === 0x00) {
            throw new Error('getJpegSize requires a binary jpeg file')
        }
        var blockLength = imgData.charCodeAt(4) * 256 + imgData.charCodeAt(5);
        var i = 4, len = imgData.length;
        while (i < len) {
            i += blockLength;
            if (imgData.charCodeAt(i) !== 0xff) {
                throw new Error('getJpegSize could not find the size of the image');
            }
            if (imgData.charCodeAt(i + 1) === 0xc0) {
                height = imgData.charCodeAt(i + 5) * 256 + imgData.charCodeAt(i + 6);
                width = imgData.charCodeAt(i + 7) * 256 + imgData.charCodeAt(i + 8);
                return [width, height];
            } else {
                i += 2;
                blockLength = imgData.charCodeAt(i) * 256 + imgData.charCodeAt(i + 1)
            }
        }
    }
    // Image functionality ported from pdf.js
    , putImage = function (img) {
        var objectNumber = this.internal.newObject()
        , out = this.internal.write
        , putStream = this.internal.putStream

        img['n'] = objectNumber

        out('<</Type /XObject')
        out('/Subtype /Image')
        out('/Width ' + img['w'])
        out('/Height ' + img['h'])
        if (img['cs'] === 'Indexed') {
            out('/ColorSpace [/Indexed /DeviceRGB '
                    + (img['pal'].length / 3 - 1) + ' ' + (objectNumber + 1)
                    + ' 0 R]');
        } else {
            out('/ColorSpace /' + img['cs']);
            if (img['cs'] === 'DeviceCMYK') {
                out('/Decode [1 0 1 0 1 0 1 0]');
            }
        }
        out('/BitsPerComponent ' + img['bpc']);
        if ('f' in img) {
            out('/Filter /' + img['f']);
        }
        if ('dp' in img) {
            out('/DecodeParms <<' + img['dp'] + '>>');
        }
        if ('trns' in img && img['trns'].constructor == Array) {
            var trns = '';
            for (var i = 0; i < img['trns'].length; i++) {
                trns += (img[trns][i] + ' ' + img['trns'][i] + ' ');
                out('/Mask [' + trns + ']');
            }
        }
        if ('smask' in img) {
            out('/SMask ' + (objectNumber + 1) + ' 0 R');
        }
        out('/Length ' + img['data'].length + '>>');

        putStream(img['data']);

        out('endobj');
    }
    , putResourcesCallback = function () {
        var images = this.internal.collections[namespace + 'images']
        for (var i in images) {
            putImage.call(this, images[i])
        }
    }
    , putXObjectsDictCallback = function () {
        var images = this.internal.collections[namespace + 'images']
        , out = this.internal.write
        , image
        for (var i in images) {
            image = images[i]
            out(
                '/I' + image['i']
                , image['n']
                , '0'
                , 'R'
            )
        }
    }

    pdfDataExportAPI.addImage = function (imageData, format, x, y, w, h) {
        'use strict'
        if (typeof imageData === 'object' && imageData.nodeType === 1) {
            var canvas = document.createElement('canvas');
            canvas.width = imageData.clientWidth;
            canvas.height = imageData.clientHeight;

            var ctx = canvas.getContext('2d');
            if (!ctx) {
                throw ('addImage requires canvas to be supported by browser.');
            }
            ctx.drawImage(imageData, 0, 0, canvas.width, canvas.height);
            imageData = canvas.toDataURL('image/jpeg');
            format = "JPEG";
        }
        if (format.toUpperCase() !== 'JPEG') {
            throw new Error('addImage currently only supports format \'JPEG\', not \'' + format + '\'');
        }

        var imageIndex
        , images = this.internal.collections[namespace + 'images']
        , coord = this.internal.getCoordinateString
        , vcoord = this.internal.getVerticalCoordinateString;

        // Detect if the imageData is raw binary or Data URL
        if (imageData.substring(0, 23) === 'data:image/jpeg;base64,') {
            imageData = atob(imageData.replace('data:image/jpeg;base64,', ''));
        }

        if (images) {
            // this is NOT the first time this method is ran on this instance of pdfDataExport object.
            imageIndex = Object.keys ?
            Object.keys(images).length :
            (function (o) {
                var i = 0
                for (var e in o) { if (o.hasOwnProperty(e)) { i++ } }
                return i
            })(images)
        } else {
            // this is the first time this method is ran on this instance of pdfDataExport object.
            imageIndex = 0
            this.internal.collections[namespace + 'images'] = images = {}
            this.internal.events.subscribe('putResources', putResourcesCallback)
            this.internal.events.subscribe('putXobjectDict', putXObjectsDictCallback)
        }

        var dims = getJpegSize(imageData);
        var info = {
            w: dims[0],
            h: dims[1],
            cs: 'DeviceRGB',
            bpc: 8,
            f: 'DCTDecode',
            i: imageIndex,
            data: imageData
            // n: objectNumber will be added by putImage code

        };
        images[imageIndex] = info
        if (!w && !h) {
            w = -96;
            h = -96;
        }
        if (w < 0) {
            w = (-1) * info['w'] * 72 / w / this.internal.scaleFactor;
        }
        if (h < 0) {
            h = (-1) * info['h'] * 72 / h / this.internal.scaleFactor;
        }
        if (w === 0) {
            w = h * info['w'] / info['h'];
        }
        if (h === 0) {
            h = w * info['h'] / info['w'];
        }

        this.internal.write(
            'q'
            , coord(w)
            , '0 0'
            , coord(h) // TODO: check if this should be shifted by vcoord
            , coord(x)
            , vcoord(y + h)
            , 'cm /I' + info['i']
            , 'Do Q'
        )

        return this
    }
})(pdfDataExport.API)

; (function (API) {
    'use strict'

    /**
    Uncompresses data compressed into custom, base16-like format. 
    @public
    @function
    @param
    @returns {Type}
    */
    var uncompress = function (data) {

        var decoded = '0123456789abcdef'
        , encoded = 'klmnopqrstuvwxyz'
        , mapping = {}

        for (var i = 0; i < encoded.length; i++) {
            mapping[encoded[i]] = decoded[i]
        }

        var undef
        , output = {}
        , sign = 1
        , stringparts // undef. will be [] in string mode

        , activeobject = output
        , parentchain = []
        , parent_key_pair
        , keyparts = ''
        , valueparts = ''
        , key // undef. will be Truthy when Key is resolved.
        , datalen = data.length - 1 // stripping ending }
        , ch

        i = 1 // stripping starting {

        while (i != datalen) {
            // - { } ' are special.

            ch = data[i]
            i += 1

            if (ch == "'") {
                if (stringparts) {
                    // end of string mode
                    key = stringparts.join('')
                    stringparts = undef
                } else {
                    // start of string mode
                    stringparts = []
                }
            } else if (stringparts) {
                stringparts.push(ch)
            } else if (ch == '{') {
                // start of object
                parentchain.push([activeobject, key])
                activeobject = {}
                key = undef
            } else if (ch == '}') {
                // end of object
                parent_key_pair = parentchain.pop()
                parent_key_pair[0][parent_key_pair[1]] = activeobject
                key = undef
                activeobject = parent_key_pair[0]
            } else if (ch == '-') {
                sign = -1
            } else {
                // must be number
                if (key === undef) {
                    if (mapping.hasOwnProperty(ch)) {
                        keyparts += mapping[ch]
                        key = parseInt(keyparts, 16) * sign
                        sign = +1
                        keyparts = ''
                    } else {
                        keyparts += ch
                    }
                } else {
                    if (mapping.hasOwnProperty(ch)) {
                        valueparts += mapping[ch]
                        activeobject[key] = parseInt(valueparts, 16) * sign
                        sign = +1
                        key = undef
                        valueparts = ''
                    } else {
                        valueparts += ch
                    }
                }
            }
        } // end while

        return output
    }

    // encoding = 'Unicode' 
    // NOT UTF8, NOT UTF16BE/LE, NOT UCS2BE/LE. NO clever BOM behavior
    // Actual 16bit char codes used.
    // no multi-byte logic here

    // Unicode characters to WinAnsiEncoding:
    // {402: 131, 8211: 150, 8212: 151, 8216: 145, 8217: 146, 8218: 130, 8220: 147, 8221: 148, 8222: 132, 8224: 134, 8225: 135, 8226: 149, 8230: 133, 8364: 128, 8240:137, 8249: 139, 8250: 155, 710: 136, 8482: 153, 338: 140, 339: 156, 732: 152, 352: 138, 353: 154, 376: 159, 381: 142, 382: 158}
    // as you can see, all Unicode chars are outside of 0-255 range. No char code conflicts.
    // this means that you can give Win cp1252 encoded strings to pdfDataExport for rendering directly
    // as well as give strings with some (supported by these fonts) Unicode characters and 
    // these will be mapped to win cp1252 
    // for example, you can send char code (cp1252) 0x80 or (unicode) 0x20AC, getting "Euro" glyph displayed in both cases.

    var encodingBlock = {
        'codePages': ['WinAnsiEncoding']
        , 'WinAnsiEncoding': uncompress("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
    }
    , encodings = {
        'Unicode': {
            'Courier': encodingBlock
            , 'Courier-Bold': encodingBlock
            , 'Courier-BoldOblique': encodingBlock
            , 'Courier-Oblique': encodingBlock
            , 'Helvetica': encodingBlock
            , 'Helvetica-Bold': encodingBlock
            , 'Helvetica-BoldOblique': encodingBlock
            , 'Helvetica-Oblique': encodingBlock
            , 'Times-Roman': encodingBlock
            , 'Times-Bold': encodingBlock
            , 'Times-BoldItalic': encodingBlock
            , 'Times-Italic': encodingBlock
            //	, 'Symbol'
            //	, 'ZapfDingbats'
        }
    }

    , fontMetrics = {
        'Unicode': {
            // all sizing numbers are n/fontMetricsFractionOf = one font size unit
            // this means that if fontMetricsFractionOf = 1000, and letter A's width is 476, it's
            // width is 476/1000 or 47.6% of its height (regardless of font size)
            // At this time this value applies to "widths" and "kerning" numbers.

            // char code 0 represents "default" (average) width - use it for chars missing in this table.
            // key 'fof' represents the "fontMetricsFractionOf" value

            'Courier-Oblique': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")
            , 'Times-BoldItalic': uncompress("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}")
            , 'Helvetica-Bold': uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}")
            , 'Courier': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")
            , 'Courier-BoldOblique': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")
            , 'Times-Bold': uncompress("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}")
            //, 'Symbol': uncompress("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}")
            , 'Helvetica': uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
            , 'Helvetica-BoldOblique': uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}")
            //, 'ZapfDingbats': uncompress("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}")
            , 'Courier-Bold': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}")
            , 'Times-Italic': uncompress("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}")
            , 'Times-Roman': uncompress("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}")
            , 'Helvetica-Oblique': uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
        }
    };

    /*
    This event handler is fired when a new pdfDataExport object is initialized
    This event handler appends metrics data to standard fonts within
    that pdfDataExport instance. The metrics are mapped over Unicode character
    codes, NOT CIDs or other codes matching the StandardEncoding table of the
    standard PDF fonts.
    Future:
    Also included is the encoding maping table, converting Unicode (UCS-2, UTF-16)
    char codes to StandardEncoding character codes. The encoding table is to be used
    somewhere around "pdfEscape" call.
    */

    API.events.push([
        'addFonts'
        , function (fontManagementObjects) {
            // fontManagementObjects is {
            //	'fonts':font_ID-keyed hash of font objects
            //	, 'dictionary': lookup object, linking ["FontFamily"]['Style'] to font ID
            //}
            var font
            , fontID
            , metrics
            , unicode_section
            , encoding = 'Unicode'
            , encodingBlock

            for (fontID in fontManagementObjects.fonts) {
                if (fontManagementObjects.fonts.hasOwnProperty(fontID)) {
                    font = fontManagementObjects.fonts[fontID]

                    // // we only ship 'Unicode' mappings and metrics. No need for loop.
                    // // still, leaving this for the future.

                    // for (encoding in fontMetrics){
                    // 	if (fontMetrics.hasOwnProperty(encoding)) {

                    metrics = fontMetrics[encoding][font.PostScriptName]
                    if (metrics) {
                        if (font.metadata[encoding]) {
                            unicode_section = font.metadata[encoding]
                        } else {
                            unicode_section = font.metadata[encoding] = {}
                        }

                        unicode_section.widths = metrics.widths
                        unicode_section.kerning = metrics.kerning
                    }
                    // 	}
                    // }
                    // for (encoding in encodings){
                    // 	if (encodings.hasOwnProperty(encoding)) {
                    encodingBlock = encodings[encoding][font.PostScriptName]
                    if (encodingBlock) {
                        if (font.metadata[encoding]) {
                            unicode_section = font.metadata[encoding]
                        } else {
                            unicode_section = font.metadata[encoding] = {}
                        }

                        unicode_section.encoding = encodingBlock
                        if (encodingBlock.codePages && encodingBlock.codePages.length) {
                            font.encoding = encodingBlock.codePages[0]
                        }
                    }
                    // 	}
                    // }
                }
            }
        }
    ]) // end of adding event handler

})(pdfDataExport.API);


/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */


var saveAs = window.jqxSaveAs = saveAs
  || (navigator.msSaveBlob && navigator.msSaveBlob.bind(navigator))
  || (function (view) {
      "use strict";
      var
            doc = view.document
            // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
          , get_URL = function () {
              return view.URL || view.webkitURL || view;
          }
          , URL = view.URL || view.webkitURL || view
           , save_link = $("<a></a>")[0]
      //   , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
          , can_use_save_link = "download" in save_link
          , click = function (node) {
              var event = doc.createEvent("MouseEvents");
              event.initMouseEvent(
                  "click", true, false, view, 0, 0, 0, 0, 0
                  , false, false, false, false, 0, null
              );
              return node.dispatchEvent(event); // false if event was cancelled
          }
          , webkit_req_fs = view.webkitRequestFileSystem
          , req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
          , throw_outside = function (ex) {
              (view.setImmediate || view.setTimeout)(function () {
                  throw ex;
              }, 0);
          }
          , force_saveable_type = "application/octet-stream"
          , fs_min_size = 0
          , deletion_queue = []
          , process_deletion_queue = function () {
              var i = deletion_queue.length;
              while (i--) {
                  var file = deletion_queue[i];
                  if (typeof file === "string") { // file is an object URL
                      URL.revokeObjectURL(file);
                  } else { // file is a File
                      file.remove();
                  }
              }
              deletion_queue.length = 0; // clear queue
          }
          , dispatch = function (filesaver, event_types, event) {
              event_types = [].concat(event_types);
              var i = event_types.length;
              while (i--) {
                  var listener = filesaver["on" + event_types[i]];
                  if (typeof listener === "function") {
                      try {
                          listener.call(filesaver, event || filesaver);
                      } catch (ex) {
                          throw_outside(ex);
                      }
                  }
              }
          }
          , FileSaver = function (blob, name) {
              // First try a.download, then web filesystem, then object URLs
              var
                    filesaver = this
                  , type = blob.type
                  , blob_changed = false
                  , object_url
                  , target_view
                  , get_object_url = function () {
                      var object_url = get_URL().createObjectURL(blob);
                      deletion_queue.push(object_url);
                      return object_url;
                  }
                  , dispatch_all = function () {
                      dispatch(filesaver, "writestart progress write writeend".split(" "));
                  }
                  // on any filesys errors revert to saving with object URLs
                  , fs_error = function () {
                      // don't create more object URLs than needed
                      if (blob_changed || !object_url) {
                          object_url = get_object_url(blob);
                      }
                      if (target_view) {
                          target_view.location.href = object_url;
                      }
                      filesaver.readyState = filesaver.DONE;
                      dispatch_all();
                  }
                  , abortable = function (func) {
                      return function () {
                          if (filesaver.readyState !== filesaver.DONE) {
                              return func.apply(this, arguments);
                          }
                      };
                  }
                  , create_if_not_found = { create: true, exclusive: false }
                  , slice
              ;
              filesaver.readyState = filesaver.INIT;
              if (!name) {
                  name = "download";
              }
              if (can_use_save_link) {
                  object_url = get_object_url(blob);
                  save_link.href = object_url;
                  save_link.download = name;
                  if (click(save_link)) {
                      filesaver.readyState = filesaver.DONE;
                      dispatch_all();
                      return;
                  }
              }
              // Object and web filesystem URLs have a problem saving in Google Chrome when
              // viewed in a tab, so I force save with application/octet-stream
              // http://code.google.com/p/chromium/issues/detail?id=91158
              if (view.chrome && type && type !== force_saveable_type) {
                  slice = blob.slice || blob.webkitSlice;
                  blob = slice.call(blob, 0, blob.size, force_saveable_type);
                  blob_changed = true;
              }
              // Since I can't be sure that the guessed media type will trigger a download
              // in WebKit, I append .download to the filename.
              // https://bugs.webkit.org/show_bug.cgi?id=65440
              if (webkit_req_fs && name !== "download") {
                  name += ".download";
              }
              if (type === force_saveable_type || webkit_req_fs) {
                  target_view = view;
              } else {
                  target_view = view.open();
              }
              if (!req_fs) {
                  fs_error();
                  return;
              }
              fs_min_size += blob.size;
              req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
                  fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) {
                      var save = function () {
                          dir.getFile(name, create_if_not_found, abortable(function (file) {
                              file.createWriter(abortable(function (writer) {
                                  writer.onwriteend = function (event) {
                                      target_view.location.href = file.toURL();
                                      deletion_queue.push(file);
                                      filesaver.readyState = filesaver.DONE;
                                      dispatch(filesaver, "writeend", event);
                                  };
                                  writer.onerror = function () {
                                      var error = writer.error;
                                      if (error.code !== error.ABORT_ERR) {
                                          fs_error();
                                      }
                                  };
                                  "writestart progress write abort".split(" ").forEach(function (event) {
                                      writer["on" + event] = filesaver["on" + event];
                                  });
                                  writer.write(blob);
                                  filesaver.abort = function () {
                                      writer.abort();
                                      filesaver.readyState = filesaver.DONE;
                                  };
                                  filesaver.readyState = filesaver.WRITING;
                              }), fs_error);
                          }), fs_error);
                      };
                      dir.getFile(name, { create: false }, abortable(function (file) {
                          // delete file if it already exists
                          file.remove();
                          save();
                      }), abortable(function (ex) {
                          if (ex.code === ex.NOT_FOUND_ERR) {
                              save();
                          } else {
                              fs_error();
                          }
                      }));
                  }), fs_error);
              }), fs_error);
          }
          , FS_proto = FileSaver.prototype
          , saveAs = function (blob, name) {
              return new FileSaver(blob, name);
          }
      ;
      FS_proto.abort = function () {
          var filesaver = this;
          filesaver.readyState = filesaver.DONE;
          dispatch(filesaver, "abort");
      };
      FS_proto.readyState = FS_proto.INIT = 0;
      FS_proto.WRITING = 1;
      FS_proto.DONE = 2;

      FS_proto.error =
      FS_proto.onwritestart =
      FS_proto.onprogress =
      FS_proto.onwrite =
      FS_proto.onabort =
      FS_proto.onerror =
      FS_proto.onwriteend =
          null;

      if (view.addEventListener) {
          view.addEventListener("unload", process_deletion_queue, false);
      }
      return saveAs;
  }(self));


; (function (API) {
    'use strict'

    var name = 'pdfDataExport IE Below 9 Shim plugin';
    // Shim in IE6-9 support
    API.output = function (type, options) {

        // If not IE then return early
        return this.internal.output(type, options);

        var filename = 'Output.pdf';
        switch (type) {
            case 'datauristring':
            case 'dataurlstring':
            case 'datauri':
            case 'dataurl':
            case 'dataurlnewwindow':
                if (console)
                    console.log(name + ': Data URIs are not supported on IE6-9.');
                break;
            case 'save':
                filename = options;
                break;
        }

        // @TODO: IE shim 


    };



})(pdfDataExport.API)
})();



/***/ }),

/***/ 4198:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

( function ( $ ) {

    if ( !Array.prototype.find ) {
        Object.defineProperty( Array.prototype, 'find', {
            value: function ( predicate ) {
                // 1. Let O be ? ToObject(this value).
                if ( this == null ) {
                    throw TypeError( '"this" is null or not defined' );
                }

                var o = Object( this );

                // 2. Let len be ? ToLength(? Get(O, "length")).
                var len = o.length >>> 0;

                // 3. If IsCallable(predicate) is false, throw a TypeError exception.
                if ( typeof predicate !== 'function' ) {
                    throw TypeError( 'predicate must be a function' );
                }

                // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
                var thisArg = arguments[ 1 ];

                // 5. Let k be 0.
                var k = 0;

                // 6. Repeat, while k < len
                while ( k < len ) {
                    // a. Let Pk be ! ToString(k).
                    // b. Let kValue be ? Get(O, Pk).
                    // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
                    // d. If testResult is true, return kValue.
                    var kValue = o[ k ];
                    if ( predicate.call( thisArg, kValue, k, o ) ) {
                        return kValue;
                    }
                    // e. Increase k by 1.
                    k++;
                }

                // 7. Return undefined.
                return undefined;
            },
            configurable: true,
            writable: true
        } );
    }

    $.jqx.observableArray = function ( items, observeFunction ) {
        if ( typeof ( items ) == 'string' ) {
            items = $.parseJSON( items );
        }

        if ( !Object.defineProperty ||
            !( function () { try { Object.defineProperty( {}, 'x', {} ); return true; } catch ( e ) { return false; } }() ) ) {
            var orig = Object.defineProperty;
            Object.defineProperty = function ( o, prop, desc ) {
                // In IE8 try built-in implementation for defining properties on DOM prototypes.
                if ( orig ) { try { return orig( o, prop, desc ); } catch ( e ) { } }

                if ( o !== Object( o ) ) { throw TypeError( "Object.defineProperty called on non-object" ); }
                if ( Object.prototype.__defineGetter__ && ( 'get' in desc ) ) {
                    Object.prototype.__defineGetter__.call( o, prop, desc.get );
                }
                if ( Object.prototype.__defineSetter__ && ( 'set' in desc ) ) {
                    Object.prototype.__defineSetter__.call( o, prop, desc.set );
                }
                if ( 'value' in desc ) {
                    o[ prop ] = desc.value;
                }
                else if ( !o[ prop ] ) {
                    o[ prop ] = desc;
                }

                return o;
            };
        }

        if ( !Array.prototype.forEach ) {
            Array.prototype.forEach = function ( fun /*, thisp */ ) {
                if ( this === void 0 || this === null ) { throw TypeError(); }

                var t = Object( this );
                var len = t.length >>> 0;
                if ( typeof fun !== "function" ) { throw TypeError(); }

                var thisp = arguments[ 1 ], i;
                for ( i = 0; i < len; i++ ) {
                    if ( i in t ) {
                        fun.call( thisp, t[ i ], i, t );
                    }
                }
            };
        }

        if ( typeof Object.getOwnPropertyNames !== "function" ) {
            Object.getOwnPropertyNames = function ( o ) {
                if ( o !== Object( o ) ) { throw TypeError( "Object.getOwnPropertyNames called on non-object" ); }
                var props = [], p;
                for ( p in o ) {
                    if ( Object.prototype.hasOwnProperty.call( o, p ) ) {
                        props.push( p );
                    }
                }
                return props;
            };
        }

        var that = this, notifier, array = [];
        that.notifier = null;
        that.name = "observableArray";
        that.observing = true;
        that.changes = new Array();

        var observeFunction = observeFunction;
        that.observe = function () {
            that.observing = true;
            if ( arguments.length == 1 ) {
                observeFunction = arguments[ 0 ];
            }
        }

        that.unobserve = function () {
            that.observing = false;
        }

        that.toArray = function () {
            return array.slice( 0 );
        }

        that.toJSON = function ( keys, subArray ) {
            var value = array;
            if ( subArray ) {
                value = subArray;
            }
            var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                meta = {
                    '\b': '\\b',
                    '\t': '\\t',
                    '\n': '\\n',
                    '\f': '\\f',
                    '\r': '\\r',
                    '"': '\\"',
                    '\\': '\\\\'
                };

            function quote( string ) {
                return '"' + string.replace( escapable, function ( a ) {
                    var c = meta[ a ];
                    return typeof c === 'string' ? c : '\\u' + ( '0000' + a.charCodeAt( 0 ).toString( 16 ) ).slice( -4 );
                } ) + '"';
            }

            function formatNumber( n ) {
                return n < 10 ? '0' + n : n;
            }

            function stringifyDate( value ) {
                var date;
                if ( isFinite( value.valueOf() ) ) {
                    date = value.getUTCFullYear() + '-' + formatNumber( value.getUTCMonth() + 1 ) + '-' +
                        formatNumber( value.getUTCDate() ) + 'T' + formatNumber( value.getUTCHours() ) + ':' +
                        formatNumber( value.getUTCMinutes() ) + ':' + formatNumber( value.getUTCSeconds() ) + 'Z"';
                } else {
                    date = 'null';
                }
                return date;
            }

            function stringifyArray( value ) {
                var len = value.length,
                    partial = [],
                    i;
                for ( i = 0; i < len; i++ ) {
                    partial.push( str( i, value ) || 'null' );
                }

                return '[' + partial.join( ',' ) + ']';
            }

            function stringifyObject( value ) {
                var partial = [],
                    i, v;
                for ( i in value ) {
                    if ( Object.prototype.hasOwnProperty.call( value, i ) ) {
                        if ( i != "" && keys && keys.indexOf( i ) === -1 ) {
                            continue;
                        }

                        v = str( i, value );
                        if ( v ) {
                            partial.push( quote( i ) + ':' + v );
                        }
                    }
                }
                return '{' + partial.join( ',' ) + '}';
            }

            function stringifyReference( value ) {
                switch ( Object.prototype.toString.call( value ) ) {
                    case '[object Date]':
                        return stringifyDate( value );
                    case '[object Array]':
                        return stringifyArray( value );
                }
                return stringifyObject( value );
            }

            function stringifyPrimitive( value, type ) {
                switch ( type ) {
                    case 'string':
                        return quote( value );
                    case 'number':
                    case 'float':
                    case 'integer':
                    case 'int':
                        return isFinite( value ) ? value : 'null';
                    case 'boolean':
                        return value;
                }
                return 'null';
            }

            function str( key, holder ) {
                var value = holder[ key ], type = typeof value;

                if ( value && typeof value === 'object' && typeof value.toJSON === 'function' ) {
                    value = value.toJSON( key );
                    type = typeof value;
                }
                if ( /(number|float|int|integer|string|boolean)/.test( type ) || ( !value && type === 'object' ) ) {
                    return stringifyPrimitive( value, type );
                } else {
                    return stringifyReference( value );
                }
            }
            if ( !keys && window.JSON && typeof window.JSON.stringify === 'function' ) {
                return window.JSON.stringify( value );
            }

            return str( "", { "": value } );
        }

        that.defineIndexProperty = function ( index ) {
            if ( !( index in that ) ) {
                var defineProperty = function ( obj, property, path, context ) {
                    var newValue = obj[ property ];
                    var oldValue = newValue;
                    var getter = function () {
                        return oldValue;
                    }
                    var setter = function ( val ) {
                        newValue = val;
                        if ( oldValue !== newValue ) {
                            var oldValueArg = oldValue;
                            oldValue = newValue;
                            if ( typeof notifier === "function" ) {
                                var index = array.indexOf( context );

                                var propertyPath = "";
                                var getPath = function ( obj, path ) {
                                    Object.getOwnPropertyNames( obj ).forEach( function ( name ) {
                                        var type = $.type( obj[ name ] );
                                        if ( type == "array" || type == "object" ) {
                                            getPath( obj[ name ], path + "." + name );
                                        }
                                        else if ( property === name ) {
                                            propertyPath = path + "." + name;
                                        }
                                    } );
                                }
                                getPath( context, index );

                                notifier( { object: that, type: 'update', path: propertyPath, index: index, name: property, newValue: newValue, oldValue: oldValueArg } );
                            }
                        }
                        oldValue = newValue;
                        return newValue;
                    }
                    if ( obj[ property ] != undefined && property != "length" ) {
                        if ( Object.defineProperty )
                            Object.defineProperty( obj, property, {
                                get: getter,
                                set: setter
                            } );
                        else if ( Object.prototype.__defineGetter__ && Object.prototype.__defineSetter__ ) {
                            Object.prototype.__defineGetter__.call( obj, property, getter );
                            Object.prototype.__defineSetter__.call( obj, property, setter );
                        }
                    }
                }

                var defineProperties = function ( obj, path, context ) {
                    var type = $.type( obj );
                    if ( /(number|float|int|integer|string|boolean)/.test( type ) ) {
                        return;
                    }

                    if ( obj === undefined ) {
                        return;
                    }

                    Object.getOwnPropertyNames( obj ).forEach( function ( name ) {
                        var type = $.type( obj[ name ] );
                        if ( type == "array" || type == "object" ) {
                            defineProperty( obj, name, path + "." + name, context );
                            defineProperties( obj[ name ], path + "." + name, context );
                        }
                        else {
                            defineProperty( obj, name, path + "." + name, context );
                        }
                    } );
                }

                Object.defineProperty( that, index, {
                    configurable: true,
                    enumerable: true,
                    get: function () {
                        return array[ index ];
                    },
                    set: function ( newValue ) {
                        var oldValue = array[ index ];
                        if ( that.toJSON( null, oldValue ) != that.toJSON( null, newValue ) ) {
                            array[ index ] = newValue;
                            if ( typeof notifier === "function" ) {
                                notifier( { object: that, type: 'update', path: index.toString(), index: index, name: "index", newValue: newValue, oldValue: oldValue } );
                            }
                            defineProperties( newValue, index, newValue );
                        }
                    }
                } );
                defineProperties( that[ index ], index, that[ index ] );
            }
        }

        that.push = function () {
            var index;
            for ( var i = 0, ln = arguments.length; i < ln; i++ ) {
                index = array.length;
                array.push( arguments[ i ] );
                that.defineIndexProperty( index );
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'add', name: "length", index: index, newValue: array.length, oldValue: index } );
                }
            }
            return array.length;
        };

        that.pop = function () {
            if ( ~array.length ) {
                var index = array.length - 1,
                    item = array.pop();
                delete that[ index ];
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'delete', name: "length", index: index, newValue: array.length, oldValue: index } );
                }
                return item;
            }
        };

        that.unshift = function () {
            var index = array.length;
            for ( var i = 0, ln = arguments.length; i < ln; i++ ) {
                array.splice( i, 0, arguments[ i ] );
                that.defineIndexProperty( array.length - 1 );
            }
            if ( typeof notifier === "function" ) {
                notifier( { object: that, type: 'add', index: 0, name: "length", newValue: array.length, oldValue: index } );
            }
            return array.length;
        };

        that.shift = function () {
            var index = array.length;
            if ( ~array.length ) {
                var item = array.shift();
                array.length === 0 && delete that[ index ];
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'delete', index: index, name: "length", newValue: array.length, oldValue: index } );
                }
                return item;
            }
        };

        that.slice = function ( start, end, observeFunction ) {
            var newArray = array.slice( start, end );
            var observableArray = new $.jqx.observableArray( newArray, observeFunction );
            return observableArray;
        }

        that.splice = function ( index, howMany, observeFunction ) {
            var removed = [],
                item,
                pos;

            index = !~index ? array.length - index : index;

            howMany = ( howMany == null ? array.length - index : howMany ) || 0;

            while ( howMany-- ) {
                item = array.splice( index, 1 )[ 0 ];
                removed.push( item );
                delete that[ array.length ];
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'delete', index: index, name: "length", newValue: -1, oldValue: index } );
                }
            }

            for ( var i = 2, ln = arguments.length; i < ln; i++ ) {
                array.splice( index, 0, arguments[ i ] );
                this.defineIndexProperty( array.length - 1 );
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'add', index: index, name: "length", newValue: array.length - 1, oldValue: index } );
                }
                index++;
            }

            var observableArray = new $.jqx.observableArray( removed, observeFunction );
            return observableArray;
        };

        Object.defineProperty( that, "length", {
            configurable: false,
            enumerable: true,
            get: function () {
                return array.length;
            },
            set: function ( value ) {
                var n = Number( value );
                if ( n % 1 === 0 && n >= 0 ) {
                    if ( n < array.length ) {
                        that.splice( n );
                    } else if ( n > array.length ) {
                        that.push.apply( that, new Array( n - array.length ) );
                    }
                } else {
                    throw new RangeError( "Invalid array length" );
                }
                return value;
            }
        } );

        $.jqx.observableArray.prototype.fromArray = function ( array, observeFunction ) {
            var observableArray = new $.jqx.observableArray( array, observeFunction );
            return observableArray;
        }

        $.jqx.observableArray.prototype.clone = function () {
            var observableArray = new $.jqx.observableArray( array, observeFunction );
            observableArray.observing = that.observing;
            observableArray.changes = that.changes;
            observableArray.notifier = that.notifier;
            return observableArray;
        }

        that.remove = function ( index ) {
            if ( index < 0 || index >= that.length ) {
                throw new Error( 'Invalid index : ' + index );
            }
            if ( that.hasOwnProperty( index ) ) {
                var oldValue = that[ index ];
                that[ index ] = undefined;
                array[ index ] = undefined;
                if ( typeof notifier === "function" ) {
                    notifier( { object: that, type: 'delete', index: index, name: "index", newValue: undefined, oldValue: oldValue } );
                }
                return true;
            }
            return false;
        };

        that.concat = function ( args, observeFunction ) {
            var newArray = array.concat( args );
            var observableArray = new $.jqx.observableArray( newArray, observeFunction );
            return observableArray;
        };

        Object.getOwnPropertyNames( Array.prototype ).forEach( function ( name ) {
            if ( !( name in that ) ) {
                var fn = function () {
                    var tmp = that.observing;
                    that.observing = false;
                    var arrayFn = array[ name ];
                    var result = arrayFn.apply( array, arguments );
                    that.observing = tmp;
                    return result;
                }
                Object.defineProperty( that, name, {
                    configurable: false,
                    enumerable: true,
                    writeable: false,
                    value: fn
                } );
            }
        } );


        that.set = function ( index, value ) {
            if ( $.type( index ) == "string" && index.split( "." ).length > 1 ) {
                var items = index.split( "." );
                var obj = that;
                for ( var i = 0; i < items.length; i++ ) {
                    if ( i === 0 ) {
                        if ( items[ i ] >= that.length ) {
                            throw new Error( "Invalid Index: " + index );
                        }
                    }
                    if ( i < items.length - 1 ) {
                        obj = obj[ items[ i ] ];
                    }
                    else {
                        obj[ items[ i ] ] = value;
                    }
                }
                return true;
            }
            if ( index >= that.length ) {
                that.push( value );
            }
            else {
                that[ index ] = value;
            }
            return true;
        }

        that.get = function ( index ) {
            return that[ index ];
        }

        if ( items instanceof Array ) {
            that.push.apply( that, items );
        }

        notifier = function () {
            if ( !that.observing ) {
                return;
            }

            if ( arguments && arguments[ 0 ] ) {
                that.changes.push( arguments[ 0 ] );
            }

            if ( observeFunction ) {
                observeFunction.apply( that, arguments );
            }
            if ( that.notifier ) {
                that.notifier.apply( that, arguments );
            }
        }

        return that;
    }

    $.jqx.formatDate = function ( value, format, calendar ) {
        var result = $.jqx.dataFormat.formatdate( value, format, calendar );
        return result;
    }

    $.jqx.formatNumber = function ( value, format, calendar ) {
        var result = $.jqx.dataFormat.formatnumber( value, format, calendar );
        return result;
    }

    $.jqx.dataAdapter = function ( source, options ) {
        if ( source != undefined ) {
            if ( source.dataFields !== undefined ) {
                source.datafields = source.dataFields;
            }
            if ( source.dataType !== undefined ) {
                source.datatype = source.dataType;
            }
            if ( source.localData !== undefined ) {
                source.localdata = source.localData;
            }
            if ( source.sortColumn !== undefined ) {
                source.sortcolumn = source.sortColumn;
            }
            if ( source.sortDirection !== undefined ) {
                source.sortdirection = source.sortDirection;
            }
            if ( source.sortColumns !== undefined ) {
                source.sortcolumns = source.sortColumns;
            }
            if ( source.sortDirections !== undefined ) {
                source.sortdirections = source.sortDirections;
            }
            if ( source.sortOrder !== undefined ) {
                source.sortdirection = source.sortOrder;
            }
            if ( source.formatData !== undefined ) {
                source.formatdata = source.formatData;
            }
            if ( source.processData !== undefined ) {
                source.processdata = source.processData;
            }
            if ( source.pageSize !== undefined ) {
                source.pagesize = source.pageSize;
            }
            if ( source.pageNum !== undefined ) {
                source.pagenum = source.pageNum;
            }
            if ( source.updateRow !== undefined ) {
                source.updaterow = source.updateRow;
            }
            if ( source.addRow !== undefined ) {
                source.addrow = source.addRow;
            }
            if ( source.deleteRow !== undefined ) {
                source.deleterow = source.deleteRow;
            }
            if ( source.contentType !== undefined ) {
                source.contenttype = source.contentType;
            }
            if ( source.totalRecords != undefined ) {
                source.totalrecords = source.totalRecords;
            }
            if ( source.loadError != undefined ) {
                source.loadError = source.loadError;
            }
            if ( source.sortComparer != undefined ) {
                source.sortcomparer = source.sortComparer;
            }
        }

        this._source = source;
        this._options = options || {};
        if ( source.beforeLoadComplete != undefined ) {
            this._options.beforeLoadComplete = this._source.beforeLoadComplete;
        }
        if ( source.downloadComplete != undefined ) {
            this._options.downloadComplete = this._source.downloadComplete;
        }
        if ( source.loadComplete != undefined ) {
            this._options.loadComplete = this._source.loadComplete;
        }
        if ( source.autoBind != undefined ) {
            this._options.downloadComplete = this._source.autoBind;
        }
        if ( source.formatData != undefined ) {
            this._options.formatData = this._source.formatData;
        }
        if ( source.loadError != undefined ) {
            this._options.loadError = this._source.loadError;
        }
        if ( source.beforeSend != undefined ) {
            this._options.beforeSend = this._source.beforeSend;
        }
        if ( source.contentType != undefined ) {
            this._options.contentType = this._source.contentType;
        }
        if ( source.async != undefined ) {
            this._options.async = this._source.async;
        }
        if ( source.loadServerData != undefined ) {
            this._options.loadServerData = this._source.loadServerData;
        }
        if ( source.uniqueDataFields != undefined ) {
            this._options.uniqueDataFields = this._source.uniqueDataFields;
        }

        this.records = new Array();
        this._downloadComplete = new Array();
        this._bindingUpdate = new Array();

        if ( source != undefined && source.localdata != null && typeof source.localdata == "function" ) {
            var localData = source.localdata();
            if ( localData != null ) {
                source._localdata = source.localdata;
                var me = this;
                if ( source._localdata.subscribe ) {
                    me._oldlocaldata = [];
                    source._localdata.subscribe( function ( value ) {
                        var deepClone = function ( objThing ) {
                            if ( $.isArray( objThing ) ) {
                                return $.makeArray( deepClone( $( objThing ) ) );
                            }
                            return $.extend( true, {}, objThing );
                        };
                        if ( me.suspendKO == false || me.suspendKO == undefined || me._oldlocaldata.length == 0 ) {
                            me._oldlocaldata = deepClone( value );
                        }
                    }, source._localdata, 'beforeChange' );

                    source._localdata.subscribe( function ( value ) {
                        if ( me.suspendKO == false || me.suspendKO == undefined ) {
                            var changeType = "";
                            me._oldrecords = me.records;
                            if ( me._oldlocaldata.length == 0 ) {
                                source.localdata = source._localdata();
                            }

                            if ( me._oldlocaldata.length == 0 ) {
                                changeType = 'change';
                            }
                            else {
                                if ( value ) {
                                    if ( me._oldlocaldata.length == value.length ) {
                                        changeType = 'update';
                                    }
                                    if ( me._oldlocaldata.length > value.length ) {
                                        changeType = 'remove';
                                    }
                                    if ( me._oldlocaldata.length < value.length ) {
                                        changeType = 'add';
                                    }
                                }
                            }
                            me.dataBind( null, changeType );
                        }
                    }, source._localdata, 'change' );

                    me._knockoutdatasource = true;
                }

                source.localdata = localData;
            }
        }
        if ( this._options.autoBind == true ) {
            this.dataBind();
        }
    }

    $.jqx.dataAdapter.prototype = {
        getrecords: function () {
            return this.records;
        },

        beginUpdate: function () {
            this.isUpdating = true;
        },

        endUpdate: function ( refresh ) {
            this.isUpdating = false;
            if ( refresh != false ) {
                if ( this._changedrecords && this._changedrecords.length > 0 ) {
                    this.callBindingUpdate( "update" );
                    this._changedrecords = [];
                }
                else {
                    this.dataBind( null, "" );
                }
            }
        },

        formatDate: function ( value, format, calendar ) {
            var result = $.jqx.dataFormat.formatdate( value, format, calendar );
            return result;
        },

        formatNumber: function ( value, format, calendar ) {
            var result = $.jqx.dataFormat.formatnumber( value, format, calendar );
            return result;
        },

        dataBind: function ( objectuniqueId, collectionChanged ) {
            if ( this.isUpdating == true )
                return;

            var source = this._source;
            if ( !source )
                return;

            if ( source.generatedfields ) {
                source.datafields = null;
                source.generatedfields = null;
            }

            $.jqx.dataFormat.datescache = new Array();
            if ( source.dataFields != null ) {
                source.datafields = source.dataFields;
            }

            if ( source.recordstartindex == undefined ) {
                source.recordstartindex = 0;
            }
            if ( source.recordendindex == undefined ) {
                source.recordendindex = 0;
            }
            if ( source.loadallrecords == undefined ) {
                source.loadallrecords = true;
            }
            if ( source.root == undefined ) source.root = '';
            if ( source.record == undefined ) source.record = '';

            if ( source.sort != undefined ) {
                this.sort = source.sort;
            }

            if ( source.filter != undefined ) {
                this.filter = source.filter;
            }
            else this.filter = null;

            if ( source.sortcolumn != undefined ) {
                this.sortcolumn = source.sortcolumn;
            }

            if ( source.sortdirection != undefined ) {
                this.sortdirection = source.sortdirection;
            }
            if ( source.sortcolumns != undefined ) {
                this.sortcolumns = source.sortcolumns;
            }

            if ( source.sortdirections != undefined ) {
                this.sortdirections = source.sortdirections;
            }

            if ( source.sortcomparer != undefined ) {
                this.sortcomparer = source.sortcomparer;
            }

            this.records = new Array();
            var options = this._options || {};
            this.virtualmode = options.virtualmode != undefined ? options.virtualmode : false;
            this.totalrecords = options.totalrecords != undefined ? options.totalrecords : 0;
            this.pageable = options.pageable != undefined ? options.pageable : false;
            this.pagesize = options.pagesize != undefined ? options.pagesize : 0;
            this.pagenum = options.pagenum != undefined ? options.pagenum : 0;
            this.cachedrecords = options.cachedrecords != undefined ? options.cachedrecords : new Array();
            this.originaldata = new Array();
            this.recordids = new Array();
            this.updaterow = options.updaterow != undefined ? options.updaterow : null;
            this.addrow = options.addrow != undefined ? options.addrow : null;
            this.deleterow = options.deleterow != undefined ? options.deleterow : null;
            this.cache = options.cache != undefined ? options.cache : false;
            this.unboundmode = false;
            if ( source.formatdata != undefined ) {
                options.formatData = source.formatdata;
            }
            if ( source.data != undefined ) {
                if ( options.data == undefined ) {
                    options.data = {};
                }
                $.extend( options.data, source.data );
            }

            if ( source.mapChar != undefined ) {
                source.mapchar = source.mapChar;
            }

            if ( source.mapchar != undefined ) {
                this.mapChar = source.mapchar ? source.mapchar : '>';
            }
            else {
                this.mapChar = options.mapChar ? options.mapChar : '>';
            }

            if ( options.unboundmode || source.unboundmode ) {
                this.unboundmode = options.unboundmode || source.unboundmode;
            }

            if ( source.cache != undefined ) {
                this.cache = source.cache;
            }

            if ( this.koSubscriptions ) {
                for ( var subscription = 0; subscription < this.koSubscriptions.length; subscription++ ) {
                    this.koSubscriptions[ subscription ].dispose();
                }
            }
            this.koSubscriptions = new Array();

            if ( this.pagenum < 0 ) {
                this.pagenum = 0;
            }

            var me = this;

            var datatype = source.datatype;

            if ( source.datatype === 'csv' || source.datatype === 'tab' || source.datatype === 'tsv' || source.datatype == 'text' )
                datatype = 'text';

            var async = options.async != undefined ? options.async : true;

            if ( source.async != undefined ) {
                async = source.async;
            }

            if ( datatype === "xlsx" && source.url ) {
                source.localdata = [];
                datatype = "array";
                if ( window.jqxDataSource ) {
                    var data = new window.jqxDataSource( {
                        dataSource: source.url,
                        async: false,
                        dataFields: source.datafields
                    } );
                    data.notify( function () {
                        source.url = null;
                        source.localdata = data.boundSource;
                        source.datatype = "array";
                        me.dataBind();
                    } );
                }
            }

            switch ( datatype ) {
                case "local":
                case "array":
                case "observablearray":
                case "observableArray":
                default:
                    if ( source.localdata == undefined && source.length ) {
                        source.localdata = new Array();
                        for ( var i = 0; i < source.length; i++ ) {
                            source.localdata[ source.localdata.length ] = source[ i ];
                            source[ i ].uid = i;
                        }
                    }
                    if ( source.beforeprocessing && $.isFunction( source.beforeprocessing ) ) {
                        source.beforeprocessing( source.localdata );
                    }

                    var length = source.localdata.length;
                    this.totalrecords = this.virtualmode ? ( source.totalrecords || length ) : length;

                    if ( this.unboundmode ) {
                        this.totalrecords = this.unboundmode ? ( source.totalrecords || length ) : length;
                        var datafieldslength = source.datafields ? source.datafields.length : 0;
                        if ( datafieldslength > 0 ) {
                            for ( var i = 0; i < this.totalrecords; i++ ) {
                                var record = {};
                                for ( var j = 0; j < datafieldslength; j++ ) {
                                    record[ source.datafields[ j ].name ] = "";
                                }
                                record.uid = i;
                                source.localdata[ source.localdata.length ] = record;
                            }
                        }
                    }

                    if ( this.totalrecords == undefined ) {
                        this.totalrecords = 0;
                    }

                    var datafieldslength = source.datafields ? source.datafields.length : 0;
                    var getrecord = function ( record, datafieldslength ) {
                        var datarow = {};
                        for ( var j = 0; j < datafieldslength; j++ ) {
                            var datafield = source.datafields ? source.datafields[ j ] : {};
                            var value = '';
                            if ( undefined == datafield || datafield == null ) {
                                continue;
                            }

                            if ( datafield.map ) {
                                if ( $.isFunction( datafield.map ) ) {
                                    value = datafield.map( record );
                                }
                                else {
                                    var splitMap = datafield.map.split( me.mapChar );
                                    if ( splitMap.length > 0 ) {
                                        var datarecord = record;
                                        for ( var p = 0; p < splitMap.length; p++ ) {
                                            if ( !datarecord ) continue;
                                            datarecord = datarecord[ splitMap[ p ] ];
                                        }
                                        value = datarecord;
                                    }
                                    else {
                                        value = record[ datafield.map ];
                                    }
                                }

                                if ( value != undefined && value != null ) {
                                    value = value.toString();
                                }
                                else {
                                    if ( value == undefined && value != null ) {
                                        value = '';
                                    }
                                }
                            }
                            var isEmptyString = false;
                            // searches by both selectors when necessary.
                            if ( value == '' ) {
                                isEmptyString = true;
                                value = record[ datafield.name ];
                                if ( value != undefined && value != null ) {
                                    if ( source._localdata && value.subscribe ) {
                                        value = value();
                                    }
                                    else {
                                        if ( datafield.type != "array" ) {
                                            if ( datafield.type === 'date' ) {
                                                if ( value && value instanceof Date ) {
                                                    value = value;
                                                }
                                            }
                                            else {
                                                value = value.toString();
                                            }
                                        }
                                    }
                                }
                            }
                            if ( value == "[object Object]" && datafield.map && isEmptyString ) {
                                value = '';
                            }

                            value = me.getvaluebytype( value, datafield );
                            if ( datafield.displayname != undefined ) {
                                datarow[ datafield.displayname ] = value;
                            }
                            else {
                                datarow[ datafield.name ] = value;
                            }
                        }
                        return datarow;
                    }

                    if ( source._localdata ) {
                        this._changedrecords = [];
                        this.records = new Array();
                        var localdata = source._localdata();

                        $.each( localdata, function ( i, value ) {
                            if ( typeof value === 'string' ) {
                                me.records.push( value );
                            }
                            else {
                                var record = {};
                                var _koindex = 0;
                                var dataObject = this;
                                $.each( this, function ( obj, objvalue ) {
                                    var map = null;
                                    var type = 'string';
                                    var dataFieldName = obj;
                                    if ( datafieldslength > 0 ) {
                                        var hasField = false;
                                        var hasMap = false;
                                        for ( var j = 0; j < datafieldslength; j++ ) {
                                            var datafield = source.datafields[ j ];
                                            if ( datafield != undefined && ( datafield.name == obj ) ) {
                                                hasField = true;
                                                map = datafield.map;
                                                type = datafield.type;
                                                dataFieldName = datafield.name;
                                                break;
                                            }
                                            else if ( datafield != undefined && datafield.map && ( datafield.map.indexOf( obj ) >= 0 ) ) {
                                                hasField = true;
                                                map = datafield.map;
                                                type = datafield.type;
                                                dataFieldName = datafield.name;
                                                hasMap = true;
                                                var value = dataObject[ obj ];
                                                if ( map != null ) {
                                                    var splitMap = map.split( me.mapChar );
                                                    if ( splitMap.length > 0 ) {
                                                        var datarecord = dataObject;
                                                        for ( var p = 0; p < splitMap.length; p++ ) {
                                                            datarecord = datarecord[ splitMap[ p ] ];
                                                        }
                                                        value = datarecord;
                                                    }
                                                    else {
                                                        value = dataObject[ map ];
                                                    }
                                                }

                                                if ( type != 'string' ) {
                                                    value = me.getvaluebytype( value, { type: type } );
                                                }
                                                record[ dataFieldName ] = value;
                                                if ( record[ dataFieldName ] != undefined ) {
                                                    _koindex += record[ dataFieldName ].toString().length + record[ dataFieldName ].toString().substr( 0, 1 );
                                                }
                                            }
                                        }
                                        if ( !hasField ) return true;
                                        if ( hasMap ) return true;
                                    }

                                    var isFunction = $.isFunction( dataObject[ obj ] );
                                    if ( isFunction ) {
                                        var value = dataObject[ obj ]();
                                        if ( type != 'string' ) {
                                            value = me.getvaluebytype( value, { type: type } );
                                        }
                                        record[ obj ] = value;
                                        if ( dataObject[ obj ].subscribe ) {
                                            var recordindex = i;
                                            me.koSubscriptions[ me.koSubscriptions.length ] = dataObject[ obj ].subscribe( function ( value ) {
                                                var _changeindex = recordindex;
                                                record[ obj ] = value;
                                                var changedRecord = { index: _changeindex, oldrecord: record, record: record };
                                                me._changedrecords.push( changedRecord );
                                                if ( me.isUpdating )
                                                    return;

                                                me.callBindingUpdate( "update" );
                                                me._changedrecords = [];
                                                return false;
                                            } );
                                        }
                                    }
                                    else {
                                        var value = dataObject[ obj ];
                                        if ( map != null ) {
                                            var splitMap = map.split( me.mapChar );
                                            if ( splitMap.length > 0 ) {
                                                var datarecord = dataObject;
                                                for ( var p = 0; p < splitMap.length; p++ ) {
                                                    datarecord = datarecord[ splitMap[ p ] ];
                                                }
                                                value = datarecord;
                                            }
                                            else {
                                                value = dataObject[ map ];
                                            }
                                        }

                                        if ( type != 'string' ) {
                                            value = me.getvaluebytype( value, { type: type } );
                                        }
                                        record[ dataFieldName ] = value;
                                        if ( record[ dataFieldName ] != undefined ) {
                                            _koindex += record[ dataFieldName ].toString().length + record[ dataFieldName ].toString().substr( 0, 1 );
                                        }
                                    }
                                } );

                                var recordid = me.getid( source.id, dataObject, i );
                                record.uid = recordid;
                                me.records.push( record );

                                record._koindex = _koindex;
                                if ( me._oldrecords ) {
                                    var _changeindex = me.records.length - 1;
                                    if ( collectionChanged == 'update' ) {
                                        if ( me._oldrecords[ _changeindex ]._koindex != _koindex ) {
                                            var changedRecord = { index: _changeindex, oldrecord: me._oldrecords[ _changeindex ], record: record };
                                            me._changedrecords.push( changedRecord );
                                        }
                                    }
                                }
                            }
                        } );
                        if ( collectionChanged == 'add' ) {
                            var length = me.records.length;
                            for ( var i = 0; i < length; i++ ) {
                                var record = me.records[ i ];
                                var hasOldRecord = false;
                                for ( var p = 0; p < me._oldrecords.length; p++ ) {
                                    if ( me._oldrecords[ p ]._koindex === record._koindex ) {
                                        hasOldRecord = true;
                                        break;
                                    }
                                }
                                if ( !hasOldRecord ) {
                                    me._changedrecords.push( { index: i, oldrecord: null, record: record, position: ( i != 0 ? "last" : "first" ) } );
                                }
                            }
                        }
                        else if ( collectionChanged == 'remove' ) {
                            var length = me._oldrecords.length;
                            for ( var i = 0; i < length; i++ ) {
                                var oldrecord = me._oldrecords[ i ];
                                if ( !me.records[ i ] ) {
                                    me._changedrecords.push( { index: i, oldrecord: oldrecord, record: null } );
                                }
                                else {
                                    if ( me.records[ i ]._koindex != oldrecord._koindex ) {
                                        me._changedrecords.push( { index: i, oldrecord: oldrecord, record: null } );
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if ( !$.isArray( source.localdata ) ) {
                            this.records = new Array();
                            var fields = 0;
                            var generatedfields = new Array();
                            $.each( source.localdata, function ( i ) {
                                var recordid = me.getid( source.id, this, i );
                                if ( datafieldslength == 0 ) {
                                    if ( !( typeof this === "string" || this instanceof String ) ) {
                                        for ( var obj in this ) {
                                            fields++;
                                            var valueType = $.type( this[ obj ] );

                                            generatedfields.push( { name: obj, type: valueType } );
                                        }
                                        datafieldslength = fields;
                                        source.datafields = generatedfields;
                                        source.generatedfields = generatedfields;
                                    }
                                }
                                if ( datafieldslength > 0 ) {
                                    var record = this;
                                    var datarow = getrecord( record, datafieldslength );
                                    datarow.uid = recordid;
                                    me.records[ me.records.length ] = datarow;
                                }
                                else {
                                    this.uid = recordid;
                                    me.records[ me.records.length ] = this;
                                }
                            } );
                        }
                        else {
                            if ( datafieldslength == 0 ) {
                                var fields = 0;
                                var generatedfields = new Array();

                                $.each( source.localdata, function ( i, value ) {
                                    //      var record = $.extend({}, this);
                                    var record = new Object( this );
                                    if ( typeof value === "string" ) {
                                        me.records = source.localdata;
                                        return false;
                                    }
                                    else {
                                        var recordid = me.getid( source.id, record, i );
                                        if ( typeof ( recordid ) === "object" ) {
                                            recordid = i;
                                        }
                                        record.uid = recordid;
                                        if ( i == 0 ) {
                                            for ( var obj in this ) {
                                                fields++;
                                                var valueType = $.type( this[ obj ] );

                                                generatedfields.push( { name: obj, type: valueType } );
                                            }
                                            datafieldslength = fields;
                                            source.datafields = generatedfields;
                                            source.generatedfields = generatedfields;
                                        }
                                        if ( datafieldslength > 0 ) {
                                            var datarow = getrecord( record, datafieldslength );
                                            datarow.uid = recordid;
                                            me.records[ me.records.length ] = datarow;
                                        }
                                        else {
                                            me.records[ me.records.length ] = record;
                                        }
                                    }
                                } );
                            }
                            else {
                                $.each( source.localdata, function ( i ) {
                                    var record = this;
                                    var datarow = getrecord( record, datafieldslength );
                                    var recordid = me.getid( source.id, datarow, i );
                                    if ( typeof ( recordid ) === "object" ) {
                                        recordid = i;
                                    }
                                    //      var record = $.extend({}, datarow);
                                    var record = new Object( datarow );
                                    record.uid = recordid;
                                    me.records[ me.records.length ] = record;
                                } );
                            }
                        }
                    }

                    this.originaldata = source.localdata;
                    this.cachedrecords = this.records;
                    this.addForeignValues( source );
                    if ( options.uniqueDataFields ) {
                        var uniquerecords = this.getUniqueRecords( this.records, options.uniqueDataFields );
                        this.records = uniquerecords;
                        this.cachedrecords = uniquerecords;
                    }

                    if ( options.beforeLoadComplete ) {
                        var newRecords = options.beforeLoadComplete( me.records, this.originaldata );
                        if ( newRecords != undefined ) {
                            me.records = newRecords;
                            me.cachedrecords = newRecords;
                        }
                    }

                    if ( options.autoSort && options.autoSortField ) {
                        var tmpToString = Object.prototype.toString;
                        Object.prototype.toString = ( typeof field == "function" ) ? field : function () { return this[ options.autoSortField ] };
                        me.records.sort( function ( value1, value2 ) {
                            if ( value1 === undefined ) { value1 = null; }
                            if ( value2 === undefined ) { value2 = null; }
                            if ( value1 === null && value2 === null ) {
                                return 0;
                            }
                            if ( value1 === null && value2 !== null ) {
                                return 1;
                            }
                            if ( value1 !== null && value2 === null ) {
                                return -1;
                            }

                            value1 = value1.toString();
                            value2 = value2.toString();
                            if ( value1 === null && value2 === null ) {
                                return 0;
                            }
                            if ( value1 === null && value2 !== null ) {
                                return 1;
                            }
                            if ( value1 !== null && value2 === null ) {
                                return -1;
                            }
                            if ( $.jqx.dataFormat.isNumber( value1 ) && $.jqx.dataFormat.isNumber( value2 ) ) {
                                if ( value1 < value2 ) { return -1; }
                                if ( value1 > value2 ) { return 1; }
                                return 0;
                            }
                            else if ( $.jqx.dataFormat.isDate( value1 ) && $.jqx.dataFormat.isDate( value2 ) ) {
                                if ( value1 < value2 ) { return -1; }
                                if ( value1 > value2 ) { return 1; }
                                return 0;
                            }
                            else if ( !$.jqx.dataFormat.isNumber( value1 ) && !$.jqx.dataFormat.isNumber( value2 ) ) {
                                value1 = String( value1 ).toLowerCase();
                                value2 = String( value2 ).toLowerCase();
                            }

                            try {
                                if ( value1 < value2 ) { return -1; }
                                if ( value1 > value2 ) { return 1; }
                            }
                            catch ( error ) {
                                var er = error;
                            }

                            return 0;
                        } );
                        Object.prototype.toString = tmpToString;
                    }

                    me.loadedData = source.localdata;
                    me.buildHierarchy();

                    if ( $.isFunction( options.loadComplete ) ) {
                        options.loadComplete( source.localdata, me.records );
                    }
                    break;
                case "json":
                case "jsonp":
                case "xml":
                case "xhtml":
                case "script":
                case "text":
                case "ics":
                    {
                        if ( source.localdata != null && !source.url ) {
                            if ( $.isFunction( source.beforeprocessing ) ) {
                                source.beforeprocessing( source.localdata );
                            }
                            if ( source.datatype === "xml" ) {
                                me.loadxml( source.localdata, source.localdata, source );
                            }
                            else if ( datatype === "text" ) {
                                me.loadtext( source.localdata, source );
                            }
                            else if ( datatype === "ics" ) {
                                me.loadics( source.localdata, source );
                            }
                            else {
                                me.loadjson( source.localdata, source.localdata, source );
                            }
                            me.addForeignValues( source );
                            if ( options.uniqueDataFields ) {
                                var uniquerecords = me.getUniqueRecords( me.records, options.uniqueDataFields );
                                me.records = uniquerecords;
                                me.cachedrecords = uniquerecords;
                            }

                            if ( options.beforeLoadComplete ) {
                                var newRecords = options.beforeLoadComplete( me.records, this.originaldata );
                                if ( newRecords != undefined ) {
                                    me.records = newRecords;
                                    me.cachedrecords = newRecords;
                                }
                            }

                            me.loadedData = source.localdata;
                            me.buildHierarchy.call( me );
                            if ( $.isFunction( options.loadComplete ) ) {
                                options.loadComplete( source.localdata, me.records );
                            }
                            me.callBindingUpdate( collectionChanged );
                            return;
                        }

                        var postdata = options.data != undefined ? options.data : {};
                        // call the source object's processdata function.
                        if ( source.processdata ) {
                            source.processdata( postdata );
                        }
                        // call the adapter's process data function.
                        if ( $.isFunction( options.processData ) ) {
                            options.processData( postdata );
                        }

                        // call the adapter's format data function.
                        if ( $.isFunction( options.formatData ) ) {
                            var newpostdata = options.formatData( postdata );
                            if ( newpostdata != undefined ) {
                                postdata = newpostdata;
                            }
                        }

                        var contentType = 'application/x-www-form-urlencoded';
                        if ( options.contentType ) {
                            contentType = options.contentType;
                        }

                        var type = "GET";
                        if ( source.type ) {
                            type = source.type;
                        }

                        if ( options.type ) {
                            type = options.type;
                        }

                        var dataType = datatype;
                        if ( datatype == "ics" ) dataType = "text";
                        if ( source.url && source.url.length > 0 ) {
                            if ( $.isFunction( options.loadServerData ) ) {
                                me._requestData( postdata, source, options );
                            }
                            else {
                                this.xhr = $.jqx.data.ajax( {
                                    dataType: dataType,
                                    cache: this.cache,
                                    type: type,
                                    url: source.url,
                                    async: async,
                                    timeout: source.timeout,
                                    contentType: contentType,
                                    data: postdata,
                                    success: function ( data, status, xhr ) {
                                        if ( $.isFunction( source.beforeprocessing ) ) {
                                            var tmpdata = source.beforeprocessing( data, status, xhr );
                                            if ( tmpdata != undefined ) {
                                                data = tmpdata;
                                            }
                                        }
                                        if ( $.isFunction( options.downloadComplete ) ) {
                                            var tmpdata = options.downloadComplete( data, status, xhr );
                                            if ( tmpdata != undefined ) {
                                                data = tmpdata;
                                            }
                                        }

                                        if ( data == null ) {
                                            me.records = new Array();
                                            me.cachedrecords = new Array();
                                            me.originaldata = new Array();

                                            me.callDownloadComplete();
                                            if ( $.isFunction( options.loadComplete ) ) {
                                                options.loadComplete( new Array() );
                                            }
                                            return;
                                        }

                                        var records = data;
                                        if ( data.records ) {
                                            records = data.records;
                                        }

                                        if ( data.totalrecords != undefined ) {
                                            source.totalrecords = data.totalrecords;
                                        }
                                        else if ( data.totalRecords != undefined ) {
                                            source.totalrecords = data.totalRecords;
                                        }

                                        if ( source.datatype === "xml" ) {
                                            me.loadxml( null, records, source );
                                        }
                                        else if ( datatype === "text" ) {
                                            me.loadtext( records, source );
                                        }
                                        else if ( datatype === "ics" ) {
                                            me.loadics( records, source );
                                        }
                                        else {
                                            me.loadjson( null, records, source );
                                        }

                                        // add foreign values.
                                        me.addForeignValues( source );

                                        if ( options.uniqueDataFields ) {
                                            var uniquerecords = me.getUniqueRecords( me.records, options.uniqueDataFields );
                                            me.records = uniquerecords;
                                            me.cachedrecords = uniquerecords;
                                        }

                                        if ( options.beforeLoadComplete ) {
                                            var newRecords = options.beforeLoadComplete( me.records, data );
                                            if ( newRecords != undefined ) {
                                                me.records = newRecords;
                                                me.cachedrecords = newRecords;
                                            }
                                        }

                                        me.loadedData = data;
                                        me.buildHierarchy.call( me );

                                        me.callDownloadComplete();
                                        if ( $.isFunction( options.loadComplete ) ) {
                                            options.loadComplete( data, status, xhr, me.records );
                                        }
                                    },
                                    error: function ( xhr, status, error ) {
                                        if ( $.isFunction( source.loaderror ) ) { source.loaderror( xhr, status, error ); }
                                        if ( $.isFunction( options.loadError ) ) { options.loadError( xhr, status, error ); }
                                        xhr = null;
                                        me.callDownloadComplete();
                                    },
                                    beforeSend: function ( xhr, settings ) {
                                        if ( $.isFunction( options.beforeSend ) ) { options.beforeSend( xhr, settings ); }
                                        if ( $.isFunction( source.beforesend ) ) { source.beforesend( xhr, settings ); }
                                    }
                                } );
                            }
                        }
                        else {
                            me.buildHierarchy( new Array() );
                            me.callDownloadComplete();
                            if ( $.isFunction( options.loadComplete ) ) {
                                if ( !data ) {
                                    var data = {};
                                }
                                options.loadComplete( data );
                            }
                        }
                    }
                    break;
            }
            this.callBindingUpdate( collectionChanged );
        },

        buildHierarchy: function ( dataRecords ) {
            var source = this._source;
            var hierarchy = new Array();
            if ( !source.datafields ) {
                return;
            }

            if ( source.hierarchy && !source.hierarchy.reservedNames ) {
                source.hierarchy.reservedNames = {
                    leaf: "leaf",
                    parent: "parent",
                    expanded: "expanded",
                    checked: "checked",
                    selected: "selected",
                    level: "level",
                    icon: "icon",
                    data: "data"
                }
            }
            else {
                if ( source.hierarchy ) {
                    var names = source.hierarchy.reservedNames;
                    if ( !names.leaf ) names.leaf = "leaf";
                    if ( !names.parent ) names.parent = "parent";
                    if ( !names.expanded ) names.expanded = "expanded";
                    if ( !names.checked ) names.checked = "checked";
                    if ( !names.selected ) names.selected = "selected";
                    if ( !names.level ) names.level = "level";
                    if ( !names.data ) names.data = "data";
                }
            }

            if ( !source.hierarchy ) {
                return;
            }

            var that = this;
            var names = source.hierarchy.reservedNames;
            if ( source.hierarchy.root ) {
                if ( source.dataType == "xml" ) {
                    var hierarchy = this.getRecordsHierarchy( 'uid', 'parentuid', 'records', null, dataRecords );
                    this.hierarchy = hierarchy;
                    return hierarchy;
                }
                else {
                    this.hierarchy = this.records;
                    var root = source.hierarchy.root;
                    for ( var i = 0; i < this.records.length; i++ ) {
                        var record = this.records[ i ];
                        if ( !record ) {
                            continue;
                        }

                        var addRecords = function ( record ) {
                            if ( source.hierarchy.record ) {
                                record.records = record[ root ][ source.hierarchy.record ];
                            }
                            else {
                                var splitMap = root.split( that.mapChar );
                                var records = null;
                                if ( splitMap.length > 1 ) {
                                    var d = record;
                                    for ( var p = 0; p < splitMap.length; p++ ) {
                                        if ( d != undefined ) {
                                            d = d[ splitMap[ p ] ];
                                        }
                                    }
                                    records = d;
                                }
                                else records = record[ root ];
                                record.records = records;
                            }
                            if ( record.records == null || ( record.records && record.records.length == 0 ) ) {
                                record[ names.leaf ] = true;
                            }
                        }
                        addRecords( record );
                        record[ names.level ] = 0;
                        var recordid = this.getid( source.id, record, i );
                        record.uid = recordid;
                        record[ names.parent ] = null;
                        record[ names.data ] = record;
                        if ( record[ names.expanded ] === undefined ) {
                            record[ names.expanded ] = false;
                        }
                        var drillThrough = function ( parent, records ) {
                            if ( !records ) {
                                parent.records = new Array();
                                return;
                            }

                            for ( var i = 0; i < records.length; i++ ) {
                                var record = records[ i ];
                                if ( !record ) {
                                    continue;
                                }

                                addRecords( record );
                                record[ names.level ] = parent[ names.level ] + 1;
                                record[ names.parent ] = parent;
                                record[ names.data ] = record;
                                var recordid = that.getid( source.id, record, i );
                                if ( recordid == i && source.id == null ) {
                                    record.uid = parent.uid + "_" + recordid;
                                }
                                else {
                                    record.uid = recordid;
                                }

                                if ( record[ names.expanded ] === undefined ) {
                                    record[ names.expanded ] = false;
                                }
                                drillThrough( record, record.records );
                            }
                        }
                        drillThrough( record, record.records );
                    }
                }
                return this.hierarchy;
            }

            if ( source.hierarchy.keyDataField && source.hierarchy.parentDataField ) {
                var hierarchy = this.getRecordsHierarchy( source.hierarchy.keyDataField.name, source.hierarchy.parentDataField.name, 'records', null, dataRecords );
                this.hierarchy = hierarchy;
                return hierarchy;
            }

            if ( source.hierarchy.groupingDataFields ) {
                var groups = new Array();
                for ( var i = 0; i < source.hierarchy.groupingDataFields.length; i++ ) {
                    groups.push( source.hierarchy.groupingDataFields[ i ].name );
                }

                var hierarchy = this.getGroupedRecords( groups, 'records', 'label', null, 'data', null, 'parent', dataRecords );
                this.hierarchy = hierarchy;
                return hierarchy;
            }
        },

        addRecord: function ( record, position, parentID, virtualMode ) {
            var that = this;
            var reservedNames = function () {
                return {
                    leaf: "leaf",
                    parent: "parent",
                    expanded: "expanded",
                    checked: "checked",
                    selected: "selected",
                    level: "level",
                    icon: "icon",
                    data: "data"
                }
            }
            if ( record != undefined ) {
                if ( parentID != undefined ) {
                    if ( this.hierarchy.length > 0 ) {
                        var traverse = function ( records ) {
                            if ( records ) {
                                for ( var i = 0; i < records.length; i++ ) {
                                    var r = records[ i ];
                                    if ( r.uid == parentID ) {
                                        var names = ( that._source && that._source.hierarchy ) ? that._source.hierarchy.reservedNames : null;
                                        if ( names == null ) names = reservedNames();

                                        record[ names.parent ] = r;
                                        record[ names.level ] = r[ names.level ] + 1;

                                        if ( !r.records ) {
                                            r.records = new Array();
                                            r[ names.leaf ] = false;
                                        }
                                        else {
                                            r[ names.leaf ] = false;
                                        }

                                        if ( position == 'last' ) {
                                            r.records.push( record );
                                        }
                                        else if ( typeof position === 'number' && isFinite( position ) ) {
                                            r.records.splice( position, 0, record );
                                        }
                                        else {
                                            r.records.splice( 0, 0, record );
                                        }
                                        return true;
                                    }
                                    if ( r.records ) {
                                        traverse( r.records );
                                    }
                                }
                            }
                        }
                        traverse( this.hierarchy );
                    }
                }
                else {
                    if ( this.hierarchy && this.hierarchy.length >= 0 && ( this._source.hierarchy || virtualMode ) ) {
                        var names = ( that._source && that._source.hierarchy ) ? that._source.hierarchy.reservedNames : null;
                        if ( names == null ) names = reservedNames();

                        record[ names.level ] = 0;

                        if ( position == 'last' ) {
                            this.hierarchy.push( record );
                        }
                        else if ( typeof position === 'number' && isFinite( position ) ) {
                            this.hierarchy.splice( position, 0, record );
                        }
                        else {
                            this.hierarchy.splice( 0, 0, record );
                        }
                    }
                    else {
                        if ( position == 'last' ) {
                            this.records.push( record );
                        }
                        else if ( typeof position === 'number' && isFinite( position ) ) {
                            this.records.splice( position, 0, record );
                        }
                        else {
                            this.records.splice( 0, 0, record );
                        }
                    }
                    return true;
                }
            }
            return false;
        },

        deleteRecord: function ( uid ) {
            var that = this;
            if ( this.hierarchy.length > 0 ) {
                var traverse = function ( records ) {
                    if ( records ) {
                        for ( var i = 0; i < records.length; i++ ) {
                            var r = records[ i ];
                            if ( r.uid == uid ) {
                                records.splice( i, 1 );
                                if ( that.recordids[ uid ] ) {
                                    delete that.recordids[ uid ];
                                }

                                var removeChildren = function ( children ) {
                                    for ( var x = 0; x < children.length; x++ ) {
                                        var uid = children[ x ].uid;
                                        for ( var j = 0; j < that.records.length; j++ ) {
                                            var r = that.records[ j ];
                                            if ( r.uid == uid ) {
                                                that.records.splice( j, 1 );
                                                break;
                                            }
                                        }
                                        if ( children[ x ].records ) {
                                            removeChildren( children[ x ].records );
                                        }
                                    }
                                }
                                if ( r.records ) {
                                    removeChildren( r.records );
                                }
                                for ( var j = 0; j < that.records.length; j++ ) {
                                    var r = that.records[ j ];
                                    if ( r.uid == uid ) {
                                        that.records.splice( j, 1 );
                                        break;
                                    }
                                }
                                return true;
                            }
                            if ( r.records ) {
                                traverse( r.records );
                            }
                        }
                    }
                }
                traverse( this.hierarchy );
            }
            else {
                for ( var i = 0; i < this.records.length; i++ ) {
                    var r = this.records[ i ];
                    if ( r.uid == uid ) {
                        this.records.splice( i, 1 );
                        return true;
                    }
                }
            }
            return false;
        },

        addForeignValues: function ( source ) {
            var me = this;
            var datafieldslength = source.datafields ? source.datafields.length : 0;
            for ( var j = 0; j < datafieldslength; j++ ) {
                var datafield = source.datafields[ j ];
                if ( datafield != undefined ) {
                    if ( datafield.values != undefined ) {
                        if ( datafield.value == undefined ) datafield.value = datafield.name;
                        if ( datafield.values[ 'value' ] == undefined ) {
                            datafield.values[ 'value' ] = datafield.value;
                        }

                        var matchedIDs = new Array();
                        var start, end;
                        if ( me.pageable && me.virtualmode ) {
                            start = me.pagenum * me.pagesize;
                            end = start + me.pagesize;
                            if ( end > me.totalrecords ) {
                                end = me.totalrecords;
                            }
                        }
                        else if ( me.virtualmode ) {
                            start = source.recordstartindex;
                            end = source.recordendindex;
                            if ( end > me.totalrecords ) {
                                end = me.totalrecords;
                            }
                        }
                        else {
                            start = 0;
                            end = me.records.length;
                        }

                        for ( var i = start; i < end; i++ ) {
                            var record = me.records[ i ];
                            var name = datafield.name;
                            var value = record[ datafield.value ];

                            if ( matchedIDs[ value ] != undefined ) {
                                record[ name ] = matchedIDs[ value ];
                            }
                            else {
                                for ( var p = 0; p < datafield[ 'values' ].source.length; p++ ) {
                                    var sourcerecord = datafield.values.source[ p ];
                                    var sourcevalue = sourcerecord[ datafield.values[ 'value' ] ];
                                    if ( sourcevalue == undefined ) {
                                        sourcevalue = sourcerecord.uid;
                                    }
                                    if ( sourcevalue == value ) {
                                        var label = sourcerecord[ datafield.values[ 'name' ] ];
                                        record[ name ] = label;
                                        matchedIDs[ value ] = label;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    else if ( datafield.value != undefined ) {
                        for ( var i = 0; i < me.records.length; i++ ) {
                            var record = me.records[ i ];
                            record[ datafield.name ] = record[ datafield.value ];
                        }
                    }
                }
            }
        },

        abort: function () {
            if ( this.xhr && this.xhr.readyState != 4 ) {
                this.xhr.abort();
                this.callDownloadComplete();
            }
        },

        _requestData: function ( postdata, source, options ) {
            var me = this;
            var success = function ( requestedData ) {
                if ( requestedData.totalrecords ) {
                    source.totalrecords = requestedData.totalrecords;
                    me.totalrecords = requestedData.totalrecords;
                }
                if ( requestedData.records ) {
                    me.records = requestedData.records;
                    me.cachedrecords = requestedData.records;
                }
                // add foreign values.
                me.addForeignValues( source );

                if ( options.uniqueDataFields ) {
                    var uniquerecords = me.getUniqueRecords( me.records, options.uniqueDataFields );
                    me.records = uniquerecords;
                    me.cachedrecords = uniquerecords;
                }

                if ( options.beforeLoadComplete ) {
                    var newRecords = options.beforeLoadComplete( me.records, requestedData );
                    if ( newRecords != undefined ) {
                        me.records = newRecords;
                        me.cachedrecords = newRecords;
                    }
                }
                for ( var i = 0; i < me.records.length; i++ ) {
                    var record = me.records[ i ];
                    if ( undefined == record ) {
                        continue;
                    }

                    if ( undefined == record.uid ) {
                        record.uid = me.getid( source.id, record, i );
                    }
                }

                me.buildHierarchy.call( me );
                if ( $.isFunction( options.loadComplete ) ) {
                    options.loadComplete( requestedData );
                }
                me.callDownloadComplete();
            }
            options.loadServerData( postdata, source, success );
        },

        getUniqueRecords: function ( records, dataFields ) {
            if ( records && dataFields ) {
                var length = records.length;
                var datafieldslength = dataFields.length;

                var uniqueRecords = new Array();
                var lookupkeys = new Array();
                // loop through all records.
                for ( var urec = 0; urec < length; urec++ ) {
                    var datarow = records[ urec ];
                    var lookupkey = "";
                    if ( datarow == undefined )
                        continue;
                    // build lookup key from the datafield values.
                    for ( var datafieldindex = 0; datafieldindex < datafieldslength; datafieldindex++ ) {
                        var datafield = dataFields[ datafieldindex ];
                        if ( datarow[ datafield ] !== undefined ) {
                            lookupkey += datarow[ datafield ] + "_";
                        }
                    }
                    // add the unique record.
                    if ( !lookupkeys[ lookupkey ] && lookupkey ) {
                        uniqueRecords[ uniqueRecords.length ] = datarow;
                    }
                    // add the lookup key.
                    lookupkeys[ lookupkey ] = true;
                }
            }

            return uniqueRecords;
        },

        getAggregatedData: function ( aggregates, calendar, records, level ) {
            var dataRecords = records;
            if ( !dataRecords ) {
                dataRecords = this.records;
            }
            var data = {};
            var dataValuesByAggregate = new Array();
            var length = dataRecords.length;
            if ( length == 0 ) return;
            if ( length == undefined ) return;
            for ( var i = 0; i < length; i++ ) {
                var record = dataRecords[ i ];
                for ( var j = 0; j < aggregates.length; j++ ) {
                    var aggregate = aggregates[ j ];
                    var value = record[ aggregate.name ];
                    //            if (value === null) continue;
                    if ( aggregate.aggregates ) {
                        data[ aggregate.name ] = data[ aggregate.name ] || {};
                        dataValuesByAggregate[ aggregate.name ] = dataValuesByAggregate[ aggregate.name ] || 0;
                        dataValuesByAggregate[ aggregate.name ]++;
                        var _customCalcFunc = function ( aggObject ) {
                            for ( var obj in aggObject ) {
                                var oldValue = data[ aggregate.name ][ obj ];
                                if ( oldValue == null ) {
                                    data[ aggregate.name ][ obj ] = 0;
                                    oldValue = 0;
                                }
                                if ( $.isFunction( aggObject[ obj ] ) ) {
                                    oldValue = aggObject[ obj ]( oldValue, value, aggregate.name, record, level );
                                }
                                data[ aggregate.name ][ obj ] = oldValue;
                            }
                        }

                        var canParse = parseFloat( value );
                        if ( isNaN( canParse ) ) canParse = false; else canParse = true;
                        if ( canParse )
                            value = parseFloat( value );

                        if ( typeof value === 'number' && isFinite( value ) ) {
                            $.each( aggregate.aggregates, function () {
                                var oldValue = data[ aggregate.name ][ this ];
                                if ( oldValue == null ) {
                                    oldValue = 0;
                                    if ( this == 'min' ) oldValue = 9999999999999;
                                    if ( this == 'max' ) oldValue = -9999999999999;
                                }
                                if ( this == 'sum' || this == 'avg' || this == 'stdev'
                                    || this == 'stdevp' || this == 'var' || this == 'varp' ) {
                                    oldValue += parseFloat( value );
                                }
                                else if ( this == 'product' ) {
                                    if ( i == 0 )
                                        oldValue = parseFloat( value );
                                    else
                                        oldValue *= parseFloat( value );
                                }
                                else if ( this == 'min' ) {
                                    oldValue = Math.min( oldValue, parseFloat( value ) );
                                }
                                else if ( this == 'max' ) {
                                    oldValue = Math.max( oldValue, parseFloat( value ) );
                                }
                                else if ( this == 'count' ) {
                                    oldValue++;
                                }
                                else if ( typeof ( this ) == 'object' ) {
                                    _customCalcFunc( this );
                                    return;
                                }
                                data[ aggregate.name ][ this ] = oldValue;
                            } );
                        }
                        else {
                            $.each( aggregate.aggregates, function () {
                                if ( this == 'min' || this == 'max' || this == 'count' || this == 'product' || this == 'sum'
                                    || this == 'avg' || this == 'stdev'
                                    || this == 'stdevp' || this == 'var' || this == 'varp' ) {
                                    if ( value === null ) return true;

                                    var oldValue = data[ aggregate.name ][ this ];
                                    if ( oldValue == null ) {
                                        oldValue = 0;
                                    }
                                    data[ aggregate.name ][ this ] = oldValue;
                                    return true;
                                }

                                if ( typeof ( this ) == 'object' ) {
                                    _customCalcFunc( this );
                                }
                            } );
                        }
                    }
                }
            }

            for ( var j = 0; j < aggregates.length; j++ ) {
                var aggregate = aggregates[ j ];
                if ( !data[ aggregate.name ] ) {
                    data[ aggregate.name ] = {};
                    $.each( aggregate.aggregates, function ( index ) {
                        data[ aggregate.name ][ this ] = 0;
                    } );
                }

                if ( data[ aggregate.name ][ 'avg' ] != undefined ) {
                    var value = data[ aggregate.name ][ 'avg' ];
                    var dataValues = dataValuesByAggregate[ aggregate.name ];
                    if ( dataValues === 0 || dataValues == undefined ) {
                        data[ aggregate.name ][ 'avg' ] = 0;
                    }
                    else {
                        data[ aggregate.name ][ 'avg' ] = value / dataValues;
                    }
                }
                else if ( data[ aggregate.name ][ 'count' ] != undefined ) {
                    data[ aggregate.name ][ 'count' ] = length;
                }

                // stdev, stdevp, var, varp.
                // stdev - Standard deviation on a sample.
                // varp - Variance on an entire population.
                // var - Variance on a sample.
                if ( data[ aggregate.name ][ 'stdev' ] || data[ aggregate.name ][ 'stdevp' ]
                    || data[ aggregate.name ][ 'var' ] || data[ aggregate.name ][ 'varp' ] ) {
                    $.each( aggregate.aggregates, function ( index ) {
                        if ( this == 'stdev' || this == 'var' || this == 'varp' || this == 'stdevp' ) {
                            var value = data[ aggregate.name ][ this ];
                            var count = length;
                            var average = ( value / length );
                            var sumSq = 0.0;
                            for ( var i = 0; i < length; i++ ) {
                                var record = dataRecords[ i ];
                                var recordvalue = record[ aggregate.name ];
                                sumSq += ( recordvalue - average ) * ( recordvalue - average );
                            }

                            var denominator = ( this == 'stdevp' || this == 'varp' ) ? count : count - 1;
                            if ( denominator == 0 )
                                denominator = 1;

                            if ( this == 'var' || this == 'varp' ) {
                                data[ aggregate.name ][ this ] = sumSq / denominator;
                            }
                            else if ( this == 'stdevp' || this == 'stdev' ) {
                                data[ aggregate.name ][ this ] = Math.sqrt( sumSq / denominator );
                            }
                        }
                    } );
                }

                if ( aggregate.formatStrings ) {
                    $.each( aggregate.aggregates, function ( index ) {
                        var formatString = aggregate.formatStrings[ index ];
                        if ( formatString ) {
                            if ( this == 'min' || this == 'max' || this == 'count' || this == 'product' || this == 'sum'
                                || this == 'avg' || this == 'stdev'
                                || this == 'stdevp' || this == 'var' || this == 'varp' ) {
                                var value = data[ aggregate.name ][ this ];
                                data[ aggregate.name ][ this ] = $.jqx.dataFormat.formatnumber( value, formatString, calendar );
                            }
                            else if ( typeof this == 'object' ) {
                                for ( var obj in this ) {
                                    var value = data[ aggregate.name ][ obj ];
                                    data[ aggregate.name ][ obj ] = $.jqx.dataFormat.formatnumber( value, formatString, calendar );
                                }
                            }
                        }
                    } );
                }
            }
            return data;
        },

        bindDownloadComplete: function ( id, func ) {
            this._downloadComplete[ this._downloadComplete.length ] = { id: id, func: func };

        },

        unbindDownloadComplete: function ( id ) {
            for ( var i = 0; i < this._downloadComplete.length; i++ ) {
                if ( this._downloadComplete[ i ].id == id ) {
                    this._downloadComplete[ i ].func = null;
                    this._downloadComplete.splice( i, 1 );
                    break;
                }
            }
        },

        callDownloadComplete: function () {
            for ( var complete = 0; complete < this._downloadComplete.length; complete++ ) {
                var downloadComplete = this._downloadComplete[ complete ];
                if ( downloadComplete.func != null ) {
                    downloadComplete.func();
                }
            }
        },

        setSource: function ( source ) {
            this._source = source;
        },

        generatekey: function () {
            var S4 = function () {
                return ( ( ( 1 + Math.random() ) * 0x10000 ) | 0 ).toString( 16 ).substring( 1 );
            };
            return ( S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4() );
        },

        getGroupedRecords: function ( groups, collectionName, groupName, mappingFields, recordName, valueName, parentName, data, startIndex ) {
            var visualRows = 0;
            var self = this;
            if ( !startIndex ) startIndex = 0;
            var groupHashCodes = new Array();
            for ( var iGroupColumn = 0; iGroupColumn < groups.length; iGroupColumn++ ) {
                groupHashCodes[ iGroupColumn ] = self.generatekey();
            }

            if ( !collectionName ) {
                collectionName = 'items';
            }

            if ( !groupName ) {
                groupName = 'group';
            }

            if ( !recordName ) {
                recordName = 'record';
            }

            if ( !parentName ) {
                parentName = 'parentItem';
            }

            if ( undefined === valueName ) {
                valueName = 'value';
            }

            var grouprecords = new Array();
            var grouprecordsindex = 0;
            var hashRowGroups = new Array();
            var groupslength = groups.length;
            var groupsHierarchy = new Array();
            if ( !data ) {
                var data = this.records;
            }

            var dataLength = data.length;

            var itemByRecord = function ( record ) {
                var itemObj = record;
                if ( mappingFields ) {
                    $.each( mappingFields, function () {
                        if ( this.name && this.map ) {
                            itemObj[ this.map ] = itemObj[ this.name ];
                        }
                    } );
                }

                return itemObj;
            }

            for ( var obj = 0; obj < dataLength; obj++ ) {
                var item = itemByRecord( data[ obj ] );
                var id = item[ self.uniqueId ];
                var itemKeysHierarchy = new Array();
                var keys = 0;
                for ( iGroupColumn = 0; iGroupColumn < groupslength; iGroupColumn++ ) {
                    var group = groups[ iGroupColumn ];
                    var value = item[ group ];

                    if ( null == value )
                        continue;

                    itemKeysHierarchy[ keys++ ] = { value: value, hash: groupHashCodes[ iGroupColumn ] };
                }

                if ( itemKeysHierarchy.length != groupslength )
                    break;

                var parentItem = null;

                var lookupKey = "";
                var iLevel = -1;
                for ( var q = 0; q < itemKeysHierarchy.length; q++ ) {
                    iLevel++;
                    var itemKey = itemKeysHierarchy[ q ].value;
                    var columnHash = itemKeysHierarchy[ q ].hash;
                    lookupKey = lookupKey + "_" + columnHash + "_" + itemKey;
                    if ( hashRowGroups[ lookupKey ] != undefined && hashRowGroups[ lookupKey ] != null ) {
                        parentItem = hashRowGroups[ lookupKey ];
                        continue;
                    }
                    if ( parentItem == null ) {
                        parentItem = { level: 0 };
                        parentItem[ parentName ] = null;
                        parentItem[ groupName ] = itemKey;
                        parentItem[ recordName ] = item;
                        if ( item.expanded !== undefined ) {
                            parentItem.expanded = item.expanded;
                        }
                        else {
                            parentItem.expanded = false;
                        }

                        if ( valueName ) {
                            parentItem[ valueName ] = item[ valueName ];
                        }
                        parentItem[ collectionName ] = new Array();
                        var uid = grouprecords.length + startIndex;
                        if ( !this._source.id || typeof item.uid === "number" || isFinite( item.uid ) ) {
                            uid = "Row" + uid;
                        }
                        parentItem.uid = uid;
                        grouprecords[ grouprecordsindex++ ] = parentItem;
                    }
                    else {
                        var subItem = { level: parentItem.level + 1 };
                        subItem[ parentName ] = parentItem;
                        subItem[ groupName ] = itemKey;
                        subItem[ collectionName ] = new Array();
                        subItem[ recordName ] = item;
                        if ( item.expanded !== undefined ) {
                            subItem.expanded = item.expanded;
                        }
                        else {
                            subItem.expanded = false;
                        }

                        if ( valueName ) {
                            subItem[ valueName ] = item[ valueName ];
                        }
                        subItem.uid = parentItem.uid + "_" + parentItem[ collectionName ].length;
                        parentItem[ collectionName ][ parentItem[ collectionName ].length ] = subItem;
                        parentItem = subItem;
                    }

                    hashRowGroups[ lookupKey ] = parentItem;
                }

                if ( item ) {
                    item.leaf = true;
                }

                if ( parentItem != null ) {
                    if ( this._source.id == null ) {
                        if ( undefined == item.uid ) {
                            item.uid = parentItem.uid + "_" + parentItem[ collectionName ].length;
                        }
                        else {
                            if ( item.uid.toString().indexOf( parentItem.uid ) == -1 ) {
                                item.uid = parentItem.uid + "_" + item.uid;
                            }
                        }
                    }
                    item[ parentName ] = parentItem;
                    item.level = parentItem.level + 1;
                    parentItem[ collectionName ][ parentItem[ collectionName ].length ] = item;
                }
                else {
                    if ( undefined == item.uid ) {
                        item.uid = this.generatekey();
                    }
                }
            }
            return grouprecords;
        },

        getRecordsHierarchy: function ( fieldName, parentFieldName, collectionName, mappingFields, dataRecords ) {
            var recordsHierarchy = new Array();
            var flatData = this.records;
            if ( dataRecords ) {
                flatData = dataRecords;
            }

            if ( this.records.length == 0 )
                return null;

            var subItemsName = collectionName != null ? collectionName : "items";
            var items = [];
            var data = flatData;
            var dataLength = data.length;
            var names = ( this._source && this._source.hierarchy ) ? this._source.hierarchy.reservedNames : null;

            var itemByRecord = function ( record ) {
                var itemObj = record;
                if ( mappingFields ) {
                    $.each( mappingFields, function () {
                        if ( this.name && this.map ) {
                            itemObj[ this.map ] = itemObj[ this.name ];
                        }
                    } );
                }

                return itemObj;
            }

            // build hierarchical source.
            for ( var i = 0; i < dataLength; i++ ) {
                var item = $.extend( {}, data[ i ] );
                var parentid = item[ parentFieldName ];
                var id = item[ fieldName ];
                items[ id ] = { parentid: parentid, item: item };
            }

            for ( var i = 0; i < dataLength; i++ ) {
                var item = $.extend( {}, data[ i ] );
                var parentid = item[ parentFieldName ];
                var id = item[ fieldName ];

                if ( items[ parentid ] != undefined ) {
                    var item = { parentid: parentid, item: items[ id ].item };
                    var parentItem = items[ parentid ].item;
                    if ( !parentItem[ subItemsName ] ) {
                        parentItem[ subItemsName ] = [];
                    }
                    var length = parentItem[ subItemsName ].length;
                    var record = item.item;

                    if ( !names ) {
                        if ( record.parent == undefined ) {
                            record.parent = parentItem;
                        }
                    }
                    else {
                        if ( record[ names.parent ] == undefined ) {
                            record[ names.parent ] = parentItem;
                        }
                    }

                    var itemObj = itemByRecord( record );
                    parentItem[ subItemsName ][ length ] = itemObj;
                    items[ parentid ].item = parentItem;
                    items[ id ] = item;
                }
                else {
                    var record = items[ id ].item;
                    if ( !names ) {
                        if ( record.parent == undefined ) {
                            record.parent = null;
                        }
                    }
                    else {
                        if ( record[ names.parent ] == undefined ) {
                            record[ names.parent ] = null;
                        }
                    }

                    var itemObj = itemByRecord( record );
                    if ( !names ) {
                        itemObj.level = 0;
                    }
                    else {
                        itemObj[ names.level ] = 0;
                    }

                    recordsHierarchy[ recordsHierarchy.length ] = itemObj;
                }
            }
            if ( recordsHierarchy.length != 0 ) {
                var updateLevels = function ( level, records ) {
                    for ( var i = 0; i < records.length; i++ ) {
                        if ( !names ) {
                            records[ i ].level = level;
                        }
                        else {
                            records[ i ][ names.level ] = level;
                        }

                        var subRecords = records[ i ][ subItemsName ];
                        if ( subRecords ) {
                            if ( subRecords.length > 0 ) {
                                updateLevels( level + 1, subRecords );
                            }
                            else {
                                if ( !names ) {
                                    records[ i ].leaf = true;
                                }
                                else {
                                    records[ i ][ names.leaf ] = true;
                                }
                            }
                        }
                        else {
                            if ( !names ) {
                                records[ i ].leaf = true;
                            }
                            else {
                                records[ i ][ names.leaf ] = true;
                            }
                        }
                    }
                };
                updateLevels( 0, recordsHierarchy );
            }
            return recordsHierarchy;
        },

        bindBindingUpdate: function ( id, func ) {
            this._bindingUpdate[ this._bindingUpdate.length ] = { id: id, func: func };

        },

        unbindBindingUpdate: function ( id ) {
            for ( var i = 0; i < this._bindingUpdate.length; i++ ) {
                if ( this._bindingUpdate[ i ].id == id ) {
                    this._bindingUpdate[ i ].func = null;
                    this._bindingUpdate.splice( i, 1 );
                    break;
                }
            }
        },

        callBindingUpdate: function ( collectionChanged ) {
            for ( var update = 0; update < this._bindingUpdate.length; update++ ) {
                var bindingUpdate = this._bindingUpdate[ update ];
                if ( bindingUpdate.func != null ) {
                    bindingUpdate.func( collectionChanged );
                }
            }
        },

        getid: function ( id, record, index ) {
            if ( id != null && id.name != undefined ) {
                if ( id.name ) {
                    var result = $( record ).attr( id.name );
                    if ( result != null && result.toString().length > 0 ) {
                        return result;
                    }
                    else if ( id.map ) {
                        try {
                            var result = $( record ).attr( id.map );
                            if ( result != null && result.toString().length > 0 ) {
                                return result;
                            }
                            else if ( $( id.map, record ).length > 0 ) {
                                return $( id.map, record ).text();
                            }
                            else if ( $( id.name, record ).length > 0 ) {
                                return $( id.name, record ).text();
                            }
                        }
                        catch ( error ) {
                            return index;
                        }
                    }
                    return;
                }
            }

            if ( $( id, record ).length > 0 ) {
                return $( id, record ).text();
            }

            if ( id ) {
                if ( id.toString().length > 0 ) {
                    var result = $( record ).attr( id );
                    if ( result != null && result.toString().length > 0 ) {
                        return $.trim( result ).split( " " ).join( "" ).replace( /([ #;?%&,.+*~\':"!^$[\]()=>|\/\\@])/g, '' );
                    }
                    else {
                        var splitMap = id.split( this.mapChar );
                        if ( splitMap.length > 1 ) {
                            var d = record;
                            for ( var p = 0; p < splitMap.length; p++ ) {
                                if ( d != undefined ) {
                                    d = d[ splitMap[ p ] ];
                                }
                            }
                            if ( d != undefined ) {
                                return d;
                            }
                        }
                        else {
                            if ( record[ id ] != undefined ) {
                                return record[ id ];
                            }
                        }
                    }
                }
            }

            return index;
        },

        loadjson: function ( jsondata, data, source ) {
            if ( typeof ( jsondata ) == 'string' ) {
                jsondata = $.parseJSON( jsondata );
            }

            if ( source.root == undefined ) source.root = '';
            if ( source.record == undefined ) source.record = '';

            var jsondata = jsondata || data;
            if ( !jsondata ) {
                jsondata = [];
            }

            var me = this;
            if ( source.root != '' ) {
                var splitMap = source.root.split( me.mapChar );
                if ( splitMap.length > 1 ) {
                    var d = jsondata;
                    for ( var p = 0; p < splitMap.length; p++ ) {
                        if ( d != undefined ) {
                            d = d[ splitMap[ p ] ];
                        }
                    }
                    jsondata = d;
                }
                else {
                    if ( jsondata[ source.root ] !== undefined ) {
                        jsondata = jsondata[ source.root ];
                    }
                    else if ( jsondata[ 0 ] && jsondata[ 0 ][ source.root ] !== undefined ) {
                        jsondata = jsondata[ 0 ][ source.root ];
                    }
                    else {
                        $.each( jsondata, function ( i ) {
                            var root = this;
                            if ( this == source.root ) {
                                jsondata = this;
                                return false;
                            }
                            else if ( this[ source.root ] != undefined ) {
                                jsondata = this[ source.root ];
                            }
                        } );
                    }

                    if ( !jsondata ) {
                        var splitMap = source.root.split( me.mapChar );
                        if ( splitMap.length > 0 ) {
                            var d = jsondata;
                            for ( var p = 0; p < splitMap.length; p++ ) {
                                if ( d != undefined ) {
                                    d = d[ splitMap[ p ] ];
                                }
                            }
                            jsondata = d;
                        }
                    }
                }
            }
            else {
                if ( !jsondata.length ) {
                    for ( var obj in jsondata ) {
                        if ( $.isArray( jsondata[ obj ] ) ) {
                            jsondata = jsondata[ obj ];
                            break;
                        }
                    }
                }
            }

            if ( jsondata != null && jsondata.length == undefined ) {
                jsondata = $.makeArray( jsondata );
            }

            if ( jsondata == null || jsondata == undefined || jsondata == "undefined" || jsondata.length == undefined ) {
                throw new Error( 'jqxDataAdapter: JSON Parse error! Invalid JSON. Please, check your JSON or your jqxDataAdapter initialization!' );
                return;
            }

            if ( jsondata.length == 0 ) {
                this.totalrecords = 0;
                return;
            }

            var length = jsondata.length;
            this.totalrecords = this.virtualmode ? ( source.totalrecords || length ) : length;
            this.records = new Array();
            this.originaldata = new Array();

            var records = this.records;
            var recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;

            this.recordids = new Array();

            if ( source.loadallrecords ) {
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var dataoffset = 0;
            if ( this.virtualmode ) {
                recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;
                dataoffset = recordsstartindex;
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var datafieldslength = source.datafields ? source.datafields.length : 0;
            // auto-generate data columns
            if ( datafieldslength == 0 ) {
                var firstrecord = jsondata[ 0 ];
                var datafields = new Array();
                for ( var obj in firstrecord ) {
                    var field = obj;
                    datafields[ datafields.length ] = { name: field };
                }
                source.datafields = datafields;
                source.generatedfields = source.datafields;
                datafieldslength = datafields.length;
            }

            var index = recordsstartindex;
            for ( var i = recordsstartindex; i < length; i++ ) {
                var record = jsondata[ i ];

                if ( record == undefined )
                    break;

                if ( source.record && source.record != '' ) {
                    record = record[ source.record ];
                    if ( record == undefined )
                        continue;
                }

                var recordid = this.getid( source.id, record, i );
                if ( typeof ( recordid ) === "object" ) {
                    recordid = i;
                }

                if ( !this.recordids[ recordid ] ) {
                    this.recordids[ recordid ] = record;
                    var datarow = {};

                    for ( var j = 0; j < datafieldslength; j++ ) {
                        var datafield = source.datafields[ j ];
                        var value = '';
                        if ( undefined == datafield || datafield == null ) {
                            continue;
                        }

                        if ( datafield.map ) {
                            if ( $.isFunction( datafield.map ) ) {
                                value = datafield.map( record );
                            }
                            else {
                                var splitMap = datafield.map.split( me.mapChar );
                                if ( splitMap.length > 0 ) {
                                    var datarecord = record;
                                    for ( var p = 0; p < splitMap.length; p++ ) {
                                        if ( datarecord != undefined ) {
                                            datarecord = datarecord[ splitMap[ p ] ];
                                        }
                                    }
                                    value = datarecord;
                                }
                                else {
                                    value = record[ datafield.map ];
                                }
                            }

                            if ( value != undefined && value != null ) {
                                value = this.getvaluebytype( value, datafield );
                            }
                            else if ( value == undefined && value != null ) {
                                value = '';
                            }
                        }

                        // searches by both selectors when necessary.
                        if ( value == '' && !datafield.map ) {
                            value = record[ datafield.name ];
                            if ( value == undefined && value != null ) {
                                value = '';
                            }
                            // the datafield.value allows you to load values like: "Nombre":{"#text":"FASE 1"}, where the datafield is Nombre, the value is object.
                            // If the datafield.value is "#text", the value that will be loaded will be "FASE 1".
                            if ( datafield.value != undefined ) {
                                if ( value != undefined ) {
                                    var tmpvalue = value[ datafield.value ];
                                    if ( tmpvalue != undefined ) {
                                        value = tmpvalue;
                                    }
                                }
                            }
                        }

                        value = this.getvaluebytype( value, datafield );
                        if ( datafield.displayname != undefined ) {
                            datarow[ datafield.displayname ] = value;
                        }
                        else {
                            datarow[ datafield.name ] = value;
                        }

                        if ( datafield.type === "array" ) {
                            var updateValues = function ( records ) {
                                if ( !records ) return;
                                for ( var t = 0; t < records.length; t++ ) {
                                    var record = records[ t ];
                                    if ( !record ) {
                                        continue;
                                    }

                                    for ( var c = 0; c < datafieldslength; c++ ) {
                                        var datafield = source.datafields[ c ];
                                        var value = '';
                                        if ( undefined == datafield || datafield == null ) {
                                            continue;
                                        }

                                        if ( datafield.map ) {
                                            if ( $.isFunction( datafield.map ) ) {
                                                value = datafield.map( record );
                                            }
                                            else {
                                                var splitMap = datafield.map.split( me.mapChar );
                                                if ( splitMap.length > 0 ) {
                                                    var datarecord = record;
                                                    for ( var p = 0; p < splitMap.length; p++ ) {
                                                        if ( datarecord != undefined ) {
                                                            datarecord = datarecord[ splitMap[ p ] ];
                                                        }
                                                    }
                                                    value = datarecord;
                                                }
                                                else {
                                                    value = record[ datafield.map ];
                                                }
                                            }

                                            if ( value != undefined && value != null ) {
                                                value = this.getvaluebytype( value, datafield );
                                            }
                                            else if ( value == undefined && value != null ) {
                                                value = '';
                                            }
                                        }

                                        // searches by both selectors when necessary.
                                        if ( value == '' && !datafield.map ) {
                                            value = record[ datafield.name ];
                                            if ( value == undefined && value != null ) {
                                                value = '';
                                            }
                                            // the datafield.value allows you to load values like: "Nombre":{"#text":"FASE 1"}, where the datafield is Nombre, the value is object.
                                            // If the datafield.value is "#text", the value that will be loaded will be "FASE 1".
                                            if ( datafield.value != undefined ) {
                                                if ( value != undefined ) {
                                                    var tmpvalue = value[ datafield.value ];
                                                    if ( tmpvalue != undefined ) {
                                                        value = tmpvalue;
                                                    }
                                                }
                                            }
                                        }

                                        value = this.getvaluebytype( value, datafield );
                                        if ( datafield.displayname != undefined ) {
                                            record[ datafield.displayname ] = value;
                                        }
                                        else {
                                            record[ datafield.name ] = value;
                                        }
                                        if ( datafield.type === "array" ) {
                                            updateValues.call( this, value );
                                        }
                                    }
                                }
                            }
                            updateValues.call( this, value );
                        }
                    }

                    if ( source.recordendindex <= 0 || recordsstartindex < source.recordendindex ) {
                        //      records[dataoffset + index] = $.extend({}, datarow);
                        records[ dataoffset + index ] = new Object( datarow );
                        records[ dataoffset + index ].uid = recordid;

                        this.originaldata[ dataoffset + index ] = new Object( records[ i ] );

                        //     this.originaldata[dataoffset + index] = $.extend({}, records[i]);
                        index++;
                    }
                }
            }
            this.records = records;
            this.cachedrecords = this.records;
        },

        loadxml: function ( xmldata, data, source ) {
            if ( typeof ( xmldata ) == 'string' ) {
                xmldata = data = $( $.parseXML( xmldata ) );
                xmldata = null;
            }

            if ( source.root == undefined ) source.root = '';
            if ( source.record == undefined ) source.record = '';


            var xmldata;

            if ( $.jqx.browser.msie && data ) {
                if ( data.xml != undefined ) {
                    xmldata = $( source.root + " " + source.record, $.parseXML( data.xml ) );
                }
                else {
                    xmldata = xmldata || $( source.root + " " + source.record, data );
                }
            }
            else xmldata = xmldata || $( source.root + " " + source.record, data );

            if ( !xmldata ) {
                xmldata = [];
            }

            var length = xmldata.length;
            if ( xmldata.length == 0 ) {
                return;
            }

            this.totalrecords = this.virtualmode ? ( source.totalrecords || length ) : length;
            this.records = new Array();
            this.originaldata = new Array();

            var records = this.records;
            var recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;

            this.recordids = new Array();

            if ( source.loadallrecords ) {
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var dataoffset = 0;
            if ( this.virtualmode ) {
                recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;
                dataoffset = recordsstartindex;
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var datafieldslength = source.datafields ? source.datafields.length : 0;
            // auto-generate data columns
            if ( datafieldslength == 0 ) {
                var firstrecord = xmldata[ 0 ];
                var datafields = new Array();
                for ( var obj in firstrecord ) {
                    var field = obj;
                    datafields[ datafields.length ] = { name: field };
                }
                source.datafields = datafields;
                source.generatedfields = source.datafields;

                datafieldslength = datafields.length;
            }

            var p = recordsstartindex;
            var hasArray = false;
            for ( var i = recordsstartindex; i < length; i++ ) {
                var record = xmldata[ i ];
                if ( record == undefined )
                    break;

                var recordid = this.getid( source.id, record, i );
                if ( !this.recordids[ recordid ] ) {
                    this.recordids[ recordid ] = record;
                    var datarow = {};

                    var multiLevel = false;
                    if ( source.hierarchy && source.hierarchy.root ) {
                        multiLevel = true;
                    }

                    for ( var j = 0; j < datafieldslength; j++ ) {
                        var datafield = source.datafields[ j ];
                        var value = '';
                        if ( undefined == datafield || datafield == null ) {
                            continue;
                        }

                        if ( datafield.map ) {
                            if ( $.isFunction( datafield.map ) ) {
                                value = datafield.map( record );
                            }
                            else {
                                var attributeStartIndex = datafield.map.indexOf( '[' );
                                if ( attributeStartIndex < 0 ) {
                                    value = $( datafield.map, record );
                                    if ( value.length == 1 ) value = value.text();
                                    else {
                                        hasArray = true;
                                        var subArray = new Array();
                                        for ( var f = 0; f < value.length; f++ ) {
                                            subArray.push( $( value[ f ] ).text() );
                                        }
                                        value = subArray;
                                        if ( multiLevel && subArray.length > 0 ) {
                                            value = subArray[ 0 ];
                                        }
                                    }
                                }
                                else {
                                    var submap = datafield.map.substring( 0, attributeStartIndex - 1 );
                                    var attributeEndIndex = datafield.map.indexOf( ']' );
                                    var attribute = datafield.map.substring( attributeStartIndex + 1, attributeEndIndex );
                                    value = $( submap, record ).attr( attribute );
                                    if ( value == undefined ) {
                                        value = $( record ).attr( attribute );
                                    }

                                    if ( value == undefined ) value = '';
                                }
                                if ( value == '' ) {
                                    value = $( record ).attr( datafield.map );
                                    if ( value == undefined ) value = '';
                                }
                            }
                        }
                        // searches by both selectors when necessary.
                        if ( value == '' ) {
                            value = $( datafield.name, record );
                            if ( value.length == 1 ) value = value.text();
                            else {
                                var subArray = new Array();
                                for ( var f = 0; f < value.length; f++ ) {
                                    subArray.push( $( value[ f ] ).text() );
                                }
                                value = subArray;
                                if ( multiLevel && subArray.length > 0 ) {
                                    value = subArray[ 0 ];
                                }
                            }

                            if ( value == '' ) {
                                value = $( record ).attr( datafield.name );
                                if ( value == undefined ) value = '';
                            }
                            if ( value == '' ) {
                                if ( record.nodeName && record.nodeName == datafield.name && record.firstChild ) {
                                    value = $( record.firstChild ).text();
                                }
                            }
                        }

                        var originalvalue = value;
                        value = this.getvaluebytype( value, datafield );
                        if ( datafield.displayname != undefined ) {
                            datarow[ datafield.displayname ] = value;
                        }
                        else {
                            datarow[ datafield.name ] = value;
                        }
                    }
                    if ( source.recordendindex <= 0 || recordsstartindex < source.recordendindex ) {
                        records[ dataoffset + p ] = $.extend( {}, datarow );
                        records[ dataoffset + p ].uid = recordid;

                        this.originaldata[ dataoffset + p ] = $.extend( {}, records[ i ] );
                        p++;
                    }
                }
            }

            if ( source.hierarchy && source.hierarchy.root ) {
                for ( var i = recordsstartindex; i < length; i++ ) {
                    var record = xmldata[ i ];
                    var dataRecord = records[ i ];

                    if ( $( record ).parent().length > 0 ) {
                        var recordid = this.getid( source.id, $( record ).parents( source.hierarchy.record + ":first" ) );
                        dataRecord.parentuid = recordid;
                    }
                    else {
                        dataRecord.parentuid = null;
                    }
                }
            }

            this.records = records;
            this.cachedrecords = this.records;
        },

        loadics: function ( data, source ) {
            if ( data == null ) {
                return;
            }

            var rowDelimiter = source.rowDelimiter || this.rowDelimiter || '\n';
            var rows = data.split( rowDelimiter );
            var length = rows.length;
            var rowsWithNewRowDelimiter = data.split( '\r' );
            if ( length == 1 && rowsWithNewRowDelimiter.length > 1 ) {
                rows = rowsWithNewRowDelimiter;
                length = rows.length;
            }
            this.records = new Array();
            this.originaldata = new Array();

            var records = this.records;
            this.recordids = new Array();

            var dataoffset = 0;

            var stringToDate = function ( until ) {
                var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z)?$/;
                var bits = re.exec( until );
                if ( !bits ) {
                    throw new Error( 'Invalid UNTIL value: ' + until )
                }
                return new Date(
                    Date.UTC( bits[ 1 ],
                        bits[ 2 ] - 1,
                        bits[ 3 ],
                        bits[ 5 ] || 0,
                        bits[ 6 ] || 0,
                        bits[ 7 ] || 0
                    ) );
            }

            for ( var i = 0; i < length; i++ ) {
                var record = rows[ i ];
                if ( record == "BEGIN:VEVENT" ) {
                    var appointment = {};
                    continue;
                }

                if ( record.indexOf( "SUMMARY" ) >= 0 ) {
                    appointment.SUMMARY = record.substring( record.indexOf( "SUMMARY" ) + 8 );
                    continue;
                }
                if ( record.indexOf( "LOCATION" ) >= 0 ) {
                    appointment.LOCATION = record.substring( record.indexOf( "LOCATION" ) + 9 );
                    continue;
                }
                if ( record.indexOf( "DESCRIPTION" ) >= 0 ) {
                    appointment.DESCRIPTION = record.substring( record.indexOf( "DESCRIPTION" ) + 12 );
                    continue;
                }
                if ( record.indexOf( "RRULE" ) >= 0 ) {
                    appointment.RRULE = record.substring( record.indexOf( "RRULE" ) + 6 );
                    continue;
                }
                if ( record.indexOf( "EXDATE" ) >= 0 ) {
                    var exDate = record.substring( record.indexOf( "EXDATE" ) + 7 );
                    appointment.EXDATE = exDate;
                    continue;
                }
                if ( record.indexOf( "DTEND" ) >= 0 ) {
                    appointment.DTEND = stringToDate( record.substring( record.indexOf( "DTEND" ) + 6 ) );
                    continue;
                }
                if ( record.indexOf( "DTSTART" ) >= 0 ) {
                    appointment.DTSTART = stringToDate( record.substring( record.indexOf( "DTSTART" ) + 8 ) );
                    continue;
                }
                if ( record.indexOf( "UID" ) >= 0 ) {
                    appointment.uid = appointment.UID = record.substring( record.indexOf( "UID" ) + 4 );
                    continue;
                }
                if ( record.indexOf( "STATUS" ) >= 0 ) {
                    appointment.STATUS = record.substring( record.indexOf( "STATUS" ) + 7 );
                    continue;
                }
                if ( record == "END:VEVENT" ) {
                    records.push( appointment );
                    continue;
                }
            }
            this.records = records;
            this.cachedrecords = this.records;
        },

        loadtext: function ( data, source ) {
            if ( data == null ) {
                return;
            }

            var rowDelimiter = source.rowDelimiter || this.rowDelimiter || '\n';
            var rows = data.split( rowDelimiter );
            var length = rows.length;
            var rowsWithNewRowDelimiter = data.split( '\r' );
            if ( length == 1 && rowsWithNewRowDelimiter.length > 1 ) {
                rows = rowsWithNewRowDelimiter;
                length = rows.length;
            }
            this.totalrecords = this.virtualmode ? ( source.totalrecords || length ) : length;
            this.records = new Array();
            this.originaldata = new Array();

            var records = this.records;
            var recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;

            this.recordids = new Array();

            if ( source.loadallrecords ) {
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var dataoffset = 0;
            if ( this.virtualmode ) {
                recordsstartindex = !this.pageable ? source.recordstartindex : this.pagesize * this.pagenum;
                dataoffset = recordsstartindex;
                recordsstartindex = 0;
                length = this.totalrecords;
            }

            var datafieldslength = source.datafields.length;
            var columnDelimiter = source.columnDelimiter || this.columnDelimiter;
            if ( !columnDelimiter )
                columnDelimiter = ( source.datatype === 'tab' || source.datatype === 'tsv' ) ? '\t' : ',';

            for ( var i = recordsstartindex; i < length; i++ ) {
                var record = rows[ i ];
                var recordid = null;
                if ( !this.recordids[ recordid ] ) {
                    if ( source.id == null ) {
                        recordid = i;
                        this.recordids[ recordid ] = record;
                    }

                    var datarow = {};
                    var columns = rows[ i ].split( columnDelimiter );

                    for ( var j = 0; j < datafieldslength; j++ ) {
                        if ( j >= columns.length )
                            continue;
                        var datafield = source.datafields[ j ];

                        var value = columns[ j ];
                        if ( datafield.map && $.isFunction( datafield.map ) ) {
                            value = datafield.map( record );
                        }

                        if ( datafield.type ) {
                            value = this.getvaluebytype( value, datafield );
                        }

                        var key = datafield.map || datafield.name || j.toString();
                        datarow[ key ] = value;
                        if ( source.id != null ) {
                            if ( source.id === datafield.name ) {
                                recordid = value;
                                this.recordids[ recordid ] = record;
                            }
                        }
                    }
                    if ( recordid == null ) {
                        recordid = i;
                    }

                    records[ dataoffset + i ] = $.extend( {}, datarow );
                    records[ dataoffset + i ].uid = recordid;

                    this.originaldata[ dataoffset + i ] = $.extend( {}, records[ i ] );
                }
            }
            this.records = records;
            this.cachedrecords = this.records;
        },

        getvaluebytype: function ( value, datafield ) {
            var originalvalue = value;
            if ( value == null ) return value;
            if ( $.isArray( value ) && datafield.type != "array" ) {
                for ( var t = 0; t < value.length; t++ ) {
                    value[ t ] = this.getvaluebytype( value[ t ], datafield );
                }
                return value;
            }

            if ( datafield.type == 'date' ) {
                if ( value == "NaN" ) {
                    value = "";
                }
                else {
                    if ( value && value instanceof Date ) {
                        return value;
                    }

                    var tmpvalue = new Date( value );

                    if ( typeof value == 'string' ) {
                        if ( datafield.format ) {
                            var newtmpvalue = $.jqx.dataFormat.parsedate( value, datafield.format );
                            if ( newtmpvalue != null ) {
                                tmpvalue = newtmpvalue;
                            }
                        }
                    }

                    if ( tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date" ) {
                        if ( $.jqx.dataFormat ) {
                            value = $.jqx.dataFormat.tryparsedate( value );
                        }
                        else value = tmpvalue;
                    }
                    else {
                        value = tmpvalue;
                    }

                    if ( value == null ) {
                        value = originalvalue;
                    }
                }
            }
            else if ( datafield.type == 'float' || datafield.type == 'number' || datafield.type == 'decimal' ) {
                if ( value == "NaN" ) value = "";
                else {
                    var value = parseFloat( value );
                    if ( isNaN( value ) ) {
                        value = originalvalue;
                    }
                }
            }
            else if ( datafield.type == 'int' || datafield.type == 'integer' ) {
                var value = parseInt( value );
                if ( isNaN( value ) ) {
                    value = originalvalue;
                }
            }
            else if ( datafield.type == 'bool' || datafield.type == 'boolean' ) {
                if ( value != null ) {
                    if ( value.toLowerCase != undefined ) {
                        if ( value.toLowerCase() == 'false' ) {
                            value = false;
                        }
                        else if ( value.toLowerCase() == 'true' ) {
                            value = true;
                        }
                    }
                }

                if ( value == 1 ) {
                    value = true;
                }
                else if ( value == 0 && value !== "" ) {
                    value = false;
                }
                else value = '';
            }

            return value;
        }
    }

    $.jqx.dataFormat = {};

    $.extend( $.jqx.dataFormat, {
        regexTrim: /^\s+|\s+$/g,
        regexInfinity: /^[+-]?infinity$/i,
        regexHex: /^0x[a-f0-9]+$/i,
        regexParseFloat: /^[+-]?\d*\.?\d*(e[+-]?\d+)?$/,
        toString: Object.prototype.toString,

        isBoolean: function ( value ) {
            return typeof value === 'boolean';
        },

        isObject: function ( value ) {
            return ( value && ( typeof value === 'object' || $.isFunction( value ) ) ) || false;
        },

        isDate: function ( value ) {
            return value instanceof Date;
        },

        arrayIndexOf: function ( array, item ) {
            if ( array.indexOf ) {
                return array.indexOf( item );
            }
            for ( var i = 0, length = array.length; i < length; i++ ) {
                if ( array[ i ] === item ) {
                    return i;
                }
            }
            return -1;
        },

        isString: function ( value ) {
            return typeof value === 'string';
        },

        isNumber: function ( value ) {
            return typeof value === 'number' && isFinite( value );
        },

        isNull: function ( value ) {
            return value === null;
        },

        isUndefined: function ( value ) {
            return typeof value === 'undefined';
        },

        isValue: function ( value ) {
            return ( this.isObject( value ) || this.isString( value ) || this.isNumber( value ) || this.isBoolean( value ) );
        },

        isEmpty: function ( value ) {
            if ( !this.isString( value ) && this.isValue( value ) ) {
                return false;
            } else if ( !this.isValue( value ) ) {
                return true;
            }
            value = $.trim( value ).replace( /\&nbsp\;/ig, '' ).replace( /\&#160\;/ig, '' );
            return value === "";
        },

        startsWith: function ( value, pattern ) {
            return value.indexOf( pattern ) === 0;
        },

        endsWith: function ( value, pattern ) {
            return value.substr( value.length - pattern.length ) === pattern;
        },

        trim: function ( value ) {
            return ( value + "" ).replace( this.regexTrim, "" );
        },

        isArray: function ( obj ) {
            return this.toString.call( obj ) === "[object Array]";
        },

        defaultcalendar: function () {
            var calendar = {
                // separator of parts of a date (e.g. '/' in 11/05/1955)
                '/': "/",
                // separator of parts of a time (e.g. ':' in 05:44 PM)
                ':': ":",
                // the first day of the week (0 = Sunday, 1 = Monday, etc)
                firstDay: 0,
                days: {
                    // full day names
                    names: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                    // abbreviated day names
                    namesAbbr: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                    // shortest day names
                    namesShort: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ]
                },
                months: {
                    // full month names (13 months for lunar calendards -- 13th month should be "" if not lunar)
                    names: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", "" ],
                    // abbreviated month names
                    namesAbbr: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "" ]
                },
                // AM and PM designators in one of these forms:
                // The usual view, and the upper and lower case versions
                //      [standard,lowercase,uppercase]
                // The culture does not use AM or PM (likely all standard date formats use 24 hour time)
                //      null
                AM: [ "AM", "am", "AM" ],
                PM: [ "PM", "pm", "PM" ],
                eras: [
                    // eras in reverse chronological order.
                    // name: the name of the era in this culture (e.g. A.D., C.E.)
                    // start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
                    // offset: offset in years from gregorian calendar
                    { "name": "A.D.", "start": null, "offset": 0 }
                ],
                twoDigitYearMax: 2029,
                patterns: {
                    // short date pattern
                    d: "M/d/yyyy",
                    // long date pattern
                    D: "dddd, MMMM dd, yyyy",
                    // short time pattern
                    t: "h:mm tt",
                    // long time pattern
                    T: "h:mm:ss tt",
                    // long date, short time pattern
                    f: "dddd, MMMM dd, yyyy h:mm tt",
                    // long date, long time pattern
                    F: "dddd, MMMM dd, yyyy h:mm:ss tt",
                    // month/day pattern
                    M: "MMMM dd",
                    // month/year pattern
                    Y: "yyyy MMMM",
                    // S is a sortable format that does not vary by culture
                    S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss",
                    // formatting of dates in MySQL DataBases
                    ISO: "yyyy-MM-dd hh:mm:ss",
                    ISO2: "yyyy-MM-dd HH:mm:ss",
                    d1: "dd.MM.yyyy",
                    d2: "dd-MM-yyyy",
                    d3: "MM-dd-yyyy",
                    zone1: "yyyy-MM-ddTHH:mm:ss-HH:mm",
                    zone2: "yyyy-MM-ddTHH:mm:ss+HH:mm",
                    custom: "yyyy-MM-ddTHH:mm:ss.fff",
                    custom2: "yyyy-MM-dd HH:mm:ss.fff"
                },
                percentsymbol: "%",
                currencysymbol: "$",
                currencysymbolposition: "before",
                decimalseparator: '.',
                thousandsseparator: ','
            }
            return calendar;
        },

        expandFormat: function ( calendar, format ) {
            // expands unspecified or single character date formats into the full pattern.
            format = format || "F";
            var pattern,
                patterns = calendar.patterns,
                len = format.length;
            if ( len === 1 ) {
                pattern = patterns[ format ];
                if ( !pattern ) {
                    throw "Invalid date format string '" + format + "'.";
                }
                format = pattern;
            }
            else if ( len === 2 && format.charAt( 0 ) === "%" ) {
                // %X escape format -- intended as a custom format string that is only one character, not a built-in format.
                format = format.charAt( 1 );
            }
            return format;
        },

        getEra: function ( date, eras ) {
            if ( !eras ) return 0;
            if ( typeof date === 'string' ) {
                return 0;
            }

            var start, ticks = date.getTime();
            for ( var i = 0, l = eras.length; i < l; i++ ) {
                start = eras[ i ].start;
                if ( start === null || ticks >= start ) {
                    return i;
                }
            }
            return 0;
        },

        toUpper: function ( value ) {
            // 'he-IL' has non-breaking space in weekday names.
            return value.split( "\u00A0" ).join( ' ' ).toUpperCase();
        },

        toUpperArray: function ( arr ) {
            var results = [];
            for ( var i = 0, l = arr.length; i < l; i++ ) {
                results[ i ] = this.toUpper( arr[ i ] );
            }
            return results;
        },

        getEraYear: function ( date, cal, era, sortable ) {
            var year = date.getFullYear();
            if ( !sortable && cal.eras ) {
                // convert normal gregorian year to era-shifted gregorian
                // year by subtracting the era offset
                year -= cal.eras[ era ].offset;
            }
            return year;
        },

        toUpper: function ( value ) {
            if ( value ) {
                return value.toUpperCase();
            }
            return "";
        },

        getDayIndex: function ( cal, value, abbr ) {
            var ret,
                days = cal.days,
                upperDays = cal._upperDays;
            if ( !upperDays ) {
                cal._upperDays = upperDays = [
                    this.toUpperArray( days.names ),
                    this.toUpperArray( days.namesAbbr ),
                    this.toUpperArray( days.namesShort )
                ];
            }
            value = value.toUpperCase();
            if ( abbr ) {
                ret = this.arrayIndexOf( upperDays[ 1 ], value );
                if ( ret === -1 ) {
                    ret = this.arrayIndexOf( upperDays[ 2 ], value );
                }
            }
            else {
                ret = this.arrayIndexOf( upperDays[ 0 ], value );
            }
            return ret;
        },

        getMonthIndex: function ( cal, value, abbr ) {
            var months = cal.months,
                monthsGen = cal.monthsGenitive || cal.months,
                upperMonths = cal._upperMonths,
                upperMonthsGen = cal._upperMonthsGen;
            if ( !upperMonths ) {
                cal._upperMonths = upperMonths = [
                    this.toUpperArray( months.names ),
                    this.toUpperArray( months.namesAbbr )
                ];
                cal._upperMonthsGen = upperMonthsGen = [
                    this.toUpperArray( monthsGen.names ),
                    this.toUpperArray( monthsGen.namesAbbr )
                ];
            }
            value = this.toUpper( value );
            var i = this.arrayIndexOf( abbr ? upperMonths[ 1 ] : upperMonths[ 0 ], value );
            if ( i < 0 ) {
                i = this.arrayIndexOf( abbr ? upperMonthsGen[ 1 ] : upperMonthsGen[ 0 ], value );
            }
            return i;
        },

        appendPreOrPostMatch: function ( preMatch, strings ) {
            // appends pre- and post- token match strings while removing escaped characters.
            // Returns a single quote count which is used to determine if the token occurs
            // in a string literal.
            var quoteCount = 0,
                escaped = false;
            for ( var i = 0, il = preMatch.length; i < il; i++ ) {
                var c = preMatch.charAt( i );
                switch ( c ) {
                    case '\'':
                        if ( escaped ) {
                            strings.push( "'" );
                        }
                        else {
                            quoteCount++;
                        }
                        escaped = false;
                        break;
                    case '\\':
                        if ( escaped ) {
                            strings.push( "\\" );
                        }
                        escaped = !escaped;
                        break;
                    default:
                        strings.push( c );
                        escaped = false;
                        break;
                }
            }
            return quoteCount;
        },

        getTokenRegExp: function () {
            // regular expression for matching date and time tokens in format strings.
            return /\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g;
        },

        formatlink: function ( value, format ) {
            var target = '';
            if ( format && format.target ) { target = 'target=' + format.target; }
            if ( target != '' ) {
                return "<a " + target + " href=\"" + value + "\">" + value + "</a>";
            }
            return "<a href=\"" + value + "\">" + value + "</a>";
        },

        formatemail: function ( value ) {
            return "<a href=\"mailto:" + value + "\">" + value + "</a>";
        },

        formatNumber: function ( value, format, calendar ) {
            return this.formatnumber( value, format, calendar );
        },

        formatnumber: function ( value, format, calendar ) {
            if ( calendar == undefined || calendar == null || calendar == "" ) {
                calendar = this.defaultcalendar();
            }

            if ( format === "" || format === null ) {
                return value;
            }

            if ( !this.isNumber( value ) ) {
                value *= 1;
            }
            var precision;
            if ( format.length > 1 ) precision = parseInt( format.slice( 1 ), 10 );

            var options = {}
            var current = format.charAt( 0 ).toUpperCase();

            options.thousandsSeparator = calendar.thousandsseparator;
            options.decimalSeparator = calendar.decimalseparator;
            switch ( current ) {
                case "D":
                case "d":
                case "F":
                case "f":
                    options.decimalPlaces = precision;
                    break;
                case "N":
                case "n":
                    options.decimalPlaces = 0;
                    break;
                case "C":
                case "c":
                    options.decimalPlaces = precision;
                    if ( calendar.currencysymbolposition == "before" ) {
                        options.prefix = calendar.currencysymbol;
                    }
                    else {
                        options.suffix = calendar.currencysymbol;
                    }
                    break;
                case "P":
                case "p":
                    options.suffix = calendar.percentsymbol;
                    options.decimalPlaces = precision;
                    break;
                default:
                    throw "Bad number format specifier: " + current;
            }

            if ( this.isNumber( value ) ) {
                var negative = ( value < 0 );
                var output = value + "";
                var decimalseparator = ( options.decimalSeparator ) ? options.decimalSeparator : ".";
                var decimalindex;
                if ( this.isNumber( options.decimalPlaces ) ) {
                    // Round to the correct decimal place
                    var decimalplaces = options.decimalPlaces;
                    var decimal = Math.pow( 10, decimalplaces );
                    output = ( value * decimal ).toFixed( 0 ) / decimal + "";
                    decimalindex = output.lastIndexOf( "." );
                    if ( decimalplaces > 0 ) {
                        // Add the decimal separator
                        if ( decimalindex < 0 ) {
                            output += decimalseparator;
                            decimalindex = output.length - 1;
                        }
                        // Replace the "."
                        else if ( decimalseparator !== "." ) {
                            output = output.replace( ".", decimalseparator );
                        }
                        // Add missing zeros
                        while ( ( output.length - 1 - decimalindex ) < decimalplaces ) {
                            output += "0";
                        }
                    }
                }
                else {
                    var output = value + "";
                    decimalindex = output.lastIndexOf( "." );
                    if ( decimalindex > 0 && decimalplaces == undefined ) {
                        // Replace the "."
                        if ( decimalseparator !== "." ) {
                            output = output.replace( ".", decimalseparator );
                        }
                    }
                }

                if ( options.thousandsSeparator ) {
                    var groupseparator = options.thousandsSeparator;
                    decimalindex = output.lastIndexOf( decimalseparator );
                    decimalindex = ( decimalindex > -1 ) ? decimalindex : output.length;
                    var newoutput = output.substring( decimalindex );
                    var nCount = -1;
                    for ( var i = decimalindex; i > 0; i-- ) {
                        nCount++;
                        if ( ( nCount % 3 === 0 ) && ( i !== decimalindex ) && ( !negative || ( i > 1 ) ) ) {
                            newoutput = groupseparator + newoutput;
                        }
                        newoutput = output.charAt( i - 1 ) + newoutput;
                    }
                    output = newoutput;
                }
                // Prepend prefix
                output = ( options.prefix ) ? options.prefix + output : output;
                // Append suffix
                output = ( options.suffix ) ? output + options.suffix : output;
                return output;

            } else {
                return value;
            }
        },

        tryparsedate: function ( value, calendar ) {
            if ( calendar == undefined || calendar == null ) {
                calendar = this.defaultcalendar();
            }
            var me = this;
            if ( value == "" )
                return null;

            if ( value != null && !value.substring ) {
                value = value.toString();
            }

            if ( value != null && value.substring( 0, 6 ) == "/Date(" ) {
                var jsonDateRE = /^\/Date\((-?\d+)(\+|-)?(\d+)?\)\/$/;

                var date = new Date( +value.replace( /\/Date\((\d+)\)\//, '$1' ) );
                if ( date == "Invalid Date" ) {
                    var m = value.match( /^\/Date\((\d+)([-+]\d\d)(\d\d)\)\/$/ );
                    var date = null;
                    if ( m )
                        date = new Date( 1 * m[ 1 ] + 3600000 * m[ 2 ] + 60000 * m[ 3 ] );
                }
                if ( date == null || date == "Invalid Date" || isNaN( date ) ) {
                    var arr = jsonDateRE.exec( value );
                    if ( arr ) {
                        // 0 - complete results; 1 - ticks; 2 - sign; 3 - minutes
                        var result = new Date( parseInt( arr[ 1 ] ) );
                        if ( arr[ 2 ] ) {
                            var mins = parseInt( arr[ 3 ] );
                            if ( arr[ 2 ] === "-" ) {
                                mins = -mins;
                            }
                            var current = result.getUTCMinutes();
                            result.setUTCMinutes( current - mins );
                        }
                        if ( !isNaN( result.valueOf() ) ) {
                            return result;
                        }
                    }
                }

                return date;
            }

            var patterns = calendar.patterns;
            for ( var prop in patterns ) {
                date = me.parsedate( value, patterns[ prop ], calendar );
                if ( date ) {
                    if ( prop == "ISO" ) {
                        var tmpDate = me.parsedate( value, patterns[ "ISO2" ], calendar );
                        if ( tmpDate ) return tmpDate;
                    }
                    return date;
                }
            }

            if ( value != null ) {
                var tmpDate = null;
                var dateParts = [ ':', '/', '-' ];
                var canParse = true;
                for ( var part = 0; part < dateParts.length; part++ ) {
                    if ( value.indexOf( dateParts[ part ] ) != -1 ) {
                        canParse = false;
                    }
                }

                if ( canParse ) {
                    var number = new Number( value );
                    if ( !isNaN( number ) ) {
                        return new Date( number );
                    }
                }
            }

            if ( $.type( value ) === "string" ) {
                var that = me;
                value = that.trim( value );
                var splitParts = [ ':', '/', '-', ' ', ',' ];
                var replaceAll = function ( find, replace, str ) {
                    return str.replace( new RegExp( find, 'g' ), replace );
                }
                value = replaceAll( ', ', ',', value );
                var timePart = "";
                var datePart = value;
                if ( value.indexOf( ":" ) >= 0 ) {
                    timePart = value.substring( value.indexOf( ":" ) - 2 );
                    timePart = that.trim( timePart );
                    datePart = value.substring( 0, value.indexOf( ":" ) - 2 );
                }
                else if ( value.toUpperCase().indexOf( "AM" ) >= 0 ) {
                    timePart = value.substring( value.toUpperCase().indexOf( "AM" ) - 2 );
                    timePart = that.trim( timePart );
                    datePart = value.substring( 0, value.toUpperCase().indexOf( "AM" ) - 2 );
                }
                else if ( value.toUpperCase().indexOf( "PM" ) >= 0 ) {
                    timePart = value.substring( value.toUpperCase().indexOf( "PM" ) - 2 );
                    timePart = that.trim( timePart );
                    datePart = value.substring( 0, value.toUpperCase().indexOf( "PM" ) - 2 );
                }
                var parseDate = new Date();
                var parsed = false;
                if ( datePart ) {
                    for ( var i = 0; i < splitParts.length; i++ ) {
                        if ( datePart.indexOf( splitParts[ i ] ) >= 0 ) {
                            dateParts = datePart.split( splitParts[ i ] );
                            break;
                        }
                    }

                    var days = new Array();
                    var months = new Array();
                    var years = new Array();
                    var dayPart = null;
                    var monthPart = null;
                    for ( var i = 0; i < dateParts.length; i++ ) {
                        var part = dateParts[ i ];
                        var isDay = that.parsedate( part, "d", calendar ) || that.parsedate( part, "dd", calendar ) || that.parsedate( part, "ddd", calendar ) || that.parsedate( part, "dddd", calendar );
                        if ( isDay ) {
                            if ( part.length <= 2 ) {
                                dayPart = i;
                                days.push( isDay.getDate() );
                                break
                            }
                        }
                    }
                    for ( var i = 0; i < dateParts.length; i++ ) {
                        var part = dateParts[ i ];
                        var isMonth = that.parsedate( part, "M", calendar ) || that.parsedate( part, "MM", calendar ) || that.parsedate( part, "MMM", calendar ) || that.parsedate( part, "MMMM", calendar );
                        if ( isMonth ) {
                            if ( dayPart != undefined && dayPart == i )
                                continue;

                            months.push( isMonth.getMonth() );

                            if ( part.length > 2 ) {
                                monthPart = i;
                                break;
                            }
                        }
                    }
                    for ( var i = 0; i < dateParts.length; i++ ) {
                        var part = dateParts[ i ];
                        var isYear = that.parsedate( part, "yyyy", calendar );
                        if ( isYear ) {
                            if ( dayPart != undefined && dayPart == i )
                                continue;

                            if ( monthPart != undefined && monthPart == i )
                                continue;

                            years.push( isYear.getFullYear() );
                        }
                    }
                    var dates = new Array();
                    for ( var d = 0; d < days.length; d++ ) {
                        for ( var m = 0; m < months.length; m++ ) {
                            for ( var y = 0; y < years.length; y++ ) {
                                var result = new Date( years[ y ], months[ m ], days[ d ] );
                                if ( years[ y ] < 1970 )
                                    result.setFullYear( years[ y ] );
                                if ( result.getTime() != NaN ) {
                                    dates.push( result );
                                }
                            }
                        }
                    }
                    if ( dates.length > 0 ) {
                        parseDate = dates[ 0 ];
                        parsed = true;
                    }
                }
                if ( timePart ) {
                    var timeParts = timePart.indexOf( ":" ) >= 0 ? timePart.split( ':' ) : timePart;
                    var parsedTime = that.parsedate( timePart, "h:mm tt", calendar ) || that.parsedate( timePart, "h:mm:ss tt", calendar ) || that.parsedate( timePart, "HH:mm:ss.fff", calendar ) || that.parsedate( timePart, "HH:mm:ss.ff", calendar ) || that.parsedate( timePart, "HH:mm:ss.tttt", calendar ) || that.parsedate( timePart, "HH:mm:ss", calendar ) || that.parsedate( timePart, "HH:mm", calendar ) || that.parsedate( timePart, "HH", calendar );

                    var hour = 0, minute = 0, second = 0, milisecond = 0;
                    if ( parsedTime && parsedTime.getTime() != NaN ) {
                        hour = parsedTime.getHours();
                        minute = parsedTime.getMinutes();
                        second = parsedTime.getSeconds();
                        milisecond = parsedTime.getMilliseconds();
                    }
                    else {
                        if ( timeParts.length == 1 ) {
                            hour = parseInt( timeParts[ 0 ] );
                        }
                        if ( timeParts.length == 2 ) {
                            hour = parseInt( timeParts[ 0 ] );
                            minute = parseInt( timeParts[ 1 ] );
                        }
                        if ( timeParts.length == 3 ) {
                            hour = parseInt( timeParts[ 0 ] );
                            minute = parseInt( timeParts[ 1 ] );
                            if ( timeParts[ 2 ].indexOf( "." ) >= 0 ) {
                                second = parseInt( timeParts[ 2 ].toString().split( "." )[ 0 ] );
                                milisecond = parseInt( timeParts[ 2 ].toString().split( "." )[ 1 ] );
                            }
                            else {
                                second = parseInt( timeParts[ 2 ] );
                            }
                        }
                        if ( timeParts.length == 4 ) {
                            hour = parseInt( timeParts[ 0 ] );
                            minute = parseInt( timeParts[ 1 ] );
                            second = parseInt( timeParts[ 2 ] );
                            milisecond = parseInt( timeParts[ 3 ] );
                        }
                    }
                    if ( parseDate && !isNaN( hour ) && !isNaN( minute ) && !isNaN( second ) && !isNaN( milisecond ) ) {
                        parseDate.setHours( hour, minute, second, milisecond );
                        parsed = true;
                    }
                }
                if ( parsed ) {
                    return parseDate;
                }
            }

            return null;
        },

        getparseregexp: function ( cal, format ) {
            // converts a format string into a regular expression with groups that
            // can be used to extract date fields from a date string.
            // check for a cached parse regex.
            var re = cal._parseRegExp;
            if ( !re ) {
                cal._parseRegExp = re = {};
            }
            else {
                var reFormat = re[ format ];
                if ( reFormat ) {
                    return reFormat;
                }
            }

            // expand single digit formats, then escape regular expression characters.
            var expFormat = this.expandFormat( cal, format ).replace( /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\\\$1" ),
                regexp = [ "^" ],
                groups = [],
                index = 0,
                quoteCount = 0,
                tokenRegExp = this.getTokenRegExp(),
                match;

            // iterate through each date token found.
            while ( ( match = tokenRegExp.exec( expFormat ) ) !== null ) {
                var preMatch = expFormat.slice( index, match.index );
                index = tokenRegExp.lastIndex;

                // don't replace any matches that occur inside a string literal.
                quoteCount += this.appendPreOrPostMatch( preMatch, regexp );
                if ( quoteCount % 2 ) {
                    regexp.push( match[ 0 ] );
                    continue;
                }

                // add a regex group for the token.
                var m = match[ 0 ],
                    len = m.length,
                    add;
                switch ( m ) {
                    case 'dddd': case 'ddd':
                    case 'MMMM': case 'MMM':
                    case 'gg': case 'g':
                        add = "(\\D+)";
                        break;
                    case 'tt': case 't':
                        add = "(\\D*)";
                        break;
                    case 'yyyy':
                    case 'fff':
                    case 'ff':
                    case 'f':
                        add = "(\\d{" + len + "})";
                        break;
                    case 'dd': case 'd':
                    case 'MM': case 'M':
                    case 'yy': case 'y':
                    case 'HH': case 'H':
                    case 'hh': case 'h':
                    case 'mm': case 'm':
                    case 'ss': case 's':
                        add = "(\\d\\d?)";
                        break;
                    case 'zzz':
                        add = "([+-]?\\d\\d?:\\d{2})";
                        break;
                    case 'zz': case 'z':
                        add = "([+-]?\\d\\d?)";
                        break;
                    case '/':
                        add = "(\\" + cal[ "/" ] + ")";
                        break;
                    default:
                        throw "Invalid date format pattern '" + m + "'.";
                        break;
                }
                if ( add ) {
                    regexp.push( add );
                }
                groups.push( match[ 0 ] );
            }
            this.appendPreOrPostMatch( expFormat.slice( index ), regexp );
            regexp.push( "$" );

            // allow whitespace to differ when matching formats.
            var regexpStr = regexp.join( '' ).replace( /\s+/g, "\\s+" ),
                parseRegExp = { 'regExp': regexpStr, 'groups': groups };

            // cache the regex for this format.
            return re[ format ] = parseRegExp;
        },

        outOfRange: function ( value, low, high ) {
            return value < low || value > high;
        },

        expandYear: function ( cal, year ) {
            // expands 2-digit year into 4 digits.
            var now = new Date(),
                era = this.getEra( now );
            if ( year < 100 ) {
                var twoDigitYearMax = cal.twoDigitYearMax;
                twoDigitYearMax = typeof twoDigitYearMax === 'string' ? new Date().getFullYear() % 100 + parseInt( twoDigitYearMax, 10 ) : twoDigitYearMax;
                var curr = this.getEraYear( now, cal, era );
                year += curr - ( curr % 100 );
                if ( year > twoDigitYearMax ) {
                    year -= 100;
                }
            }
            return year;
        },

        parsedate: function ( value, format, calendar ) {
            if ( calendar == undefined || calendar == null ) {
                calendar = this.defaultcalendar();
            }
            // try to parse the date string by matching against the format string
            // while using the specified culture for date field names.
            value = this.trim( value );
            var cal = calendar,
                // convert date formats into regular expressions with groupings.
                // use the regexp to determine the input format and extract the date fields.
                parseInfo = this.getparseregexp( cal, format ),
                match = new RegExp( parseInfo.regExp ).exec( value );
            if ( match === null ) {
                return null;
            }
            // found a date format that matches the input.
            var groups = parseInfo.groups,
                era = null, year = null, month = null, date = null, weekDay = null,
                hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,
                pmHour = false;
            // iterate the format groups to extract and set the date fields.
            for ( var j = 0, jl = groups.length; j < jl; j++ ) {
                var matchGroup = match[ j + 1 ];
                if ( matchGroup ) {
                    var current = groups[ j ],
                        clength = current.length,
                        matchInt = parseInt( matchGroup, 10 );
                    switch ( current ) {
                        case 'dd': case 'd':
                            // Day of month.
                            date = matchInt;
                            // check that date is generally in valid range, also checking overflow below.
                            if ( this.outOfRange( date, 1, 31 ) ) return null;
                            break;
                        case 'MMM':
                        case 'MMMM':
                            month = this.getMonthIndex( cal, matchGroup, clength === 3 );
                            if ( this.outOfRange( month, 0, 11 ) ) return null;
                            break;
                        case 'M': case 'MM':
                            // Month.
                            month = matchInt - 1;
                            if ( this.outOfRange( month, 0, 11 ) ) return null;
                            break;
                        case 'y': case 'yy':
                        case 'yyyy':
                            year = clength < 4 ? this.expandYear( cal, matchInt ) : matchInt;
                            if ( this.outOfRange( year, 0, 9999 ) ) return null;
                            break;
                        case 'h': case 'hh':
                            // Hours (12-hour clock).
                            hour = matchInt;
                            if ( hour === 12 ) hour = 0;
                            if ( this.outOfRange( hour, 0, 11 ) ) return null;
                            break;
                        case 'H': case 'HH':
                            // Hours (24-hour clock).
                            hour = matchInt;
                            if ( this.outOfRange( hour, 0, 23 ) ) return null;
                            break;
                        case 'm': case 'mm':
                            // Minutes.
                            min = matchInt;
                            if ( this.outOfRange( min, 0, 59 ) ) return null;
                            break;
                        case 's': case 'ss':
                            // Seconds.
                            sec = matchInt;
                            if ( this.outOfRange( sec, 0, 59 ) ) return null;
                            break;
                        case 'tt': case 't':
                            // AM/PM designator.
                            // see if it is standard, upper, or lower case PM. If not, ensure it is at least one of
                            // the AM tokens. If not, fail the parse for this format.
                            pmHour = cal.PM && ( matchGroup === cal.PM[ 0 ] || matchGroup === cal.PM[ 1 ] || matchGroup === cal.PM[ 2 ] );
                            if ( !pmHour && ( !cal.AM || ( matchGroup !== cal.AM[ 0 ] && matchGroup !== cal.AM[ 1 ] && matchGroup !== cal.AM[ 2 ] ) ) ) return null;
                            break;
                        case 'f':
                        // Deciseconds.
                        case 'ff':
                        // Centiseconds.
                        case 'fff':
                            // Milliseconds.
                            msec = matchInt * Math.pow( 10, 3 - clength );
                            if ( this.outOfRange( msec, 0, 999 ) ) return null;
                            break;
                        case 'ddd':
                        // Day of week.
                        case 'dddd':
                            // Day of week.
                            weekDay = this.getDayIndex( cal, matchGroup, clength === 3 );
                            if ( this.outOfRange( weekDay, 0, 6 ) ) return null;
                            break;
                        case 'zzz':
                            // Time zone offset in +/- hours:min.
                            var offsets = matchGroup.split( /:/ );
                            if ( offsets.length !== 2 ) return null;
                            hourOffset = parseInt( offsets[ 0 ], 10 );
                            if ( this.outOfRange( hourOffset, -12, 13 ) ) return null;
                            var minOffset = parseInt( offsets[ 1 ], 10 );
                            if ( this.outOfRange( minOffset, 0, 59 ) ) return null;
                            tzMinOffset = ( hourOffset * 60 ) + ( this.startsWith( matchGroup, '-' ) ? -minOffset : minOffset );
                            break;
                        case 'z': case 'zz':
                            // Time zone offset in +/- hours.
                            hourOffset = matchInt;
                            if ( this.outOfRange( hourOffset, -12, 13 ) ) return null;
                            tzMinOffset = hourOffset * 60;
                            break;
                        case 'g': case 'gg':
                            var eraName = matchGroup;
                            if ( !eraName || !cal.eras ) return null;
                            eraName = this.trim( eraName.toLowerCase() );
                            for ( var i = 0, l = cal.eras.length; i < l; i++ ) {
                                if ( eraName === cal.eras[ i ].name.toLowerCase() ) {
                                    era = i;
                                    break;
                                }
                            }
                            // could not find an era with that name
                            if ( era === null ) return null;
                            break;
                    }
                }
            }
            var result = new Date(), defaultYear, convert = cal.convert;
            defaultYear = result.getFullYear();
            if ( year === null ) {
                year = defaultYear;
            }
            else if ( cal.eras ) {
                // year must be shifted to normal gregorian year
                // but not if year was not specified, its already normal gregorian
                // per the main if clause above.
                year += cal.eras[ ( era || 0 ) ].offset;
            }
            // set default day and month to 1 and January, so if unspecified, these are the defaults
            // instead of the current day/month.
            if ( month === null ) {
                month = 0;
            }
            if ( date === null ) {
                date = 1;
            }
            // now have year, month, and date, but in the culture's calendar.
            // convert to gregorian if necessary
            if ( convert ) {
                result = convert.toGregorian( year, month, date );
                // conversion failed, must be an invalid match
                if ( result === null ) return null;
            }
            else {
                // have to set year, month and date together to avoid overflow based on current date.
                result.setFullYear( year, month, date );
                // check to see if date overflowed for specified month (only checked 1-31 above).
                if ( result.getDate() !== date ) return null;
                // invalid day of week.
                if ( weekDay !== null && result.getDay() !== weekDay ) {
                    return null;
                }
            }
            // if pm designator token was found make sure the hours fit the 24-hour clock.
            if ( pmHour && hour < 12 ) {
                hour += 12;
            }
            result.setHours( hour, min, sec, msec );
            if ( tzMinOffset !== null ) {
                // adjust timezone to utc before applying local offset.
                var adjustedMin = result.getMinutes() - ( tzMinOffset + result.getTimezoneOffset() );
                // Safari limits hours and minutes to the range of -127 to 127.  We need to use setHours
                // to ensure both these fields will not exceed this range.  adjustedMin will range
                // somewhere between -1440 and 1500, so we only need to split this into hours.
                result.setHours( result.getHours() + parseInt( adjustedMin / 60, 10 ), adjustedMin % 60 );
            }
            return result;
        },

        cleardatescache: function () {
            this.datescache = new Array();
        },

        formatDate: function ( value, format, calendar ) {
            return this.formatdate( value, format, calendar );
        },

        formatdate: function ( value, format, calendar ) {
            if ( calendar == undefined || calendar == null ) {
                calendar = this.defaultcalendar();
            }

            if ( typeof value === 'string' ) {
                return value;
            }

            var lookupkey = value.toString() + "_" + format;
            if ( this.datescache && this.datescache[ lookupkey ] ) {
                if ( format.indexOf( 'f' ) == -1 ) {
                    return this.datescache[ lookupkey ];
                }
            }

            if ( !format || !format.length || format === 'i' ) {
                var ret;
                ret = this.formatDate( value, calendar.patterns.F, calendar );
                return ret;
            }

            var eras = calendar.eras,
                sortable = format === "s";
            format = this.expandFormat( calendar, format );

            // Start with an empty string
            ret = [];
            var hour,
                zeros = [ '0', '00', '000' ],
                foundDay,
                checkedDay,
                dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,
                quoteCount = 0,
                tokenRegExp = this.getTokenRegExp(),
                converted;

            function padZeros( num, c ) {
                var r, s = num + '';
                if ( c > 1 && s.length < c ) {
                    r = ( zeros[ c - 2 ] + s );
                    return r.substr( r.length - c, c );
                }
                else {
                    r = s;
                }
                return r;
            }

            function hasDay() {
                if ( foundDay || checkedDay ) {
                    return foundDay;
                }
                foundDay = dayPartRegExp.test( format );
                checkedDay = true;
                return foundDay;
            }

            function getPart( date, part ) {
                if ( converted ) {
                    return converted[ part ];
                }
                if ( date.getMonth != undefined ) {
                    switch ( part ) {
                        case 0: return date.getFullYear();
                        case 1: return date.getMonth();
                        case 2: return date.getDate();
                    }
                }
            }

            for ( ; ; ) {
                // Save the current index
                var index = tokenRegExp.lastIndex,
                    // Look for the next pattern
                    ar = tokenRegExp.exec( format );

                // Append the text before the pattern (or the end of the string if not found)
                var preMatch = format.slice( index, ar ? ar.index : format.length );
                quoteCount += this.appendPreOrPostMatch( preMatch, ret );

                if ( !ar ) {
                    break;
                }

                // do not replace any matches that occur inside a string literal.
                if ( quoteCount % 2 ) {
                    ret.push( ar[ 0 ] );
                    continue;
                }

                var current = ar[ 0 ],
                    clength = current.length;

                switch ( current ) {
                    case "ddd":
                    //Day of the week, as a three-letter abbreviation
                    case "dddd":
                        // Day of the week, using the full name
                        var names = ( clength === 3 ) ? calendar.days.namesAbbr : calendar.days.names;
                        ret.push( names[ value.getDay() ] );
                        break;
                    case "d":
                    // Day of month, without leading zero for single-digit days
                    case "dd":
                        // Day of month, with leading zero for single-digit days
                        foundDay = true;
                        ret.push( padZeros( getPart( value, 2 ), clength ) );
                        break;
                    case "MMM":
                    // Month, as a three-letter abbreviation
                    case "MMMM":
                        // Month, using the full name
                        var part = getPart( value, 1 );
                        ret.push( calendar.months[ clength === 3 ? "namesAbbr" : "names" ][ part ] );
                        break;
                    case "M":
                    // Month, as digits, with no leading zero for single-digit months
                    case "MM":
                        // Month, as digits, with leading zero for single-digit months
                        ret.push( padZeros( getPart( value, 1 ) + 1, clength ) );
                        break;
                    case "y":
                    // Year, as two digits, but with no leading zero for years less than 10
                    case "yy":
                    // Year, as two digits, with leading zero for years less than 10
                    case "yyyy":
                        // Year represented by four full digits
                        part = this.getEraYear( value, calendar, this.getEra( value, eras ), sortable );
                        if ( clength < 4 ) {
                            part = part % 100;
                        }
                        ret.push( padZeros( part, clength ) );
                        break;
                    case "h":
                    // Hours with no leading zero for single-digit hours, using 12-hour clock
                    case "hh":
                        // Hours with leading zero for single-digit hours, using 12-hour clock
                        hour = value.getHours() % 12;
                        if ( hour === 0 ) hour = 12;
                        ret.push( padZeros( hour, clength ) );
                        break;
                    case "H":
                    // Hours with no leading zero for single-digit hours, using 24-hour clock
                    case "HH":
                        // Hours with leading zero for single-digit hours, using 24-hour clock
                        ret.push( padZeros( value.getHours(), clength ) );
                        break;
                    case "m":
                    // Minutes with no leading zero  for single-digit minutes
                    case "mm":
                        // Minutes with leading zero  for single-digit minutes
                        ret.push( padZeros( value.getMinutes(), clength ) );
                        break;
                    case "s":
                    // Seconds with no leading zero for single-digit seconds
                    case "ss":
                        // Seconds with leading zero for single-digit seconds
                        ret.push( padZeros( value.getSeconds(), clength ) );
                        break;
                    case "t":
                    // One character am/pm indicator ("a" or "p")
                    case "tt":
                        // Multicharacter am/pm indicator
                        part = value.getHours() < 12 ? ( calendar.AM ? calendar.AM[ 0 ] : " " ) : ( calendar.PM ? calendar.PM[ 0 ] : " " );
                        ret.push( clength === 1 ? part.charAt( 0 ) : part );
                        break;
                    case "f":
                    // Deciseconds
                    case "ff":
                    // Centiseconds
                    case "fff":
                        // Milliseconds
                        ret.push( padZeros( value.getMilliseconds(), 3 ).substr( 0, clength ) );
                        break;
                    case "z":
                    // Time zone offset, no leading zero
                    case "zz":
                        // Time zone offset with leading zero
                        hour = value.getTimezoneOffset() / 60;
                        ret.push( ( hour <= 0 ? '+' : '-' ) + padZeros( Math.floor( Math.abs( hour ) ), clength ) );
                        break;
                    case "zzz":
                        // Time zone offset with leading zero
                        hour = value.getTimezoneOffset() / 60;
                        ret.push( ( hour <= 0 ? '+' : '-' ) + padZeros( Math.floor( Math.abs( hour ) ), 2 ) +
                            // Hard coded ":" separator, rather than using calendar.TimeSeparator
                            // Repeated here for consistency, plus ":" was already assumed in date parsing.
                            ":" + padZeros( Math.abs( value.getTimezoneOffset() % 60 ), 2 ) );
                        break;
                    case "g":
                    case "gg":
                        if ( calendar.eras ) {
                            ret.push( calendar.eras[ this.getEra( value, eras ) ].name );
                        }
                        break;
                    case "/":
                        ret.push( calendar[ "/" ] );
                        break;
                    default:
                        throw "Invalid date format pattern '" + current + "'.";
                        break;
                }
            }

            var result = ret.join( '' );

            if ( !this.datescache ) {
                this.datescache = new Array();
            }

            this.datescache[ lookupkey ] = result;
            return result;
        }
    } );

    // AJAX
    $.jqx.data = {};
    var
        ajaxLocParts,
        ajaxLocation,

        rhash = /#.*$/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,
        rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rquery = /\?/,
        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        rts = /([?&])_=[^&]*/,
        rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
        core_rspace = /\s+/,
        _load = $.fn.load,
        prefilters = {},
        transports = {},
        allTypes = [ "*/" ] + [ "*" ];

    try {
        ajaxLocation = location.href;
    } catch ( e ) {
        ajaxLocation = document.createElement( "a" );
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

    ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

    function addToPrefiltersOrTransports( structure ) {

        return function ( dataTypeExpression, func ) {

            if ( typeof dataTypeExpression !== "string" ) {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType, list, placeBefore,
                dataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),
                i = 0,
                length = dataTypes.length;

            if ( $.isFunction( func ) ) {
                for ( ; i < length; i++ ) {
                    dataType = dataTypes[ i ];
                    placeBefore = /^\+/.test( dataType );
                    if ( placeBefore ) {
                        dataType = dataType.substr( 1 ) || "*";
                    }
                    list = structure[ dataType ] = structure[ dataType ] || [];
                    list[ placeBefore ? "unshift" : "push" ]( func );
                }
            }
        };
    }

    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
        dataType /* internal */, inspected /* internal */ ) {

        dataType = dataType || options.dataTypes[ 0 ];
        inspected = inspected || {};

        inspected[ dataType ] = true;

        var selection,
            list = structure[ dataType ],
            i = 0,
            length = list ? list.length : 0,
            executeOnly = ( structure === prefilters );

        for ( ; i < length && ( executeOnly || !selection ); i++ ) {
            selection = list[ i ]( options, originalOptions, jqXHR );
            if ( typeof selection === "string" ) {
                if ( !executeOnly || inspected[ selection ] ) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift( selection );
                    selection = inspectPrefiltersOrTransports(
                        structure, options, originalOptions, jqXHR, selection, inspected );
                }
            }
        }
        if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
            selection = inspectPrefiltersOrTransports(
                structure, options, originalOptions, jqXHR, "*", inspected );
        }
        return selection;
    }

    function ajaxExtend( target, src ) {
        var key, deep,
            flatOptions = $.jqx.data.ajaxSettings.flatOptions || {};
        for ( key in src ) {
            if ( src[ key ] !== undefined ) {
                ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
            }
        }
        if ( deep ) {
            $.extend( true, target, deep );
        }
    }

    $.extend( $.jqx.data, {
        ajaxSetup: function ( target, settings ) {
            if ( settings ) {
                ajaxExtend( target, $.jqx.data.ajaxSettings );
            } else {
                settings = target;
                target = $.jqx.data.ajaxSettings;
            }
            ajaxExtend( target, settings );
            return target;
        },

        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            processData: true,
            async: true,

            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": allTypes
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },

            converters: {
                "* text": window.String,
                "text html": true,
                "text json": $.parseJSON,
                "text xml": $.parseXML
            },

            flatOptions: {
                context: true,
                url: true
            }
        },

        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
        ajaxTransport: addToPrefiltersOrTransports( transports ),

        ajax: function ( url, options ) {

            if ( typeof url === "object" ) {
                options = url;
                url = undefined;
            }

            options = options || {};

            var ifModifiedKey,
                responseHeadersString,
                responseHeaders,
                transport,
                timeoutTimer,
                parts,
                fireGlobals,
                i,
                s = $.jqx.data.ajaxSetup( {}, options ),
                callbackContext = s.context || s,
                globalEventContext = callbackContext !== s &&
                    ( callbackContext.nodeType || callbackContext instanceof $ ) ?
                    $( callbackContext ) : $.event,
                deferred = $.Deferred(),
                completeDeferred = $.Callbacks( "once memory" ),
                statusCode = s.statusCode || {},
                requestHeaders = {},
                requestHeadersNames = {},
                state = 0,
                strAbort = "canceled",
                jqXHR = {
                    readyState: 0,
                    setRequestHeader: function ( name, value ) {
                        if ( !state ) {
                            var lname = name.toLowerCase();
                            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                            requestHeaders[ name ] = value;
                        }
                        return this;
                    },
                    getAllResponseHeaders: function () {
                        return state === 2 ? responseHeadersString : null;
                    },
                    getResponseHeader: function ( key ) {
                        var match;
                        if ( state === 2 ) {
                            if ( !responseHeaders ) {
                                responseHeaders = {};
                                while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                    responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
                                }
                            }
                            match = responseHeaders[ key.toLowerCase() ];
                        }
                        return match === undefined ? null : match;
                    },

                    overrideMimeType: function ( type ) {
                        if ( !state ) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    abort: function ( statusText ) {
                        statusText = statusText || strAbort;
                        if ( transport ) {
                            transport.abort( statusText );
                        }
                        done( 0, statusText );
                        return this;
                    }
                };

            function done( status, nativeStatusText, responses, headers ) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;

                if ( state === 2 ) {
                    return;
                }

                state = 2;
                if ( timeoutTimer ) {
                    clearTimeout( timeoutTimer );
                }

                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;

                if ( responses ) {
                    response = ajaxHandleResponses( s, jqXHR, responses );
                }

                if ( status >= 200 && status < 300 || status === 304 ) {

                    if ( s.ifModified ) {

                        modified = jqXHR.getResponseHeader( "Last-Modified" );
                        if ( modified ) {
                            $.lastModified[ ifModifiedKey ] = modified;
                        }
                        modified = jqXHR.getResponseHeader( "Etag" );
                        if ( modified ) {
                            $.etag[ ifModifiedKey ] = modified;
                        }
                    }

                    if ( status === 304 ) {
                        statusText = "notmodified";
                        isSuccess = true;
                    } else {

                        isSuccess = ajaxConvert( s, response );
                        statusText = isSuccess.state;
                        success = isSuccess.data;
                        error = isSuccess.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if ( !statusText || status ) {
                        statusText = "error";
                        if ( status < 0 ) {
                            status = 0;
                        }
                    }
                }

                jqXHR.status = status;
                jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                if ( isSuccess ) {
                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                } else {
                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                }

                jqXHR.statusCode( statusCode );
                statusCode = undefined;

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
                        [ jqXHR, s, isSuccess ? success : error ] );
                }

                completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                    if ( !( --$.active ) ) {
                        $.event.trigger( "ajaxStop" );
                    }
                }
            }

            deferred.promise( jqXHR );
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.add;

            jqXHR.statusCode = function ( map ) {
                if ( map ) {
                    var tmp;
                    if ( state < 2 ) {
                        for ( tmp in map ) {
                            statusCode[ tmp ] = [ statusCode[ tmp ], map[ tmp ] ];
                        }
                    } else {
                        tmp = map[ jqXHR.status ];
                        jqXHR.always( tmp );
                    }
                }
                return this;
            };

            s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
            s.dataTypes = $.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );

            if ( s.crossDomain == null ) {
                parts = rurl.exec( s.url.toLowerCase() );
                s.crossDomain = !!( parts &&
                    ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                        ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
                );
            }

            if ( s.data && s.processData && typeof s.data !== "string" ) {
                s.data = $.param( s.data, s.traditional );
            }

            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

            if ( state === 2 ) {
                return jqXHR;
            }

            fireGlobals = s.global;
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test( s.type );

            if ( fireGlobals && $.active++ === 0 ) {
                $.event.trigger( "ajaxStart" );
            }

            if ( !s.hasContent ) {
                if ( s.data ) {
                    s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
                    delete s.data;
                }

                ifModifiedKey = s.url;

                if ( s.cache === false ) {

                    var ts = ( new Date() ).getTime(),
                        ret = s.url.replace( rts, "$1_=" + ts );

                    s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
                }
            }

            if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                jqXHR.setRequestHeader( "Content-Type", s.contentType );
            }

            if ( s.ifModified ) {
                ifModifiedKey = ifModifiedKey || s.url;
                if ( $.lastModified[ ifModifiedKey ] ) {
                    jqXHR.setRequestHeader( "If-Modified-Since", $.lastModified[ ifModifiedKey ] );
                }
                if ( $.etag[ ifModifiedKey ] ) {
                    jqXHR.setRequestHeader( "If-None-Match", $.etag[ ifModifiedKey ] );
                }
            }

            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
                    s.accepts[ s.dataTypes[ 0 ] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts[ "*" ]
            );

            for ( i in s.headers ) {
                jqXHR.setRequestHeader( i, s.headers[ i ] );
            }

            if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                return jqXHR.abort();

            }

            strAbort = "abort";

            for ( i in { success: 1, error: 1, complete: 1 } ) {
                jqXHR[ i ]( s[ i ] );
            }

            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

            if ( !transport ) {
                done( -1, "No Transport" );
            } else {
                jqXHR.readyState = 1;
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                }
                if ( s.async && s.timeout > 0 ) {
                    timeoutTimer = setTimeout( function () {
                        jqXHR.abort( "timeout" );
                    }, s.timeout );
                }

                try {
                    state = 1;
                    transport.send( requestHeaders, done );
                } catch ( e ) {
                    if ( state < 2 ) {
                        done( -1, e );
                    } else {
                        throw e;
                    }
                }
            }

            return jqXHR;
        },

        active: 0,

        lastModified: {},
        etag: {}

    } );

    function ajaxHandleResponses( s, jqXHR, responses ) {

        var ct, type, finalDataType, firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes,
            responseFields = s.responseFields;

        for ( type in responseFields ) {
            if ( type in responses ) {
                jqXHR[ responseFields[ type ] ] = responses[ type ];
            }
        }

        while ( dataTypes[ 0 ] === "*" ) {
            dataTypes.shift();
            if ( ct === undefined ) {
                ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
            }
        }

        if ( ct ) {
            for ( type in contents ) {
                if ( contents[ type ] && contents[ type ].test( ct ) ) {
                    dataTypes.unshift( type );
                    break;
                }
            }
        }

        if ( dataTypes[ 0 ] in responses ) {
            finalDataType = dataTypes[ 0 ];
        } else {
            for ( type in responses ) {
                if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
                    finalDataType = type;
                    break;
                }
                if ( !firstDataType ) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }

        if ( finalDataType ) {
            if ( finalDataType !== dataTypes[ 0 ] ) {
                dataTypes.unshift( finalDataType );
            }
            return responses[ finalDataType ];
        }
    }

    function ajaxConvert( s, response ) {
        var conv, conv2, current, tmp,
            dataTypes = s.dataTypes.slice(),
            prev = dataTypes[ 0 ],
            converters = {},
            i = 0;

        if ( s.dataFilter ) {
            response = s.dataFilter( response, s.dataType );
        }

        if ( dataTypes[ 1 ] ) {
            for ( conv in s.converters ) {
                converters[ conv.toLowerCase() ] = s.converters[ conv ];
            }
        }

        for ( ; ( current = dataTypes[ ++i ] ); ) {
            if ( current !== "*" ) {
                if ( prev !== "*" && prev !== current ) {
                    conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                    if ( !conv ) {
                        for ( conv2 in converters ) {
                            tmp = conv2.split( " " );
                            if ( tmp[ 1 ] === current ) {
                                conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                    converters[ "* " + tmp[ 0 ] ];
                                if ( conv ) {
                                    if ( conv === true ) {
                                        conv = converters[ conv2 ];

                                    } else if ( converters[ conv2 ] !== true ) {
                                        current = tmp[ 0 ];
                                        dataTypes.splice( i--, 0, current );
                                    }

                                    break;
                                }
                            }
                        }
                    }

                    if ( conv !== true ) {
                        if ( conv && s[ "throws" ] ) {
                            response = conv( response );
                        } else {
                            try {
                                response = conv( response );
                            } catch ( e ) {
                                return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                            }
                        }
                    }
                }

                prev = current;
            }
        }

        return { state: "success", data: response };
    }
    var oldCallbacks = [],
        rquestion = /\?/,
        rjsonp = /(=)\?(?=&|$)|\?\?/,
        nonce = ( new Date() ).getTime();

    $.jqx.data.ajaxSetup( {
        jsonp: "callback",
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || ( $.expando + "_" + ( nonce++ ) );
            this[ callback ] = true;
            return callback;
        }
    } );

    $.jqx.data.ajaxPrefilter( "json jsonp", function ( s, originalSettings, jqXHR ) {

        var callbackName, overwritten, responseContainer,
            data = s.data,
            url = s.url,
            hasCallback = s.jsonp !== false,
            replaceInUrl = hasCallback && rjsonp.test( url ),
            replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
                !( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) &&
                rjsonp.test( data );

        if ( s.dataTypes[ 0 ] === "jsonp" || replaceInUrl || replaceInData ) {

            callbackName = s.jsonpCallback = $.isFunction( s.jsonpCallback ) ?
                s.jsonpCallback() :
                s.jsonpCallback;
            overwritten = window[ callbackName ];

            if ( replaceInUrl ) {
                s.url = url.replace( rjsonp, "$1" + callbackName );
            } else if ( replaceInData ) {
                s.data = data.replace( rjsonp, "$1" + callbackName );
            } else if ( hasCallback ) {
                s.url += ( rquestion.test( url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
            }

            s.converters[ "script json" ] = function () {
                if ( !responseContainer ) {
                    $.error( callbackName + " was not called" );
                }
                return responseContainer[ 0 ];
            };

            s.dataTypes[ 0 ] = "json";

            window[ callbackName ] = function () {
                responseContainer = arguments;
            };

            jqXHR.always( function () {
                window[ callbackName ] = overwritten;
                if ( s[ callbackName ] ) {
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    oldCallbacks.push( callbackName );
                }

                if ( responseContainer && $.isFunction( overwritten ) ) {
                    overwritten( responseContainer[ 0 ] );
                }

                responseContainer = overwritten = undefined;
            } );

            return "script";
        }
    } );

    $.jqx.data.ajaxSetup( {
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function ( text ) {
                $.globalEval( text );
                return text;
            }
        }
    } );

    $.jqx.data.ajaxPrefilter( "script", function ( s ) {
        if ( s.cache === undefined ) {
            s.cache = false;
        }
        if ( s.crossDomain ) {
            s.type = "GET";
            s.global = false;
        }
    } );

    $.jqx.data.ajaxTransport( "script", function ( s ) {
        if ( s.crossDomain ) {
            var script,
                head = document.head || document.getElementsByTagName( "head" )[ 0 ] || document.documentElement;

            return {

                send: function ( _, callback ) {

                    script = document.createElement( "script" );

                    script.async = "async";

                    if ( s.scriptCharset ) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    script.onload = script.onreadystatechange = function ( _, isAbort ) {

                        if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                            script.onload = script.onreadystatechange = null;

                            if ( head && script.parentNode ) {
                                head.removeChild( script );
                            }

                            script = undefined;

                            if ( !isAbort ) {
                                callback( 200, "success" );
                            }
                        }
                    };
                    head.insertBefore( script, head.firstChild );
                },

                abort: function () {
                    if ( script ) {
                        script.onload( 0, 1 );
                    }
                }
            };
        }
    } );
    var xhrCallbacks,
        xhrOnUnloadAbort = window.ActiveXObject ? function () {
            for ( var key in xhrCallbacks ) {
                xhrCallbacks[ key ]( 0, 1 );
            }
        } : false,
        xhrId = 0;

    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch ( e ) { }
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject( "Microsoft.XMLHTTP" );
        } catch ( e ) { }
    }

    $.jqx.data.ajaxSettings.xhr = window.ActiveXObject ?
        function () {
            return !this.isLocal && createStandardXHR() || createActiveXHR();
        } :
        createStandardXHR;

    ( function ( xhr ) {
        $.extend( $.support, {
            ajax: !!xhr,
            cors: !!xhr && ( "withCredentials" in xhr )
        } );
    } )( $.jqx.data.ajaxSettings.xhr() );

    if ( !$.support ) $.support = { ajax: true };
    if ( $.support.ajax ) {

        $.jqx.data.ajaxTransport( function ( s ) {
            if ( !s.crossDomain || $.support.cors ) {

                var callback;

                return {
                    send: function ( headers, complete ) {

                        var handle, i,
                            xhr = s.xhr();

                        if ( s.username ) {
                            xhr.open( s.type, s.url, s.async, s.username, s.password );
                        } else {
                            xhr.open( s.type, s.url, s.async );
                        }

                        if ( s.xhrFields ) {
                            for ( i in s.xhrFields ) {
                                xhr[ i ] = s.xhrFields[ i ];
                            }
                        }

                        if ( s.mimeType && xhr.overrideMimeType ) {
                            xhr.overrideMimeType( s.mimeType );
                        }


                        if ( !s.crossDomain && !headers[ "X-Requested-With" ] ) {
                            headers[ "X-Requested-With" ] = "XMLHttpRequest";
                        }

                        try {
                            for ( i in headers ) {
                                xhr.setRequestHeader( i, headers[ i ] );
                            }
                        } catch ( _ ) { }

                        xhr.send( ( s.hasContent && s.data ) || null );

                        callback = function ( _, isAbort ) {

                            var status,
                                statusText,
                                responseHeaders,
                                responses,
                                xml;
                            try {

                                if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
                                    callback = undefined;
                                    if ( handle ) {
                                        xhr.onreadystatechange = function () { };
                                        if ( xhrOnUnloadAbort ) {
                                            delete xhrCallbacks[ handle ];
                                        }
                                    }

                                    if ( isAbort ) {
                                        if ( xhr.readyState !== 4 ) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;

                                        if ( xml && xml.documentElement /* #4958 */ ) {
                                            responses.xml = xml;
                                        }

                                        try {
                                            responses.text = xhr.responseText;
                                        } catch ( e ) {
                                        }

                                        try {
                                            statusText = xhr.statusText;
                                        } catch ( e ) {
                                            statusText = "";
                                        }

                                        if ( !status && s.isLocal && !s.crossDomain ) {
                                            status = responses.text ? 200 : 404;
                                        } else if ( status === 1223 ) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch ( firefoxAccessException ) {
                                if ( !isAbort ) {
                                    complete( -1, firefoxAccessException );
                                }
                            }

                            if ( responses ) {
                                complete( status, statusText, responses, responseHeaders );
                            }
                        };

                        if ( !s.async ) {
                            callback();
                        } else if ( xhr.readyState === 4 ) {
                            setTimeout( callback, 0 );
                        } else {
                            handle = ++xhrId;
                            if ( xhrOnUnloadAbort ) {
                                if ( !xhrCallbacks ) {
                                    xhrCallbacks = {};
                                    $( window ).unload( xhrOnUnloadAbort );
                                }
                                xhrCallbacks[ handle ] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },

                    abort: function () {
                        if ( callback ) {
                            callback( 0, 1 );
                        }
                    }
                };
            }
        } );
    }
    $.jqx.filter = function () {
        this.operator = 'and';
        var and_operator = 0;
        var or_operator = 1;
        var stringcomparisonoperators = [ 'EMPTY', 'NOT_EMPTY', 'CONTAINS', 'CONTAINS_CASE_SENSITIVE',
            'DOES_NOT_CONTAIN', 'DOES_NOT_CONTAIN_CASE_SENSITIVE', 'STARTS_WITH', 'STARTS_WITH_CASE_SENSITIVE',
            'ENDS_WITH', 'ENDS_WITH_CASE_SENSITIVE', 'EQUAL', 'EQUAL_CASE_SENSITIVE', 'NULL', 'NOT_NULL' ];
        var numericcomparisonoperators = [ 'EQUAL', 'NOT_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'NULL', 'NOT_NULL' ];
        var datecomparisonoperators = [ 'EQUAL', 'NOT_EQUAL', 'LESS_THAN', 'LESS_THAN_OR_EQUAL', 'GREATER_THAN', 'GREATER_THAN_OR_EQUAL', 'NULL', 'NOT_NULL' ];
        var booleancomparisonoperators = [ 'EQUAL', 'NOT_EQUAL' ];

        var filters = new Array();
        var comparisonoperators = new Array();

        this.evaluate = function ( value ) {
            var result = true;
            for ( var i = 0; i < filters.length; i++ ) {
                var currentResult = filters[ i ].evaluate( value );
                if ( i == 0 ) {
                    result = currentResult;
                }
                else {
                    if ( comparisonoperators[ i ] == or_operator || comparisonoperators[ i ] == "or" )
                        result = result || currentResult;
                    else
                        result = result && currentResult;
                }
            }

            return result;
        }

        this.getfilterscount = function () {
            return filters.length;
        }

        this.setoperatorsbyfiltertype = function ( type, array ) {
            switch ( type ) {
                case "numericfilter":
                    numericcomparisonoperators = array;
                    break;
                case "stringfilter":
                    stringcomparisonoperators = array;
                    break;
                case "datefilter":
                    datecomparisonoperators = array;
                    break;
                case "booleanfilter":
                    booleancomparisonoperators = array;
                    break;
            }
        }

        this.getoperatorsbyfiltertype = function ( type ) {
            var array = new Array();
            switch ( type ) {
                case "numericfilter":
                    array = numericcomparisonoperators.slice( 0 );
                    break;
                case "stringfilter":
                    array = stringcomparisonoperators.slice( 0 );
                    break;
                case "datefilter":
                    array = datecomparisonoperators.slice( 0 );
                    break;
                case "booleanfilter":
                    array = booleancomparisonoperators.slice( 0 );
                    break;
            }
            return array;
        }

        var generatefilterkey = function () {
            var S4 = function () {
                return ( ( ( 1 + Math.random() ) * 0x10000 ) | 0 ).toString( 16 ).substring( 1 );
            };
            return ( S4() + "-" + S4() + "-" + S4() );
        }

        this.createfilter = function ( filtertype, filtervalue, filtercomparisonoperator, customfilter, formatstring, localization ) {
            if ( filtertype == null || filtertype == undefined )
                return null;

            switch ( filtertype ) {
                case 'numericfilter':
                    return new numericfilter( filtervalue, filtercomparisonoperator.toUpperCase() );
                case 'stringfilter':
                    return new stringfilter( filtervalue, filtercomparisonoperator.toUpperCase() );
                case 'datefilter':
                    return new datefilter( filtervalue, filtercomparisonoperator.toUpperCase(), formatstring, localization );
                case 'booleanfilter':
                    return new booleanfilter( filtervalue, filtercomparisonoperator.toUpperCase() );
                case 'custom':
                    return new filter( filtervalue, filtercomparisonoperator.toUpperCase(), customfilter );
            }

            throw new Error( "jqxGrid: There is no such filter type. The available filter types are: 'numericfilter', 'stringfilter', 'datefilter' and 'booleanfilter'" );
            return null;
        }

        this.getfilters = function () {
            var filtersarray = new Array();
            for ( var i = 0; i < filters.length; i++ ) {
                var filter = { value: filters[ i ].filtervalue, condition: filters[ i ].comparisonoperator, operator: comparisonoperators[ i ], type: filters[ i ].type };
                if ( filters[ i ].data ) {
                    filter.id = filters[ i ].data;
                }
                filtersarray[ i ] = filter;
            }
            return filtersarray;
        }

        this.addfilter = function ( comparisonoperator, filter ) {
            filters[ filters.length ] = filter;
            filter.key = generatefilterkey();
            comparisonoperators[ comparisonoperators.length ] = comparisonoperator;
        }

        this.removefilter = function ( filter ) {
            for ( var i = 0; i < filters.length; i++ ) {
                if ( filters[ i ].key == filter.key ) {
                    filters.splice( i, 1 );
                    comparisonoperators.splice( i, 1 );
                    break;
                }
            }
        }

        this.getoperatorat = function ( index ) {
            if ( index == undefined || index == null )
                return null;

            if ( index < 0 || index > filters.length )
                return null;

            return comparisonoperators[ index ];
        }

        this.setoperatorat = function ( index, comparisonoperator ) {
            if ( index == undefined || index == null )
                return null;

            if ( index < 0 || index > filters.length )
                return null;

            comparisonoperators[ comparisonoperator ] = comparisonoperator;
        }

        this.getfilterat = function ( index ) {
            if ( index == undefined || index == null )
                return null;

            if ( index < 0 || index > filters.length )
                return null;

            return filters[ index ];
        }

        this.setfilterat = function ( index, filter ) {
            if ( index == undefined || index == null )
                return null;

            if ( index < 0 || index > filters.length )
                return null;

            filter.key = generatefilterkey();
            filters[ index ] = filter;
        }

        this.clear = function () {
            filters = new Array();
            comparisonoperators = new Array();
        }

        var stringfilter = function ( filtervalue, comparisonoperator ) {
            this.filtervalue = filtervalue;
            this.comparisonoperator = comparisonoperator;
            this.type = 'stringfilter';
            this.evaluate = function ( value ) {
                var filtervalue = this.filtervalue;
                var comparisonoperator = this.comparisonoperator;
                if ( value == null || value == undefined || value == "" ) {
                    if ( comparisonoperator == 'NULL' )
                        return true;

                    if ( comparisonoperator == 'NOT_NULL' )
                        return false;

                    if ( comparisonoperator == "EQUAL" && value == filtervalue ) {
                        return true;
                    }

                    if ( comparisonoperator == "NOT_EQUAL" && value != filtervalue ) {
                        return true;
                    }

                    if ( comparisonoperator != 'EMPTY' )
                        return false;
                    else if ( value == "" )
                        return true;
                }

                var val = "";
                try {
                    val = value.toString();
                }
                catch ( error ) {
                    return true;
                }

                var compare = function ( val, filtervalue ) {
                    switch ( comparisonoperator ) {
                        case 'EQUAL':
                            return $.jqx.string.equalsIgnoreCase( val, filtervalue );
                        case 'EQUAL_CASE_SENSITIVE':
                            return $.jqx.string.equals( val, filtervalue );
                        case 'NOT_EQUAL':
                            return !$.jqx.string.equalsIgnoreCase( val, filtervalue );
                        case 'NOT_EQUAL_CASE_SENSITIVE':
                            return !$.jqx.string.equals( val, filtervalue );
                        case 'CONTAINS':
                            return $.jqx.string.containsIgnoreCase( val, filtervalue );
                        case 'CONTAINS_CASE_SENSITIVE':
                            return $.jqx.string.contains( val, filtervalue );
                        case 'DOES_NOT_CONTAIN':
                            return !$.jqx.string.containsIgnoreCase( val, filtervalue );
                        case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                            return !$.jqx.string.contains( val, filtervalue );
                        case 'EMPTY':
                            return val == '';
                        case 'NOT_EMPTY':
                            return val != '';
                        case 'NOT_NULL':
                            return val != null;
                        case 'STARTS_WITH':
                            return $.jqx.string.startsWithIgnoreCase( val, filtervalue );
                        case 'ENDS_WITH':
                            return $.jqx.string.endsWithIgnoreCase( val, filtervalue );
                        case 'ENDS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.endsWith( val, filtervalue );
                        case 'STARTS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.startsWith( val, filtervalue );
                        default:
                            return false;
                    }
                }

                var filterValues = new Array();
                if ( filtervalue && filtervalue.indexO && comparisonoperator !== 'NOT_EQUAL' ) {
                    if ( filtervalue.indexOf( "|" ) >= 0 || filtervalue.indexOf( " AND " ) >= 0 || filtervalue.indexOf( " OR " ) >= 0 || filtervalue.indexOf( " and " ) >= 0 || filtervalue.indexOf( " or " ) >= 0 ) {
                        var result = compare( val, filtervalue );
                        if ( result ) {
                            return result;
                        }

                        var andFilters = filtervalue.indexOf( " AND " ) >= 0 ? filtervalue.split( " AND " ) : new Array();
                        var orFilters = filtervalue.indexOf( " OR " ) >= 0 ? filtervalue.split( " OR " ) : new Array();
                        var andLowerCaseFilters = filtervalue.indexOf( " and " ) >= 0 ? filtervalue.split( " and " ) : new Array();
                        var orLowerCaseFilters = filtervalue.indexOf( " or " ) >= 0 ? filtervalue.split( " or " ) : new Array();
                        var delimiterFilters = filtervalue.indexOf( "|" ) >= 0 ? filtervalue.split( "|" ) : new Array();
                        if ( delimiterFilters.length > 0 ) {
                            for ( var i = 0; i < delimiterFilters.length; i++ ) {
                                delimiterFilters[ i ] = $.trim( delimiterFilters[ i ] );
                            }
                        }
                        var commaFilters = filtervalue.indexOf( " " ) >= 0 ? filtervalue.split( " " ) : new Array();
                        if ( commaFilters.length > 0 ) {
                            for ( var i = 0; i < commaFilters.length; i++ ) {
                                commaFilters[ i ] = $.trim( commaFilters[ i ] );
                            }
                        }

                        andFilters = andFilters.concat( commaFilters );
                        andFilters = andFilters.concat( andLowerCaseFilters );
                        orFilters = orFilters.concat( delimiterFilters );
                        orFilters = orFilters.concat( orLowerCaseFilters );

                        if ( andFilters.length > 0 ) {
                            for ( var i = 0; i < andFilters.length; i++ ) {
                                if ( !andFilters[ i ].indexOf( " OR " ) >= 0 ) {
                                    filterValues.push( andFilters[ i ] );
                                }
                            }
                        }
                        if ( orFilters.length > 0 ) {
                            for ( var i = 0; i < orFilters.length; i++ ) {
                                if ( !orFilters[ i ].indexOf( " AND " ) >= 0 ) {
                                    filterValues.push( orFilters[ i ] );
                                }
                            }
                        }

                        var filterresult = undefined;
                        for ( var j = 0; j < filterValues.length; j++ ) {
                            var value = filterValues[ j ];
                            var result = compare( val, value );
                            var filteroperator = j < andFilters.length ? "and" : "or";
                            if ( filterresult == undefined ) {
                                filterresult = result;
                            }
                            else {
                                if ( filteroperator == 'or' ) {
                                    filterresult = filterresult || result;
                                }
                                else {
                                    filterresult = filterresult && result;
                                }
                            }
                        }
                        return filterresult;
                    }
                }

                return compare( val, filtervalue );
            }
        }

        var booleanfilter = function ( filtervalue, comparisonoperator ) {
            this.filtervalue = filtervalue;
            this.comparisonoperator = comparisonoperator;
            this.type = 'booleanfilter';
            this.evaluate = function ( value ) {
                var filtervalue = this.filtervalue;
                var comparisonoperator = this.comparisonoperator;
                if ( value == null || value == undefined ) {
                    if ( comparisonoperator == 'NULL' )
                        return true;

                    return false;
                }

                var val = value;

                switch ( comparisonoperator ) {
                    case 'EQUAL':
                        return val == filtervalue || val.toString() == filtervalue.toString();
                    case 'NOT_EQUAL':
                        return val != filtervalue && val.toString() != filtervalue.toString();
                    default:
                        return false;
                }
            }
        }

        var numericfilter = function ( filtervalue, comparisonoperator ) {
            this.filtervalue = filtervalue;
            this.comparisonoperator = comparisonoperator;
            this.type = 'numericfilter';
            this.evaluate = function ( value ) {
                var filtervalue = this.filtervalue;
                var comparisonoperator = this.comparisonoperator;
                if ( value === null || value === undefined || value === "" ) {
                    if ( comparisonoperator == 'NOT_NULL' )
                        return false;

                    if ( comparisonoperator == 'NULL' )
                        return true;
                    else {
                        switch ( comparisonoperator ) {
                            case 'EQUAL':
                                return value == filtervalue;
                            case 'NOT_EQUAL':
                                return value != filtervalue;
                        }
                        return false;
                    }
                }
                else {
                    if ( comparisonoperator == 'NULL' )
                        return false;

                    if ( comparisonoperator == 'NOT_NULL' )
                        return true;
                }

                var val = value;

                try {
                    val = parseFloat( val );
                }
                catch ( error ) {
                    if ( value.toString() != "" )
                        return false;
                }

                var compare = function ( val, filtervalue ) {
                    switch ( comparisonoperator ) {
                        case 'EQUAL':
                            return val == filtervalue;
                        case 'NOT_EQUAL':
                            return val != filtervalue;
                        case 'GREATER_THAN':
                            return val > filtervalue;
                        case 'GREATER_THAN_OR_EQUAL':
                            return val >= filtervalue;
                        case 'LESS_THAN':
                            return val < filtervalue;
                        case 'LESS_THAN_OR_EQUAL':
                            return val <= filtervalue;
                        case 'STARTS_WITH':
                            return $.jqx.string.startsWithIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'ENDS_WITH':
                            return $.jqx.string.endsWithIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'ENDS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.endsWith( val.toString(), filtervalue.toString() );
                        case 'STARTS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.startsWith( val.toString(), filtervalue.toString() );
                        case 'CONTAINS':
                            return $.jqx.string.containsIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'CONTAINS_CASE_SENSITIVE':
                            return $.jqx.string.contains( val.toString(), filtervalue.toString() );
                        case 'DOES_NOT_CONTAIN':
                            return !$.jqx.string.containsIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                            return !$.jqx.string.contains( val.toString(), filtervalue.toString() );
                        default:
                            return true;
                    }
                }

                var filterValues = new Array();

                if ( filtervalue && filtervalue.indexOf )
                    filtervalue = filtervalue.replace( '$', '' );

                if ( filtervalue && filtervalue.indexOf && ( filtervalue.indexOf( "|" ) >= 0 || filtervalue.indexOf( " AND " ) >= 0 || filtervalue.indexOf( " OR " ) >= 0 || filtervalue.indexOf( " and " ) >= 0 || filtervalue.indexOf( " or " ) >= 0 ) ) {
                    var result = compare( val, filtervalue );
                    if ( result ) {
                        return result;
                    }
                    filtervalue = filtervalue.toString();
                    var andFilters = filtervalue.indexOf( " AND " ) >= 0 ? filtervalue.split( " AND " ) : new Array();
                    var orFilters = filtervalue.indexOf( " OR " ) >= 0 ? filtervalue.split( " OR " ) : new Array();
                    var andLowerCaseFilters = filtervalue.indexOf( " and " ) >= 0 ? filtervalue.split( " and " ) : new Array();
                    var orLowerCaseFilters = filtervalue.indexOf( " or " ) >= 0 ? filtervalue.split( " or " ) : new Array();
                    andFilters = andFilters.concat( andLowerCaseFilters );
                    orFilters = orFilters.concat( orLowerCaseFilters );
                    var delimiterFilters = filtervalue.indexOf( "|" ) >= 0 ? filtervalue.split( "|" ) : new Array();
                    if ( delimiterFilters.length > 0 ) {
                        for ( var i = 0; i < delimiterFilters.length; i++ ) {
                            delimiterFilters[ i ] = $.trim( delimiterFilters[ i ] );
                        }
                    }
                    orFilters = orFilters.concat( delimiterFilters );

                    if ( andFilters.length > 0 ) {
                        for ( var i = 0; i < andFilters.length; i++ ) {
                            if ( !andFilters[ i ].indexOf( " OR " ) >= 0 ) {
                                filterValues.push( andFilters[ i ] );
                            }
                        }
                    }
                    if ( orFilters.length > 0 ) {
                        for ( var i = 0; i < orFilters.length; i++ ) {
                            if ( !orFilters[ i ].indexOf( " AND " ) >= 0 ) {
                                filterValues.push( orFilters[ i ] );
                            }
                        }
                    }

                    var filterresult = undefined;
                    for ( var j = 0; j < filterValues.length; j++ ) {
                        var value = filterValues[ j ];

                        if ( value && value.indexOf && value.indexOf( ".." ) >= 0 ) {
                            var values = value.toString().split( ".." );
                            if ( values.length == 2 ) {
                                result = val >= values[ 0 ] && val <= values[ 1 ];
                            }
                        }
                        else {
                            var result = compare( val, value );
                        }
                        var filteroperator = j < andFilters.length ? "and" : "or";
                        if ( filterresult == undefined ) {
                            filterresult = result;
                        }
                        else {
                            if ( filteroperator == 'or' ) {
                                filterresult = filterresult || result;
                            }
                            else {
                                filterresult = filterresult && result;
                            }
                        }
                    }
                    return filterresult;
                }
                if ( filtervalue && filtervalue.indexOf && filtervalue.indexOf( ".." ) >= 0 ) {
                    filterValues = filtervalue.toString().split( ".." );
                    if ( filterValues.length == 2 ) {
                        return val >= filterValues[ 0 ] && val <= filterValues[ 1 ];
                    }
                }
                return compare( val, filtervalue );
            }
        }

        var datefilter = function ( filtervalue, comparisonoperator, formatstring, localization ) {
            this.filtervalue = filtervalue;
            this.type = 'datefilter';
            var that = this;
            if ( formatstring != undefined && localization != undefined ) {
                var parsedDate = $.jqx.dataFormat.parsedate( filtervalue, formatstring, localization );
                if ( parsedDate != null ) {
                    this.filterdate = parsedDate;
                }
                else {
                    var result = $.jqx.dataFormat.tryparsedate( filtervalue, localization );
                    if ( result != null ) this.filterdate = result;
                }

            }
            else {
                var tmpvalue = new Date( filtervalue );
                if ( tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date" ) {
                    this.filterdate = $.jqx.dataFormat.tryparsedate( filtervalue );
                }
                else {
                    this.filterdate = tmpvalue;
                }
            }
            if ( !this.filterdate ) {
                var tmpvalue = new Date( filtervalue );
                if ( tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date" ) {
                    this.filterdate = $.jqx.dataFormat.tryparsedate( filtervalue );
                }
                else {
                    this.filterdate = tmpvalue;
                }
            }

            this.comparisonoperator = comparisonoperator;
            this.evaluate = function ( value ) {
                var filtervalue = this.filtervalue;
                var comparisonoperator = this.comparisonoperator;
                if ( value == null || value == undefined || value == "" ) {
                    if ( comparisonoperator == 'NOT_NULL' )
                        return false;

                    if ( comparisonoperator == 'NULL' )
                        return true;
                    else {
                        switch ( comparisonoperator ) {
                            case 'EQUAL':
                                return value == filtervalue;
                            case 'NOT_EQUAL':
                                return value != filtervalue;
                        }
                        return false;
                    }
                }
                else {
                    if ( comparisonoperator == 'NULL' )
                        return false;

                    if ( comparisonoperator == 'NOT_NULL' )
                        return true;
                }

                var val = new Date();
                val.setFullYear( 1900, 0, 1 );
                val.setHours( 12, 0, 0, 0 );
                try {
                    var tmpvalue = new Date( value );

                    if ( tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date" ) {
                        value = $.jqx.dataFormat.tryparsedate( value );
                    }
                    else {
                        value = tmpvalue;
                    }

                    val = value;

                    var compareTimePart = false;
                    if ( formatstring != undefined && localization != undefined ) {
                        if ( formatstring.indexOf( 't' ) >= 0 || formatstring.indexOf( 'T' ) >= 0 || formatstring.indexOf( ':' ) >= 0 || formatstring.indexOf( 'f' ) >= 0 ) {
                            compareTimePart = true;
                            if ( filtervalue && filtervalue.toString().indexOf( ':' ) == -1 ) {
                                var result = $.jqx.dataFormat.tryparsedate( filtervalue.toString() + ":00", localization );
                                if ( result != null ) that.filterdate = result;
                            }
                        }
                    }
                    if ( formatstring != undefined ) {
                        if ( formatstring.indexOf( 'hh' ) >= 0 || formatstring.indexOf( 't' ) >= 0 ) {
                            compareTimePart = true;
                        }
                    }

                    if ( !compareTimePart ) {
                        val.setHours( 0 );
                        val.setMinutes( 0 );
                        val.setSeconds( 0 );
                    }
                }
                catch ( error ) {
                    if ( value && value.toString() != "" )
                        return false;
					
					return false;
                }

                if ( that.filterdate != null ) {
                    filtervalue = that.filterdate;
                }
                else {
                    if ( filtervalue && filtervalue.indexOf ) {
                        if ( filtervalue.indexOf( ':' ) != -1 || !isNaN( parseInt( filtervalue ) ) ) {
                            var tmpFilter = new Date( val );
                            tmpFilter.setHours( 12, 0, 0, 0 );
                            var timeStrings = filtervalue.split( ':' );
                            for ( var i = 0; i < timeStrings.length; i++ ) {
                                if ( i == 0 ) {
                                    tmpFilter.setHours( timeStrings[ i ] );
                                }
                                if ( i == 1 ) {
                                    tmpFilter.setMinutes( timeStrings[ i ] );
                                }
                                if ( i == 2 ) {
                                    tmpFilter.setSeconds( timeStrings[ i ] );
                                }
                            }
                            filtervalue = tmpFilter;
                        }
                    }
                }
                if ( compareTimePart ) {
                    if ( filtervalue && filtervalue.setFullYear ) {
                        if ( val && val.getFullYear ) {
                            if ( formatstring.indexOf( 'd' ) == -1 && formatstring.indexOf( 'M' ) == -1 && formatstring.indexOf( 'y' ) == -1 ) {
                                filtervalue.setFullYear( val.getFullYear(), val.getMonth(), val.getDate() );
                            }
                        }
                    }
                }


                var compare = function ( val, filtervalue ) {
                    if ( val == null ) val = "";
                    switch ( comparisonoperator ) {
                        case 'EQUAL':
                            return val.toString() == filtervalue.toString();
                        case 'NOT_EQUAL':
                            return val.toString() != filtervalue.toString();
                        case 'GREATER_THAN':
                            return val > filtervalue;
                        case 'GREATER_THAN_OR_EQUAL':
                            return val >= filtervalue;
                        case 'LESS_THAN':
                            return val < filtervalue;
                        case 'LESS_THAN_OR_EQUAL':
                            return val <= filtervalue;
                        case 'STARTS_WITH':
                            return $.jqx.string.startsWithIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'ENDS_WITH':
                            return $.jqx.string.endsWithIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'ENDS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.endsWith( val.toString(), filtervalue.toString() );
                        case 'STARTS_WITH_CASE_SENSITIVE':
                            return $.jqx.string.startsWith( val.toString(), filtervalue.toString() );
                        case 'CONTAINS':
                            return $.jqx.string.containsIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'CONTAINS_CASE_SENSITIVE':
                            return $.jqx.string.contains( val.toString(), filtervalue.toString() );
                        case 'DOES_NOT_CONTAIN':
                            return !$.jqx.string.containsIgnoreCase( val.toString(), filtervalue.toString() );
                        case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                            return !$.jqx.string.contains( val.toString(), filtervalue.toString() );
                        default:
                            return true;
                    }
                }
                var filterValues = new Array();
                if ( filtervalue && filtervalue.indexOf )
                    if ( filtervalue.indexOf( "|" ) >= 0 || filtervalue.indexOf( " AND " ) >= 0 || filtervalue.indexOf( " OR " ) >= 0 || filtervalue.indexOf( " and " ) >= 0 || filtervalue.indexOf( " or " ) >= 0 ) {
                        var result = compare( val, filtervalue );
                        if ( result ) {
                            return result;
                        }
                        var andFilters = filtervalue.indexOf( " AND " ) >= 0 ? filtervalue.split( " AND " ) : new Array();
                        var orFilters = filtervalue.indexOf( " OR " ) >= 0 ? filtervalue.split( " OR " ) : new Array();
                        var andLowerCaseFilters = filtervalue.indexOf( " and " ) >= 0 ? filtervalue.split( " and " ) : new Array();
                        var orLowerCaseFilters = filtervalue.indexOf( " or " ) >= 0 ? filtervalue.split( " or " ) : new Array();
                        andFilters = andFilters.concat( andLowerCaseFilters );
                        orFilters = orFilters.concat( orLowerCaseFilters );
                        var delimiterFilters = filtervalue.indexOf( "|" ) >= 0 ? filtervalue.split( "|" ) : new Array();
                        if ( delimiterFilters.length > 0 ) {
                            for ( var i = 0; i < delimiterFilters.length; i++ ) {
                                delimiterFilters[ i ] = $.trim( delimiterFilters[ i ] );
                            }
                        }
                        orFilters = orFilters.concat( delimiterFilters );

                        if ( andFilters.length > 0 ) {
                            for ( var i = 0; i < andFilters.length; i++ ) {
                                if ( !andFilters[ i ].indexOf( " OR " ) >= 0 ) {
                                    filterValues.push( andFilters[ i ] );
                                }
                            }
                        }
                        if ( orFilters.length > 0 ) {
                            for ( var i = 0; i < orFilters.length; i++ ) {
                                if ( !orFilters[ i ].indexOf( " AND " ) >= 0 ) {
                                    filterValues.push( orFilters[ i ] );
                                }
                            }
                        }

                        var filterresult = undefined;
                        for ( var j = 0; j < filterValues.length; j++ ) {
                            var value = filterValues[ j ];
                            if ( value && value.indexOf && value.indexOf( ".." ) >= 0 ) {
                                var values = value.toString().split( ".." );
                                if ( values.length == 2 ) {
                                    result = val >= values[ 0 ] && val <= values[ 1 ];
                                }
                            }
                            else {
                                var result = compare( val, value );
                            }
                            var filteroperator = j < andFilters.length ? "and" : "or";
                            if ( filterresult == undefined ) {
                                filterresult = result;
                            }
                            else {
                                if ( filteroperator == 'or' ) {
                                    filterresult = filterresult || result;
                                }
                                else {
                                    filterresult = filterresult && result;
                                }
                            }
                        }
                        return filterresult;
                    }
                if ( filtervalue && filtervalue.indexOf && filtervalue.indexOf( ".." ) >= 0 ) {
                    filterValues = filtervalue.toString().split( ".." );
                    if ( filterValues.length == 2 ) {
                        return val >= filterValues[ 0 ] && val <= filterValues[ 1 ];
                    }
                }
                return compare( val, filtervalue );
            }
        }

        var filter = function ( filtervalue, comparisonoperator, customfilter ) {
            this.filtervalue = filtervalue;
            this.comparisonoperator = comparisonoperator;
            this.evaluate = function ( value, comparisonoperator ) {
                return customfilter( this.filtervalue, value, this.comparisonoperator );
            }
        }
    }
} )( jqxBaseFramework );
})();



/***/ }),

/***/ 4993:
/***/ (() => {


/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {
        $.jqx.jqxWidget("jqxDateTimeInput", "", {});

        $.extend($.jqx._jqxDateTimeInput.prototype, {

            defineInstance: function () {
                var settings = {
                    value: $.jqx._jqxDateTimeInput.getDateTime(new Date()),
                    minDate: $.jqx._jqxDateTimeInput.getDateTime(new Date()),
                    maxDate: $.jqx._jqxDateTimeInput.getDateTime(new Date()),
                    min: new Date(1900, 0, 1),
                    max: new Date(2100, 0, 1),
                    rowHeaderWidth: 25,
                    enableViews: true,
                    views: ['month', 'year', 'decade'],
                    selectableDays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    change: null,
                    changing: null,
                    titleFormat: ["MMMM yyyy", "yyyy", "yyyy", "yyyy"],
                    // "primary", "inverse", "danger", "info", "success", "warning", "link"
                    template: "default",
                    // Default: 20
                    // Gets or sets the column header's height.
                    // Type: Number.
                    columnHeaderHeight: 20,
                    // Default: 25
                    // Gets or sets the title's height.
                    // Type: Number.
                    titleHeight: 30,
                    // Type: Number.
                    // Default: 0
                    // Gets or sets the first day of the week - Sunday:0, Monday:1, Tuesday:2, Wednesday:3, Thursday:4, Friday:5, Saturday:6.
                    firstDayOfWeek: 0,
                    // Type: Boolean.
                    // Default: false.
                    // Shows or hides the week numbers.
                    showWeekNumbers: false,
                    showTimeButton: false,
                    // store value in cookie
                    cookies: false,
                    cookieoptions: null,
                    showFooter: false,
                    //Type: String.
                    //Default: null.
                    //Sets the masked input's formatString.
                    // Available ready to use patterns:
                    // short date pattern: "d",
                    // long date pattern: "D"
                    // short time pattern: "t"
                    // long time pattern: "T"
                    // long date, short time pattern: "f"
                    // long date, long time pattern: "F"
                    // month/day pattern: "M"
                    // month/year pattern: "Y"
                    // sortable format that does not vary by culture: "S"
                    formatString: "dd/MM/yyyy",
                    //Type: Number.
                    //Default: 0.
                    //Sets width of the masked input in pixels. Only positive values have effect.
                    width: 200,

                    //Type: Number.
                    //Default: 0.
                    //Sets height of the masked input in pixels.
                    height: 25,

                    // Type: String.
                    // Gets or sets the string format of the day names.
                    // Possible values: default, shortest, firstTwoLetters, firstLetter, full
                    dayNameFormat: 'firstTwoLetters',

                    // Type: String
                    // Sets the  text alignment.
                    textAlign: 'left',

                    // Type: Boolean
                    // Default: false
                    // Sets the readonly state of the input.
                    readonly: false,

                    // Type: String
                    // sets the culture.
                    // Default: 'default'
                    culture: "default",

                    activeEditor: null,

                    // Type: Boolean
                    // Default:true.
                    // shows or hides the calendar's button.
                    showCalendarButton: true,
                    showDeleteButton: false,
                    // Type: Number
                    // Default: 250
                    // Sets the animation's duration when the calendar is displayed.
                    openDelay: 250,

                    // Type: Number
                    // Default: 300
                    // Sets the animation's duration when the calendar is going to be hidden.
                    closeDelay: 300,

                    // Type: Boolean
                    // Default: true
                    // Sets whether to close the calendar after selecting a date.
                    closeCalendarAfterSelection: true,
                    // internal property
                    isEditing: false,
                    // Type: Boolean.
                    // enables the browser window bounds detection.
                    // Default: false.
                    enableBrowserBoundsDetection: false,
                    dropDownHorizontalAlignment: 'left',
                    dropDownVerticalAlignment: "bottom",
                    // Type: Boolean
                    // Enables absolute date selection. When this property is true, the user selects one symbol at a time instead of a group of symbols.
                    // Default: false
                    enableAbsoluteSelection: false,
                    // Type: Boolean
                    // Enables or disables the DateTimeInput.
                    // Default: false
                    disabled: false,
                    // Type: Number
                    // Default: 18
                    // Sets the button's size.
                    buttonSize: 21,
                    // default, none
                    // Type: String.
                    // enables or disables the animation.
                    animationType: 'slide',
                    // Type: String
                    // Default: auto ( the drop down takes the calendar's width.)
                    // Sets the popup's width.
                    dropDownWidth: '200px',
                    restrictedDates: new Array(),
                    // Type: String
                    // Default: 200px ( the height is 200px )
                    // Sets the popup's height.
                    dropDownHeight: '205px',
                    dropDownContainer: "default",
                    // 'none', 'range', 'default'
                    selectionMode: 'default',
                    renderMode: "full",
                    rtl: false,
                    timeRange: null,
                    _editor: false,
                    todayString: 'Today',
                    clearString: 'Clear',
                    popupZIndex: 3001,
                    allowNullDate: true,
                    changeType: null,
                    placeHolder: "",
                    enableHover: true,
                    hint: true,
                    allowKeyboardDelete: true,
                    yearCutoff: null,
                    editMode: 'default',// Possible values: 'default', 'full'
                    localization: {
                        backString: "Back",
                        forwardString: "Forward",
                        todayString: "Today",
                        clearString: "Clear",
                        calendar: {
                            name: "Gregorian_USEnglish",
                            "/": "/",
                            // separator of parts of a time (e.g. ":" in 05:44 PM)
                            ":": ":",
                            // the first day of the week (0:Sunday, 1:Monday, etc)
                            firstDay: 0,
                            days: {
                                // full day names
                                names: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                                // abbreviated day names
                                namesAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                                // shortest day names
                                namesShort: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                            },
                            months: {
                                // full month names (13 months for lunar calendards -- 13th month should be "" if not lunar)
                                names: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""],
                                // abbreviated month names
                                namesAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""]
                            },
                            // AM and PM designators in one of these forms:
                            // The usual view, and the upper and lower case versions
                            //      [standard,lowercase,uppercase]
                            // The culture does not use AM or PM (likely all standard date formats use 24 hour time)
                            //      null
                            AM: ["AM", "am", "AM"],
                            PM: ["PM", "pm", "PM"],
                            eras: [
                                // eras in reverse chronological order.
                                // name: the name of the era in this culture (e.g. A.D., C.E.)
                                // start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
                                // offset: offset in years from gregorian calendar
                                { "name": "A.D.", "start": null, "offset": 0 }
                            ],
                            twoDigitYearMax: 2029,
                            patterns: {
                                // short date pattern
                                d: "M/d/yyyy",
                                // long date pattern
                                D: "dddd, MMMM dd, yyyy",
                                // short time pattern
                                t: "h:mm tt",
                                // long time pattern
                                T: "h:mm:ss tt",
                                // long date, short time pattern
                                f: "dddd, MMMM dd, yyyy h:mm tt",
                                // long date, long time pattern
                                F: "dddd, MMMM dd, yyyy h:mm:ss tt",
                                // month/day pattern
                                M: "MMMM dd",
                                // month/year pattern
                                Y: "yyyy MMMM",
                                // S is a sortable format that does not vary by culture
                                S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss",
                                // formatting of dates in MySQL DataBases
                                ISO: "yyyy-MM-dd hh:mm:ss"
                            }
                        }
                    },
                    // DateTimeInput events.
                    events:
                        [
                            // Occurs when the value is changed.
                            'valueChanged',
                            // Occurs when the text is changed.
                            'textchanged',
                            // Occurs when the mouse button is clicked.
                            'mousedown',
                            // Occurs when the mouse button is clicked.
                            'mouseup',
                            // Occurs when the user presses a key.
                            'keydown',
                            // Occurs when the user presses a key. Fired after keydown and keypress
                            'keyup',
                            // Occurs when the user presses a key.
                            'keypress',
                            // Occurs when the calendar is opened.
                            'open',
                            // Occurs when the calendar is hidden.
                            'close',
                            // Occurs when the value is changed.
                            'change'
                        ],
                    aria:
                    {
                        //      "aria-valuenow": { name: "getDate", type: "date" },
                        "aria-valuetext": { name: "getText", type: "string" },
                        //     "aria-valuemin": { name: "min", type: "date" },
                        //      "aria-valuemax": { name: "max", type: "date" },
                        "aria-disabled": { name: "disabled", type: "boolean" }
                    }
                };
                if (this === $.jqx._jqxDateTimeInput.prototype) {
                    return settings;
                }
                $.extend(true, this, settings);
                this.value._setHours(0);
                this.value._setMinutes(0);
                this.value._setSeconds(0);
                this.value._setMilliseconds(0);
                this.minDate._setYear(1900);
                this.minDate._setMonth(1);
                this.minDate._setDay(1);
                this.minDate._setHours(1);
                this.minDate._setMinutes(1);
                this.minDate._setSeconds(1);
                this.minDate._setMilliseconds(1);
                this.maxDate._setYear(2100);
                this.maxDate._setMonth(1);
                this.maxDate._setDay(1);
                this.maxDate._setHours(1);
                this.maxDate._setMinutes(1);
                this.maxDate._setSeconds(1);
                this.maxDate._setMilliseconds(1);
                this.defaultMinDate = this.minDate;
                this.defaultMaxDate = this.maxDate;
                return settings;
            },

            // creates the masked input's instance.
            createInstance: function (args) {
                var hasAttr = "";
                var that = this;
                if (!that.host.jqxCalendar) {
                    throw new Error("jqxDateTimeInput: Missing reference to jqxcalendar.js.");
                }
                if (that.isMaterialized()) {
                    var elementStyle = window.getComputedStyle(this.element);
                    var animation = elementStyle.getPropertyValue('--jqx-dropdown-animation');
                    var dropDownWidth = elementStyle.getPropertyValue('--jqx-datetimeinput-dropdown-width') || 280;
                    var dropDownHeight = elementStyle.getPropertyValue('--jqx-datetimeinput-dropdown-height') || 280;

                    if (animation && this.animationType == "default") {
                        this.animationType = animation.trim();
                    }
                    if (dropDownWidth) {
                        this.dropDownWidth = dropDownWidth;
                    }
                    if (dropDownHeight) {
                        this.dropDownHeight = dropDownHeight;
                    }
                }
                if (that.formatString != "dd/MM/yyyy") {
                    var formats = that.formatString.split(" ");
                    if (formats && formats.length > 1) {
                        var extendedFormat = "";
                        for (var i = 0; i < formats.length; i++) {
                            if (formats[i].length == "1") {
                                extendedFormat += that._getFormatValue(formats[i])
                            }
                            else extendedFormat += formats[i];

                            if (i < formats.length - 1) {
                                extendedFormat += " ";
                            }
                        }
                        that.formatString = extendedFormat;
                    }
                }

                if (that.element.nodeName.toLowerCase() == "input") {
                    var inputType = that.element.getAttribute("type")
                    if (inputType) {
                        if (that.formatString == "dd/MM/yyyy") {
                            if (inputType == "date") {
                                that.formatString = "d";
                            }
                            if (inputType == "datetime") {
                                var formatString = that._getFormatValue("d") + " " + that._getFormatValue("t");
                                that.formatString = formatString;
                                that.showTimeButton = true;
                            }
                            if (inputType == "time") {
                                that.formatString = "t";
                                that.showTimeButton = true;
                                that.showCalendarButton = false;
                            }
                        }
                    }
                    that.field = that.element;

                    if (that.field.getAttribute('min')) {
                        var min = new Date(that.field.getAttribute('min'));
                        if (that._isValidDate(min))
                            that.min = min;
                    }
                    if (that.field.getAttribute('max')) {
                        var max = new Date(that.field.getAttribute('max'));
                        if (that._isValidDate(max))
                            that.max = max;
                    }

                    if (that.field.className) {
                        that._className = that.field.className;
                    }

                    var properties = {
                        'title': that.field.title
                    };


                    if (that.field.value) {
                        properties.value = that.field.value;
                    }

                    if (that.field.id.length) {
                        properties.id = that.field.id.replace(/[^\w]/g, '_') + "_jqxDateTimeInput";
                    }
                    else {
                        properties.id = $.jqx.utilities.createId() + "_jqxDateTimeInput";
                    }

                    var wrapper = $("<div></div>", properties);
                    wrapper[0].style.cssText = that.field.style.cssText;
                    if (!that.width) {
                        that.width = $(that.field).width();
                    }
                    if (!that.height) {
                        that.height = $(that.field).outerHeight();
                    }
                    $(that.field).hide().after(wrapper);
                    var data = that.host.data();
                    that.host = wrapper;
                    that.host.data(data);
                    that.element = wrapper[0];
                    that.element.id = that.field.id;
                    that.field.id = properties.id;
                    if (that._className) {
                        that.host.addClass(that._className);
                        $(that.field).removeClass(that._className);
                    }

                    if (that.field.tabIndex) {
                        var tabIndex = that.field.tabIndex;
                        that.field.tabIndex = -1;
                        that.element.tabIndex = tabIndex;
                    }
                }

                if (that.host.attr('value')) {
                    hasAttr = true;
                    var val = that.host.attr('value');
                    if (that.selectionMode != 'range') {
                        var date = new Date(val);
                        if (date != undefined && !isNaN(date)) {
                            that.value = $.jqx._jqxDateTimeInput.getDateTime(date);
                        }
                    }
                }

                if (that.value != null && that.value instanceof Date) {
                    that.value = $.jqx._jqxDateTimeInput.getDateTime(that.value);
                }
                else if (that.value != null && typeof (that.value) == "string") {
                    var date = new Date(that.value);
                    if (date != undefined && !isNaN(date)) {
                        that.value = $.jqx._jqxDateTimeInput.getDateTime(date);
                    }
                    else if (that.value.indexOf(',') >= 0) {
                        that.value = that.value.replace(/\,/g, '/');
                        var date = new Date(that.value);
                        if (date != undefined && !isNaN(date)) {
                            that.value = $.jqx._jqxDateTimeInput.getDateTime(date);
                        }
                    }
                }


                this._initTimeRange();
                this._validateTimeRange();

                that.host.attr('data-role', 'input');
                that.render();
                $.jqx.aria(this);
                if (that.getDate() != null) {
                    $.jqx.aria(this, "aria-label", "Current focused date is " + that.getDate().toLocaleString());
                }
                else {
                    $.jqx.aria(this, "aria-label", "Current focused date is Null");
                }

                if (that.minDate !== that.defaultMinDate) {
                    that.min = that.minDate;
                }
                if (that.maxDate !== that.defaultMaxDate) {
                    that.max = that.maxDate;
                }

                that.setMaxDate(that.max, false);
                that.setMinDate(that.min, false);

                if (that.selectionMode !== 'range' && that.value && that.value.dateTime && that.min && that.max &&
                    (that.value.dateTime < that.min || that.value.dateTime > that.max)) {
                    if (that.value.dateTime < that.min) {
                        that.value.dateTime = that.min;
                    }
                    if (that.value.dateTime > that.max) {
                        that.value.dateTime = that.max;
                    }

                    that._updateText();
                }

                if (that.selectionMode == 'range') {
                    if (hasAttr) {
                        var val = that.host.attr('value');
                        var val1 = val.substring(0, val.indexOf('-'));
                        var val2 = val.substring(val.indexOf('-') + 1);
                        var from = new Date(val1);
                        var to = new Date(val2);
                        if (from != undefined && !isNaN(from)) {
                            if (to != undefined && !isNaN(to)) {
                                that.setRange(from, to);
                            }
                        }
                    }
                    else {
                        if (that.getDate() != null) {
                            that.setRange(that.getDate(), that.getDate());
                        }
                    }
                }

                that._getMask();

                if (that.editMode === 'full' && that.value === null && that._mask[0] !== undefined) {
                    that.dateTimeInput[0].value = that._mask[0];
                }
            },

            _validateTimeRange: function () {
                if (this.timeRange) {
                    var hours = this.value.dateTime.getHours()
                    var minute = this.value.dateTime.getMinutes();
                    if (hours <= this.timeRange.minHour) {
                        this.value._setHours(this.timeRange.minHour);
                        if (minute < this.timeRange.minMinute) {
                            this.value._setMinutes(this.timeRange.minMinute);
                            this._updateEditorsValue();
                        }
                        else {
                            this._updateEditorsValue();
                        }
                    }
                    if (hours >= this.timeRange.maxHour) {
                        this.value._setHours(this.timeRange.maxHour);
                        if (minute > this.timeRange.maxMinute) {
                            this.value._setMinutes(this.timeRange.maxMinute);
                            this._updateEditorsValue();
                        }
                        else {
                            this._updateEditorsValue();
                        }
                    }
                }
            },

            _initTimeRange: function () {
                if (this.timeRange) {
                    if (this.timeRange.min) {
                        var meridian = null;
                        if (this.timeRange.min.indexOf("AM") >= 0 || this.timeRange.min.indexOf("PM") >= 0) {
                            meridian = this.timeRange.min.indexOf("AM") >= 0 ? "AM" : "PM";
                        }

                        var minParts = this.timeRange.min.split(":");
                        var hour = parseInt(minParts[0]);
                        var minute = parseInt(minParts[1]);

                        if (meridian) {
                            this.timeRange.minDefaultHour = hour;
                            this.timeRange.minMeridian = meridian;
                        }

                        if (meridian && meridian == "PM") {
                            hour += 12;
                        }

                        this.timeRange.minHour = hour;
                        this.timeRange.minMinute = minute;
                    }
                    if (this.timeRange.max) {
                        var meridian = null;
                        if (this.timeRange.max.indexOf("AM") >= 0 || this.timeRange.max.indexOf("PM") >= 0) {
                            meridian = this.timeRange.max.indexOf("AM") >= 0 ? "AM" : "PM";
                        }

                        var maxParts = this.timeRange.max.split(":");
                        var hour = parseInt(maxParts[0]);
                        var minute = parseInt(maxParts[1]);
                        if (meridian) {
                            this.timeRange.maxDefaultHour = hour;
                            this.timeRange.maxMeridian = meridian;
                        }
                        if (meridian && meridian == "PM") {
                            hour += 12;
                        }

                        this.timeRange.maxHour = hour;
                        this.timeRange.maxMinute = minute;
                    }
                }
            },

            _format: function (date, format, culture) {
                var globalize = false;
                try {
                    if (window.Globalize != undefined) {
                        globalize = true;
                    }
                    if (document.Globalize) {
                        window.Globalize = document.Globalize;
                        globalize = true;
                    }
                }
                catch (error) {
                    if (document.Globalize) {
                        window.Globalize = document.Globalize;
                        globalize = true;
                    }
                }

                if (document.Globalize) {
                    window.Globalize = document.Globalize;
                    globalize = true;
                }

                if ($.global) {
                    return $.global.format(date, format, this.culture);
                }
                else if (globalize) {
                    try {
                        var format = window.Globalize.format(date, format, this.culture);
                        return format;
                    }
                    catch (error) {
                        return window.Globalize.format(date, format);
                    }
                }
                else if ($.jqx.dataFormat) {
                    if (date instanceof Date) {
                        return $.jqx.dataFormat.formatdate(date, format, this.localization.calendar);
                    }
                    else if (typeof date === "number") {
                        return $.jqx.dataFormat.formatnumber(date, format, this.localization.calendar);
                    }
                    else {
                        return $.jqx.dataFormat.formatdate(date, format, this.localization.calendar);
                    }
                }
                else throw new Error("jqxDateTimeInput: Missing reference to globalize.js.");
            },

            render: function () {
                var that = this;
                that._removeHandlers();
                that.element.innerHTML = "";
                that.host
                    .attr({
                        role: "spinbutton"
                    });
                that.id = $.jqx.utilities.createId();
                var id = $.jqx.utilities.createId();
                var buttonid = $.jqx.utilities.createId();

                that._setSize();
                if (that.width == null) {
                    that.width = that.host.width();
                    that.host.width(that.width);
                }

                that.touch = $.jqx.mobile.isTouchDevice();

                var wrapper = $("<div class='jqx-max-size jqx-position-relative'></div>").appendTo(that.host);
                that.dateTimeInput = $("<input role='textbox' style='border: none; padding-left: 3px; padding-right: 3px;' class='jqx-position-absolute' id='" + "input" + that.element.id + "' autocomplete='off' type='textarea'/>").appendTo(wrapper);
                that.dateTimeInput.addClass(that.toThemeProperty("jqx-reset"));
                that.dateTimeInput.addClass(that.toThemeProperty("jqx-clear"));
                that.dateTimeInput.addClass(that.toThemeProperty("jqx-input-content"));
                that.dateTimeInput.addClass(that.toThemeProperty("jqx-widget-content"));
                that.dateTimeInput.addClass(that.toThemeProperty("jqx-rc-all"));
                if (that.touch) {
                    that.dateTimeInput.attr('readonly', true);
                    that.readonly = true;
                }
                if (!that.isMaterialized()) {
                    that.dateTimeInput.attr('placeHolder', that.placeHolder);
                }
                if (that.renderMode != "full") {
                    that.dateTimeInput.remove();
                }
                var name = that.host.attr('name');
                if (name) {
                    that.dateTimeInput.attr('name', name);
                }
                if (that.host.attr('tabindex')) {
                    that.dateTimeInput.attr('tabindex', that.host.attr('tabindex'));
                    that.host.removeAttr('tabindex');
                }
                if (that.rtl) {
                    that.dateTimeInput.css('direction', 'rtl');
                    that.dateTimeInput.addClass('jqx-rtl');
                }

                that.calendarButton = $("<div style='height: 100%;' class='jqx-position-absolute'><div></div></div>").appendTo(wrapper);
                if (!that.rtl) {
                    that.calendarButton.addClass(that.toThemeProperty('jqx-action-button'));
                }
                else {
                    that.calendarButton.addClass(that.toThemeProperty('jqx-action-button-rtl'));
                }

                that.calendarButtonIcon = $(that.calendarButton.children()[0]);
                that.calendarButtonIcon.addClass(that.toThemeProperty('jqx-icon'));
                that.calendarButtonIcon.addClass(that.toThemeProperty('jqx-icon-calendar'));
                that.calendarButton.addClass(that.toThemeProperty('jqx-fill-state-normal'));
                if (!that.rtl) {
                    if (!that.showTimeButton) {
                        that.calendarButton.addClass(that.toThemeProperty('jqx-rc-r'));
                    }
                }
                else {
                    that.calendarButton.addClass(that.toThemeProperty('jqx-rc-l'));
                }

                //
                that.timeButton = $("<div style='height: 100%;' class='jqx-position-absolute'><div></div></div>").appendTo(wrapper);
                if (!that.rtl) {
                    that.timeButton.addClass(that.toThemeProperty('jqx-action-button'));
                }
                else {
                    that.timeButton.addClass(that.toThemeProperty('jqx-action-button-rtl'));
                }



                that.timeButtonIcon = $(that.timeButton.children()[0]);
                that.timeButtonIcon.addClass(that.toThemeProperty('jqx-icon'));
                that.timeButtonIcon.addClass(that.toThemeProperty('jqx-icon-time'));
                that.timeButton.addClass(that.toThemeProperty('jqx-fill-state-normal'));
                if (!that.rtl) {
                    that.timeButton.addClass(that.toThemeProperty('jqx-rc-r'));
                }
                else {
                    that.timeButton.addClass(that.toThemeProperty('jqx-rc-l'));
                }

                // delete button
                that.deleteButton = $("<div style='margin-left: 2px; right: 0px; height: 100%;' class='jqx-datetimeinput-delete-button jqx-position-absolute'><div></div></div>").appendTo(wrapper);
                if (!that.rtl) {
                    that.deleteButton.addClass(that.toThemeProperty('jqx-action-button'));
                }
                else {
                    that.deleteButton.addClass(that.toThemeProperty('jqx-action-button-rtl'));
                }


                that.deleteButton[0].onclick = function () {
                    that.setDate(null);
                }

                that.deleteButtonIcon = $(that.deleteButton.children()[0]);
                that.deleteButtonIcon.addClass(that.toThemeProperty('jqx-icon'));
                that.deleteButtonIcon.addClass(that.toThemeProperty('jqx-icon-close'));
                that.deleteButton.addClass(that.toThemeProperty('jqx-fill-state-normal'));
                if (!that.rtl) {
                    that.deleteButton.addClass(that.toThemeProperty('jqx-rc-r'));
                }
                else {
                    that.deleteButton.addClass(that.toThemeProperty('jqx-rc-l'));
                }
                // end of delete button

                var me = this;
                that._arrange();

                if ($.jqx._jqxCalendar != null && $.jqx._jqxCalendar != undefined) {
                    try {
                        var calendarID = 'calendar' + that.id;
                        var oldContainer = $($.find('#' + calendarID));
                        if (oldContainer.length > 0) {
                            oldContainer.remove();
                        }

                        $.jqx.aria(this, "aria-roledescription", "Date Picker");
                        $.jqx.aria(this, "aria-owns", calendarID);
                        $.jqx.aria(this, "aria-haspopup", true);
                        $.jqx.aria(this, "aria-readonly", that.selectionMode == 'range' ? true : false);

                        var container = $("<div class='jqx-calendar-container' style='overflow: hidden; background: transparent; position: absolute;' id='calendar" + that.id + "'><div id='innerCalendar" + that.id + "'></div><div id='innerTime" + that.id + "'></div></div>");
                        if ($.jqx.utilities.getBrowser().browser == 'opera') {
                            container.hide();
                        }

                        container.addClass(that.toThemeProperty('jqx-calendar-container'));

                        if (that.dropDownContainer == "element") {
                            container.appendTo(that.host);
                        }
                        else {
                            container.appendTo(document.body);
                        }
                        that.container = container;
                        that.calendarContainer = $($.find('#innerCalendar' + that.id)).jqxCalendar({ titleFormat: this.titleFormat, restrictedDates: this.restrictedDates, changing: that.changing, change: that.change, enableViews: that.enableViews, selectableDays: that.selectableDays, views: that.views, rowHeaderWidth: that.rowHeaderWidth, titleHeight: that.titleHeight, columnHeaderHeight: that.columnHeaderHeight, _checkForHiddenParent: false, enableAutoNavigation: false, canRender: false, localization: that.localization, todayString: that.todayString, clearString: that.clearString, dayNameFormat: that.dayNameFormat, rtl: that.rtl, culture: that.culture, showFooter: that.showFooter, selectionMode: that.selectionMode, firstDayOfWeek: that.firstDayOfWeek, showWeekNumbers: that.showWeekNumbers, width: that.dropDownWidth, height: that.dropDownHeight, theme: that.theme });
                        if (that.dropDownContainer == "element") {
                            that.calendarContainer.css({ position: 'absolute', top: 0, left: 0 });
                        }
                        else {
                            that.calendarContainer.css({ position: 'absolute', zIndex: that.popupZIndex, top: 0, left: 0 });
                        }
                        that.calendarContainer.addClass(that.toThemeProperty('jqx-popup'));
                        if ($.jqx.browser.msie) {
                            that.calendarContainer.addClass(that.toThemeProperty('jqx-noshadow'));
                        }

                        that.timeContainer = $($.find('#innerTime' + that.id));
                        that.timeContainer.css({ position: 'absolute', zIndex: that.popupZIndex, top: 0, left: 0 });
                        that.timeContainer.addClass(that.toThemeProperty('jqx-popup'));
                        if ($.jqx.browser.msie) {
                            that.timeContainer.addClass(that.toThemeProperty('jqx-noshadow'));
                        }

                        that._calendar = $.data(that.calendarContainer[0], "jqxCalendar").instance;
                        var me = this;

                        that._calendar.today = function () {
                            me.today();
                        }
                        that._calendar.clear = function () {
                            me.clear();
                        }

                        if ($.jqx.utilities.getBrowser().browser == 'opera') {
                            container.show();
                        }
                        container.height(parseInt(that.calendarContainer.height()) + 25);
                        container.width(parseInt(that.calendarContainer.width()) + 25);

                        if (that.selectionMode == 'range') {
                            that.readonly = true;
                        }

                        if (that.animationType == 'none') {
                            that.container.css('display', 'none');
                        }
                        else {
                            that.container.hide();
                        }

                    }
                    catch (e) {

                    }
                }

                if ($.global) {
                    $.global.preferCulture(that.culture);
                }

                that.selectedText = "";

                that._addHandlers();
                that.self = this;
                that.oldValue = that.getDate();
                that.items = new Array();
                that.editors = new Array();

                that._loadItems();
                that.editorText = "";

                if (that.readonly == true) {
                    that.dateTimeInput.css("readonly", that.readonly);
                }

                that.dateTimeInput.css("text-align", that.textAlign);
                that.host.addClass(that.toThemeProperty('jqx-widget'));
                that.host.addClass(that.toThemeProperty('jqx-datetimeinput'));
                that.host.addClass(that.toThemeProperty('jqx-input'));
                that.host.addClass(that.toThemeProperty('jqx-overflow-hidden'));
                that.host.addClass(that.toThemeProperty('jqx-rc-all'));
                that.host.addClass(that.toThemeProperty("jqx-reset"));
                that.host.addClass(that.toThemeProperty("jqx-clear"));
                that.host.addClass(that.toThemeProperty("jqx-widget-content"));

                that.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    if (value) {
                        instance.host.addClass(me.toThemeProperty('jqx-input-disabled'));
                        instance.host.addClass(me.toThemeProperty('jqx-fill-state-disabled'));
                    }
                    else {
                        instance.host.removeClass(me.toThemeProperty('jqx-fill-state-disabled'));
                        instance.host.removeClass(me.toThemeProperty('jqx-input-disabled'));
                    }
                    $.jqx.aria(instance, "aria-disabled", value);
                }

                if (that.disabled) {
                    that.host.addClass(that.toThemeProperty('jqx-input-disabled'));
                    that.host.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
                    that.dateTimeInput.attr("disabled", true);
                }

                if (that.host.parents('form').length > 0) {
                    that.addHandler(that.host.parents('form'), 'reset', function () {
                        setTimeout(function () {
                            me.setDate(new Date());
                        }, 10);
                    });
                }

                if (that.cookies) {
                    var date = $.jqx.cookie.cookie("jqxDateTimeInput" + that.element.id);
                    if (date != null) {
                        that.setDate(new Date(date));
                    }
                }

                // fix for IE7
                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                    if (that.host.parents('.jqx-window').length > 0) {
                        var zIndex = that.host.parents('.jqx-window').css('z-index');
                        that.container.css('z-index', zIndex + 10);
                        that.calendarContainer.css('z-index', zIndex + 10);
                    }
                }

                if (that.culture != 'default') {
                    that._applyCulture();
                }

                if (that.value) {
                    if (that.calendarContainer.jqxCalendar('_isDisabled', that.value.dateTime)) {
                        that.dateTimeInput.addClass(that.toThemeProperty("jqx-input-invalid"));
                    }
                    else {
                        that.dateTimeInput.removeClass(that.toThemeProperty("jqx-input-invalid"));
                    }
                }

                this._addBarAndLabel(this.dateTimeInput);
                this._updateHint(true);

                if (that.template) {
                    that.bar.addClass(that.toThemeProperty("jqx-" + that.template))
                    that.label.addClass(that.toThemeProperty("jqx-" + that.template))
                    that.timeButton.addClass(that.toThemeProperty("jqx-" + that.template))
                    that.calendarButton.addClass(that.toThemeProperty("jqx-" + that.template))
                }

                this._setSize();
                this._arrange();
            },

            val: function (value) {
                var that = this;
                if (arguments.length != 0) {
                    if (value == null)
                        that.setDate(null);

                    if (that.selectionMode == 'range') {
                        that.setRange(arguments[0], arguments[1]);
                        return that.getText();
                    }

                    if (value instanceof Date) {
                        that.setDate(value);
                    }

                    if (typeof (value) == "string") {
                        if (value == 'date') {
                            return that.getDate();
                        }

                        that.setDate(value);
                    }
                    if (that._calendar.getDate() != that.getDate()) {
                        that._calendar.setDate(that.getDate());
                    }
                }
                return that.getText();
            },

            _setSize: function () {
                var computedStyle = window.getComputedStyle(this.element);
                var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
                var boxSizing = computedStyle.boxSizing;

                if (this.element.offsetWidth === 0) {
                    borderSize = 2;
                }

                if (boxSizing === 'border-box' || isNaN(borderSize)) {
                    borderSize = 0;
                }

                if (this.width != null && this.width.toString().indexOf("px") != -1) {
                    this.element.style.width = parseInt(this.width) - borderSize + 'px';
                }
                else if (this.width != undefined && !isNaN(this.width)) {
                    this.element.style.width = parseInt(this.width) - borderSize + 'px';
                }

                if (this.height != null && this.height.toString().indexOf("px") != -1) {
                    this.element.style.height = parseInt(this.height) - borderSize + 'px';
                }
                else if (this.height != undefined && !isNaN(this.height)) {
                    this.element.style.height = parseInt(this.height) - borderSize + 'px';
                };

                var isPercentage = false;
                if (this.width != null && this.width.toString().indexOf("%") != -1) {
                    isPercentage = true;
                    this.host.width(this.width);

                    if (borderSize > 0) {
                        this.host.css('box-sizing', 'border-box');
                    }
                }

                if (this.height != null && this.height.toString().indexOf("%") != -1) {
                    isPercentage = true;
                    this.host.height(this.height);
                }

                var me = this;
                var resizeFunc = function () {
                    if (me.calendarContainer) {
                        me._arrange();
                    }
                }

                if (isPercentage) {
                    if (this.calendarContainer) {
                        this._arrange();
                        var width = this.host.width();
                        if (this.dropDownWidth != 'auto') {
                            width = this.dropDownWidth;
                        }
                        this.calendarContainer.jqxCalendar({ width: width });
                        this.container.width(parseInt(width) + 25);
                    }
                }
                $.jqx.utilities.resize(this.host, function () {
                    resizeFunc();
                });
            },

            _arrange: function () {
                if (this.height == null) {
                    this.height = 27;
                    this.host.height(27);
                }
                var width = parseInt(this.host.width());
                var height = parseInt(this.host.height());

                var computedStyle = window.getComputedStyle(this.element);
                var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
                var boxSizing = computedStyle.boxSizing;


                if (boxSizing === 'border-box' || isNaN(borderSize)) {
                    borderSize = 0;
                }

                //     width -= borderSize;
                //    height -= borderSize;
                var buttonWidth = this.buttonSize;
                var rightOffset = 2;
                if (!this.showCalendarButton && !this.showTimeButton) {
                    buttonWidth = 0;
                    var buttonHeight = 0;
                    this.calendarButton.hide();
                    rightOffset = 0;
                }
                if (!this.showCalendarButton) {
                    this.calendarButton.hide();
                }
                else {
                    this.calendarButton.show();
                }
                if (!this.showTimeButton) {
                    this.timeButton.hide();
                }
                else {
                    this.timeButton.show();
                }

                if (!this.showDeleteButton) {
                    this.deleteButton.hide();
                }
                else {
                    this.deleteButton.show();
                }


                var contentWidth = width - buttonWidth - 1 * rightOffset;
                if (this.showTimeButton && this.showCalendarButton) {
                    var contentWidth = width - 2 * buttonWidth - 1 * rightOffset;
                }
                else if (this.showTimeButton || this.showCalendarButton) {
                    var contentWidth = width - buttonWidth - 1 * rightOffset;
                }

                if (this.showDeleteButton) {
                    contentWidth -= buttonWidth - rightOffset;
                }

                if (contentWidth > 0) {
                    this.dateTimeInput[0].style.width = contentWidth + 'px';
                }
                if (this.rtl) {
                    this.dateTimeInput[0].style.width = (-1 + contentWidth + 'px');
                }

                this.dateTimeInput[0].style.left = '0px';
                this.dateTimeInput[0].style.top = '0px';
                this.calendarButton[0].style.width = buttonWidth + 1 + 'px';
                this.calendarButton[0].style.left = 1 + contentWidth + 'px';
                this.timeButton[0].style.width = buttonWidth + 1 + 'px';
                if (this.showCalendarButton) {
                    this.timeButton[0].style.left = 1 + this.calendarButton.width() + contentWidth + 'px';
                }
                else {
                    this.timeButton[0].style.left = 1 + contentWidth + 'px';
                }

                if (this.renderMode != "full") {
                    this.calendarButton[0].style.width = '100%';
                    this.calendarButton[0].style.left = '0px';
                    this.calendarButton.css('border', 'none');
                    this.timeButton[0].style.width = '100%';
                    this.timeButton[0].style.left = '0px';
                    this.timeButton.css('border', 'none');
                }
                var inputHeight = this.dateTimeInput.height();
                if (inputHeight == 0 && this.renderMode != "full") {
                    inputHeight = parseInt(this.dateTimeInput.css('font-size')) + 3;
                    this.calendarButton.addClass(this.toThemeProperty('jqx-rc-all'));
                    this.timeButton.addClass(this.toThemeProperty('jqx-rc-all'));
                }
                else inputHeight = 17;

                if (this.dateTimeInput[0].className.indexOf('jqx-rc-all') == -1) {
                    this.dateTimeInput.addClass(this.toThemeProperty('jqx-rc-all'));
                }

                var top = parseInt(height) / 2 - parseInt(inputHeight) / 2;
                if (top > 0) {
                    var fontSize = this.dateTimeInput.css("font-size");
                    if ("" == fontSize) fontSize = 13;

                    var top = height - 2 - parseInt(fontSize) - 2;
                    if (isNaN(top)) top = 0;
                    if (top < 0) top = 0;

                    var topPadding = top / 2;

                    // fix for MSIE 6 and 7. These browsers double the top padding for some reason...
                    if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                        topPadding = top / 4;
                    }
                    this.dateTimeInput[0].style.paddingTop = Math.round(topPadding) + "px";
                    this.dateTimeInput[0].style.paddingBottom = Math.round(topPadding) + "px";
                }

                if (this.rtl) {
                    this.calendarButton[0].style.width = buttonWidth + 'px';
                    this.timeButton[0].style.width = buttonWidth + 'px';
                    this.calendarButton.css('left', '0px');
                    if (this.showCalendarButton) {
                        this.timeButton.css('left', buttonWidth + 'px');
                    }
                    else {
                        this.timeButton.css('left', '0px');
                    }


                    this.dateTimeInput.css('left', this.calendarButton.width());
                    if (this.showTimeButton && this.showCalendarButton) {
                        this.dateTimeInput.css('left', this.timeButton.width() + this.calendarButton.width());
                    }
                    if ($.jqx.browser.msie && $.jqx.browser.version <= 8) {
                        this.dateTimeInput.css('left', 1 + this.calendarButton.width());
                        if (this.showTimeButton && this.showCalendarButton) {
                            this.dateTimeInput.css('left', 1 + this.timeButton.width() + this.calendarButton.width());
                        }
                    }
                }
            },

            _removeHandlers: function () {
                var me = this;
                this.removeHandler($(document), 'mousedown.' + this.id);
                if (this.dateTimeInput) {
                    this.removeHandler(this.dateTimeInput, 'keydown.' + this.id);
                    this.removeHandler(this.dateTimeInput, 'blur');
                    this.removeHandler(this.dateTimeInput, 'focus');
                    this.removeHandler(this.host, 'focus');
                    this.removeHandler(this.dateTimeInput, 'mousedown');
                    this.removeHandler(this.dateTimeInput, 'mouseup');
                    this.removeHandler(this.dateTimeInput, 'keydown');
                    this.removeHandler(this.dateTimeInput, 'keyup');
                    this.removeHandler(this.dateTimeInput, 'keypress');
                }
                if (this.calendarButton != null) {
                    this.removeHandler(this.calendarButton, 'mousedown');
                }
                if (this.timeButton != null) {
                    this.removeHandler(this.timeButton, 'mousedown');
                }
                if (this.calendarContainer != null) {
                    this.removeHandler(this.calendarContainer, 'cellSelected');
                    this.removeHandler(this.calendarContainer, 'cellMouseDown');
                }
                this.removeHandler($(window), 'resize.' + this.id);
            },

            isOpened: function () {
                var me = this;
                var openedCalendar = $.data(document.body, "openedJQXCalendar" + this.id);
                if (openedCalendar != null && openedCalendar == me.calendarContainer) {
                    return true;
                }

                return false;
            },

            wheel: function (event, self) {
                if (!self.isEditing) {
                    return;
                }

                self.changeType = "mouse";
                var delta = 0;
                if (!event) /* For IE. */
                    event = window.event;
                if (event.originalEvent && event.originalEvent.wheelDelta) {
                    event.wheelDelta = event.originalEvent.wheelDelta;
                }
                if (event.wheelDelta) { /* IE/Opera. */
                    delta = event.wheelDelta / 120;
                } else if (event.detail) { /** Mozilla case. */
                    delta = -event.detail / 3;
                }

                if (delta) {
                    var result = self._handleDelta(delta);
                    if (!result) {
                        if (event.preventDefault)
                            event.preventDefault();
                        event.returnValue = false;
                        return result;
                    }
                    else return false;
                }

                if (event.preventDefault)
                    event.preventDefault();
                event.returnValue = false;
            },

            _handleDelta: function (delta) {
                if (delta < 0) {
                    this.spinDown();
                }
                else this.spinUp();

                return false;
            },

            focus: function () {
                try {
                    var me = this;
                    me._firstFocusDate = me.getDate();
                    this._setSelectionStart(0);
                    this._selectGroup(-1);
                    this.dateTimeInput.focus();
                    setTimeout(function () {
                        me._setSelectionStart(0);
                        me._selectGroup(-1);
                        me.dateTimeInput.focus();
                    }, 25);
                }
                catch (error) {
                }
            },

            _addHandlers: function () {
                var id = this.element.id;
                var el = this.element;
                var me = this;

                if (this.host.parents()) {
                    this.addHandler(this.host.parents(), 'scroll.datetimeinput' + this.element.id, function (event) {
                        var opened = me.isOpened();
                        if (opened) {
                            me.close();
                        }
                    });
                }

                this.addHandler(this.host, 'mouseenter', function () {
                    if (!me.disabled && me.enableHover) {
                        var hovered = true;
                        me.calendarButtonIcon.addClass(me.toThemeProperty('jqx-icon-calendar-hover'));
                        me.calendarButton.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                        if (me.showTimeButton) {
                            me.timeButtonIcon.addClass(me.toThemeProperty('jqx-icon-time-hover'));
                            me.timeButton.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                        }
                    }
                });
                this.addHandler(this.host, 'mouseleave', function () {
                    if (!me.disabled && me.enableHover) {
                        me.calendarButtonIcon.removeClass(me.toThemeProperty('jqx-icon-calendar-hover'));
                        me.calendarButton.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                        if (me.showTimeButton) {
                            me.timeButtonIcon.removeClass(me.toThemeProperty('jqx-icon-time-hover'));
                            me.timeButton.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                        }
                    }
                });

                this.addHandler(this.host, 'mousewheel', function (event) {
                    me.wheel(event, me);
                });

                this.addHandler($(document), 'mousedown.' + this.id, this._closeOpenedCalendar, { me: this });
                if ($.jqx.mobile.isTouchDevice()) {
                    this.addHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.' + this.id, this._closeOpenedCalendar, { me: this });
                }

                this.addHandler(this.dateTimeInput, 'keydown.' + this.id, function (event) {
                    var openedCalendar = $.data(document.body, "openedJQXCalendar" + me.id);
                    if (openedCalendar != null && openedCalendar == me.calendarContainer) {
                        var result = me.handleCalendarKey(event, me);
                        return result;
                    }
                });

                if (this.calendarContainer != null) {
                    this.addHandler(this.calendarContainer, 'keydown', function (event) {
                        if (event.keyCode == 13) {
                            if (me.isOpened()) {
                                if (!me._calendar._viewAnimating && me._calendar.view == "month") {
                                    me.hideCalendar('selected', 'keyboard');
                                    me.dateTimeInput.focus();
                                    return false;
                                }
                            }
                            return true;
                        }
                        else if (event.keyCode == 9) {
                            if (me.isOpened()) {
                                me.hideCalendar('selected', 'keyboard');
                                return true;
                            }
                        }
                        else if (event.keyCode == 27) {
                            if (me.isOpened()) {
                                me.hideCalendar(null, 'keyboard');
                                me.dateTimeInput.focus();
                                return false;
                            }
                            return true;
                        }

                        me.timePopup = false;
                        if (event.keyCode == 84) {
                            me.timePopup = true;
                        }

                        if (event.keyCode == 115) {
                            if (me.isOpened()) {
                                me.hideCalendar("keyboard", 'keyboard');
                                me.dateTimeInput.focus();
                                return false;
                            }
                            else if (!me.isOpened()) {
                                me.showCalendar("keyboard", 'keyboard');
                                me.dateTimeInput.focus();
                                return false;
                            }
                        }

                        if (event.altKey) {
                            if (event.keyCode == 38) {
                                if (me.isOpened()) {
                                    me.hideCalendar("keyboard", 'keyboard');
                                    me.dateTimeInput.focus();
                                    return false;
                                }
                            }
                            else if (event.keyCode == 40) {
                                if (!me.isOpened()) {
                                    me.showCalendar("keyboard", 'keyboard');
                                    me.dateTimeInput.focus();
                                    return false;
                                }
                            }
                        }
                    });

                    this.addHandler(this.calendarContainer, 'cellSelected',
                        function (event) {
                            if (me.closeCalendarAfterSelection) {
                                var calendarOldValue = $.data(document.body, "openedJQXCalendarValue");
                                if (event.args.selectionType == 'mouse') {
                                    if (me.selectionMode != 'range') {
                                        me.hideCalendar('selected', 'mouse');
                                    }
                                    else {
                                        if (me._calendar._clicks == 0) {
                                            me.hideCalendar('selected', 'mouse');
                                        }
                                    }
                                }
                            }
                        });

                    this.addHandler(this.calendarContainer, 'cellMouseDown',
                        function (event) {
                            if (me.closeCalendarAfterSelection) {
                                if (me._calendar.value) {
                                    $.data(document.body, "openedJQXCalendarValue", new $.jqx._jqxDateTimeInput.getDateTime(me._calendar.value.dateTime));
                                }
                            }
                        });
                }

                this.addHandler(this.dateTimeInput, 'blur', function (event) {
                    me.bar.removeClass('focused');
                    me.label.removeClass('focused');

                    me._endFullEdit();

                    if (me.value != null) {
                        me.isEditing = false;
                        var oldDay = me.value.dateTime.getDay();
                        var oldValue = me._oldDT;
                        me._validateValue(true);
                        if (event.stopPropagation) {
                            event.stopPropagation();
                        }
                        //if (me.selectableDays.length != 7) {
                        //    var dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                        //    var d = me.value.dateTime.getDay();
                        //    var name = dayNames[d];
                        //    if (me.selectableDays.length > 0) {
                        //        if (me.selectableDays.indexOf(name) == -1) {
                        //            if (me.value.dateTime < oldValue) {
                        //                while (me.selectableDays.indexOf(name) == -1) {
                        //                    me.value._addDays(-1);
                        //                    var d = me.value.dateTime.getDay();
                        //                    name = dayNames[d];
                        //                }
                        //            }
                        //            else {
                        //                while (me.selectableDays.indexOf(name) == -1) {
                        //                    me.value._addDays(1);
                        //                    var d = me.value.dateTime.getDay();
                        //                    name = dayNames[d];
                        //                }
                        //            }
                        //            me.value.day = me.value.dateTime.getDate();
                        //            me.value.month = me.value.dateTime.getMonth() + 1;
                        //            me._updateEditorsValue();
                        //        }
                        //    }
                        //}
                        me._updateText();
                        me._raiseEvent(9, event);
                    }
                    if (!me.isOpened()) {
                        me.host.removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                    }
                });

                this.addHandler(this.host, 'focus', function (event) {
                    me.focus();
                });

                this.addHandler(this.dateTimeInput, 'focus', function (event) {
                    me._firstFocusDate = me.getDate();
                    if (me.value != null) {
                        if (me.selectionMode != 'range') {
                            me._oldDT = new Date(me.value.dateTime);
                        }
                        else me._oldDT = me.getRange();
                        setTimeout(function () {
                            var selection = me._selection();
                            me.isEditing = true;
                            me._validateValue();
                            me._updateText();
                            me._setSelectionStart(0);
                            me._selectGroup(-1, selection);
                            me.host.addClass(me.toThemeProperty('jqx-fill-state-focus'));
                        });
                    }
                    else {
                        me._setSelectionStart(0);
                        me._selectGroup(-1);
                        me.host.addClass(me.toThemeProperty('jqx-fill-state-focus'));
                    }

                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }

                    me.bar.addClass('focused');
                    me.label.addClass('focused');

                    if (event.preventDefault) {
                        event.preventDefault();
                        return false;
                    }
                });

                var eventName = 'mousedown';
                if (this.touch) {
                    eventName = $.jqx.mobile.getTouchEventName('touchstart');
                }

                this.addHandler(this.calendarButton, eventName,
                    function (event) {
                        var calendar = me.container;
                        var isOpen = calendar.css('display') == 'block';
                        me.timePopup = false;
                        me.calendarPopup = true;
                        if (!me.disabled) {
                            if (!me.isanimating) {
                                if (isOpen) {
                                    me.hideCalendar();
                                    return false;
                                }
                                else {
                                    me.showCalendar("mouse");
                                    event.preventDefault();
                                }
                            }
                        }
                    });

                this.addHandler(this.timeButton, eventName,
                    function (event) {
                        var calendar = me.container;
                        var isOpen = calendar.css('display') == 'block';
                        me.timePopup = true;
                        me.calendarPopup = false;

                        if (!me.disabled) {
                            if (!me.isanimating) {
                                if (isOpen) {
                                    me.hideCalendar("mouse", 'mouse');
                                    return false;
                                }
                                else {
                                    me.showCalendar("mouse");
                                    event.preventDefault();
                                }
                            }
                        }
                    });

                this.addHandler(this.dateTimeInput, 'mousedown',
                    function (event) {
                        if (me.touch) {
                            if (me.showTimeButton === true && me.showCalendarButton === false) {
                                me.open('time');
                            }
                            else {
                                me.open();
                            }
                        }
                        return me._raiseEvent(2, event)
                    });

                this.addHandler(this.dateTimeInput, 'mouseup',
                    function (event) {
                        return me._raiseEvent(3, event)
                    });

                this.addHandler(this.dateTimeInput, 'keydown',
                    function (event) {
                        return me._raiseEvent(4, event)
                    });

                this.addHandler(this.dateTimeInput, 'keyup',
                    function (event) {
                        var value = this.value;

                        if (me._fullEditInProgress && me._enteredValue &&
                            me._mask[value.length] !== undefined) {
                            this.value = this.value + me._mask[value.length];
                        }

                        return me._raiseEvent(5, event)
                    });

                this.addHandler(this.dateTimeInput, 'keypress',
                    function (event) {
                        return me._raiseEvent(6, event)
                    });
            },

            createID: function () {
                var id = Math.random() + '';
                id = id.replace('.', '');
                id = '99' + id;
                id = id / 1;
                return 'dateTimeInput' + id;
            },

            setMaxDate: function (date, refresh) {
                if (date == null)
                    return;

                if (date != null && typeof (date) == "string") {
                    date = new Date(date);
                    if (!this._isValidDate(date))
                        return;
                }

                this.maxDate = $.jqx._jqxDateTimeInput.getDateTime(date);
                if (this._calendar != null) {
                    this._calendar.setMaxDate(date);
                }
                if (refresh != false) {
                    if (this.getDate() != null && this.getDate() > date) {
                        this.setDate(date);
                    }
                    //  $.jqx.aria(this, "aria-valuemax", date);
                    this._refreshValue();
                    this._updateText();
                }
            },

            getMaxDate: function () {
                if (this.maxDate != null && this.maxDate != undefined) {
                    return this.maxDate.dateTime;
                }

                return null;
            },

            setMinDate: function (date, refresh) {
                if (date == null)
                    return;

                if (date != null && typeof (date) == "string") {
                    date = new Date(date);
                    if (!this._isValidDate(date))
                        return;
                }

                this.minDate = $.jqx._jqxDateTimeInput.getDateTime(date);
                if (this._calendar != null) {
                    this._calendar.setMinDate(date);
                }
                if (refresh != false) {
                    if (this.getDate() != null && this.getDate() < date) {
                        this.setDate(date);
                    }
                    // $.jqx.aria(this, "aria-valuemin", date);
                    this._refreshValue();
                    this._updateText();
                }
            },

            getMinDate: function () {
                if (this.minDate != null && this.minDate != undefined) {
                    return this.minDate.dateTime;
                }

                return null;
            },

            _applyCulture: function () {
                var globalize = false;
                try {
                    if (window.Globalize != undefined) {
                        globalize = true;
                    }
                }
                catch (error) {
                }

                try {
                    if ($.global) {
                        $.global.preferCulture(this.culture);
                        this.localization.calendar = $.global.culture.calendar;
                    }
                    else if (globalize) {
                        var culture = Globalize.culture(this.culture);
                        this.localization.calendar = culture.calendar;
                    }
                    this._loadItems();
                    if (this._calendar != null) {
                        this._calendar.culture = this.culture;
                        this._calendar.localization = this.localization;
                        this._calendar.render();
                    }
                }
                catch (error) {
                }
            },

            propertyMap: function (key) {
                if (key == "value") {
                    if (this.selectionMode != 'range') {
                        return this.getDate();
                    }
                    else return this.getRange();
                }
                return null;
            },

            propertiesChangedHandler: function (object, oldValues, newValues) {
                if (newValues && newValues.width && newValues.height && Object.keys(newValues).length == 2) {
                    object.refresh();
                    object.close();
                }
            },

            propertyChangedHandler: function (object, key, oldvalue, value) {
                if (object.isInitialized == undefined || object.isInitialized == false)
                    return;

                if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                    return;
                }

                if (key == "dropDownVerticalAlignment") {
                    object.close();
                }

                if (key == "template") {
                    object.bar.removeClass(object.toThemeProperty("jqx-" + oldvalue));
                    object.label.removeClass(object.toThemeProperty("jqx-" + oldvalue));
                    object.timeButton.removeClass(object.toThemeProperty("jqx-" + oldvalue))
                    object.calendarButton.removeClass(object.toThemeProperty("jqx-" + oldvalue))
                    object.bar.addClass(object.toThemeProperty("jqx-" + object.template))
                    object.label.addClass(object.toThemeProperty("jqx-" + object.template))
                    object.timeButton.addClass(object.toThemeProperty("jqx-" + object.template))
                    object.calendarButton.addClass(object.toThemeProperty("jqx-" + object.template))
                }

                if (key == "restrictedDates") {
                    object.calendarContainer.css({ restrictedDates: value });
                }

                if (key == "popupZIndex") {
                    object.calendarContainer.css({ zIndex: value });
                }

                if (key == "showCalendarButton" || key === "showDeleteButton") {
                    object._arrange();
                }

                if (key == "showTimeButton") {
                    object._arrange();
                    if (object.timePopupElement) {
                        object.timePopupElement.remove();
                        object.timePopupElement = null;
                    }
                }

                if (key == "selectionMode") {
                    object._calendar.selectionMode = value;
                    object.refreshValue();
                }

                if (key == "min") {
                    if (typeof (value) == "string") {
                        object.setMinDate(new Date(value));
                    }
                    else {
                        object.setMinDate(value);
                    }
                }
                if (key == "max") {
                    if (typeof (value) == "string") {
                        object.setMaxDate(new Date(value));
                    }
                    else {
                        object.setMaxDate(value);
                    }
                }

                if (key == "value") {
                    if (value != null && value instanceof Date) {
                        if (isNaN(value.getFullYear()) || isNaN(value.getMonth()) || isNaN(value.getDate())) {
                            this.value = oldvalue;
                            return;
                        }

                        value = $.jqx._jqxDateTimeInput.getDateTime(value);
                    }
                    else if (value != null && typeof (value) == "string") {
                        var date = new Date(value);
                        if (date != undefined && !isNaN(date)) {
                            this.value = $.jqx._jqxDateTimeInput.getDateTime(date);
                        }
                    }
                }

                if (key == "views") {
                    object.calendarContainer.jqxCalendar({ views: value });
                }

                if (key == "enableViews") {
                    object.calendarContainer.jqxCalendar({ enableViews: value });
                }

                if (key == "selectableDays") {
                    object.calendarContainer.jqxCalendar({ selectableDays: value });
                }

                if (key == "showFooter") {
                    object.calendarContainer.jqxCalendar({ showFooter: value });
                }

                if (key == 'rtl') {
                    object.calendarContainer.jqxCalendar({ rtl: value });
                    if (value) {
                        object.dateTimeInput.css('direction', 'rtl');
                        object.dateTimeInput.addClass('jqx-rtl');
                    }
                    else {
                        object.dateTimeInput.css('direction', 'ltr');
                        object.dateTimeInput.removeClass('jqx-rtl');
                    }
                }

                if (key == 'todayString' || key == 'clearString') {
                    object.calendarContainer.jqxCalendar({ clearString: object.clearString, todayString: object.todayString });
                }

                if (key == 'dayNameFormat') {
                    object.calendarContainer.jqxCalendar({ dayNameFormat: value });
                }

                if (key == 'firstDayOfWeek') {
                    object.calendarContainer.jqxCalendar({ firstDayOfWeek: value });
                }
                if (key == 'showWeekNumbers') {
                    object.calendarContainer.jqxCalendar({ showWeekNumbers: value });
                }

                if (key == 'culture' || key == 'localization') {
                    object._applyCulture();
                }
                else if (key == 'formatString' || key === 'yearCutoff' && (value === null || oldvalue === null)) {
                    if (key === 'formatString') {
                        object._getMask();
                    }

                    object.items = new Array();
                    object._loadItems();
                }

                if (key == "theme") {
                    $.jqx.utilities.setTheme(oldvalue, value, object.host);
                    object.calendarContainer.jqxCalendar({ theme: value });
                }

                if (key == "width" || key == "height") {
                    object.close();
                    object.refresh();
                    return;
                }

                object._setOption(key, value, oldvalue);
                if (key == 'dropDownWidth' || key == 'dropDownHeight') {
                    object.calendarContainer.jqxCalendar({ width: object.dropDownWidth, height: object.dropDownHeight });
                    object._calendar.render();
                    object.container.height(object.calendarContainer.height());
                    object.container.width(object.calendarContainer.width());
                }
            },

            clear: function () {
                if (this.allowNullDate) {
                    if (this.selectionMode != 'range') {
                        this.setDate(null);
                    }
                    else {
                        this._calendar._clicks = 1
                        this.setRange(null, null);
                    }
                    this._calendar._clicks = 0
                }
                else {
                    if (this.selectionMode != 'range') {
                        this.setDate(this.getMinDate());
                    }
                    else {
                        this._calendar._clicks = 1
                        this.setRange(this.getMinDate(), this.getMinDate());
                        this._calendar._clicks = 0
                    }
                }
                this.hideCalendar();
            },

            today: function () {
                var date = new Date();
                date.setHours(0, 0, 0, 0);
                if (this.selectionMode != 'range') {
                    this.setDate(date);
                }
                else {
                    this._calendar._clicks = 0
                    var toDate = new Date();
                    toDate.setHours(23, 59, 59, 0);
                    this.setRange(date, toDate);
                    this._calendar._clicks = 0
                }

                this.hideCalendar();
            },

            _isValidDate: function (date) {
                if (date == null) {
                    return true;
                }

                if (typeof (date) !== 'object')
                    return false;

                if (date !== null && date.getFullYear) {
                    return true;
                }

                if (date == "Invalid Date" || date.valueOf() < 0 || isNaN(date.valueOf()))
                    return false;

                return true;
            },

            setDate: function (date) {
                var oldDate = this.getDate();
                if (date != null && typeof (date) == "string") {
                    var beforeParse = date;
                    if (date.toString().indexOf(',') >= 0) {
                        date = date.replace(/\,/g, '/');
                        date = new Date(date);
                        if (!this._isValidDate(date)) {
                            date = beforeParse;
                        }
                    }
                    if (date.toString().indexOf('-') >= 0) {
                        date = date.replace(/\-/g, '/');
                        date = new Date(date);

                        if (!this._isValidDate(date)) {
                            date = beforeParse;
                        }

                        if (date.getFullYear && isNaN(date.getFullYear)) {
                            date = beforeParse;
                        }
                    }
                    if (date != '') {
                        var tmpDate = date;
                        if (window.Globalize != undefined) {
                            date = window.Globalize.parseDate(tmpDate, this.formatString, this.culture);
                        }
                        else if ($.jqx.dataFormat) {
                            date = $.jqx.dataFormat.parsedate(tmpDate, this.formatString, this.localization.calendar);
                        }
                        else {
                            date = new Date(date);
                        }

                        if (date === null && tmpDate !== null) {
                            if (this._isValidDate(tmpDate)) {
                                date = tmpDate;
                            }
                        }

                        if (!this._isValidDate(date)) {
                            return;
                        }
                    }
                }

                if (date == null || date == 'null' || date == 'undefined') {
                    if (!this.allowNullDate) {
                        date = this.min;
                    }
                }

                if (!this._isValidDate(date))
                    date = null;

                if (date == null || date == 'null' || date == 'undefined' || date === '') {
                    if (this.value != null) {
                        this.value = null;
                        this._calendar.setDate(null);
                        this._refreshValue();
                        if (this.cookies) {
                            if (this.value != null) {
                                $.jqx.cookie.cookie("jqxDateTimeInput" + this.element.id, this.value.dateTime.toString(), this.cookieoptions);
                            }
                        }
                        this._setSelectionStart(0);
                        this._selectGroup(-1);
                        this._raiseEvent('0', date, oldDate);
                        this._raiseEvent('9', date, oldDate);
                    }
                    return;
                }

                if (date < this.getMinDate() || date > this.getMaxDate()) {
                    return;
                }

                if (this.value == null) {
                    this.value = new $.jqx._jqxDateTimeInput.getDateTime(new Date());
                    this.value._setHours(0);
                    this.value._setMinutes(0);
                    this.value._setSeconds(0);
                    this.value._setMilliseconds(0);
                }

                if (date.getFullYear) {
                    this.value._setYear(date.getFullYear());
                    this.value._setDay(1);
                    this.value._setMonth(date.getMonth() + 1);
                    this.value._setHours(date.getHours());
                    this.value._setMinutes(date.getMinutes());
                    this.value._setSeconds(date.getSeconds());
                    this.value._setMilliseconds(date.getMilliseconds());
                    this.value._setDay(date.getDate());
                }

                this._validateTimeRange();
                this._refreshValue();

                if (this.cookies) {
                    if (this.value != null) {
                        $.jqx.cookie.cookie("jqxDateTimeInput" + this.element.id, this.value.dateTime.toString(), this.cookieoptions);
                    }
                }

                var newDate = this.getDate();

                var diff = (newDate - oldDate);
                if (diff != 0) {
                    this._raiseEvent('0', date, oldDate);
                    this._raiseEvent('9', date, oldDate);
                    return true;
                }
            },

            getDate: function () {
                if (this.value == undefined)
                    return null;

                return new Date(this.value.dateTime);
            },

            getText: function () {
                return this.dateTimeInput.val();
            },

            setRange: function (from, to) {
                if (typeof (from) == 'object' && !this._isValidDate(from))
                    from = null;

                if (typeof (to) == 'object' && !this._isValidDate(to))
                    to = null;

                if (from != null && typeof (from) == "string") {
                    from = new Date(from);
                    if (!this._isValidDate(from))
                        return;
                }
                if (to != null && typeof (to) == "string") {
                    to = new Date(to);
                    if (!this._isValidDate(to))
                        return;
                }

                if (from && isNaN(from) && from.toString() == "NaN" && typeof (from) != "string") {
                    return;
                }
                if (to && isNaN(to) && to.toString() == "NaN" && typeof (to) != "string") {
                    return;
                }
                this._calendar.setRange(from, to);
                if (to && from && (to.valueOf() != from.valueOf())) {
                    this._range = { from: from, to: to };
                }
                else {
                    this._range = this._calendar.getRange();
                }

                var date = from;
                if (date != null && date.getFullYear) {
                    if (this.value == null) {
                        this.value = new $.jqx._jqxDateTimeInput.getDateTime(new Date());
                        this.value._setHours(0);
                        this.value._setMinutes(0);
                        this.value._setSeconds(0);
                        this.value._setMilliseconds(0);
                    }

                    this.value._setYear(date.getFullYear());
                    this.value._setMonth(date.getMonth() + 1);
                    this.value._setHours(date.getHours());
                    this.value._setMinutes(date.getMinutes());
                    this.value._setSeconds(date.getSeconds());
                    this.value._setMilliseconds(date.getMilliseconds());
                    this.value._setDay(date.getDate());
                }
                this._refreshValue();
                if (this.value) {
                    this._raiseEvent('0', this.value.dateTime);
                }
                else {
                    this._raiseEvent('0', null);
                }
            },

            getRange: function () {
                var range = this._calendar.getRange();
                if (this._range) {
                    var from = this._range.from;
                    var to = this._range.to;
                    if (to && from && (to.valueOf() != from.valueOf())) {
                        if (range.from) {
                            range.from.setHours(from.getHours(), from.getMinutes(), from.getSeconds(), from.getMilliseconds());
                        }
                        if (range.to) {
                            range.to.setHours(to.getHours(), to.getMinutes(), to.getSeconds(), to.getMilliseconds());
                        }
                    }
                }
                return range;
            },

            _validateValue: function (blur) {
                var needValueUpdate = false;

                for (var i = 0; i < this.items.length; i++) {
                    var editValue = this.editors[i].value;
                    switch (this.items[i].type) {
                        case 'FORMAT_AMPM':
                            if (editValue < 0) {
                                editValue = 0;
                            }
                            else if (editValue > 1) {
                                editValue = 1;
                            }
                            break;
                        case 'Character':
                            break;
                        case 'Day':
                            if (editValue < 1) {
                                editValue = 1;
                            }
                            else if (editValue > 31) {
                                editValue = 31;
                            }
                            break;
                        case 'FORMAT_hh':
                            if (editValue < 1) {
                                editValue = 1;
                            }
                            else if (editValue > 12) {
                                editValue = 12;
                            }
                            break;
                        case 'FORMAT_HH':
                            if (editValue < 0) {
                                editValue = 0;
                            }
                            else if (editValue > 23) {
                                editValue = 23;
                            }
                            break;
                        case 'Millisecond':
                            if (editValue < 0) {
                                editValue = 0;
                            }
                            else if (editValue > 999) {
                                editValue = 999;
                            }
                            break;
                        case 'Minute':
                            if (editValue < 0) {
                                editValue = 0;
                            }
                            else if (editValue > 59) {
                                editValue = 59;
                            }
                            break;
                        case 'Month':
                            if (editValue < 1) {
                                editValue = 1;
                            }
                            else if (editValue > 12) {
                                editValue = 12;
                            }
                            break;
                        case 'ReadOnly':
                            break;
                        case 'Second':
                            if (editValue < 0) {
                                editValue = 0;
                            }
                            else if (editValue > 59) {
                                editValue = 59;
                            }
                            break;
                        case 'Year':
                            if (editValue < this.minDate.year) {
                                editValue = this.minDate.year;
                            }
                            else if (editValue > this.maxDate.year) {
                                editValue = this.maxDate.year;
                            }
                            break;
                    }

                    if (this.editors[i].value != editValue) {
                        this.editors[i].value = editValue;
                        needValueUpdate = true;
                    }
                }

                this.updateValue(blur);

                if (this.value != null && blur === true) {
                    if (this.value.dateTime > this.maxDate.dateTime) {
                        this._internalSetValue(this.maxDate);
                        this._updateEditorsValue();
                    }
                    else if (this.value.dateTime < this.minDate.dateTime) {
                        this._internalSetValue(this.minDate);
                        this._updateEditorsValue();
                    }
                    this._updateText();
                }
            },

            spinUp: function () {
                var value = this.value;
                if (value == null)
                    return;

                if (this.activeEditor != null) {
                    var currentEditorIndex = this.editors.indexOf(this.activeEditor);
                    if (currentEditorIndex == -1) return;
                    if (this.items[currentEditorIndex].type == 'Day') {
                        if (this.value != null) {
                            this.activeEditor.maxValue = this.value._daysInMonth(this.value.year, this.value.month);
                        }
                    }

                    var positions = this.activeEditor.positions;
                    this.activeEditor.increaseValue(this.enableAbsoluteSelection);

                    this.activeEditor.positions = positions;
                }

                if (this.isEditing) this.isEditing = false;

                this.updateValue();
                this.isEditing = true;
                this._updateText();

                var index1 = this.editors.indexOf(this.activeEditor);
                if (index1 >= 0) {
                    this._selectGroup(index1);
                }
            },

            spinDown: function () {
                var value = this.value;
                if (value == null)
                    return;

                if (this.activeEditor != null) {
                    var currentEditorIndex = this.editors.indexOf(this.activeEditor);
                    if (currentEditorIndex == -1) return;
                    if (this.items[currentEditorIndex].type == 'Day') {
                        if (this.value != null) {
                            this.activeEditor.maxValue = this.value._daysInMonth(this.value.year, this.value.month);
                        }
                    }

                    var positions = this.activeEditor.positions;
                    this.activeEditor.decreaseValue(this.enableAbsoluteSelection);
                    this.activeEditor.positions = positions;
                }

                if (this.isEditing) this.isEditing = false;

                this.updateValue();
                this.isEditing = true;
                this._updateText();

                var index1 = this.editors.indexOf(this.activeEditor);
                if (index1 >= 0) {
                    this._selectGroup(index1);
                }
            },

            _passKeyToCalendar: function (event) {
                if (event.keyCode == 13 || event.keyCode == 9) {
                    this.hideCalendar('selected', 'keyboard');
                    return true;
                }
                else if (event.keyCode == 27) {
                    var calendar = this.calendarContainer;
                    var calendarInstance = this._calendar;
                    var closeAfterSelection = this.closeCalendarAfterSelection;
                    this.closeCalendarAfterSelection = false;
                    calendarInstance.setDate(this.value.dateTime);
                    this.closeCalendarAfterSelection = closeAfterSelection;
                    this.hideCalendar();
                }

                var closeAfterSelection = this.closeCalendarAfterSelection;
                this.closeCalendarAfterSelection = false;
                var result = this._calendar._handleKey(event);
                this.closeCalendarAfterSelection = closeAfterSelection;
                return result;
            },

            handleCalendarKey: function (event, me) {
                var $target = $(event.target);
                var openedCalendar = $.data(document.body, "openedJQXCalendar" + this.id);
                if (openedCalendar != null) {
                    if (openedCalendar.length > 0) {
                        var result = me._passKeyToCalendar(event);
                        return result;
                    }
                }

                return true;
            },

            _findPos: function (obj) {
                if (obj == null)
                    return;

                while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
                    obj = obj['nextSibling'];
                }
                var position = $(obj).coord(true);
                return [position.left, position.top];
            },

            testOffset: function (element, offset, inputHeight) {
                var dpWidth = element.outerWidth();
                var dpHeight = element.outerHeight();
                var viewWidth = $(window).width() + $(window).scrollLeft();
                var viewHeight = $(window).height() + $(window).scrollTop();
                if (offset.left + dpWidth > viewWidth) {
                    if (dpWidth > this.host.width()) {
                        var hostLeft = this.host.coord().left;
                        var hOffset = dpWidth - this.host.width();
                        offset.left = hostLeft - hOffset + 2;
                    }
                }
                if (offset.left < 0) {
                    offset.left = parseInt(this.host.coord().left) + 'px'
                }

                offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                    Math.abs(dpHeight + inputHeight + 23) : 0);

                return offset;
            },

            open: function (mode) {
                if (mode == "time") {
                    this.timePopup = true;
                }
                else {
                    this.timePopup = false;
                }
                this.showCalendar();
            },

            close: function (reason) {
                this.hideCalendar();
            },

            _getBodyOffset: function () {
                var top = 0;
                var left = 0;
                if ($('body').css('border-top-width') != '0px') {
                    top = parseInt($('body').css('border-top-width'));
                    if (isNaN(top)) top = 0;
                }
                if ($('body').css('border-left-width') != '0px') {
                    left = parseInt($('body').css('border-left-width'));
                    if (isNaN(left)) left = 0;
                }
                return { left: left, top: top };
            },

            initTimePopup: function () {
                this.timePopupElement = $("<div style='border-style: solid; border-width: 0px;'></div>").appendTo(this.timeContainer);
                this.timePopupElement.addClass(this.toThemeProperty('jqx-widget-content jqx-widget jqx-date-time-input-popup'));
                var popupTable = "";
                popupTable += "<table>"
                    + "<tbody>"
                    + "<tr>"
                    + "<td><a class='increment-hour-column' href='javascript:;' data-action='incrementHour'><div class='jqx-icon-up'></div></a>"
                    + "</td>"
                    + "<td class='separator'>&nbsp;</td>"
                    + "<td><a class='increment-minute-column' href='javascript:;' data-action='incrementMinute'><div class='jqx-icon-up'></div></a>"
                    + "</td>"
                    + "<td class='separator'>&nbsp;</td>"
                    + "<td><a class='increment-second-column' href='javascript:;' data-action='incrementSecond'><div class='jqx-icon-up'></div></a>"
                    + "</td>"
                    + "<td class='separator'>&nbsp;</td>"
                    + "<td><a class='increment-millisecond-column' href='javascript:;' data-action='incrementMSSecond'><div class='jqx-icon-up'></div></a>"
                    + "</td>"
                    + "<td class='separator'>&nbsp;</td>"
                    + "<td class='increment-meridian-column'><a href='javascript:;' data-action='toggleMeridian'><div class='jqx-icon-up'></div></a>"
                    + "</td>"
                    + "</tr>"
                    + "<tr>"
                    + "<td>"
                    + "<input type='text' class='jqx-timepicker-hour' maxlength='2'>"
                    + "</td>"
                    + "<td class='separator'>:</td>"
                    + "<td>"
                    + "<input type='text' class='jqx-timepicker-minute' maxlength='2'>"
                    + "</td>"
                    + "<td class='separator'>:</td>"
                    + "<td>"
                    + "<input type='text' class='jqx-timepicker-second' maxlength='2'>"
                    + "</td>"
                    + "<td class='separator'>:</td>"
                    + "<td>"
                    + "<input type='text' class='jqx-timepicker-millisecond' maxlength='3'>"
                    + "</td>"
                    + "<td class='separator'>&nbsp;</td>"
                    + "<td>"
                    + "<input type='text' class='jqx-timepicker-meridian' maxlength='2'>"
                    + "</td>"
                    + "</tr>"
                    + "<tr>"
                    + "<td><a class='decrement-hour-column' href='javascript:;' data-action='decrementHour'><div class='jqx-icon-down'></div></a>"
                    + "</td>"
                    + "<td class='separator'></td>"
                    + "<td><a class='decrement-minute-column' href='javascript:;' data-action='decrementMinute'><div class='jqx-icon-down'></div></a>"
                    + "</td>"
                    + "<td class='separator'></td>"
                    + "<td><a class='decrement-second-column' href='javascript:;' data-action='decrementSecond'><div class='jqx-icon-down'></div></a>"
                    + "</td>"
                    + "<td class='separator'></td>"
                    + "<td><a class='decrement-millisecond-column' href='javascript:;' data-action='decrementMillisecond'><div class='jqx-icon-down'></div></a>"
                    + "</td>"
                    + "<td class='separator'>&nbsp;</td>"
                    + "<td><a class='decrement-meridian-column' href='javascript:;' data-action='toggleMeridian'><div class='jqx-icon-down'></div></a>"
                    + "</td>"
                    + "</tr>"
                    + "</tbody>"
                    + "</table>";
                var formatString = this._getFormatValue(this.formatString);

                if (this.selectionMode != "range") {
                    this.timePopupElement[0].innerHTML = popupTable;
                }
                else {
                    this.timePopupElement[0].innerHTML = "<table><tr><td>" + popupTable + "</td><td>-</td><td>" + popupTable + "</td></tr></table>";
                }
                this.timePopupElement.find('.jqx-icon-down').addClass(this.toThemeProperty('jqx-icon jqx-icon-arrow-down'));
                this.timePopupElement.find('.jqx-icon-up').addClass(this.toThemeProperty('jqx-icon jqx-icon-arrow-up'));
                var inputs = this.timePopupElement.find('input');
                inputs.addClass(this.toThemeProperty('jqx-input'));
                inputs.addClass(this.toThemeProperty('jqx-rc-all'));
                this.addHandler(inputs, "mousedown", function (event) {
                    event.stopPropagation();
                });

                var spinDown = function (event) {
                    if (event.target.className.indexOf("hour") >= 0) {
                        that._decrementHour($(event.target));
                    }
                    if (event.target.className.indexOf("minute") >= 0) {
                        that._decrementMinuteSecond($(event.target));
                    }
                    if (event.target.className.indexOf("second") >= 0) {
                        that._decrementMinuteSecond($(event.target));
                    }
                    if (event.target.className.indexOf("millisecond") >= 0) {
                        that._decrementMillisecond($(event.target));
                    }
                    if (event.target.className.indexOf("meridian") >= 0) {
                        that._decrementMeridian($(event.target));
                    }
                }

                var spinUp = function (event) {
                    if (event.target.className.indexOf("hour") >= 0) {
                        that._incrementHour($(event.target));
                    }
                    if (event.target.className.indexOf("minute") >= 0) {
                        that._incrementMinuteSecond($(event.target));
                    }
                    if (event.target.className.indexOf("second") >= 0) {
                        that._incrementMinuteSecond($(event.target));
                    }
                    if (event.target.className.indexOf("millisecond") >= 0) {
                        that._incrementMillisecond($(event.target));
                    }
                    if (event.target.className.indexOf("meridian") >= 0) {
                        that._incrementMeridian($(event.target));
                    }
                }

                var wheel = function (event, self) {
                    if (!self.isEditing)
                        return;

                    var delta = 0;
                    if (!event) /* For IE. */
                        event = window.event;
                    if (event.originalEvent && event.originalEvent.wheelDelta) {
                        event.wheelDelta = event.originalEvent.wheelDelta;
                    }
                    if (event.originalEvent && event.originalEvent.deltaY != undefined) {
                        delta = -event.originalEvent.deltaY;
                    }

                    if (event.wheelDelta) { /* IE/Opera. */
                        delta = event.wheelDelta / 120;
                    } else if (event.detail) { /** Mozilla case. */
                        delta = -event.detail / 3;
                    }

                    if (delta) {
                        if (document.activeElement == event.target && event.target.nodeName.toLowerCase() == "input") {
                            if (delta < 0) {
                                spinDown(event);
                            }
                            else {
                                spinUp(event);
                            }
                        }
                        if (event.preventDefault)
                            event.preventDefault();
                        event.returnValue = false;
                    }

                    if (event.preventDefault)
                        event.preventDefault();
                    event.returnValue = false;
                }


                this.addHandler(inputs, "wheel", function (event) {
                    wheel(event, that);
                });
                this.addHandler(inputs, "keydown", function (event) {
                    var input = $(event.target);
                    if (event.ctrlKey) {
                        if (event.keyCode == 38) {
                            if (that.isOpened()) {
                                that.hideCalendar("keyboard", "keyboard");
                                that.dateTimeInput.focus();
                                return false;
                            }
                        }
                        else if (event.keyCode == 40) {
                            if (!that.isOpened()) {
                                that.showCalendar("keyboard", "keyboard");
                                that.dateTimeInput.focus();
                                return false;
                            }
                        }
                    }

                    if (event.keyCode == 40) {
                        spinDown(event);
                        event.preventDefault();
                    }
                    else if (event.keyCode == 38) {
                        spinUp(event);
                        event.preventDefault();
                    }
                    else if (event.keyCode == 13) {
                        event.preventDefault();
                        that.hideCalendar("keyboard", "keyboard");
                        that.dateTimeInput.focus();
                    }
                    else if (event.keyCode == 27) {
                        event.preventDefault();
                        that.hideCalendar("cancel");
                        that.dateTimeInput.focus();
                    }
                });
                this.hourInput = $(inputs[0]);
                this.minuteInput = $(inputs[1]);
                this.secondInput = $(inputs[2]);
                this.mssecondInput = $(inputs[3]);
                this.meridianInput = $(inputs[4]);

                this.hourInput2 = $(inputs[5]);
                this.minuteInput2 = $(inputs[6]);
                this.secondInput2 = $(inputs[7]);
                this.mssecondInput2 = $(inputs[8]);
                this.meridianInput2 = $(inputs[9]);
                var that = this;
                var hourIncrementColumns = this.timePopupElement.find('.increment-hour-column');
                this.hourIncrement = $(hourIncrementColumns[0]);
                this.hourIncrement2 = $(hourIncrementColumns[1]);
                this.addHandler(inputs, "change", function (event) {
                    var input = $(event.target);
                    if (input.val().length <= 1) {
                        input.val("0" + $(event.target).val());
                    }
                    if (event.target.className.indexOf("hour") >= 0) {
                        var value = parseInt($(event.target).val());
                        if (formatString.indexOf('HH') >= 0) {
                            while (value > 24) value = value - 24;
                        }
                        else {
                            while (value > 12) value = value - 12;
                        }
                        if (value < 10) value = "0" + value;
                        if (input.val() != value) {
                            input.val(value);
                        }
                    }
                    if (event.target.className.indexOf("minute") >= 0 || event.target.className.indexOf("second") >= 0) {
                        var value = parseInt($(event.target).val());
                        while (value > 59) value--;
                        if (value < 10) value = "0" + value;
                        if (input.val() != value) {
                            input.val(value);
                        }
                    }
                });

                this._incrementHour = function (input) {
                    var value = parseInt(input.val());
                    value++;
                    if (formatString.indexOf('HH') >= 0) {
                        if (value > 23) value = 0;
                    }
                    else if (value > 12) value = 1;
                    if (value < 10) value = "0" + value;
                    input.val(value);
                }

                this._incrementMinuteSecond = function (input) {
                    var value = parseInt(input.val());
                    value++;
                    if (value > 59) value = 0;
                    if (value < 10) value = "0" + value;
                    input.val(value);
                }
                this._incrementMillisecond = function (input) {
                    var value = parseInt(input.val());
                    value++;
                    if (value > 999) value = 0;
                    if (value < 10) value = "0" + value;
                    input.val(value);
                }
                this._incrementMeridian = function (input) {
                    var value = input.val();
                    if (value.toLowerCase().indexOf("a") >= 0) {
                        value = "PM";
                    }
                    else value = "AM";
                    input.val(value);
                }
                this._decrementHour = function (input) {
                    var value = parseInt(input.val());
                    value--;
                    if (formatString.indexOf('HH') >= 0) {
                        if (value < 0) value = 23;
                    }
                    else if (value < 1) value = 12;
                    if (value < 10) value = "0" + value;
                    input.val(value);
                }

                this._decrementMinuteSecond = function (input) {
                    var value = parseInt(input.val());
                    value--
                    if (value < 0) value = 59;
                    if (value < 10) value = "0" + value;
                    input.val(value);
                }
                this._decrementMillisecond = function (input) {
                    var value = parseInt(input.val());
                    value--
                    if (value < 0) value = 999;
                    if (value < 10) value = "0" + value;
                    input.val(value);
                }
                this._decrementMeridian = function (input) {
                    var value = input.val();
                    if (value.toLowerCase().indexOf("a") >= 0) {
                        value = "PM";
                    }
                    else value = "AM";
                    input.val(value);
                }

                this.addHandler(this.hourIncrement, "mousedown", function (event) {
                    event.stopPropagation();
                    that._incrementHour(that.hourInput);
                });
                this.addHandler(this.hourIncrement2, "mousedown", function (event) {
                    event.stopPropagation();
                    that._incrementHour(that.hourInput2);
                });
                var minuteIncrementColumns = this.timePopupElement.find('.increment-minute-column');
                this.minuteIncrement = $(minuteIncrementColumns[0]);
                this.minuteIncrement2 = $(minuteIncrementColumns[1]);
                this.addHandler(this.minuteIncrement, "mousedown", function (event) {
                    event.stopPropagation();
                    that._incrementMinuteSecond(that.minuteInput);
                });
                this.addHandler(this.minuteIncrement2, "mousedown", function (event) {
                    event.stopPropagation();
                    that._incrementMinuteSecond(that.minuteInput2);
                });
                var secondIncrementColumns = this.timePopupElement.find('.increment-second-column');
                this.secondIncrement = $(secondIncrementColumns[0]);
                this.secondIncrement2 = $(secondIncrementColumns[1]);
                this.addHandler(this.secondIncrement, "mousedown", function (event) {
                    event.stopPropagation();
                    that._incrementMinuteSecond(that.secondInput);
                });
                this.addHandler(this.secondIncrement2, "mousedown", function (event) {
                    event.stopPropagation();
                    that._incrementMinuteSecond(that.secondInput2);
                });
                var millisecondsIncrementColumns = this.timePopupElement.find('.increment-millisecond-column');
                this.millisecondsIncrement = $(millisecondsIncrementColumns[0]);
                this.millisecondsIncrement2 = $(millisecondsIncrementColumns[1]);
                this.addHandler(this.millisecondsIncrement, "mousedown", function (event) {
                    event.stopPropagation();
                    that._incrementMillisecond(that.mssecondInput);
                });
                this.addHandler(this.millisecondsIncrement2, "mousedown", function (event) {
                    event.stopPropagation();
                    that._incrementMillisecond(that.mssecondInput2);

                });
                var meridianIncrementColumns = this.timePopupElement.find('.increment-meridian-column');
                this.meridianIncrement = $(meridianIncrementColumns[0]);
                this.meridianIncrement2 = $(meridianIncrementColumns[1]);
                this.addHandler(this.meridianIncrement, "mousedown", function (event) {
                    event.stopPropagation();
                    that._incrementMeridian(that.meridianInput);
                });
                this.addHandler(this.meridianIncrement2, "mousedown", function (event) {
                    event.stopPropagation();
                    that._incrementMeridian(that.meridianInput2);
                });
                // decrement
                var hourDecrementColumns = this.timePopupElement.find('.decrement-hour-column');
                this.hourDecrement = $(hourDecrementColumns[0]);
                this.hourDecrement2 = $(hourDecrementColumns[1]);
                this.addHandler(this.hourDecrement, "mousedown", function (event) {
                    event.stopPropagation();
                    that._decrementHour(that.hourInput);
                });
                this.addHandler(this.hourDecrement2, "mousedown", function (event) {
                    event.stopPropagation();
                    that._decrementHour(that.hourInput2);
                });
                var minuteDecrementColumns = this.timePopupElement.find('.decrement-minute-column');
                this.minuteDecrement = $(minuteDecrementColumns[0]);
                this.minuteDecrement2 = $(minuteDecrementColumns[1]);
                this.addHandler(this.minuteDecrement, "mousedown", function (event) {
                    event.stopPropagation();
                    that._decrementMinuteSecond(that.minuteInput);
                });
                this.addHandler(this.minuteDecrement2, "mousedown", function (event) {
                    event.stopPropagation();
                    that._decrementMinuteSecond(that.minuteInput2);
                });
                var secondDecrementColumns = this.timePopupElement.find('.decrement-second-column');
                this.secondDecrement = $(secondDecrementColumns[0]);
                this.secondDecrement2 = $(secondDecrementColumns[1]);
                this.addHandler(this.secondDecrement, "mousedown", function (event) {
                    event.stopPropagation();
                    that._decrementMinuteSecond(that.secondInput);
                });
                this.addHandler(this.secondDecrement2, "mousedown", function (event) {
                    event.stopPropagation();
                    that._decrementMinuteSecond(that.secondInput2);
                });
                var millisecondsDecrementColumns = this.timePopupElement.find('.decrement-millisecond-column');
                this.millisecondsDecrement = $(millisecondsDecrementColumns[0]);
                this.millisecondsDecrement2 = $(millisecondsDecrementColumns[1]);
                this.addHandler(this.millisecondsDecrement, "mousedown", function (event) {
                    event.stopPropagation();
                    that._decrementMillisecond(that.mssecondInput);
                });
                this.addHandler(this.millisecondsDecrement2, "mousedown", function (event) {
                    event.stopPropagation();
                    that._decrementMillisecond(that.mssecondInput2);
                });
                var meridianDecrementColumns = this.timePopupElement.find('.decrement-meridian-column');
                this.meridianDecrement = $(meridianDecrementColumns[0]);
                this.meridianDecrement2 = $(meridianDecrementColumns[1]);
                this.addHandler(this.meridianDecrement, "mousedown", function (event) {
                    event.stopPropagation();
                    that._decrementMeridian(that.meridianInput);
                });
                this.addHandler(this.meridianDecrement2, "mousedown", function (event) {
                    event.stopPropagation();
                    that._decrementMeridian(that.meridianInput2);
                });

                var table = this.timePopupElement.find('table');
                this.addHandler(this.timePopupElement, "mousedown", function (event) {
                    event.stopPropagation();
                });

                var hideByTable = function (table) {
                    var rows = table.find('tr');
                    if (formatString.indexOf('mm') == -1) {
                        that.minuteInput.hide();
                        that.minuteInput2.hide();
                        $($(rows[0]).children()[1]).hide();
                        $($(rows[0]).children()[2]).hide();
                        $($(rows[1]).children()[1]).hide();
                        $($(rows[1]).children()[2]).hide();
                        $($(rows[2]).children()[1]).hide();
                        $($(rows[2]).children()[2]).hide();
                    }
                    if (formatString.indexOf('ss') == -1) {
                        that.secondInput.hide();
                        that.secondInput2.hide();
                        $($(rows[0]).children()[3]).hide();
                        $($(rows[0]).children()[4]).hide();
                        $($(rows[1]).children()[3]).hide();
                        $($(rows[1]).children()[4]).hide();
                        $($(rows[2]).children()[3]).hide();
                        $($(rows[2]).children()[4]).hide();
                    }
                    if (formatString.indexOf('tt') == -1 && formatString.indexOf('hh') == -1) {
                        that.meridianInput.hide();
                        that.meridianInput2.hide();
                        $($(rows[0]).children()[7]).hide();
                        $($(rows[0]).children()[8]).hide();
                        $($(rows[1]).children()[7]).hide();
                        $($(rows[1]).children()[8]).hide();
                        $($(rows[2]).children()[7]).hide();
                        $($(rows[2]).children()[8]).hide();
                    }
                    if (formatString.indexOf('zz') == -1) {
                        that.mssecondInput.hide();
                        that.mssecondInput2.hide();
                        $($(rows[0]).children()[5]).hide();
                        $($(rows[0]).children()[6]).hide();
                        $($(rows[1]).children()[5]).hide();
                        $($(rows[1]).children()[6]).hide();
                        $($(rows[2]).children()[5]).hide();
                        $($(rows[2]).children()[6]).hide();
                    }
                }
                if (table.length == 1) {
                    hideByTable(table);
                }
                else {
                    hideByTable($($(table)[1]));
                    hideByTable($($(table)[2]));
                }
            },

            updateTimePopup: function () {
                var formatString = this._getFormatValue(this.formatString);
                if (this.selectionMode != "range") {
                    var date = this.getDate();
                    if (this.hourInput) {
                        if (date) {
                            var hour = date.getHours();
                            var minute = date.getMinutes();
                            var meridian = date.getHours();
                            var second = date.getSeconds();
                            var milliseconds = date.getMilliseconds();
                        }
                        else {
                            var hour = 0;
                            var minute = 0;
                            var meridian = 0;
                            var second = 0;
                            var milliseconds = 0;
                        }

                        if (hour >= 12) {
                            meridian = "PM";
                            if (formatString.indexOf("HH") == -1) {
                                hour -= 12;
                                if (hour == 0) hour = 12;
                            }
                        }
                        else meridian = "AM";
                        if (this.meridianInput.css('display') != "none") {
                            if (hour == 0) hour = 12;
                        }

                        if (hour < 10) hour = "0" + hour;
                        if (minute < 10) minute = "0" + minute;
                        if (second < 10) second = "0" + second;
                        if (milliseconds < 10) milliseconds = "0" + milliseconds;

                        this.hourInput.val(hour);
                        this.minuteInput.val(minute);
                        this.secondInput.val(second);
                        this.mssecondInput.val(milliseconds);
                        this.meridianInput.val(meridian);
                    }
                }
                else {
                    var date = this.getRange().from;
                    if (this.hourInput) {
                        if (date) {
                            var hour = date.getHours();
                            var minute = date.getMinutes();
                            var meridian = date.getHours();
                            var second = date.getSeconds();
                            var milliseconds = date.getMilliseconds();
                        }
                        else {
                            var hour = 0;
                            var minute = 0;
                            var meridian = 0;
                            var second = 0;
                            var milliseconds = 0;
                        }
                        if (hour >= 12) {
                            meridian = "PM";
                            if (formatString.indexOf("HH") == -1) {
                                hour -= 12;
                                if (hour == 0) hour = 12;
                            }
                        }
                        else meridian = "AM";
                        if (this.meridianInput.css('display') != "none") {
                            if (hour == 0) hour = 12;
                        }
                        if (hour < 10) hour = "0" + hour;
                        if (minute < 10) minute = "0" + minute;
                        if (second < 10) second = "0" + second;
                        if (milliseconds < 10) milliseconds = "0" + milliseconds;

                        this.hourInput.val(hour);
                        this.minuteInput.val(minute);
                        this.secondInput.val(second);
                        this.mssecondInput.val(milliseconds);
                        this.meridianInput.val(meridian);
                    }
                    var date = this.getRange().to;
                    if (this.hourInput2) {
                        if (date) {
                            var hour = date.getHours();
                            var minute = date.getMinutes();
                            var meridian = date.getHours();
                            var second = date.getSeconds();
                            var milliseconds = date.getMilliseconds();
                        }
                        else {
                            var hour = 0;
                            var minute = 0;
                            var meridian = 0;
                            var second = 0;
                            var milliseconds = 0;
                        }
                        if (hour >= 12) {
                            meridian = "PM";
                            if (formatString.indexOf("HH") == -1) {
                                hour -= 12;
                                if (hour == 0) hour = 12;
                            }
                        }
                        else meridian = "AM";
                        if (this.meridianInput.css('display') != "none") {
                            if (hour == 0) hour = 12;
                        }

                        if (hour < 10) hour = "0" + hour;
                        if (minute < 10) minute = "0" + minute;
                        if (second < 10) second = "0" + second;
                        if (milliseconds < 10) milliseconds = "0" + milliseconds;

                        this.hourInput2.val(hour);
                        this.minuteInput2.val(minute);
                        this.secondInput2.val(second);
                        this.mssecondInput2.val(milliseconds);
                        this.meridianInput2.val(meridian);
                    }
                }
            },

            showCalendar: function () {
                var calendar = this.calendarContainer;
                var calendarInstance = this._calendar;
                $.jqx.aria(this, "aria-expanded", true);

                if (this.showTimeButton) {
                    if (this.timePopup) {
                        if (!this.timePopupElement) {
                            this.initTimePopup();
                        }
                        this.calendarContainer.css('visibility', 'hidden');
                        this.timeContainer.css('visibility', 'visible');
                        this.updateTimePopup();
                        var inputs = this.timeContainer.find('input');
                        var width = 0;
                        for (var i = 0; i < inputs.length; i++) {
                            if (inputs[i].style.display != "none") {
                                width += 50;
                            }
                        }
                        this.container.width(parseInt(width));

                        if (!this.touch) {
                            setTimeout(function () {
                                inputs[0].focus();
                                $(inputs[0]).select();
                            }, 150 + this.openDelay);
                        }
                    }
                    else {
                        this.container.width(parseInt(this.calendarContainer.width()) + 25);
                        this.timeContainer.css('visibility', 'hidden');
                        this.calendarContainer.css('visibility', 'visible');
                    }
                }

                if (this.value != null) {
                    if (this.selectionMode != 'range') {
                        this._oldDT = new Date(this.value.dateTime);
                    }
                    else {
                        this._oldDT = this.getRange();
                    }
                }
                else {
                    this._oldDT = null;
                }
                if (!calendarInstance.canRender) {
                    calendarInstance.canRender = true;
                    calendarInstance.render();
                }
                var container = this.container;
                var self = this;
                var scrollPosition = $(window).scrollTop();
                var scrollLeftPosition = $(window).scrollLeft();
                var top = parseInt(this._findPos(this.host[0])[1]) + parseInt(this.host.outerHeight()) - 1 + 'px';
                var left, leftPos = parseInt(Math.round(this.host.coord(true).left));
                if (this.dropDownContainer === 'element') {
                    top = parseInt(this.host.outerHeight()) - 1 + 'px';
                    left = 0;
                }
                left = leftPos + 'px';

                var isMobileBrowser = false;// $.jqx.mobile.isSafariMobileBrowser() || $.jqx.mobile.isWindowsPhone();

                if ((isMobileBrowser != null && isMobileBrowser)) {
                    left = $.jqx.mobile.getLeftPos(this.element);
                    top = $.jqx.mobile.getTopPos(this.element) + parseInt(this.host.outerHeight());
                    if ($('body').css('border-top-width') != '0px') {
                        top = parseInt(top) - this._getBodyOffset().top + 'px';
                    }
                    if ($('body').css('border-left-width') != '0px') {
                        left = parseInt(left) - this._getBodyOffset().left + 'px';
                    }
                }

                this.container.css('left', left);
                this.container.css('top', top);

                var closeAfterSelection = this.closeCalendarAfterSelection;
                this.closeCalendarAfterSelection = false;
                this.isEditing = false;
                if (self.selectionMode == 'default') {
                    this._validateValue();
                    this._updateText();
                    var value = this.value != null ? this.value.dateTime : new Date();
                    calendarInstance.setDate(value);
                }
                this.closeCalendarAfterSelection = closeAfterSelection;

                var positionChanged = false;

                if (this.dropDownHorizontalAlignment == 'right' || this.rtl) {
                    var containerWidth = this.container.outerWidth();
                    var containerLeftOffset = Math.abs(containerWidth - this.host.outerWidth() + 2);
                    if (!this.rtl) containerLeftOffset -= 2;

                    if (containerWidth > this.host.width()) {
                        var offset = 23;
                        this.container.css('left', offset + parseInt(Math.round(leftPos)) - containerLeftOffset + "px");
                    }
                    else this.container.css('left', 25 + parseInt(Math.round(leftPos)) + containerLeftOffset + "px");
                }

                if (this.dropDownVerticalAlignment == "top") {
                    var dpHeight = calendar.height();
                    if (this.timePopup) {
                        this.timeContainer.css('top', this.container.height() - 75);
                    }
                    positionChanged = true;

                    calendar.css('top', 23);
                    calendar.addClass(this.toThemeProperty('jqx-popup-up'));
                    var inputHeight = parseInt(this.host.outerHeight());
                    var t = parseInt(top) - Math.abs(dpHeight + inputHeight + 23);

                    this.container.css('top', t);
                }

                if (this.enableBrowserBoundsDetection) {
                    var newOffset = this.testOffset(calendar, { left: parseInt(this.container.css('left')), top: parseInt(top) }, parseInt(this.host.outerHeight()));
                    if (parseInt(this.container.css('top')) != newOffset.top) {
                        positionChanged = true;
                        calendar.css('top', 23);
                        calendar.addClass(this.toThemeProperty('jqx-popup-up'));
                    }
                    else calendar.css('top', 0);

                    this.container.css('top', newOffset.top);
                    if (parseInt(this.container.css('left')) != newOffset.left) {
                        this.container.css('left', newOffset.left);
                    }
                }

                this._raiseEvent(7, calendar);

                if (this.animationType != 'none' && this.animationType != 'transform') {
                    this.container.css('display', 'block');
                    var height = parseInt(calendar.outerHeight());
                    calendar.stop();

                    this.isanimating = true;
                    this.opening = true;
                    if (this.animationType == 'fade') {
                        calendar.css('margin-top', 0);
                        calendar.css('opacity', 0);
                        calendar.animate({ 'opacity': 1 }, this.openDelay, function () {
                            self.isanimating = false;
                            self.opening = false;
                            $.data(document.body, "openedJQXCalendar" + self.id, calendar);
                            self.calendarContainer.focus();
                        });
                        if (this.timePopup) {
                            this.timeContainer.css('margin-top', 0);
                            this.timeContainer.css('opacity', 0);
                            this.timeContainer.animate({ 'opacity': 1 }, this.openDelay, function () {
                                self.isanimating = false;
                                self.opening = false;
                                $.data(document.body, "openedJQXCalendar" + self.id, calendar);
                                self.timeContainer.focus();
                            });
                        }
                    }
                    else {
                        calendar.css('opacity', 1);
                        if (this.timePopup) {
                            this.timeContainer.css('opacity', 1);
                        }
                        if (positionChanged) {
                            calendar.css('margin-top', height);
                        }
                        else {
                            calendar.css('margin-top', -height);
                        }
                        if (this.timePopup) {
                            if (positionChanged) {
                                this.timeContainer.css('margin-top', height);
                            }
                            else {
                                this.timeContainer.css('margin-top', -height);
                            }
                            this.timeContainer.animate({ 'margin-top': 0 }, this.openDelay, function () {
                                self.isanimating = false;
                                self.opening = false;
                                $.data(document.body, "openedJQXCalendar" + self.id, calendar);
                                self.timeContainer.focus();
                            });
                        }
                        calendar.animate({ 'margin-top': 0 }, this.openDelay, function () {
                            self.isanimating = false;
                            self.opening = false;
                            $.data(document.body, "openedJQXCalendar" + self.id, calendar);
                            self.calendarContainer.focus();
                        });
                    }
                }
                else {
                    calendar.stop();
                    self.isanimating = false;
                    self.opening = false;
                    calendar.css('opacity', 1);
                    calendar.css('margin-top', 0);
                    this.container.css('display', 'block');
                    $.data(document.body, "openedJQXCalendar" + self.id, calendar);
                    this.calendarContainer.focus();
                    if (this.timePopup) {
                        this.timeContainer.stop();
                        this.timeContainer.css('opacity', 1);
                        this.timeContainer.css('margin-top', 0);
                        this.timeContainer.focus();
                    }
                }

                if (this.value == null) {
                    if (this._calendar && this._calendar._getSelectedCell()) {
                        this._calendar._getSelectedCell().isSelected = false;
                    }
                }

                if (this.timePopup) {
                    this.timeButtonIcon.addClass(this.toThemeProperty('jqx-icon-time-pressed'));
                    this.timeButton.addClass(this.toThemeProperty('jqx-fill-state-hover'));
                    this.timeButton.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                    this.timeContainer.addClass(this.toThemeProperty('jqx-fill-state-focus'));
                }
                else {
                    this.calendarButtonIcon.addClass(this.toThemeProperty('jqx-icon-calendar-pressed'));
                    this.calendarButton.addClass(this.toThemeProperty('jqx-fill-state-hover'));
                    this.calendarButton.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                    this.calendarContainer.addClass(this.toThemeProperty('jqx-fill-state-focus'));

                }
                this.host.addClass(this.toThemeProperty('jqx-fill-state-focus'));
                this.calendarContainer.addClass(this.toThemeProperty('jqx-popup-show'));

                if (this.isMaterialized()) {
                    this._calendar.refresh();
                }
            },

            hideCalendar: function (reason, changeType) {
                if (changeType) {
                    this.changeType = changeType;
                }

                var calendar = this.calendarContainer;
                var container = this.container;
                var self = this;
                $.jqx.aria(this, "aria-expanded", false);
                if (this.showTimeButton) {
                    if (this.timeContainer.css('visibility') != "hidden" && reason != "cancel") {
                        if (this.selectionMode != "range" && this.hourInput) {
                            var date = this.getDate();
                            var hour = parseInt(this.hourInput.val());
                            var minute = parseInt(this.minuteInput.val());
                            var second = parseInt(this.secondInput.val());
                            var millisecond = parseInt(this.mssecondInput.val());
                            var meridian = this.meridianInput.val();
                            if (isNaN(hour))
                                hour = 0;
                            if (isNaN(minute))
                                minute = 0;
                            if (isNaN(second))
                                second = 0;
                            if (isNaN(millisecond))
                                millisecond = 0;

                            if (this.meridianInput.css('display') != "none") {
                                if (meridian.toLowerCase().indexOf("p") >= 0) {
                                    if (hour < 12) {
                                        hour += 12;
                                    }
                                }
                                if (meridian.toLowerCase().indexOf("a") >= 0) {
                                    if (hour >= 12) {
                                        hour -= 12;
                                    }
                                }
                            }
                            if (!date) date = new Date();
                            date.setHours(hour, minute, second, millisecond);
                            this.setDate(date);
                        }
                        else if (this.hourInput && reason != "selected") {
                            var range = this.getRange();
                            var hour = parseInt(this.hourInput.val());
                            var minute = parseInt(this.minuteInput.val());
                            var second = parseInt(this.secondInput.val());
                            var millisecond = parseInt(this.mssecondInput.val());
                            var meridian = this.meridianInput.val();
                            if (isNaN(hour))
                                hour = 0;
                            if (isNaN(minute))
                                minute = 0;
                            if (isNaN(second))
                                second = 0;
                            if (isNaN(millisecond))
                                millisecond = 0;

                            if (this.meridianInput.css('display') != "none") {
                                if (meridian.toLowerCase().indexOf("p") >= 0) {
                                    if (hour < 12) {
                                        hour += 12;
                                    }
                                }
                                if (meridian.toLowerCase().indexOf("a") >= 0) {
                                    if (hour >= 12) {
                                        hour -= 12;
                                    }
                                }
                            }
                            var from = range.from;
                            if (!from) from = new Date();

                            from.setHours(hour, minute, second, millisecond);

                            var hour = parseInt(this.hourInput2.val());
                            var minute = parseInt(this.minuteInput2.val());
                            var second = parseInt(this.secondInput2.val());
                            var millisecond = parseInt(this.mssecondInput2.val());
                            var meridian = this.meridianInput2.val();
                            if (minute == "") minute = 0;
                            if (second == "") second = 0;
                            if (millisecond == "") millisecond = 0;
                            if (this.meridianInput2.css('display') != "none") {
                                if (meridian.toLowerCase().indexOf("p") >= 0) {
                                    if (hour < 12) {
                                        hour += 12;
                                    }
                                }
                                if (meridian.toLowerCase().indexOf("a") >= 0) {
                                    if (hour >= 12) {
                                        hour -= 12;
                                    }
                                }
                            }
                            var to = range.to;
                            if (!to) to = new Date();
                            to.setHours(hour, minute, second, millisecond);
                            if (to.valueOf() < from.valueOf()) {
                                return false;
                            }

                            this.setRange(from, to);
                        }
                        else if (reason == "selected") {
                            return;
                        }
                    }
                }

                $.data(document.body, "openedJQXCalendar" + this.id, null);
                if (this.animationType != 'none' && this.animationType != 'transform') {
                    var height = calendar.outerHeight();
                    calendar.css('margin-top', 0);
                    if (this.showTimeButton) {
                        this.timeContainer.css('margin-top', 0);
                    }
                    this.isanimating = true;
                    var animationValue = -height;
                    if (parseInt(this.container.coord().top) < parseInt(this.host.coord().top)) {
                        animationValue = height;
                    }
                    if (this.animationType == 'fade') {
                        calendar.animate({ 'opacity': 0 }, this.closeDelay, function () { container.css('display', 'none'); self.isanimating = false; });
                    }
                    else {
                        calendar.animate({ 'margin-top': animationValue }, this.closeDelay, function () { container.css('display', 'none'); self.isanimating = false; });
                    }
                    if (this.showTimeButton) {
                        if (this.animationType == 'fade') {
                            this.timeContainer.animate({ 'opacity': 0 }, this.closeDelay, function () { container.css('display', 'none'); self.isanimating = false; });
                        }
                        else {
                            this.timeContainer.animate({ 'margin-top': animationValue }, this.closeDelay, function () { container.css('display', 'none'); self.isanimating = false; });
                        }
                    }
                }
                else if (this.animationType === "transform") {
                    setTimeout(function () {
                        container.css('display', 'none');
                    }, this.closeDelay);
                }
                else {
                    container.css('display', 'none');
                }

                if (reason != undefined) {
                    this._updateSelectedDate(reason);
                }

                this.timeButtonIcon.removeClass(this.toThemeProperty('jqx-icon-time-pressed'));
                this.timeButton.removeClass(this.toThemeProperty('jqx-fill-state-hover'));
                this.timeButton.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this.calendarButtonIcon.removeClass(this.toThemeProperty('jqx-icon-calendar-pressed'));
                this.calendarButton.removeClass(this.toThemeProperty('jqx-fill-state-hover'));
                this.calendarButton.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this.host.removeClass(this.toThemeProperty('jqx-fill-state-focus'));
                this.timeContainer.removeClass(this.toThemeProperty('jqx-fill-state-focus'));
                this.calendarContainer.removeClass(this.toThemeProperty('jqx-fill-state-focus'));

                this._raiseEvent(8, calendar);
                this.calendarContainer.removeClass(this.toThemeProperty('jqx-popup-show'));
            },

            _updateSelectedDate: function () {
                var value = this.value;
                if (value == null) {
                    value = new $.jqx._jqxDateTimeInput.getDateTime(new Date());
                    value._setHours(0);
                    value._setMinutes(0);
                    value._setSeconds(0);
                    value._setMilliseconds(0);
                }

                var hour = value.hour;
                var minute = value.minute;
                var second = value.second;
                var milisecond = value.millisecond;
                if (this.selectionMode == 'range' && this._calendar.getRange().from == null) {
                    this.setDate(null);
                    return;
                }

                var date = new $.jqx._jqxDateTimeInput.getDateTime(this._calendar.value.dateTime);

                date._setHours(hour);
                date._setMinutes(minute);
                date._setSeconds(second);
                date._setMilliseconds(milisecond);
                var result = this.setDate(date.dateTime);
                if (this.selectionMode == "range" && !result && this._oldDT) {
                    var range = this.getRange();
                    var oldRange = this._oldDT;
                    var from = false;
                    var to = false;
                    var oldDate = this._oldDT.from;
                    var date = range.from;
                    if (date != null && oldDate) {
                        if (!(date.getFullYear() != oldDate.getFullYear() || date.getMonth() != oldDate.getMonth() || date.getDate() != oldDate.getDate() || date.getHours() != oldDate.getHours() || date.getMinutes() != oldDate.getMinutes() || date.getSeconds() != oldDate.getSeconds())) {
                            from = true;
                        }
                    }
                    var date = range.to;
                    if (date != null) {
                        oldDate = this._oldDT.to;
                        if (oldDate) {
                            if (!(date.getFullYear() != oldDate.getFullYear() || date.getMonth() != oldDate.getMonth() || date.getDate() != oldDate.getDate() || date.getHours() != oldDate.getHours() || date.getMinutes() != oldDate.getMinutes() || date.getSeconds() != oldDate.getSeconds())) {
                                to = true;
                            }
                        }
                    }
                    if (from && to) {
                        return true;
                    }
                    this._raiseEvent(0, {});
                    this._raiseEvent(9, {});
                }
            },

            _closeOpenedCalendar: function (event) {
                var $target = $(event.target);
                var openedCalendar = $.data(document.body, "openedJQXCalendar" + event.data.me.id);
                var isCalendar = false;
                $.each($target.parents(), function () {
                    if (this.className && this.className.indexOf) {
                        if (this.className.indexOf('jqx-calendar') != -1) {
                            isCalendar = true;
                            return false;
                        }
                        if (this.className.indexOf('jqx-date-time-input-popup') != -1) {
                            isCalendar = true;
                            return false;
                        }
                        if (this.className.indexOf('jqx-input') != -1) {
                            //      isCalendar = true;
                            return false;
                        }
                    }
                });

                if ($(event.target).ischildof(event.data.me.host)) {
                    return true;
                }

                if (event.target != null && (event.target.tagName == "B" || event.target.tagName == 'b')) {
                    var hostOffset = event.data.me.host.coord();
                    var hostWidth = event.data.me.host.width();
                    var hostHeight = event.data.me.host.height();
                    var top = parseInt(hostOffset.top);
                    var left = parseInt(hostOffset.left);

                    if (top <= event.pageY && event.pageY <= top + hostHeight) {
                        if (left <= event.pageX && event.pageX <= left + hostWidth) {
                            return true;
                        }
                    }
                }

                if (openedCalendar != null && !isCalendar) {
                    if (openedCalendar.length > 0) {
                        var calendarID = openedCalendar[0].id.toString();
                        var inputID = calendarID.toString().substring(13);
                        var datetimeinput = $(document).find("#" + inputID);
                        var result = event.data.me.hideCalendar();
                        if (result !== false) {
                            $.data(document.body, "openedJQXCalendar" + event.data.me.id, null);
                        }
                    }
                }
            },

            _loadItems: function () {
                if (this.value != null) {
                    this.items = new Array();
                    var expandedMask = this._getFormatValue(this.formatString);
                    this.items = this._parseFormatValue(expandedMask);
                    this.editors = new Array();
                    for (var i = 0; i < this.items.length; i++) {
                        var editor = this.items[i].getDateTimeEditorByItemType(this.value, this);
                        this.editors[i] = editor;
                    }
                }

                this._updateEditorsValue();
                this._updateText();
            },

            _updateText: function () {
                var that = this;
                var text = "";
                if (that.items.length == 0 && that.value != null) {
                    that._loadItems();
                }

                if (that.value != null) {
                    if (that.items.length >= 1) {
                        text = that.format(that.value, 0, that.items.length);
                    }


                    var oldText = that.dateTimeInput.val();
                    if (oldText != text) {
                        that._raiseEvent(1, that.value);
                    }
                }

                if (that.selectionMode == 'range') {
                    var range = that.getRange();
                    var fromText = that.format(that.value, 0, that.items.length);
                    if (range.to) {
                        var from = $.jqx._jqxDateTimeInput.getDateTime(range.from);
                        fromText = that.format(from, 0, that.items.length);
                        var to = $.jqx._jqxDateTimeInput.getDateTime(range.to);
                        var toText = that.format(to, 0, that.items.length);
                        var text = fromText + " - " + toText;
                        if (text == ' - ') text = "";
                    }
                    else {
                        text = "";
                    }
                }

                that.dateTimeInput.val(text)
            },

            format: function (value, startFormatIndex, endFormatIndex) {
                var result = "";
                for (var i = startFormatIndex; i < endFormatIndex; ++i) {
                    var item = this.items[i];

                    var parsedValue = item.dateParser(value, this);

                    if (this.isEditing && item.type != 'ReadOnly') {
                        if (this.selectionMode != 'range') {
                            var isReadOnlyDay = item.type == 'Day' && item.format.length > 2;
                            if (item.type == 'FORMAT_AMPM') {
                                isReadOnlyDay = true;
                                if (this.editors[i].value == 0)
                                    parsedValue = this.editors[i].amString;
                                else parsedValue = this.editors[i].pmString;
                            }

                            if (!isReadOnlyDay) {
                                if (this.yearCutoff !== null && item.type === 'Year' && item.format === 'yy') {
                                    parsedValue = this.editors[i].value.toString().substring(2);
                                }
                                else {
                                    parsedValue = item.dateParserInEditMode(new Number(this.editors[i].value), "d" + this.editors[i].maxEditPositions, this);
                                    while (parsedValue.length < this.editors[i].maxEditPositions) {
                                        parsedValue = '0' + parsedValue;
                                    }
                                }
                            }
                        }
                    }
                    result += parsedValue;
                }
                return result;
            },

            _getFormatValueGroupLength: function (item) {
                for (var i = 1; i < item.toString().length; ++i) {
                    if (item.substring(i, i + 1) != item.substring(0, 1))
                        return i;
                }
                return item.length;
            },

            _parseFormatValue: function (value) {
                var myResult = new Array();
                var currentValue = value.toString();
                var i = 0;
                while (currentValue.length > 0) {
                    var formatItemLength = this._getFormatValueGroupLength(currentValue);
                    var myItem = null;

                    switch (currentValue.substring(0, 1)) {
                        case ':':
                        case '/':
                            formatItemLength = 1;
                            myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, 1), 'ReadOnly', this.culture);
                            break;
                        case '"':
                        case '\'':
                            var closingQuotePosition = currentValue.indexOf(currentValue[0], 1);
                            myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(1, 1 + Math.max(1, closingQuotePosition - 1)), 'ReadOnly', this.culture);
                            formatItemLength = Math.max(1, closingQuotePosition + 1);
                            break;
                        case '\\':
                            if (currentValue.length >= 2) {
                                myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(1, 1), 'ReadOnly', this.culture);
                                formatItemLength = 2;
                            }
                            break;
                        case 'd':
                        case 'D':
                            if (formatItemLength > 2) {
                                myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'Day', this.culture);
                            }
                            else {
                                myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'Day', this.culture);

                            }
                            break;
                        case 'f':
                        case 'F':
                            if (formatItemLength > 7) {
                                formatItemLength = 7;
                            }
                            if (formatItemLength > 3) {
                                myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'ReadOnly', this.culture);
                            }
                            else {
                                myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'Millisecond', this.culture);
                            }
                            break;
                        case 'g':
                            myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'ReadOnly', this.culture);
                            break;
                        case 'h':
                            myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'FORMAT_hh', this.culture);
                            break;
                        case 'H':
                            myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'FORMAT_HH', this.culture);
                            break;
                        case 'm':
                            myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'Minute', this.culture);
                            break;
                        case 'M':
                            if (formatItemLength > 4)
                                formatItemLength = 4;
                            myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'Month', this.culture);
                            break;
                        case 's':
                        case 'S':
                            myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'Second', this.culture);
                            break;
                        case 't':
                        case 'T':
                            myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'FORMAT_AMPM', this.culture);
                            break;
                        case 'y':
                        case 'Y':
                            if (formatItemLength > 1) {
                                myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'Year', this.culture);
                            }
                            else {
                                formatItemLength = 1;
                                myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, 1), null, 'ReadOnly', this.culture);
                            }
                            break;
                        case 'z':
                            myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, formatItemLength), 'ReadOnly', this.culture);
                            break;

                        default:
                            formatItemLength = 1;
                            myItem = $.jqx._jqxDateTimeInput.DateTimeFormatItem._create(currentValue.substring(0, 1), 'ReadOnly', this.culture);
                            break;
                    }

                    myResult[i] = $.extend(true, {}, myItem);
                    currentValue = currentValue.substring(formatItemLength);
                    i++;
                }

                return myResult;
            },

            _getFormatValue: function (format) {
                if (format == null || format.length == 0)
                    format = "d";

                if (format.length == 1) {
                    switch (format.substring(0, 1)) {
                        case "d":
                            return this.localization.calendar.patterns.d;
                        case "D":
                            return this.localization.calendar.patterns.D;
                        case "t":
                            return this.localization.calendar.patterns.t;
                        case "T":
                            return this.localization.calendar.patterns.T;
                        case "f":
                            return this.localization.calendar.patterns.f;
                        case "F":
                            return this.localization.calendar.patterns.F;
                        case "M":
                            return this.localization.calendar.patterns.M;
                        case "Y":
                            return this.localization.calendar.patterns.Y;
                        case "S":
                            return this.localization.calendar.patterns.S;
                    }
                }
                if (format.length == 2 && format.substring(0, 1) == '%')
                    format = format.substring(1);
                return format;
            },

            _updateEditorsValue: function () {
                var value = this.value;

                if (value == null)
                    return;

                var year = value.year;
                var day = value.day;
                var hour = value.hour;
                var millisecond = value.millisecond;
                var second = value.second;
                var minute = value.minute;
                var month = value.month;

                if (this.items == null)
                    return;

                for (var i = 0; i < this.items.length; i++) {
                    switch (this.items[i].type) {
                        case 'FORMAT_AMPM':
                            var initialValue = hour % 12;
                            if (initialValue == 0)
                                initialValue = 12;

                            if (hour >= 0 && hour < 12) {
                                this.editors[i].value = 0;
                            }
                            else {
                                this.editors[i].value = 1;
                            }
                            break;
                        case 'Day':
                            this.editors[i].value = day;
                            break;
                        case 'FORMAT_hh':
                            var initialValue = hour % 12;
                            if (initialValue == 0)
                                initialValue = 12;

                            this.editors[i].value = initialValue;
                            break;
                        case 'FORMAT_HH':
                            this.editors[i].value = hour;
                            break;
                        case 'Millisecond':
                            this.editors[i].value = millisecond;
                            break;
                        case 'Minute':
                            this.editors[i].value = minute;
                            break;
                        case 'Month':
                            this.editors[i].value = month;
                            break;
                        case 'Second':
                            this.editors[i].value = second;
                            break;
                        case 'Year':
                            this.editors[i].value = year;
                            break;
                    }
                }
            },


            updateValue: function (blur) {
                if (this.isEditing) {
                    return;
                }
                if (this.items && this.items.length == 0) {
                    return;
                }

                var dateTime = 0;
                var year = 1;
                var day = 1;
                var hour = 0;
                var milisecond = 0;
                var second = 0;
                var minute = 0;
                var month = 1;
                var amPmOffset = 0;
                var hasYear = false;
                var hasMonth = false;
                var hasDay = false;
                var hasHour = false;
                var hasMinute = false;
                var hasSecond = false;
                var hasMillisecond = false;
                var dayEditors = new Array();
                var amPmEditor = null;

                var k = 0;
                for (var i = 0; i < this.items.length; i++) {
                    switch (this.items[i].type) {
                        case 'FORMAT_AMPM':
                            amPmOffset = this.editors[i].value;
                            amPmEditor = this.editors[i];
                            break;
                        case 'Character':
                            break;
                        case 'Day':
                            if (this.items[i].format.length < 3) {
                                day = this.editors[i].value;
                                dayEditors[k++] = this.editors[i];
                                if (day == 0)
                                    day = 1;

                                hasDay = true;
                            }
                            break;
                        case 'FORMAT_hh':
                            var hoursEditor = this.editors[i];
                            hour = hoursEditor.value;
                            hasHour = true;
                            break;
                        case 'FORMAT_HH':
                            hour = this.editors[i].value;
                            hasHour = true;
                            break;
                        case 'Millisecond':
                            milisecond = this.editors[i].value;
                            hasMillisecond = true;
                            break;
                        case 'Minute':
                            minute = this.editors[i].value;
                            hasMinute = true;
                            break;
                        case 'Month':
                            month = this.editors[i].value;
                            hasMonth = true;
                            if (month == 0)
                                month = 1; break;
                        case 'ReadOnly':
                            break;
                        case 'Second':
                            second = this.editors[i].value;
                            hasSecond = true;
                            break;
                        case 'Year':
                            hasYear = true;
                            year = this.editors[i].value;

                            var yearFormatValue = this.editors[i].getDateTimeItem().format;
                            if (yearFormatValue.length < 3) {
                                var yearString = "1900";
                                if (yearString.Length == 4) {
                                    var baseYearString = "" + yearString[0] + yearString[1];
                                    var baseYear;
                                    baseYear = parseInt(baseYearString);
                                    year = year + (baseYear * 100);
                                }
                            }

                            if (year == 0)
                                year = 1;
                            break;
                    }
                }

                var oldDate = this.value != null ? new Date(this.value.dateTime) : null;

                if (year > 0 && month > 0 && day > 0 && minute >= 0 && hour >= 0 && second >= 0 && milisecond >= 0) {
                    var val = this.value;
                    if (val != null) {
                        if (!hasYear) {
                            year = val.year;
                        }

                        if (!hasMonth) {
                            month = val.month;
                        }

                        if (!hasDay) {
                            day = val.day;
                        }
                    }

                    try {
                        if (month > 12) month = 12;
                        if (month < 1) month = 1;
                        if (blur && val._daysInMonth(year, month) <= day) {
                            day = val._daysInMonth(year, month);
                            if (dayEditors != null && dayEditors.length > 0) {
                                for (i = 0; i < dayEditors.length; i++) {
                                    dayEditors[i].value = day;
                                }
                            }
                        }

                        if (amPmEditor != null) {
                            if (amPmEditor.value == 0) {
                                if (hour >= 12) {
                                    hour -= 12;
                                }
                            }
                            else {
                                if (hour + 12 < 24) {
                                    hour += 12;
                                }
                            }
                        }

                        var oldDay = this.value.dateTime.getDate();

                        this.value._setYear(parseInt(year));
                        this.value._setDay(day);
                        this.value._setMonth(month);
                        if (hasHour) {
                            this.value._setHours(hour);
                        }
                        if (hasMinute) {
                            this.value._setMinutes(minute);
                        }
                        if (hasSecond) {
                            this.value._setSeconds(second);
                        }
                        if (hasMillisecond) {
                            this.value._setMilliseconds(milisecond);
                        }
                        this._validateTimeRange();
                    }
                    catch (err) {
                        this.value = val;
                    }

                    if (oldDate != null) {
                        var areEqual = this.value.dateTime.getFullYear() == oldDate.getFullYear() && this.value.dateTime.getDate() == oldDate.getDate() && this.value.dateTime.getMonth() == oldDate.getMonth() && this.value.dateTime.getHours() == oldDate.getHours() && this.value.dateTime.getMinutes() == oldDate.getMinutes() && this.value.dateTime.getSeconds() == oldDate.getSeconds();
                        if (!areEqual) {
                            if (this.changing) {
                                var newDate = this.changing(oldDate, this.value.dateTime);
                                if (newDate) {
                                    this.value = $.jqx._jqxDateTimeInput.getDateTime(newDate);
                                }
                            }

                            this._raiseEvent('0', this.value.dateTime);
                            if (this.cookies) {
                                if (this.value != null) {
                                    $.jqx.cookie.cookie("jqxDateTimeInput" + this.element.id, this.value.dateTime.toString(), this.cookieoptions);
                                }
                            }
                            if (this.change) {
                                this.change(this.value.dateTime);
                            }
                        }
                    }
                }

                var editorIndex = this.editors.indexOf(this.activeEditor);
                var currentItem = this.items[editorIndex];

                if (this.value) {
                    if (this.calendarContainer.jqxCalendar('_isDisabled', this.value.dateTime)) {
                        this.dateTimeInput.addClass(this.toThemeProperty("jqx-input-invalid"));
                    }
                    else {
                        this.dateTimeInput.removeClass(this.toThemeProperty("jqx-input-invalid"));
                    }
                }
            },

            _internalSetValue: function (date) {
                this.value._setYear(parseInt(date.year));
                this.value._setDay(date.day);
                this.value._setMonth(date.month);
                this.value._setHours(date.hour);
                this.value._setMinutes(date.minute);
                this.value._setSeconds(date.second);
                this.value._setMilliseconds(date.milisecond);
            },

            _raiseEvent: function (id, arg, arg2) {
                var evt = this.events[id];
                var args = {};
                args.owner = this;
                if (arg == null) {
                    arg = {};
                }
                if (arg2 == null) {
                    arg2 = arg;
                }

                var key = arg.charCode ? arg.charCode : arg.keyCode ? arg.keyCode : 0;
                var result = true;
                var isreadOnly = this.readonly;
                var event = new $.Event(evt);
                event.owner = this;
                event.args = args;
                event.args.date = this.getDate();
                if (id == 9) {
                    event.args.type = this.changeType;
                    this.changeType = null;
                }
                this.element.value = this.dateTimeInput.val();
                if (id == 9 && this.selectionMode != 'range') {
                    var date = event.args.date;

                    if (this._oldDT) {
                        if (date != null) {
                            if (!(date.getFullYear() != this._oldDT.getFullYear() || date.getMonth() != this._oldDT.getMonth() || date.getDate() != this._oldDT.getDate() || date.getHours() != this._oldDT.getHours() || date.getMinutes() != this._oldDT.getMinutes() || date.getSeconds() != this._oldDT.getSeconds())) {
                                return true;
                            }
                        }

                        //      $.jqx.aria(this, "aria-valuenow", this.getDate());
                        $.jqx.aria(this, "aria-valuetext", this.getText());
                        if (this.getDate() != null) {
                            $.jqx.aria(this, "aria-label", "Current focused date is " + this.getDate().toLocaleString());
                        }
                        else {
                            $.jqx.aria(this, "aria-label", "Current focused date is Null");
                        }
                    }
                    event.args.oldValue = arg2;
                    event.args.newValue = event.args.date;
                    if (this._oldDT) {
                        event.args.oldValue = this._oldDT;
                    }
                }
                if (this.selectionMode == 'range') {
                    event.args.date = this.getRange();
                    if (this._oldDT) {
                        var date = event.args.date.from;
                        if (id == 9) {
                            var from = false;
                            var to = false;
                            var oldDate = this._oldDT.from;
                            if (date != null && oldDate) {
                                if (!(date.getFullYear() != oldDate.getFullYear() || date.getMonth() != oldDate.getMonth() || date.getDate() != oldDate.getDate() || date.getHours() != oldDate.getHours() || date.getMinutes() != oldDate.getMinutes() || date.getSeconds() != oldDate.getSeconds())) {
                                    from = true;
                                }
                            }
                            var date = event.args.date.to;
                            if (date != null) {
                                oldDate = this._oldDT.to;
                                if (oldDate) {
                                    if (!(date.getFullYear() != oldDate.getFullYear() || date.getMonth() != oldDate.getMonth() || date.getDate() != oldDate.getDate() || date.getHours() != oldDate.getHours() || date.getMinutes() != oldDate.getMinutes() || date.getSeconds() != oldDate.getSeconds())) {
                                        to = true;
                                    }
                                }
                            }
                            if (from && to) {
                                return true;
                            }

                            var from = event.args.date.from;
                            if (from == null) from = "";
                            else from = from.toString();
                            var to = event.args.date.to;
                            if (to == null) to = "";
                            else to = to.toString();

                            //  $.jqx.aria(this, "aria-valuenow", from + "-" + to);
                            $.jqx.aria(this, "aria-valuetext", this.getText());
                            if (from && to) {
                                $.jqx.aria(this, "aria-label", "Current focused range is " + from.toLocaleString() + "-" + to.toLocaleString());
                            }
                        }
                    }
                    event.args.oldValue = arg2;
                    event.args.newValue = event.args.date;
                    if (this._oldDT) {
                        event.args.oldValue = this._oldDT;
                    }
                }

                if (this.host.css('display') == 'none')
                    return true;

                if (id != 2 && id != 3 && id != 4 && id != 5 && id != 6) {
                    result = this.host.trigger(event);
                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                }
                var me = this;

                if (!isreadOnly) {
                    if (id == 2 && !this.disabled) {
                        setTimeout(function () {
                            me.isEditing = true;
                            if (this.selectionMode == 'range') {
                                me._selectGroup(-1);
                            }
                            else {
                                me._selectGroup(-1);
                            }
                        }, 25);
                    }
                }


                if (id == 4) {
                    if (isreadOnly || this.disabled) {
                        if (key == 8 || key == 46) {
                            this.isEditing = false;
                            if (this.allowKeyboardDelete) {
                                if (this.allowNullDate) {
                                    this.setDate(null);
                                }
                                else {
                                    if (this.selectionMode != 'range') {
                                        this.setDate(this.getMinDate());
                                    }
                                    else {
                                        this.setRange(this.getMinDate(), this.getMinDate());
                                    }
                                }
                            }
                        }
                        if (key == 9)
                            return true;

                        if (!arg.altKey) {
                            return false;
                        }
                    }

                    result = this._handleKeyDown(arg, key);
                }

                else if (id == 5) {
                    if (key == 9)
                        return true;

                    if (isreadOnly || this.disabled) {
                        return false;
                    }


                }
                else if (id == 6) {
                    if (key == 9)
                        return true;

                    if (isreadOnly || this.disabled) {
                        return false;
                    }

                    result = this._handleKeyPress(arg, key)
                }

                return result;
            },

            _doLeftKey: function () {
                if (this.activeEditor != null) {
                    if (!this.isEditing) this.isEditing = true;

                    var lastEditor = this.activeEditor;
                    var newEditor = false;
                    var index3 = this.editors.indexOf(this.activeEditor);
                    var tmpIndex3 = index3;

                    if (this.enableAbsoluteSelection) {
                        if (index3 >= 0 && this.activeEditor.positions > 0) {
                            this.activeEditor.positions--;
                            this._selectGroup(index3);
                            return;
                        }
                    }

                    while (index3 > 0) {
                        this.activeEditor = this.editors[--index3];
                        this._selectGroup(index3);
                        if (this.items[index3].type != 'ReadOnly') {
                            newEditor = true;
                            break;
                        }
                    }
                    if (!newEditor) {
                        if (tmpIndex3 >= 0) {
                            this.activeEditor = this.editors[tmpIndex3];
                        }
                    }
                    if (this.activeEditor != null && lastEditor != this.activeEditor) {
                        if (this.items[index3].type != 'ReadOnly') {
                            if (this.enableAbsoluteSelection) {
                                this.activeEditor.positions = this.activeEditor.maxEditPositions - 1;
                            }
                            else {
                                this.activeEditor.positions = 0;
                            }
                        }
                    }

                    if (this.activeEditor != lastEditor) {
                        this._validateValue();
                        this._updateText();
                        this._selectGroup(this.editors.indexOf(this.activeEditor));
                        return true;
                    }
                    else return false;
                }
            },

            _doRightKey: function () {
                if (this.activeEditor != null) {
                    if (!this.isEditing) this.isEditing = true;

                    var lastEditor = this.activeEditor;
                    var newEditor = false;
                    var index4 = this.editors.indexOf(this.activeEditor);
                    var tmpIndex3 = index4;

                    if (this.enableAbsoluteSelection) {
                        if (index4 >= 0 && this.activeEditor.positions < this.activeEditor.maxEditPositions - 1) {
                            this.activeEditor.positions++;
                            this._selectGroup(index4);
                            return;
                        }
                    }

                    while (index4 <= this.editors.length - 2) {
                        this.activeEditor = this.editors[++index4];
                        this._selectGroup(index4);
                        if (this.items[index4].type != 'ReadOnly') {
                            if (this.items[index4].type == 'Day' && this.items[index4].format.length > 2)
                                break;

                            newEditor = true;
                            break;
                        }
                    }
                    if (!newEditor) {
                        if (tmpIndex3 >= 0) {
                            this.activeEditor = this.editors[tmpIndex3];
                        }
                    }
                    if (this.activeEditor != null && this.activeEditor != lastEditor) {
                        if (this.items[index4].type != 'ReadOnly') {
                            this.activeEditor.positions = 0;
                        }
                    }

                    if (this.activeEditor != lastEditor) {
                        this._validateValue();
                        this._updateText();
                        this._selectGroup(this.editors.indexOf(this.activeEditor));
                        return true;
                    }
                    else return false;
                }
            },


            _saveSelectedText: function () {
                var selection = this._selection();
                var text = "";
                var allText = this.dateTimeInput.val();
                if (selection.start > 0 || selection.length > 0) {
                    for (var i = selection.start; i < selection.end; i++) {
                        text += allText[i];
                    }
                }
                if (window.clipboardData) {
                    window.clipboardData.setData("Text", text);
                }
                return text;
            },

            _selectWithAdvancePattern: function () {
                var editorIndex = this.editors.indexOf(this.activeEditor);
                var canAdvance = false;
                if (this.items[editorIndex].type != 'ReadOnly') {
                    canAdvance = true;
                }

                if (!canAdvance)
                    return;

                var numericEditor = this.activeEditor;

                if (numericEditor != null) {
                    var canSelectRight = numericEditor.positions == numericEditor.maxEditPositions;
                    if (canSelectRight) {
                        this.editorText = "";
                        var editValue = numericEditor.value;
                        var needValueUpdate = false;

                        switch (this.items[editorIndex].type) {
                            case 'FORMAT_AMPM':
                                if (editValue < 0) {
                                    editValue = 0;
                                }
                                else if (editValue > 1) {
                                    editValue = 1;
                                }
                                break;
                            case 'Character':
                                break;
                            case 'Day':
                                if (editValue < 1) {
                                    editValue = 1;
                                }
                                else if (editValue > 31) {
                                    editValue = 31;
                                }
                                break;
                            case 'FORMAT_hh':
                                if (editValue < 1) {
                                    editValue = 1;
                                }
                                else if (editValue > 12) {
                                    editValue = 12;
                                }
                                break;
                            case 'FORMAT_HH':
                                if (editValue < 0) {
                                    editValue = 0;
                                }
                                else if (editValue > 23) {
                                    editValue = 23;
                                }
                                break;
                            case 'Millisecond':
                                if (editValue < 0) {
                                    editValue = 0;
                                }
                                else if (editValue > 99) {
                                    editValue = 99;
                                }
                                break;
                            case 'Minute':
                                if (editValue < 0) {
                                    editValue = 0;
                                }
                                else if (editValue > 59) {
                                    editValue = 59;
                                }
                                break;
                            case 'Month':
                                if (editValue < 1) {
                                    editValue = 1;
                                }
                                else if (editValue > 12) {
                                    editValue = 12;
                                }
                                break;
                            case 'ReadOnly':
                                break;
                            case 'Second':
                                if (editValue < 0) {
                                    editValue = 0;
                                }
                                else if (editValue > 59) {
                                    editValue = 59;
                                }
                                break;
                            case 'Year':
                                if (editValue < this.minDate.year) {
                                    editValue = this.minDate.year;
                                }
                                else if (editValue > this.maxDate.year) {
                                    editValue = this.maxDate.year;
                                }
                                break;
                        }

                        if (numericEditor.value != editValue) {
                            needValueUpdate = true;
                        }

                        if (!needValueUpdate) {
                            this.isEditing = false;
                            this._validateValue();
                            this._updateText();
                            this.isEditing = true;
                            this._doRightKey();
                            return true;
                        }

                        return false;
                    }
                }
            },


            _handleKeyPress: function (e, key) {
                if (this._fullEditInProgress) {
                    this._enteredValue = true;
                    return;
                }

                var selection = this._selection();
                var rootElement = this;
                var ctrlKey = e.ctrlKey || e.metaKey;
                if ((ctrlKey && key == 97 /* firefox */) || (ctrlKey && key == 65) /* opera */) {
                    return true;
                }

                if (key == 8) {
                    if (selection.start > 0) {
                        rootElement._setSelectionStart(selection.start);
                    }
                    return false;
                }

                if (key == 46) {
                    if (selection.start < this.items.length) {
                        rootElement._setSelectionStart(selection.start);
                    }

                    return false;
                }

                if (key === 27) {
                    if (this._firstFocusDate) {
                        this.setDate(this._firstFocusDate);
                        this._setSelectionStart(0);
                        this._selectGroup(-1);
                    }
                    return false;
                }

                if (selection.start >= 0) {
                    this.changeType = "keyboard";

                    var letter = String.fromCharCode(key);
                    var digit = parseInt(letter);
                    if (letter == "p" || letter == "a" || letter == "A" || letter == "P") {
                        if (this.activeEditor && this.activeEditor.item.type == "FORMAT_AMPM") {
                            if (this.activeEditor.value == 0 && (letter == "p" || letter == "P")) {
                                this.spinUp();
                            }
                            else if (this.activeEditor.value == 1 && (letter == "a" || letter == "A")) {
                                this.spinDown();
                            }
                        }
                    }
                    if (!isNaN(digit)) {
                        if (this.container.css('display') == 'block') {
                            this.hideCalendar();
                        }

                        this.updateValue();
                        this._updateText();
                        var inserted = false;
                        var activeItem = this.editors.indexOf(this.activeEditor);
                        var dateTimeEditor = null;
                        this.isEditing = true;
                        if (activeItem.type != "ReadOnly") {
                            dateTimeEditor = this.activeEditor;
                        }

                        if (dateTimeEditor != null && dateTimeEditor.positions == 0) {
                            this.editorText = "";
                        }

                        if (this.activeEditor == null) {
                            this.activeEditor = this.editors[0];
                        }
                        if (this.activeEditor == null) return false;
                        this.activeEditor.insert(letter);
                        if (dateTimeEditor != null && this.editorText.length >= dateTimeEditor.maxEditPositions) {
                            this.editorText = "";
                        }

                        this.editorText += letter;
                        var advanced = this._selectWithAdvancePattern();

                        if (this.activeEditor.positions == this.activeEditor.maxEditPositions) {
                            var lastEditorIndex = this._getLastEditableEditorIndex();
                            if (this.editors.indexOf(this.activeEditor) == lastEditorIndex && advanced && this.enableAbsoluteSelection) {
                                this.activeEditor.positions = this.activeEditor.maxEditPositions - 1;
                            }
                            else {
                                this.activeEditor.positions = 0;
                            }
                        }

                        inserted = true;

                        this.updateValue();
                        this._updateText();
                        this._selectGroup(this.editors.indexOf(this.activeEditor));

                        return false;
                    }
                }
                var specialKey = this._isSpecialKey(key);
                return specialKey;
            },

            _getLastEditableEditorIndex: function () {
                var i = 0;
                var me = this;
                for (var itemIndex = this.items.length - 1; itemIndex >= 0; itemIndex--) {
                    if (this.items[itemIndex].type != 'ReadOnly') {
                        return itemIndex;
                    }
                }

                return -1;
            },

            _handleKeyDown: function (e, key) {
                var that = this;
                this.timePopup = false;
                if (key == 84) {
                    this.timePopup = true;
                }

                if (e.keyCode == 115) {
                    if (that.isOpened()) {
                        that.hideCalendar("keyboard", "keyboard");
                        return false;
                    }
                    else if (!that.isOpened()) {
                        that.showCalendar("keyboard", "keyboard");
                        return false;
                    }
                }

                if (e.altKey) {
                    if (e.keyCode == 38) {
                        if (that.isOpened()) {
                            if (that.showTimeButton && !that.showCalendarButton) {
                                that.timePopup = true;
                            }
                            that.hideCalendar("keyboard", "keyboard");
                            return false;
                        }
                    }
                    else if (e.keyCode == 40) {
                        if (!that.isOpened()) {
                            if (that.showTimeButton && !that.showCalendarButton) {
                                that.timePopup = true;
                            }
                            that.showCalendar("keyboard", "keyboard");
                            return false;
                        }
                    }
                }
                else if (e.ctrlKey) {
                    this.timePopup = true;
                    if (e.keyCode == 38) {
                        if (that.isOpened()) {
                            that.hideCalendar("keyboard", "keyboard");
                            return false;
                        }
                    }
                    else if (e.keyCode == 40) {
                        if (!that.isOpened()) {
                            that.showCalendar("keyboard", "keyboard");
                            return false;
                        }
                    }
                }

                if (that.isOpened()) {
                    if (e.keyCode == 9) {
                        that.hideCalendar('selected', "keyboard");
                        return true;
                    }

                    return;
                }

                var selection = that._selection();
                var ctrlKey = e.ctrlKey || e.metaKey;
                if ((ctrlKey && key == 99 /* firefox */) || (ctrlKey && key == 67) /* opera */) {
                    that._saveSelectedText(e);
                    return true;
                }

                if ((ctrlKey && key == 122 /* firefox */) || (ctrlKey && key == 90) /* opera */) return false;

                if ((ctrlKey && key == 118 /* firefox */) || (ctrlKey && key == 86) /* opera */
                    || (e.shiftKey && key == 45)) {
                    var value = that.val();
                    var me = this;
                    var pasteFrom = $('<textarea style="position: absolute; left: -1000px; top: -1000px;"/>');
                    $('body').append(pasteFrom);
                    pasteFrom.select();

                    setTimeout(function () {
                        var val = pasteFrom.val();
                        me.setDate(val);
                        pasteFrom.remove();
                    }, 100);

                    return true;
                }

                if (that._fullEditInProgress || that.editMode === 'full' && that.value === null) {
                    if (key == 13 && that._fullEditInProgress) {
                        // Enter has been pressed
                        that._endFullEdit();

                        if (that.value != null) {
                            that.isEditing = false;
                            that._validateValue(true);
                            that._updateText();
                            that._raiseEvent(9, event);

                            var i = that.editors.length - 1,
                                editor = that.editors[i];

                            while (editor && editor.formatValueLength === undefined) {
                                i--;
                                editor = that.editors[i];
                            }

                            if (editor && editor.formatValueLength !== undefined) {
                                that.activeEditor = editor;
                                that._selectGroup(i);
                            }
                        }
                    }
                    else {
                        that._fullEditInProgress = true;
                        delete that._enteredValue;
                    }

                    return;
                }

                if (key == 8 || key == 46) {
                    if (!e.altKey && !ctrlKey && key == 46) {
                        that.isEditing = false;
                        if (that.allowKeyboardDelete) {
                            that.changeType = "keyboard";
                            if (that.allowNullDate) {
                                that.setDate(null);
                            }
                            else {
                                if (that.selectionMode != 'range') {
                                    that.setDate(that.getMinDate());
                                }
                                else {
                                    that.setRange(that.getMinDate(), that.getMinDate());
                                }
                            }
                        }
                    }
                    else {
                        if (that.activeEditor != null) {
                            var activeEditorIndex = that.editors.indexOf(that.activeEditor);
                            if (that.activeEditor.positions >= 0) {
                                var formattedValue = that._format(Number(that.activeEditor.value), "d" + that.activeEditor.maxEditPositions, that.culture)
                                var tmp = formattedValue;
                                tmp = tmp.substring(0, that.activeEditor.positions) + '0' + tmp.substring(that.activeEditor.positions + 1);
                                if (parseInt(tmp) < that.activeEditor.minValue) {
                                    tmp = that._format(Number(that.activeEditor.minValue), "d" + that.activeEditor.maxEditPositions, that.culture)
                                }

                                if (that.enableAbsoluteSelection) {
                                    that.activeEditor.value = tmp;
                                }
                                else that.activeEditor.value = that.activeEditor.minValue;

                                that._validateValue();
                                that._updateText();
                                that.changeType = "keyboard";
                                if (key == 8) {
                                    var myself = this;

                                    if (that.enableAbsoluteSelection && that.activeEditor.positions > 0) {
                                        setTimeout(function () {
                                            myself.activeEditor.positions = myself.activeEditor.positions - 1;
                                            myself._selectGroup(activeEditorIndex);
                                        }, 10);
                                    }
                                    else {
                                        setTimeout(function () {
                                            myself._doLeftKey();
                                        }, 10);
                                    }
                                }
                                else that._selectGroup(activeEditorIndex);
                            }
                            else that._doLeftKey();
                        }
                    }
                    return false;
                }

                if (key == 38) {
                    this.spinUp();
                    that.changeType = "keyboard";
                    return false;
                }
                else if (key == 40) {
                    this.spinDown();
                    that.changeType = "keyboard";
                    return false;
                }

                if (key == 9) {
                    if (that.value == null)
                        return true;

                    if (e.shiftKey) {
                        var result = this._doLeftKey()
                    }
                    else {
                        var result = this._doRightKey();
                    }
                    if (!result)
                        return true;
                    else
                        return false;
                }

                if (key == 37) {
                    if (this._editor) {
                        var result = this._doLeftKey();
                        if (!result) {
                            this.isEditing = false;
                            this._validateValue();
                        }
                        return !result;
                    }
                    else {
                        var result = this._doLeftKey()
                        return false;
                    }
                }
                else if (key == 39 || key == 191) {
                    if (this._editor) {
                        var result = this._doRightKey();
                        if (!result) {
                            this.isEditing = false;
                            this._validateValue();
                        }
                        return !result;
                    }
                    else {
                        var result = this._doRightKey();
                        return false;
                    }
                }

                var specialKey = this._isSpecialKey(key);

                if (this.value == null && (key >= 48 && key <= 57 || key >= 96 && key <= 105)) {
                    that.changeType = "keyboard";

                    if (new Date() >= this.getMinDate() && new Date() <= this.getMaxDate()) {
                        this.setDate(new Date());
                    }
                    else {
                        this.setDate(this.getMaxDate());
                    }
                }

                if (!$.jqx.browser.mozilla)
                    return true;
                if ($.jqx.browser.mozilla && $.jqx.browser.version > 24) {
                    return true;
                }

                return specialKey;
            },


            _isSpecialKey: function (key) {
                if (key != 8 /* backspace */ &&
                    key != 9 /* tab */ &&
                    key != 13 /* enter */ &&
                    key != 35 /* end */ &&
                    key != 36 /* home */ &&
                    key != 37 /* left */ &&
                    key != 39 /* right */ &&
                    key != 27 /* right */ &&
                    key != 46 /* del */
                ) {
                    return false;
                }

                return true;
            },

            _selection: function () {
                if ('selectionStart' in this.dateTimeInput[0]) {
                    var e = this.dateTimeInput[0];
                    var selectionLength = e.selectionEnd - e.selectionStart;
                    return { start: e.selectionStart, end: e.selectionEnd, length: selectionLength, text: e.value };
                }
                else {
                    var r = document.selection.createRange();
                    if (r == null) {
                        return { start: 0, end: e.value.length, length: 0 }
                    }

                    var re = this.dateTimeInput[0].createTextRange();
                    var rc = re.duplicate();
                    re.moveToBookmark(r.getBookmark());
                    rc.setEndPoint('EndToStart', re);
                    var selectionLength = r.text.length;

                    return { start: rc.text.length, end: rc.text.length + r.text.length, length: selectionLength, text: r.text };
                }
            },

            _selectGroup: function (value, selection) {
                if (this.host.css('display') == 'none')
                    return;

                if (this.readonly) return;

                if (!selection) {
                    var selection = this._selection();
                }
                var str = "";
                var currentString = "";
                var activeEditor = null;
                for (var i = 0; i < this.items.length; i++) {
                    currentString = this.items[i].dateParser(this.value, this);
                    if (this.isEditing && this.items[i].type != 'ReadOnly') {
                        var isReadOnlyDay = this.items[i].type == 'Day' && this.items[i].format.length > 2;

                        if (!isReadOnlyDay && this.items[i].type != 'FORMAT_AMPM') {
                            if (this.yearCutoff !== null && this.items[i].type === 'Year' && this.items[i].format === 'yy') {
                                currentString = this.editors[i].value.toString().substring(2);
                            }
                            else {
                                currentString = this.items[i].dateParserInEditMode(new Number(this.editors[i].value), "d" + this.editors[i].maxEditPositions, this);
                                while (currentString.length < this.editors[i].maxEditPositions) {
                                    currentString = '0' + currentString;
                                }
                            }
                        }
                    }

                    str += currentString;

                    if (this.items[i].type == 'ReadOnly')
                        continue;

                    if (this.items[i].type == 'Day' && this.items[i].format.length > 2)
                        continue;

                    if (value != undefined && value != -1) {
                        if (i >= value) {
                            var selectionStart = str.length - currentString.length;
                            var selectionLength = currentString.length;

                            if (this.enableAbsoluteSelection) {
                                if (!isNaN(parseInt(currentString)) && this.isEditing && value != -1) {
                                    selectionLength = 1;
                                    selectionStart += this.editors[i].positions;
                                }
                            }

                            if (selectionStart == this.dateTimeInput.val().length) {
                                selectionStart--;
                            }

                            this._setSelection(selectionStart, selectionStart + selectionLength);
                            activeEditor = this.editors[i];
                            this.activeEditor = activeEditor;
                            break;
                        }
                    }
                    else if (str.length >= selection.start) {
                        activeEditor = this.editors[i];
                        this.activeEditor = activeEditor;
                        var selectionStart = str.length - currentString.length;
                        var selectionLength = 1;
                        if (this.enableAbsoluteSelection) {
                            if (!isNaN(parseInt(currentString)) && this.isEditing && value != -1) {
                                selectionLength = 1;
                                selectionStart += this.editors[i].positions;
                            }
                        }
                        else selectionLength = currentString.length;

                        this._setSelection(selectionStart, selectionStart + selectionLength);
                        break;
                    }
                }

                if (i < this.items.length && value == -1) {
                    if (this.items[i].type != 'ReadOnly') {
                        this.activeEditor.positions = 0;
                    }
                }

                var newSelection = this._selection();
                if (newSelection.length == 0) {
                    if (newSelection.start > 0) {
                        var editorIndex = this._getLastEditableEditorIndex();
                        if (editorIndex >= 0) {
                            //   this._selectGroup(editorIndex);
                        }
                    }
                }
            },

            _getLastEditableEditorIndex: function () {
                var editorIndex = -1;
                for (var i = 0; i < this.editors.length; i++) {
                    if (this.items[i].type == 'ReadOnly')
                        continue;

                    if (this.items[i].type == 'Day' && this.items[i].format.length > 2)
                        continue;

                    editorIndex = i;
                }

                return editorIndex;
            },

            _setSelection: function (start, end) {
                try {
                    if ('selectionStart' in this.dateTimeInput[0]) {
                        //  this.dateTimeInput[0].focus();
                        this.dateTimeInput[0].setSelectionRange(start, end);
                    }
                    else {
                        var range = this.dateTimeInput[0].createTextRange();
                        range.collapse(true);
                        range.moveEnd('character', end);
                        range.moveStart('character', start);
                        range.select();
                    }
                }
                catch (error) {
                }
            },

            _setSelectionStart: function (start) {
                this._setSelection(start, start);
            },

            destroy: function () {
                $.jqx.utilities.resize(this.host, null, true);
                this.host
                    .removeClass("jqx-rc-all")
                    ;
                if (this.timePopupElement) {
                    this.timePopupElement.remove();
                }
                this._calendar.destroy();
                this.container.remove();
                this._removeHandlers();
                this.dateTimeInput.remove();
                this.host.remove();
            },

            refreshValue: function () {
                this._refreshValue();
            },

            refresh: function (initialRefresh) {
                if (initialRefresh != true) {
                    this._setSize();
                    this._arrange();
                }
            },

            resize: function (width, height) {
                this.width = width;
                this.height = height;
                this.refresh();
            },

            _setOption: function (key, value, oldvalue) {
                if (key === "value") {
                    if (this.selectionMode != 'range') {
                        this._oldDT = null;
                    }
                    else this._oldDT = null;

                    this.value = value;
                    this._refreshValue();
                    this._raiseEvent(9, { type: null });
                }
                if (key == 'maxDate') {
                    this._calendar.maxDate = value;
                    this._raiseEvent(9, { type: null });
                }

                if (key == 'minDate') {
                    this._calendar.minDate = value;
                    this._raiseEvent(9, { type: null });
                }

                if (key == 'showCalendarButton') {
                    if (value) {
                        this.calendarButton.css('display', 'block');
                    }
                    else {
                        this.calendarButton.css('display', 'none');
                    }
                }

                if (key == "disabled") {
                    this.dateTimeInput.attr("disabled", value);
                }

                if (key == "readonly") {
                    this.readonly = value;
                    this.dateTimeInput.css("readonly", value);
                }

                if (key == "textAlign") {
                    this.dateTimeInput.css("text-align", value);
                    this.textAlign = value;
                }

                if (key == "width") {
                    this.width = value;
                    this.width = parseInt(this.width);
                    this._arrange();
                }
                else if (key == "height") {
                    this.height = value;
                    this.height = parseInt(this.height);
                    this._arrange();
                }
            },

            _updateHint: function () {
                var that = this;

                if (!that.hint) {
                    return;
                }

                if (that.isMaterialized()) {
                    setTimeout(function () {
                        if (that.dateTimeInput[0].value.length === 0) {
                            that.element.removeAttribute('hint');
                            that.label[0].innerHTML = that.placeHolder;
                        }
                        else {
                            that.label[0].innerHTML = '';

                            if (that.hint) {
                                that.element.setAttribute('hint', true);
                            }
                        }
                    });
                }
            },

            _refreshValue: function () {
                this._updateEditorsValue();
                this.updateValue();
                this._validateValue();
                this._updateText();
                this._updateHint();
            },

            _getYearBasedOnCutoff: function (lastTwoDigits) {
                var yearCutoff = this.yearCutoff.toString(),
                    threshold = parseFloat(yearCutoff.substring(2)),
                    decade = parseFloat(yearCutoff.substring(0, 2));

                if (parseFloat(lastTwoDigits) < threshold) {
                    decade++;
                }

                return parseFloat(decade + '' + lastTwoDigits);
            },

            _endFullEdit: function () {
                var me = this;

                if (!me._fullEditInProgress) {
                    return;
                }

                var enteredValue = me.dateTimeInput[0].value;

                delete me._fullEditInProgress;
                delete me._enteredValue;

                if (enteredValue === '') {
                    me.value = null;
                }
                else {
                    var enteredDate = new Date(enteredValue);
                    if (this._mask && this.formatString) {
                        var maskKeys = Object.keys(this._mask);
                        if (maskKeys.length === 2) {
                            var mask = [maskKeys[0], maskKeys[1]];
                            var prefix = enteredValue.substring(0, mask[0]);
                            var middle = enteredValue.substring(parseInt(mask[0]) + 1, mask[1]);
                            var suffix = enteredValue.substring(parseInt(mask[1]) + 1);

                            if (this.formatString.substring(0, mask[0]) === "dd") {
                                prefix = parseInt(prefix);
                                middle = parseInt(middle);
                                suffix = parseInt(suffix);

                                enteredDate = new Date(suffix, middle - 1, prefix);
                            }
                        }
                    }

                    if (!isNaN(enteredDate.getTime())) {
                        me.items = [];

                        if (me.yearCutoff) {
                            var year = enteredDate.getFullYear().toString();

                            if (enteredValue.indexOf(year) === -1 && enteredValue.indexOf(year.slice(2))) {
                                // only 2-digit year has been entered by the user
                                var validYear = me._getYearBasedOnCutoff(year.slice(2));

                                enteredDate.setFullYear(validYear);
                            }
                        }

                        me.value = $.jqx._jqxDateTimeInput.getDateTime(enteredDate);
                    }
                    else if (me.value === null) {
                        me._updateText();
                    }
                }
            },

            _getMask: function () {
                var that = this,
                    format = that.formatString,
                    patterns = {
                        // short date pattern
                        d: "M/d/yyyy",
                        // long date pattern
                        D: "dddd, MMMM dd, yyyy",
                        // short time pattern
                        t: "h:mm tt",
                        // long time pattern
                        T: "h:mm:ss tt",
                        // long date, short time pattern
                        f: "dddd, MMMM dd, yyyy h:mm tt",
                        // long date, long time pattern
                        F: "dddd, MMMM dd, yyyy h:mm:ss tt",
                        // month/day pattern
                        M: "MMMM dd",
                        // month/year pattern
                        Y: "yyyy MMMM",
                        // S is a sortable format that does not vary by culture
                        S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss",
                        // formatting of dates in MySQL DataBases
                        ISO: "yyyy-MM-dd hh:mm:ss",
                        ISO2: "yyyy-MM-dd HH:mm:ss",
                        d1: "dd.MM.yyyy",
                        d2: "dd-MM-yyyy",
                        zone1: "yyyy-MM-ddTHH:mm:ss-HH:mm",
                        zone2: "yyyy-MM-ddTHH:mm:ss+HH:mm",
                        custom: "yyyy-MM-ddTHH:mm:ss.fff",
                        custom2: "yyyy-MM-dd HH:mm:ss.fff"
                    },
                    mask = {};

                if (patterns[format]) {
                    format = patterns[format];
                }

                // expand single digit formats, then escape regular expression characters.
                var expFormat = format.replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\\\$1"),
                    regexp = ["^"],
                    index = 0,
                    quoteCount = 0,
                    tokenRegExp = /\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g,
                    match;

                // iterate through each date token found.
                while ((match = tokenRegExp.exec(expFormat)) !== null) {
                    var preMatch = expFormat.slice(index, match.index);

                    if (preMatch !== '') {
                        mask[index] = preMatch;
                    }

                    index = tokenRegExp.lastIndex;

                    // don't replace any matches that occur inside a string literal.
                    quoteCount += that._appendPreOrPostMatch(preMatch, regexp);
                    if (quoteCount % 2) {
                        regexp.push(match[0]);
                        continue;
                    }

                    // add a regex group for the token.
                    var m = match[0],
                        len = m.length,
                        add;
                    switch (m) {
                        case 'dddd': case 'ddd':
                        case 'MMMM': case 'MMM':
                        case 'gg': case 'g':
                            add = "(\\D+)";
                            break;
                        case 'tt': case 't':
                            add = "(\\D*)";
                            break;
                        case 'yyyy':
                        case 'fff':
                        case 'ff':
                        case 'f':
                            add = "(\\d{" + len + "})";
                            break;
                        case 'dd': case 'd':
                        case 'MM': case 'M':
                        case 'yy': case 'y':
                        case 'HH': case 'H':
                        case 'hh': case 'h':
                        case 'mm': case 'm':
                        case 'ss': case 's':
                            add = "(\\d\\d?)";
                            break;
                        case 'zzz':
                            add = "([+-]?\\d\\d?:\\d{2})";
                            break;
                        case 'zz': case 'z':
                            add = "([+-]?\\d\\d?)";
                            break;
                        case '/':
                            add = "(\\/)";
                            mask[index - 1] = '/';
                            break;
                        default:
                            throw "Invalid date format pattern '" + m + "'.";
                            break;
                    }
                    if (add) {
                        regexp.push(add);
                    }
                }
                that._appendPreOrPostMatch(expFormat.slice(index), regexp);
                regexp.push("$");

                that._mask = mask;
            },

            _appendPreOrPostMatch: function (preMatch, strings) {
                // appends pre- and post- token match strings while removing escaped characters.
                // Returns a single quote count which is used to determine if the token occurs
                // in a string literal.
                var quoteCount = 0,
                    escaped = false;
                for (var i = 0, il = preMatch.length; i < il; i++) {
                    var c = preMatch.charAt(i);
                    switch (c) {
                        case '\'':
                            if (escaped) {
                                strings.push("'");
                            }
                            else {
                                quoteCount++;
                            }
                            escaped = false;
                            break;
                        case '\\':
                            if (escaped) {
                                strings.push("\\");
                            }
                            escaped = !escaped;
                            break;
                        default:
                            strings.push(c);
                            escaped = false;
                            break;
                    }
                }
                return quoteCount;
            }
        })
    })(jqxBaseFramework);


    (function ($) {
        $.jqx._jqxDateTimeInput.DateTimeFormatItem = {};
        $.extend($.jqx._jqxDateTimeInput.DateTimeFormatItem, {

            _create: function (format, type, culture) {
                this.format = format;
                this.type = type;
                this.culture = culture;
                return this;
            },

            _itemValue: function () {
                switch (this.format.length) {
                    case 1:
                        return 9;
                    case 2:
                        return 99;
                    case 3:
                    default:
                        return 999;
                }
            },

            _maximumValue: function () {
                switch (this.format.length) {
                    case 1:
                        return 9;
                    case 2:
                        return 99;
                    case 3:
                    default:
                        return 999;
                }
            },

            dateParser: function (formattedDateTime, that) {
                if (formattedDateTime == null)
                    return "";
                var value = that._format(formattedDateTime.dateTime, this.format.length == 1 ? '%' + this.format : this.format, this.culture);
                return value;
            },

            dateParserInEditMode: function (val, format, that) {
                if (val == null)
                    return "";

                var value = that._format(val.toString(), format.length == 1 ? '%' + format : format, this.culture);
                return value;
            },

            getDateTimeEditorByItemType: function (value, that) {
                switch (this.type) {
                    case 'FORMAT_AMPM':
                        var aMpMEditor = $.jqx._jqxDateTimeInput.AmPmEditor._createAmPmEditor(this.format, value.hour / 12, that.localization.calendar.AM[0], that.localization.calendar.PM[0], this, that);
                        var newEditor = $.extend({}, aMpMEditor);
                        return newEditor;
                    case 'Character':
                        return null;
                    case 'Day':
                        var year = value.year;
                        var month = value.month;
                        var dayNames;
                        if (this.format.length == 3)
                            dayNames = that.localization.calendar.days.namesAbbr;
                        else if (this.format.length > 3)
                            dayNames = that.localization.calendar.days.names;
                        else
                            dayNames = null;

                        var val = value.day;
                        if (dayNames != null)
                            val = value.dayOfWeek + 1;

                        var dayEditor = $.jqx._jqxDateTimeInput.DateEditor._createDayEditor(value, value.day, 1, value._daysInMonth(year, month), this.format.length == 1 ? 1 : 2, 2, dayNames, this, that);
                        var newEditor = $.extend({}, dayEditor);
                        return newEditor;
                    case 'FORMAT_hh':
                        var initialValue = value.hour % 12;
                        if (initialValue == 0)
                            initialValue = 12;
                        var hhEditor = $.jqx._jqxDateTimeInput.NumberEditor._createNumberEditor(initialValue, 1, 12, this.format.length == 1 ? 1 : 2, 2, this, that);
                        var newEditor = $.extend({}, hhEditor);
                        return newEditor;
                    case 'FORMAT_HH':
                        var HHEditor = $.jqx._jqxDateTimeInput.NumberEditor._createNumberEditor(value.hour, 0, 23, this.format.length == 1 ? 1 : 2, 2, this, that);
                        var newEditor = $.extend({}, HHEditor);
                        return newEditor;
                    case 'Millisecond':
                        var milisecondEditor = $.jqx._jqxDateTimeInput.NumberEditor._createNumberEditor(value.millisecond / this._itemValue(), 0, this._maximumValue(), this.format.length, this.format.length, this, that);
                        var newEditor = $.extend({}, milisecondEditor);
                        return newEditor;
                    case 'Minute':
                        var minuteEditor = $.jqx._jqxDateTimeInput.NumberEditor._createNumberEditor(value.minute, 0, 59, this.format.length == 1 ? 1 : 2, 2, this, that);
                        var newEditor = $.extend({}, minuteEditor);
                        return newEditor;
                    case 'Month':
                        var monthNames;
                        if (this.format.length == 3)
                            monthNames = that.localization.calendar.months.namesAbbr;
                        else if (this.format.length > 3)
                            monthNames = that.localization.calendar.months.names;
                        else
                            monthNames = null;
                        var monthEditor = $.jqx._jqxDateTimeInput.DateEditor._createMonthEditor(value.month, this.format.length == 2 ? 2 : 1, monthNames, this, that);
                        var newEditor = $.extend({}, monthEditor);
                        return newEditor;
                    case 'ReadOnly':
                        return $.jqx._jqxDateTimeInput.DisabledEditor._create(this.format.length, value.day, this, that);
                    case 'Second':
                        var secondEditor = $.jqx._jqxDateTimeInput.NumberEditor._createNumberEditor(value.second, 0, 59, this.format.length == 1 ? 1 : 2, 2, this, that);
                        var newEditor = $.extend({}, secondEditor);
                        return newEditor;
                    case 'Year':
                        var yearEditor = $.jqx._jqxDateTimeInput.DateEditor._createYearEditor(value.year, (that.yearCutoff !== null && this.format === 'yy') ? 2 : 4, this, that);
                        var newEditor = $.extend({}, yearEditor);
                        return newEditor;
                }

                return null;
            }

            //getDateTimeWithOffset: function(offset, value)
            //{
            //    if (offset == null || value == null)
            //    {
            //        throw 'Invalid arguments';
            //    }

            //    var hours = value.hour;
            //    var minutes = value.minute;
            //    var seconds = value.second;
            //    var days = value.day();
            //    var months = value.month();
            //    var years = value.year();

            //    var dateTime = value;
            //    var newDateTime = value;

            //    switch (this.type)
            //    {
            //        case 'FORMAT_AMPM':
            //            hours = 12 * (offset - hours / 12);
            //            break;
            //        case 'Day':
            //            days = offset - days;
            //            if (days != offset)
            //            {
            //                if (offset == 29 && months == 2)
            //                {
            //                    newDateTime = dateTime;
            //                    while (!DateTime._isLeapYear(newDateTime.year))
            //                    {
            //                        newDateTime = newDateTime._addYears(1);
            //                    }

            //                        newDateTime = newDateTime._addDays(offset - newDateTime.day);
            //                }
            //                else
            //                {
            //                    newDateTime = dateTime._addMonths(1 - dateTime.month);
            //                    newDateTime = newDateTime._addDays(offset - dateTime.day);
            //                }
            //            }
            //            break;
            //        case 'FORMAT_hh':
            //            var res = offset == 12 ? 0 : offset;
            //            dateTime = dateTime._addHours(res - (dateTime.hour % 12));
            //            break;
            //        case 'FORMAT_HH':
            //            dateTime = dateTime._addHours(offset - dateTime.hour);
            //            break;
            //        case 'Millisecond':
            //            dateTime = dateTime._addMilliseconds(offset * this._itemValue() - dateTime.millisecond);
            //            break;
            //        case 'Minute':
            //            dateTime = dateTime._addMinutes(offset - dateTime.minute);
            //            break;
            //        case 'Month':
            //            newDateTime = dateTime._addMonths(offset - dateTime.month);
            //            if (offset == 2 && dateTime.day == 29 && dateTime.day != newDateTime.day
            //                )
            //            {
            //                newDateTime = dateTime;
            //                while (!dateTime.IsLeapYear(newDateTime.year))
            //                {
            //                    newDateTime = newDateTime._addYears(1);
            //                }

            //                newDateTime = newDateTime._addMonths(offset - newDateTime.month);
            //            }

            //            dateTime = newDateTime;
            //            break;
            //        case 'ReadOnly':
            //            break;
            //        case 'Second':
            //            dateTime = dateTime._addSeconds(offset - dateTime.second);

            //            break;
            //        case 'Year':
            //            if (offset == 0)
            //                offset = 1;

            //            dateTime = dateTime._addYears(offset - value.year);
            //            break;
            //    }
            //    return dateTime;
            //}
        });
    })(jqxBaseFramework);

    (function ($) {
        $.jqx._jqxDateTimeInput.DateEditor = $.extend($.jqx._jqxDateTimeInput.DateEditor, {

            formatValueLength: 0,
            handleYears: false,
            handleDays: false,
            handleMonths: false,
            positions: 0,
            value: 0,
            minEditPositions: 0,
            maxEditPositions: 0,
            minValue: 0,
            maxValue: 0,
            item: null,
            dateTimeFormatInfo: null,
            days: null,
            dateTimeMonths: null,
            lastDayInput: null,

            minPositions: function () {
                if (this.handleYears) {
                    if (this.formatValueLength == 4) {
                        if (this.positions <= 1) {
                            return 1;
                        }
                        else {
                            if (this.positions >= 4) {
                                return 4;
                            }
                        }

                        return this.positions;
                    }
                    else {
                        return this.minEditPositions;
                    }
                }
                return this.minEditPositions;
            },

            initializeFields: function (minValue, maxValue, minEditPositions, maxEditPositions, item) {
                this.minValue = minValue;
                this.maxValue = maxValue;
                this.minEditPositions = minEditPositions;
                this.maxEditPositions = maxEditPositions;
                this.updateActiveEditor(minValue);
                this.item = item;
            },

            _createYearEditor: function (baseYear, formatValueLength, item, that) {
                $.jqx._jqxDateTimeInput.DateEditor = $.extend(true, {}, this);
                this.initializeFields(formatValueLength <= 4 ? 0 : 0, formatValueLength < 4 ? 99 : 9999, (formatValueLength == 2) ? 2 : 1, formatValueLength > 3 ? 4 : 2, item);
                this.initializeYearEditor(baseYear, formatValueLength, item.culture);
                this.handleYears = true;
                this.that = that;
                return this;
            },

            initializeYearEditor: function (baseYear, formatValueLength, info) {
                this.formatValueLength = formatValueLength;
                this.dateTimeFormatInfo = info;

                var realYear = baseYear;
                realYear = Math.min(realYear, 9999);
                realYear = Math.max(realYear, 1);
                realYear = this.formatValueLength < 4 ? realYear % 100 : realYear;
                this.updateActiveEditor(realYear);
                this.value = realYear;
            },

            updateActiveEditor: function (newValue) {
                this.value = newValue;
                this.positions = 0;
            },

            _createDayEditor: function (editedValue, initialValue, minValue, maxValue, minEditingPositions, maxEditingPositions, dayKeys, item, that) {
                $.jqx._jqxDateTimeInput.DateEditor = $.extend(true, {}, this);
                this.initializeFields(minValue, maxValue, 1, maxEditingPositions, item);
                this.currentValue = editedValue;
                this.value = initialValue;
                this.days = dayKeys;
                this.handleDays = true;
                this.that = that;
                return this;
            },

            getDayOfWeek: function (val) {
                if (typeof this.currentValue == $.jqx._jqxDateTimeInput.DateTime) {
                    this.currentValue.dayOfWeek();
                }
                return val;
            },

            defaultTextValue: function () {
                var value = this.value;
                var minPositions = this.minEditPositions;
                var minFormattedPositions = minPositions;
                var formattedValue = this.that._format(this.value, "d" + minFormattedPositions, "");

                return formattedValue;
            },

            textValue: function () {
                if (this.handleDays) {
                    if (this.days == null) {
                        return this.defaultTextValue();
                    }
                    else {
                        var val = (this.value % 7) + 1;
                        val = this.getDayOfWeek(val);
                        return this.days[val];
                    }
                }
                else if (this.handleMonths) {
                    if (this.dateTimeMonths == null || this.value < 1 || this.value > 12) {
                        return this.defaultTextValue();
                    }
                    else {
                        return this.dateTimeMonths[this.value - 1];
                    }
                }
                return this.defaultTextValue();
            },

            defaultInsertString: function (inseredValue) {
                if (inseredValue == null) {
                    return this.deleteValue();
                }

                if (inseredValue.length == 0) {
                    return this.deleteValue();
                }

                var character = inseredValue.substring(0, 1);
                if (isNaN(character)) {
                    return;
                }

                var res = true;
                var tmp;
                var entries = 1;
                var formattedValue = this.that._format(Number(this.value), "d" + this.maxEditPositions, this.culture)
                tmp = formattedValue;
                if (this.positions >= this.maxEditPositions) {
                    this.positions = 0;
                }

                tmp = tmp.substring(0, this.positions) + character + tmp.substring(this.positions + 1);
                tmp = this.setValueByString(tmp, entries);
                return true;
            },

            setValueByString: function (tmp, entries) {
                tmp = this.fixValueString(tmp);
                var nextValue = new Number(tmp);
                this.value = nextValue;
                this.positions += entries;
                return tmp;
            },

            fixValueString: function (tmp) {
                if (tmp.length > this.maxEditPositions) {
                    tmp = tmp.substring(tmp.length - this.maxEditPositions);
                }

                //            var enteredDigit = parseInt(tmp[this.positions]);
                //            var pos = this.maxEditPositions - 1;
                //            while(parseInt(tmp) > this.maxValue)
                //            {
                //                if (pos < 0)
                //                    break;

                //                if (tmp[pos] > 0)
                //                {
                //                    var digit = parseInt(tmp[pos])-1;
                //                    tmp = tmp.substring(0, pos) + digit + tmp.substring(pos+1);
                //                }
                //                else pos--;
                //            }

                return tmp;
            },

            initializeValueString: function (formattedValue) {
                var tmp;
                tmp = "";

                if (this.hasDigits()) {
                    tmp = formattedValue;
                }
                return tmp;
            },

            deleteValue: function () {
                if (this.value == this.minValue && this.hasDigits() == false) {
                    return false;
                }

                this.updateActiveEditor(this.minValue);
                return true;
            },

            hasDigits: function () {
                return this.positions > 0;
            },

            insert: function (input) {
                if (this.handleDays) {
                    if (this.days != null) {
                        var res = false;
                        res = this.insertLongString(input, res);
                        if (res) {
                            return res;
                        }
                        res = this.insertShortString(input, res);
                        if (res) {
                            return res;
                        }
                    }

                    if (this.value == 1 && this.lastDayInput != null && this.lastDayInput.toString().length > 0 && this.lastDayInput.toString() == "0") {
                        this.value = 0;
                    }

                    this.lastDayInput = input;

                    return this.defaultInsertString(input);
                }
                else if (this.handleMonths) {
                    if (this.dateTimeMonths != null) {
                        var res = false;
                        res = this.insertLongString2(input, res);

                        if (res) {
                            return res;
                        }

                        res = this.insertShortString2(input, res);

                        if (res) {
                            return res;
                        }
                    }
                }
                else if (this.that.yearCutoff !== null && this.handleYears && this.formatValueLength === 2) {
                    if (input == null || input.length == 0) {
                        return this.deleteValue();
                    }

                    var character = input.substring(0, 1);

                    if (isNaN(character)) {
                        return;
                    }

                    if (this.positions >= this.maxEditPositions) {
                        this.positions = 0;
                    }

                    var tmp = this.value.toString().substring(2);

                    tmp = tmp.substring(0, this.positions) + character + tmp.substring(this.positions + 1);

                    this.value = this.that._getYearBasedOnCutoff(tmp);
                    this.positions += 1;

                    return true;
                }

                return this.defaultInsertString(input);
            },

            insertShortString: function (input, res) {
                if (input.length == 1) {
                    for (var i = 0; i < 6; ++i) {
                        var testedDay = (this.value + i) % 7 + 1;
                        var dayName = this.days[testedDay - 1];
                        if (dayName.substring(0, 1) == input) {
                            this.updateActiveEditor(testedDay);
                            res = true;
                            return res;
                        }
                    }
                }
                return res;
            },

            insertLongString: function (input, res) {
                if (input.length > 0) {
                    for (var i = 0; i < 6; ++i) {
                        var testedDay = (this.value + i) % 7 + 1;
                        if (this.days[testedDay - 1] == input) {
                            this.updateActiveEditor(testedDay);
                            res = true;
                            return res;
                        }
                    }
                }
                return res;
            },

            _createMonthEditor: function (baseValue, positions, monthsNames, item, that) {
                $.jqx._jqxDateTimeInput.DateEditor = $.extend(true, {}, this);

                this.initializeFields(1, 12, positions, 2, item);
                this.dateTimeMonths = monthsNames;
                this.value = baseValue;
                if (this.dateTimeMonths != null && this.dateTimeMonths[12] != null && this.dateTimeMonths[12].length > 0)
                    this.dateTimeMonths = null;
                this.handleMonths = true;
                this.that = that;
                return this;
            },

            insertLongString2: function (input, res) {
                if (input.length > 0) {
                    for (var i = 0; i < 11; ++i) {
                        var month = (this.value + i) % 12 + 1;
                        if (this.dateTimeMonths[month - 1] == input) {
                            this.updateActiveEditor(month);
                            res = true;
                            return res;
                        }
                    }
                }
                return res;
            },

            insertShortString2: function (input, res) {
                if (input.length == 1) {
                    for (var i = 0; i < 11; ++i) {
                        var month = (this.value + i) % 12 + 1;
                        var monthName = this.dateTimeMonths[month - 1];
                        if (monthName.substring(0, 1) == input) {
                            this.updateActiveEditor(month);
                            res = true;
                            return res;
                        }
                    }
                }
                return res;
            },

            correctMaximumValue: function (val) {
                var maxValue = this.maxValue;

                if (this.that.yearCutoff !== null && this.item.type === 'Year' && this.item.format === 'yy') {
                    maxValue = 9999;
                }

                if (val > maxValue) {
                    val = this.minValue;
                }
                return val;
            },

            correctMinimumValue: function (val) {
                if (val < this.minValue) {
                    val = this.maxValue;
                }
                return val;
            },

            increaseValue: function (byPosition) {
                var formattedValue = this.that._format(Number(this.value), "d" + this.maxEditPositions, this.culture)
                var digit = formattedValue.toString()[this.positions];
                digit = parseInt(digit) + 1;
                if (digit > 9) digit = 0;

                if (!byPosition) {
                    var tmpValue = this.value + 1;
                    tmpValue = this.correctMaximumValue(tmpValue);
                    this.updateActiveEditor(tmpValue);
                    return true;
                }

                var val = formattedValue.substring(0, this.positions) + digit + formattedValue.substring(this.positions + 1);

                if (val != this.value || this.hasDigits()) {
                    this.updateActiveEditor(val);
                    return true;
                }
                else {
                    return false;
                }
            },

            decreaseValue: function (byPosition) {
                var formattedValue = this.that._format(Number(this.value), "d" + this.maxEditPositions, this.culture)
                var digit = formattedValue.toString()[this.positions];
                digit = parseInt(digit) - 1;
                if (digit < 0) digit = 9;

                if (!byPosition) {
                    var tmpValue = this.value - 1;
                    tmpValue = this.correctMinimumValue(tmpValue);
                    this.updateActiveEditor(tmpValue);
                    return true;
                }

                var val = formattedValue.substring(0, this.positions) + digit + formattedValue.substring(this.positions + 1);

                if (val != this.value || this.hasDigits()) {
                    this.updateActiveEditor(val);
                    return true;
                }
                else {
                    return false;
                }
            },

            getDateTimeItem: function () {
                return this.item;
            }
        })
    })(jqxBaseFramework);

    //Number Editor
    (function ($) {
        $.jqx._jqxDateTimeInput.NumberEditor = {};
        $.extend($.jqx._jqxDateTimeInput.NumberEditor, {

            formatValueLength: 0,
            positions: 0,
            value: 0,
            minEditPositions: 0,
            maxEditPositions: 0,
            minValue: 0,
            maxValue: 0,
            item: null,

            minPositions: function () {
                if (this.handleYears) {
                    if (this.formatValueLength == 4) {
                        if (this.positions <= 1) {
                            return 1;
                        }
                        else {
                            if (this.positions >= 4) {
                                return 4;
                            }
                        }

                        return this.positions;
                    }
                    else {
                        return this.minEditPositions;
                    }
                }
                return this.minEditPositions;
            },

            _createNumberEditor: function (value, minValue, maxValue, minEditPositions, maxEditPositions, item, that) {
                $.jqx._jqxDateTimeInput.NumberEditor = $.extend(true, {}, this);
                this.initializeFields(minValue, maxValue, minEditPositions, maxEditPositions, item);
                this.that = that;

                return this;
            },

            initializeFields: function (minValue, maxValue, minEditPositions, maxEditPositions, item) {
                this.minValue = minValue;
                this.maxValue = maxValue;
                this.minEditPositions = minEditPositions;
                this.maxEditPositions = maxEditPositions;
                this.updateActiveEditor(minValue);
                this.item = item;
            },

            updateActiveEditor: function (newValue) {
                this.value = newValue;
                this.positions = 0;
            },

            getDayOfWeek: function (val) {
                if (typeof this.currentValue == $.jqx._jqxDateTimeInput.DateTime) {
                    this.currentValue.dayOfWeek();
                }
                return val;
            },

            textValue: function () {
                var value = this.value;
                var minPositions = this.minEditPositions;
                var minFormattedPositions = minPositions;
                var formattedValue = this.that._format(this.value, "d" + minFormattedPositions, "");

                return formattedValue;
            },

            insert: function (inseredValue) {
                if (inseredValue == null) {
                    return this.deleteValue();
                }

                if (inseredValue.length == 0) {
                    return this.deleteValue();
                }

                var character = inseredValue.substring(0, 1);
                if (isNaN(character)) {
                    return;
                }

                var res = true;
                var tmp;
                var entries = 1;
                var formattedValue = this.that._format(Number(this.value), "d" + this.maxEditPositions, this.culture)
                tmp = formattedValue;
                if (this.positions >= this.maxEditPositions) {
                    this.positions = 0;
                }

                tmp = tmp.substring(0, this.positions) + character + tmp.substring(this.positions + 1);
                tmp = this.setValueByString(tmp, entries);
                return true;
            },

            setValueByString: function (tmp, entries) {
                tmp = this.fixValueString(tmp);
                var nextValue = new Number(tmp);
                this.value = nextValue;
                this.positions += entries;
                return tmp;
            },

            fixValueString: function (tmp) {
                if (tmp.length > this.maxEditPositions) {
                    tmp = tmp.substring(tmp.length - this.maxEditPositions);
                }

                //            var enteredDigit = parseInt(tmp[this.positions]);
                //            var pos = this.maxEditPositions - 1;
                //            while(parseInt(tmp) > this.maxValue)
                //            {
                //                if (pos < 0)
                //                    break;

                //                if (tmp[pos] > 0)
                //                {
                //                    var digit = parseInt(tmp[pos])-1;
                //                    tmp = tmp.substring(0, pos) + digit + tmp.substring(pos+1);
                //                }
                //                else pos--;
                //            }

                return tmp;
            },

            initializeValueString: function (formattedValue) {
                var tmp;
                tmp = "";

                if (this.hasDigits()) {
                    tmp = formattedValue;
                }
                return tmp;
            },

            deleteValue: function () {
                if (this.value == this.minValue && this.hasDigits() == false) {
                    return false;
                }

                this.updateActiveEditor(this.minValue);
                return true;
            },

            hasDigits: function () {
                return this.positions > 0;
            },

            correctMaximumValue: function (val) {
                if (val > this.maxValue) {
                    val = this.minValue;
                }
                return val;
            },

            correctMinimumValue: function (val) {
                if (val < this.minValue) {
                    val = this.maxValue;
                }
                return val;
            },

            increaseValue: function (byPosition) {
                var formattedValue = this.that._format(Number(this.value), "d" + this.maxEditPositions, this.culture)
                var digit = formattedValue.toString()[this.positions];
                digit = parseInt(digit) + 1;
                if (digit > 9) digit = 0;

                if (!byPosition) {
                    var tmpValue = this.value + 1;
                    tmpValue = this.correctMaximumValue(tmpValue);
                    this.updateActiveEditor(tmpValue);
                    return true;
                }

                var val = formattedValue.substring(0, this.positions) + digit + formattedValue.substring(this.positions + 1);

                if (val != this.value || this.hasDigits()) {
                    this.updateActiveEditor(val);
                    return true;
                }
                else {
                    return false;
                }
            },

            decreaseValue: function (byPosition) {
                var formattedValue = this.that._format(Number(this.value), "d" + this.maxEditPositions, this.culture)
                var digit = formattedValue.toString()[this.positions];
                digit = parseInt(digit) - 1;
                if (digit < 0) digit = 9;

                if (!byPosition) {
                    var tmpValue = this.value - 1;
                    tmpValue = this.correctMinimumValue(tmpValue);
                    this.updateActiveEditor(tmpValue);
                    return true;
                }

                var val = formattedValue.substring(0, this.positions) + digit + formattedValue.substring(this.positions + 1);

                if (val != this.value || this.hasDigits()) {
                    this.updateActiveEditor(val);
                    return true;
                }
                else {
                    return false;
                }
            },

            getDateTimeItem: function () {
                return this.item;
            }
        })
    })(jqxBaseFramework);

    //DisabledEditor
    (function ($) {

        $.jqx._jqxDateTimeInput.DisabledEditor = {};
        $.extend($.jqx._jqxDateTimeInput.DisabledEditor, {

            _create: function (format, baseValue, am, pm, item, that) {
                this.format = format;
                this.value = -1;
                this.item = item;
                this.that = that;

                return this;
            },

            textValue: function () {
                return "";
            },

            insert: function (val) {
                return false;
            },

            deleteValue: function () {
                return false;
            },

            increaseValue: function () {
                return false;
            },

            decreaseValue: function () {
                return false;
            },

            getDateTimeItem: function () {
                return this.item;
            }
        })
    })(jqxBaseFramework);

    //AmPmEditor
    (function ($) {

        $.jqx._jqxDateTimeInput.AmPmEditor = {};
        $.extend($.jqx._jqxDateTimeInput.AmPmEditor, {
            _createAmPmEditor: function (format, baseValue, am, pm, item, that) {
                this.format = format;
                this.value = baseValue;
                this.minValue = 0;
                this.amString = am;
                this.pmString = pm;
                this.item = item;
                this.that = that;

                if (am == pm) {
                    this.amString = "<" + am;
                    this.pmString = ">" + pm;
                }
                return this;
            },

            textValue: function () {
                var res = this.amString;
                if (this.value != 0) {
                    res = this.pmString;
                }

                if (this.format.length == 1 && res.length > 1) {
                    res = res.substring(0, 1);
                }

                return res;
            },

            insert: function (val) {
                var inserted = val.toString();
                if (inserted.Length == 0) {
                    return this.deleteValue();
                }

                var res = false;
                if (this.amString.Length > 0
                    && this.pmString.Length > 0) {
                    var amChar = this.amString[0];
                    var newChar = inserted[0];
                    var pmChar = this.pmString[0];

                    if (amChar.toString() == newChar.toString()) {
                        this.value = 0;
                        res = true;

                    }
                    else if (pmChar.toString() == newChar.toString()) {
                        this.value = 1;
                        res = true;
                    }
                }
                else if (this.pmString.Length > 0) {
                    this.value = 1;
                    res = true;
                }
                else if (this.amString.Length > 0) {
                    this.value = 0;
                    res = true;
                }

                return res;
            },

            deleteValue: function () {
                var isValid = true;

                if (this.amString.Length == 0
                    && this.pmString.Length != 0) {
                    if (this.value == 0) {
                        return false;
                    }

                    this.value = 0;
                }
                else {
                    if (this.value == 1) {
                        return false;
                    }

                    this.value = 1;
                }
                return isValid;
            },

            increaseValue: function () {
                this.value = 1 - this.value;
                return true;
            },

            decreaseValue: function () {
                this.increaseValue();
                return true;
            },

            getDateTimeItem: function () {
                return this.item;
            }
        })
    })(jqxBaseFramework);

    // DateTime
    (function ($) {
        $.jqx._jqxDateTimeInput.getDateTime = function (date) {
            var result =
            {
                dateTime: new Date(date),
                daysPer4Years: 0x5b5,
                daysPerYear: 0x16d,
                daysToMonth365: { 0: 0, 1: 0x1f, 2: 0x3b, 3: 90, 4: 120, 5: 0x97, 6: 0xb5, 7: 0xd4, 8: 0xf3, 9: 0x111, 10: 0x130, 11: 0x14e, 12: 0x16d },
                daysToMonth366: { 0: 0, 1: 0x1f, 2: 60, 3: 0x5b, 4: 0x79, 5: 0x98, 6: 0xb6, 7: 0xd5, 8: 0xf4, 9: 0x112, 10: 0x131, 11: 0x14f, 12: 0x16e },
                maxValue: 0x2bca2875f4373fff,
                millisPerDay: 0x5265c00,
                millisPerHour: 0x36ee80,
                millisPerMinute: 0xea60,
                millisPerSecond: 0x3e8,
                minTicks: 0,
                minValue: 0,
                ticksPerDay: 0xc92a69c000,
                ticksPerHour: 0x861c46800,
                ticksPerMillisecond: 0x2710,
                ticksPerMinute: 0x23c34600,
                ticksPerSecond: 0x989680,
                hour: date.getHours(),
                minute: date.getMinutes(),
                day: date.getDate(),
                second: date.getSeconds(),
                month: 1 + date.getMonth(),
                year: date.getFullYear(),
                millisecond: date.getMilliseconds(),
                dayOfWeek: date.getDay(),
                isWeekend: function (value) {
                    if (value == undefined || value == null)
                        value = this.dateTime;

                    var isWeekend = value.getDay() % 6 == 0;
                    return isWeekend;
                },
                dayOfYear: function (value) {
                    if (value == undefined || value == null)
                        value = this.dateTime;

                    var firstDay = new Date(value.getFullYear(), 0, 1);
                    return Math.ceil((value - firstDay) / 86400000);
                },
                _setDay: function (value) {
                    if (value == undefined || value == null)
                        value = 0;

                    this.dateTime.setDate(value);
                    this.day = this.dateTime.getDate();
                },
                _setMonth: function (value) {
                    if (value == undefined || value == null)
                        value = 0;

                    this.dateTime.setMonth(value - 1);
                    this.month = 1 + this.dateTime.getMonth();
                },
                _setYear: function (value) {
                    if (value == undefined || value == null)
                        value = 0;

                    this.dateTime.setFullYear(value);
                    this.year = this.dateTime.getFullYear();
                },
                _setHours: function (value) {
                    if (value == undefined || value == null)
                        value = 0;

                    this.dateTime.setHours(value);
                    this.hour = this.dateTime.getHours();
                },
                _setMinutes: function (value) {
                    if (value == undefined || value == null)
                        value = 0;

                    this.dateTime.setMinutes(value);
                    this.minute = this.dateTime.getMinutes();
                },
                _setSeconds: function (value) {
                    if (value == undefined || value == null)
                        value = 0;

                    this.dateTime.setSeconds(value);
                    this.second = this.dateTime.getSeconds();
                },
                _setMilliseconds: function (value) {
                    if (value == undefined || value == null)
                        value = 0;

                    this.dateTime.setMilliseconds(value);
                    this.millisecond = this.dateTime.getMilliseconds();
                },
                _addDays: function (value) {
                    var newDate = this.dateTime;
                    var day = newDate.getDate();
                    newDate.setDate(newDate.getDate() + value);
                    if (day === newDate.getDate()) {
                        newDate.setHours(newDate.getHours() + newDate.getTimezoneOffset() / 60);
                    }
                    return newDate;
                },
                _addWeeks: function (value) {
                    var newDate = this.dateTime;
                    newDate.setDate(newDate.getDate() + 7 * value);
                    return newDate;
                },
                _addMonths: function (value) {
                    var newDate = this.dateTime;
                    newDate.setMonth(newDate.getMonth() + value);
                    return newDate;
                },
                _addYears: function (value) {
                    var newDate = this.dateTime;
                    newDate.setFullYear(newDate.getFullYear() + value);
                    return newDate;
                },
                _addHours: function (value) {
                    var newDate = this.dateTime;
                    newDate.setHours(newDate.getHours() + value);
                    return newDate;
                },
                _addMinutes: function (value) {
                    var newDate = this.dateTime;
                    newDate.setMinutes(newDate.getMinutes() + value);
                    return newDate;
                },
                _addSeconds: function (value) {
                    var newDate = this.dateTime;
                    newDate.setSeconds(newDate.getSeconds() + value);
                    return newDate;
                },
                _addMilliseconds: function (value) {
                    var newDate = this.dateTime;
                    newDate.setMilliseconds(newDate.getMilliseconds() + value);
                    return newDate;
                },
                _isLeapYear: function (year) {
                    if ((year < 1) || (year > 0x270f)) {
                        throw "invalid year";
                    }
                    if ((year % 4) != 0) {
                        return false;
                    }
                    if ((year % 100) == 0) {
                        return ((year % 400) == 0);
                    }
                    return true;
                },
                _dateToTicks: function (year, month, day) {
                    if (((year >= 1) && (year <= 0x270f)) && ((month >= 1) && (month <= 12))) {
                        var numArray = this._isLeapYear(year) ? this.daysToMonth366 : this.daysToMonth365;
                        if ((day >= 1) && (day <= (numArray[month] - numArray[month - 1]))) {
                            var year = year - 1;
                            var ticks = ((((((year * 0x16d) + (year / 4)) - (year / 100)) + (year / 400)) + numArray[month - 1]) + day) - 1;
                            return (ticks * 0xc92a69c000);
                        }
                    }
                },
                _daysInMonth: function (year, month) {
                    if ((month < 1) || (month > 12)) {
                        throw ("Invalid month.");
                    }
                    var arr = this._isLeapYear(year) ? this.daysToMonth366 : this.daysToMonth365;
                    return (arr[month] - arr[month - 1]);
                },
                _timeToTicks: function (hour, minute, second) {
                    var ticks = ((hour * 0xe10) + (minute * 60)) + second;
                    return (ticks * 0x989680);
                },
                _equalDate: function (date) {
                    if (this.year == date.getFullYear() && this.day == date.getDate() && this.month == date.getMonth() + 1)
                        return true;

                    return false;
                }
            }
            return result;
        }
    })(jqxBaseFramework);
})();





/***/ }),

/***/ 5868:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {

        $.jqx.jqxWidget("jqxDropDownList", "", {});

        $.extend($.jqx._jqxDropDownList.prototype, {
            defineInstance: function () {
                var settings = {
                    // enables/disables the dropdownlist.
                    disabled: false,
                    // gets or sets the listbox width.
                    width: null,
                    // gets or sets the listbox height.
                    height: null,
                    // Represents the collection of list items.
                    items: new Array(),
                    // Gets or sets the selected index.
                    selectedIndex: -1,
                    // data source.
                    source: null,
                    // gets or sets the scrollbars size.
                    scrollBarSize: 15,
                    // gets or sets the scrollbars size.
                    arrowSize: 17,
                    // enables/disables the hover state.
                    enableHover: true,
                    // enables/disables the selection.
                    enableSelection: true,
                    autoItemsHeight: false,
                    // gets the visible items. // this property is internal for the dropdownlist.
                    visualItems: new Array(),
                    // gets the groups. // this property is internal for the dropdownlist.
                    groups: new Array(),
                    // gets or sets whether the items width should be equal to the dropdownlist's width.
                    equalItemsWidth: true,
                    // gets or sets the height of the ListBox Items. When the itemHeight == - 1, each item's height is equal to its desired height.
                    itemHeight: -1,
                    // represents the dropdownlist's events.
                    visibleItems: new Array(),
                    // emptry group's text.
                    emptyGroupText: 'Group',
                    checkboxes: false,
                    // Type: Number
                    // Default: 100
                    // Showing Popup Animation's delay.
                    openDelay: 250,
                    // Type: Number
                    // Default: 200
                    // Hiding Popup Animation's delay.
                    closeDelay: 300,
                    dropDownContainer: "default",
                    // default, none
                    // Type: String.
                    // enables or disables the animation.
                    animationType: 'default',
                    autoOpen: false,
                    // Type: String
                    // Default: auto ( the drop down takes the dropdownlist's width.)
                    // Sets the popup's width.
                    dropDownWidth: 'auto',
                    // Type: String
                    // Default: 200px ( the height is 200px )
                    // Sets the popup's height.
                    dropDownHeight: '200px',
                    // Type: Boolean
                    // Default: false
                    // Sets the popup's height to be equal to the items summary height,
                    autoDropDownHeight: false,
                    keyboardSelection: true,
                    // Type: Boolean
                    // Default: false
                    // Enables or disables the browser detection.
                    enableBrowserBoundsDetection: false,
                    dropDownHorizontalAlignment: 'left',
                    dropDownVerticalAlignment: 'bottom',
                    displayMember: "",
                    valueMember: "",
                    groupMember: "",
                    searchMember: "",
                    searchMode: 'startswithignorecase',
                    incrementalSearch: true,
                    incrementalSearchDelay: 700,
                    renderer: null,
                    placeHolder: "",
                    promptText: "Please Choose:",
                    emptyString: "",
                    rtl: false,
                    selectionRenderer: null,
                    listBox: null,
                    popupZIndex: 3001,
                    renderMode: "default",
                    touchMode: "auto",
                    _checkForHiddenParent: true,
                    autoBind: true,
                    ready: null,
                    focusable: true,
                    filterable: false,
                    filterHeight: 27,
                    filterPlaceHolder: "Looking for",
                    filterDelay: 100,
                    hint: true,
                    // "primary", "inverse", "danger", "info", "success", "warning", "link"
                    template: "default",
                    aria:
                    {
                        "aria-disabled": { name: "disabled", type: "boolean" }
                    },
                    events:
                        [
                            // occurs when the dropdownlist is opened.
                            'open',
                            // occurs when the dropdownlist is closed.
                            'close',
                            // occurs when an item is selected.
                            'select',
                            // occurs when an item is unselected.
                            'unselect',
                            // occurs when the selection is changed.
                            'change',
                            // triggered when the user checks or unchecks an item.
                            'checkChange',
                            // triggered when the binding operation is completed.
                            'bindingComplete',
                            // triggered when a new item is added.
                            'itemAdd',
                            // triggered when a new item is removed.
                            'itemRemove',
                            // triggered when a new item is updated.
                            'itemUpdate'
                        ]
                }
                if (this === $.jqx._jqxDropDownList.prototype) {
                    return settings;
                }
                $.extend(true, this, settings);
                return settings;
            },

            createInstance: function (args) {
                var that = this;

                if (that.isMaterialized()) {
                    var elementStyle = window.getComputedStyle(this.element);
                    var animation = elementStyle.getPropertyValue('--jqx-dropdown-animation');
                    var rowHeight = elementStyle.getPropertyValue('--jqx-list-item-height');
                    var arrowSize = elementStyle.getPropertyValue('--jqx-action-button-size');

                    if (arrowSize) {
                        this.arrowSize = parseInt(arrowSize);
                    }
                    else {
                        this.arrowSize = 25;
                    }

                    if (animation && this.animationType == "default") {
                        this.animationType = animation.trim();
                    }

                    if (rowHeight && this.itemHeight === -1) {
                        this.itemHeight = parseInt(rowHeight);
                    }
                }

                this.render();
            },

            render: function () {
                var self = this;
                if (!self.width) self.width = 200;
                if (!self.height) self.height = 25;

                self.host.addClass(self.toThemeProperty('jqx-dropdownlist'));

                var nodeName = self.element.nodeName.toLowerCase();
                if (nodeName == "select" || nodeName == "ul" || nodeName == "ol") {
                    self.field = self.element;
                    if (self.field.className) {
                        self._className = self.field.className;
                    }

                    var properties = {
                        'title': self.field.title
                    };

                    if (self.field.id.length) {
                        properties.id = self.field.id.replace(/[^\w]/g, '_') + "_jqxDropDownList";
                    }
                    else {
                        properties.id = $.jqx.utilities.createId() + "_jqxDropDownList";
                    }

                    var wrapper = $("<div></div>", properties);
                    if (!self.width) {
                        self.width = $(self.field).width();
                    }
                    if (!self.height) {
                        self.height = $(self.field).outerHeight();
                    }
                    wrapper[0].style.cssText = self.field.style.cssText;
                    $(self.field).hide().after(wrapper);
                    var data = self.host.data();
                    self.host = wrapper;
                    self.host.data(data);
                    self.element = wrapper[0];
                    self.element.id = self.field.id;
                    self.field.id = properties.id;
                    if (self._className) {
                        self.host.addClass(self._className);
                        $(self.field).removeClass(self._className);
                    }

                    if (self.field.tabIndex) {
                        var tabIndex = self.field.tabIndex;
                        self.field.tabIndex = -1;
                        self.element.tabIndex = tabIndex;
                    }
                    var result = $.jqx.parseSourceTag(self.field);
                    self.source = result.items;
                    if (self.selectedIndex == -1)
                        self.selectedIndex = result.index;
                }
                else {
                    if (self.host.find('li').length > 0 || self.host.find('option').length > 0) {
                        var result = $.jqx.parseSourceTag(self.element);
                        self.source = result.items;
                    }
                }
                self.element.innerHTML = "";
                self.isanimating = false;
                self.id = self.element.id || $.jqx.utilities.createId();
                self.host.attr('role', 'combobox');
                self.host.attr('aria-label', 'DropDownList');
                self.host.attr('aria-expanded', 'false');

                $.jqx.aria(self, "aria-autocomplete", "both");
                $.jqx.aria(self, "aria-readonly", false);

                var comboStructure = "<div style='background-color: transparent; -webkit-appearance: none; outline: none; width:100%; height: 100%; padding: 0px; margin: 0px; border: 0px; position: relative;'>" +
                    "<div id='dropdownlistWrapper' style='overflow: hidden; outline: none; background-color: transparent; border: none; float: left; width:100%; height: 100%; position: relative;'>" +
                    "<div id='dropdownlistContent' unselectable='on' style='outline: none; background-color: transparent; border: none; float: left; position: relative;'></div>" +
                    "<div id='dropdownlistArrow' unselectable='on' style='background-color: transparent; border: none; float: right; position: relative;'><div unselectable='on'></div></div>" +
                    "</div>" +
                    "</div>";

                if ($.jqx._jqxListBox == null || $.jqx._jqxListBox == undefined) {
                    throw new Error("jqxDropDownList: Missing reference to jqxlistbox.js.");
                }

                if (self.host.attr('tabindex')) {
                }
                else {
                    self.host.attr('tabindex', 0);
                }

                var me = self;

                self.touch = $.jqx.mobile.isTouchDevice();
                self.comboStructure = comboStructure;
                self.element.innerHTML = comboStructure;

                self.dropdownlistWrapper = $(self.element.firstChild.firstChild);
                self.dropdownlistArrow = $(self.dropdownlistWrapper[0].firstChild.nextSibling);
                self.arrow = $(self.dropdownlistArrow[0].firstChild);
                self.dropdownlistContent = $(self.dropdownlistWrapper[0].firstChild);
                self.dropdownlistContent.addClass(self.toThemeProperty('jqx-dropdownlist-content jqx-disableselect'));
                if (self.rtl) {
                    self.dropdownlistContent.addClass(self.toThemeProperty('jqx-rtl jqx-dropdownlist-content-rtl'));
                }
                self.addHandler(self.dropdownlistWrapper, 'selectstart', function () { return false; });
                self.dropdownlistWrapper[0].id = "dropdownlistWrapper" + self.element.id;
                self.dropdownlistArrow[0].id = "dropdownlistArrow" + self.element.id;
                self.dropdownlistContent[0].id = "dropdownlistContent" + self.element.id;
                self._addInput();

                var label = $("<label></label");
                if (this.hint) {
                    label[0].innerHTML = this.placeHolder;
                }
                label.addClass(self.toThemeProperty('jqx-input-label'));
                self.dropdownlistWrapper.append(label);
                self.label = label;

                var bar = $("<span></span>");
                self.dropdownlistWrapper.append(bar);
                bar.addClass(self.toThemeProperty('jqx-input-bar'));
                self.bar = bar;
                self.bar.css('top', this.host.height());

                var that = this;

                if (that.template) {
                    that.bar.addClass(that.toThemeProperty("jqx-" + that.template));
                    that.label.addClass(that.toThemeProperty("jqx-" + that.template));
                }

                if (self.promptText != "Please Choose:") self.placeHolder = self.promptText;
                var hostClassName = self.toThemeProperty('jqx-widget') + " " + self.toThemeProperty('jqx-dropdownlist-state-normal') + " " + self.toThemeProperty('jqx-rc-all') + " " + self.toThemeProperty('jqx-fill-state-normal');
                self.element.className += " " + hostClassName;
                self._firstDiv = $(self.element.firstChild);

                try {
                    var listBoxID = 'listBox' + self.id;
                    var oldContainer = $($.find('#' + listBoxID));
                    if (oldContainer.length > 0) {
                        oldContainer.remove();
                    }
                    $.jqx.aria(self, "aria-owns", listBoxID);
                    $.jqx.aria(self, "aria-haspopup", true);

                    var container = $("<div style='overflow: hidden; background-color: transparent; border: none; position: absolute;' id='listBox" + self.id + "'><div id='innerListBox" + self.id + "'></div></div>");
                    container.hide();
                    container.addClass(self.toThemeProperty('jqx-listbox-container'));
                    if (self.dropDownContainer == "element") {
                        container.appendTo(self.host);
                    }
                    else {
                        container.appendTo(document.body);
                    }
                    self.container = container;
                    self.listBoxContainer = $($.find('#innerListBox' + self.id));

                    var width = self.width;
                    if (self.dropDownWidth != 'auto') {
                        width = self.dropDownWidth;
                    }
                    if (width == null) {
                        width = self.host.width();
                        if (width == 0) width = self.dropDownWidth;
                    }

                    if (self.dropDownHeight == null) {
                        self.dropDownHeight = 200;
                    }
                    var me = self;
                    self.container.width(parseInt(width) + 25);
                    self.container.height(parseInt(self.dropDownHeight) + 25);
                    self._ready = false;
                    self.addHandler(self.listBoxContainer, 'bindingComplete', function (event) {
                        if (!self.listBox) {
                            self.listBox = $.data(self.listBoxContainer[0], "jqxListBox").instance;
                        }
                        if (self.selectedIndex != self.listBoxContainer.jqxListBox('selectedIndex')) {
                            self.listBox = $.data(self.listBoxContainer[0], "jqxListBox").instance;
                            self.listBoxContainer.jqxListBox({ selectedIndex: self.selectedIndex });
                            self.renderSelection('mouse');
                        } else {
                            self.renderSelection('mouse');
                        }
                        if (!self._ready) {
                            if (self.ready) {
                                self.ready();
                            }
                            self._ready = true;
                        }
                        self._raiseEvent('6');
                    });
                    self.addHandler(self.listBoxContainer, 'itemAdd', function (event) {
                        self._raiseEvent('7', event.args);
                    });
                    self.addHandler(self.listBoxContainer, 'itemRemove', function (event) {
                        self._raiseEvent('8', event.args);
                    });
                    self.addHandler(self.listBoxContainer, 'itemUpdate', function (event) {
                        self._raiseEvent('9', event.args);
                    });

                    self.listBoxContainer.jqxListBox({
                        filterHeight: self.filterHeight,
                        filterPlaceHolder: self.filterPlaceHolder,
                        filterDelay: self.filterDelay,
                        autoItemsHeight: self.autoItemsHeight,
                        filterable: self.filterable, allowDrop: false, allowDrag: false,
                        autoBind: self.autoBind, _checkForHiddenParent: false, focusable: self.focusable,
                        touchMode: self.touchMode, checkboxes: self.checkboxes, rtl: self.rtl, _renderOnDemand: true, emptyString: self.emptyString, itemHeight: self.itemHeight, width: width, searchMode: self.searchMode, incrementalSearch: self.incrementalSearch, incrementalSearchDelay: self.incrementalSearchDelay, groupMember: self.groupMember, searchMember: self.searchMember, displayMember: self.displayMember, valueMember: self.valueMember, height: self.dropDownHeight, autoHeight: self.autoDropDownHeight, scrollBarSize: self.scrollBarSize, selectedIndex: self.selectedIndex, source: self.source, theme: self.theme,
                        rendered: function () {
                            if (self.selectedIndex != self.listBoxContainer.jqxListBox('selectedIndex')) {
                                self.listBox = $.data(self.listBoxContainer[0], "jqxListBox").instance;
                                self.listBoxContainer.jqxListBox({ selectedIndex: self.selectedIndex });
                                self.renderSelection('mouse');
                            } else {
                                self.renderSelection('mouse');
                            }
                        }, renderer: self.renderer,
                        filterChange: function (value) {
                            if (self.autoDropDownHeight) {
                                self.container.height(self.listBoxContainer.height() + 25);
                            }
                        }
                    });
                    if (self.dropDownContainer === "element") {
                        self.listBoxContainer.css({ position: 'absolute', top: 0, left: 0 });
                    }
                    else {
                        self.listBoxContainer.css({ position: 'absolute', zIndex: self.popupZIndex, top: 0, left: 0 });
                    }
                    if (self.template) {
                        self.listBoxContainer.addClass(self.toThemeProperty("jqx-" + self.template + "-item"));
                    }

                    self.listBox = $.data(self.listBoxContainer[0], "jqxListBox").instance;
                    self.listBox.enableSelection = self.enableSelection;
                    self.listBox.enableHover = self.enableHover;
                    self.listBox.equalItemsWidth = self.equalItemsWidth;
                    self.listBox.selectIndex(self.selectedIndex);
                    self.listBox._arrange();
                    self.listBoxContainer.addClass(self.toThemeProperty('jqx-popup'));
                    if ($.jqx.browser.msie) {
                        self.listBoxContainer.addClass(self.toThemeProperty('jqx-noshadow'));
                    }

                    self.addHandler(self.listBoxContainer, 'unselect', function (event) {
                        self._raiseEvent('3', { index: event.args.index, type: event.args.type, item: event.args.item });
                    });

                    self.addHandler(self.listBoxContainer, 'change', function (event) {
                        if (event.args) {
                            if (event.args.type != "keyboard") {
                                self._raiseEvent('4', { index: event.args.index, type: event.args.type, item: event.args.item });
                            }
                            else if (event.args.type == "keyboard") {
                                if (!self.isOpened()) {
                                    self._raiseEvent('4', { index: self.selectedIndex, type: 'keyboard', item: self.getItem(self.selectedIndex) });
                                }
                                else {
                                    if (event.args.item && event.args.oldItem && event.args.item.label !== event.args.oldItem.label) {
                                        self._raiseEvent('4', { index: self.selectedIndex, type: 'keyboard', item: self.getItem(self.selectedIndex) });
                                    }
                                }
                            }
                        }
                    });

                    if (self.animationType == 'none') {
                        self.container.css('display', 'none');
                    }
                    else {
                        self.container.hide();
                    }
                }
                catch (e) {
                    if (console)
                        console.log(e);
                }

                var self = self;
                self.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                    if (value) {
                        instance.host.addClass(self.toThemeProperty('jqx-dropdownlist-state-disabled'));
                        instance.host.addClass(self.toThemeProperty('jqx-fill-state-disabled'));
                        instance.dropdownlistContent.addClass(self.toThemeProperty('jqx-dropdownlist-content-disabled'));
                    }
                    else {
                        instance.host.removeClass(self.toThemeProperty('jqx-dropdownlist-state-disabled'));
                        instance.host.removeClass(self.toThemeProperty('jqx-fill-state-disabled'));
                        instance.dropdownlistContent.removeClass(self.toThemeProperty('jqx-dropdownlist-content-disabled'));
                    }
                    $.jqx.aria(instance, "aria-disabled", instance.disabled);
                }

                if (self.disabled) {
                    self.host.addClass(self.toThemeProperty('jqx-dropdownlist-state-disabled'));
                    self.host.addClass(self.toThemeProperty('jqx-fill-state-disabled'));
                    self.dropdownlistContent.addClass(self.toThemeProperty('jqx-dropdownlist-content-disabled'));
                }

                if (self.dropDownVerticalAlignment == "top") {
                    self.arrow.addClass(self.toThemeProperty('jqx-icon-arrow-up'));
                }
                else {
                    self.arrow.addClass(self.toThemeProperty('jqx-icon-arrow-down'));
                }
                self.arrow.addClass(self.toThemeProperty('jqx-icon'));

                if (self.renderMode === "simple") {
                    self.arrow.remove();
                    self.host.removeClass(self.toThemeProperty('jqx-fill-state-normal'));
                    self.host.removeClass(self.toThemeProperty('jqx-rc-all'));
                }
                if (self.template) {
                    self.host.addClass(self.toThemeProperty("jqx-" + self.template))
                }

                self._updateHandlers();
                self._setSize();
                self._arrange();
                if (self.listBox) {
                    self.renderSelection();
                }

                // fix for IE7
                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                    if (self.host.parents('.jqx-window').length > 0) {
                        var zIndex = self.host.parents('.jqx-window').css('z-index');
                        container.css('z-index', zIndex + 10);
                        self.listBoxContainer.css('z-index', zIndex + 10);
                    }
                }
            },

            resize: function (width, height) {
                this.width = width;
                this.height = height;
                this._setSize();
                this._arrange();
            },

            val: function (value) {
                if (!this.dropdownlistContent) return "";

                var isEmpty = function (obj) {
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key))
                            return false;
                    }

                    if (typeof value == "number")
                        return false;
                    if (typeof value == "date")
                        return false;
                    if (typeof value == "boolean")
                        return false;
                    if (typeof value == "string")
                        return false;

                    return true;
                }

                if (this.input && (isEmpty(value) || arguments.length == 0)) {
                    return this.input.val();
                }

                var item = this.getItemByValue(value);
                if (item != null) {
                    this.selectItem(item);
                }

                if (this.input) {
                    return this.input.val();
                }
            },

            focus: function () {
                try {
                    var me = this;
                    var doFocus = function () {
                        if (me.host) {
                            me.host.focus();
                            if (me._firstDiv) {
                                me._firstDiv.focus();
                            }
                        }
                    }
                    doFocus();
                    setTimeout(function () {
                        doFocus();
                    }, 10);
                }
                catch (error) {
                }
            },

            _addInput: function () {
                var name = this.host.attr('name');
                this.input = $("<input type='hidden'/>");
                this.host.append(this.input);
                if (name) {
                    this.input.attr('name', name);
                }
            },

            getItems: function () {
                if (!this.listBox) {
                    return new Array();
                }

                return this.listBox.items;
            },

            getVisibleItems: function () {
                return this.listBox.getVisibleItems();
            },


            _setSize: function () {
                var computedStyle = window.getComputedStyle(this.element);
                var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
                var boxSizing = computedStyle.boxSizing;

                if (this.element.offsetWidth === 0) {
                    borderSize = 2;
                }

                if (boxSizing === 'border-box' || isNaN(borderSize)) {
                    borderSize = 0;
                }

                if (this.width != null && this.width.toString().indexOf("px") != -1) {
                    this.element.style.width = parseInt(this.width) - borderSize + 'px';
                }
                else if (this.width != undefined && !isNaN(this.width)) {
                    this.element.style.width = parseInt(this.width) - borderSize + 'px';
                }

                if (this.height != null && this.height.toString().indexOf("px") != -1) {
                    this.element.style.height = parseInt(this.height) - borderSize + 'px';
                }
                else if (this.height != undefined && !isNaN(this.height)) {
                    this.element.style.height = parseInt(this.height) - borderSize + 'px';
                };

                var isPercentage = false;
                if (this.width != null && this.width.toString().indexOf("%") != -1) {
                    isPercentage = true;
                    this.element.style.width = this.width;

                    if (borderSize > 0) {
                        this.host.css('box-sizing', 'border-box');
                        this.listBoxContainer.css('box-sizing', 'border-box');
                    }
                }

                if (this.height != null && this.height.toString().indexOf("%") != -1) {
                    isPercentage = true;
                    this.element.style.height = this.height;
                }

                var me = this;
                var resizeFunc = function () {
                    me._arrange();
                    if (me.dropDownWidth == 'auto') {
                        var width = me.host.width() + 2;
                        me.listBoxContainer.jqxListBox({ width: width });
                        me.container.width(parseInt(width) + 25);
                    }
                }

                if (isPercentage) {
                    var width = this.host.width() + 2;
                    if (this.dropDownWidth != 'auto') {
                        width = this.dropDownWidth;
                    }
                    this.listBoxContainer.jqxListBox({ width: width });
                    this.container.width(parseInt(width) + 25);
                }
                $.jqx.utilities.resize(this.host, function () {
                    resizeFunc();
                }, false, this._checkForHiddenParent);
            },

            // returns true when the listbox is opened, otherwise returns false.
            isOpened: function () {
                var me = this;
                var openedListBox = $.data(document.body, "openedJQXListBox" + this.id);
                if (openedListBox != null && openedListBox == me.listBoxContainer) {
                    return true;
                }

                return false;
            },

            _updateHandlers: function () {
                var self = this;
                var hovered = false;
                this.removeHandlers();
                if (!this.touch) {
                    this.addHandler(this.host, 'mouseenter', function () {
                        if (!self.disabled && self.enableHover && self.renderMode !== 'simple') {
                            hovered = true;
                            self.host.addClass(self.toThemeProperty('jqx-dropdownlist-state-hover'));
                            if (self.dropDownVerticalAlignment == "top") {
                                self.arrow.addClass(self.toThemeProperty('jqx-icon-arrow-up-hover'));
                            }
                            else {
                                self.arrow.addClass(self.toThemeProperty('jqx-icon-arrow-down-hover'));
                            }
                            self.host.addClass(self.toThemeProperty('jqx-fill-state-hover'));
                        }
                    });

                    this.addHandler(this.host, 'mouseleave', function () {
                        if (!self.disabled && self.enableHover && self.renderMode !== 'simple') {
                            self.host.removeClass(self.toThemeProperty('jqx-dropdownlist-state-hover'));
                            self.host.removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                            self.arrow.removeClass(self.toThemeProperty('jqx-icon-arrow-down-hover'));
                            self.arrow.removeClass(self.toThemeProperty('jqx-icon-arrow-up-hover'));
                            hovered = false;
                        }
                    });
                }

                if (this.host.parents()) {
                    this.addHandler(this.host.parents(), 'scroll.dropdownlist' + this.element.id, function (event) {
                        var opened = self.isOpened();
                        if (opened) {
                            self.close();
                        }
                    });
                }

                var eventName = 'mousedown';
                if (this.touch) eventName = $.jqx.mobile.getTouchEventName('touchstart');
                this.addHandler(this.dropdownlistWrapper, eventName,
                    function (event) {
                        if (!self.disabled) {
                            var isOpen = self.container.css('display') == 'block';
                            if (!self.isanimating) {
                                if (isOpen) {
                                    self.hideListBox();
                                    return false;
                                }
                                else {
                                    self.showListBox();
                                    if (!self.focusable) {
                                        if (event.preventDefault) {
                                            event.preventDefault();
                                        }
                                    }
                                    else self.focus();

                                    //    event.stopPropagation();
                                }
                            }
                        }
                    });

                if (self.autoOpen) {
                    this.addHandler(this.host, 'mouseenter', function () {
                        var isOpened = self.isOpened();
                        if (!isOpened && self.autoOpen) {
                            self.open();
                            self.host.focus();
                        }
                    });

                    $(document).on('mousemove.' + self.id, function (event) {
                        var isOpened = self.isOpened();
                        if (isOpened && self.autoOpen) {
                            var offset = self.host.coord();
                            var top = offset.top;
                            var left = offset.left;
                            var popupOffset = self.container.coord();
                            var popupLeft = popupOffset.left;
                            var popupTop = popupOffset.top;

                            var canClose = true;

                            if (event.pageY >= top && event.pageY <= top + self.host.height()) {
                                if (event.pageX >= left && event.pageX < left + self.host.width())
                                    canClose = false;
                            }
                            if (event.pageY >= popupTop && event.pageY <= popupTop + self.container.height()) {
                                if (event.pageX >= popupLeft && event.pageX < popupLeft + self.container.width())
                                    canClose = false;
                            }

                            if (canClose) {
                                self.close();
                            }
                        }
                    });
                }

                if (this.touch) {
                    this.addHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.' + this.id, self.closeOpenedListBox, { me: this, listbox: this.listBox, id: this.id });
                }
                else this.addHandler($(document), 'mousedown.' + this.id, self.closeOpenedListBox, { me: this, listbox: this.listBox, id: this.id });

                this.addHandler(this.host, 'keydown', function (event) {
                    var isOpen = self.container.css('display') == 'block';

                    if (self.host.css('display') == 'none') {
                        return true;
                    }

                    if (event.keyCode == '13' || event.keyCode == '9') {
                        if (!self.isanimating) {
                            if (isOpen) {
                                self.renderSelection();
                                if (event.keyCode == '13' && self.focusable) {
                                    self._firstDiv.focus();
                                }
                                self.hideListBox();
                                if (!self.keyboardSelection) {
                                    self._raiseEvent('2', { index: self.selectedIndex, type: 'keyboard', item: self.getItem(self.selectedIndex) });
                                }
                                if (event.keyCode == "13") {
                                    self._raiseEvent('4', { index: self.selectedIndex, type: 'keyboard', item: self.getItem(self.selectedIndex) });
                                }
                            }
                            if (isOpen && event.keyCode != '9') {
                                return false;
                            }
                            return true;
                        }
                    }

                    if (event.keyCode == 115) {
                        if (!self.isanimating) {
                            if (!self.isOpened()) {
                                self.showListBox();
                            }
                            else if (self.isOpened()) {
                                self.hideListBox();
                            }
                        }
                        return false;
                    }

                    if (event.altKey) {
                        if (self.host.css('display') == 'block') {
                            if (event.keyCode == 38) {
                                if (self.isOpened()) {
                                    self.hideListBox();
                                    return true;
                                }
                            }
                            else if (event.keyCode == 40) {
                                if (!self.isOpened()) {
                                    self.showListBox();
                                    return true;
                                }
                            }
                        }
                    }

                    if (event.keyCode == '27') {
                        if (!self.ishiding) {
                            if (self.isOpened()) {
                                self.hideListBox();
                                if (self.tempSelectedIndex != undefined) {
                                    self.selectIndex(self.tempSelectedIndex);
                                }
                            }

                            return true;
                        }
                    }

                    if (!self.disabled) {
                        self._kbnavigated = self.listBox._handleKeyDown(event);
                        return self._kbnavigated;
                    }
                });
                this.addHandler(this.listBoxContainer, 'checkChange', function (event) {
                    self.renderSelection();
                    self._updateInputSelection();
                    self._raiseEvent(5, { label: event.args.label, value: event.args.value, checked: event.args.checked, item: event.args.item });
                });

                this.addHandler(this.listBoxContainer, 'select', function (event) {
                    if (!self.disabled) {
                        if (!event.args)
                            return;

                        if (event.args.type == 'keyboard' && !self.isOpened()) {
                            self.renderSelection();
                        }

                        if (event.args.type != 'keyboard' || self.keyboardSelection) {
                            self.renderSelection();
                            self._raiseEvent('2', { index: event.args.index, type: event.args.type, item: event.args.item, originalEvent: event.args.originalEvent });
                            if (event.args.type == 'mouse') {
                                if (!self.checkboxes) {
                                    self.hideListBox();
                                    if (self._firstDiv && self.focusable) {
                                        self._firstDiv.focus();
                                    }
                                }
                            }
                        }
                    }
                });
                if (this.listBox) {
                    if (this.listBox.content) {
                        this.addHandler(this.listBox.content, 'click', function (event) {
                            if (!self.disabled) {
                                if (self.listBox.itemswrapper && event.target === self.listBox.itemswrapper[0])
                                    return true;

                                self.renderSelection('mouse');
                                if (!self.touch) {
                                    if (!self.ishiding) {
                                        if (!self.checkboxes) {
                                            self.hideListBox();
                                            if (self._firstDiv && self.focusable) {
                                                self._firstDiv.focus();
                                            }
                                        }
                                    }
                                }

                                if (!self.keyboardSelection) {
                                    if (self._kbnavigated === false) {
                                        if (self.tempSelectedIndex != self.selectedIndex) {
                                            self._raiseEvent('4', { index: self.selectedIndex, type: "mouse", item: self.getItem(self.selectedIndex) });
                                        }
                                        self._kbnavigated = true;
                                    }

                                    if (self._oldSelectedInd == undefined) self._oldSelectedIndx = self.selectedIndex;

                                    if (self.selectedIndex != self._oldSelectedIndx) {
                                        self._raiseEvent('2', { index: self.selectedIndex, type: 'keyboard', item: self.getItem(self.selectedIndex) });
                                        self._oldSelectedIndx = self.selectedIndex;
                                    }
                                }
                            }
                        });
                    }
                }

                this.addHandler(this.host, 'focus', function (event) {
                    if (self.renderMode !== 'simple') {
                        self.host.addClass(self.toThemeProperty('jqx-dropdownlist-state-focus'));
                        self.host.addClass(self.toThemeProperty('jqx-fill-state-focus'));
                    }
                    self.bar.addClass('focused');
                    self.label.addClass('focused');
                });
                this.addHandler(this.host, 'blur', function () {
                    if (self.renderMode !== 'simple') {
                        self.host.removeClass(self.toThemeProperty('jqx-dropdownlist-state-focus'));
                        self.host.removeClass(self.toThemeProperty('jqx-fill-state-focus'));
                    }
                    self.bar.removeClass('focused');
                    self.label.removeClass('focused');
                });
                this.addHandler(this._firstDiv, 'focus', function (event) {
                    if (self.renderMode !== 'simple') {
                        self.host.addClass(self.toThemeProperty('jqx-dropdownlist-state-focus'));
                        self.host.addClass(self.toThemeProperty('jqx-fill-state-focus'));
                    }
                    self.bar.addClass('focused');
                    self.label.addClass('focused');
                });
                this.addHandler(this._firstDiv, 'blur', function () {
                    if (self.renderMode !== 'simple') {
                        self.host.removeClass(self.toThemeProperty('jqx-dropdownlist-state-focus'));
                        self.host.removeClass(self.toThemeProperty('jqx-fill-state-focus'));
                    }
                    self.bar.removeClass('focused');
                    self.label.removeClass('focused');
                });
            },

            removeHandlers: function () {
                var self = this;
                var eventName = 'mousedown';
                if (this.touch) eventName = $.jqx.mobile.getTouchEventName('touchstart');
                this.removeHandler(this.dropdownlistWrapper, eventName);
                if (this.listBox) {
                    if (this.listBox.content) {
                        this.removeHandler(this.listBox.content, 'click');
                    }
                }

                this.removeHandler(this.host, 'loadContent');
                this.removeHandler(this.listBoxContainer, 'checkChange');
                this.removeHandler(this.host, 'keydown');
                this.removeHandler(this.host, 'focus');
                this.removeHandler(this.host, 'blur');
                this.removeHandler(this._firstDiv, 'focus');
                this.removeHandler(this._firstDiv, 'blur');
                this.removeHandler(this.host, 'mouseenter');
                this.removeHandler(this.host, 'mouseleave');
                this.removeHandler($(document), 'mousemove.' + self.id);
            },

            // gets an item by index.
            getItem: function (index) {
                var item = this.listBox.getItem(index);
                return item;
            },

            getItemByValue: function (value) {
                var item = this.listBox.getItemByValue(value);
                return item;
            },

            selectItem: function (item) {
                if (this.listBox != undefined) {
                    this.listBox.selectItem(item);
                    this.selectedIndex = this.listBox.selectedIndex;
                    this.renderSelection('mouse');
                }
            },

            unselectItem: function (item) {
                if (this.listBox != undefined) {
                    this.listBox.unselectItem(item);
                    this.renderSelection('mouse');
                }
            },

            checkItem: function (item) {
                if (this.listBox != undefined) {
                    this.listBox.checkItem(item);
                }
            },

            uncheckItem: function (item) {
                if (this.listBox != undefined) {
                    this.listBox.uncheckItem(item);
                }
            },

            indeterminateItem: function (item) {
                if (this.listBox != undefined) {
                    this.listBox.indeterminateItem(item);
                }
            },


            // renders the selection.
            renderSelection: function () {
                if (this.listBox == null)
                    return;

                if (this.height && this.height.toString().indexOf('%') != -1) {
                    this._arrange();
                }

                var item = this.listBox.visibleItems[this.listBox.selectedIndex];
                if (this.filterable) {
                    if (this.listBox.selectedIndex == -1) {
                        for (var selectedValue in this.listBox.selectedValues) {
                            var value = this.listBox.selectedValues[selectedValue];
                            var selectedItem = this.listBox.getItemByValue(value);
                            if (selectedItem) {
                                item = selectedItem;
                            }
                        }
                    }
                }

                var me = this;
                if (this.checkboxes) {
                    var checkedItems = this.getCheckedItems();
                    if (checkedItems != null && checkedItems.length > 0) {
                        item = checkedItems[0];
                    }
                    else item = null;
                }

                if (this.hint) {
                    if (this.label) {
                        this.label[0].innerHTML = this.placeHolder;
                    }

                    if (item != null) {
                        this.element.setAttribute('hint', true);
                    }
                    else {
                        this.element.removeAttribute('hint');
                    }
                }

                this.bar.css('top', this.host.height());
                if (item == null) {
                    var spanElement = $('<span unselectable="on" style="color: inherit; border: none; background-color: transparent;"></span>');
                    spanElement.appendTo($(document.body));
                    spanElement.addClass(this.toThemeProperty('jqx-widget'));
                    spanElement.addClass(this.toThemeProperty('jqx-listitem-state-normal'));
                    spanElement.addClass(this.toThemeProperty('jqx-item'));

                    $.jqx.utilities.html(spanElement, this.placeHolder);
                    if (this.isMaterialized() && !this.element.getAttribute('default-placeholder') && this.hint) {
                        spanElement[0].innerHTML = "";

                        if (this.label) {
                            this.label[0].innerHTML = this.placeHolder;
                        }
                    }
                    var topPadding = this.dropdownlistContent.css('padding-top');
                    var bottomPadding = this.dropdownlistContent.css('padding-bottom');
                    spanElement.css('padding-top', topPadding);
                    spanElement.css('padding-bottom', bottomPadding);
                    var spanHeight = spanElement.outerHeight();
                    spanElement.remove();
                    spanElement.removeClass();
                    $.jqx.utilities.html(this.dropdownlistContent, spanElement);
                    var height = this.host.height();
                    if (this.height != null && this.height != undefined) {
                        if (this.height.toString().indexOf('%') === -1) {
                            height = parseInt(this.height);
                        }
                    }

                    var top = parseInt((parseInt(height) - parseInt(spanHeight)) / 2);

                    if (this.host.css('box-sizing') === 'border-box') {
                        top = parseInt((parseInt(height - 2) - parseInt(spanHeight)) / 2);
                    }

                    if (top > 0) {
                        this.dropdownlistContent.css('margin-top', top + 'px');
                        this.dropdownlistContent.css('margin-bottom', top + 'px');
                    }
                    if (this.selectionRenderer) {
                        $.jqx.utilities.html(this.dropdownlistContent, this.selectionRenderer(spanElement, -1, "", ""));
                        this.dropdownlistContent.css('margin-top', '0px');
                        this.dropdownlistContent.css('margin-bottom', '0px');
                        this._updateInputSelection();
                    }
                    else this._updateInputSelection();
                    this.selectedIndex = this.listBox.selectedIndex;
                    if (this.width === "auto") {
                        this._arrange();
                    }
                    if (this.focusable && this.isOpened()) {
                        this.focus();
                    }
                    return;
                }

                this.selectedIndex = this.listBox.selectedIndex;
                var spanElement = $(document.createElement('span'));
                spanElement[0].setAttribute('unselectable', 'on');
                try {
                    spanElement[0].style.color = "inherit";
                }
                catch (er) {
                }

                spanElement[0].style.borderWidth = '0px';
                spanElement[0].style.backgroundColor = "transparent";
                spanElement.appendTo($(document.body));
                spanElement.addClass(this.toThemeProperty('jqx-widget jqx-listitem-state-normal jqx-item'));

                var emptyItem = false;
                try {
                    if (item.html != undefined && item.html != null && item.html.toString().length > 0) {
                        $.jqx.utilities.html(spanElement, item.html);
                    }
                    else if (item.label != undefined && item.label != null && item.label.toString().length > 0) {
                        $.jqx.utilities.html(spanElement, item.label);
                    }
                    else if (item.label === null || item.label === "") {
                        emptyItem = true;
                        $.jqx.utilities.html(spanElement, "");
                    }
                    else if (item.value != undefined && item.value != null && item.value.toString().length > 0) {
                        $.jqx.utilities.html(spanElement, item.value);

                    }
                    else if (item.title != undefined && item.title != null && item.title.toString().length > 0) {
                        $.jqx.utilities.html(spanElement, item.title);
                    }
                    else if (item.label == "" || item.label == null) {
                        emptyItem = true;
                        $.jqx.utilities.html(spanElement, "");
                    }
                }
                catch (error) {
                    var errorMessage = error;
                }

                var topPadding = this.dropdownlistContent[0].style.paddingTop;
                var bottomPadding = this.dropdownlistContent[0].style.paddingBottom;
                if (topPadding === "") topPadding = "0px";
                if (bottomPadding === "") bottomPadding = "0px";

                spanElement[0].style.paddingTop = topPadding;
                spanElement[0].style.paddingBottom = bottomPadding;

                var spanHeight = spanElement.outerHeight();
                if (spanHeight === 0) {
                    spanHeight = 16;
                }

                if ((item.label == "" || item.label == null) && emptyItem) {
                    $.jqx.utilities.html(spanElement, "");
                }
                var notPercentageWidth = this.width && this.width.toString().indexOf('%') <= 0;

                spanElement.remove();
                spanElement.removeClass();
                if (this.selectionRenderer) {
                    $.jqx.utilities.html(this.dropdownlistContent, this.selectionRenderer(spanElement, item.index, item.label, item.value));
                    if (this.focusable && this.isOpened()) {
                        this.focus();
                    }
                }
                else {
                    if (this.checkboxes) {
                        var items = this.getCheckedItems();
                        var str = "";
                        for (var i = 0; i < items.length; i++) {
                            if (i == items.length - 1) {
                                str += items[i].label;
                            }
                            else {
                                str += items[i].label + ",";
                            }
                        }
                        spanElement.text(str);
                        if (notPercentageWidth) {
                            spanElement.css('max-width', this.host.width() - 30);
                        }
                        spanElement.css('overflow', 'hidden');
                        spanElement.css('display', 'block');
                        if (!this.rtl) {
                            if (notPercentageWidth) {
                                spanElement.css('width', this.host.width() - 30);
                            }
                        }
                        spanElement.css('text-overflow', 'ellipsis');
                        spanElement.css('padding-bottom', 1 + parseInt(bottomPadding));

                        this.dropdownlistContent.html(spanElement);
                        if (this.focusable && this.isOpened()) {
                            this.focus();
                        }
                    }
                    else {
                        var w = this.host.width() - this.arrowSize - 1;
                        if (this.width && this.width !== 'auto') {
                            if (notPercentageWidth) {
                                if (!this.rtl) {
                                    spanElement.css('max-width', w + "px");
                                }
                            }

                            spanElement[0].style.overflow = "hidden";
                            spanElement[0].style.display = "block";
                            spanElement[0].style.paddingTop = (1 + parseInt(bottomPadding)) + "px";
                            if (!this.rtl) {
                                if (notPercentageWidth) {
                                    if (w < 0) w = 0;
                                    spanElement[0].style.width = w + "px";
                                }
                            }
                            spanElement[0].style.textOverflow = 'ellipsis';
                        }

                        this.dropdownlistContent[0].innerHTML = spanElement[0].innerHTML;
                        if (this.focusable && this.isOpened()) {
                            this.focus();
                        }
                    }
                }

                var height = this.host.height();
                if (this.height != null && this.height != undefined) {
                    if (this.height.toString().indexOf('%') === -1) {
                        height = parseInt(this.height);
                    }
                }

                var top = parseInt((parseInt(height) - parseInt(spanHeight)) / 2);

                if (this.host.css('box-sizing') === 'border-box') {
                    top = parseInt((parseInt(height - 2) - parseInt(spanHeight)) / 2);
                }

                if (top >= 0) {
                    this.dropdownlistContent[0].style.marginTop = top + 'px';
                    this.dropdownlistContent[0].style.marginBottom = top + 'px';
                }
                if (this.selectionRenderer) {
                    this.dropdownlistContent[0].style.marginTop = '0px';
                    this.dropdownlistContent[0].style.marginBottom = '0px';
                }
                if (this.dropdownlistContent && this.input) {
                    this._updateInputSelection();
                }
                if (this.listBox && this.listBox._activeElement) {
                    $.jqx.aria(this, "aria-activedescendant", this.listBox._activeElement.id);
                }
                if (this.width === "auto") {
                    this._arrange();
                }
            },

            _updateInputSelection: function () {
                if (this.input) {
                    var selectedValues = new Array();
                    if (this.selectedIndex == -1) {
                        this.input.val("");
                    }
                    else {
                        var selectedItem = this.getSelectedItem();
                        if (selectedItem != null) {
                            this.input.val(selectedItem.value);
                            selectedValues.push(selectedItem.value);
                        }
                        else {
                            this.input.val(this.dropdownlistContent.text());
                        }
                    }
                    if (this.checkboxes) {
                        var items = this.getCheckedItems();
                        var str = "";
                        if (items != null) {
                            for (var i = 0; i < items.length; i++) {
                                var value = items[i].value;
                                if (value == undefined) continue;
                                if (i == items.length - 1) {
                                    str += value;
                                }
                                else {
                                    str += value + ",";
                                }
                                selectedValues.push(value);
                            }
                        }
                        this.input.val(str);
                    }
                }
                if (this.field && this.input) {
                    if (this.field.nodeName.toLowerCase() == "select") {
                        $.each(this.field, function (index, value) {
                            $(this).removeAttr('selected');
                            this.selected = selectedValues.indexOf(this.value) >= 0;
                            if (this.selected) {
                                $(this).attr('selected', true);
                            }
                        });
                    }
                    else {
                        $.each(this.items, function (index, value) {
                            $(this.originalItem.originalItem).removeAttr('data-selected');
                            this.selected = selectedValues.indexOf(this.value) >= 0;
                            if (this.selected) {
                                $(this.originalItem.originalItem).attr('data-selected', true);
                            }
                        });
                    }
                }
            },

            setContent: function (content) {
                $.jqx.utilities.html(this.dropdownlistContent, content);
                this._updateInputSelection();
            },

            dataBind: function () {
                this.listBoxContainer.jqxListBox({ source: this.source });
                this.renderSelection('mouse');
                if (this.source == null) {
                    this.clearSelection();
                }
            },

            clear: function () {
                this.listBoxContainer.jqxListBox({ source: null });
                this.clearSelection();
            },

            // clears the selection.
            clearSelection: function (render) {
                this.selectedIndex = -1;
                this._updateInputSelection();
                this.listBox.clearSelection();
                this.renderSelection();
                if (!this.selectionRenderer && !this.hint && !this.isMaterialized()) {
                    $.jqx.utilities.html(this.dropdownlistContent, this.placeHolder);
                }
            },

            // unselects an item at specific index.
            // @param Number
            unselectIndex: function (index, render) {
                if (isNaN(index))
                    return;

                this.listBox.unselectIndex(index, render);
                this.renderSelection();
            },

            // selects an item at specific index.
            // @param Number
            selectIndex: function (index, ensureVisible, render, forceSelect) {
                this.listBox.selectIndex(index, ensureVisible, render, forceSelect, 'api');
            },

            // gets the selected index.
            getSelectedIndex: function () {
                return this.selectedIndex;
            },

            // gets the selected item.
            getSelectedItem: function () {
                return this.listBox.getVisibleItem(this.selectedIndex);
            },

            getCheckedItems: function () {
                return this.listBox.getCheckedItems();
            },

            checkIndex: function (index) {
                this.listBox.checkIndex(index);
            },

            uncheckIndex: function (index) {
                this.listBox.uncheckIndex(index);
            },

            indeterminateIndex: function (index) {
                this.listBox.indeterminateIndex(index);
            },
            checkAll: function () {
                this.listBox.checkAll();
                this.renderSelection('mouse');
            },

            uncheckAll: function () {
                this.listBox.uncheckAll();
                this.renderSelection('mouse');
            },

            addItem: function (item) {
                return this.listBox.addItem(item);
            },

            insertAt: function (item, index) {
                if (item == null)
                    return false;

                return this.listBox.insertAt(item, index);
            },

            removeAt: function (index) {
                var result = this.listBox.removeAt(index);
                this.renderSelection('mouse');
                return result;
            },

            removeItem: function (item) {
                var result = this.listBox.removeItem(item);
                this.renderSelection('mouse');
                return result;
            },

            updateItem: function (item, oldItem) {
                var result = this.listBox.updateItem(item, oldItem);
                this.renderSelection('mouse');
                return result;
            },

            updateAt: function (item, index) {
                var result = this.listBox.updateAt(item, index);
                this.renderSelection('mouse');
                return result;
            },

            ensureVisible: function (index) {
                return this.listBox.ensureVisible(index);
            },

            disableAt: function (index) {
                return this.listBox.disableAt(index);
            },

            enableAt: function (index) {
                return this.listBox.enableAt(index);
            },

            disableItem: function (item) {
                return this.listBox.disableItem(item);
            },

            enableItem: function (item) {
                return this.listBox.enableItem(item);
            },

            _findPos: function (obj) {
                while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
                    obj = obj['nextSibling'];
                }
                var position = $(obj).coord(true);
                return [position.left, position.top];
            },

            testOffset: function (element, offset, inputHeight) {
                var dpWidth = element.outerWidth();
                var dpHeight = element.outerHeight();
                var viewWidth = $(window).width() + $(window).scrollLeft();
                var viewHeight = $(window).height() + $(window).scrollTop();

                if (offset.left + dpWidth > viewWidth) {
                    if (dpWidth > this.host.width()) {
                        var hostLeft = this.host.coord().left;
                        var hOffset = dpWidth - this.host.width();
                        offset.left = hostLeft - hOffset + 2;
                    }
                }
                if (offset.left < 0) {
                    offset.left = parseInt(this.host.coord().left) + 'px'
                }

                offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                    Math.abs(dpHeight + inputHeight + 22) : 0);

                return offset;
            },

            open: function () {
                this.showListBox();
            },

            close: function () {
                this.hideListBox();
            },

            _getBodyOffset: function () {
                var top = 0;
                var left = 0;
                if ($('body').css('border-top-width') != '0px') {
                    top = parseInt($('body').css('border-top-width'));
                    if (isNaN(top)) top = 0;
                }
                if ($('body').css('border-left-width') != '0px') {
                    left = parseInt($('body').css('border-left-width'));
                    if (isNaN(left)) left = 0;
                }
                return { left: left, top: top };
            },

            // shows the listbox.
            showListBox: function () {
                $.jqx.aria(this, "aria-expanded", true);
                if (this.listBox._renderOnDemand) {
                    this.listBoxContainer.jqxListBox({ _renderOnDemand: false });
                }

                if (this.dropDownWidth == 'auto' && this.width != null && this.width.indexOf && (this.width.indexOf('%') != -1 || this.width.indexOf('auto') != -1)) {
                    if (this.listBox.host.width() != this.host.width()) {
                        var width = this.element.offsetWidth;
                        this.listBoxContainer.jqxListBox({ width: width });
                        this.container.width(parseInt(width) + 25);
                    }
                }
                if (this.dropDownWidth == 'auto' && this.host.css('border-left-width') === "0px") {
                    var width = this.element.offsetWidth;
                    this.listBoxContainer.jqxListBox({ width: width + 1 });
                    this.container.width(parseInt(width) + 25);
                }

                var self = this;
                var listBox = this.listBoxContainer;
                var listBoxInstance = this.listBox;
                var scrollPosition = $(window).scrollTop();
                var scrollLeftPosition = $(window).scrollLeft();
                var top = parseInt(this._findPos(this.host[0])[1]) + parseInt(this.host.outerHeight()) - 1 + 'px';
                //var left = parseInt(Math.round(this.host.coord(true).left)) + 'px';
                var left, leftPos = parseInt(Math.round(this.host.coord(true).left));
                left = leftPos + 'px';


                if (this.dropDownContainer === 'element') {
                    top = parseInt(this.host.outerHeight()) - 1 + 'px';
                    left = 0;
                }


                var isMobileBrowser = false;//$.jqx.mobile.isSafariMobileBrowser() || $.jqx.mobile.isWindowsPhone();

                if (this.listBox == null)
                    return;

                this.ishiding = false;
                if (!this.keyboardSelection) {
                    this.listBox.selectIndex(this.selectedIndex);
                    this.listBox.ensureVisible(this.selectedIndex);
                }

                this.tempSelectedIndex = this.selectedIndex;

                if (this.autoDropDownHeight) {
                    this.container.height(this.listBoxContainer.height() + 25);
                }

                if ((isMobileBrowser != null && isMobileBrowser)) {
                    left = $.jqx.mobile.getLeftPos(this.element);
                    top = $.jqx.mobile.getTopPos(this.element) + parseInt(this.host.outerHeight());
                    if ($('body').css('border-top-width') != '0px') {
                        top = parseInt(top) - this._getBodyOffset().top + 'px';
                    }
                    if ($('body').css('border-left-width') != '0px') {
                        left = parseInt(left) - this._getBodyOffset().left + 'px';
                    }
                }

                listBox.stop();
                if (this.renderMode !== 'simple') {
                    this.host.addClass(this.toThemeProperty('jqx-dropdownlist-state-selected'));
                    this.host.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                    if (this.dropDownVerticalAlignment == "top") {
                        this.arrow.addClass(this.toThemeProperty('jqx-icon-arrow-up-selected'));
                    }
                    else {
                        this.arrow.addClass(this.toThemeProperty('jqx-icon-arrow-down-selected'));
                    }
                }


                this.container.css('left', left);
                this.container.css('top', top);
                listBoxInstance._arrange();

                var closeAfterSelection = true;
                var positionChanged = false;

                if (this.dropDownHorizontalAlignment == 'right' || this.rtl) {
                    var containerWidth = this.container.outerWidth();
                    var containerLeftOffset = -2 + Math.abs(containerWidth - this.host.width());

                    if (containerWidth > this.host.width()) {
                        this.container.css('left', 25 + parseInt(Math.round(leftPos)) - containerLeftOffset + "px");
                    }
                    else this.container.css('left', 25 + parseInt(Math.round(leftPos)) + containerLeftOffset + "px");
                }

                if (this.dropDownVerticalAlignment == "top") {
                    var dpHeight = listBox.height();
                    positionChanged = true;

                    listBox.css('top', 23);
                    listBox.addClass(this.toThemeProperty('jqx-popup-up'));
                    var inputHeight = parseInt(this.host.outerHeight());
                    var t = parseInt(top) - Math.abs(dpHeight + inputHeight + 23);

                    this.container.css('top', t);
                }

                if (this.enableBrowserBoundsDetection) {
                    var newOffset = this.testOffset(listBox, { left: parseInt(this.container.css('left')), top: parseInt(top) }, parseInt(this.host.outerHeight()));
                    if (parseInt(this.container.css('top')) != newOffset.top) {
                        positionChanged = true;
                        listBox.css('top', 23);
                        listBox.addClass(this.toThemeProperty('jqx-popup-up'));
                    }
                    else listBox.css('top', 0);

                    this.container.css('top', newOffset.top);
                    if (parseInt(this.container.css('left')) != newOffset.left) {
                        this.container.css('left', newOffset.left);
                    }
                }

                if (this.animationType == 'none' || this.animationType === 'transform') {
                    this.container.css('display', 'block');
                    $.data(document.body, "openedJQXListBoxParent", self);
                    $.data(document.body, "openedJQXListBox" + this.id, listBox);
                    listBox.css('margin-top', 0);
                    listBox.css('opacity', 1);
                    listBoxInstance._renderItems();
                    self._raiseEvent('0', listBoxInstance);
                }
                else {
                    this.container.css('display', 'block');
                    self.isanimating = true;
                    if (this.animationType == 'fade') {
                        listBox.css('margin-top', 0);
                        listBox.css('opacity', 0);
                        listBox.animate({ 'opacity': 1 }, this.openDelay, function () {
                            $.data(document.body, "openedJQXListBoxParent", self);
                            $.data(document.body, "openedJQXListBox" + self.id, listBox);
                            self.ishiding = false;
                            self.isanimating = false;
                            listBoxInstance._renderItems();
                            self._raiseEvent('0', listBoxInstance);
                        });
                    }
                    else {
                        listBox.css('opacity', 1);
                        var height = listBox.outerHeight();
                        if (positionChanged) {
                            listBox.css('margin-top', height);
                        }
                        else {
                            listBox.css('margin-top', -height);
                        }

                        listBox.animate({ 'margin-top': 0 }, this.openDelay, function () {
                            $.data(document.body, "openedJQXListBoxParent", self);
                            $.data(document.body, "openedJQXListBox" + self.id, listBox);
                            self.ishiding = false;
                            self.isanimating = false;
                            listBoxInstance._renderItems();
                            self._raiseEvent('0', listBoxInstance);
                        });
                    }
                }
                if (!positionChanged) {
                    this.host.addClass(this.toThemeProperty('jqx-rc-b-expanded'));
                    listBox.addClass(this.toThemeProperty('jqx-rc-t-expanded'));
                }
                else {
                    this.host.addClass(this.toThemeProperty('jqx-rc-t-expanded'));
                    listBox.addClass(this.toThemeProperty('jqx-rc-b-expanded'));
                }
                if (this.renderMode !== 'simple') {
                    listBox.addClass(this.toThemeProperty('jqx-fill-state-focus'));
                    this.host.addClass(this.toThemeProperty('jqx-dropdownlist-state-focus'));
                    this.host.addClass(this.toThemeProperty('jqx-fill-state-focus'));
                }

                this.element.setAttribute('opened', true);
                listBox.addClass(this.toThemeProperty('jqx-popup-show'));
            },

            // hides the listbox.
            hideListBox: function () {
                $.jqx.aria(this, "aria-expanded", false);

                var listBox = this.listBoxContainer;
                var listBoxInstance = this.listBox;
                var container = this.container;
                var me = this;
                this.element.removeAttribute('opened');

                listBox.removeClass('jqx-popup-show');

                $.data(document.body, "openedJQXListBox" + this.id, null);
                if (this.animationType == 'none') {
                    this.container.css('display', 'none');
                }
                else if (this.animationType === 'transform') {
                    setTimeout(function () {
                        container.css('display', 'none');
                    }, this.closeDelay);
                }
                else {
                    if (!me.ishiding) {
                        listBox.stop();
                        var height = listBox.outerHeight();
                        listBox.css('margin-top', 0);
                        me.isanimating = true;

                        var animationValue = -height;
                        if (parseInt(this.container.coord().top) < parseInt(this.host.coord().top)) {
                            animationValue = height;
                        }

                        if (this.animationType == 'fade') {
                            listBox.css({ 'opacity': 1 });
                            listBox.animate({ 'opacity': 0 }, this.closeDelay, function () {
                                container.css('display', 'none');
                                me.isanimating = false;
                                me.ishiding = false;
                            });
                        }
                        else {
                            listBox.animate({ 'margin-top': animationValue }, this.closeDelay, function () {
                                container.css('display', 'none');
                                me.isanimating = false;
                                me.ishiding = false;
                            });
                        }
                    }
                }

                this.ishiding = true;
                this.host.removeClass(this.toThemeProperty('jqx-dropdownlist-state-selected'));
                this.host.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this.arrow.removeClass(this.toThemeProperty('jqx-icon-arrow-down-selected'));
                this.arrow.removeClass(this.toThemeProperty('jqx-icon-arrow-up-selected'));
                this.host.removeClass(this.toThemeProperty('jqx-rc-b-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-rc-t-expanded'));
                this.host.removeClass(this.toThemeProperty('jqx-rc-t-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-rc-b-expanded'));
                listBox.removeClass(this.toThemeProperty('jqx-fill-state-focus'));
                this.host.removeClass(this.toThemeProperty('jqx-dropdownlist-state-focus'));
                this.host.removeClass(this.toThemeProperty('jqx-fill-state-focus'));

                this._raiseEvent('1', listBoxInstance);
            },

            /* Close popup if clicked elsewhere. */
            closeOpenedListBox: function (event) {
                var self = event.data.me;
                var $target = $(event.target);
                var openedListBox = event.data.listbox;
                if (openedListBox == null)
                    return true;

                if ($(event.target).ischildof(event.data.me.host)) {
                    return true;
                }

                if (!self.isOpened()) {
                    return true;
                }

                if ($(event.target).ischildof(self.listBoxContainer)) {
                    return true;
                }

                var dropdownlistInstance = self;

                var isListBox = false;
                $.each($target.parents(), function () {
                    if (this.className != 'undefined') {
                        if (this.className.indexOf) {
                            if (this.className.indexOf('jqx-listbox') != -1) {
                                isListBox = true;
                                return false;
                            }
                            if (this.className.indexOf('jqx-dropdownlist') != -1) {
                                if (self.element.id == this.id) {
                                    isListBox = true;
                                }
                                return false;
                            }
                        }
                    }
                });

                if (openedListBox != null && !isListBox && self.isOpened()) {
                    self.hideListBox();
                }

                return true;
            },

            clearFilter: function () {
                this.listBox.clearFilter();
            },

            loadFromSelect: function (id) {
                this.listBox.loadFromSelect(id);
            },

            refresh: function (initialRefresh) {
                if (initialRefresh !== true) {
                    this._setSize();
                    this._arrange();
                    if (this.listBox) {
                        this.renderSelection();
                    }
                }
            },

            _arrange: function () {
                var that = this;
                var width = parseInt(that.host.width());
                var height = parseInt(that.host.height());
                var arrowHeight = that.arrowSize;
                var arrowWidth = that.arrowSize;
                var rightOffset = 3;
                var contentWidth = width - arrowWidth - 2 * rightOffset;
                if (contentWidth > 0 && that.width !== "auto") {
                    that.dropdownlistContent[0].style.width = contentWidth + "px";
                }
                else if (contentWidth <= 0) {
                    that.dropdownlistContent[0].style.width = "0px";
                }

                if (that.width === "auto") {
                    that.dropdownlistContent.css('width', 'auto');
                    width = 2 + that.dropdownlistContent.width() + arrowWidth + 2 * rightOffset;
                    if (width < 47) {
                        width = 47;
                    }
                    that.host.width(width);
                }
                that.dropdownlistContent[0].style.height = height + "px";
                that.dropdownlistContent[0].style.left = "0px";
                that.dropdownlistContent[0].style.top = "0px";

                that.dropdownlistArrow[0].style.width = arrowWidth + "px";
                if (that.width && that.width.toString().indexOf('%') >= 0) {
                    var arrowPercentage = (arrowWidth * 100) / width;
                    var contentPercentage = (contentWidth * 100) / width;
                    that.dropdownlistArrow[0].style.width = arrowPercentage + '%';
                    that.dropdownlistContent[0].style.width = contentPercentage + '%';
                }
                that.dropdownlistArrow[0].style.height = height + "px";

                if (that.rtl) {
                    that.dropdownlistArrow.css('float', 'left');
                    that.dropdownlistContent.css('float', 'right');
                }
            },

            destroy: function () {
                $.jqx.utilities.resize(this.host, null, true);
                this.removeHandler(this.listBoxContainer, 'select');
                this.removeHandler(this.listBoxContainer, 'unselect');
                this.removeHandler(this.listBoxContainer, 'change');
                this.removeHandler(this.dropdownlistWrapper, 'selectstart');
                this.removeHandler(this.dropdownlistWrapper, 'mousedown');
                this.removeHandler(this.host, 'keydown');
                this.removeHandler(this.listBoxContainer, 'select');
                this.removeHandler(this.listBox.content, 'click');
                this.removeHandler(this.listBoxContainer, 'bindingComplete');

                if (this.host.parents()) {
                    this.removeHandler(this.host.parents(), 'scroll.dropdownlist' + this.element.id);
                }

                this.removeHandlers();

                this.listBoxContainer.jqxListBox('destroy');
                this.listBoxContainer.remove();
                this.host.removeClass();
                this.removeHandler($(document), 'mousedown.' + this.id, this.closeOpenedListBox);
                if (this.touch) {
                    this.removeHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.' + this.id);
                }

                this.dropdownlistArrow.remove();
                delete this.dropdownlistArrow;
                delete this.dropdownlistWrapper;
                delete this.listBoxContainer;
                delete this.input;
                delete this.arrow;
                delete this.dropdownlistContent;
                delete this.listBox;
                delete this._firstDiv;
                this.container.remove();
                delete this.container;
                var vars = $.data(this.element, "jqxDropDownList");
                if (vars) {
                    delete vars.instance;
                }
                this.host.removeData();
                this.host.remove();
                delete this.comboStructure;
                delete this.host;
                delete this.element;
            },

            _raiseEvent: function (id, arg) {
                if (arg == undefined)
                    arg = { owner: null };

                var evt = this.events[id];
                var args = arg;
                args.owner = this;

                var event = new $.Event(evt);
                event.owner = this;
                if (id == 2 || id == 3 || id == 4 || id == 5 || id == 6 || id == 7 || id == 8 || id == 9) {
                    event.args = arg;
                }

                var result = this.host.trigger(event);
                return result;
            },


            propertiesChangedHandler: function (object, key, value) {
                if (value.width && value.height && Object.keys(value).length == 2) {
                    object._setSize();
                    if (key == 'width') {
                        if (object.dropDownWidth == 'auto') {
                            var width = object.host.width();
                            object.listBoxContainer.jqxListBox({ width: width });
                            object.container.width(parseInt(width) + 25);
                        }
                    }
                    object._arrange();
                    object.close();
                }
            },

            propertyChangedHandler: function (object, key, oldvalue, value) {
                if (object.isInitialized == undefined || object.isInitialized == false)
                    return;

                if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                    return;
                }

                if (key == "template") {
                    object.listBoxContainer.removeClass(object.toThemeProperty("jqx-" + oldvalue + "-item"));
                    object.listBoxContainer.addClass(object.toThemeProperty("jqx-" + object.template + "-item"));
                    object.host.removeClass(object.toThemeProperty("jqx-" + oldvalue + ""));
                    object.host.addClass(object.toThemeProperty("jqx-" + object.template + ""));
                }

                if (key == "dropDownVerticalAlignment") {
                    object.close();
                    object.arrow.removeClass(object.toThemeProperty('jqx-icon-arrow-up'));
                    object.arrow.removeClass(object.toThemeProperty('jqx-icon-arrow-down'));
                    if (object.dropDownVerticalAlignment == "top") {
                        object.arrow.addClass(object.toThemeProperty('jqx-icon-arrow-up'));
                    }
                    else {
                        object.arrow.addClass(object.toThemeProperty('jqx-icon-arrow-down'));
                    }
                    object.listBoxContainer.css('top', 0);
                    object.listBoxContainer.removeClass(this.toThemeProperty('jqx-popup-up'));
                }

                if (key == "autoItemsHeight") {
                    object.listBoxContainer.jqxListBox({ autoItemsHeight: value });
                }

                if (key == "filterable") {
                    object.listBoxContainer.jqxListBox({ filterable: value });
                }
                if (key == "filterHeight") {
                    object.listBoxContainer.jqxListBox({ filterHeight: value });
                }
                if (key == "filterPlaceHolder") {
                    object.listBoxContainer.jqxListBox({ filterPlaceHolder: value });
                }
                if (key == "filterDelay") {
                    object.listBoxContainer.jqxListBox({ filterDelay: value });
                }

                if (key == "enableSelection") {
                    object.listBoxContainer.jqxListBox({ enableSelection: value });
                }
                if (key == "enableHover") {
                    object.listBoxContainer.jqxListBox({ enableHover: value });
                }

                if (key == 'autoOpen') {
                    object._updateHandlers();
                }
                if (key == 'emptyString') {
                    object.listBox.emptyString = object.emptyString;
                }
                if (key == "itemHeight") {
                    object.listBoxContainer.jqxListBox({ itemHeight: value });
                }

                if (key == "renderer") {
                    object.listBoxContainer.jqxListBox({ renderer: value });
                }

                if (key == "rtl") {
                    if (value) {
                        object.dropdownlistArrow.css('float', 'left');
                        object.dropdownlistContent.css('float', 'right');
                    }
                    else {
                        object.dropdownlistArrow.css('float', 'right');
                        object.dropdownlistContent.css('float', 'left');
                    }
                    object.listBoxContainer.jqxListBox({ rtl: object.rtl });
                }
                if (key == 'source') {
                    object.listBoxContainer.jqxListBox({ source: object.source });
                    object.listBox.selectedIndex = -1;
                    object.listBox.selectIndex(this.selectedIndex);
                    object.renderSelection();
                    if (value == null) {
                        object.clear();
                    }
                }

                if (key == "displayMember" || key == "valueMember") {
                    object.listBoxContainer.jqxListBox({ displayMember: object.displayMember, valueMember: object.valueMember });
                    object.renderSelection();
                }
                if (key == "placeHolder") {
                    object.renderSelection();
                }

                if (key == 'theme' && value != null) {
                    object.listBoxContainer.jqxListBox({ theme: value });
                    object.listBoxContainer.addClass(object.toThemeProperty('jqx-popup'));
                    $.jqx.utilities.setTheme(oldvalue, value, object.host);
                }

                if (key == "autoDropDownHeight") {
                    object.listBoxContainer.jqxListBox({ autoHeight: object.autoDropDownHeight });
                    if (object.autoDropDownHeight) {
                        object.container.height(object.listBoxContainer.height() + 25);
                    }
                    else {
                        object.listBoxContainer.jqxListBox({ height: object.dropDownHeight });
                        object.container.height(parseInt(object.dropDownHeight) + 25);
                    }

                    object.listBox._arrange();
                    object.listBox._updatescrollbars();
                }

                if (key == "searchMode") {
                    object.listBoxContainer.jqxListBox({ searchMode: object.searchMode });
                }

                if (key == "incrementalSearch") {
                    object.listBoxContainer.jqxListBox({ incrementalSearch: object.incrementalSearch });
                }

                if (key == "incrementalSearchDelay") {
                    object.listBoxContainer.jqxListBox({ incrementalSearchDelay: object.incrementalSearchDelay });
                }

                if (key == "dropDownHeight") {
                    if (!object.autoDropDownHeight) {
                        object.listBoxContainer.jqxListBox({ height: object.dropDownHeight });
                        object.container.height(parseInt(object.dropDownHeight) + 25);
                    }
                }

                if (key == "dropDownWidth" || key == "scrollBarSize") {
                    var width = object.width;
                    if (object.dropDownWidth != 'auto') {
                        width = object.dropDownWidth;
                    }

                    object.listBoxContainer.jqxListBox({ width: width, scrollBarSize: object.scrollBarSize });
                    object.container.width(parseInt(width) + 25);
                }

                if (key == 'width' || key == 'height') {
                    if (value != oldvalue) {
                        this.refresh();
                        if (key == 'width') {
                            if (object.dropDownWidth == 'auto') {
                                var width = 2 + object.host.width();
                                object.listBoxContainer.jqxListBox({ width: width });
                                object.container.width(parseInt(width) + 25);
                            }
                        }
                        object.close();
                    }
                }

                if (key == "checkboxes") {
                    object.listBoxContainer.jqxListBox({ checkboxes: object.checkboxes });
                }

                if (key == 'selectedIndex') {
                    if (object.listBox != null) {
                        object.listBox.selectIndex(parseInt(value));
                        object.renderSelection();
                    }
                }
            }
        });
    })(jqxBaseFramework);
})();



/***/ }),

/***/ 714:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {
        window.jqxToDash = function (value) {
            return value.split(/(?=[A-Z])/).join('-').toLowerCase();
        }

        var LINE_SEPARATOR2 = "\r\n";
        function returnAttributeIfPopulated(key, value, booleanTransformer) {
            if (!value && value !== "" && value !== 0) {
                return "";
            }
            let xmlValue = value;
            if (typeof value === "boolean") {
                if (booleanTransformer) {
                    xmlValue = booleanTransformer(value);
                }
            }
            return ` ${key}="${xmlValue}"`;
        }

        var XmlFactory = class {
            static createHeader(headerElement = {}) {
                const headerStart = "<?";
                const headerEnd = "?>";
                const keys = ["version"];
                if (!headerElement.version) {
                    headerElement.version = "1.0";
                }
                if (headerElement.encoding) {
                    keys.push("encoding");
                }
                if (headerElement.standalone) {
                    keys.push("standalone");
                }
                const att = keys.map((key) => `${key}="${headerElement[key]}"`).join(" ");
                return `${headerStart}xml ${att} ${headerEnd}`;
            }
            static createXml(xmlElement, booleanTransformer) {
                let props = "";
                if (xmlElement.properties) {
                    if (xmlElement.properties.prefixedAttributes) {
                        xmlElement.properties.prefixedAttributes.forEach((prefixedSet) => {
                            Object.keys(prefixedSet.map).forEach((key) => {
                                props += returnAttributeIfPopulated(
                                    prefixedSet.prefix + key,
                                    prefixedSet.map[key],
                                    booleanTransformer
                                );
                            });
                        });
                    }
                    if (xmlElement.properties.rawMap) {
                        Object.keys(xmlElement.properties.rawMap).forEach((key) => {
                            props += returnAttributeIfPopulated(key, xmlElement.properties.rawMap[key], booleanTransformer);
                        });
                    }
                }
                let result = "<" + xmlElement.name + props;
                if (!xmlElement.children && xmlElement.textNode == null) {
                    return result + "/>" + LINE_SEPARATOR2;
                }
                if (xmlElement.textNode != null) {
                    return result + ">" + xmlElement.textNode + "</" + xmlElement.name + ">" + LINE_SEPARATOR2;
                }
                result += ">" + LINE_SEPARATOR2;
                if (xmlElement.children) {
                    xmlElement.children.forEach((it) => {
                        result += this.createXml(it, booleanTransformer);
                    });
                }
                return result + "</" + xmlElement.name + ">" + LINE_SEPARATOR2;
            }
        };

        class DataExporter {
            constructor(exportDetails, groupBy, filterBy, conditionalFormatting) {
                const that = this;

                if (!exportDetails) {
                    exportDetails = {};
                }

                /*
                 * "style" object definition (all properties are optional):
                 *
                 * any valid CSS property - applied to whole table
                 * header (Object)
                 *      any valid CSS property - applied to header cells
                 *      any column name (Object)
                 *          any valid CSS property - applied to particular column header cell
                 * columns (Object)
                 *      any valid CSS property - applied to column cells
                 *      any column name (Object)
                 *          any valid CSS property - applied to the cells of particular column
                 *          format - applicable to numeric and date columns
                 *          n (Object), where n is a row index (related to use of "ConditionalFormatting" object)
                 *              background
                 *              border
                 *              color
                 * rows (Object)
                 *      any valid CSS property - applied to rows
                 *      alternationCount
                 *      alternationStart
                 *      alternationEnd
                 *      alternationIndexnColor, where n is an integer
                 *      alternationIndexnBorderColor, where n is an integer
                 *      alternationIndexnBackgroundColor, where n is an integer
                 *      n (Object), where n is a row index
                 *          any valid CSS property - applied to particular row
                 */
                that.style = exportDetails.style;

                that.header = exportDetails.header;
                that.exportHeader = exportDetails.exportHeader !== undefined ? exportDetails.exportHeader : true;
                that.hierarchical = exportDetails.hierarchical;
                that.expandChar = exportDetails.expandChar || '+';
                that.collapseChar = exportDetails.collapseChar || '-';
                that.pageOrientation = exportDetails.pageOrientation;
                that.allowNull = exportDetails.allowNull || false;
                that.spreadsheets = exportDetails.spreadsheets || null;

                that._media = [];

                if (!that.hierarchical && groupBy && groupBy.length > 0) {
                    that.groupBy = groupBy;
                }
                else {
                    that.mergedCells = exportDetails.mergedCells;
                }

                if (!that.groupBy && filterBy && Object.keys(filterBy).length > 0) {
                    that.filterBy = filterBy;
                }

                if (conditionalFormatting) {
                    that.conditionalFormatting = conditionalFormatting;
                }

                that.timeBetween1900And1970 = new Date(1970, 0, 1, 0, 0, 0).getTime() - new Date(1900, 0, 1, 0, 0, 0).getTime();
            }

            /**
             * Generates and downloads a file.
             */
            downloadFile(data, type, fileName) {
                let file;

                if (!fileName) {
                    return data;
                }

                if (data instanceof Blob) {
                    file = data;
                }
                else {
                    file = new Blob([data], { type: type });
                }

                if (window.navigator.msSaveOrOpenBlob) { // Edge
                    window.navigator.msSaveOrOpenBlob(file, fileName);
                }
                else { // Chrome, Firefox, Safari
                    const a = document.createElement('a'),
                        url = URL.createObjectURL(file);

                    a.href = url;
                    a.download = fileName;
                    a.style.position = 'absolute';
                    a.style.visibility = 'hidden';

                    document.body.appendChild(a);

                    a.click();

                    setTimeout(function () {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                    }, 100);
                }
            }

            /**
             * Exports data.
             */
            exportData(data, format, fileName, callback) {
                const that = this;

                that.actualHierarchy = that.hierarchical;
                format = format.toLowerCase();

                if (that.exportHeader) {
                    if (that.header) {
                        data = data.slice(0);

                        if (data.length === 0) {
                            that.actualHierarchy = false;
                        }

                        that.processComplexHeader(that.header, data, format);
                    }
                    else if (data.length === 1) {
                        that.actualHierarchy = false;
                    }
                }

                if (data.length === 0) {
                    // eslint-disable-next-line
                    console.warn('No data to export.');
                    return;
                }

                if (format === 'xlsx') {
                    that.xlsxStartIndex = that.complexHeader ? that.complexHeader.length : +that.exportHeader;

                    const offset = that.headerContent ? that.headerContent.length : 0;
                    that.xlsxStartIndex = that.xlsxStartIndex + offset;
                }

                if (that.actualHierarchy) {
                    data = that.processHierarchicalData(data, format);
                }

                that.getDatafields(data);

                if (fileName && fileName.slice(fileName.length - format.length - 1, fileName.length) !== '.' + format) {
                    fileName += '.' + format;
                }

                let output = null;
                switch (format) {
                    case 'csv':
                        output = that.exportToCSVAndTSV(data, { delimiter: ', ', MIME: 'text/csv', toRemove: 2 }, fileName);
                        break;
                    case 'html':
                        output = that.exportToHTML(data, fileName);
                        break;
                    case 'jpeg':
                    case 'png':
                        that.exportToImage(data, fileName, format, callback);
                        break;
                    case 'json':
                        output = that.exportToJSON(data, fileName);
                        break;
                    case 'pdf':
                        output = that.exportToPDF(data, fileName);
                        break;
                    case 'tsv':
                        output = that.exportToCSVAndTSV(data, { delimiter: '\t', MIME: 'text/tab-separated-values', toRemove: 1 }, fileName);
                        break;
                    case 'xlsx':
                        output = that.exportToXLSX(data, fileName, callback);
                        break;
                    case 'xml':
                        output = that.exportToXML(data, fileName);
                        break;
                    case 'md':
                        output = that.exportToMD(data, fileName);
                        break;
                }

                if (callback && output) {
                    callback(output);
                }

                delete that.complexHeader;

                return output;
            }

            /**
             * Exports to CSV and TSV.
             */
            exportToCSVAndTSV(data, formatOptions, fileName) {
                const that = this,
                    datafields = that.datafields;
                let stringResult = '';

                for (let i = 0; i < data.length; i++) {
                    const currentRecord = data[i];
                    let stringifiedCurrentRecord = '';

                    for (let j = 0; j < datafields.length; j++) {
                        if (that.actualHierarchy && j === 0) {
                            stringifiedCurrentRecord += ('""' + formatOptions.delimiter).repeat(currentRecord._level - 1) +
                                '"' + currentRecord[datafields[j]] + '"' + formatOptions.delimiter +
                                ('""' + formatOptions.delimiter).repeat(that.maxLevel - currentRecord._level);
                            continue;
                        }

                        stringifiedCurrentRecord += '"' + currentRecord[datafields[j]] + '"' + formatOptions.delimiter;
                    }

                    stringifiedCurrentRecord = stringifiedCurrentRecord.slice(0, stringifiedCurrentRecord.length - formatOptions.toRemove) + '\n';
                    stringResult += stringifiedCurrentRecord;
                }

                if (!fileName) {
                    return stringResult;
                }
                return this.downloadFile(stringResult, formatOptions.MIME, fileName);
            }

            /**
             * Exports to HTML.
             */
            exportToHTML(data, fileName) {
                const that = this,
                    datafields = that.datafields,
                    style = that.style;
                let header = '',
                    startIndex = 0,
                    html2canvas = '';

                data = that.processGroupingInformation(data);
                that.data = data;

                if (that.exportHeader) {
                    header = that.getHTMLHeader(datafields, data);
                    startIndex = 1;
                }

                if (arguments[2]) {
                    const scripts = Array.from(document.getElementsByTagName('script')),
                        html2canvasScript = scripts.find(script => script.src.indexOf('html2canvas') !== -1);
                    html2canvas = `<script type="text/javascript" src="${html2canvasScript.src}"></script>`;
                }

                let htmlContent = `<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <style type="text/css">
    ${that.getRowStyle()}${that.getColumnStyle()}
        </style>${html2canvas}${that.toggleableFunctionality()}
    </head>
    <body>
        <table${that.getTableStyle()}>${header}
            <tbody>\n`;

                const mergedMainCells = {},
                    mergedSecondaryCells = {},
                    groupsHandled = [];

                that.getMergedCellsInfo(mergedMainCells, mergedSecondaryCells);

                mainLoop:
                for (let i = startIndex; i < data.length; i++) {
                    const currentRecord = data[i],
                        row = i - startIndex;
                    let n = that.getAlternationIndex(row, ' rowN'),
                        toCollapse = '',
                        level = '',
                        groupId = '',
                        outlineLevel = 0;

                    if (that.actualHierarchy) {
                        if (currentRecord._collapsed) {
                            toCollapse = ' collapsed';
                        }

                        level = ` level="${currentRecord._level}"`;
                    }
                    else if (that.groupBy) {
                        for (let k = 0; k < that.groupBy.length; k++) {
                            const datafield = that.groupBy[k],
                                currentGroup = currentRecord[datafield],
                                currentGroupLabel = that.groups[datafield][currentGroup];

                            groupId += currentGroup;

                            if (groupsHandled.indexOf(groupId) === -1) {
                                htmlContent += `            <tr class="row">
                    <td class="column group" style="padding-left: ${outlineLevel * 25}px;" colspan="${that.datafields.length}">${currentGroupLabel}</td>
                </tr>`;
                                groupsHandled.push(groupId);
                                i--;
                                continue mainLoop;
                            }

                            outlineLevel++;
                        }
                    }

                    let currentContent = `            <tr class="row row${row}${n}${toCollapse}"${level}`;

                    if (!fileName) {
                        currentContent += ' style="page-break-inside: avoid;"'
                    }

                    currentContent += '>\n';

                    for (let j = 0; j < datafields.length; j++) {
                        const cellCode = j + ',' + (row);
                        let colspan = 1, rowspan = 1;

                        if (mergedMainCells[cellCode]) {
                            colspan = mergedMainCells[cellCode].colspan;
                            rowspan = mergedMainCells[cellCode].rowspan;
                        }
                        else if (mergedSecondaryCells[cellCode]) {
                            continue;
                        }

                        const datafield = datafields[j];
                        let value = currentRecord[datafield],
                            indent = '';

                        if (that.actualHierarchy && j === 0) {
                            let sign = '';

                            if (currentRecord._expanded) {
                                sign = that.collapseChar;
                            }
                            else if (currentRecord._expanded === false) {
                                sign = that.expandChar;
                            }

                            indent = `<div class="toggle-element" style="margin-left: ${25 * (currentRecord._level - 1) + 5}px;" expanded>${sign}</div>`;
                        }

                        value = that.getFormattedValue(value, datafield);

                        if (typeof value === 'string' && (value.indexOf('base64') >= 0 || value.indexOf('.svg') >= 0 || value.indexOf('.png') >= 0 || value.indexOf('.jpeg') >= 0)) {
                            value = `<img height="30" src="${value}"/>`;
                        }

                        let css = '';

                        if (style && style.columns && style.columns[datafield] && style.columns[datafield][row]) {
                            const uniqueStyle = style.columns[datafield][row];

                            css += `border-color: ${uniqueStyle.border}; background-color: ${uniqueStyle.background}; color: ${uniqueStyle.color};"`;
                        }

                        if (j === 0 && outlineLevel > 1) {
                            css += `padding-left: ${(outlineLevel - 1) * 25}px;"`;
                        }

                        if (css) {
                            css = ` style="${css}"`;
                        }

                        currentContent += `                <td class="column column${datafield}"${css} colspan="${colspan}" rowspan="${rowspan}">${indent + value}</td>\n`;
                    }

                    htmlContent += currentContent + '            </tr>\n';
                }

                htmlContent += `        </tbody>
        </table>
    </body>
    </html>`;

                if (arguments[2]) {
                    return htmlContent;
                }

                return this.downloadFile(htmlContent, 'text/html', fileName);
            }

            /**
             * Exports to an image (PNG/JPEG).
             */
            exportToImage(data, fileName, fileExtension, callback) {
                const that = this;

                try {
                    html2canvas;
                }
                catch (error) {
                    throw new Error('jqx-grid: Missing reference to \'html2canvas.min.js\'.');
                }

                let imageData = null;

                const htmlContent = that.exportToHTML(data, fileName, true),
                    iframe = document.createElement('iframe');

                iframe.style.position = 'absolute';
                iframe.style.top = 0;
                iframe.style.left = 0;
                iframe.style.border = 'none';
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.opacity = 0;
                iframe.style.pointerEvents = 'none';

                document.body.appendChild(iframe);

                iframe.contentDocument.write(htmlContent);

                function checkIframePopulated() {
                    if (!iframe.contentDocument.body || !iframe.contentDocument.body.firstElementChild) {
                        requestAnimationFrame(checkIframePopulated);
                    }
                    else {
                        iframe.contentWindow.html2canvas(iframe.contentDocument.body.firstElementChild).then(canvas => {
                            const draw = new JQX.Utilities.Draw(document.createElement('div'));

                            imageData = canvas.toDataURL('image/png');

                            if (callback) {
                                callback(imageData);
                            }
                            else {
                                document.body.appendChild(canvas);
                                draw.exportImage(undefined, canvas, fileExtension, fileName);
                            }

                            iframe.remove();
                            canvas.remove();
                        });
                    }
                }

                checkIframePopulated();

                return imageData;
            }

            /**
             * Gets merged cells information (for use in HTML and PDF export).
             */
            getMergedCellsInfo(mergedMainCells, mergedSecondaryCells, mapping) {
                const that = this;

                if (!that.mergedCells) {
                    return;
                }

                const multipleTables = mapping && mapping[that.datafields.length - 1] !== 0;

                that.mergedCellsPDF = that.mergedCells.slice(0);

                for (let i = 0; i < that.mergedCellsPDF.length; i++) {
                    const cellDefinition = that.mergedCellsPDF[i];
                    let colspan = cellDefinition.colspan,
                        rowspan = cellDefinition.rowspan;

                    if (rowspan < 2 && colspan < 2) {
                        continue;
                    }

                    const row = cellDefinition.cell[1];
                    let col = cellDefinition.cell[0];

                    if (multipleTables && colspan > 1) {
                        const startTable = mapping[col],
                            endTable = mapping[col + colspan - 1],
                            splitCells = [];

                        if (endTable > startTable) {
                            let currentTable = startTable,
                                currentColumn = col,
                                overal = 0;

                            mainLoop:
                            for (let i = startTable; i <= endTable; i++) {
                                let start = currentColumn,
                                    span = 0;

                                while (mapping[currentColumn] === currentTable) {
                                    currentColumn++;
                                    overal++;
                                    span++;

                                    if (overal === colspan) {
                                        splitCells.push({ start: start, span: span });
                                        break mainLoop;
                                    }
                                }

                                splitCells.push({ start: start, span: span });
                                currentTable = mapping[currentColumn];
                            }

                            colspan = splitCells[0].span;

                            for (let i = 1; i < splitCells.length; i++) {
                                that.mergedCellsPDF.push({ cell: [splitCells[i].start, row], colspan: splitCells[i].span, rowspan: rowspan, originalCell: col });
                            }
                        }
                    }

                    for (let j = col; j < col + colspan; j++) {
                        for (let k = row; k < row + rowspan; k++) {
                            const code = j + ',' + k;

                            if (j === col && k === row) {
                                mergedMainCells[code] = { colspan: colspan, rowspan: rowspan, originalCell: cellDefinition.originalCell };
                                continue;
                            }

                            mergedSecondaryCells[code] = true;
                        }
                    }
                }
            }

            /**
             * Gets alternation index.
             */
            getAlternationIndex(row, prefix) {
                const that = this;

                if (!that.style) {
                    return '';
                }

                const rowsDefinition = that.style.rows,
                    alternationCount = rowsDefinition && rowsDefinition.alternationCount;

                if (alternationCount &&
                    (((rowsDefinition.alternationStart === undefined || row >= rowsDefinition.alternationStart) &&
                        (rowsDefinition.alternationEnd === undefined || row <= rowsDefinition.alternationEnd)) ||
                        rowsDefinition.alternationStart === rowsDefinition.alternationEnd)) {
                    return prefix + (row % rowsDefinition.alternationCount);
                }

                return '';
            }

            /**
             * Gets formatted numeric or date value (for use in HTML and PDF export).
             */
            getFormattedValue(value, datafield) {
                const that = this,
                    style = that.style;

                if (value === null) {
                    return that.allowNull ? 'null' : '';
                }

                if (datafield && style && style.columns &&
                    style.columns[datafield] && style.columns[datafield].format) {
                    if (typeof value === 'number') {
                        return that.formatNumber(value, style.columns[datafield].format);
                    }
                    else if (value instanceof Date) {
                        return that.formatDate(value, style.columns[datafield].format);
                    }
                }
                else if (value instanceof Date) {
                    return that.formatDate(value, 'd');
                }

                return value;
            }

            /**
             * Exports to JSON.
             */
            exportToJSON(data, fileName) {
                return this.downloadFile(JSON.stringify(data, this.datafields.concat('rows')), 'application/json', fileName);
            }

            /**
             * Export to Markdown(MD)
             * @param {string} data - the data to export
             * @param {string} fileName - the name of the file
             * @returns 
             */
            exportToMD(data, fileName) {
                const that = this,
                    dataFields = that.datafields;
                let text = '';


                for (let i = 0, max = data.length; i < max; i += 1) {
                    for (let j = 0, max = dataFields.length; j < max; j += 1) {
                        const dataField = data[i][dataFields[j]];

                        if (typeof dataField === 'string') {
                            text += dataField;
                        }
                    }
                }

                return that.downloadFile(text, 'application/text', fileName);
            }

            /**
             * Exports to PDF.
             */
            exportToPDF(data, fileName) {
                try {
                    pdfMake;
                }
                catch (error) {
                    throw new Error('Missing reference to \'pdfmake.min.js\'.');
                }

                const that = this,
                    datafields = that.datafields,
                    startIndex = +that.exportHeader,
                    groupsHandled = [],
                    mergedMainCells = {},
                    mergedSecondaryCells = {},
                    mapping = {},
                    headerRows = startIndex ? that.complexHeader ? that.complexHeader.length : 1 : 0,
                    docDefinition = {
                        pageOrientation: that.pageOrientation || 'portrait'
                    };
                let header = [], content = [], tables;

                function createTableRow() {
                    let tableRow = [];

                    for (let i = 0; i < tables.length; i++) {
                        tableRow.push([]);
                    }

                    return tableRow;
                }

                data = that.processGroupingInformation(data);
                that.data = data;
                that.headerRows = headerRows;
                that.getPDFStyle();

                const styleInfo = that.styleInfo;

                tables = styleInfo ? that.wrapPDFColumns(docDefinition, mapping) : [{ body: header, datafields: datafields }];

                if (startIndex) {
                    header = that.getPDFHeader(datafields, tables, mapping);
                }

                that.getMergedCellsInfo(mergedMainCells, mergedSecondaryCells, mapping);

                mainLoop:
                for (let i = startIndex; i < data.length; i++) {
                    const currentRecord = data[i];
                    let groupId = '',
                        outlineLevel = 0;

                    if (that.groupBy) {
                        for (let k = 0; k < that.groupBy.length; k++) {
                            const datafield = that.groupBy[k],
                                currentGroup = currentRecord[datafield],
                                currentGroupLabel = that.groups[datafield][currentGroup];

                            groupId += currentGroup;

                            if (groupsHandled.indexOf(groupId) === -1) {
                                that.createGroupHeaderRow(tables, { text: currentGroupLabel, style: ['row', 'cell', 'group'], marginLeft: outlineLevel * 7.5 });
                                groupsHandled.push(groupId);
                                i--;
                                continue mainLoop;
                            }

                            outlineLevel++;
                        }
                    }

                    const tableRow = createTableRow(),
                        row = i - startIndex;
                    let n = that.getAlternationIndex(row, '');

                    for (let j = 0; j < datafields.length; j++) {
                        const datafield = datafields[j],
                            entry = { style: ['row', 'row' + row, 'cell', 'cell' + datafield] },
                            tableIndex = mapping[j] || 0;

                        if (n !== undefined) {
                            entry.style.splice(1, 0, 'rowN' + n);
                        }

                        if (that.mergedCellsPDF) {
                            const cellCode = j + ',' + row,
                                mergeInfo = mergedMainCells[cellCode];

                            if (mergeInfo) {
                                entry.colSpan = mergeInfo.colspan;
                                entry.rowSpan = mergeInfo.rowspan;

                                if (mergeInfo.originalCell !== undefined) {
                                    entry.text = '';
                                    entry.style[entry.style.length - 1] = 'cell' + datafields[mergeInfo.originalCell];
                                    tableRow[tableIndex].push(entry);
                                    continue;
                                }
                            }
                            else if (mergedSecondaryCells[cellCode]) {
                                tableRow[tableIndex].push({});
                                continue;
                            }
                        }

                        const value = that.getFormattedValue(currentRecord[datafield], datafield);

                        entry.text = value.toString();
                        that.getUniqueStylePDF(entry, datafield, row);
                        that.setIndentation(entry, { j: j, currentRecord: currentRecord, value: value, outlineLevel: outlineLevel });
                        tableRow[tableIndex].push(entry);
                    }

                    for (let k = 0; k < tables.length; k++) {
                        tables[k].body.push(tableRow[k]);
                    }
                }

                if (styleInfo) {
                    for (let i = 0; i < tables.length; i++) {
                        const body = tables[i].body;

                        for (let j = headerRows - 1; j >= 0; j--) {
                            body.unshift(header[i][j]);
                        }

                        content.push({
                            table: {
                                headerRows: headerRows,
                                widths: tables[i].widths,
                                heights: function (row) {
                                    if (styleInfo.heights[row]) {
                                        return styleInfo.heights[row];
                                    }

                                    if (styleInfo.defaultHeight) {
                                        return styleInfo.defaultHeight;
                                    }
                                },
                                body: body
                            },
                            pageBreak: 'after'
                        });
                    }

                    delete content[tables.length - 1].pageBreak;
                    docDefinition.styles = styleInfo.styles;
                }
                else {
                    const body = tables[0].body;

                    for (let j = headerRows - 1; j >= 0; j--) {
                        body.unshift(header[0][j]);
                    }

                    content = [{ table: { headerRows: headerRows, body: body } }];
                    docDefinition.styles = { header: { bold: true }, group: { bold: true } };
                }

                docDefinition.content = content;

                if (!fileName) {
                    const output = pdfMake.createPdf(docDefinition);

                    delete that.mergedCellsPDF;
                    delete that.styleInfo;

                    return output;
                }
                pdfMake.createPdf(docDefinition).download(fileName);

                delete that.mergedCellsPDF;
                delete that.styleInfo;
            }

            /**
             * Gets the header content when exporting to PDF.
             */
            getPDFStyle() {
                const that = this,
                    style = that.style;

                if (!style) {
                    return '';
                }

                const sampleRecord = that.data[0],
                    headerDefinition = style.header,
                    columnsDefinition = style.columns,
                    rowsDefinition = style.rows,
                    styleInfo = {
                        heights: [],
                        widths: Array(that.datafields.length).fill('*'),
                        styles: {
                            header: {},
                            row: {},
                            cell: {},
                            group: { fillColor: '#FFFFFF', color: '#000000', bold: true }
                        }
                    };

                that.styleInfo = styleInfo;

                function processStyleDefinition(definition, type) {
                    if (!definition) {
                        return;
                    }

                    for (let prop in definition) {
                        if (!Object.prototype.hasOwnProperty.call(definition, prop)) {
                            continue;
                        }

                        if (sampleRecord[prop] === undefined) {
                            if (prop === 'height' && type === 'header') {
                                for (let i = 0; i < that.headerRows; i++) {
                                    styleInfo.heights[i] = (parseInt(definition[prop], 10) / that.headerRows) / 1.4;
                                }
                            }
                            else {
                                that.storePDFStyle({ prop: prop, value: definition[prop], toUpdate: type });
                            }
                        }
                        else {
                            for (let columnProp in definition[prop]) {
                                if (!isNaN(columnProp) || !Object.prototype.hasOwnProperty.call(definition[prop], columnProp)) {
                                    continue;
                                }

                                const value = definition[prop][columnProp],
                                    index = that.datafields.indexOf(prop);

                                if (columnProp === 'width' && styleInfo.widths[index] === '*') {
                                    styleInfo.widths[index] = value;
                                }
                                else {
                                    that.storePDFStyle({ prop: columnProp, value: value, toUpdate: type + prop });
                                }
                            }
                        }
                    }
                }

                processStyleDefinition(headerDefinition, 'header');
                processStyleDefinition(columnsDefinition, 'cell');

                if (!rowsDefinition) {
                    return;
                }

                for (let prop in rowsDefinition) {
                    if (!Object.prototype.hasOwnProperty.call(rowsDefinition, prop) || prop.indexOf('alt') !== -1) {
                        continue;
                    }

                    const value = rowsDefinition[prop];

                    if (!isNaN(prop)) {
                        for (let rowProp in value) {
                            if (Object.prototype.hasOwnProperty.call(value, rowProp)) {
                                if (rowProp === 'height') {
                                    styleInfo.heights[parseFloat(prop) + that.headerRows] = parseFloat(value[rowProp]) / 1.4;
                                }
                                else {
                                    that.storePDFStyle({ prop: rowProp, value: value[rowProp], toUpdate: 'row' + prop });
                                }
                            }
                        }

                        continue;
                    }

                    if (prop === 'height') {
                        styleInfo.defaultHeight = parseFloat(value) / 1.4;
                    }
                    else {
                        that.storePDFStyle({ prop: prop, value: value, toUpdate: 'row' });
                    }
                }

                if (!rowsDefinition.alternationCount) {
                    return;
                }

                for (let i = 0; i < rowsDefinition.alternationCount; i++) {
                    const styleN = {};

                    if (rowsDefinition[`alternationIndex${i}Color`]) {
                        styleN.color = rowsDefinition[`alternationIndex${i}Color`];
                    }

                    if (rowsDefinition[`alternationIndex${i}BackgroundColor`]) {
                        styleN.fillColor = rowsDefinition[`alternationIndex${i}BackgroundColor`];
                    }

                    styleInfo.styles['rowN' + i] = styleN;
                }
            }

            /**
             * Stores style in object to be applied to generated PDF.
             */
            storePDFStyle(details) {
                const that = this;
                let objectToUpdate = that.styleInfo.styles[details.toUpdate];

                if (!objectToUpdate) {
                    objectToUpdate = {};
                    that.styleInfo.styles[details.toUpdate] = objectToUpdate;
                }

                let value = details.value;

                switch (details.prop) {
                    case 'backgroundColor':
                        objectToUpdate.fillColor = value;
                        break;
                    case 'color':
                        objectToUpdate.color = value;
                        break;
                    case 'fontSize':
                        objectToUpdate.fontSize = parseFloat(value);
                        break;
                    case 'fontStyle':
                        if (value === 'italic') {
                            objectToUpdate.italics = true;
                        }

                        break;
                    case 'fontWeight':
                        if (value === 'bold') {
                            objectToUpdate.bold = true;
                        }

                        break;
                    case 'textAlign':
                        objectToUpdate.alignment = value;
                        break;
                }
            }

            /**
             * Enables column wrapping when exporting to PDF.
             */
            wrapPDFColumns(docDefinition, mapping) {
                const that = this,
                    styleInfo = this.styleInfo,
                    maxPerPage = docDefinition.pageOrientation === 'portrait' ? 655 : 1155, // maximum of 655px (portrait) or 1155px (landscape) per A4 page
                    tables = [];
                let currentPage = 0;

                for (let i = 0; i < styleInfo.widths.length; i++) {
                    let currentWidth = styleInfo.widths[i],
                        numericWidth;

                    if (currentWidth === '*') {
                        numericWidth = maxPerPage / 6;
                    }
                    else if (typeof currentWidth === 'string' && currentWidth.indexOf('%') !== -1) {
                        numericWidth = Math.min(maxPerPage, Math.floor((parseFloat(currentWidth) / 100) * maxPerPage));

                        if (numericWidth === maxPerPage) {
                            currentWidth = '*';
                        }
                    }
                    else {
                        currentWidth = parseFloat(currentWidth);

                        if (currentWidth >= maxPerPage) {
                            numericWidth = maxPerPage
                            currentWidth = '*';
                        }
                        else {
                            numericWidth = currentWidth;
                            currentWidth /= 1.4;
                        }
                    }

                    if (tables[currentPage] === undefined) {
                        const body = [];

                        tables[currentPage] = {
                            body: body,
                            width: numericWidth,
                            widths: [currentWidth],
                            datafields: [that.datafields[i]]
                        };
                        mapping[i] = currentPage;
                        continue;
                    }

                    const table = tables[currentPage];

                    if (table.width + numericWidth > maxPerPage) {
                        currentPage++;
                        i--;
                        continue;
                    }

                    mapping[i] = currentPage;
                    table.width += numericWidth;
                    table.widths.push(currentWidth);
                    table.datafields.push(that.datafields[i]);
                }

                return tables;
            }

            /**
             * Gets the header content when exporting to PDF.
             */
            getPDFHeader(datafields, tables, mapping) {
                const that = this,
                    headerArray = [],
                    headerRows = that.headerRows,
                    headers = [],
                    headerDataFields = [];
                let result = [],
                    headerStructure, headerDataFieldStructure;

                if (that.complexHeader) {
                    headerStructure = that.complexHeader;
                    headerDataFieldStructure = that.complexDataFieldsHeader;
                }
                else {
                    headerStructure = [Object.values(that.data[0])];
                    headerDataFieldStructure = headerStructure;
                }

                for (let i = 0; i < headerRows; i++) {
                    const row = headerStructure[i],
                        rowDataField = headerDataFieldStructure[i];

                    for (let k = 0; k < row.length; k++) {
                        let tableIndex = mapping[k] || 0;

                        if (!headers[tableIndex]) {
                            headers[tableIndex] = [];
                            headerDataFields[tableIndex] = [];
                        }

                        if (!headers[tableIndex][i]) {
                            headers[tableIndex][i] = [];
                            headerDataFields[tableIndex][i] = [];
                        }

                        headers[tableIndex][i].push(row[k]);
                        headerDataFields[tableIndex][i].push(rowDataField[k]);
                    }
                }

                function processHeader(header, headerDataField, result, table) {
                    for (let j = 0; j < headerRows; j++) {
                        const row = header[j],
                            rowDataField = headerDataField[j];
                        const tableRow = [];

                        for (let k = 0; k < row.length; k++) {
                            const currentDataField = rowDataField[k];
                            let colspan = 1, rowspan = 1;

                            if ((rowDataField[k - 1] && rowDataField[k - 1] === currentDataField) ||
                                (headerDataField[j - 1] && (headerDataField[j - 1][k] === currentDataField))) {
                                tableRow.push({});
                                continue;
                            }

                            let iterator = k + 1;

                            while (rowDataField[iterator] && rowDataField[iterator] === rowDataField[iterator - 1]) {
                                colspan++;
                                iterator++;
                            }

                            iterator = j + 1;

                            while (headerDataField[iterator] && headerDataField[iterator][k] === currentDataField) {
                                rowspan++;
                                iterator++;
                            }

                            const datafield = j === headerRows - 1 || rowspan + j === headerRows ?
                                table.datafields[k] : null,
                                entry = {
                                    text: row[k], colSpan: colspan, rowSpan: rowspan
                                };

                            if (!datafield) {
                                entry.alignment = 'center';
                                entry.style = 'header';
                            }
                            else {
                                entry.style = ['header', 'header' + datafield];
                            }

                            tableRow.push(entry);
                        }

                        result.push(tableRow);
                    }
                }

                for (let i = 0; i < tables.length; i++) {
                    result = [];
                    processHeader(headers[i], headerDataFields[i], result, tables[i]);
                    headerArray.push(result);
                }

                return headerArray;
            }

            /**
             * Creates group header rows when exporting to PDF.
             */
            createGroupHeaderRow(tables, entryTemplate) {
                for (let i = 0; i < tables.length; i++) {
                    const entry = Object.assign({}, entryTemplate),
                        colspan = tables[i].datafields.length,
                        tableRow = [entry];

                    entry.colSpan = colspan;
                    tableRow.length = colspan;
                    tableRow.fill({}, 1, colspan - 1);

                    tables[i].body.push(tableRow);
                }
            }

            /**
             * Gets unique cell style when exporting to PDF.
             */
            getUniqueStylePDF(entry, datafield, row) {
                const style = this.style;

                function toHex(background) {
                    const parts = /rgba\((\d+),(\d+),(\d+)\,(\d*.\d+|\d+)\)/gi.exec(background.replace(/\s/g, ''));

                    if (parts === null) {
                        return background;
                    }

                    const r = parseFloat(parts[1]).toString(16).toUpperCase(),
                        g = parseFloat(parts[2]).toString(16).toUpperCase(),
                        b = parseFloat(parts[3]).toString(16).toUpperCase();

                    return '#' + ('0').repeat(2 - r.length) + r +
                        ('0').repeat(2 - g.length) + g +
                        ('0').repeat(2 - b.length) + b;
                }

                if (!style || !style.columns || !style.columns[datafield]) {
                    return;
                }

                const uniqueStyle = style.columns[datafield][row];

                if (!uniqueStyle) {
                    return;
                }

                entry.fillColor = toHex(uniqueStyle.background);
                entry.color = uniqueStyle.color.toLowerCase();
            }

            /**
             * Sets the indentation of a PDF cell.
             */
            setIndentation(entry, details) {
                if (details.j !== 0) {
                    return;
                }

                const that = this;

                if (that.actualHierarchy) {
                    const currentRecord = details.currentRecord;

                    if (currentRecord._expanded !== undefined) {
                        entry.marginLeft = 25 * (currentRecord._level - 1);
                        entry.text = that.collapseChar + ' ' + details.value;
                    }
                    else {
                        entry.marginLeft = 25 * (currentRecord._level - 1) + 6;
                    }
                }
                else if (details.outlineLevel > 1) {
                    entry.marginLeft = (details.outlineLevel - 1) * 7.5;
                }
            }

            addBodyImageToMap(image, rowIndex, col, columnsToExport) {
                const sheetIndex = 1;
                const { row, column } = image.position || {};
                const calculatedImage = image;
                if (columnsToExport) {
                    if (rowIndex !== null && col !== null && (!row || !column)) {
                        if (!image.position) {
                            image.position = {};
                        }
                        image.position = Object.assign({}, image.position, {
                            row: rowIndex,
                            column: columnsToExport.indexOf(col) + 1
                        });
                    }
                    calculatedImage.totalWidth = calculatedImage.width;
                    calculatedImage.totalHeight = calculatedImage.height;
                }
                this.buildImageMap({ imageToAdd: calculatedImage, idx: sheetIndex });
                let worksheetImageIdMap = this.worksheetImageIds.get(sheetIndex);
                if (!worksheetImageIdMap) {
                    worksheetImageIdMap = new Map();
                    this.worksheetImageIds.set(sheetIndex, worksheetImageIdMap);
                }
                const sheetImages = this.worksheetImages.get(sheetIndex);
                if (!sheetImages) {
                    this.worksheetImages.set(sheetIndex, [calculatedImage]);
                } else {
                    sheetImages.push(calculatedImage);
                }
                if (!worksheetImageIdMap.get(image.id)) {
                    worksheetImageIdMap.set(image.id, { index: worksheetImageIdMap.size, type: image.imageType });
                }
            }
            buildImageMap(params) {
                const { imageToAdd, idx } = params;
                const mappedImagesToSheet = this.images.get(imageToAdd.id);
                if (mappedImagesToSheet) {
                    const currentSheetImages = mappedImagesToSheet.find((currentImage) => currentImage.sheetId === idx);
                    if (currentSheetImages) {
                        currentSheetImages.image.push(imageToAdd);
                    } else {
                        mappedImagesToSheet.push({
                            sheetId: idx,
                            image: [imageToAdd]
                        });
                    }
                } else {
                    this.images.set(imageToAdd.id, [{ sheetId: idx, image: [imageToAdd] }]);
                    this.workbookImageIds.set(imageToAdd.id, { type: imageToAdd.imageType, index: this.workbookImageIds.size });
                }
            }

            createXmlPart(body, skipHeader) {
                const header = XmlFactory.createHeader({
                    encoding: "UTF-8",
                    standalone: "yes"
                });
                const xmlBody = XmlFactory.createXml(body);
                if (skipHeader) {
                    return xmlBody;
                }
                return `${header}${xmlBody}`;
            }

            generateWorksheetImages(zip, xl, data) {
                const that = this;

                this.images = new Map();
                this.worksheetImages = new Map();
                this.worksheetHeaderFooterImages = new Map();
                this.workbookImageIds = new Map();
                this.worksheetImageIds = new Map();
                let drawingIndex = 0;
                let imgCounter = 0;
                let imgIndex = 0;
                if (that.addImageToCell) {
                    let offset = that.headerContent ? that.headerContent.length : 0;
                    if (that.complexHeader) {
                        offset += that.complexHeader.length - 1;
                    }

                    for (let i = 1 + offset; i < data.length; i++) {
                        const row = data[i];
                        for (let j = 0; j < that.datafields.length; j++) {
                            const dataField = that.datafields[j];
                            let value = row[dataField];

                            if (value && Array.isArray(value)) {
                                for (let m = 0; m < value.length; m++) {
                                    const addedImage = that.addImageToCell(i + imgIndex++, dataField, value[m], value, row, m);
                                    if (addedImage) {
                                        row[dataField] = '';
                                        this.addBodyImageToMap(
                                            addedImage.image,
                                            1 + i,
                                            dataField,
                                            that.datafields
                                        );
                                    }
                                }
                                continue;
                            }

                            const addedImage = that.addImageToCell(i + imgIndex++, dataField, value, value, row, 0);
                            if (addedImage) {
                                row[dataField] = '';
                                if (addedImage.value && addedImage.value !== value) {
                                    row[dataField] = addedImage.value;
                                }
                                this.addBodyImageToMap(
                                    addedImage.image,
                                    1 + i,
                                    dataField,
                                    that.datafields
                                );
                            }
                        }
                    }

                    if (that.headerContent) {
                        for (let m = 0; m < that.headerContent.length; m++) {
                            const row = data[m];
                            for (let j = 0; j < that.datafields.length; j++) {
                                const dataField = that.datafields[j];
                                const value = row[dataField];

                                const addedImage = that.addImageToCell(m + 1, dataField, value, value, row, 0);
                                if (addedImage) {
                                    row[dataField] = '';
                                    this.addBodyImageToMap(
                                        addedImage.image,
                                        1 + m,
                                        dataField,
                                        that.datafields
                                    );
                                }
                            }
                        }
                    }

                    this.images.forEach((value) => {
                        const firstImage = value[0].image[0];
                        const { base64, imageType } = firstImage;
                        const ext = imageType === 'jpg' ? 'jpeg' : imageType;
                        // Function to convert a base64 string to a Blob
                        const base64ToBlob = (base64, mimeType) => {
                            if (!base64) {
                                base64 = '';
                            }
                            const byteCharacters = atob(base64);
                            const byteNumbers = new Array(byteCharacters.length);
                            for (let i = 0; i < byteCharacters.length; i++) {
                                byteNumbers[i] = byteCharacters.charCodeAt(i);
                            }
                            const byteArray = new Uint8Array(byteNumbers);
                            return new Blob([byteArray], { type: mimeType });
                        }

                        let imageBlob;
                        // Convert the Base64 string to a PNG Blob
                        if (base64 && Array.isArray(base64)) {
                            imageBlob = base64ToBlob(base64[0].split(',')[1], 'image/' + ext);
                        }
                        else {
                            imageBlob = base64ToBlob(base64.split(',')[1], 'image/' + ext);
                        }

                        zip.file(`xl/media/image${++imgCounter}.${ext}`, imageBlob, true);
                    });
                }

                let imageRelationCounter = 0;

                var INCH_TO_EMU = 9525;

                var pixelsToEMU = (value) => {
                    return Math.ceil(value * INCH_TO_EMU);
                };

                var getImageBoxSize = (image) => {
                    image.fitCell = !!image.fitCell || !image.width || !image.height;
                    const { position = {}, fitCell, width = 0, height = 0, totalHeight, totalWidth } = image;
                    const { offsetX = 0, offsetY = 0, row = 1, rowSpan = 1, column = 1, colSpan = 1 } = position;
                    return {
                        from: {
                            row: row - 1,
                            col: column - 1,
                            offsetX: pixelsToEMU(offsetX),
                            offsetY: pixelsToEMU(offsetY)
                        },
                        to: {
                            row: row - 1 + (fitCell ? 1 : rowSpan - 1),
                            col: column - 1 + (fitCell ? 1 : colSpan - 1),
                            offsetX: pixelsToEMU(width + offsetX),
                            offsetY: pixelsToEMU(height + offsetY)
                        },
                        height: pixelsToEMU(totalHeight || height),
                        width: pixelsToEMU(totalWidth || width)
                    };
                };
                var getPicture = (image, currentIndex, worksheetImageIndex, imageBoxSize) => {
                    return {
                        name: "xdr:pic",
                        children: [
                            getNvPicPr(image, currentIndex + 1),
                            getBlipFill(image, worksheetImageIndex + 1),
                            getSpPr(image, imageBoxSize)
                        ]
                    };
                };


                var getBlipFill = (image, index) => {
                    let blipChildren;
                    if (image.transparency) {
                        const transparency = Math.min(Math.max(image.transparency, 0), 100);
                        blipChildren = [
                            {
                                name: "a:alphaModFix",
                                properties: {
                                    rawMap: {
                                        amt: 1e5 - Math.round(transparency * 1e3)
                                    }
                                }
                            }
                        ];
                    }
                    if (image.recolor) {
                        if (!blipChildren) {
                            blipChildren = [];
                        }
                        switch (image.recolor.toLocaleLowerCase()) {
                            case "grayscale":
                                blipChildren.push({ name: "a:grayscl" });
                                break;
                            case "sepia":
                                blipChildren.push(getDuoTone({ color: "black" }, { color: "D9C3A5", tint: 50, saturation: 180 }));
                                break;
                            case "washout":
                                blipChildren.push({
                                    name: "a:lum",
                                    properties: {
                                        rawMap: {
                                            bright: "70000",
                                            contrast: "-70000"
                                        }
                                    }
                                });
                                break;
                            default:
                        }
                    }
                    return {
                        name: "xdr:blipFill",
                        children: [
                            {
                                name: "a:blip",
                                properties: {
                                    rawMap: {
                                        cstate: "print",
                                        "r:embed": `rId${index}`,
                                        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships"
                                    }
                                },
                                children: blipChildren
                            },
                            {
                                name: "a:stretch",
                                children: [
                                    {
                                        name: "a:fillRect"
                                    }
                                ]
                            }
                        ]
                    };
                };
                var getSpPr = (image, imageBoxSize) => {
                    const xfrm = {
                        name: "a:xfrm",
                        children: [
                            {
                                name: "a:off",
                                properties: {
                                    rawMap: {
                                        x: 0,
                                        y: 0
                                    }
                                }
                            },
                            {
                                name: "a:ext",
                                properties: {
                                    rawMap: {
                                        cx: imageBoxSize.width,
                                        cy: imageBoxSize.height
                                    }
                                }
                            }
                        ]
                    };
                    if (image.rotation) {
                        const rotation = image.rotation;
                        xfrm.properties = {
                            rawMap: {
                                rot: Math.min(Math.max(rotation, 0), 360) * 6e4
                            }
                        };
                    }
                    const prstGeom = {
                        name: "a:prstGeom",
                        properties: {
                            rawMap: {
                                prst: "rect"
                            }
                        },
                        children: [{ name: "a:avLst" }]
                    };
                    const ret = {
                        name: "xdr:spPr",
                        children: [xfrm, prstGeom]
                    };
                    return ret;
                };

                var getExt = (image) => {
                    const children = [
                        {
                            name: "a:ext",
                            properties: {
                                rawMap: {
                                    uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}"
                                }
                            },
                            children: [
                                {
                                    name: "a16:creationId",
                                    properties: {
                                        rawMap: {
                                            id: "{822E6D20-D7BC-2841-A643-D49A6EF008A2}",
                                            "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main"
                                        }
                                    }
                                }
                            ]
                        }
                    ];
                    const recolor = image.recolor && image.recolor.toLowerCase();
                    switch (recolor) {
                        case "grayscale":
                        case "sepia":
                        case "washout":
                            children.push({
                                name: "a:ext",
                                properties: {
                                    rawMap: {
                                        uri: "{C183D7F6-B498-43B3-948B-1728B52AA6E4}"
                                    }
                                },
                                children: [
                                    {
                                        name: "adec:decorative",
                                        properties: {
                                            rawMap: {
                                                val: "0",
                                                "xmlns:adec": "http://schemas.microsoft.com/office/drawing/2017/decorative"
                                            }
                                        }
                                    }
                                ]
                            });
                    }
                    return {
                        name: "a:extLst",
                        children
                    };
                };

                var getNvPicPr = (image, index) => ({
                    name: "xdr:nvPicPr",
                    children: [
                        {
                            name: "xdr:cNvPr",
                            properties: {
                                rawMap: {
                                    id: index,
                                    name: image.id,
                                    descr: image.altText != null ? image.altText : void 0
                                }
                            },
                            children: [getExt(image)]
                        },
                        {
                            name: "xdr:cNvPicPr",
                            properties: {
                                rawMap: {
                                    preferRelativeResize: "0"
                                }
                            },
                            children: [
                                {
                                    name: "a:picLocks"
                                }
                            ]
                        }
                    ]
                });

                var getAnchor = (name, imageAnchor) => ({
                    name: `xdr:${name}`,
                    children: [
                        {
                            name: "xdr:col",
                            textNode: imageAnchor.col.toString()
                        },
                        {
                            name: "xdr:colOff",
                            textNode: imageAnchor.offsetX.toString()
                        },
                        {
                            name: "xdr:row",
                            textNode: imageAnchor.row.toString()
                        },
                        {
                            name: "xdr:rowOff",
                            textNode: imageAnchor.offsetY.toString()
                        }
                    ]
                });

                var drawingFactory = {
                    getTemplate(config) {
                        const { sheetIndex } = config;
                        const sheetImages = that.worksheetImages.get(sheetIndex);
                        const sheetImageIds = that.worksheetImageIds.get(sheetIndex);
                        const children = sheetImages.map((image, idx) => {
                            const boxSize = getImageBoxSize(image);
                            return {
                                name: "xdr:twoCellAnchor",
                                properties: {
                                    rawMap: {
                                        editAs: "absolute"
                                    }
                                },
                                children: [
                                    getAnchor("from", boxSize.from),
                                    getAnchor("to", boxSize.to),
                                    getPicture(image, idx, sheetImageIds.get(image.id).index, boxSize),
                                    { name: "xdr:clientData" }
                                ]
                            };
                        });
                        return {
                            name: "xdr:wsDr",
                            properties: {
                                rawMap: {
                                    "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
                                    "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main",
                                }
                            },
                            children
                        };
                    }
                };

                const createDrawing = (sheetIndex) => {
                    return this.createXmlPart(drawingFactory.getTemplate({ sheetIndex }));
                }
                // enterprise-modules/excel-export/src/excelExport/files/ooxml/relationship.ts
                var relationshipFactory = {
                    getTemplate(config) {
                        const { Id, Type, Target } = config;
                        return {
                            name: "Relationship",
                            properties: {
                                rawMap: {
                                    Id,
                                    Type,
                                    Target
                                }
                            }
                        };
                    }
                };
                var relationship_default = relationshipFactory;

                // enterprise-modules/excel-export/src/excelExport/files/ooxml/relationships.ts
                var relationshipsFactory = {
                    getTemplate(c) {
                        const children = c.map((relationship) => relationship_default.getTemplate(relationship));
                        return {
                            name: "Relationships",
                            properties: {
                                rawMap: {
                                    xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
                                }
                            },
                            children
                        };
                    }
                };
                var relationships_default = relationshipsFactory;

                const createDrawingRel = (sheetIndex) => {
                    const worksheetImageIds = this.worksheetImageIds.get(sheetIndex) || [];
                    const XMLArr = [];
                    for (const [key, value] of worksheetImageIds) {
                        XMLArr.push({
                            Id: `rId${value.index + 1}`,
                            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                            Target: `../media/image${this.workbookImageIds.get(key).index + 1}.${value.type}`
                        });
                    }
                    return this.createXmlPart(relationshipsFactory.getTemplate(XMLArr));
                }

                var createExcelXmlDrawings = (sheetIndex, drawingIndex) => {
                    const drawingFolder = 'xl/drawings';
                    const drawingFileName = `${drawingFolder}/drawing${drawingIndex + 1}.xml`;
                    const relFileName = `${drawingFolder}/_rels/drawing${drawingIndex + 1}.xml.rels`;
                    zip.file(relFileName, createDrawingRel(sheetIndex));
                    zip.file(drawingFileName, createDrawing(sheetIndex));
                };

                for (let i = 1; i < data.length; i++) {
                    const hasImages = this.worksheetImages.has(i);
                    if (hasImages) {
                        createExcelXmlDrawings(i, imageRelationCounter);
                        drawingIndex = imageRelationCounter;
                        imageRelationCounter++;
                    }
                }

                const createRelationships = ({
                    drawingIndex,
                    tableIndex
                } = {}) => {
                    if (drawingIndex === void 0 && tableIndex === void 0) {
                        return '';
                    }
                    const config = [];

                    if (drawingIndex !== null && imgCounter > 0) {
                        config.push({
                            Id: `rId${config.length + 1}`,
                            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
                            Target: `../drawings/drawing${drawingIndex + 1}.xml`
                        });
                    }
                    if (tableIndex !== null) {
                        config.push({
                            Id: `rId${config.length + 1}`,
                            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table",
                            Target: `../tables/table1.xml`
                        });
                    }
                    const rs = relationships_default.getTemplate(config);
                    return this.createXmlPart(rs);
                }

                var tableIndex = this.exportAsTable ? 1 : 0;
                const worksheetRelFile = `xl/worksheets/_rels/sheet1.xml.rels`;
                zip.file(
                    worksheetRelFile,
                    createRelationships({
                        tableIndex,
                        drawingIndex
                    })
                );
            }
            /**
             * Exports to XLSX.
             */
            exportToXLSX(data, fileName, callback) {
                try {
                    JSZip;
                }
                catch (error) {
                    throw new Error('Missing reference to \'jszip.min.js\'.');
                }

                const that = this;
                let style = that.style;

                data = that.processGroupingInformation(data, true);
                that.data = data;
                that.getColumnsArray();

                that.complexHeaderMergedCells = [];

                if (that.complexHeaderMergeInfo) {
                    for (let cell in that.complexHeaderMergeInfo) {
                        if (Object.prototype.hasOwnProperty.call(that.complexHeaderMergeInfo, cell)) {
                            const currentEntry = that.complexHeaderMergeInfo[cell];

                            if (currentEntry.from[0] === currentEntry.to[0] &&
                                currentEntry.from[1] === currentEntry.to[1]) {
                                continue;
                            }

                            that.complexHeaderMergedCells.push({
                                from: that.columnsArray[currentEntry.from[1]] + (currentEntry.from[0] + 1),
                                to: that.columnsArray[currentEntry.to[1]] + (currentEntry.to[0] + 1)
                            });
                        }
                    }
                }

                that.getConditionalFormatting();

                if (!style) {
                    style = that.generateDefaultStyle(data);
                }

                // eslint-disable-next-line
                const zip = new JSZip(),
                    _rels = zip.folder('_rels'),
                    docProps = zip.folder('docProps'),
                    xl = zip.folder('xl');

                if (that.headerContent) {
                    const rows = that.headerContent;
                    const customRows = [];
                    for (let i = 0; i < rows.length; i++) {
                        const row = rows[i];
                        const cells = row.cells;
                        let customRow = {};
                        for (let j = 0; j < that.datafields.length; j++) {
                            const dataField = that.datafields[j];
                            if (cells[dataField]) {
                                customRow[dataField] = cells[dataField];
                            }
                            else {
                                customRow[dataField] = null;
                            }
                        }
                        customRows.push(customRow);
                    }
                    data = [...customRows, ...data];
                }

                if (that.footerContent) {
                    const rows = that.footerContent;
                    const customRows = [];
                    for (let i = 0; i < rows.length; i++) {
                        const row = rows[i];
                        const cells = row.cells;
                        let customRow = {};
                        for (let j = 0; j < that.datafields.length; j++) {
                            const dataField = that.datafields[j];
                            if (cells[dataField]) {
                                customRow[dataField] = cells[dataField];
                            }
                            else {
                                customRow[dataField] = null;
                            }
                        }
                        customRows.push(customRow);
                    }
                    data = [...data, ...customRows];
                }

                this.generateWorksheetImages(zip, xl, data);

                const sharedStrings = that.generateSharedStrings(data),
                    sharedStringsCollection = sharedStrings.collection,
                    sharedStringsXML = sharedStrings.xml,
                    stylesXML = that.generateStyles(style),
                    sheet1XML = that.groupBy ? that.generateSheet1WithGrouping(data, sharedStringsCollection) :
                        that.generateSheet1(data, sharedStringsCollection, that.datafields, that.columnsArray),
                    auxiliaryFiles = that.generateAuxiliaryFiles();


                let hasImages = false;
                const worksheetImages = this.worksheetImages.get(1);
                if (worksheetImages && worksheetImages.length) {
                    hasImages = true;
                }

                const xl_rels = xl.folder('_rels'),
                    theme = xl.folder('theme'),
                    worksheets = xl.folder('worksheets');

                if (hasImages) {
                    const media = xl.folder('media'),
                        drawings = xl.folder('drawings'),
                        drawingsRels = xl.folder('drawings/_rels');
                }

                _rels.file('.rels', auxiliaryFiles._relsRels);
                docProps.file('app.xml', auxiliaryFiles.docPropsAppXml);
                docProps.file('core.xml', auxiliaryFiles.docPropsCoreXml);
                xl_rels.file('workbook.xml.rels', auxiliaryFiles.xl_relsWorkbookXmlRels);
                theme.file('theme1.xml', auxiliaryFiles.xlThemeTheme1Xml);
                worksheets.file('sheet1.xml', sheet1XML);
                xl.file('sharedStrings.xml', sharedStringsXML);
                xl.file('styles.xml', stylesXML);
                xl.file('workbook.xml', auxiliaryFiles.xlWorkbookXml);
                zip.file('[Content_Types].xml', auxiliaryFiles.Content_TypesXml);


                if (this.spreadsheets) {
                    let sheetIndex = 2;
                    for (let s = 0; s < this.spreadsheets.length; s++) {
                        const sheet = this.spreadsheets[s];
                        const dataFields = sheet.dataFields;
                        let data = [...sheet.dataSource];

                        let header = [];
                        for (let i = 0; i < sheet.columns.length; i++) {
                            const column = sheet.columns[i];
                            if (typeof column === 'string') {
                                header[column] = column;
                            }
                            else {
                                header[column.dataField] = column.label || column.text;
                            }
                        }
                        data.splice(0, 0, header);
                        const sheet1XML = that.generateSheet1(data, sharedStringsCollection, dataFields, that.getColumnsArrayFromDataFields(dataFields), sheetIndex);
                        worksheets.file('sheet' + sheetIndex++ + '.xml', sheet1XML);
                    }
                }

                if (this.exportAsTable) {
                    const columnNames = Object.values(that.data[0]);

                    const createGUID = () => {
                        function part() {
                            return Math.floor((1 + Math.random()) * 0x10000)
                                .toString(16)
                                .substring(1);
                        }

                        return part() + part() + '-' + part() + '-' + part() + '-' + part() + '-' + part() + part() + part();
                    }

                    const dimensionEnd = (that.groupBy && that.groupBy.length) ? that.groupDimensionEnd : that.columnsArray[that.columnsArray.length - 1] + (data.length - 1);

                    let table = `<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" mc:Ignorable="xr xr3" id="1" name="Table1" displayName="Table1" ref="A${this.xlsxStartIndex}:${dimensionEnd}" totalsRowShown="0">
    <autoFilter ref="A${this.xlsxStartIndex}:${dimensionEnd}">`;
                    for (let i = 0; i < columnNames.length; i++) {
                        table += `<filterColumn colId="${i}" hiddenButton="0"/>
    `;
                    }
                    table += '</autoFilter>';
                    let tableColumns = `
    <tableColumns count="${columnNames.length}">`;

                    for (let i = 0; i < columnNames.length; i++) {
                        const column = columnNames[i];

                        tableColumns += `<tableColumn id="${i + 1}" name="${column}" dataCellStyle="Normal"/>
    `;
                    }
                    tableColumns += `
    </tableColumns>`;

                    table += tableColumns;
                    table += `
        <tableStyleInfo name="TableStyleLight1" showFirstColumn="0" showLastColumn="0" showRowStripes="1" showColumnStripes="0"/>
    </table>`;


                    const tables = xl.folder('tables');
                    tables.file('table1.xml', table);
                }

                zip.generateAsync({
                    type: 'blob',
                    mimeType:
                        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                })
                    .then(function (content) {
                        if (!fileName && callback) {
                            callback(content);
                        }
                        return that.downloadFile(content, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', fileName);
                    });

                delete that.conditionalFormattingXLSX;
                delete that.complexHeaderMergeInfo;
                delete that.defaultRowHeight;
                delete that.rowHeight;
            }

            /**
             * Processes grouping information.
             */
            processGroupingInformation(data, xlsx) {
                const that = this;

                if (!that.groupBy) {
                    return data;
                }

                let header;

                data = data.slice(0);

                if (that.exportHeader) {
                    if (xlsx && that.complexHeader) {
                        header = data.slice(0, that.complexHeader.length);
                        data.splice(0, that.complexHeader.length);
                    }
                    else {
                        header = [data[0]];
                        data.splice(0, 1);
                    }
                }

                if (data.length > 1) {
                    const getCompareFunction = function (a, knownDataType) {
                        // gets data type of column (not necessary if the Grid provides this information)
                        const dataType = knownDataType || typeof a;
                        let compareFunction;

                        switch (dataType) {
                            case 'string':
                                compareFunction = new Intl.Collator().compare;
                                break;
                            case 'number':
                                compareFunction = function (a, b) {
                                    return a - b;
                                };
                                break;
                            case 'boolean':
                            case 'bool':
                                compareFunction = function (a, b) {
                                    if (a === b) {
                                        return 0;
                                    }
                                    else if (a === false) {
                                        return -1;
                                    }
                                    else {
                                        return 1;
                                    }
                                };
                                break;
                            case 'date':
                            case 'time':
                            case 'dateTime':
                                if (a instanceof Date) {
                                    compareFunction = function (a, b) {
                                        return a.getTime() - b.getTime();
                                    };
                                }

                                break;
                            case 'object':
                                if (a instanceof Date) {
                                    compareFunction = function (a, b) {
                                        return a.getTime() - b.getTime();
                                    };
                                }


                                break;
                        }

                        return compareFunction;
                    }

                    const sortByMultipleColumns = function (dataSource, sortColumns, directions, customSortingCallback) {
                        if (!dataSource || !(Array.isArray(dataSource)) || dataSource.length === 0 ||
                            !sortColumns || Array.isArray(sortColumns) && sortColumns.length === 0) {
                            return;
                        }

                        if (typeof sortColumns === 'string') {
                            sortColumns = [sortColumns];
                        }

                        const directionCoefficients = [],
                            compareFunctions = [];

                        if (directions === undefined) {
                            directions = [];
                        }

                        for (let i = 0; i < sortColumns.length; i++) {
                            if (directions[i] === undefined || directions[i] === 'asc' || directions[i] === 'ascending') {
                                directionCoefficients[i] = 1;
                            }
                            else {
                                directionCoefficients[i] = -1;
                            }

                            compareFunctions[i] = getCompareFunction(dataSource[0][sortColumns[i]]);
                        }

                        if (customSortingCallback) {
                            customSortingCallback(dataSource, sortColumns, directions, compareFunctions);
                            return;
                        }

                        dataSource.sort(function (a, b) {
                            for (let i = 0; i < sortColumns.length; i++) {
                                const result = compareFunctions[i](a[sortColumns[i]], b[sortColumns[i]]);

                                if (result === 0) {
                                    if (sortColumns[i + 1]) {
                                        continue;
                                    }
                                    else if (a._index !== undefined) {
                                        // makes sorting stable
                                        return (a._index - b._index) * directionCoefficients[i];
                                    }

                                    return 0;
                                }

                                return result * directionCoefficients[i];
                            }
                        });
                    }

                    sortByMultipleColumns(data, that.groupBy);
                }

                if (header) {
                    data = header.concat(data);
                }

                that.getGroupLabels(data);

                return data;
            }

            /**
             * Exports to XML.
             */
            exportToXML(data, fileName) {
                const datafields = this.datafields.slice(0);
                let xmlContent = '<?xml version="1.0" encoding="UTF-8" ?>\n<table>\n';

                if (datafields.indexOf('rows') === -1) {
                    datafields.push('rows');
                }

                function recursion(records, indent) {
                    let content = '';

                    for (let i = 0; i < records.length; i++) {
                        const currentRecord = records[i];

                        content += indent + '<row>\n';

                        for (let j = 0; j < datafields.length; j++) {
                            const datafield = datafields[j];

                            if (datafield === 'rows') {
                                if (!currentRecord.rows) {
                                    continue;
                                }

                                content += `${indent}    <rows>\n${recursion(currentRecord.rows, indent + '        ')}${indent}    </rows>\n`;
                                continue;
                            }

                            content += indent + `    <${datafield}>${currentRecord[datafield]}</${datafield}>\n`;
                        }

                        content += indent + '</row>\n';
                    }

                    return content;
                }

                xmlContent += recursion(data, '    ') + '</table>';

                if (!fileName) {
                    return xmlContent;
                }

                return this.downloadFile(xmlContent, 'application/xml', fileName);
            }

            /**
             * Formats a date.
             */
            formatDate(value, format) {
                return value;
            }

            /**
             * Formats a number.
             */
            formatNumber(value, format) {
                return value;
            }

            /**
             * Generates auxiliary files necessary for XLSX.
             */
            generateAuxiliaryFiles() {
                // _rels\.rels
                const _relsRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>`;

                // docProps\app.xml
                const docPropsAppXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>`;

                // docProps\core.xml
                const now = new Date().toISOString(),
                    docPropsCoreXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator>Smart HTML Elements</dc:creator><cp:lastModifiedBy>Smart HTML Elements</cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">${now}</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">${now}</dcterms:modified></cp:coreProperties>`;

                // xl\_rels\workbook.xml.rels
                let relationShips = `<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>`;
                let relationShipId = 1;
                if (this.spreadsheets) {
                    for (let s = 0; s < this.spreadsheets.length; s++) {
                        const sheetId = 2 + s;
                        relationShipId++;
                        relationShips += `<Relationship Id="rId${sheetId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet${sheetId}.xml"/>`;
                    }
                }

                const xl_relsWorkbookXmlRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">${relationShips}<Relationship Id="rId${++relationShipId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId${++relationShipId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId${++relationShipId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/></Relationships>`;

                // xl\theme\theme1.xml
                const xlThemeTheme1Xml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=" Light"/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=" Light"/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface=""/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface=""/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>`;

                // xl\workbook.xml
                let sheets = '<sheet name="Sheet1" sheetId="1" r:id="rId1"/>';
                if (this.spreadsheets) {
                    for (let s = 0; s < this.spreadsheets.length; s++) {
                        const sheetId = 2 + s;
                        const sheet = this.spreadsheets[s];
                        sheets += `<sheet name="${sheet.label}" sheetId="${sheetId}" r:id="rId${sheetId}"/>`;
                    }
                }

                const xlWorkbookXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15 xr xr6 xr10 xr2" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr6="http://schemas.microsoft.com/office/spreadsheetml/2016/revision6" xmlns:xr10="http://schemas.microsoft.com/office/spreadsheetml/2016/revision10" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2"><fileVersion appName="xl" lastEdited="7" lowestEdited="7" rupBuild="20325"/><workbookPr defaultThemeVersion="166925"/><mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice Requires="x15"><x15ac:absPath url="C:\Users\jqwidgets\Desktop\" xmlns:x15ac="http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac"/></mc:Choice></mc:AlternateContent><xr:revisionPtr revIDLastSave="0" documentId="13_ncr:1_{0DEDCB6D-5403-4CD8-AAA5-59B6D238A8B6}" xr6:coauthVersionLast="34" xr6:coauthVersionMax="34" xr10:uidLastSave="{00000000-0000-0000-0000-000000000000}"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="19200" windowHeight="6950" xr2:uid="{0CB664E6-3800-4A88-B158-B46A682E7484}"/></bookViews><sheets>${sheets}</sheets><calcPr calcId="179021"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>`;

                const worksheetImages = this.worksheetImages.get(1);
                let drawings = '';
                if (worksheetImages && worksheetImages.length) {
                    drawings = '<Override PartName="/xl/drawings/drawing1.xml" ContentType="application/vnd.openxmlformats-officedocument.drawing+xml"/>';
                }

                let tables = '';
                if (this.exportAsTable) {
                    tables = '<Override PartName="/xl/tables/table1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"/>';
                }

                // [Content_Types].xml
                let sheetOverrides = `<Override PartName = "/xl/worksheets/sheet1.xml" ContentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />`;
                if (this.spreadsheets) {
                    for (let i = 0; i < this.spreadsheets.length; i++) {
                        sheetOverrides += `<Override PartName = "/xl/worksheets/sheet${i + 2}.xml" ContentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />`;
                    }
                }
                const Content_TypesXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="bin" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings"/><Default Extension="jpeg" ContentType="image/jpeg"/><Default Extension="png" ContentType="image/png"/><Default Extension="svg" ContentType="image/svg"/><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>${sheetOverrides}<Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>${tables}${drawings}<Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/><Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/></Types>`;

                return {
                    _relsRels: _relsRels,
                    docPropsAppXml: docPropsAppXml,
                    docPropsCoreXml: docPropsCoreXml,
                    xl_relsWorkbookXmlRels: xl_relsWorkbookXmlRels,
                    xlThemeTheme1Xml: xlThemeTheme1Xml,
                    xlWorkbookXml: xlWorkbookXml,
                    Content_TypesXml: Content_TypesXml
                };
            }

            /**
             * Generates default style object (for use in XLSX export).
             */
            generateDefaultStyle(data) {
                const that = this,
                    defaultStyle = {},
                    datafields = that.datafields,
                    firstRecord = that.complexHeader ? data[that.complexHeader.length] : data[+that.exportHeader];

                if (!firstRecord) {
                    return defaultStyle;
                }

                for (let i = 0; i < datafields.length; i++) {
                    const sampleValue = firstRecord[datafields[i]];

                    if (sampleValue instanceof Date) {
                        if (!defaultStyle.columns) {
                            defaultStyle.columns = [];
                        }

                        defaultStyle.columns[datafields[i]] = { format: 'd' };
                    }
                }

                return defaultStyle;
            }

            /**
             * Generates group row.
             */
            generateGroupRow(details) {
                const rowNumber = details.rowNumber,
                    from = 'A' + rowNumber,
                    recordXML = `        <row r="${rowNumber}" outlineLevel="${details.outlineLevel}" spans="1:${details.numberOfColumns}"${this.getCustomRowHeight(rowNumber - 1)} x14ac:dyDescent="0.45">
                <c r="${from}" t="s" s="0">
                    <v>${details.sharedStringIndex}</v>
                </c>
            </row>\n`;

                details.mergedCells.push({ from: from, to: this.columnsArray[details.numberOfColumns - 1] + rowNumber });

                return recordXML;
            }

            /**
             * Generates sharedStrings.xml.
             */
            generateSharedStrings(data) {
                const that = this,
                    datafields = that.datafields,
                    collection = [];
                let xml = '',
                    count = 0,
                    uniqueCount = 0;

                function addSharedString(currentValue) {
                    count++;

                    if (collection.indexOf(currentValue) === -1) {
                        uniqueCount++;
                        collection.push(currentValue);

                        currentValue = currentValue.replace(/&(?!amp;)/g, '&amp;');
                        currentValue = currentValue.replace(/'/g, '&apos;');
                        currentValue = currentValue.replace(/"/g, '&quot;');
                        currentValue = currentValue.replace(/>/g, '&gt;');
                        currentValue = currentValue.replace(/</g, '&lt;');

                        xml += `<si><t>${currentValue}</t></si>`;
                    }
                }

                const addSharedStrings = (data, datafields) => {
                    for (let i = 0; i < data.length; i++) {
                        const currentRecord = data[i];

                        for (let j = 0; j < datafields.length; j++) {
                            let currentValue = currentRecord[datafields[j]];

                            if (currentValue === null && !that.allowNull) {
                                currentValue = '';
                            }

                            if (typeof currentValue !== 'string') {
                                continue;
                            }

                            addSharedString(currentValue);
                        }
                    }
                }

                addSharedStrings(data, datafields);

                if (that.spreadsheets) {
                    for (let i = 0; i < that.spreadsheets.length; i++) {
                        const sheet = that.spreadsheets[i];
                        const datafields = sheet.dataFields;
                        let data = [...sheet.dataSource];

                        let header = [];
                        for (let i = 0; i < sheet.columns.length; i++) {
                            const column = sheet.columns[i];
                            if (typeof column === 'string') {
                                header[column] = column;
                            }
                            else {
                                header[column.dataField] = column.label;
                            }
                        }
                        data.splice(0, 0, header);
                        addSharedStrings(data, datafields);
                    }

                }

                if (that.groupLabels) {
                    for (let i = 0; i < that.groupLabels.length; i++) {
                        addSharedString(that.groupLabels[i]);
                    }
                }

                xml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="${count}" uniqueCount="${uniqueCount}">${xml}</sst>`;

                return { collection: collection, xml: xml };
            }


            /**
             * Generates sheet1.xml.
             */
            generateSheet1(data, sharedStrings, datafields, columnsArray, sheetIndex) {
                const that = this,
                    numberOfColumns = columnsArray.length,
                    numberOfRows = data.length,
                    dimensionEnd = columnsArray[numberOfColumns - 1] + numberOfRows,
                    autoFilter = that.getFilters(),
                    mergedCells = [].concat(that.complexHeaderMergedCells);
                let rIdCounter = 0;

                const addDrawingRel = (currentSheet2) => {
                    let xmlContent = '';

                    const worksheetImages = this.worksheetImages.get(currentSheet2);
                    if (worksheetImages && worksheetImages.length) {
                        xmlContent += `<drawing r:id="rId${++rIdCounter}"/>`;
                    }
                    return xmlContent;
                };
                const addTableRel = () => {
                    if (!that.exportAsTable) {
                        return '';
                    }

                    let xmlContent = `<tableParts count="1">
                    <tablePart r:id="rId${++rIdCounter}"/>
                </tableParts>`;

                    return xmlContent;
                };

                const freezeHeader = that.freezeHeader ? `<sheetView rightToLeft="0" workbookViewId="0">
             <pane state="frozen" topLeftCell="A${that.xlsxStartIndex + 1}" ySplit="${that.xlsxStartIndex}"/>
            </sheetView>` : '';

                let cols = that.getCustomColumnWidths(columnsArray);

                if (sheetIndex > 1) {
                    let colsString = '<cols>';
                    for (let i = 0; i < columnsArray.length; i++) {
                        colsString += '<col min="1" max="1" width="25" hidden="0" bestFit="0" customWidth="1"/>';
                    }
                    colsString += '</cols>';

                    cols = colsString;
                }

                const tabSelected = sheetIndex <= 1 ? 'tabSelected="1"' : '';

                let xmlContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac xr xr2 xr3" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" xr:uid="{7F25248B-C640-4C64-AD47-C0EA0E5D90D0}">
        <sheetPr filterMode="${autoFilter !== ''}" />
        <dimension ref="A1:${dimensionEnd}" />
        <sheetViews>
            <sheetView ${tabSelected} workbookViewId="0" />
            ${freezeHeader}
        </sheetViews>
        <sheetFormatPr defaultRowHeight="14.5" x14ac:dyDescent="0.35" />${cols}
        <sheetData>\n`;

                function r(col, row) {
                    return columnsArray[col] + row;
                }

                for (let i = 0; i <= data.length; i++) {
                    const currentRecord = data[i],
                        rowNumber = i + 1;
                    let collapsed = '';

                    if (that.actualHierarchy) {
                        const previousRecord = data[i - 1];

                        if (previousRecord && previousRecord._collapsed &&
                            (!currentRecord || previousRecord._level > currentRecord._level)) {
                            collapsed = ' collapsed="true"';
                        }
                    }

                    if (i === data.length) {
                        if (collapsed) {
                            xmlContent += `        <row r="${rowNumber}" outlineLevel="${Math.max(data[i - 1]._level - 2, 0)}" hidden="false" collapsed="true" />\n`;
                        }

                        break;
                    }

                    let recordXML = `        <row r="${rowNumber}"${that.getOutlineLevel(currentRecord)} hidden="${currentRecord._hidden || currentRecord._collapsed || false}"${collapsed} spans="1:${numberOfColumns}"${that.getCustomRowHeight(rowNumber - 1)} customHeight="1" x14ac:dyDescent="0.45">\n`;

                    for (let j = 0; j < datafields.length; j++) {
                        const s = that.getXLSXCellStyle(r(j, rowNumber));

                        recordXML += that.getActualCellData(currentRecord[datafields[j]], { r: r(j, rowNumber), s: s }, sharedStrings, rowNumber, datafields[j]);
                    }

                    recordXML += '        </row>\n';
                    xmlContent += recordXML;
                }

                if (that.headerContent) {
                    for (let m = 0; m < that.headerContent.length; m++) {
                        const row = that.headerContent[m];
                        if (row.style && row.style.mergeAcross) {
                            mergedCells.push({
                                from: 'A' + (m + 1),
                                to: columnsArray[numberOfColumns - 1] + (m + 1)
                            });
                        }
                    }
                }
                if (that.footerContent) {
                    for (let m = 0; m < that.footerContent.length; m++) {
                        const row = that.footerContent[m];
                        if (row.style && row.style.mergeAcross) {
                            mergedCells.push({
                                from: 'A' + (data.length - m),
                                to: columnsArray[numberOfColumns - 1] + (data.length - m)
                            });
                        }
                    }
                }
                xmlContent += `    </sheetData>${that.conditionalFormattingXLSX.conditions}${autoFilter}${that.getMergedCells(mergedCells)}
        <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />
        <pageSetup paperSize="9" orientation="portrait" r:id="rId1" />
        ${addDrawingRel(sheetIndex ? sheetIndex : 1)}
        ${addTableRel()}
    </worksheet>`;



                return xmlContent;
            }

            /**
             * Generates sheet1.xml with grouping.
             */
            generateSheet1WithGrouping(data, sharedStrings) {
                const that = this,
                    numberOfColumns = that.columnsArray.length,
                    numberOfRows = data.length,
                    dimensionEnd = that.columnsArray[numberOfColumns - 1] + numberOfRows,
                    datafields = that.datafields,
                    mergedCells = [].concat(that.complexHeaderMergedCells);
                let rIdCounter = 0;

                const addDrawingRel = (currentSheet2) => {
                    let xmlContent = '';

                    const worksheetImages = this.worksheetImages.get(currentSheet2);
                    if (worksheetImages && worksheetImages.length) {
                        xmlContent += `<drawing r:id="rId${++rIdCounter}"/>`;
                    }
                    return xmlContent;
                };
                const addTableRel = () => {
                    if (!that.exportAsTable) {
                        return '';
                    }

                    let xmlContent = `<tableParts count="1">
                    <tablePart r:id="rId${++rIdCounter}"/>
                </tableParts>`;

                    return xmlContent;
                };
                const freezeHeader = that.freezeHeader ? `<sheetView rightToLeft="0" workbookViewId="0">
             <pane state="frozen" topLeftCell="A${that.xlsxStartIndex + 1}" ySplit="${that.xlsxStartIndex}"/>
            </sheetView>` : '';
                let xmlContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac xr xr2 xr3" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision" xmlns:xr2="http://schemas.microsoft.com/office/spreadsheetml/2015/revision2" xmlns:xr3="http://schemas.microsoft.com/office/spreadsheetml/2016/revision3" xr:uid="{7F25248B-C640-4C64-AD47-C0EA0E5D90D0}">
        <dimension ref="A1:${dimensionEnd}" />
        <sheetViews>
            <sheetView tabSelected="1" workbookViewId="0" />
            ${freezeHeader}
        </sheetViews>
        <sheetFormatPr defaultRowHeight="14.5" x14ac:dyDescent="0.35" />${that.getCustomColumnWidths()}
        <sheetData>\n`,
                    rowNumberCorrection = 0,
                    groupsHandled = [];

                function r(col, row) {
                    return that.columnsArray[col] + row;
                }

                mainLoop:
                for (let i = 0; i < data.length; i++) {
                    const currentRecord = data[i],
                        rowNumber = i + 1 + rowNumberCorrection;
                    let outlineLevel = 0,
                        outlineXML = '';

                    if (!that.exportHeader ||
                        (!that.complexHeader && i !== 0) ||
                        (that.complexHeader && i >= that.complexHeader.length)) {
                        let groupId = '';

                        for (let k = 0; k < that.groupBy.length; k++) {
                            const datafield = that.groupBy[k],
                                currentGroup = currentRecord[datafield],
                                currentGroupLabel = that.groups[datafield][currentGroup];

                            groupId += currentGroup;

                            if (groupsHandled.indexOf(groupId) === -1) {
                                let sharedStringIndex = sharedStrings.indexOf(currentGroupLabel);

                                xmlContent += that.generateGroupRow({
                                    rowNumber: rowNumber,
                                    outlineLevel: outlineLevel,
                                    numberOfColumns: numberOfColumns,
                                    sharedStringIndex: sharedStringIndex,
                                    mergedCells: mergedCells
                                });
                                groupsHandled.push(groupId);
                                i--;
                                rowNumberCorrection++;
                                continue mainLoop;
                            }

                            outlineLevel++;
                        }

                        outlineXML = ` outlineLevel="${outlineLevel}"`;
                    }

                    let recordXML = `        <row r="${rowNumber}"${outlineXML} spans="1:${numberOfColumns}"${that.getCustomRowHeight(rowNumber - 1)} customHeight="1" x14ac:dyDescent="0.45">\n`;

                    for (let j = 0; j < datafields.length; j++) {
                        const s = that.getXLSXCellStyle(r(j, i + 1));

                        recordXML += that.getActualCellData(currentRecord[datafields[j]], { r: r(j, rowNumber), s: s }, sharedStrings, rowNumber, datafields[j]);
                    }

                    recordXML += '        </row>\n';
                    xmlContent += recordXML;
                }

                xmlContent += `    </sheetData>${!that.exportAsTable ? that.getMergedCells(mergedCells) : ''}
        <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />
        <pageSetup paperSize="9" orientation="portrait" r:id="rId1" />
        ${addDrawingRel(1)}
        ${addTableRel()}
    </worksheet>`;

                that.groupDimensionEnd = that.columnsArray[numberOfColumns - 1] + (numberOfRows + rowNumberCorrection);
                that.groupRowsCount = numberOfRows + rowNumberCorrection;
                return xmlContent;
            }

            isFormula(value) {
                if (value === null) {
                    return false;
                }
                return this.autoConvertFormulas && value.toString().startsWith('=');
            }

            /**
             * Gets actual spreadsheet cell data.
             */
            getActualCellData(currentValue, details, sharedStrings) {
                const r = details.r,
                    s = details.s || ' s="0"';

                if (currentValue === null && !this.allowNull) {
                    currentValue = '';
                }

                if (currentValue && this.isFormula(currentValue)) {
                    return `            <c r="${r}" t="s"${s}>
                    <f>${currentValue.slice(1)}</f>
                </c>\n`;
                }

                if (typeof currentValue === 'string') {
                    return `            <c r="${r}" t="s"${s}>
                    <v>${sharedStrings.indexOf(currentValue)}</v>
                </c>\n`;
                }

                if (typeof currentValue === 'boolean') {
                    return `            <c r="${r}" t="b"${s}>
                    <v>${+currentValue}</v>
                </c>\n`;
                }

                if (currentValue instanceof Date) {
                    //    const timeZoneOffset = currentValue.getTimezoneOffset() * 1000 * 60;
                    //    const excelDate = (currentValue.getTime() + this.timeBetween1900And1970 - timeZoneOffset) / (1000 * 60 * 60 * 24) + 3;

                    const timeBetweenJSandExcel = 2 + Math.round(this.timeBetween1900And1970 / (1000 * 60 * 60 * 24));
                    const excelDateTime = timeBetweenJSandExcel + ((currentValue.getTime() - (currentValue.getTimezoneOffset() * 60 * 1000)) / (1000 * 60 * 60 * 24));

                    return `            <c r="${r}"${s}>
                    <v>${excelDateTime}</v>
                </c>\n`;
                }

                // numeric cells
                return `            <c r="${r}"${s}>
                    <v>${currentValue}</v>
                </c>\n`;
            }

            /**
             * Gets column labels.
             */
            getColumnsArray() {
                const that = this,
                    numberOfColumns = that.datafields.length,
                    columnsCollection = [];

                function getIterator(i) {
                    if (i < 26) {
                        return '';
                    }

                    return String.fromCharCode(64 + Math.floor(i / 26));
                }

                for (let i = 0; i < numberOfColumns; i++) {
                    columnsCollection.push(getIterator(i) + String.fromCharCode(65 + (i < 26 ? i : i % 26)));
                }

                that.columnsArray = columnsCollection;
            }

            /**
           * Gets column labels.
           */
            getColumnsArrayFromDataFields(datafields) {
                const that = this,
                    numberOfColumns = datafields.length,
                    columnsCollection = [];

                function getIterator(i) {
                    if (i < 26) {
                        return '';
                    }

                    return String.fromCharCode(64 + Math.floor(i / 26));
                }

                for (let i = 0; i < numberOfColumns; i++) {
                    columnsCollection.push(getIterator(i) + String.fromCharCode(65 + (i < 26 ? i : i % 26)));
                }

                return columnsCollection;
            }

            /**
             * Gets column style.
             */
            getColumnStyle() {
                const that = this,
                    style = that.style;

                if (!style) {
                    return `        .header { border: 1px solid black; padding: 5px; }
            .column { border: 1px solid black; padding: 5px; }
            .group { background-color: #FFFFFF; color: #000000; font-weight: bold; }`;
                }

                let styles;

                if (style.removeDefault) {
                    styles = {
                        header: '',
                        column: '',
                        group: ''
                    };
                }
                else {
                    styles = {
                        header: 'border: 1px solid black; padding: 5px; ',
                        column: 'white-space: nowrap; overflow: hidden; border: 1px solid black; padding: 5px; ',
                        group: 'background-color: #FFFFFF; color: #000000; font-weight: bold; '
                    };
                }

                const sampleRecord = that.data[0];
                let generatedStyle = '';

                const headerDefinition = style.header || {};

                for (let prop in headerDefinition) {
                    if (!Object.prototype.hasOwnProperty.call(headerDefinition, prop)) {
                        continue;
                    }

                    const value = headerDefinition[prop];

                    if (sampleRecord[prop]) {
                        if (!styles['header' + prop]) {
                            styles['header' + prop] = '';
                        }

                        for (let columnProp in value) {
                            if (Object.prototype.hasOwnProperty.call(value, columnProp)) {
                                const css = window.jqxToDash(columnProp) + ': ' + value[columnProp] + '; ';

                                styles['header' + prop] += css;

                                if (columnProp === 'width') {
                                    if (!styles['column' + prop]) {
                                        styles['column' + prop] = '';
                                    }

                                    styles['column' + prop] += css;
                                }
                            }
                        }

                        continue;
                    }

                    if (prop === 'height' && that.complexHeader) {
                        styles.header += 'height: ' + parseInt(headerDefinition[prop], 10) / that.complexHeader.length + 'px; ';
                    }
                    else {
                        styles.header += window.jqxToDash(prop) + ': ' + headerDefinition[prop] + '; ';
                    }
                }

                const columnsDefinition = style.columns || {};

                for (let prop in columnsDefinition) {
                    if (!Object.prototype.hasOwnProperty.call(columnsDefinition, prop)) {
                        continue;
                    }

                    const value = columnsDefinition[prop];

                    if (sampleRecord[prop]) {
                        if (!styles['column' + prop]) {
                            styles['column' + prop] = '';
                        }

                        for (let columnProp in value) {
                            if (isNaN(columnProp) && Object.prototype.hasOwnProperty.call(value, columnProp) && columnProp !== 'format') {
                                styles['column' + prop] += window.jqxToDash(columnProp) + ': ' + value[columnProp] + '; ';
                            }
                        }

                        continue;
                    }

                    styles.column += window.jqxToDash(prop) + ': ' + value + '; ';
                }

                for (let prop in styles) {
                    if (Object.prototype.hasOwnProperty.call(styles, prop)) {
                        generatedStyle += `        .${prop} { ${styles[prop]}}\n`;
                    }
                }

                if (style.custom) {
                    generatedStyle += `${style.custom}\n`;
                }

                return generatedStyle;
            }

            /**
             * Gets custom column widths.
             */
            getCustomColumnWidths(columnsArray) {
                const that = this;

                if (columnsArray !== that.columnsArray) {
                    return '';
                }

                if (!that.style || !that.columnWidth || that.columnWidth.length === 0) {
                    return '';
                }

                let xml = '\n    <cols>\n';

                for (let i = 0; i < that.columnWidth.length; i++) {
                    let width = that.columnWidth[i];

                    if (width !== undefined) {
                        width = Math.round(parseFloat(width)) / 7;
                        xml += `        <col min="${i + 1}" max="${i + 1}" width="${width}" customWidth="1" />\n`;
                    }
                }

                xml += '    </cols>';

                return xml;
            }

            /**
             * Returns customFilter tag.
             */
            getCustomFilter(value, condition) {
                let operator = 'equal',
                    val;

                if (value instanceof Date) {
                    value = (value.getTime() + this.timeBetween1900And1970) / 86400000 + 2;
                }

                condition = condition.toUpperCase();

                switch (condition) {
                    case 'EMPTY':
                        val = '';
                        break;
                    case 'NOT_EMPTY':
                        val = '';
                        operator = 'notEqual';
                        break;
                    case 'CONTAINS':
                    case 'CONTAINS_CASE_SENSITIVE':
                        val = `*${value}*`;
                        break;
                    case 'DOES_NOT_CONTAIN':
                    case 'DOES_NOT_CONTAIN_CASE_SENSITIVE':
                        val = `*${value}*`;
                        operator = 'notEqual';
                        break;
                    case 'STARTS_WITH':
                    case 'STARTS_WITH_CASE_SENSITIVE':
                        val = `${value}*`;
                        break;
                    case 'ENDS_WITH':
                    case 'ENDS_WITH_CASE_SENSITIVE':
                        val = `*${value}`;
                        break;
                    case 'EQUAL':
                    case 'EQUAL_CASE_SENSITIVE':
                        val = value;
                        break;
                    case 'NULL':
                        val = null;
                        break;
                    case 'NOT_NULL':
                        val = null;
                        operator = 'notEqual';
                        break;
                    case 'NOT_EQUAL':
                        val = value;
                        operator = 'notEqual';
                        break;
                    case 'LESS_THAN':
                        val = value;
                        operator = 'lessThan';
                        break;
                    case 'LESS_THAN_OR_EQUAL':
                        val = value;
                        operator = 'lessThanOrEqual';
                        break;
                    case 'GREATER_THAN':
                        val = value;
                        operator = 'greaterThan';
                        break;
                    case 'GREATER_THAN_OR_EQUAL':
                        val = value;
                        operator = 'greaterThanOrEqual';
                        break;
                }

                return `                <customFilter val="${val}" operator="${operator}"/>\n`;
            }

            /**
             * Gets custom row height.
             */
            getCustomRowHeight(row) {
                const that = this;

                if (that.style) {
                    return that.rowHeight[row] || that.defaultRowHeight || '';
                }

                return '';
            }

            /**
             * Gets datafields.
             */
            getDatafields(data) {
                const that = this,
                    sampleRecord = data[0],
                    datafields = [];

                for (let prop in sampleRecord) {
                    if (Object.prototype.hasOwnProperty.call(sampleRecord, prop) && prop.charAt(0) !== '_') {
                        datafields.push(prop);
                    }
                }

                that.datafields = datafields;
            }

            /**
             * Returns autoFilter XML.
             */
            getFilters() {
                const that = this,
                    filterBy = that.filterBy;

                if (!filterBy) {
                    return '';
                }

                let xml = '';

                for (let datafield in filterBy) {
                    if (Object.prototype.hasOwnProperty.call(filterBy, datafield)) {
                        const colId = that.datafields.indexOf(datafield);

                        if (colId === -1) {
                            continue;
                        }

                        const filterDetails = filterBy[datafield],
                            filters = filterDetails.filters;

                        xml += `        <filterColumn colId="${colId}">
                <customFilters and="${!filterDetails.operator}">\n`;

                        for (let i = 0; i < filters.length; i++) {
                            xml += that.getCustomFilter(filters[i].value, filters[i].condition);
                        }

                        xml += `            </customFilters>
            </filterColumn>`;
                    }
                }

                if (!xml) {
                    return '';
                }

                xml = `\n    <autoFilter ref="A1:${that.columnsArray[that.columnsArray.length - 1] + that.data.length}">\n${xml}\n    </autoFilter>`;
                return xml;
            }

            /**
             * Gets group labels based on data.
             */
            getGroupLabels(data) {
                const that = this,
                    startIndex = that.xlsxStartIndex !== undefined ? that.xlsxStartIndex : +that.exportHeader,
                    groups = {},
                    groupLabels = [];

                for (let i = startIndex; i < data.length; i++) {
                    const currentRecord = data[i];

                    for (let j = 0; j < that.groupBy.length; j++) {
                        const datafield = that.groupBy[j],
                            currentValue = currentRecord[datafield];
                        let group = groups[datafield];

                        if (group === undefined) {
                            groups[datafield] = {};
                            group = groups[datafield];
                        }

                        if (group[currentValue] === undefined) {
                            group[currentValue] = (that.exportHeader ? data[startIndex - 1][datafield] : datafield) + ': ' + currentValue;
                            groupLabels.push(group[currentValue]);
                        }
                    }
                }

                that.groups = groups;
                that.groupLabels = groupLabels;
            }

            /**
             * Gets the header content when exporting to HTML.
             */
            getHTMLHeader(datafields, data) {
                const that = this;
                let header = '\n        <thead>\n';

                if (!that.complexHeader) {
                    header += '            <tr>\n';

                    for (let j = 0; j < datafields.length; j++) {
                        const datafield = datafields[j];

                        header += `                <th class="header header${datafield}">${data[0][datafield]}</th>\n`;
                    }

                    header += '            </tr>\n        </thead>';
                    return header;
                }

                for (let j = 0; j < that.complexDataFieldsHeader.length; j++) {
                    const row = that.complexDataFieldsHeader[j];

                    header += '            <tr>\n';

                    for (let k = 0; k < row.length; k++) {
                        const currentLabel = row[k];
                        let colspan = 1, rowspan = 1;

                        if ((row[k - 1] && row[k - 1] === currentLabel) ||
                            (that.complexDataFieldsHeader[j - 1] && (that.complexDataFieldsHeader[j - 1][k] === currentLabel))) {
                            continue;
                        }

                        let iterator = k + 1;

                        while (row[iterator] && row[iterator] === row[iterator - 1]) {
                            colspan++;
                            iterator++;
                        }

                        iterator = j + 1;

                        while (that.complexDataFieldsHeader[iterator] && that.complexDataFieldsHeader[iterator][k] === currentLabel) {
                            rowspan++;
                            iterator++;
                        }

                        const datafield = j === that.complexHeader.length - 1 || rowspan + j === that.complexHeader.length ?
                            ' header' + datafields[k] : '';

                        header += `                <th class="header${datafield}" colspan="${colspan}" rowspan="${rowspan}">${that.complexHeader[j][k]}</th>\n`;
                    }

                    header += '            </tr>\n';
                }

                header += '        </thead>';
                return header;
            }

            /**
             * Gets conditional formatting XML.
             */
            getConditionalFormatting() {
                const that = this,
                    conditionalFormatting = that.conditionalFormatting;

                if (!conditionalFormatting) {
                    that.conditionalFormattingXLSX = { conditions: '', styles: '' };
                    return;
                }

                const dxfCodes = [];
                let conditionsXml = '',
                    stylesXml = '';

                for (let i = conditionalFormatting.length - 1; i >= 0; i--) {
                    const columnFormat = conditionalFormatting[i],
                        columnLetter = that.columnsArray[that.datafields.indexOf(columnFormat.column)],
                        startCell = columnLetter + (that.xlsxStartIndex + 1),
                        sqref = startCell + ':' + columnLetter + (that.data.length),
                        dxfCode = columnFormat.background + columnFormat.color,
                        attr = that.getConditionalAttributes(columnFormat, startCell);
                    let dxfId = dxfCodes.indexOf(dxfCode);

                    if (dxfId === -1) {
                        const newDxf = `        <dxf>
                <font>
                    <b val="0"/>
                    <i val="0"/>
                    <color rgb="${columnFormat.color === 'White' ? 'FFFFFFFF' : 'FF000000'}"/>
                    <sz val="10"/>
                </font>
                <fill>
                    <patternFill>
                        <bgColor rgb="${that.toARGB(columnFormat.background)}"/>
                    </patternFill>
                </fill>
            </dxf>\n`;

                        stylesXml += newDxf;
                        dxfId = dxfCodes.length;
                        dxfCodes.push(dxfCode);
                    }

                    conditionsXml += `    <conditionalFormatting sqref="${sqref}">
            <cfRule dxfId="${dxfId}" text="${attr.text}" rank="${attr.rank}" percent="${attr.percent}" bottom="${attr.bottom}" equalAverage="${attr.equalAverage}" aboveAverage="${attr.aboveAverage}"${attr.operator}${attr.timePeriod} priority="${i + 2}" type="${attr.type}">
    ${attr.formula}        </cfRule>
        </conditionalFormatting>\n`;
                }

                stylesXml = `    <dxfs count="${dxfCodes.length}">\n${stylesXml}    </dxfs>`;

                that.conditionalFormattingXLSX = { conditions: conditionsXml, styles: stylesXml };
            }

            /**
             * Gets conditional formatting XML attributes.
             */
            getConditionalAttributes(columnFormat, startCell) {
                let condition = columnFormat.condition,
                    comparator = columnFormat.comparator,
                    text = '',
                    rank = 0,
                    percent = 0,
                    bottom = 0,
                    equalAverage = 0,
                    aboveAverage = 0,
                    operator = '',
                    timePeriod = '',
                    type = '',
                    formula = '';

                switch (condition) {
                    case 'equal':
                        operator = 'equal';
                        type = 'cellIs';
                        formula = `            <formula>${comparator}</formula>\n`;
                        break;
                    case 'lessThan':
                        operator = 'lessThan';
                        type = 'cellIs';
                        formula = `            <formula>${comparator}</formula>\n`;
                        break;
                    case 'greaterThan':
                        operator = 'greaterThan';
                        type = 'cellIs';
                        formula = `            <formula>${comparator}</formula>\n`;
                        break;
                    case 'notEqual':
                        operator = 'notEqual';
                        type = 'cellIs';
                        formula = `            <formula>${comparator}</formula>\n`;
                        break;
                    case 'between':
                        operator = 'between';
                        type = 'cellIs';
                        formula = `            <formula>${columnFormat.min}</formula>
                <formula>${columnFormat.max}</formula>\n`;
                        break;
                    case 'duplicate':
                        type = 'duplicateValues';
                        formula = '            <formula>0</formula>\n';
                        break;
                    case 'topNItems':
                        rank = comparator;
                        type = 'top10';
                        break;
                    case 'bottomNItems':
                        rank = comparator;
                        bottom = 1;
                        type = 'top10';
                        break;
                    case 'topNPercent':
                        rank = comparator;
                        percent = 1;
                        type = 'top10';
                        break;
                    case 'bottomNPercent':
                        rank = comparator;
                        percent = 1;
                        bottom = 1;
                        type = 'top10';
                        break;
                    case 'aboveAverage':
                        aboveAverage = 1;
                        type = 'aboveAverage';
                        formula = '            <formula>0</formula>\n';
                        break;
                    case 'belowAverage':
                        type = 'aboveAverage';
                        formula = '            <formula>0</formula>\n';
                        break;
                    case 'contains':
                        text = comparator;
                        operator = 'containsText';
                        type = 'containsText';
                        formula = `            <formula>NOT(ISERROR(SEARCH("${comparator}",${startCell})))</formula>\n`;
                        break;
                    case 'doesNotContain':
                        text = comparator;
                        operator = 'notContains';
                        type = 'notContainsText';
                        formula = `            <formula>ISERROR(SEARCH("${comparator}",${startCell}))</formula>\n`;
                        break;
                    case 'dateOccur':
                        timePeriod = ` timePeriod="${comparator}"`;
                        type = 'timePeriod';
                        break;
                }

                if (operator) {
                    operator = ` operator="${operator}" `;
                }

                return {
                    text: text,
                    rank: rank,
                    percent: percent,
                    bottom: bottom,
                    equalAverage: equalAverage,
                    aboveAverage: aboveAverage,
                    operator: operator,
                    timePeriod: timePeriod,
                    type: type,
                    formula: formula
                }
            }

            /**
             * Gets merged cells XML.
             */
            getMergedCells(mergedCells) {
                const that = this;

                let mergeCellsXml = '';

                for (let i = 0; i < mergedCells.length; i++) {
                    if (mergedCells[i].from === mergedCells[i].to) {
                        continue;
                    }

                    mergeCellsXml += `\n        <mergeCell ref="${mergedCells[i].from}:${mergedCells[i].to}" />\n`;
                }

                if (that.mergedCells) {
                    for (let i = 0; i < that.mergedCells.length; i++) {
                        const cellDefinition = that.mergedCells[i];

                        if (cellDefinition.rowspan < 2 && cellDefinition.colspan < 2) {
                            continue;
                        }

                        const from = that.columnsArray[cellDefinition.cell[0]] + (cellDefinition.cell[1] + that.xlsxStartIndex + 1),
                            to = that.columnsArray[cellDefinition.cell[0] + cellDefinition.colspan - 1] + (cellDefinition.cell[1] + that.xlsxStartIndex + cellDefinition.rowspan);

                        mergeCellsXml += `\n        <mergeCell ref="${from}:${to}" />\n`;
                    }
                }

                if (mergeCellsXml) {
                    mergeCellsXml = `\n    <mergeCells count="${mergedCells.length}">${mergeCellsXml}    </mergeCells>`;
                }

                return mergeCellsXml;
            }

            /**
             * Gets numFmt index.
             */
            getNumFmtIndex(format, numFmts) {
                let index = numFmts.collection.indexOf(format);

                if (index === -1) {
                    index = numFmts.collection.length + 100;
                    numFmts.collection.push(format);
                    numFmts.xml += `<numFmt numFmtId="${index}" formatCode="${format}"/>`;
                }
                else {
                    index += 100;
                }

                return index;
            }

            /**
                * Returns outlineLevel.
                */
            getOutlineLevel(record) {
                if (!this.actualHierarchy || record._level === 1) {
                    return '';
                }

                return ` outlineLevel="${record._level - 1}"`;
            }

            /**
             * Gets row style.
             */
            getRowStyle() {
                const that = this,
                    style = that.style;

                if (!style) {
                    return '';
                }

                const rowsDefinition = style.rows;

                if (!rowsDefinition) {
                    return '';
                }

                const styles = {
                    row: ''
                };
                let generatedStyle = '';

                for (let prop in rowsDefinition) {
                    if (!Object.prototype.hasOwnProperty.call(rowsDefinition, prop) ||
                        prop === 'alternationCount' ||
                        prop === 'alternationStart' ||
                        prop === 'alternationEnd') {
                        continue;
                    }

                    const value = rowsDefinition[prop];

                    if (prop.indexOf('alt') !== -1) {
                        const i = prop.slice(16, 17),
                            property = prop.slice(17);

                        if (!styles['rowN' + i]) {
                            styles['rowN' + i] = '';
                        }

                        if (property === 'Color') {
                            styles['rowN' + i] += 'color : ' + value + '; ';
                        }
                        else if (property === 'BorderColor') {
                            styles['rowN' + i] += 'border-color : ' + value + '; ';
                        }
                        else {
                            styles['rowN' + i] += 'background-color : ' + value + '; ';
                        }

                        continue;
                    }

                    if (!isNaN(prop)) {
                        if (!styles['row' + prop]) {
                            styles['row' + prop] = '';
                        }

                        for (let rowProp in value) {
                            if (Object.prototype.hasOwnProperty.call(value, rowProp)) {
                                styles['row' + prop] += window.jqxToDash(rowProp) + ': ' + value[rowProp] + '; ';
                            }
                        }

                        continue;
                    }

                    styles.row += window.jqxToDash(prop) + ': ' + rowsDefinition[prop] + '; ';
                }

                let keys = Object.keys(styles);

                keys.sort(function (a, b) {
                    if (a === 'row') {
                        return -1;
                    }

                    if (b === 'row') {
                        return 1;
                    }

                    const aIsNum = !isNaN(a.slice(3)),
                        bIsNum = !isNaN(b.slice(3));

                    if (aIsNum && !bIsNum) {
                        return 1;
                    }

                    if (!aIsNum && bIsNum) {
                        return -1;
                    }

                    return +(a < b);
                });

                for (let i = 0; i < keys.length; i++) {
                    generatedStyle += `        .${keys[i]} { ${styles[keys[i]]}}\n`;
                }

                return generatedStyle;
            }

            /**
             * Gets table style.
             */
            getTableStyle() {
                const that = this,
                    style = that.style;

                if (!style) {
                    return ' style="table-layout: fixed; border: 1px solid black; border-collapse: collapse;"';
                }

                let generatedStyle = 'table-layout: fixed; ';

                for (let prop in style) {
                    if (Object.prototype.hasOwnProperty.call(style, prop) &&
                        ['header', 'columns', 'rows', 'removeDefault', 'custom'].indexOf(prop) === -1) {
                        generatedStyle += window.jqxToDash(prop) + ': ' + style[prop] + '; ';
                    }
                }

                if (generatedStyle) {
                    generatedStyle = ' style="' + generatedStyle + '"';
                }

                return generatedStyle;
            }

            /**
             * Gets the "s" (style) attribute of an XLSX cell.
             */
            getXLSXCellStyle(r) {
                const that = this;

                if (that.cellStyleMapping[r] !== undefined) {
                    return ` s="${that.cellStyleMapping[r]}"`;
                }

                return '';
            }

            /**
             * Gets the "s" (style) attribute of an XLSX cell.
             */
            getXLSXFormat(format, cellValue) {
                if (typeof cellValue === 'number') {
                    let currencySign = '$';
                    if (format && typeof (format) === 'string' && format.indexOf('c') >= 0 && format.indexOf('x') >= 0) {
                        currencySign = format.substring(0, format.indexOf('x'));
                        format = format.substring(1 + format.indexOf('x'));
                    }

                    if (!/^([a-zA-Z]\d*)$/g.test(format)) {
                        return format;
                    }

                    let precision = parseFloat(format.slice(1)) || 0,
                        precisionCode = precision > 0 ? '.' + ('0').repeat(precision) : '';

                    format = format.slice(0, 1);

                    switch (format) {
                        case 'C':
                        case 'c':
                            if (currencySign !== '$') {
                                return '\#,0' + precisionCode + ' ' + currencySign;
                            }
                            return currencySign + '\#,0' + precisionCode;
                        case 'D':
                        case 'd':
                            if (precision) {
                                return ('0').repeat(precision);
                            }

                            return '0';
                        case 'E':
                        case 'e':
                            return '0' + precisionCode + format + '000';
                        case 'F':
                        case 'f':
                            return '0' + precisionCode;
                        case 'N':
                        case 'n':
                            return '#,0' + precisionCode;
                        case 'P':
                        case 'p':
                            return '#,0' + precisionCode + ' %';
                        default:
                            return;
                    }
                }
                else if (cellValue instanceof Date) {
                    switch (format) {
                        case 'd':
                            return 'm/d/yyyy';
                        case 'D':
                            return 'nnnnmmmm dd, yyyy';
                        case 't':
                            return 'h:m AM/PM';
                        case 'T':
                            return 'h:mm:ss AM/PM';
                        case 'f':
                            return 'nnnnmmmm dd, yyyy h:m AM/PM';
                        case 'F':
                            return 'nnnnmmmm dd, yyyy h:mm:ss AM/PM';
                        case 'M':
                            return 'mmmm d';
                        case 'Y':
                            return 'yyyy mmmm';
                        case 'FP':
                        case 'PP':
                            return 'yyyy-mm-dd hh:mm:ss';
                        case 'FT':
                        case 'PT':
                            return 'hh:mm:ss';
                    }

                    format = format.replace(/f|u|n|p|e|a|x|o/gi, '');
                    format = format.replace(/tt/gi, 'AM/PM');
                    format = format.replace(/:{2,}|:\s|:$|\.$/g, '');
                    format = format.trim();
                    return format;
                }
            }

            /**
             * Processes column styles.
             */
            processColumnStyle(style) {
                const that = this,
                    headerDefinition = style.header,
                    columnsDefinition = style.columns,
                    sampleRecord = that.data[0],
                    startIndex = that.xlsxStartIndex;

                that.columnWidth = [];

                if (startIndex && headerDefinition) {
                    for (let i = 0; i < that.columnsArray.length; i++) {
                        const columnLetter = that.columnsArray[i],
                            cell = columnLetter + startIndex,
                            columnSpecific = headerDefinition[that.datafields[i]];

                        for (let prop in headerDefinition) {
                            if (Object.prototype.hasOwnProperty.call(headerDefinition, prop) && sampleRecord[prop] === undefined) {
                                if (that.complexHeader) {
                                    for (let j = 0; j < that.complexHeader.length; j++) {
                                        if (prop === 'height') {
                                            that.rowHeight[j] = ` ht="${(parseFloat(headerDefinition.height) / 1) / 2}"`;
                                            continue;
                                        }
                                        else {
                                            that.storeCellStyle(columnLetter + (j + 1), prop, headerDefinition[prop]);
                                        }
                                    }
                                }
                                else {
                                    if (prop === 'height') {
                                        that.rowHeight[startIndex - 1] = ` ht="${parseFloat(headerDefinition.height) / 2}"`;
                                        continue;
                                    }

                                    that.storeCellStyle(cell, prop, headerDefinition[prop]);
                                }
                            }
                        }

                        if (!columnSpecific) {
                            continue;
                        }

                        for (let prop in columnSpecific) {
                            if (Object.prototype.hasOwnProperty.call(columnSpecific, prop)) {
                                if (prop === 'width') {
                                    that.columnWidth[i] = columnSpecific.width;
                                    continue;
                                }

                                that.storeCellStyle(cell, prop, columnSpecific[prop]);
                            }
                        }
                    }
                }
                else if (headerDefinition) {
                    for (let i = 0; i < that.columnsArray.length; i++) {
                        const columnSpecific = headerDefinition[that.datafields[i]];

                        if (columnSpecific && columnSpecific.width !== undefined) {
                            that.columnWidth[i] = columnSpecific.width;
                        }
                    }
                }

                if (!columnsDefinition) {
                    return '';
                }

                for (let i = startIndex; i < that.data.length; i++) {
                    for (let j = 0; j < that.columnsArray.length; j++) {
                        const columnLetter = that.columnsArray[j],
                            cell = columnLetter + (i + 1),
                            datafield = that.datafields[j],
                            columnSpecific = columnsDefinition[datafield];

                        for (let prop in columnsDefinition) {
                            if (Object.prototype.hasOwnProperty.call(columnsDefinition, prop) && sampleRecord[prop] === undefined) {
                                that.storeCellStyle(cell, prop, columnsDefinition[prop]);
                            }
                        }

                        if (!columnSpecific) {
                            continue;
                        }

                        for (let prop in columnSpecific) {
                            if (!isNaN(prop) || !Object.prototype.hasOwnProperty.call(columnSpecific, prop)) {
                                continue;
                            }

                            that.storeCellStyle(cell, prop, columnSpecific[prop], that.data[i][datafield]);
                        }

                        if (columnSpecific[i]) {
                            const cellProperties = columnSpecific[i];
                            for (let prop in cellProperties) {
                                if (!isNaN(prop) || !Object.prototype.hasOwnProperty.call(cellProperties, prop)) {
                                    continue;
                                }
                                if (!cellProperties[prop]) {
                                    continue;
                                }

                                that.storeCellStyle(cell, prop, cellProperties[prop], that.data[i][datafield]);
                            }
                        }
                    }
                }

                // prepend

                if (that.headerContent && that.headerContent.length) {
                    for (let m = 0; m < that.headerContent.length; m++) {
                        const applyToRowCells = (row, prop, value) => {
                            for (let j = 0; j < that.columnsArray.length; j++) {
                                const currentCell = that.columnsArray[j] + (row);

                                that.storeCellStyle(currentCell, prop, value);
                            }
                        }

                        const row = m + 1;

                        if (that.headerContent[m].style) {
                            const contentStyle = that.headerContent[m].style;

                            const hexDigits = new Array
                                ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');

                            const hex = (x) => {
                                return isNaN(x) ? '00' : hexDigits[(x - x % 16) / 16] + hexDigits[x % 16];
                            }

                            //Function to convert rgb color to hex format
                            const toHex = (rgb) => {
                                if (!rgb.startsWith('#')) {
                                    rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);

                                    if (!rgb) {
                                        return null;
                                    }
                                }
                                else {
                                    return rgb.toUpperCase();
                                }

                                return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]).toUpperCase();
                            }



                            for (let prop in contentStyle) {
                                let value = contentStyle[prop];

                                if (prop === 'height') {
                                    that.rowHeight[row - 1] = ` ht="${parseFloat(value)}"`;
                                    continue;
                                }
                                if (prop === 'color' || prop === 'backgroundColor') {
                                    value = toHex(value);
                                }

                                applyToRowCells(row, prop, value);
                            }
                        }
                    }
                }




                // append
                if (that.footerContent && that.footerContent.length) {
                    for (let m = 0; m < that.footerContent.length; m++) {
                        const applyToRowCells = (row, prop, value) => {
                            for (let j = 0; j < that.columnsArray.length; j++) {
                                const currentCell = that.columnsArray[j] + (row);

                                that.storeCellStyle(currentCell, prop, value);
                            }
                        }

                        let prefix = (that.headerContent && that.headerContent.length) ? that.headerContent.length : 0;

                        const row = 1 + that.data.length + m + prefix;

                        if (that.footerContent[m].style) {
                            const contentStyle = that.footerContent[m].style;

                            const hexDigits = new Array
                                ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');

                            const hex = (x) => {
                                return isNaN(x) ? '00' : hexDigits[(x - x % 16) / 16] + hexDigits[x % 16];
                            }

                            //Function to convert rgb color to hex format
                            const toHex = (rgb) => {
                                if (!rgb.startsWith('#')) {
                                    rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);

                                    if (!rgb) {
                                        return null;
                                    }
                                }
                                else {
                                    return rgb.toUpperCase();
                                }

                                return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]).toUpperCase();
                            }



                            for (let prop in contentStyle) {
                                let value = contentStyle[prop];

                                if (prop === 'height') {
                                    that.rowHeight[row - 1] = ` ht="${parseFloat(value)}"`;
                                    continue;
                                }
                                if (prop === 'color' || prop === 'backgroundColor') {
                                    value = toHex(value);
                                }

                                applyToRowCells(row, prop, value);
                            }
                        }
                    }
                }
            }

            /**
             * Processes complex header object.
             */
            processComplexHeader(header, data, format) {
                const that = this,
                    flatHeader = {},
                    processGrouping = ['html', 'jpeg', 'pdf', 'png', 'xlsx'].indexOf(format) !== -1 && header.columngroups,
                    datafieldMapping = [],
                    columnGroupHierarchy = {},
                    columnGroupNameHierarchy = {},
                    complexHeader = [],
                    complexDataFieldsHeader = [];
                let headerDepth = 0;

                function getColumnGroup(columnGroup) {
                    for (let i = 0; i < header.columngroups.length; i++) {
                        const currentGroupDefinition = header.columngroups[i];

                        if (currentGroupDefinition.name === columnGroup) {
                            return currentGroupDefinition;
                        }
                    }
                }

                function getColumnGroupHierarchy(groupDefinition, property) {
                    const columnGroups = [];

                    while (groupDefinition) {
                        columnGroups.unshift(groupDefinition[property]);

                        if (groupDefinition.parentGroup) {
                            groupDefinition = getColumnGroup(groupDefinition.parentGroup);
                        }
                        else {
                            return columnGroups;
                        }
                    }
                }

                if (processGrouping) {
                    for (let i = 0; i < header.columngroups.length; i++) {
                        const currentGroupDefinition = header.columngroups[i],
                            groupHierarchy = getColumnGroupHierarchy(currentGroupDefinition, 'label');

                        columnGroupHierarchy[currentGroupDefinition.name] = groupHierarchy;
                        columnGroupNameHierarchy[currentGroupDefinition.name] = getColumnGroupHierarchy(currentGroupDefinition, 'name');
                        headerDepth = Math.max(headerDepth, groupHierarchy.length);
                    }

                    headerDepth++;

                    for (let i = 0; i < headerDepth; i++) {
                        complexHeader[i] = [];
                        complexDataFieldsHeader[i] = [];
                    }
                }

                for (let i = 0; i < header.columns.length; i++) {
                    const currentColumn = header.columns[i];

                    flatHeader[currentColumn.dataField] = currentColumn.label;

                    if (!processGrouping) {
                        continue;
                    }

                    datafieldMapping[i] = currentColumn.dataField;
                    complexHeader[headerDepth - 1][i] = currentColumn.label;
                    complexDataFieldsHeader[headerDepth - 1][i] = currentColumn.dataField;

                    if (!currentColumn.columnGroup) {
                        continue;
                    }

                    const columnGroups = columnGroupHierarchy[currentColumn.columnGroup],
                        columnGroupNames = columnGroupNameHierarchy[currentColumn.columnGroup];

                    if (columnGroups) {
                        for (let j = 0; j < columnGroups.length; j++) {
                            complexHeader[j][i] = columnGroups[j];
                            complexDataFieldsHeader[j][i] = columnGroupNames[j];
                        }
                    }
                }

                if (complexHeader.length > 1) {
                    const numberOfDatafields = Object.keys(flatHeader).length;

                    for (let i = 0; i < headerDepth - 1; i++) {
                        const entry = {};

                        for (let j = 0; j < numberOfDatafields; j++) {
                            if (complexHeader[i][j] === undefined) {
                                let iterator = i + 1;

                                while (complexHeader[iterator][j] === undefined) {
                                    iterator++;
                                }

                                complexHeader[i][j] = complexHeader[iterator][j];
                                complexDataFieldsHeader[i][j] = complexDataFieldsHeader[iterator][j];
                            }

                            entry[datafieldMapping[j]] = complexHeader[i][j];
                        }

                        if (format === 'xlsx') {
                            data.splice(i, 0, entry);
                        }
                    }

                    that.complexHeader = complexHeader;
                    that.complexDataFieldsHeader = complexDataFieldsHeader;

                    if (format !== 'xlsx') {
                        data.unshift(flatHeader);
                    }
                    else {
                        data.splice(headerDepth - 1, 0, flatHeader);

                        const toMerge = {};

                        for (let i = 0; i < headerDepth; i++) {
                            for (let j = 0; j < numberOfDatafields; j++) {
                                const dataField = complexDataFieldsHeader[i][j];

                                if (!toMerge[dataField]) {
                                    toMerge[dataField] = { from: [i, j] };
                                    toMerge[dataField].to = toMerge[dataField].from;
                                }
                                else {
                                    const oldMergeTo = toMerge[dataField].to;

                                    if (i - oldMergeTo[0] > 1 || j - oldMergeTo[1] > 1) {
                                        toMerge[dataField + Math.random().toString(36)] = toMerge[dataField];
                                        toMerge[dataField] = { from: [i, j], to: [i, j] };
                                        continue;
                                    }

                                    toMerge[dataField].to = [i, j];
                                }
                            }
                        }

                        that.complexHeaderMergeInfo = toMerge;
                    }
                }
                else {
                    data.unshift(flatHeader);
                }
            }

            /**
             * Processes hierarchical data.
             */
            processHierarchicalData(data, format) {
                const that = this,
                    startIndex = format !== 'xlsx' ? +that.exportHeader : that.xlsxStartIndex,
                    siblingGroups = {},
                    processedData = [];
                let maxLevel = 0,
                    actualHierarchy = false;

                function process(parentKey, level, collapsed) {
                    const group = siblingGroups[parentKey];

                    maxLevel = Math.max(maxLevel, level);

                    if (group === undefined) {
                        return;
                    }

                    for (let i = 0; i < group.length; i++) {
                        const currentRecord = group[i],
                            keyDataField = currentRecord._keyDataField;

                        currentRecord._collapsed = collapsed;
                        currentRecord._level = level;
                        processedData.push(currentRecord);

                        if (siblingGroups[keyDataField]) {
                            actualHierarchy = true;
                            currentRecord._expanded = currentRecord._expanded !== undefined ? currentRecord._expanded : true;
                            process(keyDataField, level + 1, collapsed || !currentRecord._expanded);
                        }
                    }
                }

                function processJSONXML(parentKey, level, parent) {
                    const group = siblingGroups[parentKey];

                    maxLevel = Math.max(maxLevel, level);

                    if (group === undefined) {
                        return;
                    }

                    for (let i = 0; i < group.length; i++) {
                        const currentRecord = group[i],
                            keyDataField = currentRecord._keyDataField;
                        let cleanedRecord;

                        if (format === 'json') {
                            cleanedRecord = {};

                            for (let prop in currentRecord) {
                                if (Object.prototype.hasOwnProperty.call(currentRecord, prop) && prop.charAt(0) !== '_') {
                                    cleanedRecord[prop] = currentRecord[prop];
                                }
                            }
                        }
                        else {
                            cleanedRecord = Object.assign({}, currentRecord);
                        }

                        parent.push(cleanedRecord);

                        if (siblingGroups[keyDataField]) {
                            actualHierarchy = true;
                            cleanedRecord.rows = [];
                            processJSONXML(keyDataField, level + 1, cleanedRecord.rows);
                        }
                    }
                }

                if (data[startIndex]._keyDataField === undefined) {
                    return that.processNestedData(data, format, startIndex);
                }

                for (let i = startIndex; i < data.length; i++) {
                    const currentRecord = Object.assign({}, data[i]);
                    let parentKey = currentRecord._parentDataField;

                    if (parentKey === undefined) {
                        parentKey = null;
                    }

                    if (siblingGroups[parentKey] === undefined) {
                        siblingGroups[parentKey] = [currentRecord];
                    }
                    else {
                        siblingGroups[parentKey].push(currentRecord);
                    }
                }

                if (startIndex) {
                    for (let i = 0; i < startIndex; i++) {
                        processedData.push(Object.assign({}, data[i]));

                        if (['json', 'pdf', 'xml'].indexOf(format) === -1) {
                            processedData[i]._level = 1;
                        }
                    }
                }

                if (format !== 'json' && format !== 'xml') {
                    process(null, 1, false);
                }
                else {
                    processJSONXML(null, 1, processedData);
                }

                if (!actualHierarchy) {
                    that.actualHierarchy = false;
                }

                that.maxLevel = maxLevel;
                return processedData;
            }

            /**
             * Processes nested hierarchical data.
             */
            processNestedData(data, format, startIndex) {
                const that = this,
                    processedData = [];
                let maxLevel = 0,
                    actualHierarchy = false;

                function process(start, children, level, collapsed) {
                    maxLevel = Math.max(maxLevel, level);

                    for (let i = start; i < children.length; i++) {
                        const currentRecord = Object.assign({}, children[i]);

                        currentRecord._collapsed = collapsed;
                        currentRecord._level = level;
                        processedData.push(currentRecord);

                        if (currentRecord.children && currentRecord.children.length > 0) {
                            actualHierarchy = true;
                            currentRecord._expanded = currentRecord._expanded !== undefined ? currentRecord._expanded : true;
                            process(0, currentRecord.children, level + 1, collapsed || !currentRecord._expanded);
                        }

                        delete currentRecord.children;
                    }
                }

                function processJSONXML(start, children, rows, level) {
                    maxLevel = Math.max(maxLevel, level);

                    for (let i = start; i < children.length; i++) {
                        const currentRecord = Object.assign({}, children[i]);

                        if (level === 1) {
                            processedData[i] = currentRecord;
                        }
                        else {
                            rows[i] = currentRecord;
                        }

                        if (currentRecord.children && currentRecord.children.length > 0) {
                            actualHierarchy = true;
                            currentRecord.rows = [];
                            processJSONXML(0, currentRecord.children, currentRecord.rows, level + 1);
                        }

                        delete currentRecord.children;
                    }
                }

                if (startIndex) {
                    for (let i = 0; i < startIndex; i++) {
                        processedData.push(Object.assign({}, data[i]));

                        if (['json', 'pdf', 'xml'].indexOf(format) === -1) {
                            processedData[i]._level = 1;
                        }
                    }
                }

                if (format !== 'json' && format !== 'xml') {
                    process(startIndex, data, 1, false);
                }
                else {
                    processJSONXML(startIndex, data, undefined, 1);
                }

                if (!actualHierarchy) {
                    that.actualHierarchy = false;
                }

                that.maxLevel = maxLevel;
                return processedData;
            }

            /**
             * Processes row styles.
             */
            processRowStyle(style) {
                const that = this,
                    rowsDefinition = style.rows;

                that.rowHeight = [];

                if (!rowsDefinition) {
                    return;
                }

                const startIndex = that.xlsxStartIndex;

                function applyToRowCells(row, prop, value) {
                    for (let j = 0; j < that.columnsArray.length; j++) {
                        const currentCell = that.columnsArray[j] + (row + 1 + startIndex);

                        that.storeCellStyle(currentCell, prop, value);
                    }
                }

                if (rowsDefinition.height) {
                    if (!rowsDefinition.height) {
                        rowsDefinition.height = 15;
                    }
                    that.defaultRowHeight = ` ht="${parseFloat(rowsDefinition.height) / 2}"`;
                }

                for (let i = startIndex; i < that.data.length; i++) {
                    const row = i - startIndex;

                    for (let prop in rowsDefinition) {
                        if (Object.prototype.hasOwnProperty.call(rowsDefinition, prop) &&
                            prop.indexOf('alt') === -1 &&
                            isNaN(prop) &&
                            prop !== 'height') {
                            applyToRowCells(row, prop, rowsDefinition[prop]);
                        }
                    }

                    if (rowsDefinition.alternationCount &&
                        (((rowsDefinition.alternationStart === undefined || row >= rowsDefinition.alternationStart) &&
                            (rowsDefinition.alternationEnd === undefined || row <= rowsDefinition.alternationEnd)) ||
                            rowsDefinition.alternationStart === rowsDefinition.alternationEnd)) {
                        const start = rowsDefinition.alternationStart || 0,
                            i = (row - start) % rowsDefinition.alternationCount;

                        if (rowsDefinition[`alternationIndex${i}Color`]) {
                            applyToRowCells(row, 'color', rowsDefinition[`alternationIndex${i}Color`]);
                        }

                        if (rowsDefinition[`alternationIndex${i}BorderColor`]) {
                            applyToRowCells(row, 'borderColor', rowsDefinition[`alternationIndex${i}BorderColor`]);
                        }

                        if (rowsDefinition[`alternationIndex${i}BackgroundColor`]) {
                            applyToRowCells(row, 'backgroundColor', rowsDefinition[`alternationIndex${i}BackgroundColor`]);
                        }
                    }

                    if (that.setRowHeight) {
                        const rowHeight = that.setRowHeight(row);
                        if (rowHeight) {
                            that.rowHeight[i] = ` ht="${parseFloat(rowHeight)}"`;
                            continue;
                        }
                    }

                    if (rowsDefinition[row]) {
                        for (let prop in rowsDefinition[row]) {
                            if (Object.prototype.hasOwnProperty.call(rowsDefinition[row], prop)) {
                                if (prop === 'height') {
                                    that.rowHeight[i] = ` ht="${parseFloat(rowsDefinition[row].height) / 2}"`;
                                    continue;
                                }

                                if (that.data[i] && that.data[i][prop]) {
                                    function applyToRowCell(row, prop, value, dataField) {
                                        const j = that.datafields ? that.datafields.indexOf(dataField) : -1;
                                        if (j >= 0) {
                                            const currentCell = that.columnsArray[j] + (row + 1 + startIndex);

                                            that.storeCellStyle(currentCell, prop, value);
                                        }
                                    }
                                    for (let styleProp in rowsDefinition[row][prop]) {
                                        applyToRowCell(row, styleProp, rowsDefinition[row][prop][styleProp], prop);
                                    }
                                    continue;
                                }

                                applyToRowCells(row, prop, rowsDefinition[row][prop]);
                            }
                        }
                    }
                }
            }

            /**
             * Stores cell style in "styleMap" object.
             */
            storeCellStyle(cell, prop, value) {
                const that = this,
                    cellMap = that.styleMap[cell];

                switch (prop) {
                    case 'backgroundColor':
                        cellMap.fills.fgColor = value;
                        break;
                    case 'color':
                        cellMap.fonts.color = value;
                        break;
                    case 'fontFamily':
                        cellMap.fonts.name = value.replace(/"/g, '\'');
                        break;
                    case 'fontSize':
                        cellMap.fonts.sz = Math.round(parseFloat(value) / (96 / 72));
                        break;
                    case 'fontStyle':
                        if (value === 'italic') {
                            cellMap.fonts.i = true;
                        }
                        else {
                            delete cellMap.fonts.i;
                        }

                        break;
                    case 'fontWeight':
                        if (value === 'bold') {
                            cellMap.fonts.b = true;
                        }
                        else {
                            delete cellMap.fonts.b;
                        }

                        break;
                    case 'numFmt': {
                        cellMap.numFmt = value;
                        break;
                    }
                    case 'textAlign':
                        cellMap.alignment.horizontal = value;
                        break;
                    case 'textDecoration':
                        if (value === 'underline') {
                            cellMap.fonts.u = true;
                        }
                        else {
                            delete cellMap.fonts.u;
                        }

                        break;
                    case 'verticalAlign':
                        if (value === 'middle') {
                            value = 'center';
                        }

                        cellMap.alignment.vertical = value;
                        break;
                }
            }

            /**
             * Returns an Alpha Red Green Blue color value.
             */
            toARGB(color) {
                color = color.replace(/\s/g, '');

                const rgbResult = /rgb\((\d+),(\d+),(\d+)\)/gi.exec(color);

                if (rgbResult !== null) {
                    const r = parseFloat(rgbResult[1]).toString(16).toUpperCase(),
                        g = parseFloat(rgbResult[2]).toString(16).toUpperCase(),
                        b = parseFloat(rgbResult[3]).toString(16).toUpperCase();

                    return 'FF' + ('0').repeat(2 - r.length) + r +
                        ('0').repeat(2 - g.length) + g +
                        ('0').repeat(2 - b.length) + b;
                }

                const rgbaResult = /rgba\((\d+),(\d+),(\d+)\,(\d*.\d+|\d+)\)/gi.exec(color);

                if (rgbaResult !== null) {
                    const a = Math.round(parseFloat(rgbaResult[4]) * 255).toString(16).toUpperCase(),
                        r = parseFloat(rgbaResult[1]).toString(16).toUpperCase(),
                        g = parseFloat(rgbaResult[2]).toString(16).toUpperCase(),
                        b = parseFloat(rgbaResult[3]).toString(16).toUpperCase();

                    return ('0').repeat(2 - a.length) + a +
                        ('0').repeat(2 - r.length) + r +
                        ('0').repeat(2 - g.length) + g +
                        ('0').repeat(2 - b.length) + b;
                }

                const shortHexResult = /^#(.)(.)(.)$/gi.exec(color);

                if (shortHexResult !== null) {
                    const r = shortHexResult[1].toUpperCase(),
                        g = shortHexResult[2].toUpperCase(),
                        b = shortHexResult[3].toUpperCase();

                    return 'FF' + r + r + g + g + b + b;
                }

                return 'FF' + color.toUpperCase().slice(1);
            }

            /**
             * Adds toggleable functionality.
             */
            toggleableFunctionality() {
                const that = this;

                if (!that.actualHierarchy) {
                    return '';
                }

                return `\n    <style type="text/css">
            .toggle-element {
                width: 5px;
                height: 1px;
                padding-right: 5px;
                float: left;
                text-align: right;
                cursor: pointer;
                user-select: none;
            }
    
            .collapsed {
                display: none;
            }
        </style>
        <script type="text/javascript">
            window.onload = function () {
                var expandChar = '${that.expandChar}',
                    collapseChar = '${that.collapseChar}',
                    toggleElements = document.getElementsByClassName('toggle-element');
    
                function getParent(child) {
                    var prevSibling = child.previousElementSibling;
    
                    while (prevSibling) {
                        if (child.getAttribute('level') > prevSibling.getAttribute('level')) {
                            return prevSibling;
                        }
    
                        prevSibling = prevSibling.previousElementSibling;
                    }
    
                }
    
                function getFirstCollapsedAncestor(child) {
                    var parent = getParent(child);
    
                    while (parent) {
                        if (parent.firstElementChild.firstElementChild.innerHTML === expandChar) {
                            return parent;
                        }
    
                        parent = getParent(parent);
                    }
                }
    
                for (var i = 0; i < toggleElements.length; i++) {
                    toggleElements[i].addEventListener('click', function (event) {
                        var expanded = this.innerHTML === collapseChar,
                            row = this.parentElement.parentElement,
                            sibling = row.nextElementSibling;
    
                        if (expanded) {
                            this.innerHTML = expandChar;
                        }
                        else {
                            this.innerHTML = collapseChar;
                        }
    
                        while (sibling && row.getAttribute('level') < sibling.getAttribute('level')) {
                            if (expanded) {
                                sibling.style.display = 'none';
                            }
                            else {
                                var firstCollapsedAncestor = getFirstCollapsedAncestor(sibling);
    
                                if (!firstCollapsedAncestor || firstCollapsedAncestor === row) {
                                    sibling.classList.remove('collapsed');
                                    sibling.style.display = null;
                                }
    
                            }
    
                            sibling = sibling.nextElementSibling;
                        }
                    });
                }
            }
        </script>`;
            }

            /**
             * Generates styles.xml.
             */
            generateStyles(style) {
                const that = this;

                that.cellStyleMapping = {};

                if (Object.keys(style).length === 0 && !that.complexHeader) {
                    // default style
                    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2 xr" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><charset val="204"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/></cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>${that.conditionalFormattingXLSX.styles || '<dxfs count="0"/>'}<tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>`;
                }

                that.styleMap = {};

                let offset = that.headerContent ? that.headerContent.length : 0;
                offset += that.footerContent ? that.footerContent.length : 0;

                let count = that.data.length + offset;

                if (that.groupBy && that.groupBy.length) {
                    count += 50;
                }

                for (let i = 0; i < count; i++) {
                    for (let j = 0; j < that.columnsArray.length; j++) {
                        that.styleMap[that.columnsArray[j] + (i + 1)] = {
                            numFmts: {}, fonts: {}, fills: {}, borders: {}, alignment: {}
                        }
                    }
                }

                if (style && style.columns) {
                    for (let i = 0; i < that.columnsArray.length; i++) {
                        const datafield = that.datafields[i];

                        if (!style.columns[datafield] || !style.columns[datafield].format) {
                            continue;
                        }

                        const XLSXFormatFirst = that.getXLSXFormat(style.columns[datafield].format, that.data[1][datafield]);
                        const XLSXFormat = that.getXLSXFormat(style.columns[datafield].format, that.data[that.data.length - 1][datafield]);

                        if (XLSXFormat) {
                            style.columns[datafield].numFmt = XLSXFormat;
                        }
                        else if (XLSXFormatFirst) {
                            style.columns[datafield].numFmt = XLSXFormatFirst;
                        }
                        else if (style.columns[datafield].format && (datafield.toLowerCase().indexOf('date') >= 0 || style.columns[datafield].format.indexOf('d/') >= 0)) {
                            let format = style.columns[datafield].format;
                            switch (format) {
                                case 'd':
                                    format = 'm/d/yyyy';
                                    break;
                                case 'D':
                                    format = 'nnnnmmmm dd, yyyy';
                                    break;
                                case 't':
                                    format = 'h:m AM/PM';
                                    break;
                                case 'T':
                                    format = 'h:mm:ss AM/PM';
                                    break;
                                case 'f':
                                    format = 'nnnnmmmm dd, yyyy h:m AM/PM';
                                    break;
                                case 'F':
                                    format = 'nnnnmmmm dd, yyyy h:mm:ss AM/PM';
                                    break;
                                case 'M':
                                    format = 'mmmm d';
                                    break;
                                case 'Y':
                                    format = 'yyyy mmmm';
                                    break;
                                case 'FP':
                                case 'PP':
                                    format = 'yyyy-mm-dd hh:mm:ss';
                                    break;
                                case 'FT':
                                case 'PT':
                                    format = 'hh:mm:ss';
                                    break;
                            }

                            format = format.replace(/f|u|n|p|e|a|x|o/gi, '');
                            format = format.replace(/tt/gi, 'AM/PM');
                            format = format.replace(/:{2,}|:\s|:$|\.$/g, '');
                            format = format.trim();
                            style.columns[datafield].numFmt = format;
                        }
                    }
                }

                that.processRowStyle(style);
                that.processColumnStyle(style);

                const cellAliases = {};

                for (let i = 0; i < that.complexHeaderMergedCells.length; i++) {
                    const currentCell = that.complexHeaderMergedCells[i];

                    if (parseFloat(currentCell.to[1]) === that.complexHeader.length) {
                        cellAliases[currentCell.to] = currentCell.from;
                        continue;
                    }

                    that.styleMap[currentCell.from].alignment.horizontal = 'center';
                    that.styleMap[currentCell.from].alignment.vertical = 'center';
                }

                const fonts = {
                    xml: '<font><sz val="11" /><color theme="1" /><name val="Calibri" /><family val="2" /><charset val="204" /><scheme val="minor" /></font>',
                    collection: ['default']
                },
                    fills = {
                        xml: '<fill><patternFill patternType="none" /></fill><fill><patternFill patternType="gray125" /></fill>',
                        collection: ['default', 'gray125']
                    },
                    numFmts = {
                        xml: '',
                        collection: []
                    },
                    cellXfs = {
                        xml: '<xf fontId="0" fillId="0" borderId="1"/>',
                        collection: ['default']
                    };

                for (let i = 0; i < count; i++) { // iterate rows
                    for (let j = 0; j < that.columnsArray.length; j++) { // iterate columns
                        const currentCell = that.columnsArray[j] + (i + 1),
                            currentCellStyle = that.styleMap[currentCell];
                        let currentFont = '', currentFill = '', currentAlignment = '',
                            currentFontCode = [], currentFillCode = [], currentAlignmentCode = [], xf = [];

                        for (let prop in currentCellStyle.fonts) {
                            if (Object.prototype.hasOwnProperty.call(currentCellStyle.fonts, prop)) {
                                const value = currentCellStyle.fonts[prop];

                                switch (prop) {
                                    case 'color':
                                        currentFontCode[0] = value;
                                        currentFont += `<color rgb="${that.toARGB(value)}" />`;
                                        break;
                                    case 'name':
                                        currentFontCode[1] = value;
                                        currentFont += `<name val="${value}" />`;
                                        break;
                                    case 'sz':
                                        currentFontCode[2] = value;
                                        currentFont += `<sz val="${value}" />`;
                                        break;
                                    case 'i':
                                        currentFontCode[3] = value;
                                        currentFont += '<i />';
                                        break;
                                    case 'b':
                                        currentFontCode[4] = value;
                                        currentFont += '<b />';
                                        break;
                                    case 'u':
                                        currentFontCode[5] = value;
                                        currentFont += '<u />';
                                        break;
                                }
                            }
                        }

                        for (let prop in currentCellStyle.fills) {
                            if (Object.prototype.hasOwnProperty.call(currentCellStyle.fills, prop)) {
                                const value = currentCellStyle.fills[prop];

                                switch (prop) {
                                    case 'fgColor':
                                        currentFillCode[0] = value;
                                        currentFill += `<fgColor rgb="${that.toARGB(value)}" />`;
                                        break;
                                }
                            }
                        }

                        for (let prop in currentCellStyle.alignment) {
                            if (Object.prototype.hasOwnProperty.call(currentCellStyle.alignment, prop)) {
                                const value = currentCellStyle.alignment[prop];

                                switch (prop) {
                                    case 'horizontal':
                                        currentAlignmentCode[0] = value;
                                        currentAlignment += `horizontal="${value}" `;
                                        break;
                                    case 'vertical':
                                        currentAlignmentCode[1] = value;
                                        currentAlignment += `vertical="${value}" `;
                                        break;
                                }
                            }
                        }

                        currentFontCode = currentFontCode.toString();
                        currentFillCode = currentFillCode.toString();

                        if (currentFont !== '') {
                            let fontIndex = fonts.collection.indexOf(currentFontCode);

                            if (fontIndex === -1) {
                                fontIndex = fonts.collection.length;

                                fonts.xml += '<font>' + currentFont + '</font>';
                                fonts.collection.push(currentFontCode);
                            }

                            xf[0] = fontIndex;
                        }

                        if (currentFill !== '') {
                            let fillIndex = fills.collection.indexOf(currentFillCode);

                            if (fillIndex === -1) {
                                fillIndex = fills.collection.length;

                                fills.xml += '<fill><patternFill patternType="solid">' + currentFill + '</patternFill></fill>';
                                fills.collection.push(currentFillCode);
                            }

                            xf[1] = fillIndex;
                        }

                        if (currentAlignmentCode.length > 0) {
                            xf[2] = currentAlignment;
                        }

                        if (currentCellStyle.numFmt !== undefined) {
                            xf[3] = that.getNumFmtIndex(currentCellStyle.numFmt, numFmts);
                        }

                        const xfCode = xf.toString();

                        if (xfCode !== '') {
                            let xfIndex = cellXfs.collection.indexOf(xfCode);

                            if (xfIndex === -1) {
                                let newXfXML = '<xf ';

                                xfIndex = cellXfs.collection.length;

                                if (xf[0] !== undefined) {
                                    newXfXML += `fontId="${xf[0]}" `;
                                }

                                if (xf[1] !== undefined) {
                                    newXfXML += `fillId="${xf[1]}" `;
                                }

                                if (xf[3] !== undefined) {
                                    newXfXML += `numFmtId="${xf[3]}" `;
                                }

                                if (xf[2] !== undefined) {
                                    newXfXML += `applyAlignment="1" borderId="1"><alignment ${currentAlignment}/></xf>`;
                                }
                                else {
                                    newXfXML += ' borderId="1"/>';
                                }

                                cellXfs.xml += newXfXML;
                                cellXfs.collection.push(xfCode);
                            }

                            that.cellStyleMapping[cellAliases[currentCell] || currentCell] = xfIndex;
                        }
                    }
                }

                if (numFmts.collection.length) {
                    numFmts.xml = `<numFmts count="${numFmts.collection.length}">${numFmts.xml}</numFmts>`;
                }

                return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2 xr" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" xmlns:xr="http://schemas.microsoft.com/office/spreadsheetml/2014/revision">${numFmts.xml}<fonts count="${fonts.collection.length}" x14ac:knownFonts="1">${fonts.xml}</fonts><fills count="${fills.collection.length}">${fills.xml}</fills><borders count="2"><border><left/><right/><top/><bottom/></border><border><left style="hair"/><right style="hair"/><top style="hair"/><bottom style="hair"/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="${cellXfs.collection.length}">${cellXfs.xml}</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>${that.conditionalFormattingXLSX.styles}<dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>`;
            }
        }

        if ($.jqx && $.jqx.dataAdapter) {
            $.jqx.dataAdapter.DataExporter = DataExporter;
        }
    })(jqxBaseFramework);
})();

/***/ }),

/***/ 3189:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {
    $.extend($.jqx._jqxGrid.prototype, {
        _calculateaggregate: function (column, aggregates, formatData, records) {
            var aggregate = column.aggregates;
            if (!aggregate) aggregate = aggregates;

            if (aggregate) {
                var formatstrings = new Array();
                for (var i = 0; i < aggregate.length; i++) {
                    if (aggregate[i] == 'count') {
                        continue;
                    }
                    formatstrings[formatstrings.length] = column.cellsformat;
                }

                if (this.source && this.source.getAggregatedData) {
                    if (records == undefined) {
                        records = this.getrows();
                    }
                    if (this.virtualmode) {
                        var records = new Array();
                        $.each(this.source._source.records, function () {
                            records.push(this);
                        });
                    }

                    if (formatData == undefined || formatData == true) {
                        var summaryData = this.source.getAggregatedData
                ([{ name: column.datafield, aggregates: aggregate, formatStrings: formatstrings }], this.gridlocalization, records);
                        return summaryData;
                    }
                    else {
                        var summaryData = this.source.getAggregatedData
                ([{ name: column.datafield, aggregates: aggregate }], this.gridlocalization, records);
                        return summaryData;
                    }
                }
            }
            return null;
        },

        getcolumnaggregateddata: function (datafield, aggregates, formatdata, records) {
            var column = this.getcolumn(datafield);
            var format = (formatdata == undefined || formatdata == false) ? false : formatdata;
            if (aggregates == null) return "";

            var tmpaggregates = column.aggregates;
            column.aggregates = null;

            var agg = this._calculateaggregate(column, aggregates, format, records);
            var summaryData = {};
            if (agg) {
                summaryData = agg[datafield];
            }
            column.aggregates = tmpaggregates;
            return summaryData;
        },

        refreshaggregates: function () {
            this._updatecolumnsaggregates();
        },

        renderaggregates: function () {
            this._updateaggregates();
        },

        _updatecolumnaggregates: function (column, aggregates, columnelement) {
            var me = this;
            if (!aggregates) {
                columnelement.children().remove();
                columnelement.html('');
                if (column.aggregatesrenderer) {
                    var obj = {};
                    if (column.aggregates) {
                        obj = this.getcolumnaggregateddata(column.datafield, column.aggregates);
                    }

                    var renderstring = column.aggregatesrenderer({}, column, columnelement, null);
                    columnelement.html(renderstring);
                }
                return;
            }

            columnelement.children().remove();
            columnelement.html('');
            if (column.aggregatesrenderer) {
                if (aggregates) {
                    var renderstring = column.aggregatesrenderer(aggregates[column.datafield], column, columnelement, this.getcolumnaggregateddata(column.datafield, aggregates[column.datafield]));
                    columnelement.html(renderstring);
                }
            }
            else {
                $.each(aggregates, function () {
                    var aggregate = this;
                    for (obj in aggregate) {
                        var field = $('<div style="position: relative; margin: 4px; overflow: hidden;"></div>');
                        var name = obj;
                        name = me._getaggregatename(name);
                        field.html(name + ':' + aggregate[obj]);
                        if (me.rtl) {
                            field.addClass(me.toThemeProperty('jqx-rtl'));
                        }

                        columnelement.append(field);
                    }
                });
            }
        },

        _getaggregatetype: function (obj) {
            switch (obj) {
                case 'min':
                case 'max':
                case 'count':
                case 'avg':
                case 'product':
                case 'var':
                case 'varp':
                case 'stdev':
                case 'stdevp':
                case 'sum':
                    return obj;
            }
            var name = obj;
            for (var myObj in obj) {
                name = myObj;
                break;
            }
            return name;
        },

        _getaggregatename: function (obj) {
            var name = obj;
            switch (obj) {
                case 'min':
                    name = 'Min';
                    break;
                case 'max':
                    name = 'Max';
                    break;
                case 'count':
                    name = 'Count';
                    break;
                case 'avg':
                    name = 'Avg';
                    break;
                case 'product':
                    name = 'Product';
                    break;
                case 'var':
                    name = 'Var';
                    break;
                case 'stdevp':
                    name = 'StDevP';
                    break;
                case 'stdev':
                    name = 'StDev';
                    break;
                case 'varp':
                    name = 'VarP';
                case 'sum':
                    name = 'Sum';
                    break;
            }
            if (obj === name && typeof(name) != 'string') {
                for (var myObj in obj) {
                    name = myObj;
                    break;
                }
            }
            return name;
        },

        _updatecolumnsaggregates: function () {
            var rows = this.getrows();
            var columnslength = this.columns.records.length;
            if (undefined != this.statusbar[0].cells) {
                for (var j = 0; j < columnslength; j++) {
                    var tablecolumn = $(this.statusbar[0].cells[j]);
                    var columnrecord = this.columns.records[j];
                    var summaryData = this._calculateaggregate(columnrecord, null, true, rows);
                    this._updatecolumnaggregates(columnrecord, summaryData, tablecolumn);
                }
            }
        },

        _updateaggregates: function () {
            var tablerow = $('<div style="position: relative;" id="statusrow' + this.element.id + '"></div>');
            var left = 0;
            var columnslength = this.columns.records.length;
            var cellclass = this.toThemeProperty('jqx-grid-cell');
            if (this.rtl) {
                cellclass += ' ' + this.toThemeProperty('jqx-grid-cell-rtl');
                left = -1;
            }
            cellclass += ' ' + this.toThemeProperty('jqx-grid-cell-pinned');
            //var cellclass = this.toThemeProperty('jqx-widget-header');
            var zindex = columnslength + 10;
            var cells = new Array();
            this.statusbar[0].cells = cells;
            var rows = this.getrows();
            for (var j = 0; j < columnslength; j++) {
                var columnrecord = this.columns.records[j];
                var summaryData = this._calculateaggregate(columnrecord, columnrecord.aggregates, true, rows);
                var width = columnrecord.width;
                if (width < columnrecord.minwidth) width = columnrecord.minwidth;
                if (width > columnrecord.maxwidth) width = columnrecord.maxwidth;
                var currentCellClass = cellclass;
                if (columnrecord.cellsalign) {
                    currentCellClass += ' ' + this.toThemeProperty('jqx-' + columnrecord.cellsalign + '-align');
                }
                var tablecolumn = $('<div style="overflow: hidden; position: absolute; height: 100%;" class="' + currentCellClass + '"></div>');
                tablerow.append(tablecolumn);
                tablecolumn.css('left', left);
                if (!this.rtl) {
                    tablecolumn.css('z-index', zindex--);
                }
                else {
                    tablecolumn.css('z-index', zindex++);
                }

                tablecolumn.width(width);
                tablecolumn[0].left = left;
                if (!(columnrecord.hidden && columnrecord.hideable)) {
                    left += width;
                }
                else {
                    tablecolumn.css('display', 'none');
                }
                cells[cells.length] = tablecolumn[0];
                this._updatecolumnaggregates(columnrecord, summaryData, tablecolumn);
            }

            if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                tablerow.css('z-index', zindex--);
            }

            tablerow.width(parseFloat(left) + 2);
            tablerow.height(this.statusbarheight);
            this.statusbar.children().remove();
            this.statusbar.append(tablerow);
            this.statusbar.removeClass(this.toThemeProperty('jqx-widget-header'));
            this.statusbar.addClass(cellclass);
            this.statusbar.css('border-bottom-color', 'transparent');
            this.statusbar.css('border-top-width', '1px');
            if (this.rtl && this.hScrollBar.css('visibility') != 'hidden') {
                this._renderhorizontalscroll();
            }
            this._arrange();
        }
    });
})(jqxBaseFramework);
})();





/***/ }),

/***/ 2465:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {
	if (!Array.prototype.find) {
		Object.defineProperty(Array.prototype, 'find', {
			value: function (predicate) {
				// 1. var O be ? ToObject(this value).
				if (this == null) {
					throw new TypeError('"this" is null or not defined');
				}

				var o = Object(this);

				// 2. var len be ? ToLength(? Get(O, "length")).
				var len = o.length >>> 0;

				// 3. If IsCallable(predicate) is false, throw a TypeError exception.
				if (typeof predicate !== 'function') {
					throw new TypeError('predicate must be a function');
				}

				// 4. If thisArg was supplied, var T be thisArg; else var T be undefined.
				var thisArg = arguments[1];

				// 5. var k be 0.
				var k = 0;

				// 6. Repeat, while k < len
				while (k < len) {
					// a. var Pk be ! ToString(k).
					// b. var kValue be ? Get(O, Pk).
					// c. var testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
					// d. If testResult is true, return kValue.
					var kValue = o[k];
					if (predicate.call(thisArg, kValue, k, o)) {
						return kValue;
					}
					// e. Increase k by 1.
					k++;
				}

				// 7. Return undefined.
				return undefined;
			}
		});
	}
	if (!Array.prototype.findIndex) {
		Object.defineProperty(Array.prototype, 'findIndex', {
			value: function (predicate) {
				// 1. var O be ? ToObject(this value).
				if (this == null) {
					throw new TypeError('"this" is null or not defined');
				}

				var o = Object(this);

				// 2. var len be ? ToLength(? Get(O, "length")).
				var len = o.length >>> 0;

				// 3. If IsCallable(predicate) is false, throw a TypeError exception.
				if (typeof predicate !== 'function') {
					throw new TypeError('predicate must be a function');
				}

				// 4. If thisArg was supplied, var T be thisArg; else var T be undefined.
				var thisArg = arguments[1];

				// 5. var k be 0.
				var k = 0;

				// 6. Repeat, while k < len
				while (k < len) {
					// a. var Pk be ! ToString(k).
					// b. var kValue be ? Get(O, Pk).
					// c. var testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
					// d. If testResult is true, return k.
					var kValue = o[k];
					if (predicate.call(thisArg, kValue, k, o)) {
						return k;
					}
					// e. Increase k by 1.
					k++;
				}

				// 7. Return -1.
				return -1;
			},
			configurable: true,
			writable: true
		});
	}

	$.extend($.jqx._jqxGrid.prototype, {
		_getChartDataFields: function (data) {
			var that = this;
			var record = data[0];
			var stringOnly = true,
				xAxisDataField,
				series = [];

			for (var dataField in record) {
				if (dataField === '$' || dataField === 'uid' || dataField === 'boundindex' || dataField === 'uniqueid' || dataField === 'visibleindex') {
					continue;
				}

				if (that.source._source.dataFields) {
					var dataType = that.source._source.dataFields.find(function (gridField) { return gridField.name === dataField }).type;
				}
				else {
					var dataType = that.source._source.datafields.find(function (gridField) { return gridField.name === dataField }).type;

				}
				if (dataType === 'string') {
					var index = that.columns.records.findIndex(function (col) { return col.datafield === dataField });

					if (index === 0) {
						xAxisDataField = dataField;
					}
				}
				else {
					stringOnly = false;
					series.push({ dataField: dataField, displayText: dataField });
				}
			}

			return { xAxisDataField: xAxisDataField, series: series, stringOnly: stringOnly };
		},

		createChart: function (type, dataSource) {
			var that = this;
			var gridSelection = that.getselection(),
				selectedRows = gridSelection.rows,
				selectedCells = gridSelection.cells,
				chartElement = document.createElement('div'),
				chartData = [],
				seriesGroup = {};
			var rowsToPlot = [],
				columnsToPlot = [],
				series;

			if (selectedCells && selectedCells.length > 1) {
				selectedCells.forEach(function (cell) {
					if (rowsToPlot.indexOf(cell.rowindex) === -1) {
						rowsToPlot.push(cell.rowindex);
					}

					if (columnsToPlot.indexOf(cell.datafield) === -1) {
						columnsToPlot.push(cell.datafield);
					}
				});
			}

			if (selectedRows.length === 0 && selectedCells.length === 0) {
				var dataSource = that.source.records;
			}

			if (dataSource) {
				chartData = chartData.concat(dataSource);
			}
			else {
				var dataSource = that.source.records;

				for (var i = 0; i < dataSource.length; i++) {
					var record = {};

					if (selectedRows.length > 0) {
						if (selectedRows.indexOf(i) === -1) {
							continue;
						}
					}
					else if (selectedCells.length > 0) {
						if (selectedCells.length > 1) {
							if (rowsToPlot.indexOf(i) === -1) {
								continue;
							}

							columnsToPlot.forEach(function (dataField) {
								record[dataField] = dataSource[i][dataField];
							});
							chartData.push(record);
							continue;
						}
					}

					that.columns.records.forEach(function (col) { record[col.datafield] = dataSource[i][col.datafield] });
					chartData.push(record);
				}
			}

			var chartDataFields = that._getChartDataFields(chartData);

			if (chartDataFields.stringOnly) {
				if (that.showheader) {
					var chartIcon = that.element.querySelector('#' + type);

					that.toolbar[0].firstElementChild.classList.add('warning');

					if (chartIcon) {
						chartIcon.classList.add('warning');
					}

					setTimeout(function () {
						that.toolbar[0].firstElementChild.classList.remove('warning');

						if (chartIcon) {
							chartIcon.classList.remove('warning');
						}
					}, 1000);
				}

				return;
			}

			series = chartDataFields.series;

			var chart = {};

			chart.title = '';
			chart.description = '';
			chart.showLegend = true;
			chart.showBorderLine = false;
			chart.padding = { left: 5, top: 10, right: 5, bottom: 5 };
			chart.source = chartData;
			chart.xAxis =
			{
				dataField: chartDataFields.xAxisDataField,
				gridLines: {
					visible: true
				}
			};
			chart.valueAxis =
			{
				displayValueAxis: true,
				description: that.charting.description,
				axisSize: 'auto',
				formatSettings: that.charting.formatSettings
			};
			chart.colorScheme = that.charting.colorScheme;
			chart.seriesGroups = [seriesGroup];

			seriesGroup.formatSettings = that.charting.formatSettings;
			seriesGroup.series = series;

			if (type === 'line') {
				series.forEach(function (serie) {
					serie.symbolSize = 8;
					serie.symbolType = 'square';
				});
			}
			else if (type === 'pie') {
				var pieDataField = series[0].dataField;

				delete seriesGroup.formatSettings;
				seriesGroup.formatFunction = function (value, index) {
					if (isNaN(value)) {
						if (typeof value === 'object') {
							return index;
						}

						return value;
					}

					return value;
				};
				seriesGroup.showLabels = true;
				series.length = 0;
				series.push({
					dataField: pieDataField,
					displayText: chartDataFields.xAxisDataField,
					initialAngle: 0
				});
			}
			else if (type === 'bar') {
				type = 'column';
				seriesGroup.orientation = 'horizontal';
				chart.xAxis.textRotationAngle = 90;
				chart.valueAxis.textRotationAngle = 30;
				chart.valueAxis.flip = true;
			}
			else if (type === 'area') {
				var opacity = 1;

				for (var i = 0; i < series.length; i++) {
					series[i].opacity = opacity;
					opacity -= 0.2;
					opacity = Math.max(0.3, opacity);
				}
			}

			seriesGroup.type = type;

			if (that.charting.ready) {
				that.charting.ready(chart);
			}

			if (that.charting.appendTo) {
				var container = that.charting.appendTo === 'string' ? document.querySelector(that.charting.appendTo) : that.charting.appendTo;

				if (container) {
					var chartInstance = new jqxChart(chartElement, chart);
					container.appendChild(chartElement);
				}
			}
			else {
				that._openChartDialog(chartElement, type, chart);
			}
		},

		_openChartDialog: function (chart, chartType, settings) {
			var that = this;

			if (!that.charting.dialog.enabled) {
				return false;
			}

			var dialogElement = document.createElement('div');

			dialogElement.innerHTML = '<div>' + that.charting.dialog.header + '</div><div style="overflow:hidden;"></div>';

			var chartLabel = chartType.substring(0, 1).toUpperCase() + chartType.substring(1);

			chart.style.width = '100%';
			chart.style.height = '100%';

			var dialog = new jqxWindow(dialogElement, {
				width: that.charting.dialog.width,
				height: that.charting.dialog.height,
				position: that.charting.dialog.position,
				isModal: true
			});

			dialog.open();

			setTimeout(function () {
				dialogElement.querySelector('.jqx-widget-content').appendChild(chart);
				var chartInstance = new jqxChart(chart, settings);
			}, 100);

			dialog.on('close', function () {
				dialog.destroy();
			});
		}
	});
})(jqxBaseFramework);
})();


/***/ }),

/***/ 2421:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {
    $.extend($.jqx._jqxGrid.prototype, {

        getcolumnindex: function (datafield) {
            var column = this.getcolumn(datafield);
            var columnindex = this.columns.records.indexOf(column);
            return columnindex;
        },

        setcolumnindex: function (datafield, index, refresh) {
            var column = this.getcolumn(datafield);
            if (column.pinned) return;
            if (column.hidden) return;
            if (column.checkboxcolumn) return;
            if (column.grouped) return;

            var columnindex = this.columns.records.indexOf(column);
            this.columns.records.splice(columnindex, 1);
            this.columns.records.splice(index, 0, column);

            var left = 0;
            var zindex = this.headerZIndex;
            this.columnsrow.children().detach();

            var cellclass = this.toThemeProperty('jqx-grid-cell');
            cellclass += ' ' + this.toThemeProperty('jqx-grid-cell-pinned');
            if (this.filterrow) {
                $(this.filterrow.children()[0]).children().detach();
                this.filterrow[0].cells = [];
            }

            var self = this;
            var tablerow = null;
            if (self.filterrow != undefined) {
                var tablerow = $(self.filterrow.children()[0]);
            }

            this.columnsrow[0].cells = [];
            var hasHiddenColumns = false;
            $.each(this.columns.records, function (i, value) {
                var column = this.uielement;
                self.columnsrow.append(column);
                if (!self.rtl) {
                    column.css('z-index', zindex--);
                }
                else {
                    column.css('z-index', zindex++);
                }

                var desiredwidth = this.width;
                column.css('left', left);
                self.columnsrow[0].cells[self.columnsrow[0].cells.length] = column[0];

                if (self.filterrow) {
                    var tablecolumn = $('<div style="overflow: hidden; position: absolute; height: 100%;" class="' + cellclass + '"></div>');
                    tablerow.append(tablecolumn);
                    tablecolumn.css('left', left);
                    tablecolumn.css('z-index', zindex + 1);
                    tablecolumn.width(this.width);
                    tablecolumn[0].left = left;
                    tablecolumn.append(this._filterwidget);
                    self.filterrow[0].cells[self.filterrow[0].cells.length] = tablecolumn[0];
                }
                if (this.hidden) {
                    hasHiddenColumns = true;
                }
                if (!(this.hidden && this.hideable)) {
                    left += desiredwidth;
                }
            });

            if (this.groupable) {
                var groupslength = this.groups.length;
                if (groupslength > 0) {
                    if (columnindex - groupslength >= 0) {
                        columnindex -= groupslength;
                        index -= groupslength;
                    }
                }
            }
            if (this.rowdetails) {
                if (columnindex - 1 >= 0) {
                    columnindex--;
                    index--;
                }
            }
            if (this.selectionmode == 'checkbox') {
                if (columnindex - 1 >= 0) {
                    columnindex--;
                    index--;
                }
            }

            var column = this._columns[columnindex];
            var oldColumn = this._columns[index];

            this._columns.splice(columnindex, 1);
            this._columns.splice(index, 0, column);

            this._raiseEvent(24, { columntext: column.text, datafield: column.datafield, oldindex: columnindex, newindex: index });
            if (refresh == false) return;

            if (hasHiddenColumns || column.columntype == "checkbox" || (oldColumn && oldColumn.columntype === "checkbox")) {
                this.prerenderrequired = true;
                this.rendergridcontent(true, false);
                this._updatecolumnwidths();
                this._updatecellwidths();
            }
            else {
                this._updatecolumnwidths();
                this._updatecellwidths();
            }
            if (this._updatefilterrowui && this.filterable && this.showfilterrow) {
                this._updatefilterrowui();
            }
            if (this.showeverpresentrow) {
                this._updateaddnewrowui();
            }
            this._rendercolumngroups();
            this._renderrows(this.virtualsizeinfo);

        },

        _pinnedColumnsLength: function () {
            var pinned = 0;
            $.each(this.columns.records, function () {
                if (this.pinned) pinned++;
                if (this.grouped) pinned++;
            });
            if (this.selectionmode == 'checkbox') pinned++;
            return pinned;
        },

        _handlecolumnsreorder: function () {
            var self = this;
            var dropindex = -1;
            var candrop = false;

            if (!self.columnsreorder)
                return;

            var mousemove = 'mousemove.reorder' + this.element.id;
            var mousedown = 'mousedown.reorder' + this.element.id;
            var mouseup = 'mouseup.reorder' + this.element.id;

            var touchdevice = false;
            if (this.isTouchDevice() && this.touchmode !== true) {
                touchdevice = true;
                mousemove = $.jqx.mobile.getTouchEventName('touchmove') + '.reorder' + this.element.id;
                mousedown = $.jqx.mobile.getTouchEventName('touchstart') + '.reorder' + this.element.id;
                mouseup = $.jqx.mobile.getTouchEventName('touchend') + '.reorder' + this.element.id;
            }

            this.removeHandler($(document), mousemove);
            this.addHandler($(document), mousemove, function (event) {
                if (self.resizing) {
                    return true;
                }

                if (self.reordercolumn != null) {
                    var left = parseInt(event.pageX);
                    var top = parseInt(event.pageY);
                    if (touchdevice) {
                        var touches = self.getTouches(event);
                        var touch = touches[0];
                        if (touch != undefined) {
                            left = parseInt(touch.pageX);
                            top = parseInt(touch.pageY);
                        }
                    }
                    var hostoffset = self.host.coord();
                    var hostleft = parseInt(hostoffset.left);
                    var hosttop = parseInt(hostoffset.top);
                    if (self.dragmousedownoffset == undefined || self.dragmousedownoffset == null) {
                        self.dragmousedownoffset = { left: 0, top: 0 };
                    }

                    var leftposition = parseInt(left) - parseInt(self.dragmousedownoffset.left);
                    var topposition = parseInt(top) - parseInt(self.dragmousedownoffset.top);

                    self.reordercolumn.css({ left: leftposition + 'px', top: topposition + 'px' });
                    candrop = false;
                    if (left >= hostleft && left <= hostleft + self.host.width()) {
                        if (top >= hosttop && top <= hosttop + self.host.height()) {
                            candrop = true;
                        }
                    }

                    dropindex = -1;
                    if (candrop) {
                        self.reordercolumnicon.removeClass(self.toThemeProperty('jqx-grid-dragcancel-icon'));
                        self.reordercolumnicon.addClass(self.toThemeProperty('jqx-grid-drag-icon'));
                        var groupsheaderoffset = self.columnsheader.coord();
                        var groupsheaderbottom = groupsheaderoffset.top + self.columnsheader.height();

                        if (self.columnsdropline != null) {
                            if (top >= groupsheaderoffset.top && top <= groupsheaderbottom) {
                                dropindex = self._handlereordercolumnsdroplines(left);
                            }
                            else {
                                self.columnsdropline.fadeOut('slow');
                            }
                        }
                    }
                    else {
                        if (self.columnsdropline != null) {
                            self.columnsdropline.fadeOut('slow');
                        }

                        self.reordercolumnicon.removeClass(self.toThemeProperty('jqx-grid-drag-icon'));
                        self.reordercolumnicon.addClass(self.toThemeProperty('jqx-grid-dragcancel-icon'));
                    }
                    if (touchdevice) {
                        event.preventDefault();
                        event.stopPropagation();
                        return false;
                    }
                }
            });

            this.columnsbounds = new Array();

            this.removeHandler($(document), mousedown);
            this.addHandler($(document), mousedown, function (event) {
                if (self.resizing) {
                    return true;
                }

                self.columnsbounds = new Array();
                var left = self.host.coord().left;
                var top = self.host.coord().top;
                if (self.showtoolbar) top += self.toolbarheight;
                if (self.groupable && self.showgroupsheader) top += self.groupsheaderheight;
                if (self.showfilterbar) {
                    top += self.toolbarheight;
                }
                var columnIndex = 0;
                $.each(self.columns.records, function (index) {
                    var column = this;

                    if (column.hidden) {
                        self.columnsbounds[self.columnsbounds.length] = { top: top, column: column, left: left, width: 0, height: 2 + self.rowsheight };
                        return true;
                    }

                    if (columnIndex == 0) {
                        if (!self.rtl) {
                            left = parseInt(self.host.coord().left) - self.hScrollInstance.value;
                        }
                        else {
                            if (self.hScrollBar.css('visibility') != "hidden") {
                                left = parseInt(self.host.coord().left) - self.hScrollInstance.max + self.hScrollInstance.value;
                            }
                            else {
                                if (self.vScrollBar.css('visibility') == "hidden") {
                                    left = $(column.element).coord().left;
                                }
                                else {
                                    left = $(column.element).coord().left - self.vScrollBar.width() - self.host.offset().left;
                                }
                            }
                        }
                    }
                    columnIndex++;
                    var height = 2 + self.columnsheight;
                    if (self.columnshierarchy) {
                        top = $(column.uielement).coord().top;
                        height = $(column.uielement).height();
                    }
                    self.columnsbounds[self.columnsbounds.length] = { top: top, column: column, left: left, width: column.width, height: height };
                    left += column.width;
                });
            });
            this.removeHandler($(document), mouseup);
            this.addHandler($(document), mouseup, function (event) {
                if (self.resizing) {
                    return true;
                }

                self.__drag = false;

                $(document.body).removeClass('jqx-disableselect');
                var left = parseInt(event.pageX);
                var top = parseInt(event.pageY);
                if (touchdevice) {
                    var touches = self.getTouches(event);
                    var touch = touches[0];
                    left = parseInt(touch.pageX);
                    top = parseInt(touch.pageY);
                }
                var hostoffset = self.host.coord();
                var hostleft = parseInt(hostoffset.left);
                var hosttop = parseInt(hostoffset.top);
                var groupsheaderheight = self.groupsheader.height();
                if (self.showtoolbar) {
                    hosttop += self.toolbarheight;
                }
                if (self.showfilterbar) {
                    hosttop += self.toolbarheight;
                }

                self.columndragstarted = false;
                self.dragmousedown = null;
                if (self.reordercolumn != null) {
                    var datafield = $.data(self.reordercolumn[0], 'reorderrecord');
                    var oldindex = self.columns.records.indexOf(self.getcolumn(datafield));
                    self.reordercolumn.remove();
                    self.reordercolumn = null;
                    var minIndex = 0;
                    //   minIndex += self.rowdetails ? 1 : 0;
                    minIndex += self._pinnedColumnsLength();

                    if (datafield != null) {
                        if (candrop) {
                            if (dropindex != -1) {
                                var index = dropindex.index;
                                if (index >= minIndex) {
                                    var targetcolumn = self.columns.records[index];
                                    if (targetcolumn != undefined) {
                                        var columnindex = self.columns.records.indexOf(self.getcolumn(targetcolumn.datafield));
                                        if (targetcolumn.datafield == null) {
                                            var columnindex = self.columns.records.indexOf(self.getcolumnbytext(targetcolumn.text));
                                        }
                                        if (self.columngroups) {
                                            var target = targetcolumn;
                                            if (oldindex < columnindex) {
                                                if (dropindex.position == 'before') {
                                                    target = self.columns.records[columnindex - 1];
                                                }
                                            }

                                            if (target.columngroup != self.getcolumn(datafield).columngroup) {
                                                if (self.columnsdropline != null) {
                                                    self.columnsdropline.remove();
                                                    self.columnsdropline = null;
                                                }
                                                return;
                                            }
                                        }

                                        if (oldindex < columnindex) {
                                            if (dropindex.position == 'before') {
                                                self.setcolumnindex(datafield, columnindex - 1);
                                            }
                                            else {
                                                self.setcolumnindex(datafield, columnindex);
                                            }
                                        }
                                        else if (oldindex > columnindex) {
                                            self.setcolumnindex(datafield, columnindex);
                                        }
                                        if (self.autosavestate) {
                                            if (self.savestate) self.savestate();
                                        }
                                    }
                                }
                            }
                        }

                        if (self.columnsdropline != null) {
                            self.columnsdropline.remove();
                            self.columnsdropline = null;
                        }
                    }
                }
            });
        },

        getcolumnbytext: function (text) {
            var column = null;
            if (this.columns.records) {
                $.each(this.columns.records, function () {
                    if (this.text == text) {
                        column = this;
                        return false;
                    }
                });
            }
            return column;
        },

        _handlereordercolumnsdroplines: function (left) {
            var self = this;
            var dropindex = -1;
            var minIndex = self._pinnedColumnsLength();
            var hostleft = parseInt(self.host.coord().left);
            var hostright = hostleft + self.host.width();
            var leftOffset = self.vScrollBar.css('visibility') != 'hidden' ? 19 : 0;
            if (!self.rtl) leftOffset = 0;

            $.each(self.columnsbounds, function (index) {
                if (index >= minIndex) {
                    if (this.width == 0) return true;

                    if (left <= this.left + this.width / 2) {
                        if (left > hostright) {
                            self.columnsdropline.fadeOut();
                            return false;
                        }
                        self.columnsdropline.css('left', leftOffset + parseInt(this.left) + 'px');
                        self.columnsdropline.css('top', parseInt(this.top) + 'px');
                        self.columnsdropline.height(this.height);
                        self.columnsdropline.fadeIn('slow');
                        dropindex = { index: index, position: 'before' }
                        return false;
                    }
                    else if (left >= this.left + this.width / 2) {
                        if (this.left + this.width > hostright) {
                            self.columnsdropline.fadeOut();
                            return false;
                        }

                        self.columnsdropline.css('left', leftOffset + 1 + this.left + this.width);
                        self.columnsdropline.css('top', this.top);
                        self.columnsdropline.height(this.height);
                        self.columnsdropline.fadeIn('slow');
                        dropindex = { index: index, position: 'after' }
                    }
                }
            });

            return dropindex;
        },

        _createreordercolumn: function (column, position, hascolumnsdropline) {
            var me = this;
            var mousemove = position;

            if (me.reordercolumn) me.reordercolumn.remove();
            if (me.columnsdropline) me.columnsdropline.remove();
            me.reordercolumn = $('<div></div>');
            var columnclone = column.clone();
            me.reordercolumn.css('z-index', 999999);
            columnclone.css('border-width', '1px');
            columnclone.css('opacity', '0.4');
            var menubutton = $(columnclone.find('.' + me.toThemeProperty('jqx-grid-column-menubutton')));
            if (menubutton.length > 0) {
                menubutton.css('display', 'none');
            }
            var closebutton = $(columnclone.find('.jqx-icon-close'));
            if (closebutton.length > 0) {
                closebutton.css('display', 'none');
            }

            me.reordercolumnicon = $('<div style="z-index: 9999; position: absolute; left: 100%; top: 50%; margin-left: -18px; margin-top: -7px;"></div>');
            me.reordercolumnicon.addClass(me.toThemeProperty('jqx-grid-drag-icon'));
            me.reordercolumn.css('float', 'left');
            me.reordercolumn.css('position', 'absolute');
            var hostoffset = me.host.coord();
            columnclone.width(column.width() + 16);
            me.reordercolumn.append(columnclone);
            me.reordercolumn.height(column.height());
            me.reordercolumn.width(columnclone.width());
            me.reordercolumn.append(me.reordercolumnicon);
            $(document.body).append(me.reordercolumn);

            columnclone.css('margin-left', 0);
            columnclone.css('left', 0);
            columnclone.css('top', 0);
            me.reordercolumn.css('left', mousemove.left + me.dragmousedown.left);
            me.reordercolumn.css('top', mousemove.top + me.dragmousedown.top);

            if (hascolumnsdropline != undefined && hascolumnsdropline) {
                me.columnsdropline = $('<div style="z-index: 9999; display: none; position: absolute;"></div>');

                me.columnsdropline.width(2);
                me.columnsdropline.addClass(me.toThemeProperty('jqx-grid-group-drag-line'));
                $(document.body).append(me.columnsdropline);
            }
        },

        _handlecolumnsdragreorder: function (record, column) {
            if (this.reordercolumn) this.reordercolumn.remove();
            if (this.columnsdropline) this.columnsdropline.remove();

            this.dragmousedown = null;
            this.dragmousedownoffset = null;
            this.columndragstarted = false;
            this.reordercolumn = null;

            var me = this;
            var mousemove;
            var touchdevice = false;
            if (this.isTouchDevice() && this.touchmode !== true) {
                touchdevice = true;
            }

            var mousedown = 'mousedown.drag';
            var mousemove = 'mousemove.drag';
            if (touchdevice) {
                mousedown = $.jqx.mobile.getTouchEventName('touchstart') + '.drag';
                mousemove = $.jqx.mobile.getTouchEventName('touchmove') + '.drag';
            }
            else {
                this.addHandler(column, 'dragstart', function (event) {
                    return false;
                });
            }
            this.addHandler(column, mousedown, function (event) {
                if (false == record.draggable) {
                    return true;
                }
                if (me.resizing) {
                    return true;
                }

                me.__drag = true;

                var pagex = event.pageX;
                var pagey = event.pageY;
                if (touchdevice) {
                    var touches = me.getTouches(event);
                    var touch = touches[0];
                    pagex = touch.pageX;
                    pagey = touch.pageY;
                }

                me.dragmousedown = { left: pagex, top: pagey };

                var offsetposition = $(event.target).coord();
                me.dragmousedownoffset = { left: parseInt(pagex) - parseInt(offsetposition.left), top: parseInt(pagey - offsetposition.top) };
                return true;
            });

            this.addHandler(column, mousemove, function (event) {
                if (!record.draggable) return true;
                if (undefined == record.datafield) return true;
                if (record.pinned) return true;
                if (me.resizing) {
                    return true;
                }

                if (me.dragmousedown) {
                    var pagex = event.pageX;
                    var pagey = event.pageY;
                    if (touchdevice) {
                        var touches = me.getTouches(event);
                        var touch = touches[0];
                        if (touch != undefined) {
                            pagex = touch.pageX;
                            pagey = touch.pageY;
                        }
                    }
                    mousemove = { left: pagex, top: pagey };
                    if (!me.columndragstarted && me.reordercolumn == null) {
                        var xoffset = Math.abs(mousemove.left - me.dragmousedown.left);
                        var yoffset = Math.abs(mousemove.top - me.dragmousedown.top);
                        if (xoffset > 3 || yoffset > 3) {
                            me._createreordercolumn(column, mousemove, true);
                            $(document.body).addClass('jqx-disableselect');
                            $.data(me.reordercolumn[0], 'reorderrecord', record.datafield);
                        }
                    }
                }
            });
        }
    });
})(jqxBaseFramework);
})();



/***/ }),

/***/ 4854:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {

    $.extend($.jqx._jqxGrid.prototype, {
        autoresizecolumns: function (resizetype, additionalwidth) {
            if (resizetype != 'cells' && resizetype != 'all' && resizetype != 'column') resizetype = 'all';
            var me = this.that;
            var rows = this.getrows();
            if (this.pageable) {
                rows = this.dataview.rows;
                if (this.groupable) {
                    rows = this.dataview.records;
                }
            }
            if (additionalwidth == undefined) additionalwidth = 0;
            else additionalwidth = parseInt(additionalwidth);

            var length = rows.length;
            if (length == undefined && rows != undefined) {
                var rowsArr = new Array();
                $.each(rows, function (index) {
                    rowsArr.push(this);
                });
                rows = rowsArr;
                length = rows.length;
            }

            var span = $("<span></span>");
            span.addClass(this.toThemeProperty('jqx-widget'));
            span.addClass(this.toThemeProperty('jqx-grid-cell'));
            $(document.body).append(span);
            var textlength = [];
            var maxLength = [];
            var maxText = [];
            var maxUppers = [];
            var hostwidth = me.host.width();
            var totalWidth = 0;

            if (me.vScrollBar[0].style.visibility != 'hidden') {
                hostwidth -= this.scrollbarsize + 5;
            }
            if (hostwidth < 0) hostwidth = 0;

            for (var i = 0; i < length; i++) {
                var row = rows[i];

                for (var j = 0; j < this.columns.records.length; j++) {
                    var column = this.columns.records[j];
                    if (column.hidden) continue;
                    if (this.groups.length > 0 && j <= this.groups.length - 1) {
                        continue;
                    }

                    if (maxLength[column.displayfield] == undefined) {
                        maxLength[column.displayfield] = 0;
                    }

                    if (maxText[column.displayfield] == undefined) {
                        maxText[column.displayfield] = "";
                    }

                    var text = row[column.displayfield];
                    if (column.cellsformat != '') {
                        if ($.jqx.dataFormat) {
                            if ($.jqx.dataFormat.isDate(text)) {
                                text = $.jqx.dataFormat.formatdate(text, column.cellsformat, this.gridlocalization);
                            }
                            else if ($.jqx.dataFormat.isNumber(text)) {
                                text = $.jqx.dataFormat.formatnumber(text, column.cellsformat, this.gridlocalization);
                            }
                        }
                    }
                    else if (column.cellsrenderer) {
                        var defaultcellsrenderer = me._defaultcellsrenderer(text, column);

                        var result = column.cellsrenderer(i, column.datafield, text, defaultcellsrenderer, column.getcolumnproperties(), row);
                        if (result != undefined) {
                            text = $(result).text();
                        }
                    }

                    if (resizetype == undefined || resizetype == 'cells' || resizetype == 'all') {
                        if (text != null) {
                            var textlength = text.toString().length;
                            var str = text.toString();
                            var charslength = str.replace(/[^A-Z]/g, "").length;

                            if (textlength > maxLength[column.displayfield]) {
                                maxLength[column.displayfield] = textlength;
                                maxText[column.displayfield] = text;
                                maxUppers[column.displayfield] = charslength;
                            }

                            if (textlength > 0 && textlength >= charslength) {
                                var k1 = charslength * 20 + (textlength - charslength) * 15
                                var k2 = maxUppers[column.displayfield] * 20 + (maxLength[column.displayfield] - maxUppers[column.displayfield]) * 15;
                                if (k1 > k2 && k1 > 0 && k2 > 0) {
                                    maxLength[column.displayfield] = textlength;
                                    maxText[column.displayfield] = text;
                                    maxUppers[column.displayfield] = charslength;
                                }
                            }
                        }
                    }

                    if (resizetype == 'column' || resizetype == 'all') {
                        if (column.text === null || column.text === undefined) {
                            column.text = '';
                        }

                        if (column.text.toString().length > maxLength[column.displayfield]) {
                            maxText[column.displayfield] = column.text;
                            maxLength[column.displayfield] = column.text.length;
                            var str = column.text.toString();
                            var charslength = str.replace(/[^A-Z]/g, "").length;
                            maxUppers[column.displayfield] = charslength;
                        }
                        var text = column.text;
                        var textlength = text.toString().length;
                        var str = text.toString();
                        var charslength = str.replace(/[^A-Z]/g, "").length;

                        if (textlength > 0 && textlength >= charslength) {
                            var k1 = charslength * 20 + (textlength - charslength) * 15
                            var k2 = maxUppers[column.displayfield] * 20 + (maxLength[column.displayfield] - maxUppers[column.displayfield]) * 15;
                            if (k1 > k2 && k1 > 0 && k2 > 0) {
                                maxLength[column.displayfield] = textlength;
                                maxText[column.displayfield] = text;
                                maxUppers[column.displayfield] = charslength;
                            }
                        }
                    }
                }
            }
            if (!this.columns.records) {
                return;
            }

            var columnsCount = 0;
            for (var j = 0; j < this.columns.records.length; j++) {
                var column = this.columns.records[j];
                if (!column.displayfield)
                    continue;

                if (maxText[column.displayfield] == undefined) {
                    maxText[column.displayfield] = column.text;
                }
                if (span[0].className.indexOf('jqx-grid-column-header') >= 0) {
                    span.removeClass(this.toThemeProperty('jqx-grid-column-header'));
                }
                if (maxText[column.displayfield] == column.text) {
                    span.addClass(this.toThemeProperty('jqx-grid-column-header'));
                }

                span[0].innerHTML = this.escape_HTML(maxText[column.displayfield].toString());
                var maxWidth = span.outerWidth() + 10;
                if (span.children().length > 0) {
                    maxWidth = span.children().outerWidth() + 10;
                }
                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                    maxWidth += 10;
                }
                if (this.filterable && this.showfilterrow) {
                    maxWidth += 5;
                }
                maxWidth += additionalwidth;
                maxWidth += 20;
                if (maxWidth > column.maxwidth) maxWidth = column.maxwidth;

                if (column._width != undefined) column.__width = column._width;
                column._width = null;
                if (column.maxwidth == 'auto' || maxWidth <= column.maxwidth) {
                    var oldwidth = column.width;
                    if (maxWidth < column.minwidth) {
                        maxWidth = column.minwidth;
                    }

                    column.width = maxWidth;
                    if (column._percentagewidth != undefined) {
                        column._percentagewidth = null;
                    }
                    this._raiseEvent(14, { columntext: column.text, column: column.getcolumnproperties(), datafield: column.datafield, displayfield: column.displayfield, oldwidth: oldwidth, newwidth: maxWidth });
                }
                totalWidth += column.width;
                columnsCount++;
            }

            if (totalWidth < hostwidth) {
                var remainingWidthProportion = Math.round((hostwidth - totalWidth - 2) / columnsCount);

                for (var j = 0; j < this.columns.records.length; j++) {
                    var column = this.columns.records[j];
                    if (!column.displayfield)
                        continue;
                    column._width = null;
                    column.width += remainingWidthProportion;
                }
            }

            span.remove();
            this._updatecolumnwidths();
            this._updatecellwidths();
            this._renderrows(this.virtualsizeinfo);
            for (var j = 0; j < this.columns.records.length; j++) {
                var column = this.columns.records[j];
                if (column.__width != undefined) {
                    column._width = column.__width;
                }
            }
        },

        autoresizecolumn: function (datafield, resizetype, additionalwidth) {
            if (resizetype != 'cells' && resizetype != 'all' && resizetype != 'column') resizetype = 'all';
            if (datafield == undefined) {
                return false;
            }

            var rows = this.getrows();
            if (this.pageable) {
                rows = this.dataview.rows;
                if (this.groupable) {
                    rows = this.dataview.records;
                }
            }

            var column = this.getcolumn(datafield);
            if (column == undefined) {
                return false;
            }

            if (additionalwidth == undefined) additionalwidth = 0;
            else additionalwidth = parseInt(additionalwidth);

            var length = rows.length;
            var span = $("<span></span>");
            span.addClass(this.toThemeProperty('jqx-widget'));
            span.addClass(this.toThemeProperty('jqx-grid-cell'));
            $(document.body).append(span);
            var maxLength = 0;
            var maxText = "";
            var maxUppers = 0;

            var me = this.that;
            var hostwidth = me.host.width();
            if (me.vScrollBar[0].style.visibility != 'hidden') {
                hostwidth -= this.scrollbarsize + 5;
            }
            if (hostwidth < 0) hostwidth = 0;

            if (resizetype == undefined || resizetype == 'cells' || resizetype == 'all') {
                for (var i = 0; i < length; i++) {
                    var text = rows[i][column.displayfield];
                    if (column.cellsformat != '') {
                        if ($.jqx.dataFormat) {
                            if ($.jqx.dataFormat.isDate(text)) {
                                text = $.jqx.dataFormat.formatdate(text, column.cellsformat, this.gridlocalization);
                            }
                            else if ($.jqx.dataFormat.isNumber(text)) {
                                text = $.jqx.dataFormat.formatnumber(text, column.cellsformat, this.gridlocalization);
                            }
                        }
                    } else if (column.cellsrenderer) {
                        var result = column.cellsrenderer(i, column, text);
                        if (result != undefined) {
                            text = $(result).text();
                        }
                    }

                    if (text != null) {
                        var textlength = text.toString().length;
                        var str = text.toString();
                        var charslength = str.replace(/[^A-Z]/g, "").length;
                        if (textlength > maxLength) {
                            maxLength = textlength;
                            maxText = text;
                            maxUppers = charslength;
                        }
                        if (textlength > 0 && textlength >= charslength) {
                            var k1 = charslength * 20 + (textlength - charslength) * 15
                            var k2 = maxUppers * 20 + (maxLength - maxUppers) * 15;
                            if (k1 > k2 && k1 > 0 && k2 > 0) {
                                maxLength = textlength;
                                maxText = text;
                                maxUppers = charslength;
                            }
                        }
                    }
                }
            }

            if (resizetype == 'column' || resizetype == 'all') {
                if (column.text.toString().length > maxLength) {
                    maxText = column.text;
                }

                var text = column.text.toString();
                var textlength = text.toString().length;
                var str = text.toString();
                var charslength = str.replace(/[^A-Z]/g, "").length;

                if (textlength > 0 && textlength >= charslength) {
                    var k1 = charslength * 20 + (textlength - charslength) * 15
                    var k2 = maxUppers * 20 + (maxLength - maxUppers) * 15;
                    if (k1 > k2 && k1 > 0 && k2 > 0) {
                        maxLength = textlength;
                        maxText = text;
                        maxUppers = charslength;
                    }
                }
            }
            if (maxText == undefined) {
                maxText = column.text;
            }

            span[0].innerHTML = this.escape_HTML(maxText);
            if (maxText == column.text) {
                span.addClass(this.toThemeProperty('jqx-grid-column-header'));
            }
            var maxWidth = span.outerWidth() + 10;
            if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                maxWidth += 5;
            }
            if (this.filterable && this.showfilterrow) {
                maxWidth += 5;
            }
            maxWidth += additionalwidth;

            span.remove();
            if (maxWidth > column.maxwidth) maxWidth = column.maxwidth;

            if (column.maxwidth == 'auto' || maxWidth <= column.maxwidth) {
                var oldwidth = column.width;
                if (maxWidth < column.minwidth) maxWidth = column.minwidth;
                column.width = maxWidth;
                if (column._width != undefined) column.__width = column._width;
                column._width = null;
                if (column._percentagewidth != undefined) {
                    column._percentagewidth = null;
                }
                this._updatecolumnwidths();
                this._updatecellwidths();
                this._raiseEvent(14, { columntext: column.text, column: column.getcolumnproperties(), datafield: datafield, displayfield: column.displayfield, oldwidth: oldwidth, newwidth: maxWidth });
                this._renderrows(this.virtualsizeinfo);
                if (column._width != undefined)
                    column._width = column.__width;
            }
        },

        _handlecolumnsresize: function () {
            var self = this.that;
            if (this.columnsresize) {
                var touchdevice = false;
                if (self.isTouchDevice() && self.touchmode !== true) {
                    touchdevice = true;
                }
                var mousemove = 'mousemove.resize' + this.element.id;
                var mousedown = 'mousedown.resize' + this.element.id;
                var mouseup = 'mouseup.resize' + this.element.id;
                if (touchdevice) {
                    var mousemove = $.jqx.mobile.getTouchEventName('touchmove') + '.resize' + this.element.id;
                    var mousedown = $.jqx.mobile.getTouchEventName('touchstart') + '.resize' + this.element.id;
                    var mouseup = $.jqx.mobile.getTouchEventName('touchend') + '.resize' + this.element.id;
                }

                this.removeHandler($(document), mousemove);
                this.addHandler($(document), mousemove, function (event) {
                    var openedmenu = $.data(document.body, "contextmenu" + self.element.id);
                    if (openedmenu != null && self.autoshowcolumnsmenubutton)
                        return true;

                    if (self.resizablecolumn != null && !self.disabled && self.resizing) {
                        if (self.resizeline != null) {
                            var resizeElement = self.resizablecolumn.columnelement;

                            var hostoffset = self.host.coord();
                            var startleft = parseInt(self.resizestartline.coord().left);

                            var minleft = startleft - self._startcolumnwidth
                            var mincolumnwidth = self.resizablecolumn.column.minwidth;
                            if (mincolumnwidth == 'auto') mincolumnwidth = 0;
                            else mincolumnwidth = parseInt(mincolumnwidth);
                            var maxcolumnwidth = self.resizablecolumn.column.maxwidth;
                            if (maxcolumnwidth == 'auto') maxcolumnwidth = 0;
                            else maxcolumnwidth = parseInt(maxcolumnwidth);
                            var pageX = event.pageX;
                            if (touchdevice) {
                                var touches = self.getTouches(event);
                                var touch = touches[0];
                                pageX = touch.pageX;
                            }

                            minleft += mincolumnwidth;

                            var maxleft = maxcolumnwidth > 0 ? startleft + maxcolumnwidth : 0;
                            var canresize = maxcolumnwidth == 0 ? true : self._startcolumnwidth + pageX - startleft < maxcolumnwidth ? true : false;
                            if (self.rtl) {
                                var canresize = true;
                            }

                            if (canresize) {
                                if (!self.rtl) {
                                    if (pageX >= hostoffset.left && pageX >= minleft) {
                                        if (maxleft != 0 && event.pageX < maxleft) {
                                            self.resizeline.css('left', pageX);
                                        }
                                        else if (maxleft == 0) {
                                            self.resizeline.css('left', pageX);
                                        }

                                        if (touchdevice)
                                            return false;
                                    }
                                }
                                else {
                                    if (pageX >= hostoffset.left && pageX <= hostoffset.left + self.host.width()) {
                                        self.resizeline.css('left', pageX);

                                        if (touchdevice)
                                            return false;
                                    }
                                }
                            }
                        }
                    }

                    if (!touchdevice && self.resizablecolumn != null)
                        return false;
                });

                this.removeHandler($(document), mousedown);
                this.addHandler($(document), mousedown, function (event) {
                    var openedmenu = $.data(document.body, "contextmenu" + self.element.id);
                    if (openedmenu != null && self.autoshowcolumnsmenubutton)
                        return true;

                    if (self.resizablecolumn != null && !self.disabled && self.columnsresize) {
                        var resizeElement = self.resizablecolumn.columnelement;
                        if (resizeElement.coord().top + resizeElement.height() + 5 < event.pageY) {
                            self.resizablecolumn = null;
                            return;
                        }

                        if (resizeElement.coord().top - 5 > event.pageY) {
                            self.resizablecolumn = null;
                            return;
                        }

                        self._startcolumnwidth = self.resizablecolumn.column.width;
                        self.resizablecolumn.column._width = null;
                        $(document.body).addClass('jqx-disableselect');
                        $(document.body).addClass('jqx-position-reset');
                        self.host.addClass('jqx-disableselect');
                        self.content.addClass('jqx-disableselect');


                        self._mouseDownResize = new Date();
                        self.resizing = true;

                        if (self._lastmouseDownResize && self.columnsautoresize) {
                            if (self._lastmouseDownResize - self._mouseDownResize < 300 && self._lastmouseDownResize - self._mouseDownResize > -500) {
                                var column = self.resizablecolumn.column;
                                if (column.resizable) {
                                    var width = self.resizablecolumn.column.width;
                                    var scrollVisibility = self.hScrollBar[0].style.visibility;


                                    self._resizecolumn = null;

                                    self.resizeline.hide();
                                    self.resizestartline.hide();
                                    self.resizebackground.remove();
                                    self.resizablecolumn = null;
                                    self.columndragstarted = false;
                                    self.dragmousedown = null;
                                    self.__drag = false;

                                    self.autoresizecolumn(column.displayfield, "all");
                                    if (scrollVisibility != self.hScrollBar[0].style.visibility) {
                                        self.hScrollInstance.setPosition(0);
                                    }
                                    if (self.rtl) {
                                        self._arrange();
                                    }
                                    if (self.autosavestate) {
                                        if (self.savestate) self.savestate();
                                    }
                                    event.stopPropagation();
                                    self.suspendClick = true;
                                    setTimeout(function () {
                                        self.suspendClick = false;
                                    }, 100);
                                    return false;
                                }
                            }
                        }

                        self._lastmouseDownResize = new Date();

                        self._resizecolumn = self.resizablecolumn.column;
                        self.resizeline = self.resizeline || $('<div style="position: absolute;"></div>');
                        self.resizestartline = self.resizestartline || $('<div style="position: absolute;"></div>');

                        self.resizebackground = self.resizebackground || $('<div style="position: absolute; left: 0; top: 0; background: #000;"></div>');
                        self.resizebackground.css('opacity', 0.01);
                        self.resizebackground.css('cursor', "col-resize");
                        self.resizeline.css('cursor', 'col-resize');
                        self.resizestartline.css('cursor', 'col-resize');

                        self.resizeline.addClass(self.toThemeProperty('jqx-grid-column-resizeline'));
                        self.resizestartline.addClass(self.toThemeProperty('jqx-grid-column-resizestartline'));

                        $(document.body).append(self.resizeline);
                        $(document.body).append(self.resizestartline);
                        $(document.body).append(self.resizebackground);
                        var resizelineoffset = self.resizablecolumn.columnelement.coord();
                        self.resizebackground.css('left', self.host.coord().left);
                        self.resizebackground.css('top', self.host.coord().top);
                        self.resizebackground.width(self.host.width());
                        self.resizebackground.height(self.host.height());
                        self.resizebackground.css('z-index', 9999);

                        var positionline = function (resizeline) {
                            if (!self.rtl) {
                                resizeline.css('left', parseInt(resizelineoffset.left) + self._startcolumnwidth);
                            }
                            else {
                                resizeline.css('left', parseInt(resizelineoffset.left));
                            }

                            var hasgroups = self._groupsheader();
                            var groupsheaderheight = hasgroups ? self.groupsheader.height() : 0;
                            var toolbarheight = self.showtoolbar ? self.toolbarheight : 0;
                            groupsheaderheight += toolbarheight;
                            var statusbarheight = self.showstatusbar ? self.statusbarheight : 0;
                            groupsheaderheight += statusbarheight;

                            var pagerheight = 0;
                            if (self.pageable) {
                                pagerheight = self.pagerheight;
                            }
                            var scrollbaroffset = self.hScrollBar.css('visibility') == 'visible' ? 17 : 0;

                            resizeline.css('top', parseInt(resizelineoffset.top));
                            resizeline.css('z-index', 99999);
                            if (self.columngroups) {
                                resizeline.height(self.host.height() + self.resizablecolumn.columnelement.height() - pagerheight - groupsheaderheight - scrollbaroffset - self.columngroupslevel * self.columnsheight);
                            }
                            else {
                                resizeline.height(self.host.height() - pagerheight - groupsheaderheight - scrollbaroffset);
                            }
                            if (self.enableanimations) {
                                resizeline.show('fast');
                            }
                            else {
                                resizeline.show();
                            }
                        }
                        positionline(self.resizeline);
                        positionline(self.resizestartline);

                        self.dragmousedown = null;
                    }
                });

                var doresize = function () {
                    $(document.body).removeClass('jqx-disableselect');
                    $(document.body).removeClass('jqx-position-reset');

                    if (self.showfilterrow || self.showstatusbar || self.showtoolbar || self.enablebrowserselection) {
                        self.host.removeClass('jqx-disableselect');
                        self.content.removeClass('jqx-disableselect');
                    }

                    if (!self.resizing)
                        return;

                    self._mouseUpResize = new Date();
                    var timeout = self._mouseUpResize - self._mouseDownResize;
                    if (timeout < 200) {
                        self.resizing = false;
                        if (self._resizecolumn != null && self.resizeline != null && self.resizeline.css('display') == 'block') {
                            self._resizecolumn = null;
                            self.resizeline.hide();
                            self.resizestartline.hide();
                            self.resizebackground.remove();
                        }
                        return;
                    }

                    self.resizing = false;

                    if (self.disabled)
                        return;

                    var hostwidth = self.host.width();
                    if (self.vScrollBar[0].style.visibility != 'hidden') hostwidth -= 20;
                    if (hostwidth < 0) hostwidth = 0;

                    if (self._resizecolumn != null && self.resizeline != null && self.resizeline.css('display') == 'block') {
                        var resizelineleft = parseInt(self.resizeline.css('left'));
                        var resizestartlineleft = parseInt(self.resizestartline.css('left'));

                        var newwidth = self._startcolumnwidth + resizelineleft - resizestartlineleft;
                        if (self.rtl) {
                            var newwidth = self._startcolumnwidth - resizelineleft + resizestartlineleft;
                        }

                        var oldwidth = self._resizecolumn.width;
                        self._closemenu();
                        if (newwidth < self._resizecolumn.minwidth)
                            newwidth = self._resizecolumn.minwidth;

                        self._resizecolumn.width = newwidth;
                        if (self._resizecolumn._percentagewidth != undefined) {
                            self._resizecolumn._percentagewidth = (newwidth / hostwidth) * 100;
                        }

                        for (var m = 0; m < self._columns.length; m++) {
                            if (self._columns[m].datafield === self._resizecolumn.datafield) {
                                self._columns[m].width = self._resizecolumn.width;
                                if (self._columns[m].width < self._resizecolumn.minwidth)
                                    self._columns[m].width = self._resizecolumn.minwidth;
                                break;
                            }
                        }

                        var scrollVisibility = self.hScrollBar[0].style.visibility;

                        self._updatecolumnwidths();
                        self._updatecellwidths();
                        self._raiseEvent(14, { columntext: self._resizecolumn.text, column: self._resizecolumn.getcolumnproperties(), datafield: self._resizecolumn.datafield, oldwidth: oldwidth, newwidth: newwidth });
                        self._renderrows(self.virtualsizeinfo);
                        if (self.autosavestate) {
                            if (self.savestate) self.savestate();
                        }
                        if (scrollVisibility != self.hScrollBar[0].style.visibility) {
                            self.hScrollInstance.setPosition(0);
                        }
                        if (self.rtl) {
                            self._arrange();
                        }

                        self._resizecolumn = null;

                        self.resizeline.hide();
                        self.resizestartline.hide();
                        self.resizebackground.remove();
                        self.resizablecolumn = null;
                    }
                    else {
                        self.resizablecolumn = null;
                    }
                }

                try {
                    if (document.referrer != "" || window.frameElement) {
                        var parentLocation = null;
                        if (window.top != null && window.top != window.self) {
                            if (window.parent && document.referrer) {
                                parentLocation = document.referrer;
                            }
                        }

                        if (parentLocation && parentLocation.indexOf(document.location.host) != -1) {
                            var eventHandle = function (event) {
                                doresize();
                            };

                            if (window.top.document.addEventListener) {
                                window.top.document.addEventListener('mouseup', eventHandle, false);

                            } else if (window.top.document.attachEvent) {
                                window.top.document.attachEvent("on" + 'mouseup', eventHandle);
                            }
                        }
                    }
                }
                catch (error) {
                }

                this.removeHandler($(document), mouseup);
                this.addHandler($(document), mouseup, function (event) {
                    var openedmenu = $.data(document.body, "contextmenu" + self.element.id);
                    if (openedmenu != null && self.autoshowcolumnsmenubutton)
                        return true;

                    doresize();
                });
            }
        }
    });
})(jqxBaseFramework);
})();





/***/ }),

/***/ 5574:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {

        $.extend($.jqx._jqxGrid.prototype, {
            _handledblclick: function (event, self) {
                if (event.target == null) {
                    return;
                }

                if (self.disabled) {
                    return;
                }

                if ($(event.target).ischildof(this.columnsheader)) {
                    return;
                }

                var rightclick;
                if (event.which) rightclick = (event.which == 3);
                else if (event.button) rightclick = (event.button == 2);

                if (rightclick) {
                    return;
                }

                var middleclick;
                if (event.which) middleclick = (event.which == 2);
                else if (event.button) middleclick = (event.button == 1);

                if (middleclick) {
                    return;
                }

                var columnheaderheight = this.showheader ? this.columnsheader.height() + 2 : 0;
                var groupsheaderheight = this._groupsheader() ? this.groupsheader.height() : 0;
                var toolbarheight = this.showtoolbar ? this.toolbarheight : 0;
                var filterheight = this.showfilterbar ? this.toolbarheight : 0;

                groupsheaderheight += toolbarheight;
                groupsheaderheight += filterheight;

                var hostoffset = this.host.offset();
                var x = event.pageX - hostoffset.left;
                var y = event.pageY - columnheaderheight - hostoffset.top - groupsheaderheight;
                var rowinfo = this._hittestrow(x, y);
                if (!rowinfo)
                    return;
                var row = rowinfo.row;
                var index = rowinfo.index;
                var targetclassname = event.target.className;
                var tablerow = this.table[0].rows[index];
                if (tablerow == null)
                    return;

                self.mousecaptured = true;
                self.mousecaptureposition = { left: event.pageX, top: event.pageY - groupsheaderheight };

                var hScrollInstance = this.hScrollInstance;
                var horizontalscrollvalue = hScrollInstance.value;
                var cellindex = 0;
                var groupslength = this.groupable ? this.groups.length : 0;

                for (var i = 0; i < tablerow.cells.length; i++) {
                    var columnleft = parseInt($(this.columnsrow[0].cells[i]).css('left'));
                    var left = columnleft - horizontalscrollvalue;
                    if (self.columns.records[i].pinned) {
                        left = columnleft;
                    }

                    var column = this._getcolumnat(i);
                    if (column != null && column.hidden) {
                        continue;
                    }

                    var right = left + $(this.columnsrow[0].cells[i]).width();
                    if (right >= x && x >= left) {
                        cellindex = i;
                        break;
                    }
                }

                if (row != null) {
                    var column = this._getcolumnat(cellindex);
                    if (!(targetclassname.indexOf('jqx-grid-group-expand') != -1 || targetclassname.indexOf('jqx-grid-group-collapse') != -1)) {
                        if (row.boundindex != -1) {
                            self.begincelledit(self.getboundindex(row), column.datafield, column.defaulteditorvalue);
                        }
                    }
                }
            },

            _getpreveditablecolumn: function (index) {
                var self = this;
                while (index > 0) {
                    index--;
                    var column = self.getcolumnat(index);
                    if (!column)
                        return null;

                    if (!column.editable)
                        continue;

                    if (!column.hidden)
                        return column;
                }
                return null;
            },

            _getnexteditablecolumn: function (index) {
                var self = this;
                while (index < this.columns.records.length) {
                    index++;
                    var column = self.getcolumnat(index);

                    if (!column)
                        return null;

                    if (!column.editable)
                        continue;

                    if (!column.hidden)
                        return column;
                }
                return null;
            },

            _handleeditkeydown: function (event, self) {
                if (self.handlekeyboardnavigation) {
                    var handled = self.handlekeyboardnavigation(event);
                    if (handled == true) {
                        return true;
                    }
                }

                var key = event.charCode ? event.charCode : event.keyCode ? event.keyCode : 0;
                self.editEvent = event;

                if (self.showfilterrow && self.filterable) {
                    if (this.filterrow) {
                        if ($(event.target).ischildof(this.filterrow))
                            return true;
                    }
                }
                if (self.showfilterbar && self.filterable) {
                    if (this.filterbar) {
                        if ($(event.target).ischildof(this.filterbar))
                            return true;
                    }
                }

                if (event.target.className && event.target.className.indexOf('jqx-grid-widget') >= 0) {
                    return true;
                }
                if (self.pageable) {
                    if ($(event.target).ischildof(this.pager)) {
                        return true;
                    }
                }

                if (this.showtoolbar) {
                    if ($(event.target).ischildof(this.toolbar)) {
                        return true;
                    }
                }
                if (this.showeverpresentrow) {
                    if (this.addnewrowtop) {
                        if ($(event.target).ischildof(this.addnewrowtop)) {
                            return true;
                        }
                    }
                    if (this.addnewrowbottom) {
                        if ($(event.target).ischildof(this.addnewrowbottom)) {
                            return true;
                        }
                    }
                }
                if (this.showstatusbar) {
                    if ($(event.target).ischildof(this.statusbar)) {
                        return true;
                    }
                }

                if (this.rowdetails) {
                    if ($(event.target).ischildof(this.content.find("[role='rowgroup']"))) {
                        return true;
                    }
                }

                if (this.editcell) {
                    if (this.editmode === "selectedrow") {
                        if (key === 13) {
                            this.endrowedit(this.editcell.row, false);
                            return false;
                        }
                        else if (key === 27) {
                            this.endrowedit(this.editcell.row, true);
                            return false;
                        }
                        if (key == 32) {
                            if (this._currentColumn && this.getcolumn(this._currentColumn).columntype == 'checkbox') {
                                var column = this.getcolumn(this._currentColumn);
                                if (column.editable) {
                                    var checked = !this.getcellvalue(this.editcell.row, column.datafield);

                                    var datarow = this.getrowdata(this.editcell.row);
                                    var row = this.editcell.row;
                                    var datarow = self.getrowdata(self.editcell.row);
                                    this.pushToHistory = true;
                                    this.setcellvalue(this.editcell.row, column.datafield, checked, false);
                                    this.pushToHistory = false;
                                    var focusedColumn = this._focusedColumn;
                                    var currentColumn = this._currentColumn;
                                    var _currentEditableColumn = this._currentEditableColumn;
                                    this.endrowedit(this.editcell.row, false);
                                    this.beginrowedit(row, false);
                                    this._currentColumn = currentColumn;
                                    this._focusedColumn = focusedColumn;
                                    this._currentEditableColumn = _currentEditableColumn;
                                    this._renderrows();
                                    this.selectcell(row, column.datafield);
                                    this._oldselectedcell = this.selectedcell;
                                    if (focusedColumn) {
                                        var that = this;
                                        setTimeout(function () {
                                            that.selectcell(row, column.datafield);
                                            that._oldselectedcell = that.selectedcell;
                                            $(that._checkboxCells[column.datafield].checkbox).jqxCheckBox('focus');

                                        }, 25);
                                    }
                                    return false;
                                }
                            }
                        }
                        if (key === 9) {
                            var datafield = this.editcell.datafield;
                            var columnindex = this._getcolumnindex(datafield);

                            if (this._currentEditableColumn) {
                                columnindex = this._currentEditableColumn;
                            }
                            else {
                                this._currentEditableColumn = columnindex;
                            }

                            var column = this._getnexteditablecolumn(columnindex);
                            if (event.shiftKey || this.rtl) {
                                column = this._getpreveditablecolumn(columnindex);
                            }
                            if (column) {
                                var columnindex = this._getcolumnindex(column.datafield);
                                if (this.editcell[column.datafield]) {
                                    this._currentEditableColumn = columnindex;
                                    var editor = this.editcell[column.datafield].editor;

                                    if (editor) {
                                        if (editor.data().jqxWidget && editor.data().jqxWidget.focus) {
                                            editor.data().jqxWidget.focus();
                                        }
                                        else {
                                            editor.focus();
                                            editor[0].onkeyup = function () {
                                                if (self.gridcontent[0].scrollTop != 0) {
                                                    self.scrolltop(Math.abs(self.gridcontent[0].scrollTop));
                                                    self.gridcontent[0].scrollTop = 0;
                                                }

                                                if (self.gridcontent[0].scrollLeft != 0) {
                                                    self.gridcontent[0].scrollLeft = 0;
                                                }
                                            }
                                        }
                                    }
                                    this._focusedColumn = column.datafield;
                                    this._currentColumn = column.datafield;

                                    if (this.gridcontent[0].scrollTop != 0) {
                                        this.scrolltop(Math.abs(this.gridcontent[0].scrollTop));
                                        this.gridcontent[0].scrollTop = 0;
                                    }

                                    if (this.gridcontent[0].scrollLeft != 0) {
                                        this.gridcontent[0].scrollLeft = 0;
                                    }
                                }
                                else if (column.columntype == "checkbox") {
                                    this._currentColumn = column.datafield;
                                    this._currentEditableColumn = columnindex;
                                    this.selectcell(this.editcell.row, column.datafield);
                                    this._oldselectedcell = this.selectedcell;
                                    if (this._checkboxCells[column.datafield]) {
                                        $(this._checkboxCells[column.datafield].checkbox).jqxCheckBox('focus');
                                    }
                                    return false;
                                }
                            }
                            return false;
                        }

                        return true;
                    }

                    if (this.editcell.columntype == null || this.editcell.columntype == 'textbox' || this.editcell.columntype == 'numberinput' || this.editcell.columntype == 'combobox' || this.editcell.columntype == 'datetimeinput') {
                        if (key >= 33 && key <= 40 && self.selectionmode == 'multiplecellsadvanced') {
                            var editor = this.editcell.columntype == 'textbox' || this.editcell.columntype == null ? this.editcell.editor : this.editcell.editor.find('input');
                            var selection = self._selection(editor);
                            var strlength = editor.val().length;
                            if (selection.length > 0 && this.editcell.columntype != 'datetimeinput') {
                                self._cancelkeydown = true;
                            }

                            if (selection.start > 0 && key == 37) {
                                self._cancelkeydown = true;
                            }
                            if (selection.start < strlength && key == 39 && this.editcell.columntype != 'datetimeinput') {
                                self._cancelkeydown = true;
                            }
                            if (this.editcell.columntype == 'datetimeinput' && key == 39) {
                                if (selection.start + selection.length < strlength) {
                                    self._cancelkeydown = true;
                                }
                            }
                        }
                    }
                    else if (this.editcell.columntype == 'dropdownlist') {
                        if (key == 37 || key == 39 && self.selectionmode == 'multiplecellsadvanced') {
                            self._cancelkeydown = false;
                        }
                    }
                    else if (this.selectionmode == 'multiplecellsadvanced' && this.editcell.columntype != 'textbox' && this.editcell.columntype != 'numberinput') {
                        self._cancelkeydown = true;
                    }

                    if (key == 32) {
                        if (self.editcell.columntype == 'checkbox') {
                            var column = self.getcolumn(self.editcell.datafield);
                            if (column.editable) {
                                var checked = !self.getcellvalue(self.editcell.row, self.editcell.column);
                                if (column.cellbeginedit) {
                                    var beginEdit = column.cellbeginedit(self.editcell.row, column.datafield, column.columntype, !checked);
                                    if (beginEdit == false) {
                                        return false;
                                    }
                                }
                                var datarow = self.getrowdata(self.editcell.row);

                                self.pushToHistory = true;
                                self.setcellvalue(self.editcell.row, self.editcell.column, checked, true);
                                self.pushToHistory = false;

                                self._raiseEvent(18, { rowindex: self.editcell.row, row: datarow, datafield: self.editcell.column, oldvalue: !checked, value: checked, columntype: 'checkbox' });
                                return false;
                            }
                        }
                    }
                    if (key == 9) {
                        var rowindex = this.editcell.row;
                        var datafield = this.editcell.column;
                        var initialdatafield = datafield;
                        var columnindex = self._getcolumnindex(datafield);
                        var canedit = false;
                        var visibleindex = self.getrowvisibleindex(rowindex);
                        var initialrowindex = rowindex;
                        this.editchar = "";
                        var validated = this.editcell.validated;
                        if (!this.editcell.validated) {
                            var validated = this.endcelledit(this.editcell.row, this.editcell.column, false, true, false);
                        }

                        if (validated != false) {
                            if (event.shiftKey || this.rtl) {
                                var column = self._getpreveditablecolumn(columnindex);
                                if (column) {
                                    datafield = column.datafield;
                                    canedit = true;
                                    if (self.selectionmode.indexOf('cell') != -1) {
                                        self.selectprevcell(rowindex, initialdatafield);
                                        self._oldselectedcell = self.selectedcell;
                                        setTimeout(function () {
                                            self.ensurecellvisible(visibleindex, datafield);
                                        }, 10);
                                    }
                                }
                                else {
                                    var lastColumn = self._getlastvisiblecolumn();
                                    canedit = true;
                                    datafield = lastColumn.displayfield;
                                    var datarecord = self.getdisplayrows()[visibleindex - 1];
                                    if (datarecord) {
                                        rowindex = datarecord.dataindex;
                                        if (rowindex === undefined) {
                                            rowindex = datarecord.boundindex;
                                        }
                                        visibleindex = self.getrowvisibleindex(rowindex);
                                    }

                                    var canensure = true;

                                    if (self.pageable) {
                                        var pagenumber = Math.floor(visibleindex / this.pagesize);
                                        if (this.dataview.pagenum != pagenumber) {
                                            canensure = false;
                                        }
                                    }

                                    if (canensure && self.selectionmode.indexOf('cell') != -1) {
                                        self.clearselection();
                                        self.selectcell(rowindex, datafield);
                                        self._oldselectedcell = self.selectedcell;
                                        setTimeout(function () {
                                            self.ensurecellvisible(visibleindex, datafield);
                                        }, 10);
                                    }
                                }
                            }
                            else {
                                var column = self._getnexteditablecolumn(columnindex);
                                if (column) {
                                    datafield = column.datafield;
                                    canedit = true;
                                    if (self.selectionmode.indexOf('cell') != -1) {
                                        self.selectnextcell(rowindex, initialdatafield);
                                        self._oldselectedcell = self.selectedcell;
                                        setTimeout(function () {
                                            self.ensurecellvisible(visibleindex, datafield);
                                        }, 10);
                                    }
                                }
                                else {
                                    var firstColumn = self._getfirstvisiblecolumn();
                                    canedit = true;
                                    datafield = firstColumn.displayfield;
                                    var datarecord = self.getdisplayrows()[visibleindex + 1];
                                    if (datarecord) {
                                        rowindex = datarecord.dataindex;
                                        if (rowindex === undefined) {
                                            rowindex = datarecord.boundindex;
                                        }
                                        visibleindex = self.getrowvisibleindex(rowindex);
                                    }

                                    var canensure = true;

                                    if (self.pageable) {
                                        var pagenumber = Math.floor(visibleindex / this.pagesize);
                                        if (this.dataview.pagenum != pagenumber) {
                                            canensure = false;
                                        }
                                    }

                                    if (self.selectionmode.indexOf('cell') != -1) {
                                        if (canensure) {
                                            self.clearselection();
                                            self.selectcell(rowindex, datafield);
                                            self._oldselectedcell = self.selectedcell;
                                            setTimeout(function () {
                                                self.ensurecellvisible(visibleindex, datafield);
                                            }, 10);
                                        }
                                    }
                                }
                            }

                            if (canedit) {
                                if (self.pageable) {
                                    var pagenumber = Math.floor(visibleindex / this.pagesize);
                                    if (this.dataview.pagenum != pagenumber) {
                                        this._renderrows(this.virtualsizeinfo);
                                        if (self.selectionmode.indexOf('cell') != -1) {
                                            self.clearselection();
                                            self.selectcell(initialrowindex, initialdatafield);
                                            self._oldselectedcell = self.selectedcell;

                                        }
                                        if (pagenumber > this.dataview.pagenum) {
                                            setTimeout(function () {
                                                self.pagerpageinput.focus();
                                            }, 25);
                                        }
                                        return;
                                    }

                                }
                                self.begincelledit(rowindex, datafield);
                                if (this.editcell != null && this.editcell.columntype == 'checkbox') {
                                    this._renderrows(this.virtualsizeinfo);
                                }
                            }
                            else {
                                if (this.editcell != null) {
                                    self.endcelledit(rowindex, datafield, false);
                                    this._renderrows(this.virtualsizeinfo);
                                }
                                return true;
                            }
                        }
                        return false;
                    }
                    else if (key == 13) {
                        var oldselectedcell = this.selectedcell;
                        if (oldselectedcell) {
                            var oldvisibleindex = this.getrowvisibleindex(oldselectedcell.rowindex);
                        }
                        this.endcelledit(this.editcell.row, this.editcell.column, false, true);
                        if (this.selectionmode == 'multiplecellsadvanced') {
                            var cell = self.getselectedcell();
                            if (cell != null) {
                                if (self.selectcell) {
                                    if (this.editcell == null) {
                                        if (cell.rowindex + 1 < this.dataview.totalrecords) {
                                            if (this.sortcolumn != cell.datafield) {
                                                var visibleindex = this.getrowvisibleindex(cell.rowindex);
                                                var visiblerow = this.dataview.loadedrecords[visibleindex + 1];
                                                if (visiblerow) {
                                                    if (!this.pageable || (this.pageable && visibleindex + 1 < (this.dataview.pagenum + 1) * this.pagesize)) {
                                                        this.clearselection(false);
                                                        this.selectcell(this.getboundindex(visiblerow), cell.datafield);
                                                        var cell = this.getselectedcell();
                                                        this.ensurecellvisible(visiblerow.visibleindex, cell.datafield);
                                                    }
                                                }
                                            }
                                            else {
                                                if (oldselectedcell != null) {
                                                    var oldvisiblerow = this.dataview.loadedrecords[oldvisibleindex + 1];
                                                    if (oldvisiblerow) {
                                                        if (!this.pageable || (this.pageable && oldvisibleindex + 1 < this.pagesize)) {
                                                            this.clearselection(false);
                                                            this.selectcell(this.getboundindex(oldvisiblerow), cell.datafield);
                                                        }
                                                        else if (this.pageable && oldvisibleindex + 1 >= this.pagesize) {
                                                            this.clearselection(false);
                                                            var oldvisiblerow = this.dataview.loadedrecords[oldvisibleindex];
                                                            this.selectcell(this.getboundindex(oldvisiblerow), cell.datafield);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return false;
                    }
                    else if (key == 27) {
                        this.endcelledit(this.editcell.row, this.editcell.column, true, true);
                        return false;
                    }
                }
                else {
                    var startedit = false;
                    if (key == 113) {
                        startedit = true;
                    }
                    if (!event.ctrlKey && !event.altKey && !event.metaKey) {
                        if (key >= 48 && key <= 57) {
                            this.editchar = String.fromCharCode(key);
                            startedit = true;
                        }
                        if (key === 189) {
                            startedit = true;
                        }

                        if (key >= 65 && key <= 90) {
                            this.editchar = String.fromCharCode(key);
                            var shifton = false;
                            if (event.shiftKey) {
                                shifton = event.shiftKey;
                            } else if (event.modifiers) {
                                shifton = !!(event.modifiers & 4);
                            }
                            if (this._capsLock) {
                                shifton = !shifton;
                            }
                            if (!shifton) {
                                this.editchar = this.editchar.toLowerCase();
                            }
                            startedit = true;
                        }
                        else if (key >= 96 && key <= 105) {
                            this.editchar = key - 96;
                            this.editchar = this.editchar.toString();
                            startedit = true;
                        }
                        var gridscount = $('.jqx-grid').length;
                        startedit = startedit && (gridscount == 1 || (gridscount > 1 && self.focused));
                        var editID = $.data(document.body, 'jqxgrid.edit');
                        if (editID !== undefined && editID !== "") {
                            if (key === 13 || startedit) {
                                if (editID != self.element.id) {
                                    return true;
                                }
                            }
                        }
                    }

                    if (key == 13 || startedit) {
                        if (self.getselectedrowindex) {
                            var rowindex = self.getselectedrowindex();
                            if (self.editmode === 'selectedrow') {
                                if (rowindex >= 0) {
                                    self.beginrowedit(rowindex);
                                }
                                else {
                                    var cell = self.getselectedcell();
                                    if (cell != null) {
                                        var column = self._getcolumnbydatafield(cell.datafield);
                                        self.beginrowedit(cell.rowindex);
                                    }
                                    return false;
                                }
                            }

                            switch (self.selectionmode) {
                                case 'singlerow':
                                case 'multiplerows':
                                case 'multiplerowsextended':
                                    {
                                        if (rowindex >= 0) {
                                            var datafield = "";
                                            for (var m = 0; m < self.columns.records.length; m++) {
                                                var column = self.getcolumnat(m);
                                                if (column.editable) {
                                                    datafield = column.datafield;
                                                    break;
                                                }
                                            }
                                            if (self.editmode === 'selectedrow') {
                                                self.beginrowedit(rowindex);
                                            }
                                            else {
                                                self.begincelledit(rowindex, datafield);
                                            }
                                        }
                                        break;
                                    }
                                case 'singlecell':
                                case 'multiplecells':
                                case 'multiplecellsextended':
                                    var cell = self.getselectedcell();
                                    if (cell != null) {
                                        var column = self._getcolumnbydatafield(cell.datafield);
                                        if (self.editmode === 'selectedrow') {
                                            self.beginrowedit(cell.rowindex);
                                        }
                                        else if (column.columntype != 'checkbox') {
                                            self.begincelledit(cell.rowindex, cell.datafield);
                                        }
                                    }
                                    break;
                                case "multiplecellsadvanced":
                                    var cell = self.getselectedcell();
                                    if (cell != null) {
                                        if (key == 13) {
                                            if (self.selectcell) {
                                                var visibleindex = this.getrowvisibleindex(cell.rowindex);
                                                if (visibleindex + 1 < self.dataview.totalrecords) {
                                                    var visiblerow = this.dataview.loadedrecords[visibleindex + 1];
                                                    if (visiblerow) {
                                                        this.clearselection(false);
                                                        this.selectcell(this.getboundindex(visiblerow), cell.datafield);
                                                        var cell = this.getselectedcell();
                                                        this.ensurecellvisible(visiblerow.visibleindex, cell.datafield);
                                                    }
                                                }
                                            }
                                        }
                                        else {
                                            if (self.editmode !== "selectedrow") {
                                                self.begincelledit(cell.rowindex, cell.datafield, null, false);
                                            }
                                        }
                                    }

                                    break;
                            }
                            return false;
                        }
                    }
                    if (key == 46) {
                        var cells = self.getselectedcells();
                        if (self.selectionmode.indexOf('cell') == -1) {
                            if (self._getcellsforcopypaste) {
                                cells = self._getcellsforcopypaste();
                            }
                        }
                        if (cells != null && cells.length > 0) {
                            for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                                var cell = cells[cellIndex];
                                if (!cell.datafield) continue;
                                var column = self.getcolumn(cell.datafield);
                                var cellValue = self.getcellvalue(cell.rowindex, cell.datafield);
                                if (cellValue !== "" && column.editable && self.enablekeyboarddelete) {
                                    var newvalue = null;
                                    if (column.columntype == "checkbox") {
                                        if (!column.threestatecheckbox) {
                                            newvalue = false;
                                        }
                                    }
                                    if (column.cellbeginedit) {
                                        var beginEdit = column.cellbeginedit(cell.rowindex, column.datafield, column.columntype, newvalue);
                                        if (beginEdit == false) {
                                            return false;
                                        }
                                    }
                                    var datarow = self.getrowdata(cell.rowindex);
                                    if (column.validation) {
                                        var validationobj = column.validation(cell, newvalue);
                                        var result = typeof validationobj == "boolean" ? validationobj : validationobj.result;

                                        if (!result) {
                                            return;
                                        }
                                    }

                                    self._raiseEvent(17, { rowindex: cell.rowindex, row: datarow, datafield: cell.datafield, value: cellValue });

                                    self.pushToHistory = true;
                                    if (cellIndex == cells.length - 1) {
                                        self.setcellvalue(cell.rowindex, cell.datafield, newvalue, true);
                                        if (column.displayfield != column.datafield) {
                                            self.setcellvalue(cell.rowindex, column.displayfield, newvalue, true);
                                        }
                                    }
                                    else {
                                        self.setcellvalue(cell.rowindex, cell.datafield, newvalue, false);
                                        if (column.displayfield != column.datafield) {
                                            self.setcellvalue(cell.rowindex, column.displayfield, newvalue, true);
                                        }
                                    }
                                    self.pushToHistory = false;

                                    if (column.cellendedit) {
                                        var cellendeditresult = column.cellendedit(cell.rowindex, column.datafield, column.columntype, newvalue);
                                    }
                                    self._raiseEvent(18, { rowindex: cell.rowindex, row: datarow, datafield: cell.datafield, oldvalue: cellValue, value: newvalue });
                                }
                            }
                            this.dataview.updateview();
                            this._renderrows(this.virtualsizeinfo);
                            return false;
                        }
                    }
                    if (key == 32) {
                        var cell = self.getselectedcell();
                        if (cell != null) {
                            var column = self.getcolumn(cell.datafield);
                            if (column.columntype == 'checkbox' && column.editable) {
                                var checked = !self.getcellvalue(cell.rowindex, cell.datafield);
                                if (column.cellbeginedit) {
                                    var beginEdit = column.cellbeginedit(cell.rowindex, column.datafield, column.columntype, !checked);
                                    if (beginEdit == false) {
                                        return false;
                                    }
                                }

                                var datarow = self.getrowdata(cell.rowindex);
                                self._raiseEvent(17, { rowindex: cell.rowindex, row: datarow, datafield: cell.datafield, value: !checked, columntype: 'checkbox' });
                                self.pushToHistory = true;
                                self.setcellvalue(cell.rowindex, cell.datafield, checked, true);
                                self.pushToHistory = false;

                                self._raiseEvent(18, { rowindex: cell.rowindex, row: datarow, datafield: cell.datafield, oldvalue: !checked, value: checked, columntype: 'checkbox' });
                                return false;
                            }
                        }
                    }
                }

                return true;
            },

            // begins cell editing.
            begincelledit: function (row, datafield, defaultvalue, ensurevisible, render) {
                var column = this.getcolumn(datafield);
                this._cellscache = new Array();

                if (datafield == null)
                    return;

                if (column.columntype == "number" || column.columntype == "button" || column.createwidget) {
                    return;
                }

                if (this.groupable) {
                    if (this.groups.indexOf(datafield) >= 0) {
                        return;
                    }
                    if (this.groups.indexOf(column.displayfield) >= 0) {
                        return;
                    }
                }

                if (this.editrow != undefined) return;

                if (this.editcell) {
                    if (this.editcell.row == row && this.editcell.column == datafield) {
                        return true;
                    }
                    if (this.editmode === "selectedrow") {
                        if (this.editcell.row == row) {
                            return;
                        }
                    }

                    var validated = this.endcelledit(this.editcell.row, this.editcell.column, false, true, false);
                    if (false == validated)
                        return;
                }

                var isembeddededitor = column.columntype == 'checkbox' || column.columntype == 'button' || column.createwidget;
                this.host.removeClass('jqx-disableselect');
                this.content.removeClass('jqx-disableselect');

                if (column.editable) {
                    if (column.cellbeginedit) {
                        var cell = this.getcell(row, datafield);
                        var beginEdit = column.cellbeginedit(row, datafield, column.columntype, cell != null ? cell.value : null);
                        if (beginEdit == false)
                            return;
                    }

                    var visiblerowindex = this.getrowvisibleindex(row);
                    this.editcell = this.getcell(row, datafield);
                    if (this.editcell) {
                        this.editcell.visiblerowindex = visiblerowindex;
                        if (!this.editcell.editing) {
                            if (!isembeddededitor) {
                                this.editcell.editing = true;
                            }
                            this.editcell.columntype = column.columntype;
                            this.editcell.defaultvalue = defaultvalue;
                            if (column.defaultvalue != undefined) {
                                this.editcell.defaultvalue = column.defaultvalue;
                            }
                            this.editcell.init = true;
                            // raise begin cell edit event.
                            if (column.columntype != "checkbox" && this.editmode != "selectedrow") {
                                var datarow = this.getrowdata(row);
                                this._raiseEvent(17, { rowindex: row, row: datarow, datafield: column.datafield, value: this.editcell.value, columntype: column.columntype });
                            }
                            $.data(document.body, 'jqxgrid.edit', this.element.id);

                            if (!isembeddededitor) {
                                var visibleindex = this.getrowvisibleindex(row);
                                if (ensurevisible !== false) {
                                    if (!this.autorowheight && this.groups.length === 0) {
                                        var result = this.ensurecellvisible(visibleindex, column.datafield);
                                    }
                                }
                                if (render !== false) {
                                    this._renderrows(this.virtualsizeinfo);
                                }
                            }
                            if (this.editcell) {
                                this.editcell.init = false;
                                return true;
                            }
                        }
                    }
                }
                else {
                    if (!this.editcell) {
                        this.editchar = "";
                        return;
                    }

                    this.editchar = "";
                    this.editcell.editor = null;
                    this.editcell.editing = false;
                    if (render !== false) {
                        this._renderrows(this.virtualsizeinfo);
                    }
                    this.editcell = null;
                }
            },

            getScrollTop: function () {
                if (this._py) {
                    return this._py;
                }

                this._py = typeof pageYOffset != 'undefined';
                if (this._py) {
                    //most browsers
                    return pageYOffset;
                }
                else {
                    var B = document.body; //IE 'quirks'
                    var D = document.documentElement; //IE with doctype
                    D = (D.clientHeight) ? D : B;
                    return D.scrollTop;
                }
            },

            getScrollLeft: function () {
                if (typeof pageXOffset != 'undefined') {
                    //most browsers
                    return pageXOffset;
                }
                else {
                    var B = document.body; //IE 'quirks'
                    var D = document.documentElement; //IE with doctype
                    D = (D.clientHeight) ? D : B;
                    return D.scrollLeft;
                }
            },

            endcelledit: function (row, datafield, cancelchanges, refresh, focus) {
                if (row == undefined || datafield == undefined) {
                    if (this.editcell) {
                        row = this.editcell.row;
                        datafield = this.editcell.column;
                    }
                    if (cancelchanges == undefined) {
                        cancelchanges = true;
                    }
                }

                if (!this.editcell) {
                    return;
                }

                var column = this.getcolumn(datafield);
                var me = this;

                if (me.editmode === "selectedrow") {
                    this.endrowedit(row, cancelchanges);
                    return;
                }

                var setfocus = function () {
                    if (focus != false) {
                        if (me.isTouchDevice()) {
                            return;
                        }

                        if (!me.isNestedGrid) {
                            var topPos = me.getScrollTop();
                            var leftPos = me.getScrollLeft();

                            try {
                                me.element.focus();
                                me.content.focus();
                                if (topPos != me.getScrollTop()) {
                                    window.scrollTo(leftPos, topPos);
                                }

                                setTimeout(function () {
                                    me.element.focus();
                                    me.content.focus();
                                    if (topPos != me.getScrollTop()) {
                                        window.scrollTo(leftPos, topPos);
                                    }
                                }, 10);
                            }
                            catch (error) {
                            }
                        }
                    }
                }

                if (column.columntype == 'checkbox' || column.columntype == 'button' || column.createwidget) {
                    if (this.editcell) {
                        this.editcell.editor = null;
                        this.editcell.editing = false;
                        this.editcell = null;
                    }
                    return true;
                }

                var editorvalue = this._geteditorvalue(column);

                var cancelchangesfunc = function (me) {
                    me._hidecelleditor();
                    if (column.cellendedit) {
                        column.cellendedit(row, datafield, column.columntype, me.editcell.value, editorvalue);
                    }
                    me.editchar = null;
                    var oldvalue;
                    if (column.displayfield != column.datafield) {
                        var label = me.getcellvalue(me.editcell.row, column.displayfield);
                        var value = me.editcell.value;
                        oldvalue = { value: value, label: label };
                    }
                    else oldvalue = me.editcell.value;
                    var rowdata = me.getrowdata(row);
                    me._raiseEvent(18, { rowindex: row, row: rowdata, datafield: datafield, displayfield: column.displayfield, oldvalue: editorvalue, value: editorvalue, columntype: column.columntype });

                    me.editcell.editor = null;
                    me.editcell.editing = false;
                    me.editcell = null;
                    if (refresh || refresh == undefined) {
                        me._renderrows(me.virtualsizeinfo);
                    }
                    setfocus();
                    if (!me.enablebrowserselection) {
                        me.host.addClass('jqx-disableselect');
                        me.content.addClass('jqx-disableselect');
                    }
                }

                if (cancelchanges) {
                    cancelchangesfunc(this);
                    return false;
                }

                if (this.validationpopup) {
                    this.validationpopup.hide();
                    this.validationpopuparrow.hide();
                }

                if (column.cellvaluechanging) {
                    var newcellvalue = column.cellvaluechanging(row, datafield, column.columntype, this.editcell.value, editorvalue);
                    if (newcellvalue != undefined) {
                        editorvalue = newcellvalue;
                    }
                }

                if (column.validation) {
                    var cell = this.getcell(row, datafield);
                    try {
                        var validationobj = column.validation(cell, editorvalue);
                        var validationmessage = this.gridlocalization.validationstring;
                        if (validationobj.message != undefined) {
                            validationmessage = validationobj.message;
                        }
                        var result = typeof validationobj == "boolean" ? validationobj : validationobj.result;

                        if (!result) {
                            if (validationobj.showmessage == undefined || validationobj.showmessage == true) {
                                this._showvalidationpopup(row, datafield, validationmessage);
                            }
                            this.editcell.validated = false;
                            return false;
                        }
                    }
                    catch (error) {
                        this._showvalidationpopup(row, datafield, this.gridlocalization.validationstring);
                        this.editcell.validated = false;
                        return false;
                    }
                }

                var oldvalue;
                if (column.displayfield != column.datafield) {
                    var label = this.getcellvalue(this.editcell.row, column.displayfield);
                    var value = this.editcell.value;
                    oldvalue = { value: value, label: label };
                }
                else oldvalue = this.editcell.value;

                var datarow = this.getrowdata(row);
                if (column.cellendedit) {
                    var cellendeditresult = column.cellendedit(row, datafield, column.columntype, this.editcell.value, editorvalue);
                    if (cellendeditresult == false) {
                        this._raiseEvent(18, { rowindex: row, row: datarow, datafield: datafield, displayfield: column.displayfield, oldvalue: oldvalue, value: oldvalue, columntype: column.columntype });
                        cancelchangesfunc(this);
                        return false;
                    }
                }

                this._raiseEvent(18, { rowindex: row, row: datarow, datafield: datafield, displayfield: column.displayfield, oldvalue: oldvalue, value: editorvalue, columntype: column.columntype });

                this._hidecelleditor(false);
                if (this.editcell != undefined) {
                    this.editcell.editor = null;
                    this.editcell.editing = false;
                }
                this.editcell = null;
                this.editchar = null;
                this.pushToHistory = true;
                this.setcellvalue(row, datafield, editorvalue, refresh);
                this.pushToHistory = false;

                if (!this.enablebrowserselection) {
                    this.host.addClass('jqx-disableselect');
                    this.content.addClass('jqx-disableselect');
                }
                if (!$.jqx.browser.msie) {
                    setfocus();
                }
                $.data(document.body, 'jqxgrid.edit', "");

                if (this.showgroupaggregates && this.groupable && this.groups.length && column.aggregates && column.aggregates.length) {
                    this.dataview.reloaddata();
                    this._renderrows(this.virtualsizeinfo);
                }
                // raise end cell edit event.
                return true;
            },

            beginrowedit: function (row) {
                var me = this;
                var lastIndex = -1;

                if (row == undefined) {
                    return;
                }

                me._oldselectedrow = row;
                this._cellscache = new Array();
                var programmaticMode = false;
                if (this.editmode != "selectedrow") {
                    programmaticMode = true;
                }

                if (programmaticMode) {
                    var tmpmode = this.editmode;
                    this.editmode = "selectedrow";
                }
                var firstEditableColumn = null;
                if (this._currentEditableColumn) {
                    firstEditableColumn = this.getcolumnat(this._currentEditableColumn).datafield;
                }

                $.each(this.columns.records, function (index, value) {
                    if (me.editable && this.editable) {
                        if (this.columntype === "checkbox" || this.columntype === "custom" || this.columntype === "widget" || this.columntype === "template" || this.columntype === "button") {
                            return true;
                        }

                        if (!firstEditableColumn) {
                            firstEditableColumn = this.datafield;
                        }

                        var cell = me.getcell(row, this.datafield);
                        me.begincelledit(row, this.datafield, null, false, false);
                        var datarow = me.getrowdata(row);
                        me._raiseEvent(17, { rowindex: row, row: datarow, datafield: this.datafield, value: cell.value, columntype: this.columntype });
                    }
                });
                if (me.editcell) {
                    me.editcell.init = true;
                }
                this._renderrows(this.virtualsizeinfo);
                if (programmaticMode) {
                    this.editmode = tmpmode;
                }
                if (firstEditableColumn && me.editcell) {
                    setTimeout(function () {
                        if (me.editcell && me.editcell[firstEditableColumn]) {
                            var editor = me.editcell[firstEditableColumn].editor;
                            if (editor) {
                                if (editor.data().jqxWidget && editor.data().jqxWidget.focus) {
                                    editor.data().jqxWidget.focus();
                                }
                                else {
                                    editor.focus();
                                }
                            }
                        }
                    }, 25);
                }
            },

            endrowedit: function (row, cancelchanges) {
                var me = this;
                this._currentEditableColumn = 0;
                this._focusedColumn = null;
                this._currentColumn = null;
                this._checkboxCells = [];

                if (!this.editcell) {
                    return false;
                }

                if (this.editcell.editor == undefined && this.editcell.columntype !== "checkbox") {
                    return false;
                }

                if (this._commandColumnEdit) {
                    this.editmode = this._commandColumnEditMode;
                    delete this._commandColumnEdit;
                    delete this._commandColumnEditMode;
                    delete this.editrow;
                }

                var setfocus = function () {
                    if (focus != false) {
                        if (me.isTouchDevice()) {
                            return;
                        }

                        if (!me.isNestedGrid) {
                            var topPos = me.getScrollTop();
                            var leftPos = me.getScrollLeft();

                            try {
                                me.element.focus();
                                me.content.focus();
                                if (topPos != me.getScrollTop()) {
                                    window.scrollTo(leftPos, topPos);
                                }

                                setTimeout(function () {
                                    me.element.focus();
                                    me.content.focus();
                                    if (topPos != me.getScrollTop()) {
                                        window.scrollTo(leftPos, topPos);
                                    }
                                }, 10);
                            }
                            catch (error) {
                            }
                        }
                    }
                }

                var programmaticMode = false;
                if (this.editmode != "selectedrow") {
                    programmaticMode = true;
                }

                if (programmaticMode) {
                    var tmpmode = this.editmode;
                    this.editmode = "selectedrow";
                }

                var hasInvalidColumns = false;
                var values = {};
                if (this.validationpopup) {
                    this.validationpopup.hide();
                    this.validationpopuparrow.hide();
                }

                for (var i = 0; i < this.columns.records.length; i++) {
                    var column = this.columns.records[i];
                    if (!column.editable) {
                        continue;
                    }

                    if (column.hidden) {
                        continue;
                    }


                    if (column.createwidget) {
                        continue;
                    }

                    var editorvalue = this._geteditorvalue(column);
                    if (column.columntype == "checkbox") {
                        if (cancelchanges) {
                            editorvalue = this.editcell[column.datafield];
                            var oldvalue = this.getcellvalue(this.editcell.row, column.displayfield);
                            this.setcellvalue(this.editcell.row, column.displayfield, editorvalue);
                        }
                        continue;
                    }

                    var cancelchangesfunc = function (me) {
                        me._hidecelleditor();
                        var oldval = me.getcellvalue(me.editcell.row, column.displayfield);
                        if (column.cellendedit) {
                            column.cellendedit(row, datafield, column.columntype, oldval, editorvalue);
                        }
                        me.editchar = null;
                        var oldvalue;

                        if (column.displayfield != column.datafield) {
                            var label = me.getcellvalue(me.editcell.row, column.displayfield);
                            var value = oldval;
                            oldvalue = { value: value, label: label };
                        }
                        else oldvalue = oldval;

                        var datarow = me.getrowdata(row);
                        me._raiseEvent(18, { rowindex: row, row: datarow, datafield: datafield, displayfield: column.displayfield, oldvalue: oldval, value: oldval, columntype: column.columntype });

                        me.editcell.editing = false;
                    }

                    if (cancelchanges) {
                        cancelchangesfunc(this);
                        continue;
                    }

                    if (column.cellvaluechanging) {
                        var oldvalue = this.getcellvalue(this.editcell.row, column.displayfield);
                        var newcellvalue = column.cellvaluechanging(row, datafield, column.columntype, oldvalue, editorvalue);
                        if (newcellvalue != undefined) {
                            editorvalue = newcellvalue;
                        }
                    }

                    var datafield = column.datafield;
                    if (column.validation) {
                        var cell = this.getcell(row, column.datafield);
                        try {
                            var validationobj = column.validation(cell, editorvalue);
                            var validationmessage = this.gridlocalization.validationstring;
                            if (validationobj.message != undefined) {
                                validationmessage = validationobj.message;
                            }
                            var result = typeof validationobj == "boolean" ? validationobj : validationobj.result;

                            if (!result) {
                                if (validationobj.showmessage == undefined || validationobj.showmessage == true) {
                                    this._showvalidationpopup(row, datafield, validationmessage);
                                }
                                hasInvalidColumns = true;
                                this.editcell[column.datafield].validated = false;
                                continue;
                            }
                        }
                        catch (error) {
                            this._showvalidationpopup(row, datafield, this.gridlocalization.validationstring);
                            this.editcell[column.datafield].validated = false;
                            hasInvalidColumns = true;
                            continue;
                        }
                    }

                    if (column.displayfield != column.datafield) {
                        var label = this.getcellvalue(this.editcell.row, column.displayfield);
                        var value = this.editcell.value;
                        oldvalue = { value: value, label: label };
                    }
                    else oldvalue = this.getcellvalue(this.editcell.row, column.displayfield);
                    values[column.datafield] = { newvalue: editorvalue, oldvalue: oldvalue };
                    // raise end cell edit event.
                }

                var rowvalues = {};
                var oldvalues = {};
                if (!hasInvalidColumns) {
                    this._hidecelleditor(false);

                    for (var i = 0; i < this.columns.records.length; i++) {
                        var column = this.columns.records[i];
                        var datafield = column.datafield;

                        if (column.hidden) {
                            continue;
                        }

                        if (!column.editable) {
                            continue;
                        }

                        var datarow = this.getrowdata(row);
                        if (column.createwidget) {
                            continue;
                        }

                        if (column.columntype == "checkbox") {
                            var editorvalue = this.getcellvalue(row, column.displayfield);
                            this._raiseEvent(18, { rowindex: row, row: datarow, datafield: column.datafield, displayfield: column.displayfield, oldvalue: editorvalue, value: editorvalue, columntype: column.columntype });
                            continue;
                        }

                        if (!values[column.datafield]) {
                            continue;
                        }

                        var editorvalue = values[column.datafield].newvalue;
                        var oldvalue = values[column.datafield].oldvalue;

                        if (column.cellendedit) {
                            var cellendeditresult = column.cellendedit(row, datafield, column.columntype, oldvalue, editorvalue);
                            if (cellendeditresult == false) {
                                this._raiseEvent(18, { rowindex: row, row: datarow, datafield: datafield, displayfield: column.displayfield, oldvalue: oldvalue, value: oldvalue, columntype: column.columntype });
                                cancelchangesfunc(this);
                                continue;
                            }
                        }

                        if (!this.source.updaterow) {
                            this._raiseEvent(18, { rowindex: row, row: datarow, datafield: column.datafield, displayfield: column.displayfield, oldvalue: oldvalue, value: editorvalue, columntype: column.columntype });
                        }

                        rowvalues[column.datafield] = editorvalue;
                        oldvalues[column.datafield] = oldvalue;
                    }
                    var rowid = this.getrowid(row);
                    var datarow = this.getrowdata(row);
                    $.each(rowvalues, function (index, value) {
                        if (value && value.label != undefined) {
                            var column = me.getcolumn(index);
                            datarow[column.displayfield] = value.label;
                            datarow[column.datafield] = value.value;
                        }
                        else {
                            datarow[index] = value;
                        }
                    });


                    if (!this.enablebrowserselection) {
                        this.host.addClass('jqx-disableselect');
                        this.content.addClass('jqx-disableselect');
                    }
                    $.data(document.body, 'jqxgrid.edit', "");
                    this.editcell = null;
                    this.editchar = null;
                    this.pushToHistory = true;
                    if (this.source.updaterow && !cancelchanges) {
                        var success = false;
                        var me = this;
                        var result = function (param) {
                            var tmp = me.source.updaterow;
                            me.source.updaterow = null;
                            if (false == param) {
                                $.each(oldvalues, function (index, value) {
                                    if (value && value.label != undefined) {
                                        var column = me.getcolumn(index);
                                        datarow[column.displayfield] = value.label;
                                        datarow[column.datafield] = value.value;
                                    }
                                    else {
                                        datarow[index] = value;
                                    }
                                });
                                me.updaterow(rowid, datarow);
                            }
                            else {
                                me.updaterow(rowid, datarow);
                            }

                            for (var i = 0; i < me.columns.records.length; i++) {
                                var column = me.columns.records[i];
                                var datafield = column.datafield;
                                me._raiseEvent(18, { rowindex: row, datafield: column.datafield, row: datarow, displayfield: column.displayfield, oldvalue: oldvalues[column.datafield], value: datarow[column.displayfield], columntype: column.columntype });
                            }
                            me.source.updaterow = tmp;
                        }
                        try {
                            success = this.source.updaterow(rowid, datarow, result);
                            if (success == undefined) success = true;
                        }
                        catch (error) {
                            success = false;
                            return;
                        }
                    }
                    else {
                        if (!cancelchanges) {
                            this.updaterow(rowid, datarow);
                        }
                        this._renderrows(this.virtualsizeinfo);
                    }
                }
                this.pushToHistory = false;
                if (programmaticMode) {
                    this.editmode = tmpmode;
                }

                return hasInvalidColumns;
            },

            _selection: function (textbox) {
                if ('selectionStart' in textbox[0]) {
                    var e = textbox[0];
                    var selectionLength = e.selectionEnd - e.selectionStart;
                    return { start: e.selectionStart, end: e.selectionEnd, length: selectionLength, text: e.value };
                }
                else {
                    var r = document.selection.createRange();
                    if (r == null) {
                        return { start: 0, end: e.value.length, length: 0 }
                    }

                    var re = textbox[0].createTextRange();
                    var rc = re.duplicate();
                    re.moveToBookmark(r.getBookmark());
                    rc.setEndPoint('EndToStart', re);
                    var selectionLength = r.text.length;

                    return { start: rc.text.length, end: rc.text.length + r.text.length, length: selectionLength, text: r.text };
                }
            },

            _setSelection: function (start, end, textbox) {
                if ('selectionStart' in textbox[0]) {
                    textbox[0].focus();
                    textbox[0].setSelectionRange(start, end);
                }
                else {
                    var range = textbox[0].createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', end);
                    range.moveStart('character', start);
                    range.select();
                }
            },

            // finds the index to select in the jqxDropDownList editor.
            findRecordIndex: function (value, datafield, records) {
                var records = records;

                if (datafield) {
                    var length = records.length;

                    // loop through all records.
                    for (var urec = 0; urec < length; urec++) {
                        var datarow = records[urec];
                        var currentValue = datarow['label'];
                        if (value == currentValue)
                            return urec;
                    }
                }

                return -1;
            },

            _destroyeditors: function () {
                var me = this;
                if (!this.columns.records) return;
                $.each(this.columns.records, function (i, value) {
                    var datafieldname = $.trim(this.datafield).split(" ").join("");

                    switch (this.columntype) {
                        case "dropdownlist":
                            var dropdownlist = me.editors["dropdownlist" + "_" + datafieldname];
                            if (dropdownlist) {
                                dropdownlist.jqxDropDownList('destroy');
                                me.editors["dropdownlist" + "_" + datafieldname] = null;
                            }
                            break;
                        case "combobox":
                            var combobox = me.editors["combobox" + "_" + datafieldname];
                            if (combobox) {
                                combobox.jqxComboBox('destroy');
                                me.editors["combobox" + "_" + datafieldname] = null;
                            }
                            break;
                        case "datetimeinput":
                            var datetimeinput = me.editors["datetimeinput" + "_" + this.datafield];
                            if (datetimeinput) {
                                datetimeinput.jqxDateTimeInput('destroy');
                                me.editors["datetimeinput" + "_" + datafieldname] = null;
                            }
                            break;
                        case "numberinput":
                            var numberinput = me.editors["numberinput" + "_" + datafieldname];
                            if (numberinput) {
                                numberinput.jqxNumberInput('destroy');
                                me.editors["numberinput" + "_" + datafieldname] = null;
                            }
                            break;
                        case "custom":
                        case "template":
                            if (me.destroyeditor) {
                                if (me.editors["templateeditor" + "_" + datafieldname]) {
                                    me.destroyeditor(me.editors["templateeditor" + "_" + datafieldname]);
                                    me.editors["templateeditor" + "_" + datafieldname] = null;
                                }
                            }
                            if (me.destroyeditor) {
                                var rows = me.getrows.length();
                                for (var t = 0; t < rows; t++) {
                                    if (me.editors["customeditor" + "_" + datafieldname + "_" + t]) {
                                        me.destroyeditor(me.editors["customeditor" + "_" + datafieldname + "_" + t], t);
                                        me.editors["customeditor" + "_" + datafieldname + "_" + t] = null;
                                    }
                                }
                            }
                            break;
                        case "textbox":
                        default:
                            var textbox = me.editors["textboxeditor" + "_" + datafieldname];
                            if (textbox) {
                                me.removeHandler(textbox, 'keydown');
                                me.editors["textbox" + "_" + datafieldname] = null;
                            }
                            break;
                    }
                });
                me.editors = new Array();
            },

            _showcelleditor: function (row, column, element, init, focusable) {
                if (element == undefined)
                    return;

                if (this.editcell == null)
                    return;

                if (column.columntype == 'checkbox' && column.editable) {
                    if (this.editmode == "selectedrow") {
                        if (!this._checkboxCells) {
                            this._checkboxCells = [];
                        }
                        this._checkboxCells[column.datafield] = element;
                    }
                    return;
                }

                if (focusable == undefined) focusable = true;
                if (this.editmode == "selectedrow") {
                    this.editchar = "";
                    focusable = false;
                }

                var datafield = column.datafield;
                var $element = $(element);
                var me = this;
                var editor = this.editcell.editor;
                var cellvalue = this.getcellvalue(row, datafield);
                var celltext = this.getcelltext(row, datafield);
                var hScrollInstance = this.hScrollInstance;
                var horizontalscrollvalue = hScrollInstance.value;
                var left = parseInt(horizontalscrollvalue);
                var columnIndex = this.columns.records.indexOf(column);
                this.editcell.element = element;

                if (this.editcell.validated == false) {
                    var validationmessage = "";
                    if (this.validationpopup) {
                        validationmessage = this.validationpopup.text();
                    }

                    this._showvalidationpopup(row, datafield, validationmessage);
                }

                var focuseditor = function (editor) {
                    if (me.hScrollInstance.isScrolling() || me.vScrollInstance.isScrolling())
                        return;

                    if (!focusable)
                        return;

                    if (me.isTouchDevice()) {
                        return;
                    }

                    //         if (!me.isNestedGrid) {
                    if (editor) {
                        editor.focus();
                    }
                    //       }

                    if (me.gridcontent[0].scrollTop != 0) {
                        me.scrolltop(Math.abs(me.gridcontent[0].scrollTop));
                        me.gridcontent[0].scrollTop = 0;
                    }

                    if (me.gridcontent[0].scrollLeft != 0) {
                        me.gridcontent[0].scrollLeft = 0;
                    }
                }

                switch (column.columntype) {
                    case "dropdownlist":
                        if (this.host.jqxDropDownList) {
                            element.innerHTML = "";
                            var datafieldname = $.trim(column.datafield).split(" ").join("");
                            var displayfield = $.trim(column.displayfield).split(" ").join("");

                            if (datafieldname.indexOf('.') != -1) {
                                datafieldname = datafieldname.replace('.', "");
                            }
                            if (displayfield.indexOf('.') != -1) {
                                displayfield = displayfield.replace('.', "");
                            }

                            var offset = me.theme === 'fluent' ? 2 : 0;

                            var dropdownlisteditor = this.editors["dropdownlist" + "_" + datafieldname];
                            editor = dropdownlisteditor == undefined ? $("<div style='border: none; border-radius: 0px; -moz-border-radius: 0px; -webkit-border-radius: 0px; z-index: 799; top: 0px; left: 0px; position: absolute;' id='dropdownlisteditor'></div>") : dropdownlisteditor;
                            editor.css('top', offset + $(element).parent().position().top);
                            if (this.oldhscroll) {
                                editor.css('left', offset - left + parseInt($(element).position().left));
                            }
                            else {
                                editor.css('left', offset + parseInt($(element).position().left));
                            }

                            if (column.pinned) {
                                editor.css('left', offset + left + parseInt($(element).position().left));
                            }


                            if (dropdownlisteditor == undefined) {
                                editor.prependTo(this.table);
                                editor[0].id = "dropdownlisteditor" + this.element.id + datafieldname;
                                var isdataadapter = this.source._source ? true : false;
                                var dataadapter = null;

                                if (!isdataadapter) {
                                    dataadapter = new $.jqx.dataAdapter(this.source,
                                        {
                                            autoBind: false,
                                            uniqueDataFields: [displayfield],
                                            async: false,
                                            autoSort: true,
                                            autoSortField: displayfield
                                        });
                                }
                                else {
                                    var dataSource =
                                    {
                                        localdata: JSON.parse(JSON.stringify(this.source.records)),
                                        datatype: this.source.datatype,
                                        async: false
                                    }

                                    dataadapter = new $.jqx.dataAdapter(dataSource,
                                        {
                                            autoBind: false,
                                            async: false,
                                            uniqueDataFields: [displayfield],
                                            autoSort: true,
                                            autoSortField: displayfield
                                        });
                                }

                                var autoheight = !column.createeditor ? true : false;

                                editor.jqxDropDownList({ hint: false, enableBrowserBoundsDetection: true, keyboardSelection: false, source: dataadapter, rtl: this.rtl, autoDropDownHeight: autoheight, theme: this.theme, width: $element.width() - offset, height: $element.height() - offset, displayMember: displayfield, valueMember: datafield });
                                this.editors["dropdownlist" + "_" + datafieldname] = editor;
                                if (column.createeditor) {
                                    column.createeditor(row, cellvalue, editor);
                                }
                            }
                            if (column._requirewidthupdate) {
                                editor.jqxDropDownList({ width: $element.width() });
                            }

                            var dropdownitems = editor.jqxDropDownList('listBox').visibleItems;
                            if (!column.createeditor) {
                                if (dropdownitems.length < 8) {
                                    editor.jqxDropDownList('autoDropDownHeight', true);
                                }
                                else {
                                    editor.jqxDropDownList('autoDropDownHeight', false);
                                }
                            }
                            var cellvalue = this.getcellvalue(row, displayfield);
                            var selectedIndex = this.findRecordIndex(cellvalue, displayfield, dropdownitems);
                            if (init) {
                                if (cellvalue != "") {
                                    editor.jqxDropDownList('selectIndex', selectedIndex, true);
                                }
                                else {
                                    editor.jqxDropDownList('selectIndex', -1);
                                }
                            }
                            if (!this.editcell) {
                                return;
                            }

                            if (this.editcell.defaultvalue != undefined) {
                                editor.jqxDropDownList('selectIndex', this.editcell.defaultvalue, true);
                            }

                            if (focusable) {
                                editor.jqxDropDownList('focus');
                            }
                        }
                        break;
                    case "combobox":
                        if (this.host.jqxComboBox) {
                            element.innerHTML = "";
                            var datafieldname = $.trim(column.datafield).split(" ").join("");
                            var displayfield = $.trim(column.displayfield).split(" ").join("");
                            if (datafieldname.indexOf('.') != -1) {
                                datafieldname = datafieldname.replace('.', "");
                            }
                            if (displayfield.indexOf('.') != -1) {
                                displayfield = displayfield.replace('.', "");
                            }

                            var offset = me.theme === 'fluent' ? 2 : 0;
                            var comboboxeditor = this.editors["combobox" + "_" + datafieldname];
                            editor = comboboxeditor == undefined ? $("<div style='border: none; border-radius: 0px; -moz-border-radius: 0px; -webkit-border-radius: 0px; z-index: 799; top: 0px; left: 0px; position: absolute;' id='comboboxeditor'></div>") : comboboxeditor;
                            editor.css('top', offset + $(element).parent().position().top);
                            if (this.oldhscroll) {
                                editor.css('left', -left + offset + parseInt($(element).position().left));
                            }
                            else {
                                editor.css('left', offset + parseInt($(element).position().left));
                            }
                            if (column.pinned) {
                                editor.css('left', offset + left + parseInt($(element).position().left));
                            }

                            if (comboboxeditor == undefined) {
                                editor.prependTo(this.table);
                                editor[0].id = "comboboxeditor" + this.element.id + datafieldname;
                                var isdataadapter = this.source._source ? true : false;
                                var dataadapter = null;
                                if (!isdataadapter) {
                                    dataadapter = new $.jqx.dataAdapter(this.source,
                                        {
                                            autoBind: false,
                                            uniqueDataFields: [displayfield],
                                            async: false,
                                            autoSort: true,
                                            autoSortField: displayfield
                                        });
                                }
                                else {
                                    var dataSource =
                                    {
                                        localdata: JSON.parse(JSON.stringify(this.source.records)),
                                        datatype: this.source.datatype,
                                        async: false
                                    }

                                    dataadapter = new $.jqx.dataAdapter(dataSource,
                                        {
                                            autoBind: false,
                                            async: false,
                                            uniqueDataFields: [displayfield],
                                            autoSort: true,
                                            autoSortField: displayfield
                                        });
                                }

                                var autoheight = !column.createeditor ? true : false;
                                editor.jqxComboBox({ hint: false, enableBrowserBoundsDetection: true, keyboardSelection: false, source: dataadapter, rtl: this.rtl, autoDropDownHeight: autoheight, theme: this.theme, width: $element.width() - offset, height: $element.height() - offset, displayMember: displayfield, valueMember: datafield });
                                editor.removeAttr('tabindex');
                                editor.find('div').removeAttr('tabindex');
                                this.editors["combobox" + "_" + datafieldname] = editor;
                                if (column.createeditor) {
                                    column.createeditor(row, cellvalue, editor);
                                }
                            }
                            if (column._requirewidthupdate) {
                                editor.jqxComboBox({ width: $element.width() - 2 });
                            }

                            var dropdownitems = editor.jqxComboBox('listBox').visibleItems;
                            if (!column.createeditor) {
                                if (dropdownitems.length < 8) {
                                    editor.jqxComboBox('autoDropDownHeight', true);
                                }
                                else {
                                    editor.jqxComboBox('autoDropDownHeight', false);
                                }
                            }

                            var cellvalue = this.getcellvalue(row, displayfield);
                            var selectedIndex = this.findRecordIndex(cellvalue, displayfield, dropdownitems);
                            if (init) {
                                if (cellvalue != "") {
                                    editor.jqxComboBox('selectIndex', selectedIndex, true);
                                    editor.jqxComboBox('val', cellvalue);
                                }
                                else {
                                    editor.jqxComboBox('selectIndex', -1);
                                    editor.jqxComboBox('val', cellvalue);
                                }
                            }
                            if (!this.editcell) {
                                return;
                            }

                            if (this.editcell.defaultvalue != undefined) {
                                editor.jqxComboBox('selectIndex', this.editcell.defaultvalue, true);
                            }

                            if (this.editchar && this.editchar.length > 0) {
                                editor.jqxComboBox('input').val(this.editchar);
                            }

                            if (focusable) {
                                setTimeout(function () {
                                    focuseditor(editor.jqxComboBox('input'));
                                    if (editor) {
                                        editor.jqxComboBox('_setSelection', 0, 0);
                                        if (me.editchar) {
                                            editor.jqxComboBox('_setSelection', 1, 1);
                                            me.editchar = null;
                                        }
                                        else {
                                            if (editor.jqxComboBox('input')) {
                                                var val = editor.jqxComboBox('input').val();
                                                editor.jqxComboBox('_setSelection', 0, val.length);
                                            }
                                        }
                                    }
                                }, 10);
                            }
                        }
                        break;
                    case "datetimeinput":
                        if (this.host.jqxDateTimeInput) {
                            element.innerHTML = "";
                            var datafieldname = $.trim(column.datafield).split(" ").join("");
                            if (datafieldname.indexOf('.') != -1) {
                                datafieldname = datafieldname.replace('.', "");
                            }

                            var offset = me.theme === 'fluent' ? 2 : 0;
                            var dateeditor = this.editors["datetimeinput" + "_" + datafieldname];
                            editor = dateeditor == undefined ? $("<div style='border: none; border-radius: 0px; -moz-border-radius: 0px; -webkit-border-radius: 0px; z-index: 799; top: 0px; left: 0px; position: absolute;' id='datetimeeditor'></div>") : dateeditor;
                            editor.show();
                            editor.css('top', offset + $(element).parent().position().top);
                            if (this.oldhscroll) {
                                editor.css('left', offset - left + parseInt($(element).position().left));
                            }
                            else {
                                editor.css('left', offset + parseInt($(element).position().left));
                            }
                            if (column.pinned) {
                                editor.css('left', offset + left + parseInt($(element).position().left));
                            }

                            if (dateeditor == undefined) {
                                editor.prependTo(this.table);
                                editor[0].id = "datetimeeditor" + this.element.id + datafieldname;
                                var localization = { calendar: this.gridlocalization };
                                editor.jqxDateTimeInput({ hint: false, firstDayOfWeek: this.gridlocalization.firstDay, enableBrowserBoundsDetection: true, localization: localization, _editor: true, theme: this.theme, rtl: this.rtl, width: $element.width() - offset, height: $element.height() - 4 * offset, formatString: column.cellsformat });
                                this.editors["datetimeinput" + "_" + datafieldname] = editor;
                                if (column.createeditor) {
                                    column.createeditor(row, cellvalue, editor);
                                }
                            }
                            if (column._requirewidthupdate) {
                                editor.jqxDateTimeInput({ width: $element.width() });
                            }
                            if (init) {
                                if (cellvalue != "" && cellvalue != null) {
                                    var date = new Date(cellvalue);
                                    if (date == "Invalid Date") {
                                        if (this.source.getvaluebytype) {
                                            date = this.source.getvaluebytype(cellvalue, { name: column.datafield, type: 'date' });
                                        }
                                    }

                                    editor.jqxDateTimeInput('setDate', date);
                                }
                                else {
                                    editor.jqxDateTimeInput('setDate', null);
                                }

                                if (this.editcell.defaultvalue != undefined) {
                                    editor.jqxDateTimeInput('setDate', this.editcell.defaultvalue);
                                }
                            }

                            if (focusable) {
                                var e = this.editEvent;
                                setTimeout(function () {
                                    focuseditor(editor.jqxDateTimeInput('dateTimeInput'));
                                    setTimeout(function () {
                                        editor.jqxDateTimeInput('_selectGroup', 0);
                                        if (me.editchar && me.editchar.length > 0) {
                                            var digit = parseInt(me.editchar);
                                            if (!isNaN(digit)) {
                                                if (e) {
                                                    var key = e.charCode ? e.charCode : e.keyCode ? e.keyCode : 0;
                                                    editor.jqxDateTimeInput('_handleKeyPress', e, key);
                                                }
                                            }
                                        }
                                    }, 25);
                                }, 10);
                            }
                        }
                        break;
                    case "numberinput":
                        if (this.host.jqxNumberInput) {
                            element.innerHTML = "";
                            var datafieldname = $.trim(column.datafield).split(" ").join("");
                            if (datafieldname.indexOf('.') != -1) {
                                datafieldname = datafieldname.replace('.', "");
                            }
                            var offset = me.theme === 'fluent' ? 2 : 0;
                            var numbereditor = this.editors["numberinput" + "_" + datafieldname];
                            editor = numbereditor == undefined ? $("<div style='border:none; border-radius: 0px; -moz-border-radius: 0px; -webkit-border-radius: 0px; z-index: 799; top: 0px; left: 0px; position: absolute;' id='numbereditor'></div>") : numbereditor;
                            editor.show();
                            editor.css('top', offset + $(element).parent().position().top);
                            if (this.oldhscroll) {
                                editor.css('left', offset - left + parseInt($(element).position().left));
                            }
                            else {
                                editor.css('left', offset + parseInt($(element).position().left));
                            }
                            if (column.pinned) {
                                editor.css('left', offset + left + parseInt($(element).position().left));
                            }

                            if (numbereditor == undefined) {
                                editor.prependTo(this.table);
                                editor[0].id = "numbereditor" + this.element.id + datafieldname;
                                var symbol = '';
                                var symbolPosition = 'left';
                                var digits = 2;
                                if (column.cellsformat) {
                                    if (column.cellsformat.indexOf('c') != -1) {
                                        symbol = this.gridlocalization.currencysymbol;
                                        symbolPosition = this.gridlocalization.currencysymbolposition;
                                        if (symbolPosition == 'before') symbolPosition = 'left';
                                        else symbolPosition = 'right';
                                        if (column.cellsformat.length > 1) {
                                            digits = parseInt(column.cellsformat.substring(1), 10);
                                        }
                                    }
                                    else if (column.cellsformat.indexOf('p') != -1) {
                                        symbol = this.gridlocalization.percentsymbol;
                                        symbolPosition = 'right';
                                        if (column.cellsformat.length > 1) {
                                            digits = parseInt(column.cellsformat.substring(1), 10);
                                        }
                                    }
                                }
                                else digits = 0;

                                editor.jqxNumberInput({ decimalSeparator: this.gridlocalization.decimalseparator, decimalDigits: digits, inputMode: 'simple', theme: this.theme, rtl: this.rtl, width: $element.width() - offset, height: $element.height() - offset, spinButtons: true, symbol: symbol, symbolPosition: symbolPosition });
                                this.editors["numberinput" + "_" + datafieldname] = editor;
                                if (column.createeditor) {
                                    column.createeditor(row, cellvalue, editor);
                                }
                            }
                            if (column._requirewidthupdate) {
                                editor.jqxNumberInput({ width: $element.width() });
                            }
                            if (init) {
                                if (cellvalue != "" && cellvalue != null) {
                                    var decimal = cellvalue;
                                    editor.jqxNumberInput('setDecimal', decimal);
                                }
                                else {
                                    editor.jqxNumberInput('setDecimal', 0);
                                }

                                if (this.editcell.defaultvalue != undefined) {
                                    editor.jqxNumberInput('setDecimal', this.editcell.defaultvalue);
                                }

                                if (this.editchar && this.editchar.length > 0) {
                                    var digit = parseInt(this.editchar);
                                    if (!isNaN(digit)) {
                                        editor.jqxNumberInput('setDecimal', digit);
                                    }
                                }

                                if (focusable) {
                                    setTimeout(function () {
                                        focuseditor(editor.jqxNumberInput('numberInput'));
                                        editor.jqxNumberInput('_setSelectionStart', 0);
                                        if (me.editchar) {
                                            if (column.cellsformat.length > 0 && column.cellsformat.indexOf('c') >= 0) {
                                                editor.jqxNumberInput('_setSelectionStart', 2);
                                            }
                                            else {
                                                editor.jqxNumberInput('_setSelectionStart', 1);
                                            }
                                            me.editchar = null;
                                        }
                                        else {
                                            var spinbuttons = editor.jqxNumberInput('spinButtons');
                                            if (spinbuttons) {
                                                var val = editor.jqxNumberInput('numberInput').val();
                                                me._setSelection(editor.jqxNumberInput('numberInput')[0], val.length, val.length);
                                            }
                                            else {
                                                var val = editor.jqxNumberInput('numberInput').val();
                                                me._setSelection(editor.jqxNumberInput('numberInput')[0], 0, val.length);
                                            }
                                            editor.jqxNumberInput('selectAll');
                                        }
                                    }, 10);
                                }
                            }
                        }
                        break;
                    case "rating":
                        if (this.host.jqxRating) {
                            element.innerHTML = "";
                            var datafieldname = $.trim(column.datafield).split(" ").join("");
                            if (datafieldname.indexOf('.') != -1) {
                                datafieldname = datafieldname.replace('.', "");
                            }
                            var ratingEditor = this.editors["rating" + "_" + datafieldname];
                            editor = ratingEditor == undefined ? $("<div style='margin: 5px;white-space: nowrap; overflow: auto; border:none; border-radius: 0px; -moz-border-radius: 0px; -webkit-border-radius: 0px; z-index: 799; top: 0px; left: 0px; position: absolute;' id='ratingEditor'></div>") : ratingEditor;
                            editor.show();
                            editor.css('top', $(element).parent().position().top);
                            if (this.oldhscroll) {
                                editor.css('left', -left + parseInt($(element).position().left));
                            }
                            else {
                                editor.css('left', parseInt($(element).position().left));
                            }
                            if (column.pinned) {
                                editor.css('left', left + parseInt($(element).position().left));
                            }

                            if (ratingEditor == undefined) {
                                editor.prependTo(this.table);
                                editor[0].id = "ratingEditor" + this.element.id + datafieldname;

                                editor.jqxRating({ theme: this.theme, width: $element.width(), height: $element.height() });
                                this.editors["numberinput" + "_" + datafieldname] = editor;
                                if (column.createeditor) {
                                    column.createeditor(row, cellvalue, editor);
                                }
                            }
                            if (column._requirewidthupdate) {
                                editor.jqxRating({ width: $element.width() });
                            }
                            if (init) {
                                if (cellvalue != "" && cellvalue != null) {
                                    var decimal = cellvalue;
                                    editor.jqxRating('val', decimal);
                                }
                                else {
                                    editor.jqxRating('val', 0);
                                }

                                if (this.editcell.defaultvalue != undefined) {
                                    editor.jqxRating('val', this.editcell.defaultvalue);
                                }
                            }
                        }
                        break;

                    case "custom":
                        element.innerHTML = "";
                        var datafieldname = $.trim(column.datafield).split(" ").join("");
                        if (datafieldname.indexOf('.') != -1) {
                            datafieldname = datafieldname.replace('.', "");
                        }
                        var customeditor = this.editors["customeditor" + "_" + datafieldname + "_" + row];
                        editor = customeditor == undefined ? $("<div style='overflow: hidden; border-radius: 0px; -moz-border-radius: 0px; -webkit-border-radius: 0px; z-index: 799; top: 0px; left: 0px; position: absolute;' id='customeditor'></div>") : customeditor;
                        editor.show();
                        editor.css('top', $(element).parent().position().top);
                        if (this.oldhscroll) {
                            editor.css('left', -left + parseInt($(element).position().left));
                        }
                        else {
                            editor.css('left', parseInt($(element).position().left));
                        }
                        if (column.pinned) {
                            editor.css('left', left + parseInt($(element).position().left));
                        }

                        if (customeditor == undefined) {
                            editor.prependTo(this.table);
                            editor[0].id = "customeditor" + this.element.id + datafieldname + "_" + row;
                            this.editors["customeditor" + "_" + datafieldname + "_" + row] = editor;
                            var width = $element.width() - 1;
                            var height = $element.height() - 1;
                            editor.width(width);
                            editor.height(height);

                            if (column.createeditor) {
                                column.createeditor(row, cellvalue, editor, celltext, width, height, this.editchar);
                            }
                        }
                        if (column._requirewidthupdate) {
                            editor.width($element.width());
                        }
                        break;
                    case "template":
                        element.innerHTML = "";
                        var datafieldname = $.trim(column.datafield).split(" ").join("");
                        if (datafieldname.indexOf('.') != -1) {
                            datafieldname = datafieldname.replace('.', "");
                        }
                        var templateeditor = this.editors["templateeditor" + "_" + datafieldname];
                        editor = templateeditor == undefined ? $("<div style='overflow: hidden; border-radius: 0px; -moz-border-radius: 0px; -webkit-border-radius: 0px; z-index: 799; top: 0px; left: 0px; position: absolute;' id='templateeditor'></div>") : templateeditor;
                        editor.show();
                        editor.css('top', $(element).parent().position().top);
                        if (this.oldhscroll) {
                            editor.css('left', -left + parseInt($(element).position().left));
                        }
                        else {
                            editor.css('left', parseInt($(element).position().left));
                        }
                        if (column.pinned) {
                            editor.css('left', left + parseInt($(element).position().left));
                        }

                        if (templateeditor == undefined) {
                            editor.prependTo(this.table);
                            editor[0].id = "templateeditor" + this.element.id + datafieldname;
                            this.editors["templateeditor" + "_" + datafieldname] = editor;
                            var width = $element.width() - 1;
                            var height = $element.height() - 1;
                            editor.width(width);
                            editor.height(height);

                            if (column.createeditor) {
                                column.createeditor(row, cellvalue, editor, celltext, width, height, this.editchar);
                            }
                        }
                        if (column._requirewidthupdate) {
                            editor.width($element.width());
                        }
                        break;
                    case "textbox":
                    default:
                        element.innerHTML = "";
                        editor = this.editors["textboxeditor" + "_" + column.datafield] || $("<input autocomplete='off' style='padding-left: 4px; padding-right:4px; border: none; border-color: transparent;' autocorrect='off' autocapitalize='off' spellcheck='false' type='textbox' id='textboxeditor'/>");
                        editor[0].id = "textboxeditor" + this.element.id + column.datafield;
                        editor.appendTo($element);

                        if (this.rtl) {
                            editor.css('direction', 'rtl');
                        }

                        if (init || editor[0].className == "") {
                            editor.addClass(this.toThemeProperty('jqx-input'));
                            editor.addClass(this.toThemeProperty('jqx-widget-content'));
                            if (this.editchar && this.editchar.length > 0) {
                                editor.val(this.editchar);
                            }
                            else {
                                if (column.cellsformat != "") {
                                    cellvalue = this.getcelltext(row, datafield);
                                }
                                if (cellvalue == undefined) {
                                    cellvalue = "";
                                }
                                editor.val(cellvalue);
                            }

                            if (this.editcell.defaultvalue != undefined) {
                                editor.val(this.editcell.defaultvalue);
                            }
                            editor.width($element.width() + 1);
                            editor.height($element.height() + 1);

                            if (column.createeditor) {
                                column.createeditor(row, cellvalue, editor);
                            }

                            if (column.cellsformat != "") {
                                if (column.cellsformat.indexOf('p') != -1 || column.cellsformat.indexOf('c') != -1 || column.cellsformat.indexOf('n') != -1 || column.cellsformat.indexOf('f') != -1) {
                                    if (!this.editors["textboxeditor" + "_" + column.datafield]) {
                                        editor.keydown(function (event) {
                                            var key = event.charCode ? event.charCode : event.keyCode ? event.keyCode : 0;
                                            var letter = String.fromCharCode(key);
                                            var charDigit = parseInt(letter);
                                            if (isNaN(charDigit))
                                                return true;
                                            if (me._selection(editor).length > 0)
                                                return true;

                                            var val = "";
                                            var cellvalue = editor.val();
                                            if (column.cellsformat.length > 1) {
                                                var decimalOffset = parseInt(column.cellsformat.substring(1));
                                                if (isNaN(decimalOffset)) decimalOffset = 0;
                                            }
                                            else {
                                                var decimalOffset = 0;
                                            }

                                            if (decimalOffset > 0) {
                                                if (cellvalue.indexOf(me.gridlocalization.decimalseparator) != -1) {
                                                    if (me._selection(editor).start > cellvalue.indexOf(me.gridlocalization.decimalseparator)) {
                                                        return true;
                                                    }
                                                }
                                            }

                                            for (var t = 0; t < cellvalue.length - decimalOffset; t++) {
                                                var ch = cellvalue.substring(t, t + 1);
                                                if (ch.match(/^[0-9]+$/) != null) {
                                                    val += ch;
                                                }
                                            }
                                            if (val.length >= 11) {
                                                return false;
                                            }
                                        });
                                    }
                                }
                            }
                        }

                        this.editors["textboxeditor" + "_" + column.datafield] = editor;

                        if (init) {
                            if (focusable) {
                                setTimeout(function () {
                                    focuseditor(editor);
                                    if (me.editchar) {
                                        me._setSelection(editor[0], 1, 1);
                                        me.editchar = null;
                                    }
                                    else {
                                        me._setSelection(editor[0], 0, editor.val().length);
                                    }
                                }, 25);
                            }
                        }
                        break;
                }

                if (editor) {
                    editor.addClass('jqx-grid-cell-edit');
                    editor[0].style.zIndex = 1 + parseInt(element.style.zIndex);
                    if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                        editor[0].style.zIndex = 1 + this.columns.records.length + element.style.zIndex;
                    }
                    editor.css('display', 'block');
                    this.editcell.editor = editor;
                    if (!this.editcell[datafield]) {
                        this.editcell[datafield] = {};
                        this.editcell[datafield].editor = editor;
                    }
                    else {
                        this.editcell[datafield].editor = editor;
                    }
                }

                if (init) {
                    if (column.initeditor) {
                        column.initeditor(row, cellvalue, editor, celltext, this.editchar);
                    }
                }

                if (me.isTouchDevice()) {
                    return;
                }

                setTimeout(function () {
                    if (me.content) {
                        me.content[0].scrollTop = 0;
                        me.content[0].scrollLeft = 0;
                    }
                    if (me.gridcontent) {
                        me.gridcontent[0].scrollLeft = 0;
                        me.gridcontent[0].scrollTop = 0;
                    }
                }, 10);
            },

            _setSelection: function (textbox, start, end) {
                try {
                    if ('selectionStart' in textbox) {
                        textbox.setSelectionRange(start, end);
                    }
                    else {
                        var range = textbox.createTextRange();
                        range.collapse(true);
                        range.moveEnd('character', end);
                        range.moveStart('character', start);
                        range.select();
                    }
                }
                catch (error) {
                    var err = error;
                }
            },

            _hideeditors: function () {
                if (this.editcells != null) {
                    var me = this;
                    for (var obj in this.editcells) {
                        me.editcell = me.editcells[obj];
                        me._hidecelleditor();
                    }
                }
            },

            _hidecelleditor: function (focus) {
                if (!this.editcell) {
                    return;
                }

                if (this.editmode === "selectedrow") {
                    for (var i = 0; i < this.columns.records.length; i++) {
                        var column = this.columns.records[i];
                        if (this.editcell[column.datafield] && this.editcell[column.datafield].editor) {
                            this.editcell[column.datafield].editor.hide();
                            var editor = this.editcell[column.datafield].editor;
                            switch (column.columntype) {
                                case "dropdownlist":
                                    editor.jqxDropDownList({ closeDelay: 0 });
                                    editor.jqxDropDownList('hideListBox');
                                    editor.jqxDropDownList({ closeDelay: 300 });
                                    break;
                                case "combobox":
                                    editor.jqxComboBox({ closeDelay: 0 });
                                    editor.jqxComboBox('hideListBox');
                                    editor.jqxComboBox({ closeDelay: 300 });
                                    break;
                                case "datetimeinput":
                                    if (editor.jqxDateTimeInput('isOpened')) {
                                        editor.jqxDateTimeInput({ closeDelay: 0 });
                                        editor.jqxDateTimeInput('hideCalendar');
                                        editor.jqxDateTimeInput({ closeDelay: 300 });
                                    }
                                    break;
                            }
                        }
                    }
                    if (this.validationpopup) {
                        this.validationpopup.hide();
                        this.validationpopuparrow.hide();
                    }
                    return;
                }

                if (this.editcell.columntype == 'checkbox') {
                    return;
                }

                if (this.editcell.editor) {
                    this.editcell.editor.hide();
                    switch (this.editcell.columntype) {
                        case "dropdownlist":
                            this.editcell.editor.jqxDropDownList({ closeDelay: 0 });
                            this.editcell.editor.jqxDropDownList('hideListBox');
                            this.editcell.editor.jqxDropDownList({ closeDelay: 300 });
                            break;
                        case "combobox":
                            this.editcell.editor.jqxComboBox({ closeDelay: 0 });
                            this.editcell.editor.jqxComboBox('hideListBox');
                            this.editcell.editor.jqxComboBox({ closeDelay: 300 });
                            break;
                        case "datetimeinput":
                            var datetimeeiditor = this.editcell.editor;
                            if (datetimeeiditor.jqxDateTimeInput('isOpened')) {
                                datetimeeiditor.jqxDateTimeInput({ closeDelay: 0 });
                                datetimeeiditor.jqxDateTimeInput('hideCalendar');
                                datetimeeiditor.jqxDateTimeInput({ closeDelay: 300 });
                            }
                            break;
                    }
                }

                if (this.validationpopup) {
                    this.validationpopup.hide();
                    this.validationpopuparrow.hide();
                }
                if (!this.isNestedGrid) {
                    if (focus != false) {
                        this.element.focus();
                    }
                }
            },

            _geteditorvalue: function (column) {
                var value = new String();
                if (!this.editcell) {
                    return null;
                }

                var editor = this.editcell.editor;
                if (this.editmode == "selectedrow") {
                    if (this.editcell[column.datafield]) {
                        var editor = this.editcell[column.datafield].editor;
                    }
                }

                if (editor) {
                    switch (column.columntype) {
                        case "textbox":
                        default:
                            value = editor.val();
                            if (column.cellsformat != "") {
                                var type = 'string';
                                var datafields = this.source.datafields || ((this.source._source) ? this.source._source.datafields : null);

                                if (datafields) {
                                    var foundType = "";
                                    $.each(datafields, function () {
                                        if (this.name == column.displayfield) {
                                            if (this.type) {
                                                foundType = this.type;
                                            }
                                            return false;
                                        }
                                    });
                                    if (foundType)
                                        type = foundType;
                                }

                                var number = type === "number" || type === "float" || type === "int" || type === "integer";
                                var date = type === "date" || type === "time";
                                if (number || (type === "string" && (column.cellsformat.indexOf('p') != -1 || column.cellsformat.indexOf('c') != -1 || column.cellsformat.indexOf('n') != -1 || column.cellsformat.indexOf('f') != -1))) {
                                    if (value === "" && column.nullable)
                                        return "";

                                    if (value.indexOf && value.indexOf(this.gridlocalization.currencysymbol) > -1) {
                                        // remove currency symbol
                                        value = value.replace(this.gridlocalization.currencysymbol, "");
                                    }

                                    var replaceAll = function (text, stringToFind, stringToReplace) {
                                        var temp = text;
                                        if (stringToFind == stringToReplace) return text;

                                        var index = temp.indexOf(stringToFind);
                                        while (index != -1) {
                                            temp = temp.replace(stringToFind, stringToReplace);
                                            index = temp.indexOf(stringToFind)
                                        }

                                        return temp;
                                    }

                                    var tmp = value;
                                    tmp = new Number(tmp);
                                    if (!isNaN(tmp)) {
                                        return tmp;
                                    }

                                    value = replaceAll(value, this.gridlocalization.thousandsseparator, "");
                                    value = value.replace(this.gridlocalization.decimalseparator, ".");

                                    if (value.indexOf(this.gridlocalization.percentsymbol) > -1) {
                                        value = value.replace(this.gridlocalization.percentsymbol, "");
                                    }

                                    var val = "";
                                    for (var t = 0; t < value.length; t++) {
                                        var ch = value.substring(t, t + 1);
                                        if (ch === "-") val += "-";
                                        if (ch === ".") val += ".";
                                        if (ch.match(/^[0-9]+$/) != null) {
                                            val += ch;
                                        }
                                    }

                                    value = val;
                                    value = value.replace(/ /g, "");

                                    value = new Number(value);
                                    if (isNaN(value))
                                        value = "";
                                }
                                if (date || (type === "string" && (column.cellsformat.indexOf('H') != -1 || column.cellsformat.indexOf('m') != -1 || column.cellsformat.indexOf('M') != -1 || column.cellsformat.indexOf('y') != -1
                                    || column.cellsformat.indexOf('h') != -1 || column.cellsformat.indexOf('d') != -1))) {
                                    if (value === "" && column.nullable)
                                        return "";

                                    var tmpValue = value;
                                    if ($.jqx.dataFormat) {
                                        value = $.jqx.dataFormat.tryparsedate(tmpValue, this.gridlocalization);
                                    }
                                    if (value == "Invalid Date" || value == null) {
                                        value = "";
                                    }
                                }

                            }
                            if (column.displayfield != column.datafield) {
                                value = { label: value, value: value };
                            }
                            break;
                        case "checkbox":
                            if (editor.jqxCheckBox) {
                                value = editor.jqxCheckBox('checked');
                            }
                            break;
                        case "datetimeinput":
                            if (editor.jqxDateTimeInput) {
                                editor.jqxDateTimeInput({ isEditing: false });
                                if (editor.jqxDateTimeInput('container').css('display') !== 'none') {
                                    editor.jqxDateTimeInput('close');
                                }
                                editor.jqxDateTimeInput('_validateValue');
                                value = editor.jqxDateTimeInput('getDate');
                                if (value == null) return null;
                                value = new Date(value.toString());
                                if (column.displayfield != column.datafield) {
                                    value = { label: value, value: value };
                                }
                            }
                            break;
                        case "dropdownlist":
                            if (editor.jqxDropDownList) {
                                var selectedIndex = editor.jqxDropDownList('selectedIndex');
                                var item = editor.jqxDropDownList('listBox').getVisibleItem(selectedIndex);
                                if (column.displayfield != column.datafield) {
                                    if (item) {
                                        value = { label: item.label, value: item.value };
                                    }
                                    else value = "";
                                }
                                else {
                                    if (item) value = item.label;
                                    else value = "";
                                }

                                if (value == null) {
                                    value = "";
                                }
                            }
                            break;
                        case "combobox":
                            if (editor.jqxComboBox) {
                                value = editor.jqxComboBox('val');
                                if (column.displayfield != column.datafield) {
                                    var item = editor.jqxComboBox('getSelectedItem');
                                    if (item != null) {
                                        value = { label: item.label, value: item.value };
                                    }
                                }

                                if (value == null) {
                                    value = "";
                                }
                            }
                            break;
                        case "numberinput":
                            if (editor.jqxNumberInput) {
                                if (this.touchdevice) {
                                    editor.jqxNumberInput('_doTouchHandling');
                                }
                                var decimal = editor.jqxNumberInput('getDecimal');
                                value = new Number(decimal);
                                value = parseFloat(value);
                                if (isNaN(value)) {
                                    value = 0;
                                }
                                if (decimal === null) {
                                    value = null;
                                }

                                var max = editor.jqxNumberInput('max');
                                var min = editor.jqxNumberInput('min');

                                value = Math.min(max, Math.max(min, value));

                                if (column.displayfield != column.datafield) {
                                    value = { label: value, value: value };
                                }
                            }
                            break;
                    }
                    if (column.geteditorvalue) {
                        if (this.editmode == "selectedrow") {
                            value = column.geteditorvalue(this.editcell.row, this.getcellvalue(this.editcell.row, column.datafield), editor);
                        }
                        else {
                            value = column.geteditorvalue(this.editcell.row, this.editcell.value, editor);
                        }
                    }
                }
                return value;
            },

            hidevalidationpopups: function () {
                if (this.popups) {
                    $.each(this.popups, function () {
                        this.validation.remove();
                        this.validationrow.remove();
                    });
                    this.popups = new Array();
                }
                if (this.validationpopup) {
                    this.validationpopuparrow.hide();
                    this.validationpopup.hide();
                }
            },


            showvalidationpopup: function (row, datafield, message) {
                if (message == undefined) {
                    var message = this.gridlocalization.validationstring;
                }

                var validationpopup = $("<div style='z-index: 99999; top: 0px; left: 0px; position: absolute;'></div>");
                var validationpopuparrow = $("<div style='width: 20px; height: 20px; z-index: 999999; top: 0px; left: 0px; position: absolute;'></div>");
                validationpopup.html(message);
                validationpopuparrow.addClass(this.toThemeProperty('jqx-grid-validation-arrow-up'));
                validationpopup.addClass(this.toThemeProperty('jqx-grid-validation'));
                validationpopup.addClass(this.toThemeProperty('jqx-rc-all'));
                validationpopup.prependTo(this.table);
                validationpopuparrow.prependTo(this.table);

                var hScrollInstance = this.hScrollInstance;
                var horizontalscrollvalue = hScrollInstance.value;
                var left = parseInt(horizontalscrollvalue);
                var element = this.getcolumn(datafield).uielement;
                var info = null;
                for (var i = 0; i < this.hittestinfo.length; i++) {
                    if (row === this.hittestinfo[i].row.visibleindex) {
                        info = this.hittestinfo[i];
                    }
                }
                if (!info) {
                    this.ensurerowvisible(row);
                    var me = this;
                    validationpopup.remove();
                    validationpopuparrow.remove();
                    setTimeout(function () {
                        var info = null;
                        for (var i = 0; i < me.hittestinfo.length; i++) {
                            if (row === me.hittestinfo[i].row.visibleindex) {
                                info = me.hittestinfo[i];
                            }
                        }
                        if (info) {
                            me.showvalidationpopup(row, datafield, message);
                        }
                    }, 25);
                    return;
                }
                var rowElement = $(info.visualrow);
                validationpopup.css('top', parseInt(rowElement.position().top) + 30 + 'px');

                var topposition = parseInt(validationpopup.css('top'));

                validationpopuparrow.css('top', topposition - 12);
                validationpopuparrow.removeClass();
                validationpopuparrow.addClass(this.toThemeProperty('jqx-grid-validation-arrow-up'));

                var negativePosition = false;
                if (topposition >= this._gettableheight() - this.rowsheight) {
                    validationpopuparrow.removeClass(this.toThemeProperty('jqx-grid-validation-arrow-up'));
                    validationpopuparrow.addClass(this.toThemeProperty('jqx-grid-validation-arrow-down'));
                    topposition = parseInt(rowElement.position().top) - this.rowsheight;
                    if (topposition < 0) {
                        topposition = 0;
                        this.validationpopuparrow.removeClass(this.toThemeProperty('jqx-grid-validation-arrow-down'));
                        negativePosition = true;
                    }
                    validationpopup.css('top', topposition + 'px');
                    validationpopuparrow.css('top', topposition + validationpopup.outerHeight() - 9);
                }
                var leftposition = -left + parseInt($(element).position().left);

                if (element[0].offsetHeight === 0) {
                    leftposition = -left + parseInt(element[0].style.left);
                }

                validationpopuparrow.css('left', left + leftposition + 30);

                var width = validationpopup.width();
                if (width + leftposition > this.host.width() - 20) {
                    var offset = width + leftposition - this.host.width() + 40;
                    leftposition -= offset;
                }

                if (!negativePosition) {
                    validationpopup.css('left', left + leftposition);
                } else {
                    validationpopup.css('left', left + parseInt($(element).position().left) - validationpopup.outerWidth());
                }

                validationpopup.show();
                validationpopuparrow.show();
                if (!this.popups) {
                    this.popups = new Array();
                }
                this.popups[this.popups.length] = { validation: validationpopup, validationrow: validationpopuparrow };
            },

            _showvalidationpopup: function (row, datafield, message) {
                var editcell = this.editcell;
                var editor = this.editcell.editor;
                if (this.editmode == "selectedrow") {
                    var editcell = this.editcell[datafield];
                    if (editcell && editcell.editor) {
                        editor = editcell.editor;
                        editcell.element = editor;
                    }
                }

                if (!editor)
                    return;

                if (this.validationpopup && $.jqx.isHidden(this.validationpopup)) {
                    if (this.validationpopup.remove) {
                        this.validationpopup.remove();
                        this.validationpopuparrow.remove();
                    }
                    this.validationpopup = null;
                    this.validationpopuparrow = null;
                    if (datafield === undefined && message === undefined && this.editors && this.editors.length === 0) {
                        return;
                    }
                }

                if (!this.validationpopup) {
                    var validationpopup = $("<div style='z-index: 99999; top: 0px; left: 0px; position: absolute;'></div>");
                    var validationpopuparrow = $("<div style='width: 20px; height: 20px; z-index: 999999; top: 0px; left: 0px; position: absolute;'></div>");
                    validationpopup.html(message);
                    validationpopuparrow.addClass(this.toThemeProperty('jqx-grid-validation-arrow-up'));
                    validationpopup.addClass(this.toThemeProperty('jqx-grid-validation'));
                    validationpopup.addClass(this.toThemeProperty('jqx-rc-all'));
                    validationpopup.prependTo(this.table);
                    validationpopuparrow.prependTo(this.table);
                    this.validationpopup = validationpopup;
                    this.validationpopuparrow = validationpopuparrow;
                }
                else {
                    this.validationpopup.html(message);
                }

                var hScrollInstance = this.hScrollInstance;
                var horizontalscrollvalue = hScrollInstance.value;
                var left = parseInt(horizontalscrollvalue);

                if (this.editmode == "selectedrow") {
                    if (this.visiblerows && this.visiblerows[this.editcell.visiblerowindex]) {
                        this.validationpopup.css('top', this.visiblerows[this.editcell.visiblerowindex].top + (this.rowsheight + 5) + 'px');
                    }
                    else {
                        this.validationpopup.css('top', parseInt($(editcell.editor).position().top) + (this.rowsheight + 5) + 'px');
                    }
                }
                else {
                    this.validationpopup.css('top', parseInt($(editcell.element).parent().position().top) + (this.rowsheight + 5) + 'px');
                }

                var topposition = parseInt(this.validationpopup.css('top'));

                this.validationpopuparrow.css('top', topposition - 11);
                this.validationpopuparrow.removeClass();
                this.validationpopuparrow.addClass(this.toThemeProperty('jqx-grid-validation-arrow-up'));
                var height = this._gettableheight();

                var negativePosition = false;
                if (topposition >= height) {
                    this.validationpopuparrow.removeClass(this.toThemeProperty('jqx-grid-validation-arrow-up'));
                    this.validationpopuparrow.addClass(this.toThemeProperty('jqx-grid-validation-arrow-down'));
                    topposition = parseInt($(editcell.element).parent().position().top) - this.rowsheight - 5;
                    if (this.editmode == "selectedrow") {
                        if (this.visiblerows && this.visiblerows[this.editcell.visiblerowindex]) {
                            topposition = this.visiblerows[this.editcell.visiblerowindex].top - this.rowsheight - 5;
                        }
                        else {
                            topposition = parseInt($(editcell.editor).position().top) - this.rowsheight - 5;
                        }
                    }
                    if (topposition < 0) {
                        topposition = 0;
                        this.validationpopuparrow.removeClass(this.toThemeProperty('jqx-grid-validation-arrow-down'));
                        negativePosition = true;
                    }

                    this.validationpopup.css('top', topposition + 'px');
                    this.validationpopuparrow.css('top', topposition + this.validationpopup.outerHeight() - 9);
                }
                var leftposition = -left + parseInt($(editcell.element).offset().left);

                this.validationpopuparrow.css('left', left + leftposition + 30);

                var width = this.validationpopup.width();
                if (width + leftposition > this.host.width() - 20) {
                    var offset = width + leftposition - this.host.width() + 40;
                    leftposition -= offset;
                }

                if (!negativePosition) {
                    this.validationpopup.css('left', left + leftposition);
                }
                else {
                    this.validationpopup.css('left', left + parseInt($(editcell.element).position().left) - this.validationpopup.outerWidth());
                }

                if (this.editcell.editor.css('display') == "none") {
                    this.validationpopup.hide();
                    this.validationpopuparrow.hide();
                }
                else {
                    this.validationpopup.show();
                    this.validationpopuparrow.show();
                }
            }
        });
    })(jqxBaseFramework
    );
})();





/***/ }),

/***/ 469:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {
        $.extend($.jqx._jqxGrid.prototype, {

            _exportData: function (dataFormat, dataExport, dataRows, settings) {
                var that = this;

                var fileName = typeof dataExport === 'string' ? dataExport : dataExport.fileName;

                if (!fileName) {
                    fileName = 'jqxGrid';
                }

                if (!dataExport || typeof dataExport === 'string') {
                    dataExport =
                    {
                        header: true,
                        filterBy: null,
                        groupBy: null,
                        style: null,
                        fileName: fileName,
                        pageOrientation: 'portrait',
                        expandChart: '+',
                        collapseChar: '-'
                    }
                }


                var dataExporter = new $.jqx.dataAdapter.DataExporter({ exportHeader: dataExport.header });
                var formattedRows = [];

                dataExporter.expandChar = dataExport.expandChar;
                dataExporter.collapseChar = dataExport.collapseChar;
                dataExporter.pageOrientation = dataExport.pageOrientation;
                dataExporter.style = dataExport.style;
                dataExporter.filterBy = dataExport.filterBy;
                dataExporter.groupBy = dataExport.groupBy;

                if (settings) {
                    dataExporter.addImageToCell = settings.addImageToCell;
                    dataExporter.headerContent = settings.headerContent;
                    dataExporter.footerContent = settings.footerContent;
                    dataExporter.setRowHeight = settings.setRowHeight;
                    dataExporter.cellFormatFunction = settings.cellFormatFunction;
                    dataExporter.freezeHeader = settings.freezeHeader;
                    dataExporter.exportAsTable = settings.exportAsTable;
                    dataExporter.onlySelected = settings.onlySelected;
                    dataExporter.autoConvertFormulas = settings.autoConvertFormulas;

                }

                var cols = [];
                var colGroups = that.columngroups || [];
                var index = 0;

                if (colGroups) {
                    for (var i = 0; i < colGroups.length; i++) {
                        var column = colGroups[i];

                        column.label = column.text;
                    }
                }

                for (var i = 0; i < that.columns.records.length; i++) {
                    var column = that.columns.records[i];

                    if (!column.exportable) {
                        continue;
                    }

                    if (that.columns.records[i].datafield !== null) {
                        cols[index++] = { label: that.columns.records[i].text, width: that.columns.records[i].width ? that.columns.records[i].width + 'px' : '100px', dataField: that.columns.records[i].datafield, columnGroup: that.columns.records[i].columnGroup || that.columns.records[i].columngroup };
                    }
                }

                dataExporter.header = {
                    columns: cols,
                    columngroups: colGroups
                }

                if (!dataExport.style) {
                    var computedStyle = window.getComputedStyle(that.element);
                    var columnComputedStyle = window.getComputedStyle(that.columns.records.length > 0 && that.columns.records[0].element ? that.columns.records[0].element : that.host.find('.jqx-grid-header')[0]);
                    var headerComputedStyle = window.getComputedStyle(that.host.find('.jqx-grid-header')[0]);
                    var isHidden = that.offsetWidth === 0 || that.offsetHeight === 0;

                    if (!isHidden) {
                        var getStyle = function (computedStyle) {
                            var fontFamily = 'Helvetica';
                            var fontSize = computedStyle.fontSize;
                            var borderColor = computedStyle.borderRightColor;
                            var backgroundColor = computedStyle.backgroundColor;
                            var color = computedStyle.color;

                            var hexDigits = new Array
                                ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');

                            var hex = function (x) {
                                return isNaN(x) ? '00' : hexDigits[(x - x % 16) / 16] + hexDigits[x % 16];
                            }
                            //Function to convert rgb color to hex format
                            var toHex = function (rgb) {
                                if (rgb.toString().indexOf('rgba') != -1) {
                                    var rgbValue = color.split(',');
                                    var r = parseInt(rgbValue[0].substring(5));
                                    var g = parseInt(rgbValue[1]);
                                    var b = parseInt(rgbValue[2]);
                                    if (rgbValue[3]) {
                                        var a = parseFloat(rgbValue[3].substring(1, 4));
                                    }
                                    else {
                                        var a = 1;
                                    }

                                    var rgbObj = { r: r, g: g, b: b };
                                    var hexValue = that._rgbToHex(rgbObj);
                                    if (r == 0 && g == 0 && b == 0 && a == 0) {
                                        return "#ffffff";
                                    }

                                    return "#" + hexValue;
                                }

                                rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);

                                if (!rgb) {
                                    return '#ffffff';
                                }

                                return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]).toUpperCase();
                            }

                            return {
                                borderColor: toHex(borderColor),
                                fontSize: fontSize,
                                fontFamily: fontFamily,
                                color: toHex(color),
                                backgroundColor: toHex(backgroundColor)
                            }
                        }

                        var gridStyle = getStyle(computedStyle);
                        var columnStyle = getStyle(columnComputedStyle);
                        var headerStyle = getStyle(headerComputedStyle);

                        var header = {
                            height: '30px',
                            border: '1px solid ' + gridStyle.borderColor,
                            fontFamily: headerStyle.fontFamily,
                            fontSize: headerStyle.fontSize,
                            color: headerStyle.color,
                            backgroundColor: columnStyle.backgroundColor,
                            fontWeight: '400'
                        };

                        var columns = {
                            border: '1px solid ' + gridStyle.borderColor,
                            fontFamily: gridStyle.fontFamily,
                            fontSize: gridStyle.fontSize
                        };

                        var rows = {
                            height: that.rowsheight + 'px'
                        };

                        for (var i = 0; i < that.columns.records.length; i++) {
                            var column = that.columns.records[i];

                            if (!column.exportable) {
                                continue;
                            }

                            header[column.datafield] = {
                                textAlign: column.align,
                                width: column.width + 'px',
                                format: column.cellsformat || ''
                            };

                            var cellsFormat = column.cellsformat || '';

                            if (column.dataType === 'date') {
                                cellsFormat = 'd';
                            }
                            else if (column.dataType === 'dateTime') {
                                cellsFormat = 'D';
                            }
                            else if (column.dataType === 'time') {
                                cellsFormat = 't';
                            }

                            var columnStyleObject = {
                                textAlign: column.cellsalign,
                                format: cellsFormat
                            };

                            columns[column.datafield] = columnStyleObject;
                        }

                        if (that.altrows) {
                            rows.alternationCount = 2;
                            rows.alternationStart = 0;
                            rows.alternationEnd = 0;
                            rows.alternationIndex0Color = gridStyle.color;
                            rows.alternationIndex0BackgroundColor = gridStyle.backgroundColor;
                            rows.alternationIndex1Color = gridStyle.color;
                            rows.alternationIndex1BackgroundColor = '#F5F5F5';
                        }
                        dataExporter.style = {
                            border: '1px solid ' + gridStyle.borderColor,
                            borderCollapse: 'collapse',
                            header: header,
                            columns: columns,
                            rows: rows
                        }
                    }
                }

                if (settings) {
                    if (settings.getSpreadsheets) {
                        const spreadsheets = settings.getSpreadsheets();
                        if (spreadsheets) {
                            dataExporter.spreadsheets = spreadsheets;

                            const header = dataExporter.style.header;
                            const columns = dataExporter.style.columns;
                            for (let p = 0; p < spreadsheets.length; p++) {
                                const sheet = spreadsheets[p];
                                const sheetColumns = sheet.columns;
                                for (let i = 0; i < sheetColumns.length; i++) {
                                    let column = sheetColumns[i];

                                    if (typeof column === 'string') {
                                        column = {
                                            label: column,
                                            dataField: column,
                                            allowExport: true,
                                            visible: true
                                        }
                                    }

                                    if (column.allowExport !== undefined && !column.allowExport) {
                                        continue;
                                    }

                                    if (column.visible !== undefined && !column.visible) {
                                        continue;
                                    }

                                    column.label = column.text;

                                    header[column.dataField] = {
                                        textAlign: column.align || 'left',
                                        verticalAlign: 'center',
                                        width: column.computedWidth ? column.computedWidth + 'px' : '100px',
                                        format: column.cellsFormat || ''
                                    };

                                    let cellsFormat = column.cellsFormat || '';

                                    if (!cellsFormat) {
                                        if (column.dataType === 'date') {
                                            cellsFormat = 'd';
                                        }
                                        else if (column.dataType === 'dateTime') {
                                            cellsFormat = 'D';
                                        }
                                        else if (column.dataType === 'time') {
                                            cellsFormat = 't';
                                        }
                                    }

                                    if (that.locale && cellsFormat && cellsFormat.indexOf('c') >= 0 && dataFormat === 'xlsx') {
                                        if (that.locale !== '' && that.locale !== 'en') {
                                            const currencySign = that._getCurrencyByLocale(that.locale);
                                            cellsFormat = currencySign + 'x' + cellsFormat;
                                        }
                                    }

                                    const columnStyleObject = {
                                        textAlign: column.cellsAlign || 'left',
                                        format: cellsFormat
                                    };

                                    columns[column.dataField] = columnStyleObject;
                                }
                            }
                        }
                    }
                }
                var viewRows = dataRows || this.getrows();
                var data = [];

                for (var i = 0; i < viewRows.length; i++) {
                    var row = viewRows[i];

                    if (row.hidden) {
                        continue;
                    }

                    var rowObject = {};

                    for (var j = 0; j < that.columns.records.length; j++) {
                        var column = that.columns.records[j];

                        if (!column.exportable) {
                            continue;
                        }

                        rowObject[column.datafield] = row[column.datafield];
                    }

                    data.push(rowObject);
                }

                if (!dataExport.groupBy && that.groups && that.groups.length) {
                    dataExporter.groupBy = that.groups.slice(0);
                }


                if (settings && settings.formatData) {
                    const formatDataCallback = (formattedData) => {
                        dataExporter.exportData(formattedData, dataFormat, dataExport.fileName, null);
                    }
                    settings.formatData([...data], cols, data, formatDataCallback);
                }
                else {
                    var output = dataExporter.exportData(data, dataFormat, dataExport.fileName, null);
                }

                return output;
            },

            exportview: function (datatype, filename, rows, settings) {
                var that = this;

                that._exportData(datatype, filename, rows, settings);
            },

            exportdata: function (datatype, filename, exportHeader, rows, exportHiddenColumns, exportServer, charset) {
                if (!$.jqx.dataAdapter.ArrayExporter) {
                    throw 'jqxGrid: Missing reference to jqxdata.export.js!';
                }

                if (datatype === 'xlsx') {
                    this._exportData('xlsx', filename);
                    return;
                }

                if (exportHeader == undefined) {
                    exportHeader = true;
                }

                var me = this;

                if (rows == undefined) {
                    var rows = this.getrows();
                    if (rows.length == 0) {
                        throw 'No data to export.';
                    }
                }

                this.exporting = true;
                if (!this.pageable) {
                    this.loadondemand = true;
                }

                if (this.altrows) {
                    this._renderrows(this.virtualsizeinfo);
                }

                var hValue = this.hScrollInstance.value;

                this.hScrollInstance.setPosition(0);
                this._renderrows(this.virtualsizeinfo);

                var addhiddencolumns = exportHiddenColumns != undefined ? exportHiddenColumns : false;
                var dataFields = {};
                var styles = {};
                var alignments = [];
                var $cell = this.host.find('.jqx-grid-cell:first');
                var $cellalt = this.host.find('.jqx-grid-cell-alt:first');
                $cell.removeClass(this.toThemeProperty('jqx-grid-cell-selected'));
                $cell.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                $cellalt.removeClass(this.toThemeProperty('jqx-grid-cell-selected'));
                $cellalt.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                $cell.removeClass(this.toThemeProperty('jqx-grid-cell-hover'));
                $cell.removeClass(this.toThemeProperty('jqx-fill-state-hover'));
                $cellalt.removeClass(this.toThemeProperty('jqx-grid-cell-hover'));
                $cellalt.removeClass(this.toThemeProperty('jqx-fill-state-hover'));

                var styleName = 'cell';
                var styleIndex = 1;
                var columnStyleName = 'column';
                var columnStyleIndex = 1;
                var aggregates = [];

                for (var j = 0; j < this.columns.records.length; j++) {
                    var column = this.columns.records[j];
                    if (column.cellclassname != "") {
                        column.customCellStyles = new Array();
                        if (typeof column.cellclassname == "string") {
                            for (var i = 0; i < rows.length; i++) {
                                column.customCellStyles[i] = column.cellclassname;
                            }
                        }
                        else {
                            for (var i = 0; i < rows.length; i++) {
                                var boundIndex = this.getrowboundindex(i);
                                var className = column.cellclassname(boundIndex, column.displayfield, rows[i][column.displayfield], rows[i]);
                                if (className) {
                                    column.customCellStyles[i] = className;
                                }
                            }
                        }
                    }
                }

                var fields = new Array();
                var firstColumn = null;
                var firstCell = null;
                var firstAltCell = null;
                $.each(this.columns.records, function (index) {
                    var $cell = $(me.table[0].rows[0].cells[index]);
                    if (me.table[0].rows.length > 1) {
                        var $cellalt = $(me.table[0].rows[1].cells[index]);
                        if (!firstAltCell)
                            firstAltCell = $cellalt;
                    }
                    if (!firstCell) firstCell = $cell;

                    var column = this;
                    var removeClassFunc = function (cell) {
                        cell.removeClass(me.toThemeProperty('jqx-grid-cell-selected'));
                        cell.removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                        cell.removeClass(me.toThemeProperty('jqx-grid-cell-hover'));
                        cell.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                        if (column.customCellStyles) {
                            for (var o in column.customCellStyles) {
                                cell.removeClass(column.customCellStyles[o]);
                            }
                        }
                    }
                    removeClassFunc($cell);
                    if ($cellalt) {
                        removeClassFunc($cellalt);
                    }

                    if (this.displayfield == null) return true;

                    if (me.showaggregates) {
                        if (me.getcolumnaggregateddata) {
                            aggregates.push(me.getcolumnaggregateddata(this.displayfield, this.aggregates, true, rows));
                        }
                    }

                    var type = me._getexportcolumntype(this);
                    if (this.exportable && (!this.hidden || addhiddencolumns)) {
                        dataFields[this.displayfield] = {};
                        dataFields[this.displayfield].text = this.text;
                        dataFields[this.displayfield].width = parseInt(this.width);
                        if (isNaN(dataFields[this.displayfield].width)) dataFields[this.displayfield].width = 60;
                        dataFields[this.displayfield].formatString = this.cellsformat;
                        dataFields[this.displayfield].localization = me.gridlocalization;
                        dataFields[this.displayfield].type = type;
                        dataFields[this.displayfield].cellsAlign = this.cellsalign;
                        dataFields[this.displayfield].hidden = !exportHeader;
                        dataFields[this.displayfield].displayfield = this.displayfield;
                        fields.push(dataFields[this.displayfield]);
                    }

                    styleName = 'cell' + styleIndex;

                    var $element = $(this.element);
                    if (this.element == undefined) $element = $(this.uielement);
                    if (!firstColumn) {
                        firstColumn = $element;
                    }
                    else if (!column._rendered) {
                        $element = firstColumn;
                        $cell = firstCell;
                        $cellalt = firstAltCell;
                        var cellclass = me.toTP('jqx-grid-cell') + ' ' + me.toTP('jqx-item');
                        $cell[0].className = cellclass;
                        cellclass += me.toTP('jqx-grid-cell-alt');
                        if ($cellalt) {
                            $cellalt[0].className = cellclass;
                        }
                    }

                    columnStyleName = 'column' + columnStyleIndex;
                    if (datatype == 'html' || datatype == 'xls' || datatype == 'pdf') {
                        var buildStyle = function (styleName, $element, isColumn, altStyle, meColumn, me, index, customStyle, rowIndex) {
                            styles[styleName] = {};
                            if ($element == undefined)
                                return;

                            if ($element[0].offsetWidth == 0 || $element[0].offsetHeight == 0) {
                                if (!isColumn) {
                                    styles[styleName]['dataType'] = type;
                                }
                                return;
                            }

                            styles[styleName]['font-size'] = $element.css('font-size');
                            styles[styleName]['font-weight'] = $element.css('font-weight');
                            styles[styleName]['font-style'] = $element.css('font-style');
                            styles[styleName]['background-color'] = me._getexportcolor($element.css('background-color'));
                            styles[styleName]['color'] = me._getexportcolor($element.css('color'));
                            styles[styleName]['border-color'] = me._getexportcolor($element.css('border-top-color'));
                            if (isColumn) {
                                styles[styleName]['text-align'] = meColumn.align;
                            }
                            else {
                                styles[styleName]['text-align'] = meColumn.cellsalign;
                                styles[styleName]['formatString'] = meColumn.cellsformat;
                                styles[styleName]['dataType'] = type;
                            }

                            if (datatype == 'html' || datatype == 'pdf') {
                                styles[styleName]['border-top-width'] = $element.css('border-top-width');
                                styles[styleName]['border-left-width'] = $element.css('border-left-width');
                                styles[styleName]['border-right-width'] = $element.css('border-right-width');
                                styles[styleName]['border-bottom-width'] = $element.css('border-bottom-width');
                                styles[styleName]['border-top-style'] = $element.css('border-top-style');
                                styles[styleName]['border-left-style'] = $element.css('border-left-style');
                                styles[styleName]['border-right-style'] = $element.css('border-right-style');
                                styles[styleName]['border-bottom-style'] = $element.css('border-bottom-style');
                                if (isColumn) {
                                    if (index == 0) {
                                        styles[styleName]['border-left-width'] = $element.css('border-right-width');
                                    }
                                    styles[styleName]['border-top-width'] = $element.css('border-right-width');
                                    styles[styleName]['border-bottom-width'] = $element.css('border-bottom-width');
                                }
                                else {
                                    if (index == 0) {
                                        styles[styleName]['border-left-width'] = $element.css('border-right-width');
                                    }
                                }
                                styles[styleName]['height'] = $element.css('height');
                            }

                            if (meColumn.exportable && (!meColumn.hidden || addhiddencolumns)) {
                                if (customStyle == true) {
                                    if (!dataFields[meColumn.displayfield].customCellStyles) {
                                        dataFields[meColumn.displayfield].customCellStyles = new Array();
                                    }

                                    dataFields[meColumn.displayfield].customCellStyles[rowIndex] = styleName;
                                }
                                else {
                                    if (isColumn) {
                                        dataFields[meColumn.displayfield].style = styleName;
                                    }
                                    else if (!altStyle) {
                                        dataFields[meColumn.displayfield].cellStyle = styleName;
                                    }
                                    else dataFields[meColumn.displayfield].cellAltStyle = styleName;
                                }
                            }
                        }
                        buildStyle(columnStyleName, $element, true, false, this, me, index);
                        columnStyleIndex++;
                        buildStyle(styleName, $cell, false, false, this, me, index);
                        if (me.altrows) {
                            styleName = 'cellalt' + styleIndex;
                            buildStyle(styleName, $cellalt, false, true, this, me, index);
                        }
                        if (this.customCellStyles) {
                            for (var o in column.customCellStyles) {
                                $cell.removeClass(column.customCellStyles[o]);
                            }
                            for (var o in column.customCellStyles) {
                                $cell.addClass(column.customCellStyles[o]);
                                buildStyle(styleName + column.customCellStyles[o], $cell, false, false, this, me, index, true, o);
                                $cell.removeClass(column.customCellStyles[o]);
                            }
                        }

                        styleIndex++;
                    }
                });
                $.each(this.columns.records, function (index) {
                    if (dataFields[this.displayfield]) {
                        dataFields[this.displayfield].columnsDataFields = fields;
                    }
                });

                if (this.showaggregates) {
                    var aggregatedrows = [];
                    var prefix = datatype == 'xls' ? "_AG" : "";
                    var offset = this.groupable ? this.groups.length : 0;
                    if (this.rowdetails) offset++;
                    if (this.selectionmode === "checkbox") offset++;
                    if (aggregates.length > 0) {
                        $.each(this.columns.records, function (index) {
                            if (this.aggregates) {
                                for (var i = 0; i < this.aggregates.length; i++) {
                                    if (!aggregatedrows[i]) aggregatedrows[i] = {};
                                    if (aggregatedrows[i]) {
                                        var aggregatename = me._getaggregatename(this.aggregates[i]);
                                        var aggregatetype = me._getaggregatetype(this.aggregates[i]);
                                        var aggregate = aggregates[index - offset];
                                        if (aggregate) {
                                            aggregatedrows[i][this.displayfield] = prefix + aggregatename + ": " + aggregate[aggregatetype];
                                        }
                                    }
                                }
                            }
                        });
                        $.each(this.columns.records, function (index) {
                            for (var i = 0; i < aggregatedrows.length; i++) {
                                if (aggregatedrows[i][this.displayfield] == undefined) {
                                    aggregatedrows[i][this.displayfield] = prefix;
                                }
                            }
                        });
                    }
                    $.each(aggregatedrows, function () {
                        rows.push(this);
                    });
                }

                var that = this;
                var exporter = $.jqx.dataAdapter.ArrayExporter(rows, dataFields, styles);
                if (filename == undefined) {
                    // update ui
                    this._renderrows(this.virtualsizeinfo);
                    var result = exporter.exportTo(datatype);
                    if (this.showaggregates) {
                        $.each(aggregatedrows, function () {
                            rows.pop(this);
                        });
                    }

                    setTimeout(function () {
                        that.exporting = false;
                    }, 50);
                    this.hScrollInstance.setPosition(hValue);
                    this._renderrows(this.virtualsizeinfo);
                    return result;
                }
                else {
                    exporter.exportToFile(datatype, filename, exportServer, charset);
                }
                // update ui
                if (this.showaggregates) {
                    $.each(aggregatedrows, function () {
                        rows.pop(this);
                    });
                }
                this._renderrows(this.virtualsizeinfo);
                setTimeout(function () {
                    that.exporting = false;
                }, 50);
                this.hScrollInstance.setPosition(hValue);
                this._renderrows(this.virtualsizeinfo);

            },

            _getexportcolor: function (value) {
                var color = value;
                if (value == 'transparent') color = "#FFFFFF";
                if (!color || !color.toString()) {
                    color = "#FFFFFF";
                }

                if (color.toString().indexOf('rgb') != -1) {
                    var rgb = color.split(',');
                    if (color.toString().indexOf('rgba') != -1) {
                        var r = parseInt(rgb[0].substring(5));
                        var g = parseInt(rgb[1]);
                        var b = parseInt(rgb[2]);
                        var a = parseFloat(rgb[3].substring(1, 4));
                        var rgbObj = { r: r, g: g, b: b };
                        var hex = this._rgbToHex(rgbObj);
                        if (r == 0 && g == 0 && b == 0 && a == 0) {
                            return "#ffffff";
                        }

                        return "#" + hex;
                    }

                    var r = parseInt(rgb[0].substring(4));
                    var g = parseInt(rgb[1]);
                    var b = parseInt(rgb[2].substring(1, 4));
                    var rgbObj = { r: r, g: g, b: b };
                    var hex = this._rgbToHex(rgbObj);
                    return "#" + hex;
                }
                else if (color.toString().indexOf('#') != -1) {
                    if (color.toString().length == 4) {
                        var colorPart = color.toString().substring(1, 4);
                        color += colorPart;
                    }
                }

                return color;
            },

            _rgbToHex: function (rgb) {
                return this._intToHex(rgb.r) + this._intToHex(rgb.g) + this._intToHex(rgb.b);
            },

            _intToHex: function (dec) {
                var result = (parseInt(dec).toString(16));
                if (result.length == 1)
                    result = ("0" + result);
                return result.toUpperCase();
            },

            _getexportcolumntype: function (column) {
                var me = this;
                var type = 'string';
                var datafields = me.source.datafields || ((me.source._source) ? me.source._source.datafields : null);

                if (datafields) {
                    var foundType = "";
                    $.each(datafields, function () {
                        if (this.name == column.displayfield) {
                            if (this.type) {
                                foundType = this.type;
                            }
                            return false;
                        }
                    });
                    if (foundType)
                        return foundType;
                }

                if (column != null) {
                    if (this.dataview.cachedrecords == undefined) {
                        return type;
                    }

                    var cell = null;

                    if (!this.virtualmode) {
                        if (this.dataview.cachedrecords.length == 0)
                            return type;

                        cell = this.dataview.cachedrecords[0][column.displayfield];
                        if (cell != null && cell.toString() == "") {
                            return "string";
                        }
                    }
                    else {
                        $.each(this.dataview.cachedrecords, function () {
                            cell = this[column.displayfield];
                            return false;
                        });
                    }

                    if (cell != null) {
                        if (column.cellsformat.indexOf('c') != -1) {
                            return 'number';
                        }
                        if (column.cellsformat.indexOf('n') != -1) {
                            return 'number';
                        }
                        if (column.cellsformat.indexOf('p') != -1) {
                            return 'number';
                        }
                        if (column.cellsformat.indexOf('d') != -1) {
                            return 'date';
                        }
                        if (column.cellsformat.indexOf('y') != -1) {
                            return 'date';
                        }
                        if (column.cellsformat.indexOf('M') != -1) {
                            return 'date';
                        }
                        if (column.cellsformat.indexOf('m') != -1) {
                            return 'date';
                        }
                        if (column.cellsformat.indexOf('t') != -1) {
                            return 'date';
                        }

                        if (typeof cell == 'boolean') {
                            type = 'boolean';
                        }
                        else if ($.jqx.dataFormat.isNumber(cell)) {
                            type = 'number';
                        }
                        else {
                            var tmpvalue = new Date(cell);
                            if (tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date") {
                                if ($.jqx.dataFormat) {
                                    tmpvalue = $.jqx.dataFormat.tryparsedate(cell);
                                    if (tmpvalue != null) {
                                        if (tmpvalue && tmpvalue.getFullYear()) {
                                            if (tmpvalue.getFullYear() == 1970 && tmpvalue.getMonth() == 0 && tmpvalue.getDate() == 1) {
                                                var num = new Number(cell);
                                                if (!isNaN(num))
                                                    return 'number';

                                                return 'string';
                                            }
                                        }

                                        return 'date';
                                    }
                                    else {
                                        type = 'string';
                                    }
                                }
                                else type = 'string';
                            }
                            else {
                                type = 'date';
                            }
                        }
                    }
                }
                return type;
            }

        });
    })(jqxBaseFramework);
})();





/***/ }),

/***/ 8690:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {

        $.extend($.jqx._jqxGrid.prototype, {
            _updatefilterrowui: function (forceupdateui) {
                var columnslength = this.columns.records.length;
                var left = 0;
                var me = this;
                if (!this.filterrow)
                    return;

                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = this.columns.records[j];
                    var width = parseInt(columnrecord.width);
                    if (width < columnrecord.minwidth) width = columnrecord.minwidth;
                    if (width > columnrecord.maxwidth) width = columnrecord.maxwidth;
                    var tablecolumn = $(this.filterrow[0].cells[j]);
                    tablecolumn.css('left', left);
                    var updateui = true;
                    if (tablecolumn.width() == width) {
                        updateui = false;
                    }
                    if (forceupdateui) {
                        updateui = true;
                    }
                    tablecolumn.width(width);
                    if (!tablecolumn[0]) {
                        continue;
                    }

                    tablecolumn[0].left = left;

                    if (columnrecord.element) {
                        tablecolumn[0].style.width = columnrecord.element.style.width;
                        tablecolumn[0].style.left = columnrecord.element.style.left;
                    }

                    if (!(columnrecord.hidden && columnrecord.hideable)) {
                        left += width;
                    }
                    else {
                        tablecolumn.css('display', 'none');
                    }
                    if (!updateui)
                        continue;

                    if (columnrecord.createfilterwidget && columnrecord.filtertype == 'custom') {
                        columnrecord.createfilterwidget(columnrecord, tablecolumn);
                    }
                    else {
                        if (columnrecord.filterable) {
                            var addtextfilter = function (me, tablecolumn) {
                                var textbox = $(tablecolumn.children()[0]);

                                if (textbox[0]) {
                                    textbox[0].style.width = (width - 8) + 'px';
                                    if ($.jqx.browser.msie) {
                                        textbox[0].style.width = (width - 16) + 'px';
                                    }
                                }
                                textbox.attr('disabled', me.disabled);
                            }

                            switch (columnrecord.filtertype) {
                                case 'number':
                                case 'input':
                                    $(tablecolumn.children()[0]).width(width);
                                    tablecolumn.find('input')[0].style.width = (width - 30) + 'px';
                                    if ($.jqx.browser.msie) {
                                        tablecolumn.find('input')[0].style.width = (width - 36) + 'px';
                                    }
                                    tablecolumn.find('input').attr('disabled', me.disabled);
                                    $(tablecolumn.find('.jqx-dropdownlist-state-normal')).jqxDropDownList({ theme: me.theme, disabled: me.disabled });
                                    break;
                                case 'date':
                                case 'range':
                                    if (this.host.jqxDateTimeInput) {
                                        $(tablecolumn.children()[0]).jqxDateTimeInput({ theme: me.theme, disabled: me.disabled, width: width - 10 });
                                    }
                                    else addtextfilter(this, tablecolumn);
                                    break;
                                case 'textbox':
                                case 'default':
                                    addtextfilter(this, tablecolumn);
                                    break;
                                case 'list':
                                case 'checkedlist':
                                    if (this.host.jqxDropDownList) {
                                        $(tablecolumn.children()[0]).jqxDropDownList({ theme: me.theme, disabled: me.disabled, width: width - 10 });
                                    }
                                    else addtextfilter(this, tablecolumn);
                                    break;
                                case 'bool':
                                case 'boolean':
                                    if (!this.host.jqxCheckBox) {
                                        addtextfilter(this, tablecolumn);
                                    }
                                    else {
                                        $(tablecolumn.children()[0]).jqxCheckBox({ theme: me.theme, disabled: me.disabled });
                                    }
                                    break;
                            }
                        }
                    }
                }
                var tablerow = $(this.filterrow.children()[0]);
                tablerow.width(parseInt(left) + 2);
                tablerow.height(this.filterrowheight);
            },

            clearfilterrow: function (datafield) {
                this._disablefilterrow = true;
                if (!this.columns.records)
                    return;

                var columnslength = this.columns.records.length;
                var left = 0;
                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = this.columns.records[j];
                    var tablecolumn = $(this.filterrow[0].cells[j]);

                    if (typeof datafield == "string") {
                        if (columnrecord.displayfield != datafield) {
                            continue;
                        }
                    }

                    if (columnrecord.filterable) {
                        var addtextfilter = function (me, tablecolumn) {
                            var textbox = $(tablecolumn.children()[0]);
                            textbox.val("");
                            if (textbox[0]) {
                                me["_oldWriteText" + textbox[0].id] = "";
                            }
                        }

                        switch (columnrecord.filtertype) {
                            case 'number':
                            case 'input':
                                tablecolumn.find('input').val("");
                                if (this.host.jqxDropDownList) {
                                    var dropDownList = $($($(tablecolumn).children()[0]).children()[1]);
                                    dropDownList.jqxDropDownList('clearSelection');
                                    var selectedIndex = 0;
                                    if (selectedIndex == 0) {
                                        var source = this._getfiltersbytype(columnrecord.filtertype == 'number' ? 'number' : 'string');
                                        var filtergroup = new $.jqx.filter();
                                        var operators = filtergroup.getoperatorsbyfiltertype(columnrecord.filtertype == 'number' ? 'numberfilter' : 'stringfilter');

                                        if (columnrecord.filtercondition != null) {
                                            selectedIndex = operators.indexOf(columnrecord.filtercondition.toUpperCase());
                                            if (selectedIndex == -1) {
                                                selectedIndex = columnrecord.filtertype == 'number' ? 0 : 2;
                                            }
                                        }
                                        else {
                                            selectedIndex = columnrecord.filtertype == 'number' ? 0 : 2;
                                        }
                                    }
                                    dropDownList.jqxDropDownList({ selectedIndex: selectedIndex });
                                    dropDownList.jqxDropDownList('ensureVisible', selectedIndex);
                                }
                                break;
                            case 'date':
                            case 'range':
                                if (this.host.jqxDateTimeInput) {
                                    $(tablecolumn.children()[0]).jqxDateTimeInput('setDate', null);
                                }
                                else addtextfilter(this, tablecolumn);
                                break;
                            case 'textbox':
                            case 'default':
                                addtextfilter(this, tablecolumn);
                                break;
                            case 'list':
                                if (this.host.jqxDropDownList) {
                                    $(tablecolumn.children()[0]).jqxDropDownList('clearSelection');
                                }
                                else addtextfilter(this, tablecolumn);
                                break;
                            case 'checkedlist':
                                if (this.host.jqxDropDownList) {
                                    $(tablecolumn.children()[0]).jqxDropDownList('checkAll', false);
                                }
                                else addtextfilter(this, tablecolumn);
                                break;
                            case 'bool':
                            case 'boolean':
                                if (!this.host.jqxCheckBox) {
                                    addtextfilter(this, tablecolumn);
                                }
                                else $(tablecolumn.children()[0]).jqxCheckBox({ checked: null });
                                break;
                        }

                    }
                }
                this._disablefilterrow = false;
            },

            _applyfilterfromfilterrow: function () {
                if (this._disablefilterrow == true)
                    return;
                if (this.disabled) {
                    return;
                }

                var columnslength = this.columns.records.length;
                var me = this.that;

                for (var j = 0; j < columnslength; j++) {
                    var filtergroup = new $.jqx.filter();
                    var columnrecord = this.columns.records[j];
                    if (!columnrecord.filterable) continue;
                    if (columnrecord.datafield === null) continue;

                    var type = me._getcolumntypebydatafield(columnrecord);
                    var filtertype = me._getfiltertype(type);
                    var filter_or_operator = 1;
                    var hasFilter = true;
                    var columnrecordfiltertype = columnrecord.filtertype;
                    var addstringfilter = function (columnrecord, filtertype, filtergroup) {
                        var result = true;
                        if (columnrecord._filterwidget) {
                            var filtervalue = columnrecord._filterwidget.val();
                            if (filtervalue != "") {
                                var filtercondition = 'equal';
                                if (filtertype == 'stringfilter') {
                                    var filtercondition = 'contains';
                                }
                                if (filtertype == "numericfilter") {
                                    if (me.gridlocalization.decimalseparator == ',') {
                                        if (filtervalue.indexOf(me.gridlocalization.decimalseparator) >= 0) {
                                            filtervalue = filtervalue.replace(me.gridlocalization.decimalseparator, '.');
                                        }
                                    }
                                }

                                if (filtertype != 'stringfilter') {
                                    var hasoperator = 0;
                                    if (filtervalue.indexOf('>') != -1) {
                                        filtercondition = "greater_than";
                                        hasoperator = 1;
                                    }
                                    if (filtervalue.indexOf('<') != -1) {
                                        filtercondition = "less_than";
                                        hasoperator = 1;
                                    }
                                    if (filtervalue.indexOf('=') != -1) {
                                        if (filtercondition == "greater_than") {
                                            filtercondition = "greater_than_or_equal";
                                            hasoperator = 2;
                                        }
                                        else if (filtercondition == "less_than") {
                                            filtercondition = "less_than_or_equal";
                                            hasoperator = 2;
                                        }
                                        else {
                                            filtercondition = "equal";
                                            hasoperator = 1;
                                        }
                                    }
                                    if (hasoperator != 0) {
                                        filtervalue = filtervalue.substring(hasoperator);
                                        if (filtervalue.length < 1) return false;
                                    }
                                }

                                if (columnrecord.filtercondition != undefined) filtercondition = columnrecord.filtercondition;

                                if (filtertype == "datefilter") {
                                    var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition, null, columnrecord.cellsformat, me.gridlocalization);
                                }
                                else {
                                    var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition);
                                }

                                filtergroup.addfilter(filter_or_operator, filter);
                            }
                            else result = false;
                        }
                        return result;
                    }

                    switch (columnrecord.filtertype) {
                        case 'range':
                        case 'date':
                            if (columnrecord._filterwidget.jqxDateTimeInput) {
                                if (columnrecord.filtertype == "range") {
                                    var filtervalue = columnrecord._filterwidget.jqxDateTimeInput('getRange');
                                    if (filtervalue != null && filtervalue.from != null && filtervalue.to != null) {
                                        var filtercondition = 'GREATER_THAN_OR_EQUAL';
                                        var date1 = new Date(0);
                                        date1.setHours(0);
                                        date1.setMinutes(0);
                                        date1.setFullYear(filtervalue.from.getFullYear(), filtervalue.from.getMonth(), filtervalue.from.getDate());
                                        var date2 = new Date(0);
                                        date2.setHours(0);
                                        date2.setMinutes(0);
                                        date2.setFullYear(filtervalue.to.getFullYear(), filtervalue.to.getMonth(), filtervalue.to.getDate());
                                        date2.setHours(filtervalue.to.getHours());
                                        date2.setMinutes(filtervalue.to.getMinutes());
                                        date2.setSeconds(filtervalue.to.getSeconds());
                                        var filter1 = filtergroup.createfilter(filtertype, date1, filtercondition);
                                        filtergroup.addfilter(0, filter1);

                                        var filtercondition2 = 'LESS_THAN_OR_EQUAL';
                                        var filter2 = filtergroup.createfilter(filtertype, date2, filtercondition2);
                                        filtergroup.addfilter(0, filter2);
                                    }
                                    else hasFilter = false;
                                }
                                else {
                                    var filtervalue = columnrecord._filterwidget.jqxDateTimeInput('getDate');
                                    if (filtervalue != null) {
                                        var date1 = new Date(0);
                                        date1.setHours(0);
                                        date1.setMinutes(0);
                                        date1.setFullYear(filtervalue.getFullYear(), filtervalue.getMonth(), filtervalue.getDate());
                                        if (columnrecord._filterwidget.jqxDateTimeInput('showTimeButton')) {
                                            date1.setHours(filtervalue.getHours());
                                            date1.setMinutes(filtervalue.getMinutes());
                                        }

                                        var filtercondition = "EQUAL";
                                        if (columnrecord.filtercondition != undefined) {
                                            filtercondition = columnrecord.filtercondition;
                                        }

                                        var filter1 = filtergroup.createfilter(filtertype, date1, filtercondition);

                                        var showTimeButton = columnrecord._filterwidget.jqxDateTimeInput('showTimeButton');

                                        if (showTimeButton) {
                                            filter1 = filtergroup.createfilter(filtertype, date1, filtercondition, null, columnrecord.cellsformat);
                                        }

                                        filtergroup.addfilter(0, filter1);
                                    }
                                    else hasFilter = false;
                                }
                            }
                            else {
                                hasFilter = addstringfilter(columnrecord, filtertype, filtergroup);
                            }
                            break;
                        case 'input':
                            if (columnrecord._filterwidget) {
                                var filtervalue = columnrecord._filterwidget.find('input').val();
                                var index = columnrecord._filterwidget.find('.filter').jqxDropDownList('selectedIndex');
                                if (index < 0) {
                                    index = 0;
                                }

                                var condition = filtergroup.getoperatorsbyfiltertype(filtertype)[index];
                                if (me.updatefilterconditions) {
                                    var newfilterconditions = me.updatefilterconditions(filtertype, filtergroup.getoperatorsbyfiltertype(filtertype));
                                    if (newfilterconditions != undefined) {
                                        filtergroup.setoperatorsbyfiltertype(filtertype, newfilterconditions);
                                    }
                                    var condition = filtergroup.getoperatorsbyfiltertype(filtertype)[index];
                                }
                                var nullcondition1 = condition == "NULL" || condition == "NOT_NULL";
                                var emptycondition1 = condition == "EMPTY" || condition == "NOT_EMPTY";
                                if (filtervalue != undefined && filtervalue.length > 0 || nullcondition1 || emptycondition1) {
                                    filter1 = filtergroup.createfilter(filtertype, filtervalue, condition, null, columnrecord.cellsformat, me.gridlocalization);
                                    filtergroup.addfilter(0, filter1);
                                }
                                else hasFilter = false;
                            }
                            else {
                                hasFilter = false;
                            }
                            break;
                        case 'number':
                            if (columnrecord._filterwidget) {
                                var filtervalue = columnrecord._filterwidget.find('input').val();
                                if (me.gridlocalization.decimalseparator == ',') {
                                    if (filtervalue.indexOf(me.gridlocalization.decimalseparator) >= 0) {
                                        filtervalue = filtervalue.replace(me.gridlocalization.decimalseparator, '.');
                                    }
                                }
                                var index = columnrecord._filterwidget.find('.filter').jqxDropDownList('selectedIndex');
                                var condition = filtergroup.getoperatorsbyfiltertype(filtertype)[index];
                                if (me.updatefilterconditions) {
                                    var newfilterconditions = me.updatefilterconditions(filtertype, filtergroup.getoperatorsbyfiltertype(filtertype));
                                    if (newfilterconditions != undefined) {
                                        filtergroup.setoperatorsbyfiltertype(filtertype, newfilterconditions);
                                    }
                                    var condition = filtergroup.getoperatorsbyfiltertype(filtertype)[index];
                                }
                                var nullcondition1 = condition == "NULL" || condition == "NOT_NULL";
                                var emptycondition1 = condition == "EMPTY" || condition == "NOT_EMPTY";
                                if (filtervalue != undefined && filtervalue.length > 0 || nullcondition1 || emptycondition1) {
                                    filter1 = filtergroup.createfilter(filtertype, new Number(filtervalue), condition, null, columnrecord.cellsformat, me.gridlocalization);
                                    filtergroup.addfilter(0, filter1);
                                }
                                else hasFilter = false;
                            }
                            else {
                                hasFilter = false;
                            }
                            break;
                        case 'textbox':
                        case 'default':
                            hasFilter = addstringfilter(columnrecord, filtertype, filtergroup);
                            break;
                        case 'bool':
                        case 'boolean':
                            if (columnrecord._filterwidget.jqxCheckBox) {
                                var filtervalue = columnrecord._filterwidget.jqxCheckBox('checked');
                                if (filtervalue != null) {
                                    var filtercondition = 'equal';
                                    var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition);
                                    filtergroup.addfilter(filter_or_operator, filter);
                                }
                                else hasFilter = false;
                            } else hasFilter = addstringfilter(columnrecord, filtertype, filtergroup);
                            break;
                        case 'list':
                            var widget = columnrecord._filterwidget.jqxDropDownList('listBox');
                            if (widget.selectedIndex >= 0) {
                                var selectedItem = widget.getSelectedItem();
                                var filtervalue = selectedItem.label;
                                var filterdatavalue = selectedItem.value;
                                var filtercondition = 'equal';
                                if (filtervalue === "") {
                                    filtercondition = 'NULL';
                                }


                                var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition);
                                filtergroup.addfilter(filter_or_operator, filter);
                                if (filterdatavalue !== filtervalue) {
                                    filter.data = filterdatavalue;
                                }
                            } else {
                                hasFilter = false;
                            }
                            break;
                        case 'checkedlist':
                            if (columnrecord._filterwidget.jqxDropDownList) {
                                var widget = columnrecord._filterwidget.jqxDropDownList('listBox');
                                var checkedItems = widget.getCheckedItems();
                                if (checkedItems.length == 0) {
                                    for (var i = 1; i < widget.items.length; i++) {
                                        var filtervalue = widget.items[i].label;
                                        var filterdatavalue = widget.items[i].value;
                                        var filtercondition = 'not_equal';
                                        if (filtervalue === "") {
                                            filtercondition = 'NOT_NULL';
                                        }
                                        var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition);
                                        if (filterdatavalue !== filtervalue) {
                                            filter.data = filterdatavalue;
                                        }
                                        filtergroup.addfilter(0, filter);
                                    }

                                    hasFilter = true;
                                }
                                else {
                                    if (checkedItems.length != widget.items.length) {
                                        for (var i = 0; i < checkedItems.length; i++) {
                                            var filtervalue = checkedItems[i].label;
                                            var filterdatavalue = checkedItems[i].value;
                                            var filtercondition = 'equal';
                                            if (filtervalue === "") {
                                                filtercondition = 'NULL';
                                            }
                                            var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition);
                                            if (filterdatavalue !== filtervalue) {
                                                filter.data = filterdatavalue;
                                            }
                                            filtergroup.addfilter(filter_or_operator, filter);
                                        }
                                    }
                                    else hasFilter = false;
                                }
                            }
                            else hasFilter = addstringfilter(columnrecord, filtertype, filtergroup);
                            break;
                    }

                    if (!this._loading) {
                        if (hasFilter) {
                            this.addfilter(columnrecord.displayfield, filtergroup, false);
                        }
                        else {
                            this.removefilter(columnrecord.displayfield, false);
                        }
                    }
                }
                if (!this._loading) {
                    this.applyfilters('filterrow');
                }
            },

            _updatefilterrow: function () {
                var tablerow = $('<div style="position: relative;" id="row00' + this.element.id + '"></div>');
                var left = 0;
                var columnslength = this.columns.records.length;
                var cellclass = this.toThemeProperty('jqx-grid-cell');
                cellclass += ' ' + this.toThemeProperty('jqx-grid-cell-pinned');
                cellclass += ' ' + this.toThemeProperty('jqx-grid-cell-filter-row');
                var zindex = columnslength + 10;
                var cells = new Array();
                var me = this.that;
                this.filterrow[0].cells = cells;
                tablerow.height(this.filterrowheight);
                this.filterrow.children().detach();
                this.filterrow.append(tablerow);
                if (!this._filterrowcache)
                    this._filterrowcache = new Array();

                this._initcolumntypes();

                var usefromcache = false;
                var _newfilterrowcache = new Array();
                var frag = document.createDocumentFragment();

                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = this.columns.records[j];
                    var width = columnrecord.width;
                    if (width < columnrecord.minwidth) width = columnrecord.minwidth;
                    if (width > columnrecord.maxwidth) width = columnrecord.maxwidth;
                    var tablecolumn = document.createElement('div');
                    tablecolumn.style.overflow = "hidden";
                    tablecolumn.style.position = "absolute";
                    tablecolumn.style.height = "100%";
                    tablecolumn.className = cellclass;
                    tablecolumn = $(tablecolumn);
                    frag.appendChild(tablecolumn[0]);
                    tablecolumn[0].style.left = left + "px";
                    if (this.rtl) {
                        tablecolumn.css('z-index', zindex++);
                        tablecolumn.css('border-left-width', '1px');
                    }
                    else {
                        tablecolumn.css('z-index', zindex--);
                    }
                    if (width == "auto") width = 0;
                    tablecolumn[0].style.width = parseFloat(width) + 'px';
                    tablecolumn[0].left = left;
                    if (!(columnrecord.hidden && columnrecord.hideable)) {
                        left += width;
                    }
                    else {
                        tablecolumn.css('display', 'none');
                    }
                    cells[cells.length] = tablecolumn[0];

                    var addFilterWidget = true;
                    if (!this.rtl) {
                        if (this.groupable) {
                            var detailsoffset = (this.showrowdetailscolumn && this.rowdetails) ? 1 : 0;
                            if (this.groups.length + detailsoffset > j) {
                                addFilterWidget = false;
                            }
                        }
                        if (this.showrowdetailscolumn && this.rowdetails && j == 0) addFilterWidget = false;
                    }
                    else {
                        if (this.groupable) {
                            var detailsoffset = (this.showrowdetailscolumn && this.rowdetails) ? 1 : 0;
                            if (this.groups.length + detailsoffset + j > columnslength - 1) {
                                addFilterWidget = false;
                            }
                        }
                        if (this.showrowdetailscolumn && this.rowdetails && j == columnslength - 1) addFilterWidget = false;
                    }

                    if (addFilterWidget) {
                        if (columnrecord.filtertype == 'custom' && columnrecord.createfilterwidget) {
                            var applyfilter = function () {
                                me._applyfilterfromfilterrow();
                            }
                            columnrecord.createfilterwidget(columnrecord, tablecolumn, applyfilter);
                        }
                        else {
                            if (columnrecord.filterable) {
                                if (this._filterrowcache[columnrecord.datafield]) {
                                    usefromcache = true;
                                    tablecolumn.append(this._filterrowcache[columnrecord.datafield]);
                                    columnrecord._filterwidget = this._filterrowcache[columnrecord.datafield];
                                }
                                else {
                                    this._addfilterwidget(columnrecord, tablecolumn, width);
                                    _newfilterrowcache[columnrecord.datafield] = columnrecord._filterwidget;
                                }
                            }
                        }
                    }
                }
                tablerow[0].appendChild(frag);
                this._filterrowcache = _newfilterrowcache;
                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                    tablerow.css('z-index', zindex--);
                }

                tablerow.width(parseFloat(left) + 2);
                this.filterrow.addClass(cellclass);
                this.filterrow.css('border-top-width', '1px');
                this.filterrow.css('border-right-width', '0px');
                if (usefromcache) {
                    this._updatefilterrowui(true);
                }
            },

            _getfilterdataadapter: function (columnrecord) {
                var isdataadapter = this.source._source ? true : false;

                if (!isdataadapter) {
                    var dataadapter = new $.jqx.dataAdapter(this.source,
                        {
                            autoBind: false,
                            uniqueDataFields: [columnrecord.displayfield],
                            autoSort: true,
                            autoSortField: columnrecord.displayfield,
                            async: false
                        });
                }
                else {
                    var dataSource =
                    {
                        localdata: $.extend(true, {}, this.source.records),
                        datatype: this.source.datatype,
                        async: false
                    }
                    var that = this;
                    var dataadapter = new $.jqx.dataAdapter(dataSource,
                        {
                            autoBind: false,
                            autoSort: true,
                            autoSortField: columnrecord.displayfield,
                            async: false,
                            uniqueDataFields: [columnrecord.displayfield],
                            beforeLoadComplete: function (records) {
                                var data = new Array();
                                if (columnrecord.cellsformat) {
                                    var columntype = that._getcolumntypebydatafield(columnrecord);

                                    for (var i = 0; i < records.length; i++) {
                                        data.push(records[i]);
                                        var value = records[i][columnrecord.displayfield];
                                        records[i][columnrecord.displayfield + "JQValue"] = value;
                                        if (columntype === "date") {
                                            if (value != null) {
                                                records[i][columnrecord.displayfield] = dataadapter.formatDate(value, columnrecord.cellsformat, that.gridlocalization);
                                            }
                                            else {
                                                records[i][columnrecord.displayfield] = "";
                                            }
                                        }
                                        else if (columntype === "number" || columntype === "float" || columntype === "int") {
                                            if (value != null) {
                                                records[i][columnrecord.displayfield] = dataadapter.formatNumber(value, columnrecord.cellsformat, that.gridlocalization);
                                            }
                                            else {
                                                records[i][columnrecord.displayfield] = "";
                                            }
                                        }
                                    }
                                    return data;
                                }
                                else return records;
                            }
                        });
                }
                if (columnrecord.filteritems && columnrecord.filteritems.length > 0) {
                    var dataSource =
                    {
                        localdata: columnrecord.filteritems,
                        datatype: this.source.datatype,
                        async: false
                    }

                    var dataadapter = new $.jqx.dataAdapter(dataSource,
                        {
                            autoBind: false,
                            async: false
                        });
                }
                else if (columnrecord.filteritems) {
                    if (columnrecord.filteritems._source) {
                        columnrecord.filteritems._options.autoBind = false;
                        columnrecord.filteritems._options.async = false;

                        return columnrecord.filteritems;
                    }
                    else if ($.isFunction(columnrecord.filteritems)) {
                        return columnrecord.filteritems();
                    }
                }

                return dataadapter;
            },

            refreshfilterrow: function () {
                if (!this.showfilterrow) {
                    return;
                }

                this.refreshingfilter = true;
                this._updatefilterrowui();
                this._updatelistfilters(true, true);
                var me = this.that;
                var columnslength = this.columns.records.length;
                for (var j = 0; j < columnslength; j++) {
                    var column = this.columns.records[j];
                    if (column.filterable) {
                        if (column.filter) {
                            var filters = column.filter.getfilters();
                            if (filters.length > 0) {
                                var value = filters[0].value;
                                var widget = column._filterwidget;
                                var tablecolumn = column._filterwidget.parent();
                                if (widget != null) {
                                    switch (column.filtertype) {
                                        case 'number':
                                            tablecolumn.find('input').val(value);
                                            if (this.host.jqxDropDownList) {
                                                var conditions = column.filter.getoperatorsbyfiltertype('numericfilter');
                                                widget.find('.filter').jqxDropDownList('selectIndex', conditions.indexOf(filters[0].condition));
                                            }
                                            break;
                                        case 'input':
                                            tablecolumn.find('input').val(value);
                                            if (this.host.jqxDropDownList) {
                                                var conditions = column.filter.getoperatorsbyfiltertype('stringfilter');
                                                widget.find('.filter').jqxDropDownList('selectIndex', conditions.indexOf(filters[0].condition));
                                            }
                                            break;
                                        case 'date':
                                        case 'range':
                                            if (this.host.jqxDateTimeInput) {
                                                var value = column.filter.getfilterat(0).filtervalue;
                                                if (value != undefined) {
                                                    if (column.filter.getfilterat(1)) {
                                                        var value2 = column.filter.getfilterat(1).filtervalue;
                                                    }
                                                    else {
                                                        value2 = value;
                                                    }
                                                    if (column.filtertype == "range") {
                                                        $(tablecolumn.children()[0]).jqxDateTimeInput('setRange', new Date(value), new Date(value2));
                                                    }
                                                    else {
                                                        $(tablecolumn.children()[0]).jqxDateTimeInput('setDate', new Date(value));
                                                    }
                                                }
                                            }
                                            else {
                                                widget.val(value);
                                            }
                                            break;
                                        case 'textbox':
                                        case 'default':
                                            widget.val(value);
                                            me["_oldWriteText" + widget[0].id] = value;
                                            break;
                                        case 'bool':
                                        case 'boolean':
                                            if (!this.host.jqxCheckBox) {
                                                widget.val(value);
                                            }
                                            else $(tablecolumn.children()[0]).jqxCheckBox({ checked: value });
                                            break;
                                    }
                                }
                            }
                        }
                    }
                }
                this.refreshingfilter = false;
            },

            _destroyedfilters: function () {
                var me = this.that;
                var columnslength = this.columns.records.length;
                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = this.columns.records[j];
                    if (columnrecord.filterable) {
                        var widget = columnrecord._filterwidget;
                        if (columnrecord.filtertype == 'list' || columnrecord.filtertype == 'checkedlist') {
                            this.removeHandler(widget, 'select');
                            this.removeHandler(widget, 'close');
                            widget.jqxDropDownList('destroy');
                        }
                        else if (columnrecord.filtertype == 'date' || columnrecord.filtertype == 'range') {
                            this.removeHandler(widget, 'valueChanged');
                            widget.jqxDateTimeInput('destroy');
                        }
                        else if (columnrecord.filtertype == 'bool') {
                            this.removeHandler(widget, 'change');
                            widget.jqxCheckBox('destroy');
                        }
                        else if (columnrecord.filtertype == 'number' || columnrecord.filtertype === 'input') {
                            var input = widget.find('.jqx-input');
                            this.removeHandler(input, 'keydown');
                            var dropdownlist = $(widget.children()[1]);
                            dropdownlist.jqxDropDownList('destroy');
                        }
                        else {
                            this.removeHandler(widget, 'keydown');
                        }
                        widget.remove();
                    }
                }
            },

            _updatelistfilters: function (endcelledit, updatecheckstates) {
                var me = this.that;
                var columnslength = this.columns.records.length;
                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = this.columns.records[j];
                    if (columnrecord.filterable) {
                        if (columnrecord.filtertype == 'list' || columnrecord.filtertype == 'checkedlist') {
                            var dropdownlist = columnrecord._filterwidget;
                            if (!endcelledit) {
                                if (columnrecord.filter == undefined) {
                                    dropdownlist.jqxDropDownList('renderSelection');
                                    continue;
                                }
                            }
                            else {
                                var dataadapter = this._getfilterdataadapter(columnrecord);
                                dropdownlist.jqxDropDownList({ source: dataadapter });
                                var dropdownitems = dropdownlist.jqxDropDownList('getItems');
                                var equalSources = true;
                                if (dropdownitems.length != dataadapter.records.length + 1)
                                    equalSources = false;

                                if (equalSources) {
                                    for (var i = 1; i < dropdownitems.length; i++) {
                                        if (dropdownitems[i].label != dataadapter.records[i - 1][columnrecord.displayfield]) {
                                            equalSources = false;
                                            break;
                                        }
                                    }
                                }
                                if (equalSources && !updatecheckstates)
                                    continue;
                            }

                            var checkboxes = columnrecord.filtertype == 'checkedlist' ? true : false;
                            var dropdownitems = dropdownlist.jqxDropDownList('getItems');
                            var listbox = dropdownlist.jqxDropDownList('listBox');
                            dropdownlist.jqxDropDownList('dataBind');

                            if (checkboxes) {
                                dropdownlist.jqxDropDownList({
                                    selectionRenderer: function () {
                                        return me.gridlocalization.filterselectstring;
                                    }
                                });
                                if (listbox.getItem(this.gridlocalization.filterselectallstring) == null) {
                                    listbox.insertAt({ label: this.gridlocalization.filterselectallstring }, 0);
                                }

                                var spanElement = $('<span style="top: 2px; position: relative; color: inherit; border: none; background-color: transparent;">' + this.gridlocalization.filterselectstring + '</span>');
                                spanElement.addClass(this.toThemeProperty('jqx-item'));
                                dropdownlist.jqxDropDownList('setContent', spanElement);
                                listbox.checkAll(false);
                                if (columnrecord.filter) {
                                    var filters = columnrecord.filter.getfilters();

                                    for (var i = 0; i < listbox.items.length; i++) {
                                        var label = listbox.items[i].label;
                                        var filterresult = undefined;
                                        $.each(filters, function () {
                                            var result;
                                            if (this.condition == "NOT_EQUAL") {
                                                if (label == this.value) {
                                                    result = false;
                                                }
                                                else {
                                                    result = true;
                                                }
                                            }
                                            else if (this.condition == "EQUAL") {
                                                if (label == this.value) {
                                                    result = true;
                                                }
                                                else {
                                                    result = false;
                                                }
                                            }
                                            if (filterresult == undefined && result !== undefined) filterresult = result;
                                            else {
                                                if (this.condition == "EQUAL") {
                                                    filterresult = filterresult || result;
                                                }
                                                else {
                                                    filterresult = filterresult && result;
                                                }
                                            }
                                        });
                                        if (filterresult)
                                            listbox.checkIndex(i, false, false);
                                        else {
                                            listbox.uncheckIndex(i, false, false);
                                        }
                                    }
                                    listbox._updateCheckedItems();
                                    var checkedItemsLength = listbox.getCheckedItems().length;
                                    if (listbox.items.length != checkedItemsLength && checkedItemsLength > 0) {
                                        listbox.host.jqxListBox('indeterminateIndex', 0, true, false);
                                    }
                                }
                            }
                            else {
                                if (listbox.getItem(this.gridlocalization.filterchoosestring) == null) {
                                    listbox.insertAt({ label: this.gridlocalization.filterchoosestring, value: "" }, 0);
                                }
                                dropdownlist.jqxDropDownList({ selectedIndex: 0 });
                                if (columnrecord.filter) {
                                    var filters = columnrecord.filter.getfilters();
                                    var selectedIndex = -1;
                                    for (var i = 0; i < listbox.items.length; i++) {
                                        var label = listbox.items[i].label;
                                        $.each(filters, function () {
                                            if (this.condition == "NOT_EQUAL") return true;
                                            if (label == this.value) {
                                                selectedIndex = i;
                                                return false;
                                            }
                                        });
                                    }
                                    if (selectedIndex != -1) {
                                        listbox.selectIndex(selectedIndex);
                                    }
                                }
                            }
                            if (dropdownitems.length < 8) {
                                dropdownlist.jqxDropDownList('autoDropDownHeight', true);
                            }
                            else {
                                dropdownlist.jqxDropDownList('autoDropDownHeight', false);
                            }
                        }
                    }
                }
            },

            _renderfilter: function () {
                var that = this;
                var filterElement =
                    $("<div style='display: flex; height: calc(100% - 10px); margin-top: 5px; align-items: center; position: relative; margin-left: 4px;'>"
                        + "<input title='Filter Input' style='width: 200px; height: 100%; direction: ltr;' role='textbox' type='text'/>"
                        + "<div style='cursor: pointer; height: 100%;'><div></div></div>"
                        + "</div>");

                var input = filterElement.find('input');
                var button = filterElement.find('div:first');
                filterElement.addClass(this.toThemeProperty('jqx-rc-all'));
                filterElement.addClass(this.toThemeProperty('jqx-widget'));
                filterElement.addClass(this.toThemeProperty('jqx-input-group'));
                input.addClass(this.toThemeProperty('jqx-input'));
                input.addClass(this.toThemeProperty('jqx-rc-l'));
                input.addClass(this.toThemeProperty('jqx-input-group-addon'));
                input.addClass(this.toThemeProperty('jqx-widget'));
                input.addClass(this.toThemeProperty('jqx-widget-content'));
                button.addClass(this.toThemeProperty('jqx-fill-state-normal'));
                button.addClass(this.toThemeProperty('jqx-rc-r'));
                button.addClass(this.toThemeProperty('jqx-input-group-addon'));
                button.find('div').addClass(this.toThemeProperty('jqx-icon-search'));
                if (this.rtl) {
                    input.addClass(this.toThemeProperty('jqx-rtl'));
                    input.css('direction', 'rtl');
                }
                this.filterbar.children().remove();
                this.filterbutton = button;

                var columns = new Array();

                for (var i = 0; i < that.columns.records.length; i++) {
                    if (that.columns.records[i].datafield && that.columns.records[i].filterable) {
                        columns.push({ label: that.columns.records[i].text, value: that.columns.records[i].displayfield });
                    }
                }
                var autoDropDownHeight = columns.length < 10 ? true : false;
                var searchstring = $("<div aria-label='Search Columns' style='position: relative;  display: none; margin-right: 4px; margin-left: 4px; float: left;'>" + this.gridlocalization.filtersearchstring + "</div>");
                this.filterbar.append(searchstring);
                var columnsList = $("<div aria-expanded='false' aria-label='Filter Columns' class='filtercolumns' style='position: relative; margin-top:5px; margin-left:4px; margin-right: 4px; float: left;'></div>");
                this.filterbar.append(columnsList);
                if (columnsList.jqxDropDownList) {
                    columnsList.jqxDropDownList({ theme: this.theme, enableBrowserBoundsDetection: true, autoDropDownHeight: autoDropDownHeight, rtl: that.rtl, dropDownWidth: 220, selectedIndex: 0, width: 'auto', height: 25, source: columns, displayMember: 'label', valueMember: 'value' });
                }
                this.filtercolumnsList = columnsList;

                input[0].parentElement.insertBefore(searchstring[0], input[0]);
                var updateSimpleFilter = function (filtercolumn) {
                    that.filterinput.val("");
                    for (var i = 0; i < that.dataview.filters.length; i++) {
                        var filtergroup = that.dataview.filters[i];
                        if (filtergroup.datafield === filtercolumn) {
                            that.filterinput.val(filtergroup.filter.getfilterat(0).filtervalue);
                        }
                    }
                }
                if (that.filterHeight !== 35) {
                }

                that._updateSimpleFilter = updateSimpleFilter;
                this.addHandler(columnsList, 'select', function (event) {
                    var filtercolumn = event.args.item.value;
                    updateSimpleFilter(filtercolumn);
                });

                if (this.filterbarmode === "simple") {
                    this.filtercolumnsList.hide();
                    searchstring.show();
                }
                else {
                    this.filtercolumnsList.show();
                    searchstring.hide();
                }

                var createSimpleFilter = function () {
                    if (!button.hasClass('jqx-fill-state-disabled')) {
                        var filtervalue = input.val();
                        if (columnsList.jqxDropDownList) {
                            var item = columnsList.jqxDropDownList('getSelectedItem');
                        }
                        var buildFilterGroup = function (column, filtervalue, operator) {
                            var filtergroup = new $.jqx.filter();
                            var type = that._getcolumntypebydatafield(column);

                            var filtertype = that._getfiltertype(type);
                            if (filtertype == "datefilter") {
                                var filter = filtergroup.createfilter(filtertype, filtervalue, "EQUAL", null, column.cellsFormat, that.gridlocalization);
                            }
                            else if (filtertype == "numericfilter" || filtertype == "booleanfilter") {
                                if (filtertype == "numericfilter") {
                                    if (that.gridlocalization.decimalseparator == ',') {
                                        if (filtervalue.indexOf(that.gridlocalization.decimalseparator) >= 0) {
                                            filtervalue = filtervalue.replace(that.gridlocalization.decimalseparator, '.');
                                        }
                                    }
                                    if (filtervalue.indexOf(that.gridlocalization.currencysymbol) >= 0) {
                                        filtervalue = filtervalue.replace(that.gridlocalization.currencysymbol, '');
                                    }
                                    if (filtervalue.indexOf(that.gridlocalization.percentagesymbol) >= 0) {
                                        filtervalue = filtervalue.replace(that.gridlocalization.percentagesymbol, '');
                                    }
                                }
                                var filter = filtergroup.createfilter(filtertype, filtervalue, "EQUAL", null, column.cellsFormat, that.gridlocalization);
                            }
                            else {
                                var filter = filtergroup.createfilter(filtertype, filtervalue, "CONTAINS");
                            }
                            filtergroup.operator = operator;
                            filtergroup.addfilter(0, filter);
                            return filtergroup;
                        }

                        if (that.filterbarmode !== "simple") {
                            if (item) {
                                var field = item.value;
                                var filtergroup = buildFilterGroup(field, filtervalue, "and");
                                if (filtervalue.length > 0) {
                                    that.removefilter(field);
                                    that.addfilter(field, filtergroup);
                                    that.applyfilters();
                                }
                                else {
                                    that.removefilter(field);
                                    that.applyfilters();
                                }
                            }
                        }
                        else {
                            that.clearfilters(false, false);
                            if (filtervalue.length > 0) {
                                for (var i = 0; i < that.columns.records.length; i++) {
                                    var column = that.columns.records[i];
                                    if (column.filterable !== true) {
                                        continue;
                                    }

                                    if ((column.datatype === 'date' || column.datatype === 'number') &&
                                        filtervalue.indexOf('1') === -1 &&
                                        filtervalue.indexOf('2') === -1 &&
                                        filtervalue.indexOf('3') === -1 &&
                                        filtervalue.indexOf('4') === -1 &&
                                        filtervalue.indexOf('5') === -1 &&
                                        filtervalue.indexOf('6') === -1 &&
                                        filtervalue.indexOf('7') === -1 &&
                                        filtervalue.indexOf('8') === -1 &&
                                        filtervalue.indexOf('9') === -1) {
                                        continue;
                                    }

                                    var filtergroup = buildFilterGroup(column, filtervalue, "or");
                                    that.addfilter(column.datafield, filtergroup);
                                }
                            }
                            that.applyfilters();
                        }
                        if (that.dataview.filters.length == 0) {
                            that.filtericon.fadeOut(200);
                        }
                        else {
                            that.filtericon.fadeIn(200);
                        }
                    }
                }

                input.keydown(function (event) {
                    if (event.keyCode === 13) {
                        createSimpleFilter();
                        if (event.preventDefault) {
                            event.preventDefault();
                        }
                        return false;
                    }
                });

                button.click(function () {
                    createSimpleFilter();
                });

                this.filterinput = input;
                this.filterbar.append(filterElement);

                var icon = $("<div style='float: left; width: 16px; height: 16px; position: relative; margin: 3px;'></div>");

                icon.attr('title', that.gridlocalization.filterclearstring);
                icon.addClass(that.toThemeProperty('jqx-icon-close'));
                filterElement.append(icon);
                icon.hide();
                that.filtericon = icon;
                icon.click(function () {
                    that.clearfilters();
                    input.val('');
                    that.filtericon.fadeOut(200);
                });

                if (that.dataview.filters.length > 0) {
                    updateSimpleFilter(that.dataview.filters[0].datafield);
                }
            },

            _renderfiltercolumn: function () {
                var self = this.that;

                if (this.filterable) {
                    if (!this.columns.records) return;
                    $.each(this.columns.records, function (i, value) {
                        var filtered = false;
                        if (self.autoshowfiltericon) {
                            if (this.filter) {
                                $(this.filtericon).show();
                                filtered = true;
                            }
                            else {
                                $(this.filtericon).hide();
                            }
                        }
                        else {
                            if (this.filterable) {
                                $(this.filtericon).show();
                                filtered = true;
                            }
                        }

                        this.element.removeAttribute('filter');
                        if (filtered) {
                            this.element.setAttribute('filter', true);
                        }

                        if (this.align == "right" && !this.renderer) {
                            if (this.element) {
                                if (!filtered) {
                                    this.element.firstChild.firstChild.style.marginRight = '2px';
                                }
                                else {
                                    this.element.firstChild.firstChild.style.marginRight = '18px';
                                }
                            }
                        }
                    });
                }
            },

            _initcolumntypes: function () {
                if (this.columns && this.columns.records) {
                    var datafields = this.source._source.datafields;
                    if (datafields) {
                        for (var i = 0; i < this.columns.records.length; i++) {
                            var column = this.columns.records[i];
                            if (column.datatype) continue;
                            var foundType = "";
                            $.each(datafields, function () {
                                if (this.name == column.displayfield) {
                                    if (this.type) {
                                        foundType = this.type;
                                    }
                                    return false;
                                }
                            });
                            if (foundType != "")
                                column.datatype = foundType;
                            else column.datatype = "";
                        }
                    }
                }
            },

            _getcolumntypebydatafield: function (column) {
                var me = this.that;
                var type = 'string';
                var datafields = me.source.datafields || ((me.source._source) ? me.source._source.datafields : null);

                if (datafields) {
                    var foundType = "";
                    $.each(datafields, function () {
                        if (this.name == column.displayfield) {
                            if (this.type) {
                                foundType = this.type;
                            }
                            return false;
                        }
                    });
                    if (foundType)
                        return foundType;
                }

                if (column != null) {
                    if (this.dataview.cachedrecords == undefined) {
                        return type;
                    }

                    var cell = null;

                    if (!this.virtualmode) {
                        if (this.dataview.cachedrecords.length == 0)
                            return type;

                        cell = this.dataview.cachedrecords[0][column.displayfield];
                        if (cell != null && cell.toString() == "") {
                            return "string";
                        }
                    }
                    else {
                        $.each(this.dataview.cachedrecords, function () {
                            cell = this[column.displayfield];
                            return false;
                        });
                    }

                    if (cell != null) {
                        if (typeof cell == 'boolean') {
                            type = 'boolean';
                        }
                        else if ($.jqx.dataFormat.isNumber(cell)) {
                            type = 'number';
                        }
                        else {
                            var tmpvalue = new Date(cell);

                            if (tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date") {
                                if ($.jqx.dataFormat) {
                                    tmpvalue = $.jqx.dataFormat.tryparsedate(cell);
                                    if (tmpvalue != null) {
                                        if (tmpvalue && tmpvalue.getFullYear()) {
                                            if (tmpvalue.getFullYear() == 1970 && tmpvalue.getMonth() == 0 && tmpvalue.getDate() == 1) {
                                                var num = new Number(cell);
                                                if (!isNaN(num))
                                                    return 'number';

                                                return 'string';
                                            }
                                        }

                                        return 'date';
                                    }
                                    else {
                                        type = 'string';
                                    }
                                }
                                else type = 'string';
                            }
                            else {
                                type = 'date';
                            }
                        }
                    }
                }
                return type;
            },

            _getfiltersbytype: function (type) {
                var me = this.that;
                var source = '';
                switch (type) {
                    case "number":
                    case "float":
                    case "int":
                        source = me.gridlocalization.filternumericcomparisonoperators;
                        break;
                    case "date":
                        source = me.gridlocalization.filterdatecomparisonoperators;
                        break;
                    case "boolean":
                    case "bool":
                        source = me.gridlocalization.filterbooleancomparisonoperators;
                        break;
                    case "string":
                    default:
                        source = me.gridlocalization.filterstringcomparisonoperators;
                        break;

                }
                return source;
            },

            _getfiltertype: function (type) {
                var filtertype = "stringfilter";
                switch (type) {
                    case "number":
                    case "int":
                    case "float":
                    case "decimal":
                        filtertype = 'numericfilter';
                        break;
                    case "boolean":
                    case "bool":
                        filtertype = 'booleanfilter';
                        break;
                    case "date":
                    case "time":
                    case "range":
                        filtertype = 'datefilter';
                        break;
                    case "string":
                    case "input":
                        filtertype = 'stringfilter';
                        break;
                }
                return filtertype;
            },

            _buildfilter: function (me, element, column) {
                var condition = $(element).find('.filter1');
                var operator = $(element).find('.filter2');
                var condition2 = $(element).find('.filter3');
                var input1 = $(element).find('.filtertext1' + me.element.id);
                var input2 = $(element).find('.filtertext2' + me.element.id);
                var value1 = input1.val();
                var value2 = input2.val();
                var type = me._getcolumntypebydatafield(column);
                var source = me._getfiltersbytype(type);

                var filtergroup = new $.jqx.filter();
                var filtertype = me._getfiltertype(type);
                if (me.filtermode === "default" && (column.filtertype !== "list" && column.filtertype !== "checkedlist")) {
                    var index1 = condition.jqxDropDownList('selectedIndex');
                    var operatorindex = operator.jqxDropDownList('selectedIndex');
                    var index2 = condition2.jqxDropDownList('selectedIndex');

                    var filter1 = null;
                    var filter2 = null;

                    if (me.updatefilterconditions) {
                        var newfilterconditions = me.updatefilterconditions(filtertype, filtergroup.getoperatorsbyfiltertype(filtertype));
                        if (newfilterconditions != undefined) {
                            filtergroup.setoperatorsbyfiltertype(filtertype, newfilterconditions);
                        }
                    }

                    var isvalidfilter = false;
                    var condition1 = filtergroup.getoperatorsbyfiltertype(filtertype)[index1];
                    var condition2 = filtergroup.getoperatorsbyfiltertype(filtertype)[index2];
                    var nullcondition1 = condition1 == "NULL" || condition1 == "NOT_NULL";
                    var emptycondition1 = condition1 == "EMPTY" || condition1 == "NOT_EMPTY";

                    if (condition1 == undefined) condition1 = filtergroup.getoperatorsbyfiltertype(filtertype)[0];
                    if (condition2 == undefined) condition2 = filtergroup.getoperatorsbyfiltertype(filtertype)[0];

                    if (value1.length > 0 || nullcondition1 || emptycondition1) {
                        filter1 = filtergroup.createfilter(filtertype, value1, condition1, null, column.cellsformat, me.gridlocalization);
                        filtergroup.addfilter(operatorindex, filter1);
                        isvalidfilter = true;
                    }

                    var nullcondition2 = condition2 == "NULL" || condition2 == "NOT_NULL";
                    var emptycondition2 = condition2 == "EMPTY" || condition2 == "NOT_EMPTY";

                    if (value2.length > 0 || nullcondition2 || emptycondition2) {
                        filter2 = filtergroup.createfilter(filtertype, value2, condition2, null, column.cellsformat, me.gridlocalization);
                        filtergroup.addfilter(operatorindex, filter2);
                        isvalidfilter = true;
                    }

                    if (isvalidfilter) {
                        var datafield = column.displayfield;
                        this.addfilter(datafield, filtergroup, true);
                    }
                    else {
                        this._clearfilter(me, element, column);
                    }
                }
                else if (me.filtermode === "excel" || (column.filtertype === "list" || column.filtertype === "checkedlist")) {
                    var that = this;
                    var hasFilter = false;
                    var widget = condition.data().jqxListBox.instance;
                    var checkboxes = this.filtermode === "excel" || column.filtertype === "checkedlist";
                    var checkedItems = widget.getCheckedItems();
                    if (!checkboxes) {
                        var checkedItems = widget.getSelectedItems();
                    }
                    if (checkedItems.length == 0) {
                        for (var i = 1; i < widget.items.length; i++) {
                            var filtervalue = widget.items[i].value;
                            if (filtervalue === undefined) filtervalue = "";
                            var filtercondition = 'not_equal';

                            if (filtervalue && filtervalue.indexOf) {
                                if (filtervalue.indexOf("|") >= 0 || filtervalue.indexOf(" AND ") >= 0 || filtervalue.indexOf(" OR ") >= 0 || filtervalue.indexOf(" and ") >= 0 || filtervalue.indexOf(" or ") >= 0) {
                                    filtervalue = filtervalue.replace("|", "");
                                    filtervalue = filtervalue.replace("AND", "");
                                    filtervalue = filtervalue.replace("OR", "");
                                    filtervalue = filtervalue.replace("and", "");
                                    filtervalue = filtervalue.replace("or", "");
                                    var filtercondition = 'equal';
                                }
                            }

                            if (filtertype == "datefilter") {
                                var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition, null, column.cellsformat, me.gridlocalization);
                            }
                            else {
                                var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition, null);
                            }
                            filtergroup.addfilter(0, filter);
                        }

                        hasFilter = true;
                    }
                    else {
                        if (checkedItems.length != widget.items.length) {
                            hasFilter = true;
                            for (var i = 0; i < checkedItems.length; i++) {
                                if (me.gridlocalization.filterselectallstring === checkedItems[i].value)
                                    continue;

                                var filtervalue = checkedItems[i].value;
                                if (filtervalue === undefined) filtervalue = "";
                                var filtercondition = 'equal';

                                if (filtertype == "datefilter") {
                                    var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition, null, column.cellsformat, me.gridlocalization);
                                }
                                else {
                                    var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition, null);
                                }
                                var filter_or_operator = 1;
                                filtergroup.addfilter(filter_or_operator, filter);
                            }
                        }
                        else hasFilter = false;
                    }
                    if (hasFilter) {
                        var datafield = column.displayfield;
                        this.addfilter(datafield, filtergroup, true);
                    }
                    else {
                        var datafield = column.displayfield;
                        this.removefilter(datafield, true);
                    }
                }
            },

            _clearfilter: function (me, element, column) {
                var datafield = column.displayfield;
                this.removefilter(datafield, true);
            },

            addfilter: function (datafield, filter, apply) {
                if (this._loading) {
                    throw new Error('jqxGrid: ' + this.loadingerrormessage);
                    return false;
                }

                var columnbydatafield = this.getcolumn(datafield);
                var _columnbydatafield = this._getcolumn(datafield);
                if (columnbydatafield == undefined || columnbydatafield == null)
                    return;

                columnbydatafield.filter = filter;
                if (_columnbydatafield) {
                    _columnbydatafield.filter = filter;
                }
                this.dataview.addfilter(datafield, filter);
                if (apply == true && apply != undefined) {
                    this.applyfilters('add');
                }
            },

            // removes a filter.
            removefilter: function (datafield, apply) {
                if (this._loading) {
                    throw new Error('jqxGrid: ' + this.loadingerrormessage);
                    return false;
                }

                var columnbydatafield = this.getcolumn(datafield);
                var _columnbydatafield = this._getcolumn(datafield);
                if (columnbydatafield == undefined || columnbydatafield == null)
                    return;

                if (columnbydatafield.filter == null)
                    return;

                this.dataview.removefilter(datafield, columnbydatafield.filter);
                columnbydatafield.filter = null;
                _columnbydatafield.filter = null;

                if (this.showfilterrow) {
                    this.clearfilterrow(datafield);
                }

                if (apply == true || apply !== false) {
                    this.applyfilters('remove');
                }
            },

            applyfilters: function (reason) {
                var customfilter = false;

                if (this.dataview.filters.length >= 0 && (this.virtualmode || !this.source.localdata)) {
                    if (this.source != null && this.source.filter) {
                        var tmppage = -1;
                        if (this.pageable) {
                            tmppage = this.dataview.pagenum;
                            this.dataview.pagenum = 0;
                        }
                        else {
                            this.vScrollInstance.setPosition(0);
                            this.loadondemand = true;
                            this._renderrows(this.virtualsizeinfo);
                        }

                        if (this.pageable && this.virtualmode) {
                            this.dataview.pagenum = 0;
                        }
                        this.source.filter(this.dataview.filters, this.dataview.records, this.dataview.records.length);
                        if (this.pageable && !this.virtualmode) {
                            this.dataview.pagenum = tmppage;
                        }
                    }
                }
                this._cellscache = new Array();
                if (this.dataview.clearsortdata) {
                    this.dataview.clearsortdata();
                }
                if (!this.virtualmode) {
                    var selectedrowindexes = this.selectedrowindexes;
                    var me = this.that;
                    this.dataview.refresh();
                    if (this.dataview.clearsortdata) {
                        if (this.sortcolumn && this.sortdirection) {
                            var sortdirection = this.sortdirection.ascending ? "asc" : "desc";
                            if (!this._loading) {
                                this.sortby(this.sortcolumn, sortdirection, null, false);
                            }
                            else {
                                this.sortby(this.sortcolumn, sortdirection, null, false, false);
                            }
                        }
                    }

                }
                else {
                    if (this.pageable) {
                        this.dataview.updateview();
                        if (this.gotopage) {
                            this.gotopage(0);
                        }
                    }
                    this.rendergridcontent(false, false);
                    if (this.showfilterrow) {
                        if (typeof reason != 'string' && $.isEmptyObject(reason)) {
                            this.refreshfilterrow();
                        }
                    }
                    this._postrender("filter");
                    this._raiseEvent(13, { filters: this.dataview.filters });
                    return;
                }

                if (this.pageable) {
                    this.dataview.updateview();
                    if (this.gotopage) {
                        this.gotopage(0);
                        this.updatepagerdetails();
                    }
                }
                this._updaterowsproperties();
                if (!this.groupable || (this.groupable && this.groups.length == 0)) {
                    this._rowdetailscache = new Array();
                    this.virtualsizeinfo = null;
                    this._pagescache = new Array();
                    if (this.columns && this.columns.records && this.columns.records.length > 0 && !this.columns.records[0].filtericon) {
                        this.prerenderrequired = true;
                    }
                    // it is not necessary to update the columns and that's why the second param is false.
                    this.rendergridcontent(true, false);
                    this._updatecolumnwidths();
                    this._updatecellwidths();
                    this._renderrows(this.virtualsizeinfo);
                    if (this.showaggregates && this._updatecolumnsaggregates) {
                        this._updatecolumnsaggregates();
                    }
                    this._postrender("filter");
                }
                else {
                    this.collapseallgroups();
                    this._rowdetailscache = new Array();
                    this._render(true, true, false, false, false);
                    if (this.showfilterrow) this._updatefocusedfilter();
                    this._updatecolumnwidths();
                    this._updatecellwidths();
                    this._renderrows(this.virtualsizeinfo);
                    this._postrender("filter");
                }
                if (this.showfilterrow) {
                    if (typeof reason != 'string' && $.isEmptyObject(reason)) {
                        this.refreshfilterrow();
                    }
                }

                this._raiseEvent(13, { filters: this.dataview.filters });
            },

            getfilterinformation: function () {
                var filters = new Array();
                for (var i = 0; i < this.dataview.filters.length; i++) {
                    var column = this.getcolumn(this.dataview.filters[i].datafield);
                    filters[i] = { filter: this.dataview.filters[i].filter, datafield: column.datafield, displayfield: column.displayfield, filtercolumn: column.datafield, filtercolumntext: column.text };
                }
                return filters;
            },

            clearfilters: function (apply) {
                var me = this.that;
                if (this.showfilterrow) {
                    this.clearfilterrow();
                }

                if (this.columns.records) {
                    var canApply = apply == true || apply !== false;
                    $.each(this.columns.records, function () {
                        me.removefilter(this.displayfield, !canApply);
                    });
                }

                if (apply === false)
                    return;

                if (apply == true || apply !== false) {
                    this.applyfilters('clear');
                }
            },



            _updatefilterpanel: function (me, element, column) {
                if (me == null || me == undefined) me = this;
                var type = me._getcolumntypebydatafield(column);
                var source = me._getfiltersbytype(type);

                if (!me.host.jqxDropDownList) {
                    throw new Error('jqxGrid: Missing reference to jqxdropdownlist.js.');
                    return;
                }
                me.filterpanel.detach();
                me.excelfilterpanel.detach();
                if (column.filterpanel) {
                    column.filterpanel.detach();
                }
                $(element).children().detach();
                var filteritem = $(me.menuitemsarray[6]);
                $(filteritem).css('height', '190px');

                if (column.createfilterpanel && !column.filterpanel) {
                    var filterpanelcontainer = $("<div class='filter' style='margin-left: 7px;'></div>");
                    $(element).append(filterpanelcontainer);
                    column.createfilterpanel(column.displayfield, filterpanelcontainer);
                    column.filterpanel = filterpanelcontainer;
                }

                if (column.filtertype === "list" || column.filtertype === "checkedlist") {
                    $(element).append(me.excelfilterpanel);
                }
                else if (column.filtertype !== "custom") {
                    $(element).append(me.filterpanel);
                }
                else {
                    if (column.filterpanel) {
                        $(element).append(column.filterpanel);
                    }
                }

                var $element = $(element);
                var clearbutton = $element.find('#filterclearbutton' + me.element.id);
                var filterbutton = $element.find('#filterbutton' + me.element.id);
                var condition = $element.find('.filter1');
                var filteroperator = $element.find('.filter2');
                var condition2 = $element.find('.filter3');
                var input1 = $element.find('.filtertext1' + me.element.id);
                var input2 = $element.find('.filtertext2' + me.element.id);

                if (this._hasdatefilter && (column.filtertype !== "list" && column.filtertype !== "checkedlist" && column.filtertype !== "custom")) {
                    var filter1 = input1.parent();
                    var filter2 = input2.parent();
                    filter1.children().remove();
                    filter2.children().remove();

                    if (column.filtertype == "date") {
                        me._showwhere.text(me.gridlocalization.filtershowrowdatestring);
                        var input = $("<div class='filtertext1" + me.element.id + "' style=''></div>");

                        filter1.append(input);
                        var initInput = function (input) {
                            var localization = { calendar: me.gridlocalization, todayString: me.gridlocalization.todaystring, clearString: me.gridlocalization.clearstring };
                            input.jqxDateTimeInput({ disabled: me.disabled, firstDayOfWeek: me.gridlocalization.firstDay, localization: localization, rtl: me.rtl, width: me._filterpanelwidth - 10, height: this.filterMenuItemsHeight, value: null, formatString: column.cellsformat, theme: me.theme });
                        }
                        initInput(input);

                        var input = $("<div class='filtertext2" + me.element.id + "' style=''></div>");
                        filter2.append(input);
                        initInput(input);
                    }
                    else {
                        me._showwhere.text(me.gridlocalization.filtershowrowstring);
                        var input = $("<input autocomplete='off' class='filtertext1" + me.element.id + "' style='box-sizing: content-box; height: 16px; padding: 3px;' type='text'></input>");
                        filter1.append(input);
                        var initInput = function (input) {
                            input.addClass(me.toThemeProperty('jqx-input'));
                            input.addClass(me.toThemeProperty('jqx-filter-input jqx-widget-content'));
                            input.addClass(me.toThemeProperty('jqx-rc-all'));
                            input.width(me._filterpanelwidth - 18);
                            input[0].style.height = this.filterMenuItemsHeight + 'px';
                        }
                        initInput(input);

                        var input = $("<input autocomplete='off' class='filtertext2" + me.element.id + "' style='box-sizing: content-box; height: 16px; padding: 3px;' type='text'></input>");
                        filter2.append(input);
                        initInput(input);
                    }
                    var input1 = $element.find('.filtertext1' + me.element.id);
                    var input2 = $element.find('.filtertext2' + me.element.id);
                }

                if (column.filtertype != "date") {
                    input1.val('');
                    input2.val('');
                }
                else {
                    input1.val(null);
                    input2.val(null);
                }

                this.removeHandler(filterbutton, 'click');
                this.addHandler(filterbutton, 'click', function () {
                    me._buildfilter(me, element, column);
                    me._closemenu();
                });
                this.removeHandler(clearbutton, 'click');
                this.addHandler(clearbutton, 'click', function () {
                    me._clearfilter(me, element, column);
                    me._closemenu();
                });
                this.removeHandler(filterbutton, 'keydown');
                this.addHandler(filterbutton, 'keydown', function (event) {
                    if (event.keyCode === 13) {
                        me._buildfilter(me, element, column);
                        me._closemenu();
                    }
                });
                this.removeHandler(clearbutton, 'keydown');
                this.addHandler(clearbutton, 'keydown', function (event) {
                    if (event.keyCode === 13) {
                        me._clearfilter(me, element, column);
                        me._closemenu();
                    }
                });
                this.removeHandler(input1, "keydown");
                this.addHandler(input1, "keydown", function (event) {
                    if (event.keyCode === 13) {
                        filterbutton.trigger('click');
                    }
                    if (event.keyCode === 27) {
                        me._closemenu();
                    }
                });
                this.removeHandler(input2, "keydown");
                this.addHandler(input2, "keydown", function (event) {
                    if (event.keyCode === 13) {
                        filterbutton.trigger('click');
                    }
                    if (event.keyCode === 27) {
                        me._closemenu();
                    }
                });

                if (this.filtermode === "default" && (column.filtertype !== "list" && column.filtertype !== "checkedlist" && column.filtertype !== "custom")) {
                    if (condition.jqxDropDownList('source') != source) {
                        condition.jqxDropDownList({ enableBrowserBoundsDetection: false, source: source });
                        condition2.jqxDropDownList({ enableBrowserBoundsDetection: false, source: source });
                    }

                    if (type == 'boolean' || type == 'bool') {
                        condition.jqxDropDownList({ autoDropDownHeight: true, selectedIndex: 0 });
                        condition2.jqxDropDownList({ autoDropDownHeight: true, selectedIndex: 0 });
                    }
                    else {
                        var autoDropDownHeight = false;
                        if (source && source.length) {
                            if (source.length < 5) {
                                autoDropDownHeight = true;
                            }
                        }

                        condition.jqxDropDownList({ autoDropDownHeight: autoDropDownHeight, selectedIndex: 2 });
                        condition2.jqxDropDownList({ autoDropDownHeight: autoDropDownHeight, selectedIndex: 2 });
                    }
                    filteroperator.jqxDropDownList({ selectedIndex: 0 });

                    var filter = column.filter;
                    var filtergroup = new $.jqx.filter();
                    var filtertype = "";
                    switch (type) {
                        case "number":
                        case "int":
                        case "float":
                        case "decimal":
                            filtertype = 'numericfilter';
                            conditions = filtergroup.getoperatorsbyfiltertype('numericfilter');
                            break;
                        case "boolean":
                        case "bool":
                            filtertype = 'booleanfilter';
                            conditions = filtergroup.getoperatorsbyfiltertype('booleanfilter');
                            break;
                        case "date":
                        case "time":
                            filtertype = 'datefilter';
                            conditions = filtergroup.getoperatorsbyfiltertype('datefilter');
                            break;
                        case "string":
                            filtertype = 'stringfilter';
                            conditions = filtergroup.getoperatorsbyfiltertype('stringfilter');
                            break;
                    }
                    if (filter != null) {
                        var filter1 = filter.getfilterat(0);
                        var filter2 = filter.getfilterat(1);
                        var operator = filter.getoperatorat(0);

                        if (me.updatefilterconditions) {
                            var conditions = [];
                            var newfilterconditions = me.updatefilterconditions(filtertype, conditions);
                            if (newfilterconditions != undefined) {
                                for (var c = 0; c < newfilterconditions.length; c++) {
                                    newfilterconditions[c] = newfilterconditions[c].toUpperCase();
                                }
                                filter.setoperatorsbyfiltertype(filtertype, newfilterconditions);
                                conditions = newfilterconditions;
                            }
                        }

                        var animationtype = 'default';
                        if (filter1 != null) {
                            var index1 = conditions.indexOf(filter1.comparisonoperator);
                            var value1 = filter1.filtervalue;
                            input1.val(value1);
                            condition.jqxDropDownList({ selectedIndex: index1, animationType: animationtype });
                        }
                        if (filter2 != null) {
                            var index2 = conditions.indexOf(filter2.comparisonoperator);
                            var value2 = filter2.filtervalue;
                            input2.val(value2);
                            condition2.jqxDropDownList({ selectedIndex: index2, animationType: animationtype });
                        }
                        if (filter.getoperatorat(0) == undefined) {
                            filteroperator.jqxDropDownList({ selectedIndex: 0, animationType: animationtype });
                        }
                        else {
                            if (filter.getoperatorat(0) == 'and' || filter.getoperatorat(0) == 0) {
                                filteroperator.jqxDropDownList({ selectedIndex: 0 });
                            }
                            else {
                                filteroperator.jqxDropDownList({ selectedIndex: 1 });
                            }
                        }
                    }

                    if (me.updatefilterpanel) {
                        me.updatefilterpanel(condition, condition2, filteroperator, input1, input2, filterbutton, clearbutton, filter, filtertype, conditions);
                    }

                    if (!this._hasdatefilter || (this._hasdatefilter && column.filtertype != "date")) {
                        if (!this.touchdevice) {
                            input1.focus();
                            setTimeout(function () {
                                input1.focus();
                            }, 10);
                        }
                    }
                }
                else if (this.filtermode === "excel" || column.filtertype === "list" || column.filtertype === "checkedlist") {
                    var dataadapter = me._getfilterdataadapter(column);
                    var filtertype = me._getfiltertype(type);
                    var checkboxes = this.filtermode === "excel" || column.filtertype === "checkedlist";
                    if (column.filtertype == "date") {
                        me._showwhere.text(me.gridlocalization.filtershowrowstring);
                    }

                    condition.jqxListBox('focus');
                    this.removeHandler(condition, "keyup");
                    this.addHandler(condition, "keyup", function (event) {
                        if (event.keyCode === 13) {
                            filterbutton.trigger('click');
                        }
                        if (event.keyCode === 27) {
                            me._closemenu();
                        }
                    });
                    if (column.cellsformat) {
                        condition.jqxListBox({ checkboxes: checkboxes, displayMember: column.displayfield, valueMember: column.displayfield + "JQValue", source: dataadapter });
                    }
                    else {
                        condition.jqxListBox({ checkboxes: checkboxes, displayMember: column.displayfield, valueMember: column.displayfield, source: dataadapter });
                    }
                    if (checkboxes) {
                        condition.jqxListBox('insertAt', { label: me.gridlocalization.filterselectallstring }, 0);
                        var listbox = condition.data().jqxListBox.instance;
                        listbox.checkAll(false);
                        var that = this;
                        if (column.filter) {
                            listbox.uncheckAll(false);
                            var filters = column.filter.getfilters();
                            for (var i = 0; i < listbox.items.length; i++) {
                                var label = listbox.items[i].value;

                                $.each(filters, function () {
                                    if (this.condition == "NOT_EQUAL") {
                                        if (label != this.value) {
                                            listbox.uncheckIndex(i, false, false);
                                            return false;
                                        }
                                        else if (label != null && this.value != null && label.toString() != this.value.toString()) {
                                            listbox.uncheckIndex(i, false, false);
                                            return false;
                                        }
                                    }
                                    else if (this.condition == "EQUAL") {
                                        if (label == this.value) {
                                            listbox.checkIndex(i, false, false);
                                            return false;
                                        }
                                        else if (label != null && this.value != null && label.toString() == this.value.toString()) {
                                            listbox.checkIndex(i, false, false);
                                            return false;
                                        }
                                    }
                                });
                            }

                            listbox._updateCheckedItems();
                            var checkedItemsLength = listbox.getCheckedItems().length;
                            if (listbox.items.length != checkedItemsLength && checkedItemsLength > 0) {
                                listbox.host.jqxListBox('indeterminateIndex', 0, true, false);
                            }
                            if (checkedItemsLength === listbox.items.length - 1) {
                                listbox.host.jqxListBox('checkIndex', 0, true, false);
                            }
                        }
                    }
                    else {
                        if (column.filter) {
                            var listbox = condition.data().jqxListBox.instance;
                            listbox.clearSelection();
                            var filters = column.filter.getfilters();
                            for (var i = 0; i < listbox.items.length; i++) {
                                var label = listbox.items[i].value;

                                $.each(filters, function () {
                                    if (this.condition == "NOT_EQUAL") {
                                        if (label != this.value) {
                                            listbox.unselectIndex(i, false, false);
                                            return false;
                                        }
                                    }
                                    else if (this.condition == "EQUAL") {
                                        if (label == this.value) {
                                            listbox.selectIndex(i, true, false);
                                            return false;
                                        }
                                    }
                                });
                            }
                            listbox._renderItems();
                        }
                    }
                }
            },

            _initfilterpanel: function (me, element, column, width, excelMode) {
                if (me == null || me == undefined) me = this;
                element[0].innerHTML = "";
                var filterpanelcontainer = $("<div class='filter' style='position: absolute; bottom: 3px; margin-left: 3px;'></div>");

                element.append(filterpanelcontainer);
                var showwhere = $("<div class='filter showwhere' style='height: 18px; margin-top: 3px; margin-bottom: 3px;'></div>");
                showwhere.text(me.gridlocalization.filtershowrowstring);
                this._showwhere = showwhere;
                var exString = excelMode ? "ex" : "";
                var condition = $("<div class='filter filter1' id='filter1" + me.element.id + exString + "'></div>");
                var operator = $("<div class='filter filter2' id='filter2" + me.element.id + exString + "' style='margin-top: 3px; margin-bottom: 3px;'></div>");
                var condition2 = $("<div class='filter filter3' id='filter3" + me.element.id + exString + "'></div>");
                var type = me._getcolumntypebydatafield(column);

                if (!condition.jqxDropDownList) {
                    throw new Error('jqxGrid: jqxdropdownlist.js is not loaded.');
                    return;
                }

                condition[0].setAttribute('aria-label', 'Filter Condition 1');
                operator[0].setAttribute('aria-label', 'Filter Operator');
                condition2[0].setAttribute('aria-label', 'Filter Condition 2');

                condition[0].setAttribute('aria-expanded', false);
                operator[0].setAttribute('aria-expanded', false);
                condition2[0].setAttribute('aria-expanded', false);


                var source = me._getfiltersbytype(type);

                this._hasdatefilter = false;
                this._filterpanelwidth = width;
                if (this.columns && this.columns.records) {
                    for (var i = 0; i < this.columns.records.length; i++) {
                        if (this.columns.records[i].filtertype == "date") {
                            this._hasdatefilter = true;
                            break;
                        }
                    }
                }
                else if (this.columns && !this.columns.records) {
                    for (var i = 0; i < this.columns.length; i++) {
                        if (this.columns[i].filtertype == "date") {
                            this._hasdatefilter = true;
                            break;
                        }
                    }
                }

                var input = $("<div style='margin-top:3px;' class='filter'><input autocomplete='off' class='filtertext1" + me.element.id + "' style='padding: 3px; height: 17px; margin-top: 3px; margin-bottom: 3px;' type='text'></input></div>");
                var textField = input.find('input');
                textField.addClass(this.toThemeProperty('jqx-input'));
                textField.addClass(this.toThemeProperty('jqx-filter-input jqx-widget-content'));
                textField.addClass(this.toThemeProperty('jqx-rc-all'));
                textField.width(width - 18);

                var input2 = $("<div style='margin-top:3px;' class='filter'><input autocomplete='off' class='filtertext2" + me.element.id + "' style='padding: 3px; height: 17px; margin-top: 3px;' type='text'></input></div>");
                var textField2 = input2.find('input');
                textField2.addClass(this.toThemeProperty('jqx-input'));
                textField2.addClass(this.toThemeProperty('jqx-filter-input jqx-widget-content'));
                textField2.addClass(this.toThemeProperty('jqx-rc-all'));
                textField2.width(width - 18);

                if (me.rtl) {
                    textField.css('direction', 'rtl');
                    textField2.css('direction', 'rtl');
                }

                var applyinput = $("<div class='filter' style='height: 35px; text-align:center; margin-top: 15px; margin-left:-2px;'></div>");
                var filterbutton = $('<span tabIndex=0 id="filterbutton' + me.element.id + '" class="primary filterbutton" style="padding: 6px 15px;">' + me.gridlocalization.filterstring + '</span>');
                applyinput.append(filterbutton);
                var filterclearbutton = $('<span tabIndex=0 id="filterclearbutton' + me.element.id + '" class="secondary filterclearbutton" style="position: relative; left: 1px; padding: 6px 15px; margin-left: 7px;">' + me.gridlocalization.filterclearstring + '</span>');
                applyinput.append(filterclearbutton);

                filterbutton.jqxButton({ height: this.filterMenuItemsHeight, theme: me.theme });
                filterclearbutton.jqxButton({ height: this.filterMenuItemsHeight, theme: me.theme });

                var selectionrenderer = function (selectionelement) {
                    if (selectionelement) {
                        if (selectionelement.text().indexOf("case sensitive") != -1) {
                            var selectiontext = selectionelement.text();
                            selectiontext = selectiontext.replace("case sensitive", "match case");
                            selectionelement.text(selectiontext);
                        }
                        selectionelement.css('font-family', me.host.css('font-family'));
                        selectionelement.css('font-size', me.host.css('font-size'));
                        selectionelement.css('top', '2px');
                        selectionelement.css('position', 'relative');

                        return selectionelement;
                    }
                    return "";
                }

                if (this.filtermode === "default" && !excelMode) {
                    filterpanelcontainer.append(showwhere);
                    filterpanelcontainer.append(condition);
                    condition.jqxDropDownList({ _checkForHiddenParent: false, autoItemsHeight: true, rtl: me.rtl, enableBrowserBoundsDetection: false, selectedIndex: 2, width: width - 10, height: 24, dropDownHeight: 150, dropDownWidth: width - 10, selectionRenderer: selectionrenderer, source: source, theme: me.theme });
                    filterpanelcontainer.append(input);
                    var operators = new Array();
                    operators[0] = me.gridlocalization.filterandconditionstring;
                    operators[1] = me.gridlocalization.filterorconditionstring;
                    operator.jqxDropDownList({ _checkForHiddenParent: false, rtl: me.rtl, enableBrowserBoundsDetection: false, autoDropDownHeight: true, selectedIndex: 0, width: 60, height: 24, source: operators, selectionRenderer: selectionrenderer, theme: me.theme });
                    filterpanelcontainer.append(operator);
                    condition2.jqxDropDownList({ _checkForHiddenParent: false, autoItemsHeight: true, rtl: me.rtl, enableBrowserBoundsDetection: false, selectedIndex: 2, width: width - 10, height: 24, dropDownHeight: 150, dropDownWidth: width - 10, selectionRenderer: selectionrenderer, source: source, theme: me.theme });
                    filterpanelcontainer.append(condition2);
                    filterpanelcontainer.append(input2);
                }
                else if (this.filtermode === "excel" || excelMode) {
                    filterpanelcontainer.append(showwhere);
                    filterpanelcontainer.append(condition);
                    condition.attr('tabindex', 0);
                    condition.jqxListBox({ rtl: me.rtl, _checkForHiddenParent: false, checkboxes: true, selectedIndex: 2, width: width - 10, height: 130, theme: me.theme });
                    var handleCheckChange = true;
                    me.addHandler(condition, 'checkChange', function (event) {
                        if (!handleCheckChange)
                            return;

                        if (event.args.label != me.gridlocalization.filterselectallstring) {
                            handleCheckChange = false;
                            condition.jqxListBox('checkIndex', 0, true, false);
                            var checkedItems = condition.jqxListBox('getCheckedItems');
                            var items = condition.jqxListBox('getItems');

                            if (checkedItems.length == 1) {
                                condition.jqxListBox('uncheckIndex', 0, true, false);
                            }
                            else if (items.length != checkedItems.length) {
                                condition.jqxListBox('indeterminateIndex', 0, true, false);
                            }
                            handleCheckChange = true;
                        }
                        else {
                            handleCheckChange = false;
                            if (event.args.checked) {
                                condition.jqxListBox('checkAll', false);
                            }
                            else {
                                condition.jqxListBox('uncheckAll', false);
                            }

                            handleCheckChange = true;
                        }
                    });
                }

                filterpanelcontainer.append(applyinput);
                if (me.updatefilterpanel) {
                    me.updatefilterpanel(condition, condition2, operator, input, input2, filterbutton, filterclearbutton, null, null, source);
                }
            }
        });
    })(jqxBaseFramework);


    /* eslint-disable */
    (function ($) {

        $.extend($.jqx._jqxGrid.prototype, {
            _updatefilterrowui: function (forceupdateui) {
                var columnslength = this.columns.records.length;
                var left = 0;
                var me = this;
                if (!this.filterrow)
                    return;

                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = this.columns.records[j];
                    var width = parseInt(columnrecord.width);
                    if (width < columnrecord.minwidth) width = columnrecord.minwidth;
                    if (width > columnrecord.maxwidth) width = columnrecord.maxwidth;
                    var tablecolumn = $(this.filterrow[0].cells[j]);
                    tablecolumn.css('left', left);
                    var updateui = true;
                    if (tablecolumn.width() == width) {
                        updateui = false;
                    }
                    if (forceupdateui) {
                        updateui = true;
                    }
                    tablecolumn.width(width);
                    tablecolumn[0].left = left;

                    if (columnrecord.element) {
                        tablecolumn[0].style.width = columnrecord.element.style.width;
                        tablecolumn[0].style.left = columnrecord.element.style.left;
                    }

                    if (!(columnrecord.hidden && columnrecord.hideable)) {
                        left += width;
                    }
                    else {
                        tablecolumn.css('display', 'none');
                    }
                    if (!updateui)
                        continue;

                    if (columnrecord.createfilterwidget && columnrecord.filtertype == 'custom') {
                        columnrecord.createfilterwidget(columnrecord, tablecolumn);
                    }
                    else {
                        if (columnrecord.filterable) {
                            var addtextfilter = function (me, tablecolumn) {
                                var textbox = $(tablecolumn.children()[0]);

                                if (textbox[0]) {
                                    textbox[0].style.width = (width - 8) + 'px';
                                    if ($.jqx.browser.msie) {
                                        textbox[0].style.width = (width - 16) + 'px';
                                    }
                                }

                                textbox.attr('disabled', me.disabled);
                            }

                            switch (columnrecord.filtertype) {
                                case 'number':
                                case 'input':
                                    $(tablecolumn.children()[0]).width(width);
                                    tablecolumn.find('input')[0].style.width = (width - 30) + 'px';
                                    if ($.jqx.browser.msie) {
                                        tablecolumn.find('input')[0].style.width = (width - 36) + 'px';
                                    }
                                    tablecolumn.find('input').attr('disabled', me.disabled);
                                    $(tablecolumn.find('.jqx-dropdownlist-state-normal')).jqxDropDownList({ theme: me.theme, disabled: me.disabled });
                                    break;
                                case 'date':
                                case 'range':
                                    if (this.host.jqxDateTimeInput) {
                                        $(tablecolumn.children()[0]).jqxDateTimeInput({ theme: me.theme, disabled: me.disabled, width: width - 10 });
                                    }
                                    else addtextfilter(this, tablecolumn);
                                    break;
                                case 'textbox':
                                case 'default':
                                    addtextfilter(this, tablecolumn);
                                    break;
                                case 'list':
                                case 'checkedlist':
                                    if (this.host.jqxDropDownList) {
                                        $(tablecolumn.children()[0]).jqxDropDownList({ theme: me.theme, disabled: me.disabled, width: width - 10 });
                                    }
                                    else addtextfilter(this, tablecolumn);
                                    break;
                                case 'bool':
                                case 'boolean':
                                    if (!this.host.jqxCheckBox) {
                                        addtextfilter(this, tablecolumn);
                                    }
                                    else {
                                        $(tablecolumn.children()[0]).jqxCheckBox({ theme: me.theme, disabled: me.disabled });
                                    }
                                    break;
                            }
                        }
                    }
                }
                var tablerow = $(this.filterrow.children()[0]);
                tablerow.width(parseInt(left) + 2);
                tablerow.height(this.filterrowheight);
            },

            clearfilterrow: function (datafield) {
                this._disablefilterrow = true;
                if (!this.columns.records)
                    return;

                var columnslength = this.columns.records.length;
                var left = 0;
                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = this.columns.records[j];
                    var tablecolumn = $(this.filterrow[0].cells[j]);

                    if (typeof datafield == "string") {
                        if (columnrecord.displayfield != datafield) {
                            continue;
                        }
                    }

                    if (columnrecord.filterable) {
                        var addtextfilter = function (me, tablecolumn) {
                            var textbox = $(tablecolumn.children()[0]);
                            textbox.val("");
                            if (textbox[0]) {
                                me["_oldWriteText" + textbox[0].id] = "";
                            }
                        }

                        switch (columnrecord.filtertype) {
                            case 'number':
                            case 'input':
                                tablecolumn.find('input').val("");
                                var id = tablecolumn.find('input')[0].id;

                                this["_oldWriteText" + id] = "";

                                if (this.host.jqxDropDownList) {
                                    var dropDownList = $($($(tablecolumn).children()[0]).children()[1]);
                                    dropDownList.jqxDropDownList('clearSelection');
                                    var selectedIndex = 0;
                                    if (selectedIndex == 0) {
                                        var source = this._getfiltersbytype(columnrecord.filtertype == 'number' ? 'number' : 'string');
                                        var filtergroup = new $.jqx.filter();
                                        var operators = filtergroup.getoperatorsbyfiltertype(columnrecord.filtertype == 'number' ? 'numberfilter' : 'stringfilter');

                                        if (columnrecord.filtercondition != null) {
                                            selectedIndex = operators.indexOf(columnrecord.filtercondition.toUpperCase());
                                            if (selectedIndex == -1) {
                                                selectedIndex = columnrecord.filtertype == 'number' ? 0 : 2;
                                            }
                                        }
                                        else {
                                            selectedIndex = columnrecord.filtertype == 'number' ? 0 : 2;
                                        }
                                    }
                                    dropDownList.jqxDropDownList({ selectedIndex: selectedIndex });
                                    dropDownList.jqxDropDownList('ensureVisible', selectedIndex);
                                }
                                break;
                            case 'date':
                            case 'range':
                                if (this.host.jqxDateTimeInput) {
                                    $(tablecolumn.children()[0]).jqxDateTimeInput('setDate', null);
                                }
                                else addtextfilter(this, tablecolumn);
                                break;
                            case 'textbox':
                            case 'default':
                                addtextfilter(this, tablecolumn);
                                break;
                            case 'list':
                                if (this.host.jqxDropDownList) {
                                    $(tablecolumn.children()[0]).jqxDropDownList('clearSelection');
                                }
                                else addtextfilter(this, tablecolumn);
                                break;
                            case 'checkedlist':
                                if (this.host.jqxDropDownList) {
                                    $(tablecolumn.children()[0]).jqxDropDownList('checkAll', false);
                                }
                                else addtextfilter(this, tablecolumn);
                                break;
                            case 'bool':
                            case 'boolean':
                                if (!this.host.jqxCheckBox) {
                                    addtextfilter(this, tablecolumn);
                                }
                                else $(tablecolumn.children()[0]).jqxCheckBox({ checked: null });
                                break;
                        }

                    }
                }
                this._disablefilterrow = false;
            },

            _applyfilterfromfilterrow: function () {
                if (this._disablefilterrow == true)
                    return;
                if (this.disabled) {
                    return;
                }

                var columnslength = this.columns.records.length;
                var me = this.that;

                for (var j = 0; j < columnslength; j++) {
                    var filtergroup = new $.jqx.filter();
                    var columnrecord = this.columns.records[j];
                    if (!columnrecord.filterable) continue;
                    if (columnrecord.datafield === null) continue;

                    var type = me._getcolumntypebydatafield(columnrecord);
                    var filtertype = me._getfiltertype(type);
                    var filter_or_operator = 1;
                    var hasFilter = true;
                    var columnrecordfiltertype = columnrecord.filtertype;
                    var addstringfilter = function (columnrecord, filtertype, filtergroup) {
                        var result = true;
                        if (columnrecord._filterwidget) {
                            var filtervalue = columnrecord._filterwidget.val();
                            if (filtervalue != "") {
                                var filtercondition = 'equal';
                                if (filtertype == 'stringfilter') {
                                    var filtercondition = 'contains';
                                }
                                if (filtertype == "numericfilter") {
                                    if (me.gridlocalization.decimalseparator == ',') {
                                        if (filtervalue.indexOf(me.gridlocalization.decimalseparator) >= 0) {
                                            filtervalue = filtervalue.replace(me.gridlocalization.decimalseparator, '.');
                                        }
                                    }
                                }

                                if (filtertype != 'stringfilter') {
                                    var hasoperator = 0;
                                    if (filtervalue.indexOf('>') != -1) {
                                        filtercondition = "greater_than";
                                        hasoperator = 1;
                                    }
                                    if (filtervalue.indexOf('<') != -1) {
                                        filtercondition = "less_than";
                                        hasoperator = 1;
                                    }
                                    if (filtervalue.indexOf('=') != -1) {
                                        if (filtercondition == "greater_than") {
                                            filtercondition = "greater_than_or_equal";
                                            hasoperator = 2;
                                        }
                                        else if (filtercondition == "less_than") {
                                            filtercondition = "less_than_or_equal";
                                            hasoperator = 2;
                                        }
                                        else {
                                            filtercondition = "equal";
                                            hasoperator = 1;
                                        }
                                    }
                                    if (hasoperator != 0) {
                                        filtervalue = filtervalue.substring(hasoperator);
                                        if (filtervalue.length < 1) return false;
                                    }
                                }

                                if (columnrecord.filtercondition != undefined) filtercondition = columnrecord.filtercondition;

                                if (filtertype == "datefilter") {
                                    var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition, null, columnrecord.cellsformat, me.gridlocalization);
                                }
                                else {
                                    var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition);
                                }

                                filtergroup.addfilter(filter_or_operator, filter);
                            }
                            else result = false;
                        }
                        return result;
                    }

                    switch (columnrecord.filtertype) {
                        case 'range':
                        case 'date':
                            if (columnrecord._filterwidget.jqxDateTimeInput) {
                                if (columnrecord.filtertype == "range") {
                                    var filtervalue = columnrecord._filterwidget.jqxDateTimeInput('getRange');
                                    if (filtervalue != null && filtervalue.from != null && filtervalue.to != null) {
                                        var filtercondition = 'GREATER_THAN_OR_EQUAL';
                                        var date1 = new Date(0);
                                        date1.setHours(0);
                                        date1.setMinutes(0);
                                        date1.setFullYear(filtervalue.from.getFullYear(), filtervalue.from.getMonth(), filtervalue.from.getDate());
                                        var date2 = new Date(0);
                                        date2.setHours(0);
                                        date2.setMinutes(0);
                                        date2.setFullYear(filtervalue.to.getFullYear(), filtervalue.to.getMonth(), filtervalue.to.getDate());
                                        date2.setHours(filtervalue.to.getHours());
                                        date2.setMinutes(filtervalue.to.getMinutes());
                                        date2.setSeconds(filtervalue.to.getSeconds());
                                        var filter1 = filtergroup.createfilter(filtertype, date1, filtercondition);
                                        filtergroup.addfilter(0, filter1);

                                        var filtercondition2 = 'LESS_THAN_OR_EQUAL';
                                        var filter2 = filtergroup.createfilter(filtertype, date2, filtercondition2);
                                        filtergroup.addfilter(0, filter2);
                                    }
                                    else hasFilter = false;
                                }
                                else {
                                    var filtervalue = columnrecord._filterwidget.jqxDateTimeInput('getDate');
                                    if (filtervalue != null) {
                                        var date1 = new Date(0);
                                        date1.setHours(0);
                                        date1.setMinutes(0);
                                        date1.setFullYear(filtervalue.getFullYear(), filtervalue.getMonth(), filtervalue.getDate());

                                        var showTimeButton = columnrecord._filterwidget.jqxDateTimeInput('showTimeButton');
                                        if (showTimeButton) {
                                            date1.setHours(filtervalue.getHours());
                                            date1.setMinutes(filtervalue.getMinutes());
                                        }

                                        var filtercondition = "EQUAL";
                                        if (columnrecord.filtercondition != undefined) {
                                            filtercondition = columnrecord.filtercondition;
                                        }

                                        var filter1 = filtergroup.createfilter(filtertype, date1, filtercondition);

                                        if (showTimeButton) {
                                            filter1 = filtergroup.createfilter(filtertype, date1, filtercondition, null, columnrecord.cellsformat);
                                        }

                                        filtergroup.addfilter(0, filter1);
                                    }
                                    else hasFilter = false;
                                }
                            }
                            else {
                                hasFilter = addstringfilter(columnrecord, filtertype, filtergroup);
                            }
                            break;
                        case 'input':
                            if (columnrecord._filterwidget) {
                                var filtervalue = columnrecord._filterwidget.find('input').val();
                                var index = columnrecord._filterwidget.find('.filter').jqxDropDownList('selectedIndex');
                                if (index < 0) {
                                    index = 0;
                                }
                                var condition = filtergroup.getoperatorsbyfiltertype(filtertype)[index];
                                if (me.updatefilterconditions) {
                                    var newfilterconditions = me.updatefilterconditions(filtertype, filtergroup.getoperatorsbyfiltertype(filtertype));
                                    if (newfilterconditions != undefined) {
                                        filtergroup.setoperatorsbyfiltertype(filtertype, newfilterconditions);
                                    }
                                    var condition = filtergroup.getoperatorsbyfiltertype(filtertype)[index];
                                }
                                var nullcondition1 = condition == "NULL" || condition == "NOT_NULL";
                                var emptycondition1 = condition == "EMPTY" || condition == "NOT_EMPTY";
                                if (filtervalue != undefined && filtervalue.length > 0 || nullcondition1 || emptycondition1) {
                                    filter1 = filtergroup.createfilter(filtertype, filtervalue, condition, null, columnrecord.cellsformat, me.gridlocalization);
                                    filtergroup.addfilter(0, filter1);
                                }
                                else hasFilter = false;
                            }
                            else {
                                hasFilter = false;
                            }
                            break;
                        case 'number':
                            if (columnrecord._filterwidget) {
                                var filtervalue = columnrecord._filterwidget.find('input').val();
                                if (me.gridlocalization.decimalseparator == ',') {
                                    if (filtervalue.indexOf(me.gridlocalization.decimalseparator) >= 0) {
                                        filtervalue = filtervalue.replace(me.gridlocalization.decimalseparator, '.');
                                    }
                                }
                                var index = columnrecord._filterwidget.find('.filter').jqxDropDownList('selectedIndex');
                                var condition = filtergroup.getoperatorsbyfiltertype(filtertype)[index];
                                if (me.updatefilterconditions) {
                                    var newfilterconditions = me.updatefilterconditions(filtertype, filtergroup.getoperatorsbyfiltertype(filtertype));
                                    if (newfilterconditions != undefined) {
                                        filtergroup.setoperatorsbyfiltertype(filtertype, newfilterconditions);
                                    }
                                    var condition = filtergroup.getoperatorsbyfiltertype(filtertype)[index];
                                }
                                var nullcondition1 = condition == "NULL" || condition == "NOT_NULL";
                                var emptycondition1 = condition == "EMPTY" || condition == "NOT_EMPTY";
                                if (filtervalue != undefined && filtervalue.length > 0 || nullcondition1 || emptycondition1) {
                                    filter1 = filtergroup.createfilter(filtertype, new Number(filtervalue), condition, null, columnrecord.cellsformat, me.gridlocalization);
                                    filtergroup.addfilter(0, filter1);
                                }
                                else hasFilter = false;
                            }
                            else {
                                hasFilter = false;
                            }
                            break;
                        case 'textbox':
                        case 'default':
                            hasFilter = addstringfilter(columnrecord, filtertype, filtergroup);
                            break;
                        case 'bool':
                        case 'boolean':
                            if (columnrecord._filterwidget.jqxCheckBox) {
                                var filtervalue = columnrecord._filterwidget.jqxCheckBox('checked');
                                if (filtervalue != null) {
                                    var filtercondition = 'equal';
                                    var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition);
                                    filtergroup.addfilter(filter_or_operator, filter);
                                }
                                else hasFilter = false;
                            } else hasFilter = addstringfilter(columnrecord, filtertype, filtergroup);
                            break;
                        case 'list':
                            var widget = columnrecord._filterwidget.jqxDropDownList('listBox');
                            if (widget.selectedIndex >= 0) {
                                var selectedItem = widget.getSelectedItem();
                                var filtervalue = selectedItem.label;

                                var pleaseChoose = this.gridlocalization.filterchoosestring;

                                if (filtervalue !== "Please Choose:" && filtervalue !== pleaseChoose) {
                                    var filterdatavalue = selectedItem.value;
                                    var filtercondition = 'equal';
                                    if (filtervalue === "") {
                                        filtercondition = 'NULL';
                                    }


                                    var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition);
                                    filtergroup.addfilter(filter_or_operator, filter);
                                    if (filterdatavalue !== filtervalue) {
                                        filter.data = filterdatavalue;
                                    }
                                }
                            } else {
                                hasFilter = false;
                            }
                            break;
                        case 'checkedlist':
                            if (columnrecord._filterwidget.jqxDropDownList) {
                                var widget = columnrecord._filterwidget.jqxDropDownList('listBox');
                                var checkedItems = widget.getCheckedItems();
                                if (checkedItems.length == 0) {
                                    for (var i = 1; i < widget.items.length; i++) {
                                        var filtervalue = widget.items[i].label;
                                        var filterdatavalue = widget.items[i].value;
                                        var filtercondition = 'not_equal';
                                        if (filtervalue === "") {
                                            filtercondition = 'NOT_NULL';
                                        }
                                        var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition);
                                        if (filterdatavalue !== filtervalue) {
                                            filter.data = filterdatavalue;
                                        }
                                        filtergroup.addfilter(0, filter);
                                    }

                                    hasFilter = true;
                                }
                                else {
                                    if (checkedItems.length != widget.items.length) {
                                        for (var i = 0; i < checkedItems.length; i++) {
                                            var filtervalue = checkedItems[i].label;
                                            var filterdatavalue = checkedItems[i].value;
                                            var filtercondition = 'equal';
                                            if (filtervalue === "") {
                                                filtercondition = 'NULL';
                                            }
                                            var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition);
                                            if (filterdatavalue !== filtervalue) {
                                                filter.data = filterdatavalue;
                                            }
                                            filtergroup.addfilter(filter_or_operator, filter);
                                        }
                                    }
                                    else hasFilter = false;
                                }
                            }
                            else hasFilter = addstringfilter(columnrecord, filtertype, filtergroup);
                            break;
                    }

                    if (!this._loading) {
                        if (hasFilter) {
                            this.addfilter(columnrecord.displayfield, filtergroup, false);
                        }
                        else {
                            this.removefilter(columnrecord.displayfield, false);
                        }
                    }
                }
                if (!this._loading) {
                    this.applyfilters('filterrow');
                }
            },

            _updatefilterrow: function () {
                var tablerow = $('<div style="position: relative;" id="row00' + this.element.id + '"></div>');
                var left = 0;
                var columnslength = this.columns.records.length;
                var cellclass = this.toThemeProperty('jqx-grid-cell');
                cellclass += ' ' + this.toThemeProperty('jqx-grid-cell-pinned');
                cellclass += ' ' + this.toThemeProperty('jqx-grid-cell-filter-row');
                var zindex = columnslength + 10;
                var cells = new Array();
                var me = this.that;
                this.filterrow[0].cells = cells;
                tablerow.height(this.filterrowheight);
                this.filterrow.children().detach();
                this.filterrow.append(tablerow);
                if (!this._filterrowcache)
                    this._filterrowcache = new Array();

                this._initcolumntypes();

                var usefromcache = false;
                var _newfilterrowcache = new Array();
                var frag = document.createDocumentFragment();

                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = this.columns.records[j];
                    var width = columnrecord.width;
                    if (width < columnrecord.minwidth) width = columnrecord.minwidth;
                    if (width > columnrecord.maxwidth) width = columnrecord.maxwidth;
                    var tablecolumn = document.createElement('div');
                    tablecolumn.style.overflow = "hidden";
                    tablecolumn.style.position = "absolute";
                    tablecolumn.style.height = "100%";
                    tablecolumn.className = cellclass;
                    tablecolumn = $(tablecolumn);
                    frag.appendChild(tablecolumn[0]);
                    tablecolumn[0].style.left = left + "px";
                    if (this.rtl) {
                        tablecolumn.css('z-index', zindex++);
                        tablecolumn.css('border-left-width', '1px');
                    }
                    else {
                        tablecolumn.css('z-index', zindex--);
                    }
                    if (width == "auto") width = 0;
                    tablecolumn[0].style.width = parseFloat(width) + 'px';
                    tablecolumn[0].left = left;
                    if (!(columnrecord.hidden && columnrecord.hideable)) {
                        left += width;
                    }
                    else {
                        tablecolumn.css('display', 'none');
                    }
                    cells[cells.length] = tablecolumn[0];

                    var addFilterWidget = true;
                    if (!this.rtl) {
                        if (this.groupable) {
                            var detailsoffset = (this.showrowdetailscolumn && this.rowdetails) ? 1 : 0;
                            if (this.groups.length + detailsoffset > j) {
                                addFilterWidget = false;
                            }
                        }
                        if (this.showrowdetailscolumn && this.rowdetails && j == 0) addFilterWidget = false;
                    }
                    else {
                        if (this.groupable) {
                            var detailsoffset = (this.showrowdetailscolumn && this.rowdetails) ? 1 : 0;
                            if (this.groups.length + detailsoffset + j > columnslength - 1) {
                                addFilterWidget = false;
                            }
                        }
                        if (this.showrowdetailscolumn && this.rowdetails && j == columnslength - 1) addFilterWidget = false;
                    }

                    if (addFilterWidget) {
                        if (columnrecord.filtertype == 'custom' && columnrecord.createfilterwidget) {
                            var applyfilter = function () {
                                me._applyfilterfromfilterrow();
                            }
                            columnrecord.createfilterwidget(columnrecord, tablecolumn, applyfilter);
                        }
                        else {
                            if (columnrecord.filterable) {
                                if (this._filterrowcache[columnrecord.datafield]) {
                                    usefromcache = true;
                                    tablecolumn.append(this._filterrowcache[columnrecord.datafield]);
                                    columnrecord._filterwidget = this._filterrowcache[columnrecord.datafield];
                                }
                                else {
                                    this._addfilterwidget(columnrecord, tablecolumn, width);
                                    _newfilterrowcache[columnrecord.datafield] = columnrecord._filterwidget;
                                }
                            }
                        }
                    }
                }
                tablerow[0].appendChild(frag);
                this._filterrowcache = _newfilterrowcache;
                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                    tablerow.css('z-index', zindex--);
                }

                tablerow.width(parseFloat(left) + 2);
                this.filterrow.addClass(cellclass);
                this.filterrow.css('border-top-width', '1px');
                this.filterrow.css('border-right-width', '0px');
                if (usefromcache) {
                    this._updatefilterrowui(true);
                }
            },

            _addfilterwidget: function (columnrecord, tablecolumn, width) {
                var me = this.that;
                var that = this;
                var filtervalue = "";
                var condition = "";
                for (var f = 0; f < me.dataview.filters.length; f++) {
                    var currentfilter = me.dataview.filters[f];
                    if (currentfilter.datafield && currentfilter.datafield == columnrecord.datafield) {
                        var f = currentfilter.filter.getfilters()[0];
                        filtervalue = f.value;
                        if (columnrecord.filtertype === "range") {
                            filtervalue = { from: filtervalue, to: currentfilter.filter.getfilters()[1].value };
                        }

                        condition = f.condition;
                        columnrecord.filtercondition = condition;
                        break;
                    }
                }

                var addtextfilter = function (me, tablecolumn) {
                    var textbox = $('<input autocomplete="off" type="textarea"/>');
                    textbox.attr('tabindex', 5 + columnrecord.visibleindex);
                    textbox[0].id = $.jqx.utilities.createId();
                    textbox.addClass(me.toThemeProperty('jqx-widget'));
                    textbox.addClass(me.toThemeProperty('jqx-filter-input jqx-input jqx-input-widget'));
                    textbox.addClass(me.toThemeProperty('jqx-rc-all'));
                    textbox.addClass(me.toThemeProperty('jqx-widget-content'));
                    if (me.rtl) {
                        textbox.css('direction', 'rtl');
                    }
                    if (me.disabled) {
                        textbox.attr('disabled', true);
                    }
                    textbox.attr('disabled', false);

                    textbox.appendTo(tablecolumn);
                    textbox.css('margin', '4px');
                    textbox.width(width - 8);
                    textbox.height(me.filterrowheight - 9);
                    if (columnrecord.createfilterwidget) {
                        columnrecord.createfilterwidget(columnrecord, tablecolumn, textbox);
                    }
                    columnrecord._filterwidget = textbox;

                    textbox.focus(function () {
                        me.content[0].scrollLeft = 0;
                        setTimeout(function () {
                            me.content[0].scrollLeft = 0;
                        }, 10);

                        me.focusedfilter = textbox;
                        textbox.addClass(me.toThemeProperty('jqx-fill-state-focus'));
                        return false;
                    });
                    textbox.blur(function () {
                        textbox.removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                    });


                    textbox.keydown(function (event) {
                        if (event.keyCode == '13')
                            me._applyfilterfromfilterrow();
                        if (textbox[0]._writeTimer) clearTimeout(textbox[0]._writeTimer);
                        textbox[0]._writeTimer = setTimeout(function () {
                            if (!me._loading) {
                                if (!me["_oldWriteText" + textbox[0].id])
                                    me["_oldWriteText" + textbox[0].id] = "";
                                if (me["_oldWriteText" + textbox[0].id].length > 0 && me["_oldWriteText" + textbox[0].id] != textbox.val()) {
                                    me._applyfilterfromfilterrow();
                                    me["_oldWriteText" + textbox[0].id] = textbox.val();
                                }
                                else if (me["_oldWriteText" + textbox[0].id].length == 0) {
                                    me._applyfilterfromfilterrow();
                                    me["_oldWriteText" + textbox[0].id] = textbox.val();
                                }
                            }
                        }, columnrecord.filterdelay);
                        me.focusedfilter = textbox;
                    });
                    me.host.removeClass('jqx-disableselect');
                    me.content.removeClass('jqx-disableselect');
                    textbox.val(filtervalue);
                }

                if (columnrecord.datatype != null) {
                    if (columnrecord.filtertype == "number") {
                        if (columnrecord.datatype == "string" || columnrecord.datatype == "date" || columnrecord.datatype == "bool") {
                            columnrecord.filtertype = "textbox";
                        }
                    }
                    if (columnrecord.filtertype == "date") {
                        if (columnrecord.datatype == "string" || columnrecord.datatype == "number" || columnrecord.datatype == "bool") {
                            columnrecord.filtertype = "textbox";
                        }
                    }
                    if (columnrecord.filtertype == "bool") {
                        if (columnrecord.datatype == "string" || columnrecord.datatype == "number" || columnrecord.datatype == "date") {
                            columnrecord.filtertype = "textbox";
                        }
                    }
                }

                switch (columnrecord.filtertype) {
                    case 'number':
                    case 'input':
                        var numberwidget = $("<div></div>");
                        numberwidget.width(tablecolumn.width());
                        numberwidget.height(this.filterrowheight);
                        tablecolumn.append(numberwidget);
                        var addonwidth = 20;
                        if (this.theme === 'fluent') {
                            addonwidth = 25;
                        }

                        var width = tablecolumn.width() - addonwidth - 1;
                        var addInput = function (element, width, sign) {
                            var textbox = $('<input style="float: left;" autocomplete="off" type="textarea"/>');
                            if (me.rtl) {
                                textbox.css('float', 'right');
                                textbox.css('direction', 'rtl');
                            }
                            textbox.attr('tabindex', 5 + columnrecord.visibleindex);
                            textbox[0].id = $.jqx.utilities.createId();
                            textbox.addClass(me.toThemeProperty('jqx-widget jqx-input jqx-rc-all jqx-input-widget jqx-filter-input jqx-widget-content'));
                            textbox.appendTo(element);
                            textbox.width(width - 10);
                            if (me.disabled) {
                                textbox.attr('disabled', true);
                            }
                            textbox.attr('disabled', false);

                            textbox[0].style.height = me.filterrowheight - 9 + "px";
                            textbox.css('margin', '4px');
                            textbox.css('margin-right', '3px');
                            textbox.focus(function () {
                                me.focusedfilter = textbox;
                                textbox.addClass(me.toThemeProperty('jqx-fill-state-focus'));
                            });
                            textbox.blur(function () {
                                textbox.removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                            });
                            textbox.keydown(function (event) {
                                if (event.keyCode == '13')
                                    me._applyfilterfromfilterrow();
                                if (event.keyCode == '9') {
                                    return;
                                }

                                if (textbox[0]._writeTimer) clearTimeout(textbox[0]._writeTimer);
                                textbox[0]._writeTimer = setTimeout(function () {
                                    if (!me._loading) {
                                        if (me["_oldWriteText" + textbox[0].id] != textbox.val()) {
                                            me._applyfilterfromfilterrow();
                                            me["_oldWriteText" + textbox[0].id] = textbox.val();
                                        }
                                    }
                                }, columnrecord.filterdelay);
                                me.focusedfilter = textbox;
                            });
                            textbox.val(filtervalue);
                            return textbox;
                        }

                        addInput(numberwidget, width);
                        var source = me._getfiltersbytype(columnrecord.filtertype == 'number' ? 'number' : 'string');
                        var dropdownlist = $("<div class='filter' style='float: left;'></div>");
                        dropdownlist.css('margin-top', '4px');
                        dropdownlist.appendTo(numberwidget);
                        if (me.rtl) {
                            dropdownlist.css('float', 'right');
                        }

                        var selectedIndex = 0;
                        if (columnrecord.filtercondition != null) {
                            var f = new $.jqx.filter();

                            var conditions = f.getoperatorsbyfiltertype(columnrecord.filtertype == 'number' ? 'numericfilter' : 'stringfilter');
                            var newIndex = conditions.indexOf(columnrecord.filtercondition.toUpperCase());
                            if (newIndex != -1)
                                selectedIndex = newIndex;
                        }
                        var dropDownWidth = 180;
                        if (columnrecord.filtertype == "input") {
                            dropDownWidth = 240;
                            if (selectedIndex == 0) {
                                var newIndex = source.indexOf("contains") >= 0 ? source.indexOf("contains") : 2;
                                if (newIndex != -1 && columnrecord.filtercondition == null) {
                                    selectedIndex = newIndex;
                                }
                                else {
                                    selectedIndex = -1;
                                }
                            }
                        }


                        dropdownlist.jqxDropDownList({ disabled: me.disabled, touchMode: me.touchmode, rtl: me.rtl, dropDownHorizontalAlignment: 'right', enableBrowserBoundsDetection: true, selectedIndex: selectedIndex, width: addonwidth, height: 27, dropDownHeight: 150, dropDownWidth: dropDownWidth, source: source, theme: me.theme });
                        dropdownlist.jqxDropDownList({
                            selectionRenderer: function (element) {
                                return "";
                            }
                        });
                        dropdownlist.attr('tabindex', 5 + columnrecord.visibleindex);
                        dropdownlist.jqxDropDownList('setContent', "");
                        dropdownlist.find('.jqx-dropdownlist-content').hide();
                        if (columnrecord.createfilterwidget) {
                            columnrecord.createfilterwidget(columnrecord, tablecolumn, numberwidget);
                        }
                        columnrecord._filterwidget = numberwidget;

                        var lastSelectedItem = null;

                        this.addHandler(dropdownlist, 'open', function () {
                            that._activeFilterElement = dropdownlist;
                        });

                        this.addHandler(dropdownlist, 'select', function () {
                            var selectedItem = dropdownlist.jqxDropDownList('getSelectedItem');
                            if (selectedItem) {
                                selectedItem = selectedItem.label;
                            }
                            else {
                                selectedItem = 'contains';
                            }

                            if (columnrecord._filterwidget.find('input').val().length > 0 && !me.refreshingfilter) {
                                me._applyfilterfromfilterrow();
                            }
                            if (columnrecord.filtertype == "input" && !me.refreshingfilter) {
                                me._applyfilterfromfilterrow();
                            }
                            else if (columnrecord._filterwidget.find('input').val().length == 0 && !me.refreshingfilter) {
                                if (lastSelectedItem == 'null' || lastSelectedItem == 'not null' || selectedItem == 'null' || selectedItem == 'not null') {
                                    me._applyfilterfromfilterrow();
                                }
                            }
                            lastSelectedItem = selectedItem;
                        });
                        break;
                    case 'textbox':
                    case 'default':
                    default:
                        addtextfilter(this, tablecolumn);
                        break;
                    case 'none':
                        break;
                    case 'date':
                    case 'range':
                        if (this.host.jqxDateTimeInput) {
                            var datetimeinput = $("<div></div>");
                            datetimeinput.css('margin', '4px');
                            datetimeinput.css('margin-left', '5px');
                            datetimeinput.appendTo(tablecolumn);
                            var localization = { calendar: this.gridlocalization, todayString: this.gridlocalization.todaystring, clearString: this.gridlocalization.clearstring };
                            datetimeinput.jqxDateTimeInput({
                                firstDayOfWeek: this.gridlocalization.firstDay, readonly: true, disabled: me.disabled, localization: localization, rtl: me.rtl, showFooter: true, formatString: columnrecord.cellsformat, selectionMode: columnrecord.filtertype, value: null, theme: this.theme, width: width - 9,
                                height: this.theme === 'fluent' ? 20 : this.filterrowheight - 9
                            });
                            if (columnrecord.createfilterwidget) {
                                columnrecord.createfilterwidget(columnrecord, tablecolumn, datetimeinput);
                            }
                            if (filtervalue && filtervalue.from) {
                                datetimeinput.jqxDateTimeInput('setRange', filtervalue.from, filtervalue.to);
                            }
                            else if (filtervalue && filtervalue.toString().length > 1) {
                                datetimeinput.val(filtervalue);
                            }

                            datetimeinput.find('input').attr('tabindex', 5 + columnrecord.visibleindex);
                            columnrecord._filterwidget = datetimeinput;
                            this.addHandler(datetimeinput, 'valueChanged', function (event) {
                                if (!me.refreshingfilter) {
                                    me._applyfilterfromfilterrow();
                                    me.focusedfilter = null;
                                }
                            });
                        }
                        else addtextfilter(this, tablecolumn);
                        break;
                    case 'list':
                    case 'checkedlist':
                        if (this.host.jqxDropDownList) {
                            var dataadapter = this._getfilterdataadapter(columnrecord);

                            var autoheight = false;
                            var dropdownlist = $("<div></div>");
                            dropdownlist.css('margin', '4px');
                            dropdownlist.css('margin-left', '5px');
                            var datafield = columnrecord.datafield;
                            var checkboxes = columnrecord.filtertype == 'checkedlist' ? true : false;
                            var dropDownWidth = width < 150 ? 220 : 'auto';
                            dataadapter.dataBind();
                            var dropdownitems = dataadapter.records;
                            var autoDropDownHeight = dropdownitems.length < 8 ? true : false;
                            autoheight = autoDropDownHeight;
                            dropdownlist.appendTo(tablecolumn);
                            dropdownlist.jqxDropDownList({ hint: false, placeHolder: me.gridlocalization.filterchoosestring, disabled: me.disabled, touchMode: me.touchmode, rtl: me.rtl, checkboxes: checkboxes, dropDownWidth: dropDownWidth, source: dataadapter.records, autoDropDownHeight: autoDropDownHeight, theme: this.theme, width: width - 9, height: this.filterrowheight - 9, displayMember: columnrecord.displayfield, valueMember: datafield });
                            dropdownlist.attr('tabindex', 5 + columnrecord.visibleindex);
                            dropdownlist.attr('default-placeholder', true);
                            if (columnrecord.createfilterwidget) {
                                columnrecord.createfilterwidget(columnrecord, tablecolumn, dropdownlist);
                            }
                            this.addHandler(dropdownlist, 'open', function () {
                                that._activeFilterElement = dropdownlist;
                            });
                            var listbox = dropdownlist.jqxDropDownList('listBox');
                            if (checkboxes) {
                                dropdownlist.jqxDropDownList({
                                    selectionRenderer: function () {
                                        var spanElement = '<span class="' + me.toThemeProperty('jqx-item') + '" style="top: 4px; position: relative; color: inherit; border: none; background-color: transparent;">' + me.gridlocalization.filterselectstring + '</span>';
                                        return spanElement;
                                    }
                                });
                                var spanElement = $('<span style="top: 2px; position: relative; color: inherit; border: none; background-color: transparent;">' + me.gridlocalization.filterselectstring + '</span>');
                                spanElement.addClass(this.toThemeProperty('jqx-item'));
                                if (listbox != undefined) {
                                    if (!autoheight) {
                                        listbox.host.height(200);
                                    }
                                    listbox.insertAt({ label: me.gridlocalization.filterselectallstring }, 0);
                                    dropdownlist.jqxDropDownList('setContent', spanElement);
                                    var handleCheckChange = true;
                                    var checkedItems = new Array();
                                    listbox.checkAll(false);
                                    me.addHandler(listbox.host, 'checkChange', function (event) {
                                        dropdownlist[0]._selectionChanged = true;
                                        if (!handleCheckChange)
                                            return;

                                        if (event.args.label != me.gridlocalization.filterselectallstring) {
                                            handleCheckChange = false;
                                            listbox.host.jqxListBox('checkIndex', 0, true, false);
                                            var checkedItems = listbox.host.jqxListBox('getCheckedItems');
                                            var items = listbox.host.jqxListBox('getItems');

                                            if (checkedItems.length == 1) {
                                                listbox.host.jqxListBox('uncheckIndex', 0, true, false);
                                            }
                                            else if (items.length != checkedItems.length) {
                                                listbox.host.jqxListBox('indeterminateIndex', 0, true, false);
                                            }
                                            handleCheckChange = true;
                                        }
                                        else {
                                            handleCheckChange = false;
                                            if (event.args.checked) {
                                                listbox.host.jqxListBox('checkAll', false);
                                            }
                                            else {
                                                listbox.host.jqxListBox('uncheckAll', false);
                                            }

                                            handleCheckChange = true;
                                        }
                                    });
                                }
                            }
                            else {
                                listbox.insertAt({ label: this.gridlocalization.filterchoosestring, value: "" }, 0);
                                dropdownlist.jqxDropDownList({ selectedIndex: 0 });
                            }
                            columnrecord._filterwidget = dropdownlist;

                            var dropdownlistWrapper = dropdownlist.jqxDropDownList('dropdownlistWrapper');
                            if (columnrecord.filtertype == 'list') {
                                this.addHandler(dropdownlist, 'select', function (event) {
                                    if (!me.refreshingfilter) {
                                        if (event.args && event.args.type != 'none') {
                                            me._applyfilterfromfilterrow();
                                            me.focusedfilter = null;
                                        }
                                    }
                                });
                            }
                            else {
                                this.addHandler(dropdownlist, 'close', function (event) {
                                    if (dropdownlist[0]._selectionChanged) {
                                        me._applyfilterfromfilterrow();
                                        me.focusedfilter = null;
                                        dropdownlist[0]._selectionChanged = false;
                                    }
                                });
                            }
                        }
                        else addtextfilter(this, tablecolumn);
                        break;
                    case 'bool':
                    case 'boolean':
                        if (this.host.jqxCheckBox) {
                            var checkbox = $('<div tabIndex=0 style="opacity: 0.99; position: absolute; top: 50%; left: 50%; margin-top: -9px; margin-left: -12px;"></div>');
                            checkbox.appendTo(tablecolumn);
                            checkbox.jqxCheckBox({ disabled: me.disabled, enableContainerClick: false, animationShowDelay: 0, animationHideDelay: 0, hasThreeStates: true, theme: this.theme, checked: null });
                            checkbox.attr('tabindex', 5 + columnrecord.visibleindex);
                            if (columnrecord.createfilterwidget) {
                                columnrecord.createfilterwidget(columnrecord, tablecolumn, checkbox);
                            }
                            if (filtervalue === true || filtervalue == "true") {
                                checkbox.jqxCheckBox({ checked: true });
                            }
                            else if (filtervalue === false || filtervalue == "false") {
                                checkbox.jqxCheckBox({ checked: false });
                            }

                            columnrecord._filterwidget = checkbox;
                            this.addHandler(checkbox, 'change', function (event) {
                                if (!me.refreshingfilter) {
                                    if (event.args) {
                                        me.focusedfilter = null;
                                        me._applyfilterfromfilterrow();
                                    }
                                }
                            });
                        }
                        else addtextfilter(this, tablecolumn);
                        break;
                }
            },

            _getfilterdataadapter: function (columnrecord) {
                var isdataadapter = this.source._source ? true : false;

                if (!isdataadapter) {
                    var dataadapter = new $.jqx.dataAdapter(this.source,
                        {
                            autoBind: false,
                            uniqueDataFields: [columnrecord.displayfield],
                            autoSort: true,
                            autoSortField: columnrecord.displayfield,
                            async: false
                        });
                }
                else {
                    var dataSource =
                    {
                        localdata: $.extend(true, {}, this.source.records),
                        datatype: this.source.datatype,
                        async: false
                    }
                    var that = this;
                    var dataadapter = new $.jqx.dataAdapter(dataSource,
                        {
                            autoBind: false,
                            autoSort: true,
                            autoSortField: columnrecord.displayfield,
                            async: false,
                            uniqueDataFields: [columnrecord.displayfield],
                            beforeLoadComplete: function (records) {
                                var data = new Array();
                                if (columnrecord.cellsformat) {
                                    var columntype = that._getcolumntypebydatafield(columnrecord);

                                    for (var i = 0; i < records.length; i++) {
                                        data.push(records[i]);
                                        var value = records[i][columnrecord.displayfield];
                                        records[i][columnrecord.displayfield + "JQValue"] = value;
                                        if (columntype === "date") {
                                            if (value != null) {
                                                records[i][columnrecord.displayfield] = dataadapter.formatDate(value, columnrecord.cellsformat, that.gridlocalization);
                                            }
                                            else {
                                                records[i][columnrecord.displayfield] = "";
                                            }
                                        }
                                        else if (columntype === "number" || columntype === "float" || columntype === "int") {
                                            if (value != null) {
                                                records[i][columnrecord.displayfield] = dataadapter.formatNumber(value, columnrecord.cellsformat, that.gridlocalization);
                                            }
                                            else {
                                                records[i][columnrecord.displayfield] = "";
                                            }
                                        }
                                    }
                                    return data;
                                }
                                else return records;
                            }
                        });
                }
                if (columnrecord.filteritems && columnrecord.filteritems.length > 0) {
                    var dataSource =
                    {
                        localdata: columnrecord.filteritems,
                        datatype: this.source.datatype,
                        async: false
                    }

                    var dataadapter = new $.jqx.dataAdapter(dataSource,
                        {
                            autoBind: false,
                            async: false
                        });
                }
                else if (columnrecord.filteritems) {
                    if (columnrecord.filteritems._source) {
                        columnrecord.filteritems._options.autoBind = false;
                        columnrecord.filteritems._options.async = false;

                        return columnrecord.filteritems;
                    }
                    else if ($.isFunction(columnrecord.filteritems)) {
                        return columnrecord.filteritems();
                    }
                }

                return dataadapter;
            },

            refreshfilterrow: function () {
                if (!this.showfilterrow) {
                    return;
                }

                this.refreshingfilter = true;
                this._updatefilterrowui();
                this._updatelistfilters(true, true);
                var me = this.that;
                var columnslength = this.columns.records.length;
                for (var j = 0; j < columnslength; j++) {
                    var column = this.columns.records[j];
                    if (column.filterable) {
                        if (column.filter) {
                            var filters = column.filter.getfilters();
                            if (filters.length > 0) {
                                var value = filters[0].value;
                                var widget = column._filterwidget;
                                var tablecolumn = column._filterwidget.parent();
                                if (widget != null) {
                                    switch (column.filtertype) {
                                        case 'number':
                                            tablecolumn.find('input').val(value);
                                            if (this.host.jqxDropDownList) {
                                                var conditions = column.filter.getoperatorsbyfiltertype('numericfilter');
                                                widget.find('.filter').jqxDropDownList('selectIndex', conditions.indexOf(filters[0].condition));
                                            }
                                            break;
                                        case 'input':
                                            tablecolumn.find('input').val(value);
                                            if (this.host.jqxDropDownList) {
                                                var conditions = column.filter.getoperatorsbyfiltertype('stringfilter');
                                                widget.find('.filter').jqxDropDownList('selectIndex', conditions.indexOf(filters[0].condition));
                                            }
                                            break;
                                        case 'date':
                                        case 'range':
                                            if (this.host.jqxDateTimeInput) {
                                                var value = column.filter.getfilterat(0).filtervalue;
                                                if (value != undefined) {
                                                    if (column.filter.getfilterat(1)) {
                                                        var value2 = column.filter.getfilterat(1).filtervalue;
                                                    }
                                                    else {
                                                        value2 = value;
                                                    }
                                                    if (column.filtertype == "range") {
                                                        var from = new Date(value);
                                                        var to = new Date(value2);
                                                        if (isNaN(from)) {
                                                            from = $.jqx.dataFormat.tryparsedate(value);
                                                        }
                                                        if (isNaN(to)) {
                                                            to = $.jqx.dataFormat.tryparsedate(value);
                                                        }

                                                        $(tablecolumn.children()[0]).jqxDateTimeInput('setRange', from, to);
                                                    }
                                                    else {
                                                        $(tablecolumn.children()[0]).jqxDateTimeInput('setDate', new Date(value));
                                                    }
                                                }
                                            }
                                            else {
                                                widget.val(value);
                                            }
                                            break;
                                        case 'textbox':
                                        case 'default':
                                            widget.val(value);
                                            me["_oldWriteText" + widget[0].id] = value;
                                            break;
                                        case 'bool':
                                        case 'boolean':
                                            if (!this.host.jqxCheckBox) {
                                                widget.val(value);
                                            }
                                            else $(tablecolumn.children()[0]).jqxCheckBox({ checked: value });
                                            break;
                                    }
                                }
                            }
                        }
                    }
                }
                this.refreshingfilter = false;
            },

            _destroyedfilters: function () {
                var me = this.that;
                var columnslength = this.columns.records.length;
                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = this.columns.records[j];
                    if (columnrecord.filterable) {
                        var widget = columnrecord._filterwidget;
                        if (columnrecord.filtertype == 'list' || columnrecord.filtertype == 'checkedlist') {
                            this.removeHandler(widget, 'select');
                            this.removeHandler(widget, 'close');
                            widget.jqxDropDownList('destroy');
                        }
                        else if (columnrecord.filtertype == 'date' || columnrecord.filtertype == 'range') {
                            this.removeHandler(widget, 'valueChanged');
                            widget.jqxDateTimeInput('destroy');
                        }
                        else if (columnrecord.filtertype == 'bool') {
                            this.removeHandler(widget, 'change');
                            widget.jqxCheckBox('destroy');
                        }
                        else if (columnrecord.filtertype == 'number' || columnrecord.filtertype === 'input') {
                            var input = widget.find('.jqx-input');
                            this.removeHandler(input, 'keydown');
                            var dropdownlist = $(widget.children()[1]);
                            dropdownlist.jqxDropDownList('destroy');
                        }
                        else {
                            this.removeHandler(widget, 'keydown');
                        }
                        widget.remove();
                    }
                }
            },

            _updatelistfilters: function (endcelledit, updatecheckstates) {
                var me = this.that;
                var columnslength = this.columns.records.length;
                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = this.columns.records[j];
                    if (columnrecord.filterable) {
                        if (columnrecord.filtertype == 'list' || columnrecord.filtertype == 'checkedlist') {
                            var dropdownlist = columnrecord._filterwidget;
                            if (!endcelledit) {
                                if (columnrecord.filter == undefined) {
                                    dropdownlist.jqxDropDownList('renderSelection');
                                    continue;
                                }
                            }
                            else {
                                var dataadapter = this._getfilterdataadapter(columnrecord);
                                dropdownlist.jqxDropDownList({ source: dataadapter });
                                var dropdownitems = dropdownlist.jqxDropDownList('getItems');
                                var equalSources = true;
                                if (dropdownitems.length != dataadapter.records.length + 1)
                                    equalSources = false;

                                if (equalSources) {
                                    for (var i = 1; i < dropdownitems.length; i++) {
                                        if (dropdownitems[i].label != dataadapter.records[i - 1][columnrecord.displayfield]) {
                                            equalSources = false;
                                            break;
                                        }
                                    }
                                }
                                if (equalSources && !updatecheckstates)
                                    continue;
                            }

                            var checkboxes = columnrecord.filtertype == 'checkedlist' ? true : false;
                            var dropdownitems = dropdownlist.jqxDropDownList('getItems');
                            var listbox = dropdownlist.jqxDropDownList('listBox');
                            dropdownlist.jqxDropDownList('dataBind');

                            if (checkboxes) {
                                dropdownlist.jqxDropDownList({
                                    selectionRenderer: function () {
                                        return me.gridlocalization.filterselectstring;
                                    }
                                });
                                if (listbox.getItem(this.gridlocalization.filterselectallstring) == null) {
                                    listbox.insertAt({ label: this.gridlocalization.filterselectallstring }, 0);
                                }

                                var spanElement = $('<span style="top: 2px; position: relative; color: inherit; border: none; background-color: transparent;">' + this.gridlocalization.filterselectstring + '</span>');
                                spanElement.addClass(this.toThemeProperty('jqx-item'));
                                dropdownlist.jqxDropDownList('setContent', spanElement);
                                listbox.checkAll(false);
                                if (columnrecord.filter) {
                                    var filters = columnrecord.filter.getfilters();

                                    for (var i = 0; i < listbox.items.length; i++) {
                                        var label = listbox.items[i].label;
                                        var filterresult = undefined;
                                        $.each(filters, function () {
                                            var result;
                                            if (this.condition == "NOT_EQUAL") {
                                                if (label == this.value) {
                                                    result = false;
                                                }
                                                else {
                                                    result = true;
                                                }
                                            }
                                            else if (this.condition == "EQUAL") {
                                                if (label == this.value) {
                                                    result = true;
                                                }
                                                else {
                                                    result = false;
                                                }
                                            }
                                            if (filterresult == undefined && result !== undefined) filterresult = result;
                                            else {
                                                if (this.condition == "EQUAL") {
                                                    filterresult = filterresult || result;
                                                }
                                                else {
                                                    filterresult = filterresult && result;
                                                }
                                            }
                                        });
                                        if (filterresult)
                                            listbox.checkIndex(i, false, false);
                                        else {
                                            listbox.uncheckIndex(i, false, false);
                                        }
                                    }
                                    listbox._updateCheckedItems();
                                    var checkedItemsLength = listbox.getCheckedItems().length;
                                    if (listbox.items.length != checkedItemsLength && checkedItemsLength > 0) {
                                        listbox.host.jqxListBox('indeterminateIndex', 0, true, false);
                                    }
                                }
                            }
                            else {
                                if (listbox.getItem(this.gridlocalization.filterchoosestring) == null) {
                                    if (listbox.items[0].label !== this.gridlocalization.filterchoosestring) {
                                        listbox.insertAt({ label: this.gridlocalization.filterchoosestring, value: "" }, 0);
                                    }
                                }

                                dropdownlist.jqxDropDownList({ selectedIndex: 0 });
                                if (columnrecord.filter) {
                                    var filters = columnrecord.filter.getfilters();
                                    var selectedIndex = -1;
                                    for (var i = 0; i < listbox.items.length; i++) {
                                        var label = listbox.items[i].label;
                                        $.each(filters, function () {
                                            if (this.condition == "NOT_EQUAL") return true;
                                            if (label == this.value) {
                                                selectedIndex = i;
                                                return false;
                                            }
                                        });
                                    }
                                    if (selectedIndex != -1) {
                                        listbox.selectIndex(selectedIndex);
                                    }
                                }
                            }
                            if (dropdownitems.length < 8) {
                                dropdownlist.jqxDropDownList('autoDropDownHeight', true);
                            }
                            else {
                                dropdownlist.jqxDropDownList('autoDropDownHeight', false);
                            }
                        }
                    }
                }
            },

            _renderfiltercolumn: function () {
                var self = this.that;

                if (this.filterable) {
                    if (!this.columns.records) return;
                    $.each(this.columns.records, function (i, value) {
                        var filtered = false;
                        if (self.autoshowfiltericon) {
                            if (this.filter) {
                                $(this.filtericon).show();
                                filtered = true;
                            }
                            else {
                                $(this.filtericon).hide();
                            }
                        }
                        else {
                            if (this.filterable) {
                                $(this.filtericon).show();
                                filtered = true;
                            }
                        }

                        this.element.removeAttribute('filter');
                        if (filtered) {
                            this.element.setAttribute('filter', true);
                        }

                        if (this.align == "right" && !this.renderer) {
                            if (this.element) {
                                if (!filtered) {
                                    this.element.firstChild.firstChild.style.marginRight = '2px';
                                }
                                else {
                                    this.element.firstChild.firstChild.style.marginRight = '18px';
                                }
                            }
                        }
                    });
                }
            },

            _initcolumntypes: function () {
                if (this.columns && this.columns.records) {
                    var datafields = this.source._source.datafields;
                    if (datafields) {
                        for (var i = 0; i < this.columns.records.length; i++) {
                            var column = this.columns.records[i];
                            if (column.datatype) continue;
                            var foundType = "";
                            $.each(datafields, function () {
                                if (this.name == column.displayfield) {
                                    if (this.type) {
                                        foundType = this.type;
                                    }
                                    return false;
                                }
                            });
                            if (foundType != "")
                                column.datatype = foundType;
                            else column.datatype = "";
                        }
                    }
                }
            },

            _getcolumntypebydatafield: function (column) {
                var me = this.that;
                var type = 'string';
                var datafields = me.source.datafields || ((me.source._source) ? me.source._source.datafields : null);

                if (datafields) {
                    var foundType = "";
                    $.each(datafields, function () {
                        if (this.name == column.displayfield) {
                            if (this.type) {
                                foundType = this.type;
                            }
                            return false;
                        }
                    });
                    if (foundType)
                        return foundType;
                }

                if (column != null) {
                    if (this.dataview.cachedrecords == undefined) {
                        return type;
                    }

                    var cell = null;

                    if (!this.virtualmode) {
                        if (this.dataview.cachedrecords.length == 0)
                            return type;

                        cell = this.dataview.cachedrecords[0][column.displayfield];
                        if (cell != null && cell.toString() == "") {
                            return "string";
                        }
                    }
                    else {
                        $.each(this.dataview.cachedrecords, function () {
                            cell = this[column.displayfield];
                            return false;
                        });
                    }

                    if (cell != null) {
                        if (typeof cell == 'boolean') {
                            type = 'boolean';
                        }
                        else if ($.jqx.dataFormat.isNumber(cell)) {
                            type = 'number';
                        }
                        else {
                            var tmpvalue = new Date(cell);

                            if (tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date") {
                                if ($.jqx.dataFormat) {
                                    tmpvalue = $.jqx.dataFormat.tryparsedate(cell);
                                    if (tmpvalue != null) {
                                        if (tmpvalue && tmpvalue.getFullYear()) {
                                            if (tmpvalue.getFullYear() == 1970 && tmpvalue.getMonth() == 0 && tmpvalue.getDate() == 1) {
                                                var num = new Number(cell);
                                                if (!isNaN(num))
                                                    return 'number';

                                                return 'string';
                                            }
                                        }

                                        return 'date';
                                    }
                                    else {
                                        type = 'string';
                                    }
                                }
                                else type = 'string';
                            }
                            else {
                                type = 'date';
                            }
                        }
                    }
                }
                return type;
            },

            _getfiltersbytype: function (type) {
                var me = this.that;
                var source = '';
                switch (type) {
                    case "number":
                    case "float":
                    case "int":
                        source = me.gridlocalization.filternumericcomparisonoperators;
                        break;
                    case "date":
                        source = me.gridlocalization.filterdatecomparisonoperators;
                        break;
                    case "boolean":
                    case "bool":
                        source = me.gridlocalization.filterbooleancomparisonoperators;
                        break;
                    case "string":
                    default:
                        source = me.gridlocalization.filterstringcomparisonoperators;
                        break;

                }
                return source;
            },

            _getfiltertype: function (type) {
                var filtertype = "stringfilter";
                switch (type) {
                    case "number":
                    case "int":
                    case "float":
                    case "decimal":
                        filtertype = 'numericfilter';
                        break;
                    case "boolean":
                    case "bool":
                        filtertype = 'booleanfilter';
                        break;
                    case "date":
                    case "time":
                    case "range":
                        filtertype = 'datefilter';
                        break;
                    case "string":
                    case "input":
                        filtertype = 'stringfilter';
                        break;
                }
                return filtertype;
            },

            _buildfilter: function (me, element, column) {
                var condition = $(element).find('.filter1');
                var operator = $(element).find('.filter2');
                var condition2 = $(element).find('.filter3');
                var input1 = $(element).find('.filtertext1' + me.element.id);
                var input2 = $(element).find('.filtertext2' + me.element.id);
                var value1 = input1.val();
                var value2 = input2.val();
                var type = me._getcolumntypebydatafield(column);
                var source = me._getfiltersbytype(type);

                var filtergroup = new $.jqx.filter();
                var filtertype = me._getfiltertype(type);
                if (me.filtermode === "default" && (column.filtertype !== "list" && column.filtertype !== "checkedlist")) {
                    var index1 = condition.jqxDropDownList('selectedIndex');
                    var operatorindex = operator.jqxDropDownList('selectedIndex');
                    var index2 = condition2.jqxDropDownList('selectedIndex');

                    var filter1 = null;
                    var filter2 = null;

                    if (me.updatefilterconditions) {
                        var newfilterconditions = me.updatefilterconditions(filtertype, filtergroup.getoperatorsbyfiltertype(filtertype));
                        if (newfilterconditions != undefined) {
                            filtergroup.setoperatorsbyfiltertype(filtertype, newfilterconditions);
                        }
                    }

                    var isvalidfilter = false;
                    var condition1 = filtergroup.getoperatorsbyfiltertype(filtertype)[index1];
                    var condition2 = filtergroup.getoperatorsbyfiltertype(filtertype)[index2];
                    var nullcondition1 = condition1 == "NULL" || condition1 == "NOT_NULL";
                    var emptycondition1 = condition1 == "EMPTY" || condition1 == "NOT_EMPTY";

                    if (condition1 == undefined) condition1 = filtergroup.getoperatorsbyfiltertype(filtertype)[0];
                    if (condition2 == undefined) condition2 = filtergroup.getoperatorsbyfiltertype(filtertype)[0];

                    if (value1.length > 0 || nullcondition1 || emptycondition1) {
                        filter1 = filtergroup.createfilter(filtertype, value1, condition1, null, column.cellsformat, me.gridlocalization);
                        filtergroup.addfilter(operatorindex, filter1);
                        isvalidfilter = true;
                    }

                    var nullcondition2 = condition2 == "NULL" || condition2 == "NOT_NULL";
                    var emptycondition2 = condition2 == "EMPTY" || condition2 == "NOT_EMPTY";

                    if (value2.length > 0 || nullcondition2 || emptycondition2) {
                        filter2 = filtergroup.createfilter(filtertype, value2, condition2, null, column.cellsformat, me.gridlocalization);
                        filtergroup.addfilter(operatorindex, filter2);
                        isvalidfilter = true;
                    }

                    if (isvalidfilter) {
                        var datafield = column.displayfield;
                        this.addfilter(datafield, filtergroup, true);
                    }
                    else {
                        this._clearfilter(me, element, column);
                    }
                }
                else if (me.filtermode === "excel" || (column.filtertype === "list" || column.filtertype === "checkedlist")) {
                    var that = this;
                    var hasFilter = false;
                    var widget = condition.data().jqxListBox.instance;
                    var checkboxes = this.filtermode === "excel" || column.filtertype === "checkedlist";
                    var checkedItems = widget.getCheckedItems();
                    if (!checkboxes) {
                        var checkedItems = widget.getSelectedItems();
                    }
                    if (checkedItems.length == 0) {
                        for (var i = 1; i < widget.items.length; i++) {
                            var filtervalue = widget.items[i].value;
                            if (filtervalue === undefined) filtervalue = "";
                            var filtercondition = 'not_equal';

                            if (filtervalue && filtervalue.indexOf) {
                                if (filtervalue.indexOf("|") >= 0 || filtervalue.indexOf(" AND ") >= 0 || filtervalue.indexOf(" OR ") >= 0 || filtervalue.indexOf(" and ") >= 0 || filtervalue.indexOf(" or ") >= 0) {
                                    filtervalue = filtervalue.replace("|", "");
                                    filtervalue = filtervalue.replace("AND", "");
                                    filtervalue = filtervalue.replace("OR", "");
                                    filtervalue = filtervalue.replace("and", "");
                                    filtervalue = filtervalue.replace("or", "");
                                    var filtercondition = 'equal';
                                }
                            }

                            if (filtertype == "datefilter") {
                                var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition, null, column.cellsformat, me.gridlocalization);
                            }
                            else {
                                var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition, null);
                            }
                            filtergroup.addfilter(0, filter);
                        }

                        hasFilter = true;
                    }
                    else {
                        if (checkedItems.length != widget.items.length) {
                            hasFilter = true;
                            for (var i = 0; i < checkedItems.length; i++) {
                                if (me.gridlocalization.filterselectallstring === checkedItems[i].value)
                                    continue;

                                var filtervalue = checkedItems[i].value;
                                if (filtervalue === undefined) filtervalue = "";
                                var filtercondition = 'equal';

                                if (filtertype == "datefilter") {
                                    var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition, null, column.cellsformat, me.gridlocalization);
                                }
                                else {
                                    var filter = filtergroup.createfilter(filtertype, filtervalue, filtercondition, null);
                                }
                                var filter_or_operator = 1;
                                filtergroup.addfilter(filter_or_operator, filter);
                            }
                        }
                        else hasFilter = false;
                    }
                    if (hasFilter) {
                        var datafield = column.displayfield;
                        this.addfilter(datafield, filtergroup, true);
                    }
                    else {
                        var datafield = column.displayfield;
                        this.removefilter(datafield, true);
                    }
                }
            },

            _clearfilter: function (me, element, column) {
                var datafield = column.displayfield;
                this.removefilter(datafield, true);
            },

            addfilter: function (datafield, filter, apply) {
                if (this._loading) {
                    throw new Error('jqxGrid: ' + this.loadingerrormessage);
                    return false;
                }

                var columnbydatafield = this.getcolumn(datafield);
                var _columnbydatafield = this._getcolumn(datafield);
                if (columnbydatafield == undefined || columnbydatafield == null)
                    return;

                columnbydatafield.filter = filter;
                if (_columnbydatafield == undefined || _columnbydatafield == null)
                    return;

                _columnbydatafield.filter = filter;

                this.dataview.addfilter(datafield, filter);
                if (apply == true && apply != undefined) {
                    this.applyfilters('add');
                }
            },

            // removes a filter.
            removefilter: function (datafield, apply) {
                if (this._loading) {
                    throw new Error('jqxGrid: ' + this.loadingerrormessage);
                    return false;
                }

                var columnbydatafield = this.getcolumn(datafield);
                var _columnbydatafield = this._getcolumn(datafield);
                if (columnbydatafield == undefined || columnbydatafield == null)
                    return;

                if (columnbydatafield.filter == null)
                    return;

                this.dataview.removefilter(datafield, columnbydatafield.filter);
                columnbydatafield.filter = null;
                _columnbydatafield.filter = null;

                if (this.showfilterrow) {
                    this.clearfilterrow(datafield);
                }

                if (apply == true || apply !== false) {
                    this.applyfilters('remove');
                }
            },

            applyfilters: function (reason) {
                var customfilter = false;

                if (this.dataview.filters.length >= 0 && (this.virtualmode || !this.source.localdata)) {
                    if (this.source != null && this.source.filter) {
                        var tmppage = -1;
                        if (this.pageable) {
                            tmppage = this.dataview.pagenum;
                            this.dataview.pagenum = 0;
                        }
                        else {
                            this.vScrollInstance.setPosition(0);
                            this.loadondemand = true;
                            this._renderrows(this.virtualsizeinfo);
                        }

                        if (this.pageable && this.virtualmode) {
                            this.dataview.pagenum = 0;
                        }
                        this.source.filter(this.dataview.filters, this.dataview.records, this.dataview.records.length);
                        if (this.pageable && !this.virtualmode) {
                            this.dataview.pagenum = tmppage;
                        }
                    }
                }
                this._cellscache = new Array();
                if (this.dataview.clearsortdata) {
                    this.dataview.clearsortdata();
                }
                if (!this.virtualmode) {
                    var selectedrowindexes = this.selectedrowindexes;
                    var me = this.that;
                    this.dataview.refresh();
                    if (this.dataview.clearsortdata) {
                        if (this.sortcolumn && this.sortdirection) {
                            var sortdirection = this.sortdirection.ascending ? "asc" : "desc";
                            if (!this._loading) {
                                this.sortby(this.sortcolumn, sortdirection, null, false);
                            }
                            else {
                                this.sortby(this.sortcolumn, sortdirection, null, false, false);
                            }
                        }
                    }

                }
                else {
                    if (this.pageable) {
                        this.dataview.updateview();
                        if (this.gotopage) {
                            this.gotopage(0);
                        }
                    }
                    this.rendergridcontent(false, false);
                    if (this.showfilterrow) {
                        if (typeof reason != 'string' && $.isEmptyObject(reason)) {
                            this.refreshfilterrow();
                        }
                    }
                    this._postrender("filter");
                    this._raiseEvent(13, { filters: this.dataview.filters });
                    return;
                }

                if (this.pageable) {
                    this.dataview.updateview();
                    if (this.gotopage) {
                        this.gotopage(0);
                        this.updatepagerdetails();
                    }
                }
                this._updaterowsproperties();
                if (!this.groupable || (this.groupable && this.groups.length == 0)) {
                    this._rowdetailscache = new Array();
                    this.virtualsizeinfo = null;
                    this._pagescache = new Array();
                    if (this.columns && this.columns.records && this.columns.records.length > 0 && !this.columns.records[0].filtericon) {
                        this.prerenderrequired = true;
                    }
                    // it is not necessary to update the columns and that's why the second param is false.
                    this.rendergridcontent(true, false);
                    this._updatecolumnwidths();
                    this._updatecellwidths();
                    this._renderrows(this.virtualsizeinfo);
                    if (this.showaggregates && this._updatecolumnsaggregates) {
                        this._updatecolumnsaggregates();
                    }
                    this._postrender("filter");
                }
                else {
                    this.collapseallgroups();
                    this._rowdetailscache = new Array();
                    this._render(true, true, false, false, false);
                    if (this.showfilterrow) this._updatefocusedfilter();
                    this._updatecolumnwidths();
                    this._updatecellwidths();
                    this._renderrows(this.virtualsizeinfo);
                    this._postrender("group");
                }
                if (this.showfilterrow) {
                    if (typeof reason != 'string' && $.isEmptyObject(reason)) {
                        this.refreshfilterrow();
                    }
                }

                this._raiseEvent(13, { filters: this.dataview.filters });
            },

            getfilterinformation: function () {
                var filters = new Array();
                for (var i = 0; i < this.dataview.filters.length; i++) {
                    var column = this.getcolumn(this.dataview.filters[i].datafield);
                    filters[i] = { filter: this.dataview.filters[i].filter, datafield: column.datafield, displayfield: column.displayfield, filtercolumn: column.datafield, filtercolumntext: column.text };
                }
                return filters;
            },

            clearfilters: function (apply) {
                var me = this.that;
                if (this.showfilterrow) {
                    this.clearfilterrow();
                }

                if (this.columns.records) {
                    var canApply = apply == true || apply !== false;
                    $.each(this.columns.records, function () {
                        me.removefilter(this.displayfield, !canApply);
                    });
                }

                if (apply === false)
                    return;

                if (apply == true || apply !== false) {
                    this.applyfilters('clear');
                }
            },

            _destroyfilterpanel: function () {
                var clearbutton = $($.find('#filterclearbutton' + this.element.id));
                var filterbutton = $($.find('#filterbutton' + this.element.id));
                var condition = $($.find('#filter1' + this.element.id));
                var filteroperator = $($.find('#filter2' + this.element.id));
                var condition2 = $($.find('#filter3' + this.element.id));
                var input1 = $($.find('.filtertext1' + this.element.id));
                var input2 = $($.find('.filtertext2' + this.element.id));
                if (input1.length > 0 && input2.length > 0) {
                    input1.removeClass();
                    input2.removeClass();
                    input1.remove();
                    input2.remove();
                }

                if (clearbutton.length > 0) {
                    clearbutton.jqxButton('destroy');
                    filterbutton.jqxButton('destroy');
                    this.removeHandler(clearbutton, 'click');
                    this.removeHandler(filterbutton, 'click');
                }

                if (condition.length > 0) {
                    condition.jqxDropDownList('destroy');
                }
                if (filteroperator.length > 0) {
                    filteroperator.jqxDropDownList('destroy');
                }
                if (condition2.length > 0) {
                    condition2.jqxDropDownList('destroy');
                }

                var condition = $($.find('#filter1' + this.element.id + "ex"));
                var filteroperator = $($.find('#filter2' + this.element.id + "ex"));
                var condition2 = $($.find('#filter3' + this.element.id + "ex"));

                if (condition.length > 0) {
                    condition.jqxDropDownList('destroy');
                }
                if (filteroperator.length > 0) {
                    filteroperator.jqxDropDownList('destroy');
                }
                if (condition2.length > 0) {
                    condition2.jqxDropDownList('destroy');
                }

                if (this.excelfilterpanel) {
                    var condition = $(this.excelfilterpanel).find('#filter1' + this.element.id + "ex");
                    var filteroperator = $(this.excelfilterpanel).find('#filter2' + this.element.id + "ex");
                    var condition2 = $(this.excelfilterpanel).find('#filter3' + this.element.id + "ex");

                    if (condition.length > 0) {
                        this.removeHandler(condition, 'checkChange');
                        condition.jqxListBox('destroy');
                    }
                    if (filteroperator.length > 0) {
                        filteroperator.jqxDropDownList('destroy');
                    }
                    if (condition2.length > 0) {
                        condition2.jqxDropDownList('destroy');
                    }

                    var clearbutton = $(this.excelfilterpanel).find('#filterclearbutton' + this.element.id + "ex");
                    var filterbutton = $(this.excelfilterpanel).find('#filterbutton' + this.element.id + "ex");
                    var condition = $(this.excelfilterpanel).find('#filter1' + this.element.id + "ex");
                    var filteroperator = $(this.excelfilterpanel).find('#filter2' + this.element.id + "ex");
                    var condition2 = $(this.excelfilterpanel).find('#filter3' + this.element.id + "ex");
                    var input1 = $(this.excelfilterpanel).find('.filtertext1' + this.element.id + "ex");
                    var input2 = $(this.excelfilterpanel).find('.filtertext2' + this.element.id + "ex");

                    if (input1.length > 0 && input2.length > 0) {
                        input1.removeClass();
                        input2.removeClass();
                        input1.remove();
                        input2.remove();
                    }

                    if (clearbutton.length > 0) {
                        clearbutton.jqxButton('destroy');
                        filterbutton.jqxButton('destroy');
                        this.removeHandler(clearbutton, 'click');
                        this.removeHandler(filterbutton, 'click');
                    }
                    this.excelfilterpanel.removeData();
                    this.excelfilterpanel.remove();
                    delete this.excelfilterpanel;
                }
            },

            _updatefilterpanel: function (me, element, column) {
                if (me == null || me == undefined) me = this;
                var type = me._getcolumntypebydatafield(column);
                var source = me._getfiltersbytype(type);

                if (!me.host.jqxDropDownList) {
                    throw new Error('jqxGrid: Missing reference to jqxdropdownlist.js.');
                    return;
                }
                me.filterpanel.detach();
                me.excelfilterpanel.detach();
                if (column.filterpanel) {
                    column.filterpanel.detach();
                }
                $(element).children().detach();
                var filteritem = $(me.menuitemsarray[6]);
                $(filteritem).css('height', '220px');

                if (column.createfilterpanel && !column.filterpanel) {
                    var filterpanelcontainer = $("<div class='filter' style='margin-left: 7px;'></div>");
                    $(element).append(filterpanelcontainer);
                    column.createfilterpanel(column.displayfield, filterpanelcontainer);
                    column.filterpanel = filterpanelcontainer;
                }

                if (column.filtertype === "list" || column.filtertype === "checkedlist") {
                    $(element).append(me.excelfilterpanel);
                }
                else if (column.filtertype !== "custom") {
                    $(element).append(me.filterpanel);
                }
                else {
                    if (column.filterpanel) {
                        $(element).append(column.filterpanel);
                    }
                }

                this._showwhere = $(element).find('.filter.showwhere');

                var $element = $(element);
                var clearbutton = $element.find('#filterclearbutton' + me.element.id);
                var filterbutton = $element.find('#filterbutton' + me.element.id);
                var condition = $element.find('.filter1');
                var filteroperator = $element.find('.filter2');
                var condition2 = $element.find('.filter3');
                var input1 = $element.find('.filtertext1' + me.element.id);
                var input2 = $element.find('.filtertext2' + me.element.id);

                if (this._hasdatefilter && (column.filtertype !== "list" && column.filtertype !== "checkedlist" && column.filtertype !== "custom")) {
                    var filter1 = input1.parent();
                    var filter2 = input2.parent();

                    if (column.filtertype == "date") {
                        input1.jqxDateTimeInput('destroy');
                        input2.jqxDateTimeInput('destroy');
                        filter1.children().remove();
                        filter2.children().remove();

                        me._showwhere.text(me.gridlocalization.filtershowrowdatestring);
                        var input = $("<div class='filtertext1" + me.element.id + "' style=''></div>");

                        filter1.append(input);
                        var initInput = function (input) {
                            var localization = { calendar: me.gridlocalization, todayString: me.gridlocalization.todaystring, clearString: me.gridlocalization.clearstring };
                            input.jqxDateTimeInput({ disabled: me.disabled, firstDayOfWeek: me.gridlocalization.firstDay, localization: localization, rtl: me.rtl, width: me._filterpanelwidth - 10, height: 24, value: null, formatString: column.cellsformat, theme: me.theme });
                        }
                        initInput(input);

                        var input = $("<div class='filtertext2" + me.element.id + "' style=''></div>");
                        filter2.append(input);
                        initInput(input);
                    }
                    else {
                        filter1.children().remove();
                        filter2.children().remove();

                        me._showwhere.text(me.gridlocalization.filtershowrowstring);
                        var input = $("<input autocomplete='off' class='filtertext1" + me.element.id + "' style='box-sizing: content-box; height: 16px; padding: 3px;' type='text'></input>");

                        filter1.append(input);
                        var initInput = function (input) {
                            input.addClass(me.toThemeProperty('jqx-input'));
                            input.addClass(me.toThemeProperty('jqx-filter-input jqx-widget-content'));
                            input.addClass(me.toThemeProperty('jqx-rc-all'));
                            input.width(me._filterpanelwidth - 18);
                        }
                        initInput(input);

                        var input = $("<input autocomplete='off' class='filtertext2" + me.element.id + "' style='box-sizing: content-box; height: 16px; padding: 3px;' type='text'></input>");

                        filter2.append(input);
                        initInput(input);
                    }
                    var input1 = $element.find('.filtertext1' + me.element.id);
                    var input2 = $element.find('.filtertext2' + me.element.id);
                }

                if (column.filtertype != "date") {
                    input1.val('');
                    input2.val('');
                }
                else {
                    input1.val(null);
                    input2.val(null);
                }

                if (filterbutton.length > 0) {
                    filterbutton.jqxButton({ height: this.filterMenuItemsHeight });
                    clearbutton.jqxButton({ height: this.filterMenuItemsHeight });

                    this.removeHandler(filterbutton, 'click');
                    this.addHandler(filterbutton, 'click', function () {
                        me._buildfilter(me, element, column);
                        me._closemenu();
                    });
                    this.removeHandler(clearbutton, 'click');
                    this.addHandler(clearbutton, 'click', function () {
                        me._clearfilter(me, element, column);
                        me._closemenu();
                    });
                    this.removeHandler(filterbutton, 'keydown');
                    this.addHandler(filterbutton, 'keydown', function (event) {
                        if (event.keyCode === 13) {
                            me._buildfilter(me, element, column);
                            me._closemenu();
                        }
                    });
                    this.removeHandler(clearbutton, 'keydown');
                    this.addHandler(clearbutton, 'keydown', function (event) {
                        if (event.keyCode === 13) {
                            me._clearfilter(me, element, column);
                            me._closemenu();
                        }
                    });
                }

                if (input1.length > 0) {
                    this.removeHandler(input1, "keydown");
                    this.addHandler(input1, "keydown", function (event) {
                        if (event.keyCode === 13) {
                            filterbutton.trigger('click');
                            return false;
                        }
                        if (event.keyCode === 27) {
                            me._closemenu();
                        }

                    });
                    this.removeHandler(input2, "keydown");
                    this.addHandler(input2, "keydown", function (event) {
                        if (event.keyCode === 13) {
                            filterbutton.trigger('click');
                            return false;
                        }
                        if (event.keyCode === 27) {
                            me._closemenu();
                        }
                    });
                }
                if (this.filtermode === "default" && (column.filtertype !== "list" && column.filtertype !== "checkedlist" && column.filtertype !== "custom")) {
                    if (condition.jqxDropDownList('source') != source) {
                        condition.jqxDropDownList({ enableBrowserBoundsDetection: false, source: source });
                        condition2.jqxDropDownList({ enableBrowserBoundsDetection: false, source: source });
                    }

                    if (type == 'boolean' || type == 'bool') {
                        condition.jqxDropDownList({ autoDropDownHeight: true, selectedIndex: 0 });
                        condition2.jqxDropDownList({ autoDropDownHeight: true, selectedIndex: 0 });
                    }
                    else {
                        var autoDropDownHeight = false;
                        if (source && source.length) {
                            if (source.length < 5) {
                                autoDropDownHeight = true;
                            }
                        }

                        condition.jqxDropDownList({ autoDropDownHeight: autoDropDownHeight, selectedIndex: 2 });
                        condition2.jqxDropDownList({ autoDropDownHeight: autoDropDownHeight, selectedIndex: 2 });
                    }
                    filteroperator.jqxDropDownList({ selectedIndex: 0 });

                    var filter = column.filter;
                    var filtergroup = new $.jqx.filter();
                    var filtertype = "";
                    switch (type) {
                        case "number":
                        case "int":
                        case "float":
                        case "decimal":
                            filtertype = 'numericfilter';
                            conditions = filtergroup.getoperatorsbyfiltertype('numericfilter');
                            break;
                        case "boolean":
                        case "bool":
                            filtertype = 'booleanfilter';
                            conditions = filtergroup.getoperatorsbyfiltertype('booleanfilter');
                            break;
                        case "date":
                        case "time":
                            filtertype = 'datefilter';
                            conditions = filtergroup.getoperatorsbyfiltertype('datefilter');
                            break;
                        case "string":
                            filtertype = 'stringfilter';
                            conditions = filtergroup.getoperatorsbyfiltertype('stringfilter');
                            break;
                    }
                    if (filter != null) {
                        var filter1 = filter.getfilterat(0);
                        var filter2 = filter.getfilterat(1);
                        var operator = filter.getoperatorat(0);

                        if (me.updatefilterconditions) {
                            var conditions = [];
                            var newfilterconditions = me.updatefilterconditions(filtertype, conditions);
                            if (newfilterconditions != undefined) {
                                for (var c = 0; c < newfilterconditions.length; c++) {
                                    newfilterconditions[c] = newfilterconditions[c].toUpperCase();
                                }
                                filter.setoperatorsbyfiltertype(filtertype, newfilterconditions);
                                conditions = newfilterconditions;
                            }
                        }

                        var animationtype = 'default';
                        if (filter1 != null) {
                            var index1 = conditions.indexOf(filter1.comparisonoperator);
                            var value1 = filter1.filtervalue;
                            input1.val(value1);
                            condition.jqxDropDownList({ selectedIndex: index1, animationType: animationtype });
                        }
                        if (filter2 != null) {
                            var index2 = conditions.indexOf(filter2.comparisonoperator);
                            var value2 = filter2.filtervalue;
                            input2.val(value2);
                            condition2.jqxDropDownList({ selectedIndex: index2, animationType: animationtype });
                        }
                        if (filter.getoperatorat(0) == undefined) {
                            filteroperator.jqxDropDownList({ selectedIndex: 0, animationType: animationtype });
                        }
                        else {
                            if (filter.getoperatorat(0) == 'and' || filter.getoperatorat(0) == 0) {
                                filteroperator.jqxDropDownList({ selectedIndex: 0 });
                            }
                            else {
                                filteroperator.jqxDropDownList({ selectedIndex: 1 });
                            }
                        }
                    }

                    if (me.updatefilterpanel) {
                        me.updatefilterpanel(condition, condition2, filteroperator, input1, input2, filterbutton, clearbutton, filter, filtertype, conditions);
                    }

                    if (!this._hasdatefilter || (this._hasdatefilter && column.filtertype != "date")) {
                        if (!this.touchdevice) {
                            //  input1.focus();
                            setTimeout(function () {
                                input1.focus();
                            }, 10);
                        }
                    }
                }
                else if (this.filtermode === "excel" || column.filtertype === "list" || column.filtertype === "checkedlist") {
                    var dataadapter = me._getfilterdataadapter(column);
                    var filtertype = me._getfiltertype(type);
                    var checkboxes = this.filtermode === "excel" || column.filtertype === "checkedlist"
                    condition.jqxListBox('focus');
                    this.removeHandler(condition, "keyup");
                    this.addHandler(condition, "keyup", function (event) {
                        if (event.keyCode === 13) {
                            filterbutton.trigger('click');
                        }
                        if (event.keyCode === 27) {
                            me._closemenu();
                        }
                    });
                    if (column.cellsformat) {
                        condition.jqxListBox({ checkboxes: checkboxes, displayMember: column.displayfield, valueMember: column.displayfield + "JQValue", source: dataadapter });
                    }
                    else {
                        condition.jqxListBox({ checkboxes: checkboxes, displayMember: column.displayfield, valueMember: column.displayfield, source: dataadapter });
                    }
                    if (checkboxes) {
                        var item = condition.jqxListBox('getItem', 0);

                        if (!(item && item.label === me.gridlocalization.filterselectallstring)) {
                            condition.jqxListBox('insertAt', { label: me.gridlocalization.filterselectallstring }, 0);
                        }

                        var listbox = condition.data().jqxListBox.instance;
                        listbox.checkAll(false);
                        var that = this;
                        if (column.filter) {
                            listbox.uncheckAll(false);
                            var filters = column.filter.getfilters();
                            for (var i = 0; i < listbox.items.length; i++) {
                                var label = listbox.items[i].value;

                                $.each(filters, function () {
                                    if (this.condition == "NOT_EQUAL") {
                                        if (label != this.value) {
                                            listbox.uncheckIndex(i, false, false);
                                            return false;
                                        }
                                        else if (label != null && this.value != null && label.toString() != this.value.toString()) {
                                            listbox.uncheckIndex(i, false, false);
                                            return false;
                                        }
                                    }
                                    else if (this.condition == "EQUAL") {
                                        if (label == this.value) {
                                            listbox.checkIndex(i, false, false);
                                            return false;
                                        }
                                        else if (label != null && this.value != null && label.toString() == this.value.toString()) {
                                            listbox.checkIndex(i, false, false);
                                            return false;
                                        }
                                    }
                                });
                            }

                            listbox._updateCheckedItems();
                            var checkedItemsLength = listbox.getCheckedItems().length;
                            if (listbox.items.length != checkedItemsLength && checkedItemsLength > 0) {
                                listbox.host.jqxListBox('indeterminateIndex', 0, true, false);
                            }
                            if (checkedItemsLength === listbox.items.length - 1) {
                                listbox.host.jqxListBox('checkIndex', 0, true, false);
                            }
                        }
                    }
                    else {
                        if (column.filter) {
                            var listbox = condition.data().jqxListBox.instance;
                            listbox.clearSelection();
                            var filters = column.filter.getfilters();
                            for (var i = 0; i < listbox.items.length; i++) {
                                var label = listbox.items[i].value;

                                $.each(filters, function () {
                                    if (this.condition == "NOT_EQUAL") {
                                        if (label != this.value) {
                                            listbox.unselectIndex(i, false, false);
                                            return false;
                                        }
                                    }
                                    else if (this.condition == "EQUAL") {
                                        if (label == this.value) {
                                            listbox.selectIndex(i, true, false);
                                            return false;
                                        }
                                    }
                                });
                            }
                            listbox._renderItems();
                        }
                    }
                }
            },

            _initfilterpanel: function (me, element, column, width, excelMode) {
                if (me == null || me == undefined) me = this;
                element[0].innerHTML = "";
                var filterpanelcontainer = $("<div class='filter' style='position: absolute; bottom: 3px; margin-left: 3px;'></div>");

                element.append(filterpanelcontainer);
                var showwhere = $("<div class='filter showwhere' style='height: 18px; margin-top: 3px; margin-bottom: 3px;'></div>");
                showwhere.text(me.gridlocalization.filtershowrowstring);
                this._showwhere = showwhere;
                var exString = excelMode ? "ex" : "";
                var condition = $("<div class='filter filter1' id='filter1" + me.element.id + exString + "'></div>");
                var operator = $("<div class='filter filter2' id='filter2" + me.element.id + exString + "' style='margin-top: 3px; margin-bottom: 3px;'></div>");
                var condition2 = $("<div class='filter filter3' id='filter3" + me.element.id + exString + "'></div>");
                var type = me._getcolumntypebydatafield(column);
                condition[0].setAttribute('aria-label', 'Filter Condition 1');
                operator[0].setAttribute('aria-label', 'Filter Operator');
                condition2[0].setAttribute('aria-label', 'Filter Condition 2');
                condition[0].setAttribute('aria-expanded', false);
                operator[0].setAttribute('aria-expanded', false);
                condition2[0].setAttribute('aria-expanded', false);

                if (!condition.jqxDropDownList) {
                    throw new Error('jqxGrid: jqxdropdownlist.js is not loaded.');
                    return;
                }

                var source = me._getfiltersbytype(type);

                this._hasdatefilter = false;
                this._filterpanelwidth = width;
                if (this.columns && this.columns.records) {
                    for (var i = 0; i < this.columns.records.length; i++) {
                        if (this.columns.records[i].filtertype == "date") {
                            this._hasdatefilter = true;
                            break;
                        }
                    }
                }
                else if (this.columns && !this.columns.records) {
                    for (var i = 0; i < this.columns.length; i++) {
                        if (this.columns[i].filtertype == "date") {
                            this._hasdatefilter = true;
                            break;
                        }
                    }
                }
                this._hasdatefilter = true;

                var input = $("<div style='margin-top:3px;' class='filter'><input aria-label='Filter Value Input' autocomplete='off' class='filtertext1" + me.element.id + "' style='padding: 3px; height: 16px; margin-top: 3px; margin-bottom: 3px;' type='text'></input></div>");
                var textField = input.find('input');
                textField.addClass(this.toThemeProperty('jqx-input'));
                textField.addClass(this.toThemeProperty('jqx-filter-input jqx-widget-content'));
                textField.addClass(this.toThemeProperty('jqx-rc-all'));
                textField.width(width - 18);

                var input2 = $("<div style='margin-top:3px;' class='filter'><input aria-label='Filter Value Input 2' autocomplete='off' class='filtertext2" + me.element.id + "' style='padding: 3px; height: 16px; margin-top: 3px;' type='text'></input></div>");
                var textField2 = input2.find('input');
                textField2.addClass(this.toThemeProperty('jqx-input'));
                textField2.addClass(this.toThemeProperty('jqx-filter-input jqx-widget-content'));
                textField2.addClass(this.toThemeProperty('jqx-rc-all'));
                textField2.width(width - 18);

                if (me.rtl) {
                    textField.css('direction', 'rtl');
                    textField2.css('direction', 'rtl');
                }

                var applyinput = $("<div class='filter' style='height: 35px; text-align:center; margin-top: 15px; margin-left:-2px;'></div>");
                var filterbutton = $('<span tabIndex=0 id="filterbutton' + me.element.id + '" class="primary filterbutton" style="padding: 6px 15px;">' + me.gridlocalization.filterstring + '</span>');
                applyinput.append(filterbutton);
                var filterclearbutton = $('<span tabIndex=0 id="filterclearbutton' + me.element.id + '" class="filterclearbutton secondary" style="position: relative; left: 2px; padding: 6px 15px; margin-left: 7px;">' + me.gridlocalization.filterclearstring + '</span>');
                applyinput.append(filterclearbutton);

                filterbutton.jqxButton({ height: this.filterMenuItemsHeight, theme: me.theme });
                filterclearbutton.jqxButton({ height: this.filterMenuItemsHeight, theme: me.theme });

                var selectionrenderer = function (selectionelement) {
                    if (selectionelement) {
                        if (selectionelement.text().indexOf("case sensitive") != -1) {
                            var selectiontext = selectionelement.text();
                            selectiontext = selectiontext.replace("case sensitive", "match case");
                            selectionelement.text(selectiontext);
                        }
                        selectionelement.css('font-family', me.host.css('font-family'));
                        selectionelement.css('font-size', me.host.css('font-size'));
                        selectionelement.css('top', '2px');
                        selectionelement.css('position', 'relative');

                        return selectionelement;
                    }
                    return "";
                }

                if (this.filtermode === "default" && !excelMode) {
                    filterpanelcontainer.append(showwhere);
                    filterpanelcontainer.append(condition);
                    condition.jqxDropDownList({ _checkForHiddenParent: false, autoItemsHeight: true, rtl: me.rtl, enableBrowserBoundsDetection: false, selectedIndex: 2, width: width - 10, height: this.filterMenuItemsHeight, dropDownHeight: 200, dropDownWidth: width - 10, selectionRenderer: selectionrenderer, source: source, theme: me.theme });
                    filterpanelcontainer.append(input);
                    var operators = new Array();
                    operators[0] = me.gridlocalization.filterandconditionstring;
                    operators[1] = me.gridlocalization.filterorconditionstring;
                    operator.jqxDropDownList({ _checkForHiddenParent: false, rtl: me.rtl, enableBrowserBoundsDetection: false, autoDropDownHeight: true, selectedIndex: 0, width: 60, height: this.filterMenuItemsHeight, source: operators, selectionRenderer: selectionrenderer, theme: me.theme });
                    filterpanelcontainer.append(operator);
                    condition2.jqxDropDownList({ _checkForHiddenParent: false, autoItemsHeight: true, rtl: me.rtl, enableBrowserBoundsDetection: false, selectedIndex: 2, width: width - 10, height: this.filterMenuItemsHeight, dropDownHeight: 200, dropDownWidth: width - 10, selectionRenderer: selectionrenderer, source: source, theme: me.theme });
                    filterpanelcontainer.append(condition2);
                    filterpanelcontainer.append(input2);
                }
                else if (this.filtermode === "excel" || excelMode) {
                    filterpanelcontainer.append(showwhere);
                    filterpanelcontainer.append(condition);
                    condition.attr('tabindex', 0);
                    condition.jqxListBox({ rtl: me.rtl, _checkForHiddenParent: false, checkboxes: true, selectedIndex: 2, width: width - 10, height: 160, theme: me.theme });
                    var handleCheckChange = true;
                    me.addHandler(condition, 'checkChange', function (event) {
                        if (!handleCheckChange)
                            return;

                        if (event.args.label != me.gridlocalization.filterselectallstring) {
                            handleCheckChange = false;
                            condition.jqxListBox('checkIndex', 0, true, false);
                            var checkedItems = condition.jqxListBox('getCheckedItems');
                            var items = condition.jqxListBox('getItems');

                            if (checkedItems.length == 1) {
                                condition.jqxListBox('uncheckIndex', 0, true, false);
                            }
                            else if (items.length != checkedItems.length) {
                                condition.jqxListBox('indeterminateIndex', 0, true, false);
                            }
                            handleCheckChange = true;
                        }
                        else {
                            handleCheckChange = false;
                            if (event.args.checked) {
                                condition.jqxListBox('checkAll', false);
                            }
                            else {
                                condition.jqxListBox('uncheckAll', false);
                            }

                            handleCheckChange = true;
                        }
                    });
                }

                filterpanelcontainer.append(applyinput);
                if (me.updatefilterpanel) {
                    me.updatefilterpanel(condition, condition2, operator, input, input2, filterbutton, filterclearbutton, null, null, source);
                }
            }
        });
    })(jqxBaseFramework);
})();





/***/ }),

/***/ 3066:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {
        $.jqx.dataview.grouping = function () {
            this.loadgrouprecords = function (startvisibleindex, startindex, endindex, filter, currentPageIndex, updated, rows, rl, diff) {
                var visualRows = startvisibleindex;
                var self = this;
                var groupHashCodes = new Array();
                for (var iGroupColumn = 0; iGroupColumn < self.groups.length; iGroupColumn++) {
                    groupHashCodes[iGroupColumn] = self.generatekey();
                }
                var grouprecords = new Array();
                var grouprecordsindex = 0;
                var groupHashCodes = groupHashCodes;
                var hashRowGroups = new Array();

                var i = startindex;
                var currentRowIndex = startindex;
                var groupslength = self.groups.length;
                this.loadedrecords = new Array();

                this.bounditems = new Array();
                this.loadedrecords = new Array(); // all data records ready for rendering.
                this.loadedrootgroups = new Array(); // all groups ready for rendering
                this.loadedgroups = new Array(); // all groups ready for rendering
                this.loadedgroupsByKey = new Array(); // all groups ready for rendering
                this.sortedgroups = new Array();

                var hassortdata = this.sortdata != null;
                var data = hassortdata ? this.sortdata : this.records;
                if (this.pageable) {
                    var items = new Array();
                    var index = 0;
                    if (!data[startindex]) {
                        $.each(data, function (index, value) {
                            items[startindex + index++] = this;
                        });
                        data = items;
                    }
                }

                if (this.virtualmode) {
                    var items = new Array();
                    var index = 0;
                    for (var i = 0; i < endindex - startindex; i++) {
                        if (data[i]) {
                            items[startindex + index++] = data[i];
                        }
                        else if (data[startindex + index]) {
                            items[startindex + index] = data[startindex + index];
                            index++;
                        }
                    }
                    i = 0;
                    data = items;
                }

                for (var obj = startindex; obj < endindex; obj++) {
                    var item = {};

                    if (!hassortdata) {
                        item = $.extend({}, data[obj]);
                    }
                    else {
                        item = $.extend({}, data[obj].value);
                    }

                    var id = item[self.uniqueId];


                    if (currentPageIndex >= rl || id != rows[currentPageIndex][self.uniqueId] || (updated && updated[id]))
                        diff[diff.length] = currentPageIndex;

                    var itemKeysHierarchy = new Array();
                    var keys = 0;
                    for (var iGroupColumn = 0; iGroupColumn < groupslength; iGroupColumn++) {
                        var group = self.groups[iGroupColumn];
                        var value = item[group];
                        if (value == null) value = "";
                        itemKeysHierarchy[keys++] = { value: value, hash: groupHashCodes[iGroupColumn] };
                    }

                    if (itemKeysHierarchy.length != groupslength)
                        break;

                    var parentItem = null;

                    var lookupKey = "";
                    var iLevel = -1;

                    for (var q = 0; q < itemKeysHierarchy.length; q++) {
                        iLevel++;
                        var itemKey = itemKeysHierarchy[q].value;
                        var columnHash = itemKeysHierarchy[q].hash;
                        lookupKey = lookupKey + "_" + columnHash + "_" + itemKey;

                        if (hashRowGroups[lookupKey] != undefined && hashRowGroups[lookupKey] != null) {
                            parentItem = hashRowGroups[lookupKey];
                            continue;
                        }

                        if (parentItem == null) {
                            parentItem = { group: itemKey, subItems: new Array(), subGroups: new Array(), level: 0 };
                            grouprecords[grouprecordsindex++] = parentItem;
                            parentItem.uniqueid = self.generatekey();
                            self.loadedgroupsByKey[itemKey] = parentItem;
                        }
                        else {
                            var subItem = { group: itemKey, subItems: new Array(), subGroups: new Array(), parentItem: parentItem, level: parentItem.level + 1 };
                            self.loadedgroupsByKey[parentItem.uniqueid + '_' + itemKey] = subItem;
                            subItem.uniqueid = self.generatekey();
                            parentItem.subGroups[parentItem.subGroups.length++] = subItem;
                            parentItem = subItem;
                        }

                        hashRowGroups[lookupKey] = parentItem;
                    }

                    if (parentItem != null) {
                        if (undefined == item.uid) {
                            item.uid = this.getid(this.source.id, item, i);
                        }

                        if (!hassortdata) {
                            item.boundindex = i;
                            this.recordsbyid["id" + item.uid] = data[obj];
                        }
                        else {
                            item.boundindex = data[obj].index;
                            this.recordsbyid["id" + item.uid] = data[obj].value;
                        }

                        this.bounditems[item.boundindex] = item;
                        this.sortedgroups[i] = item;
                        item.uniqueid = self.generatekey();
                        item.parentItem = parentItem;
                        item.level = parentItem.level + 1;

                        parentItem.subItems[parentItem.subItems.length++] = item;
                    }
                    else {
                        if (undefined == item.uid) {
                            item.uid = this.getid(this.source.id, item, i);
                        }

                        if (!hassortdata) {
                            item.boundindex = i;
                            this.recordsbyid["id" + item.uid] = data[obj];
                        }
                        else {
                            item.boundindex = data[obj].index;
                            this.recordsbyid["id" + item.uid] = data[obj].value;
                        }

                        this.sortedgroups[i] = item;
                        this.bounditems[item.boundindex] = item;
                        item.uniqueid = self.generatekey();
                    }

                    currentPageIndex++;

                    i++;
                    currentRowIndex++;
                };

                var loopitems = function (self, group, visualRows) {
                    for (var m = 0; m < group.subItems.length; m++) {
                        group.subItems[m].visibleindex = startvisibleindex + visualRows;
                        self.rows[visualRows] = group.subItems[m];
                        self.loadedrecords[visualRows] = group.subItems[m];
                        visualRows++;
                    }
                    return visualRows
                }

                var loopGroups = function (self, group, visualRows) {
                    var totalRows = 1;
                    var columns = self.grid.columns.records ? self.grid.columns.records : self.grid.columns;
                    if (self.aggregates == true) {
                        for (var i = 0; i < columns.length; i++) {
                            if (columns[i].aggregates) {
                                totalRows = Math.max(totalRows, columns[i].aggregates.length);
                            }
                        }
                    }

                    var totals = function (group) {
                        if (self.aggregates == true) {
                            var addTotalRows = function (j) {
                                var olditem = group;

                                var item = {};
                                var addTotalValue = function (subItems) {
                                    for (var m = 0; m < columns.length; m++) {
                                        if (columns[m].aggregates) {

                                            var obj = self.grid.getcolumnaggregateddata(columns[m].datafield, columns[m].aggregates, true, subItems);

                                            for (var i = 0; i < columns[m].aggregates.length; i++) {
                                                if (columns[m].aggregates[j]) {
                                                    var column = columns[m];
                                                    var aggregate = columns[m].aggregates[j];
                                                    var name = aggregate;
                                                    name = self.grid._getaggregatename(name);
                                                    var field = name + ':' + obj[aggregate];
                                                    if (obj[aggregate]) {
                                                        item[column.datafield] = field;
                                                    }
                                                    else {
                                                        item[column.datafield] = name + ':' + obj[name];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                if (olditem != null) {
                                    item.level = olditem.level;
                                    item.visibleindex = startvisibleindex + visualRows;
                                    item.uniqueid = self.generatekey();
                                    self.rows[visualRows] = item;
                                    self.loadedrecords[visualRows++] = item;
                                    item.totalsrow = true;

                                    if (group.subItems.length > 0) {
                                        olditem = group.subItems[group.subItems.length - 1];
                                        item.parentItem = olditem.parentItem;
                                        if (item.parentItem.subItems) {
                                            item.parentItem.subItems[item.parentItem.subItems.length] = item;
                                        }

                                        var subItems = [];
                                        var getSubItems = function () {
                                            for (var q = 0; q < group.subItems.length; q++) {
                                                if (group.subItems[q].totalsrow) {
                                                    continue;
                                                }
                                                subItems[subItems.length] = group.subItems[q];
                                            }
                                        }
                                        getSubItems(group);
                                        addTotalValue(subItems);
                                    }
                                    else if (group.subGroups.length > 0) {
                                        olditem = group.subGroups[group.subGroups.length - 1];
                                        item.level = olditem.level;


                                        item.parentItem = group;
                                        group.subGroups[group.subGroups.length] = item;
                                        var subItems = [];
                                        var getSubItems = function (group) {
                                            if (group.totalsrow)
                                                return;

                                            for (var q = 0; q < group.subItems.length; q++) {
                                                if (group.subItems[q].totalsrow) {
                                                    continue;
                                                }
                                                subItems[subItems.length] = group.subItems[q];
                                            }
                                            for (var q = 0; q < group.subGroups.length; q++) {
                                                getSubItems(group.subGroups[q]);
                                            }
                                        }
                                        getSubItems(group);
                                        addTotalValue(subItems);
                                    }
                                }
                            }
                            for (var j = 0; j < totalRows; j++) {
                                addTotalRows(j);
                            }
                        }
                    }
                    for (var subGroup in group.subGroups) {
                        var currentGroup = group.subGroups[subGroup];
                        if (currentGroup.subGroups) {
                            self.loadedgroups[self.loadedgroups.length] = currentGroup;
                            currentGroup.visibleindex = startvisibleindex + visualRows;
                            self.rows[visualRows] = currentGroup;
                            self.loadedrecords[visualRows] = currentGroup;
                            visualRows++;
                            if (currentGroup.subGroups.length > 0) {
                                visualRows = loopGroups(self, currentGroup, visualRows);
                            }
                            else if (currentGroup.subItems.length > 0) {
                                visualRows = loopitems(self, currentGroup, visualRows);
                            }
                            //     totals(currentGroup);
                        }
                    }
                    if (group.subItems.length > 0) {
                        visualRows = loopitems(self, group, visualRows);
                    }
                    totals(group);
                    return visualRows;
                }

                var grouprecordslength = grouprecords.length;
                this.loadedgroups = new Array();
                this.rows = new Array();
                var visualRows = 0;

                for (var i = 0; i < grouprecordslength; i++) {
                    var group = grouprecords[i];
                    this.loadedrootgroups[i] = group;
                    this.loadedgroups[this.loadedgroups.length] = group;
                    group.visibleindex = startvisibleindex + visualRows;
                    this.rows[visualRows] = group;
                    this.loadedrecords[visualRows] = group;
                    visualRows++;
                    visualRows = loopGroups(this, group, visualRows);
                }


                return visualRows;
            }


            this._updategroupsinpage = function (self, filter, currentRowIndex, currentPageIndex, rl, start, end) {
                // create rows.
                var rows = new Array();

                var diff = [];
                if (this.groupable && this.groups.length > 0) {
                    var visualrows = 0;
                    var hashRowGroups = new Array();
                    var groupHashCodes = new Array();
                    for (var iGroupColumn = 0; iGroupColumn < self.groups.length; iGroupColumn++) {
                        groupHashCodes[iGroupColumn] = self.generatekey();
                    }
                    var i = 0;
                    var grouprecords = new Array();
                    var grouprecordsindex = 0;
                    if (end > this.totalrecords) {
                        end = this.totalrecords;
                    }

                    for (var obj = start; obj < end; obj++) {
                        var item = $.extend({}, self.sortedgroups[obj]);
                        var id = item[self.uniqueId];

                        if (!self.pagesize || (currentRowIndex >= self.pagesize * self.pagenum && currentRowIndex < self.pagesize * (self.pagenum + 1))) {
                            if (currentPageIndex >= rl || id != rows[currentPageIndex][self.uniqueId] || (updated && updated[id]))
                                diff[diff.length] = currentPageIndex;

                            var itemKeysHierarchy = new Array();
                            var keys = 0;
                            for (var iGroupColumn = 0; iGroupColumn < self.groups.length; iGroupColumn++) {
                                var group = self.groups[iGroupColumn];
                                var value = item[group];

                                if (null == value)
                                    value = "";

                                itemKeysHierarchy[keys++] = { value: value, hash: groupHashCodes[iGroupColumn] };
                            }

                            if (itemKeysHierarchy.length != self.groups.length)
                                break;

                            var parentItem = null;

                            var lookupKey = "";
                            var iLevel = -1;

                            for (var q = 0; q < itemKeysHierarchy.length; q++) {
                                iLevel++;
                                var itemKey = itemKeysHierarchy[q].value;
                                var columnHash = itemKeysHierarchy[q].hash;
                                lookupKey = lookupKey + "_" + columnHash + "_" + itemKey;

                                if (hashRowGroups[lookupKey] != undefined && hashRowGroups[lookupKey] != null) {
                                    parentItem = hashRowGroups[lookupKey];
                                    continue;
                                }

                                if (parentItem == null) {
                                    parentItem = { group: itemKey, subItems: new Array(), subGroups: new Array(), level: 0 };
                                    grouprecords[grouprecordsindex++] = parentItem;
                                    var initialgroup = self.loadedgroupsByKey[itemKey];
                                    if (initialgroup != undefined) {
                                        parentItem.visibleindex = initialgroup.visibleindex;
                                        parentItem.uniqueid = initialgroup.uniqueid;
                                    }
                                }
                                else {
                                    var subItem = { group: itemKey, subItems: new Array(), subGroups: new Array(), parentItem: parentItem, level: parentItem.level + 1 };
                                    var initialgroup = self.loadedgroupsByKey[parentItem.uniqueid + '_' + itemKey];
                                    subItem.visibleindex = initialgroup.visibleindex;
                                    subItem.uniqueid = initialgroup.uniqueid;
                                    parentItem.subGroups[parentItem.subGroups.length++] = subItem;
                                    parentItem = subItem;
                                }

                                hashRowGroups[lookupKey] = parentItem;
                            }

                            if (parentItem != null) {
                                item.parentItem = parentItem;
                                item.level = parentItem.level + 1;
                                parentItem.subItems[parentItem.subItems.length++] = item;
                            }

                            currentPageIndex++;
                        }
                        i++;
                        currentRowIndex++;
                    };

                    var loopitems = function (self, group, visualrows) {
                        for (var m = 0; m < group.subItems.length; m++) {
                            rows[visualrows] = $.extend({}, group.subItems[m]);
                            visualrows++;
                        }
                        return visualrows;
                    }

                    var anysubitems = function (group) {
                        var hasitems = false;

                        for (var subGroup in group.subGroups) {
                            var currentGroup = group.subGroups[subGroup];
                            if (currentGroup.subGroups) {
                                if (currentGroup.subGroups.length > 0) {
                                    var result = anysubitems(currentGroup);
                                    if (result) {
                                        hasitems = true;
                                        return true;
                                    }
                                }
                                if (currentGroup.subItems.length > 0) {
                                    hasitems = true;
                                    return true;
                                }
                            }
                        }
                        if (group.subItems.length > 0) {
                            hasitems = true;
                            return true;
                        }
                        return hasitems;
                    }

                    var loopGroups = function (self, group, visualrows) {
                        var totalRows = 1;
                        var columns = self.grid.columns.records ? self.grid.columns.records : self.grid.columns;
                        if (self.aggregates == true) {
                            for (var i = 0; i < columns.length; i++) {
                                if (columns[i].aggregates) {
                                    totalRows = Math.max(totalRows, columns[i].aggregates.length);
                                }
                            }
                        }
                        var totals = function (group) {
                            if (self.aggregates == true) {
                                var addTotalRows = function (j) {
                                    var olditem = group;
                                    var item = {};
                                    var addTotalValue = function (subItems) {
                                        for (var m = 0; m < columns.length; m++) {
                                            if (columns[m].aggregates) {

                                                var obj = self.grid.getcolumnaggregateddata(columns[m].datafield, columns[m].aggregates, true, subItems);

                                                for (var i = 0; i < columns[m].aggregates.length; i++) {
                                                    if (columns[m].aggregates[j]) {
                                                        var column = columns[m];
                                                        var aggregate = columns[m].aggregates[j];
                                                        var name = aggregate;
                                                        name = self.grid._getaggregatename(name);
                                                        var field = name + ':' + obj[aggregate];

                                                        item[column.datafield] = field;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    if (olditem != null) {
                                        item.level = olditem.level;
                                        item.visibleindex = visualrows;
                                        item.uniqueid = self.generatekey();
                                        rows[visualrows] = item;
                                        self.loadedrecords[visualrows++] = item;
                                        item.totalsrow = true;

                                        if (group.subItems.length > 0) {
                                            olditem = group.subItems[group.subItems.length - 1];
                                            item.parentItem = olditem.parentItem;
                                            if (item.parentItem.subItems) {
                                                item.parentItem.subItems[item.parentItem.subItems.length] = item;
                                            }

                                            var subItems = [];
                                            var getSubItems = function () {
                                                for (var q = 0; q < group.subItems.length; q++) {
                                                    if (group.subItems[q].totalsrow) {
                                                        continue;
                                                    }
                                                    subItems[subItems.length] = group.subItems[q];
                                                }
                                            }
                                            getSubItems(group);
                                            addTotalValue(subItems);
                                        }
                                        else if (group.subGroups.length > 0) {
                                            olditem = group.subGroups[group.subGroups.length - 1];
                                            item.level = olditem.level;
                                            item.parentItem = group;
                                            group.subGroups[group.subGroups.length] = item;
                                            var subItems = [];
                                            var getSubItems = function (group) {
                                                if (group.totalsrow)
                                                    return;

                                                for (var q = 0; q < group.subItems.length; q++) {
                                                    if (group.subItems[q].totalsrow) {
                                                        continue;
                                                    }
                                                    subItems[subItems.length] = group.subItems[q];
                                                }
                                                for (var q = 0; q < group.subGroups.length; q++) {
                                                    getSubItems(group.subGroups[q]);
                                                }
                                            }
                                            getSubItems(group);
                                            addTotalValue(subItems);
                                        }
                                    }
                                }
                                for (var j = 0; j < totalRows; j++) {
                                    addTotalRows(j);
                                }
                            }
                        }

                        for (var subGroup in group.subGroups) {
                            var currentGroup = group.subGroups[subGroup];

                            if (currentGroup.subGroups) {
                                if (anysubitems(currentGroup)) {
                                    rows[visualrows] = currentGroup;
                                    visualrows++;
                                    if (currentGroup.subGroups.length > 0) {
                                        visualrows = loopGroups(self, currentGroup, visualrows);
                                    }
                                    else if (currentGroup.subItems.length > 0) {
                                        visualrows = loopitems(self, currentGroup, visualrows);
                                    }
                                    //    totals(currentGroup);
                                }
                            }
                        }
                        if (group.subItems.length > 0) {
                            visualrows = loopitems(self, group, visualrows);
                        }


                        totals(group);
                        return visualrows;
                    }

                    var parentgroup = 0;
                    for (var i = 0; i < grouprecords.length; i++) {
                        var group = grouprecords[i];

                        if (anysubitems(group)) {
                            rows[visualrows] = group;
                            visualrows++;
                            visualrows = loopGroups(this, group, visualrows);
                        }
                    }
                }

                return rows;
            }
        }

        $.extend($.jqx._jqxGrid.prototype, {
            _initgroupsheader: function () {
                this.groupsheader.css('visibility', 'hidden');
                if (this._groupsheader()) {
                    this.groupsheader.css('visibility', 'inherit');
                    var me = this;
                    var groupsheaderstring = this.gridlocalization.groupsheaderstring;
                    this.groupsheaderdiv = this.groupsheaderdiv || $('<div style="width: 100%; position: relative;"></div>');
                    this.groupsheaderdiv.height(this.groupsheaderheight);
                    this.groupsheaderdiv.css('top', 0);
                    this.groupsheader.append(this.groupsheaderdiv);
                    this.groupheadersbounds = new Array();

                    var groupslength = this.groups.length;

                    // remove handlers and children.
                    this.groupsheaderdiv.children().remove();
                    this.groupsheaderdiv[0].innerHTML = '';

                    var groups = new Array();
                    if (groupslength > 0) {
                        $.each(this.groups, function (index) {
                            var groupcolumn = this;
                            var groupcolumninfo = me._getColumnText(this);
                            var text = groupcolumninfo.label;
                            var group = me._rendergroupcolumn(text, groupcolumn);
                            group.addClass(me.toThemeProperty('jqx-grid-group-column'));
                            me.groupsheaderdiv.append(group);
                            if (me.closeablegroups) {
                                var closebutton = $(group.find('.jqx-icon-close'));
                                if (me.isTouchDevice() && me.touchmode !== true) {
                                    me.addHandler(closebutton, 'touchstart', function () {
                                        me.removegroupat(index);
                                        return false;
                                    });
                                }
                                else {
                                    me.addHandler(closebutton, 'click', function () {
                                        me.removegroupat(index);
                                        return false;
                                    });
                                }
                            }
                            if (me.sortable) {
                                me.addHandler(group, 'click', function () {
                                    var columnitem = me.getcolumn(groupcolumn);
                                    if (columnitem != null) {
                                        me._togglesort(columnitem);
                                    }
                                    return false;
                                });
                            }
                            groups[groups.length] = group;
                            me._handlegroupstocolumnsdragdrop(this, group);
                            if (index < groupslength - 1) {
                                var height = group.height();
                                var line = $('<div style="float: left; position: relative;"></div>');
                                if (me.rtl) {
                                    line.css('float', 'right');
                                }

                                line.width(me.groupindentwidth / 3);
                                line.height(1);
                                line.css('top', height / 2);
                                line.addClass(me.toThemeProperty('jqx-grid-group-column-line'));
                                me.groupsheaderdiv.append(line);
                            }
                        });
                    }
                    else {
                        var emptygroupselement = $('<div style="position: relative;">' + groupsheaderstring + '</div>');
                        this.groupsheaderdiv.append(emptygroupselement);
                        if (this.rtl) {
                            emptygroupselement.addClass(this.toThemeProperty('jqx-rtl'));
                        }
                    }

                    this._groupheaders = groups;
                    this._updategroupheadersbounds();
                }
            },

            _updategroupheadersbounds: function () {
                var me = this;
                var headerdivheight = this.groupsheaderdiv.children().outerHeight();
                var top = (this.groupsheader.height() - headerdivheight) / 2;
                this.groupsheaderdiv.css('top', top);
                if (!this.rtl) {
                    this.groupsheaderdiv.css('left', top);
                    this.groupsheaderdiv.css('right', '');
                }
                else {
                    this.groupsheaderdiv.css('left', '');
                    this.groupsheaderdiv.css('right', top);
                }

                if (this.rtl) this._groupheaders.reverse();
                $.each(this._groupheaders, function (index) {
                    var groupoffset = this.coord();
                    me.groupheadersbounds[index] = { left: groupoffset.left, top: groupoffset.top, width: this.outerWidth(), height: this.outerHeight(), index: index };
                });

            },

            // adds a group.
            addgroup: function (datafield) {
                if (datafield) {
                    var self = this;
                    if (self.groups !== self.dataview.groups) {
                        self.dataview.groups = self.groups;
                    }
                    self.groups[self.groups.length] = datafield;
                    self.refreshgroups();
                    this._raiseEvent(12, { type: "Add", index: self.groups[self.groups.length], groups: self.groups });
                }
            },

            // inserts a new group.
            insertgroup: function (index, datafield) {
                if (index != undefined && index != null && index >= 0 && index <= this.groups.length) {
                    if (datafield) {
                        var self = this;
                        if (self.groups !== self.dataview.groups) {
                            self.dataview.groups = self.groups;
                        }
                        self.groups.splice(index, 0, datafield.toString());
                        self.refreshgroups();
                        this._raiseEvent(12, { type: "Insert", index: index, groups: self.groups });
                    }
                }
            },

            refreshgroups: function () {
                this._refreshdataview();
                this._render(true, true, true, false);
                this._postrender('group');
            },

            _insertaftergroup: function (groupfield, datafield) {
                var index = this._getGroupIndexByDataField(groupfield);
                this.insertgroup(index + 1, datafield);
            },

            _insertbeforegroup: function (groupfield, datafield) {
                var index = this._getGroupIndexByDataField(groupfield);
                this.insertgroup(index, datafield);
            },

            // removes a group by index.
            removegroupat: function (index) {
                if (index >= 0 && index != null && index != undefined) {
                    var self = this;
                    if (self.groups !== self.dataview.groups) {
                        self.dataview.groups = self.groups;
                    }
                    self.groups.splice(index, 1);
                    self.refreshgroups();
                    if (self.virtualmode) {
                        self.updatebounddata();
                    }
                    this._raiseEvent(12, { type: "Remove", index: index, groups: self.groups });
                    return true;
                }
                return false;
            },

            cleargroups: function () {
                var self = this;
                self.groups = [];
                self.dataview.groups = self.groups;
                self.refreshgroups();
                this._raiseEvent(12, { type: "Clear", index: -1, groups: self.groups });
                return true;
            },

            // removes a group by datafield
            removegroup: function (datafield) {
                if (datafield == null)
                    return false;

                var index = this.groups.indexOf(datafield.toString());
                return this.removegroupat(index);
            },


            // gets the number of root groups.
            getrootgroupscount: function () {
                var count = this.dataview.loadedrootgroups.length;
                return count;
            },

            // collapses a group.
            collapsegroup: function (index) {
                if (index >= 0 && index.toString().indexOf(".") === -1) {
                    return this._setrootgroupstate(index, false);
                }
                var groupsToExpand = index.toString().split('.');
                var group = null;
                if (!this.groupsVisibility) {
                    this.groupsVisibility = new Array();
                }
                for (var i = 0; i < groupsToExpand.length; i++) {
                    var index = parseInt(groupsToExpand[i]);
                    if (i == 0) {
                        var group = this.dataview.loadedrootgroups[index];
                        this.groupsVisibility[group.group] = null;
                    }
                    else {
                        var subGroup = group.subGroups[index];
                        if (subGroup) {
                            group = subGroup;
                            if (i == groupsToExpand.length - 1) {
                                this._setgroupstate(group, false, true);
                                this.groupsVisibility[group.group] = null;
                            }
                        }
                    }
                }
            },

            // expands a group.
            expandgroup: function (index) {
                if (index >= 0 && index.toString().indexOf(".") === -1) {
                    return this._setrootgroupstate(index, true);
                }

                var groupsToExpand = index.toString().split('.');
                var group = null;
                for (var i = 0; i < groupsToExpand.length; i++) {
                    var index = parseInt(groupsToExpand[i]);
                    if (i == 0) {
                        var group = this.dataview.loadedrootgroups[index];
                        this._setrootgroupstate(index, true);
                        if (!this.groupsVisibility) {
                            this.groupsVisibility = new Array();
                        }
                        this.groupsVisibility[group.group] = group;
                    }
                    else {
                        var subGroup = group.subGroups[index];
                        if (subGroup) {
                            group = subGroup;
                            this._setgroupstate(group, true, true);
                            if (!this.groupsVisibility) {
                                this.groupsVisibility = new Array();
                            }
                            this.groupsVisibility[group.group] = group;
                        }
                    }
                }
            },

            // collapses all groups.
            collapseallgroups: function (refresh) {
                this._setbatchgroupstate(false, refresh);
            },

            // expands all groups.
            expandallgroups: function (refresh) {
                this._setbatchgroupstate(true, refresh);
            },

            isgroupexpanded: function (index) {
                var group = this.dataview.loadedrootgroups[index];
                if (group == null)
                    return null;

                var expanded = this.expandedgroups[group.uniqueid].expanded;
                return expanded;
            },

            jsonParser: function () {
                var
                    // should be a not so common char
                    // possibly one JSON does not encode
                    // possibly one encodeURIComponent does not encode
                    // right now this char is '~' but this might change in the future
                    specialChar = '~',
                    safeSpecialChar = '\\x' + (
                        '0' + specialChar.charCodeAt(0).toString(16)
                    ).slice(-2),
                    escapedSafeSpecialChar = '\\' + safeSpecialChar,
                    specialCharRG = new RegExp(safeSpecialChar, 'g'),
                    safeSpecialCharRG = new RegExp(escapedSafeSpecialChar, 'g'),

                    safeStartWithSpecialCharRG = new RegExp('(?:^|([^\\\\]))' + escapedSafeSpecialChar),

                    indexOf = [].indexOf || function (v) {
                        for (var i = this.length; i-- && this[i] !== v;);
                        return i;
                    },
                    $String = String  // there's no way to drop warnings in JSHint
                    // about new String ... well, I need that here!
                    // faked, and happy linter!
                    ;

                function generateReplacer(value, replacer, resolve) {
                    var
                        doNotIgnore = false,
                        inspect = !!replacer,
                        path = [],
                        all = [value],
                        seen = [value],
                        mapp = [resolve ? specialChar : '[Circular]'],
                        last = value,
                        lvl = 1,
                        i, fn
                        ;
                    if (inspect) {
                        fn = typeof replacer === 'object' ?
                            function (key, value) {
                                return key !== '' && indexOf.call(replacer, key) < 0 ? void 0 : value;
                            } :
                            replacer;
                    }
                    return function (key, value) {
                        // the replacer has rights to decide
                        // if a new object should be returned
                        // or if there's some key to drop
                        // let's call it here rather than "too late"
                        if (inspect) value = fn.call(this, key, value);

                        // first pass should be ignored, since it's just the initial object
                        if (doNotIgnore) {
                            if (last !== this) {
                                i = lvl - indexOf.call(all, this) - 1;
                                lvl -= i;
                                all.splice(lvl, all.length);
                                path.splice(lvl - 1, path.length);
                                last = this;
                            }
                            // console.log(lvl, key, path);
                            if (typeof value === 'object' && value) {
                                // if object isn't referring to parent object, add to the
                                // object path stack. Otherwise it is already there.
                                if (indexOf.call(all, value) < 0) {
                                    all.push(last = value);
                                }
                                lvl = all.length;
                                i = indexOf.call(seen, value);
                                if (i < 0) {
                                    i = seen.push(value) - 1;
                                    if (resolve) {
                                        // key cannot contain specialChar but could be not a string
                                        path.push(('' + key).replace(specialCharRG, safeSpecialChar));
                                        mapp[i] = specialChar + path.join(specialChar);
                                    } else {
                                        mapp[i] = mapp[0];
                                    }
                                } else {
                                    value = mapp[i];
                                }
                            } else {
                                if (typeof value === 'string' && resolve) {
                                    // ensure no special char involved on deserialization
                                    // in this case only first char is important
                                    // no need to replace all value (better performance)
                                    value = value.replace(safeSpecialChar, escapedSafeSpecialChar)
                                        .replace(specialChar, safeSpecialChar);
                                }
                            }
                        } else {
                            doNotIgnore = true;
                        }
                        return value;
                    };
                }

                function retrieveFromPath(current, keys) {
                    for (var i = 0, length = keys.length; i < length; current = current[
                        // keys should be normalized back here
                        keys[i++].replace(safeSpecialCharRG, specialChar)
                    ]);
                    return current;
                }

                function generateReviver(reviver) {
                    return function (key, value) {
                        var isString = typeof value === 'string';
                        if (isString && value.charAt(0) === specialChar) {
                            return new $String(value.slice(1));
                        }
                        if (key === '') value = regenerate(value, value, {});
                        // again, only one needed, do not use the RegExp for this replacement
                        // only keys need the RegExp
                        if (isString) value = value.replace(safeStartWithSpecialCharRG, '$1' + specialChar)
                            .replace(escapedSafeSpecialChar, safeSpecialChar);
                        return reviver ? reviver.call(this, key, value) : value;
                    };
                }

                function regenerateArray(root, current, retrieve) {
                    for (var i = 0, length = current.length; i < length; i++) {
                        current[i] = regenerate(root, current[i], retrieve);
                    }
                    return current;
                }

                function regenerateObject(root, current, retrieve) {
                    for (var key in current) {
                        if (current.hasOwnProperty(key)) {
                            current[key] = regenerate(root, current[key], retrieve);
                        }
                    }
                    return current;
                }

                function regenerate(root, current, retrieve) {
                    return current instanceof Array ?
                        // fast Array reconstruction
                        regenerateArray(root, current, retrieve) :
                        (
                            current instanceof $String ?
                                (
                                    // root is an empty string
                                    current.length ?
                                        (
                                            retrieve.hasOwnProperty(current) ?
                                                retrieve[current] :
                                                retrieve[current] = retrieveFromPath(
                                                    root, current.split(specialChar)
                                                )
                                        ) :
                                        root
                                ) :
                                (
                                    current instanceof Object ?
                                        // dedicated Object parser
                                        regenerateObject(root, current, retrieve) :
                                        // value as it is
                                        current
                                )
                        )
                        ;
                }

                var CircularJSON = {
                    stringify: function stringify(value, replacer, space, doNotResolve) {
                        return CircularJSON.parser.stringify(
                            value,
                            generateReplacer(value, replacer, !doNotResolve),
                            space
                        );
                    },
                    parse: function parse(text, reviver) {
                        return CircularJSON.parser.parse(
                            text,
                            generateReviver(reviver)
                        );
                    },
                    // A parser should be an API 1:1 compatible with JSON
                    // it should expose stringify and parse methods.
                    // The default parser is the native JSON.
                    parser: JSON
                };

                return CircularJSON;
            },

            // gets a group by index.
            getgroup: function (index) {
                var group = this.dataview.loadedrootgroups[index];
                if (group == null)
                    return null;

                var expanded = this.expandedgroups[group.uniqueid].expanded;
                var groupname = group.group;
                var level = group.level;

                var subgroups = new Array();
                this._getsubgroups(subgroups, group);
                var me = this;
                var obj = { group: groupname, level: level, expanded: expanded, subgroups: subgroups };
                if (group.subItems) {
                    var items = new Array();
                    $.each(group.subItems, function () {
                        var index = this.boundindex;
                        items[items.length] = me.getrowdata(index);
                    });
                    if (items.length > 0) {
                        obj.subrows = items;
                    }
                }

                var str = this.jsonParser().stringify(group);

                str = str.replace(/subItems/ig, 'subrows');
                str = str.replace(/subGroups/ig, 'subgroups');
                obj = this.jsonParser().parse(str);
                obj.expanded = expanded;

                return obj;
            },

            getrootgroups: function () {
                var count = this.dataview.loadedrootgroups.length;
                var groups = new Array();
                for (var m = 0; m < count; m++) {
                    groups[m] = this.getgroup(m);
                }
                return groups;
            },

            _getsubgroups: function (subgroups, group) {
                var me = this;
                for (var obj in group.subGroups) {
                    var subGroup = group.subGroups[obj];
                    var expanded = me.expandedgroups[subGroup.uniqueid].expanded;
                    var groupname = subGroup.group;
                    var level = subGroup.level;
                    subgroups[subgroups.length] = { group: groupname, level: level, expanded: expanded };
                    if (subGroup.subItems) {
                        var items = new Array();
                        $.each(subGroup.subItems, function () {
                            var index = this.boundindex;
                            items[items.length] = me.getrowdata(index);
                        });
                        subgroups[subgroups.length - 1].subrows = items;
                    }
                    if (subGroup.subGroups) {
                        var childsubgroups = new Array();
                        me._getsubgroups(childsubgroups, subGroup);
                    }
                }

                return subgroups;
            },

            _setbatchgroupstate: function (expanded, update) {
                var me = this;
                for (var obj in this.dataview.loadedrootgroups) {
                    me._setrootgroupstate(obj, expanded, false, true);
                }

                if (update == false) {
                    me._requiresupdate = true;
                    me._renderrows(me.virtualsizeinfo);
                    return true;
                }

                var scrollBarVisibility = this.vScrollBar[0].style.visibility;
                this.rendergridcontent(true, false);
                if (scrollBarVisibility != this.vScrollBar[0].style.visibility || this._hiddencolumns) {
                    this._updatecolumnwidths();
                    this._updatecellwidths();
                    this._renderrows(this.virtualsizeinfo);
                }

                return true;
            },

            _setrootgroupstate: function (index, expanded, refresh, applytosubgroups) {
                if (index == undefined || index == null || index < 0)
                    return false;

                if (!this.groupable || this.groups.length == 0)
                    return false;

                var update = refresh != undefined ? refresh : true;

                if (index >= 0 && index < this.dataview.loadedrootgroups.length) {
                    var group = this.dataview.loadedrootgroups[index];
                    if (this.pageable) {
                        var rootgroups = new Array();
                        for (var i = 0; i < this.dataview.rows.length; i++) {
                            if (this.dataview.rows[i].group != null && this.dataview.rows[i].level === 0) {
                                rootgroups.push(this.dataview.rows[i]);
                            }
                        }

                        group = rootgroups[index];
                        if (!group) {
                            return;
                        }
                    }

                    return this._setgroupstate(group, expanded, update, applytosubgroups);
                }

                return false;
            },

            _togglegroupstate: function (group, update) {
                if (group == null || group == undefined)
                    return false;

                var scrollPosition = this.vScrollInstance.value;
                var groupstate = this.expandedgroups[group.uniqueid];
                if (groupstate == undefined) {
                    groupstate = false;
                }
                else {
                    groupstate = groupstate.expanded;
                }
                groupstate = !groupstate;
                if (!this.groupsVisibility) {
                    this.groupsVisibility = new Array();
                }
                if (groupstate) {
                    this.groupsVisibility[group.group] = group;
                }
                else {
                    this.groupsVisibility[group.group] = null;
                }
                var result = this._setgroupstate(group, groupstate, update);
                this._newmax = null;
                if (scrollPosition !== 0 && this.vScrollBar.css('visibility') !== 'hidden') {
                    if (scrollPosition <= this.vScrollInstance.max) {
                        this.vScrollInstance.setPosition(scrollPosition);
                    }
                    else {
                        this.vScrollInstance.setPosition(this.vScrollInstance.max);
                    }
                } return result;
            },

            _setgroupstate: function (group, expanded, update, applytosubgroups) {
                if (group == null || group == undefined)
                    return false;

                var isDirty = false;

                if (this.editable && this.editcell) {
                    this.endcelledit(this.editcell.row, this.editcell.column, false, false);
                }

                var groupstate = this.expandedgroups[group.uniqueid];
                if (groupstate == undefined) {
                    groupstate = { expanded: false };
                    isDirty = true;
                }

                if (groupstate.expanded != expanded || applytosubgroups) {
                    isDirty = true;
                }

                if (isDirty) {
                    this.expandedgroups[group.uniqueid] = { expanded: expanded, group: group };

                    this._setsubgroupsvisibility(this, group, !expanded, applytosubgroups);
                    if (update) {
                        var scrollBarVisibility = this.vScrollBar[0].style.visibility;
                        this.rendergridcontent(true, false);
                        if (scrollBarVisibility != this.vScrollBar[0].style.visibility || this._hiddencolumns) {
                            this._updatecolumnwidths();
                            this._updatecellwidths();
                            this._renderrows(this.virtualsizeinfo);
                        }
                    }

                    if (undefined == this.suspendgroupevents || this.suspendgroupevents == false) {
                        if (expanded) {
                            this._raiseEvent(4, { group: group.group, parentgroup: group.parentItem ? group.parentItem.group : null, level: group.level, visibleindex: group.visibleindex });
                        }
                        else {
                            this._raiseEvent(5, { group: group.group, parentgroup: group.parentItem ? group.parentItem.group : null, level: group.level, visibleindex: group.visibleindex });
                        }
                    }

                    return true;
                }

                return false;
            },

            _setgroupitemsvisibility: function (self, group, hidden) {
                for (var m = 0; m < group.subItems.length; m++) {
                    self._setrowvisibility(group.subItems[m].visibleindex, hidden, false);
                }
            },

            _setsubgroupsvisibility: function (self, group, hidden, applytosubgroups) {
                if (group.parentItem != null) {
                    if (this.hiddens[group.parentItem.visibleindex])
                        return;
                }
                else if (group.parentItem == null) {
                    if (this.hiddens[group.visibleindex])
                        return;
                }

                for (var subGroup in group.subGroups) {
                    var currentGroup = group.subGroups[subGroup];

                    if (!hidden) {
                        self._setrowvisibility(currentGroup.visibleindex, hidden, false);
                    }

                    var expanded = !hidden;

                    if (!applytosubgroups) {
                        if (self.expandedgroups[currentGroup.uniqueid] == undefined) {
                            expanded = false;
                        }
                        else {
                            expanded = self.expandedgroups[currentGroup.uniqueid].expanded;
                        }
                    }
                    else {
                        this.expandedgroups[currentGroup.uniqueid] = { expanded: expanded, group: currentGroup };
                    }

                    if (currentGroup.subGroups) {
                        if (currentGroup.subGroups.length > 0) {
                            self._setsubgroupsvisibility(self, currentGroup, !expanded || hidden, applytosubgroups);
                        }
                        else if (currentGroup.subItems.length > 0) {
                            self._setgroupitemsvisibility(self, currentGroup, !expanded || hidden);
                        }
                    }

                    if (hidden) {
                        self._setrowvisibility(currentGroup.visibleindex, hidden, false);
                    }
                }
                if (group.subItems && group.subItems.length > 0) {
                    self._setgroupitemsvisibility(self, group, hidden);
                }
            },



            _handlecolumnsdragdrop: function () {
                var self = this;
                var dropindex = -1;
                var candrop = false;

                if (!self.groupable)
                    return;

                var mousemove = 'mousemove.grouping' + this.element.id;
                var mousedown = 'mousedown.grouping' + this.element.id;
                var mouseup = 'mouseup.grouping' + this.element.id;

                var touchdevice = false;
                if (this.isTouchDevice() && this.touchmode !== true) {
                    touchdevice = true;
                    mousemove = $.jqx.mobile.getTouchEventName('touchmove') + '.grouping' + this.element.id;
                    mousedown = $.jqx.mobile.getTouchEventName('touchstart') + '.grouping' + this.element.id;
                    mouseup = $.jqx.mobile.getTouchEventName('touchend') + '.grouping' + this.element.id;
                }

                this.removeHandler($(document), mousemove);
                this.addHandler($(document), mousemove, function (event) {
                    if (!self.showgroupsheader)
                        return true;

                    if (self.dragcolumn != null) {
                        var left = parseInt(event.pageX);
                        var top = parseInt(event.pageY);
                        if (touchdevice) {
                            var touches = self.getTouches(event);
                            var touch = touches[0];
                            left = parseInt(touch.pageX);
                            top = parseInt(touch.pageY);
                        }
                        var hostoffset = self.host.coord();
                        var hostleft = parseInt(hostoffset.left);
                        var hosttop = parseInt(hostoffset.top);
                        if (self.dragmousedownoffset == undefined || self.dragmousedownoffset == null) {
                            self.dragmousedownoffset = { left: 0, top: 0 };
                        }

                        var leftposition = parseInt(left) - parseInt(self.dragmousedownoffset.left);
                        var topposition = parseInt(top) - parseInt(self.dragmousedownoffset.top);

                        self.dragcolumn.css({ left: leftposition + 'px', top: topposition + 'px' });
                        candrop = false;
                        if (left >= hostleft && left <= hostleft + self.host.width()) {
                            if (top >= hosttop && top <= hosttop + self.host.height()) {
                                candrop = true;
                            }
                        }
                        dropindex = -1;
                        if (candrop) {
                            self.dragcolumnicon.removeClass(self.toThemeProperty('jqx-grid-dragcancel-icon'));
                            self.dragcolumnicon.addClass(self.toThemeProperty('jqx-grid-drag-icon'));
                            var groupsheaderoffset = self.groupsheader.coord();
                            var groupsheaderbottom = groupsheaderoffset.top + self.groupsheader.height();
                            var datarecord = $.data(self.dragcolumn[0], 'datarecord');
                            if (datarecord) {
                                var indexingroups = self.groups.indexOf(datarecord.toString());
                            }
                            else {
                                var indexingroups = -1;
                            }

                            var candrag = (indexingroups == -1) || (self.groups.length > 1 && indexingroups > -1);

                            if (self.dropline != null) {
                                if (top >= groupsheaderoffset.top && top <= groupsheaderbottom) {
                                    if (candrag) {
                                        dropindex = self._handlegroupdroplines(left);
                                    }
                                }
                                else {
                                    self.dropline.fadeOut('slow');
                                }
                            }
                        }
                        else {
                            if (self.dropline != null) {
                                self.dropline.fadeOut('slow');
                            }

                            self.dragcolumnicon.removeClass(self.toThemeProperty('jqx-grid-drag-icon'));
                            self.dragcolumnicon.addClass(self.toThemeProperty('jqx-grid-dragcancel-icon'));
                        }
                        if (touchdevice) {
                            event.preventDefault();
                            event.stopPropagation();
                            return false;
                        }
                        //   return false;
                    }
                }, { passive: false });

                this.removeHandler($(document), mouseup);
                this.addHandler($(document), mouseup, function (event) {
                    if (!self.showgroupsheader)
                        return true;

                    self.__drag = false;

                    $(document.body).removeClass('jqx-disableselect');
                    var left = parseInt(event.pageX);
                    var top = parseInt(event.pageY);
                    if (touchdevice) {
                        var touches = self.getTouches(event);
                        var touch = touches[0];
                        left = parseInt(touch.pageX);
                        top = parseInt(touch.pageY);
                    }
                    var hostoffset = self.host.coord();
                    var hostleft = parseInt(hostoffset.left);
                    var hosttop = parseInt(hostoffset.top);
                    var groupsheaderheight = self.groupsheader.height();
                    if (self.showtoolbar) {
                        hosttop += self.toolbarheight;
                    }
                    if (self.showfilterbar) {
                        hosttop += self.toolbarheight;
                    }

                    self.dragstarted = false;
                    self.dragmousedown = null;
                    if (self.dragcolumn != null) {
                        var datafield = $.data(self.dragcolumn[0], 'datarecord');
                        self.dragcolumn.remove();
                        self.dragcolumn = null;

                        if (datafield != null) {
                            if (!self.getcolumn(datafield).groupable) {
                                if (self.dropline != null) {
                                    self.dropline.remove();
                                    self.dropline = null;
                                }
                                return;
                            }

                            if (candrop) {
                                if (dropindex != -1) {
                                    var index = dropindex.index;
                                    var targetgroup = self.groups[index];

                                    var indexInGroups = self._getGroupIndexByDataField(datafield);
                                    if (indexInGroups != index) {
                                        if (indexInGroups != undefined && indexInGroups >= 0) {
                                            self.groups.splice(indexInGroups, 1);
                                        }

                                        if (dropindex.position == 'before') {
                                            if (!self.rtl) {
                                                self._insertbeforegroup(targetgroup, datafield);
                                            }
                                            else {
                                                self._insertaftergroup(targetgroup, datafield);
                                            }
                                        }
                                        else {
                                            if (!self.rtl) {
                                                self._insertaftergroup(targetgroup, datafield);
                                            }
                                            else {
                                                self._insertbeforegroup(targetgroup, datafield);
                                            }
                                        }
                                    }
                                }
                                else if (self.groups.length == 0) {
                                    if (top > hosttop && top <= hosttop + groupsheaderheight) {
                                        self.addgroup(datafield);
                                    }
                                }
                                else if (top > hosttop + groupsheaderheight) {
                                    var indexInGroups = self._getGroupIndexByDataField(datafield);
                                    self.removegroupat(indexInGroups);
                                }
                            }

                            if (self.dropline != null) {
                                self.dropline.remove();
                                self.dropline = null;
                            }
                        }
                        //  return false;
                    }
                });
            },

            _getGroupIndexByDataField: function (datafield) {
                for (var i = 0; i < this.groups.length; i++) {
                    if (this.groups[i] == datafield)
                        return i;
                }
                return -1;
            },

            _isColumnInGroups: function (column) {
                for (var i = 0; i < this.groups.length; i++) {
                    if (this.groups[i] == column)
                        return true;
                }
                return false;
            },


            _handlegroupdroplines: function (left) {
                var self = this;
                var dropindex = -1;

                $.each(self.groupheadersbounds, function (index) {
                    if (left <= this.left + this.width / 2) {
                        var groupleft = this.left - 3;
                        if (index > 0) {
                            groupleft = this.left - 1 - self.groupindentwidth / 6;
                        }

                        self.dropline.css('left', groupleft);
                        self.dropline.css('top', this.top);
                        self.dropline.height(this.height);
                        self.dropline.fadeIn('slow');

                        dropindex = { index: index, position: 'before' };
                        if (self.rtl) {
                            dropindex = { index: self.groupheadersbounds.length - 1 - index, position: 'before' };
                        }

                        return false;
                    }
                    else if (left >= this.left + this.width / 2) {
                        self.dropline.css('left', 1 + this.left + this.width);
                        self.dropline.css('top', this.top);
                        self.dropline.height(this.height);
                        self.dropline.fadeIn('slow');
                        dropindex = { index: index, position: 'after' };
                        if (self.rtl) {
                            dropindex = { index: self.groupheadersbounds.length - 1 - index, position: 'after' };
                        }
                    }
                });

                return dropindex;
            },


            _handlegroupstocolumnsdragdrop: function (datafield, column) {
                this.dragmousedown = null;
                this.dragmousedownoffset = null;
                this.dragstarted = false;
                this.dragcolumn = null;
                var me = this;
                var mousemove;

                var mousedownevent = 'mousedown';
                var mousemoveevent = 'mousemove';

                var touchdevice = false;
                if (this.isTouchDevice() && this.touchmode !== true) {
                    touchdevice = true;
                    mousedownevent = $.jqx.mobile.getTouchEventName('touchstart');
                    mousemoveevent = $.jqx.mobile.getTouchEventName('touchmove');
                }
                this.addHandler(column, 'dragstart', function (event) {
                    return false;
                });

                this.addHandler(column, mousedownevent, function (event) {
                    if (!me.showgroupsheader)
                        return true;

                    var left = event.pageX;
                    var top = event.pageY;

                    me.__drag = true;
                    me.dragmousedown = { left: left, top: top };
                    if (touchdevice) {
                        var touches = me.getTouches(event);
                        var touch = touches[0];
                        left = touch.pageX;
                        top = touch.pageY;
                        me.dragmousedown = { left: left, top: top };
                        if (event.preventDefault) {
                            event.preventDefault();
                        }
                    }

                    var offsetposition = $(event.target).coord();
                    me.dragmousedownoffset = { left: parseInt(left) - parseInt(offsetposition.left), top: parseInt(top - offsetposition.top) };
                });

                this.addHandler(column, mousemoveevent, function (event) {
                    if (!me.showgroupsheader)
                        return true;

                    if (me.dragmousedown) {
                        mousemove = { left: event.pageX, top: event.pageY };
                        if (touchdevice) {
                            var touches = me.getTouches(event);
                            var touch = touches[0];
                            mousemove = { left: touch.pageX, top: touch.pageY };
                        }
                        if (!me.dragstarted && me.dragcolumn == null) {
                            var xoffset = Math.abs(mousemove.left - me.dragmousedown.left);
                            var yoffset = Math.abs(mousemove.top - me.dragmousedown.top);
                            if (xoffset > 3 || yoffset > 3) {
                                me._createdragcolumn(column, mousemove, true);
                                $(document.body).addClass('jqx-disableselect');
                                $.data(me.dragcolumn[0], 'datarecord', datafield);
                                if (event.preventDefault) {
                                    event.preventDefault();
                                }
                            }
                        }
                    }
                }, { passive: false });
            },


            _createdragcolumn: function (column, position, hasdropline) {
                var me = this;
                var mousemove = position;

                me.dragcolumn = $('<div></div>');
                var columnclone = column.clone();
                me.dragcolumn.css('z-index', 999999);
                columnclone.css('border-width', '1px');
                columnclone.css('opacity', '0.4');
                var menubutton = $(columnclone.find('.' + me.toThemeProperty('jqx-grid-column-menubutton')));
                if (menubutton.length > 0) {
                    menubutton.css('display', 'none');
                }
                var closebutton = $(columnclone.find('.jqx-icon-close'));
                if (closebutton.length > 0) {
                    closebutton.css('display', 'none');
                }

                me.dragcolumnicon = $('<div style="z-index: 9999; position: absolute; left: 100%; top: 50%; margin-left: -18px; margin-top: -7px;"></div>');
                me.dragcolumnicon.addClass(me.toThemeProperty('jqx-grid-drag-icon'));
                me.dragcolumn.css('float', 'left');

                me.dragcolumn.css('position', 'absolute');
                var hostoffset = me.host.coord();
                columnclone.width(column.width() + 16);
                me.dragcolumn.append(columnclone);
                me.dragcolumn.height(column.height());
                me.dragcolumn.width(columnclone.width());
                me.dragcolumn.append(me.dragcolumnicon);
                $(document.body).append(me.dragcolumn);

                columnclone.css('margin-left', 0);
                columnclone.css('left', 0);
                columnclone.css('top', 0);
                me.dragcolumn.css('left', mousemove.left + me.dragmousedown.left);
                me.dragcolumn.css('top', mousemove.top + me.dragmousedown.top);

                if (hasdropline != undefined && hasdropline) {
                    me.dropline = $('<div style="display: none; position: absolute;"></div>');

                    me.dropline.width(2);
                    me.dropline.addClass(me.toThemeProperty('jqx-grid-group-drag-line'));
                    $(document.body).append(me.dropline);
                }
            },

            // gets column's groupable.
            iscolumngroupable: function (datafield) {
                return this._getcolumnproperty(datafield, 'groupable');
            },


            _handlecolumnstogroupsdragdrop: function (record, column) {
                this.dragmousedown = null;
                this.dragmousedownoffset = null;
                this.dragstarted = false;
                this.dragcolumn = null;

                var me = this;
                var mousemove;
                var touchdevice = false;
                if (this.isTouchDevice() && this.touchmode !== true) {
                    touchdevice = true;
                }

                var mousedown = 'mousedown.drag';
                var mousemove = 'mousemove.drag';
                if (touchdevice) {
                    mousedown = $.jqx.mobile.getTouchEventName('touchstart') + '.drag';
                    mousemove = $.jqx.mobile.getTouchEventName('touchmove') + '.drag';
                }
                else {
                    this.addHandler(column, 'dragstart', function (event) {
                        return false;
                    });
                }

                this.addHandler(column, mousedown, function (event) {
                    if (!me.showgroupsheader)
                        return true;

                    me.__drag = true;

                    if (me._isColumnInGroups(record.displayfield)) {
                        if (column.css('cursor') != 'col-resize') {
                            return true;
                        }
                        else return true;
                    }
                    if (false == record.groupable) {
                        return true;
                    }

                    var pagex = event.pageX;
                    var pagey = event.pageY;
                    if (touchdevice) {
                        var touches = me.getTouches(event);
                        var touch = touches[0];
                        pagex = touch.pageX;
                        pagey = touch.pageY;
                    }

                    me.dragmousedown = { left: pagex, top: pagey };
                    if (touchdevice) {
                        if (event.preventDefault) event.preventDefault();
                    }

                    var offsetposition = $(event.target).coord();
                    me.dragmousedownoffset = { left: parseInt(pagex) - parseInt(offsetposition.left), top: parseInt(pagey - offsetposition.top) };
                });

                this.addHandler(column, mousemove, function (event) {
                    if (!me.showgroupsheader)
                        return true;

                    if (me._isColumnInGroups(record.displayfield))
                        if (column.css('cursor') != 'col-resize') {
                            return true;
                        }
                        else {
                            return true;
                        }

                    if (me.dragmousedown) {
                        var pagex = event.pageX;
                        var pagey = event.pageY;
                        if (touchdevice) {
                            var touches = me.getTouches(event);
                            var touch = touches[0];
                            pagex = touch.pageX;
                            pagey = touch.pageY;
                        }
                        mousemove = { left: pagex, top: pagey };
                        if (!me.dragstarted && me.dragcolumn == null) {
                            var xoffset = Math.abs(mousemove.left - me.dragmousedown.left);
                            var yoffset = Math.abs(mousemove.top - me.dragmousedown.top);
                            if (xoffset > 3 || yoffset > 3) {
                                me._createdragcolumn(column, mousemove, true);
                                $.data(me.dragcolumn[0], 'datarecord', record.displayfield);
                                if (event.preventDefault) {
                                    event.preventDefault();
                                }
                            }
                        }
                    }
                });
            },


            _rendergroupcolumn: function (text, groupcolumn) {
                var group = $('<div style="float: left; position: relative;"></div>');
                if (this.rtl) {
                    group.css('float', 'right');
                }

                if (this.groupcolumnrenderer != null) {
                    group[0].innerHTML = this.groupcolumnrenderer(text);
                    group.addClass(this.toThemeProperty('jqx-grid-group-column'));
                    group.addClass(this.toThemeProperty('jqx-fill-state-normal'));
                }

                if (this.closeablegroups) {
                    if (group[0].innerHTML == '') {
                        group[0].innerHTML = '<a style="float: left;" href="#">' + text + '</a>';
                    }
                    if (this.rtl) {
                        group[0].innerHTML = '<a style="float: right;" href="#">' + text + '</a>';
                    }
                    var fl = !this.rtl ? 'right' : 'left';

                    if (this.groupcolumnrenderer != null) {
                        group[0].innerHTML = this.groupcolumnrenderer(text);
                        group.addClass(this.toThemeProperty('jqx-grid-group-column'));
                        group.addClass(this.toThemeProperty('jqx-fill-state-normal'));
                    }

                    var closebutton = '<div style="float: ' + fl + '; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 100%; top: 50%; margin-left: -18px; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-icon-close') + '"></div></div>';
                    if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                        closebutton = '<div style="float: left; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 100%; top: 50%; margin-left: -18px; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-icon-close') + '"></div></div>';
                    }
                    if (this.rtl) {
                        var closebutton = '<div style="float: ' + fl + '; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 0px; top: 50%; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-icon-close') + '"></div></div>';
                        if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                            closebutton = '<div style="float: left; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 0px; top: 50%; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-icon-close') + '"></div></div>';
                        }
                    }

                    group[0].innerHTML += closebutton;
                }
                else {
                    if (group[0].innerHTML == '') {
                        group[0].innerHTML = '<a href="#">' + text + '</a>';
                    }
                }

                if (this.sortable) {
                    var sortasc = $('<div style="float: right; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 100%; top: 50%; margin-left: -16px; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-grid-column-sortascbutton') + '"></div></div>');
                    var sortdesc = $('<div style="float: right; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 100%; top: 50%; margin-left: -16px; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-grid-column-sortdescbutton') + '"></div></div>');
                    if (this.closeablegroups) {
                        var sortasc = $('<div style="float: right; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 100%; top: 50%; margin-left: -32px; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-grid-column-sortascbutton') + '"></div></div>');
                        var sortdesc = $('<div style="float: right; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 100%; top: 50%; margin-left: -32px; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-grid-column-sortdescbutton') + '"></div></div>');
                    }
                    if (this.rtl) {
                        var sortasc = $('<div style="float: right; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 0px; top: 50%; margin-left: 0px; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-grid-column-sortascbutton') + '"></div></div>');
                        var sortdesc = $('<div style="float: right; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 0px; top: 50%; margin-left: 0px; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-grid-column-sortdescbutton') + '"></div></div>');
                        if (this.closeablegroups) {
                            var sortasc = $('<div style="float: right; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 0px; top: 50%; margin-left: 16px; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-grid-column-sortascbutton') + '"></div></div>');
                            var sortdesc = $('<div style="float: right; min-height: 16px; min-width: 18px;"><div style="position: absolute; left: 0px; top: 50%; margin-left: 16px; margin-top: -8px; float: none; width: 16px; height: 16px;" class="' + this.toThemeProperty('jqx-grid-column-sortdescbutton') + '"></div></div>');
                        }
                    }
                    sortasc.css('display', 'none');
                    sortdesc.css('display', 'none');
                    if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                        sortasc.css('float', 'left');
                        sortdesc.css('float', 'left');
                    }
                    group.append(sortasc);
                    group.append(sortdesc);
                    $.data(document.body, "groupsortelements" + groupcolumn, { sortasc: sortasc, sortdesc: sortdesc });
                }

                group.addClass(this.toThemeProperty('jqx-fill-state-normal'));
                group.addClass(this.toThemeProperty('jqx-grid-group-column'));
                return group;
            },

            _rendergroup: function (groupslength, tablerow, renderrow, columnstart, columnend, renderedrows, tablewidth) {
                var visualrow = tablerow;
                var tablecell = tablerow.cells[renderrow.level];
                if (this.rtl) {
                    tablecell = tablerow.cells[tablerow.cells.length - 1 - renderrow.level];
                }

                var expanded = this._findgroupstate(renderrow.uniqueid);
                if (renderrow.bounddata.subGroups.length > 0 || renderrow.bounddata.subItems.length > 0) {
                    var rtl = this.rtl ? "-rtl" : "";
                    var iconClassName = this.toThemeProperty('jqx-icon-arrow-right');
                    if (rtl) iconClassName = this.toThemeProperty('jqx-icon-arrow-left');

                    if (expanded) {
                        tablecell.className += " " + this.toThemeProperty('jqx-grid-group-expand' + rtl) + " " + this.toThemeProperty('jqx-icon-arrow-down');
                    }
                    else {
                        tablecell.className += " " + this.toThemeProperty('jqx-grid-group-collapse' + rtl) + " " + iconClassName;
                    }
                }

                var text = this._getColumnText(this.groups[renderrow.level]).label;
                var indentwidth = this.groupindentwidth;
                var indent = this.rowdetails && this.showrowdetailscolumn ? (1 + groupslength) * indentwidth : (groupslength) * indentwidth;
                var width = tablewidth - indent;

                var start = renderrow.level + 1;
                if (this.rtl) {
                    start = 0;
                }

                var cellToRender = visualrow.cells[start];
                var m = 2;
                while (cellToRender != undefined && cellToRender.style.display == 'none' && m < visualrow.cells.length) {
                    cellToRender = visualrow.cells[start + m - 1];
                    m++;
                }

                var $cellToRender = $(cellToRender);
                if (!cellToRender) {
                    return;
                }
                cellToRender.style.width = parseInt(width) + 'px';
                if (cellToRender.className.indexOf('jqx-grid-cell-filter') != -1) {
                    $cellToRender.removeClass(this.toThemeProperty('jqx-grid-cell-filter'));
                }
                if (cellToRender.className.indexOf('jqx-grid-cell-sort') != -1) {
                    $cellToRender.removeClass(this.toThemeProperty('jqx-grid-cell-sort'));
                }
                if (cellToRender.className.indexOf('jqx-grid-cell-pinned') != -1) {
                    $cellToRender.removeClass(this.toThemeProperty('jqx-grid-cell-pinned'));
                }

                if (this.groupsrenderer != null) {
                    var groupdata = { group: renderrow.group, level: renderrow.level, parent: renderrow.bounddata.parentItem, subGroups: renderrow.bounddata.subGroups, subItems: renderrow.bounddata.subItems, groupcolumn: this._getColumnText(this.groups[renderrow.level]).column };
                    var html = this.groupsrenderer(text + ': ' + renderrow.group, renderrow.group, expanded, groupdata);
                    if (html) {
                        cellToRender.innerHTML = html;
                        tablerow.classList.add('jqx-grid-groups-custom-row');
                        if (this.theme) {
                            tablerow.classList.add('jqx-grid-groups-custom-row-' + this.theme);
                        }
                    }
                    else {
                        var count = renderrow.bounddata.subItems.length > 0 ? renderrow.bounddata.subItems.length : renderrow.bounddata.subGroups.length;
                        if (this.showgroupaggregates) {
                            var data = renderrow.bounddata.subItems.length > 0 ? renderrow.bounddata.subItems : renderrow.bounddata.subGroups;
                            count = 0;
                            for (var j = 0; j < data.length; j++) {
                                if (data[j].totalsrow)
                                    continue;
                                count++;
                            }
                        }


                        cellToRender.innerHTML = '<div class="' + this.toThemeProperty('jqx-grid-groups-row') + '" style="position: absolute;"><span>' + text + ': </span>' + '<span class="' + this.toThemeProperty('jqx-grid-groups-row-details') + '">' + renderrow.group + ' (' + count + ')' + '</span></div>';
                    }
                }
                else {
                    var column = this._getcolumnbydatafield(this.groups[renderrow.level]);
                    var value = renderrow.group;
                    if (column != null) {
                        if (column.cellsformat) {
                            if ($.jqx.dataFormat) {
                                if ($.jqx.dataFormat.isDate(value)) {
                                    value = $.jqx.dataFormat.formatdate(value, column.cellsformat, this.gridlocalization);
                                }
                                else if ($.jqx.dataFormat.isNumber(value)) {
                                    value = $.jqx.dataFormat.formatnumber(value, column.cellsformat, this.gridlocalization);
                                }
                            }
                        }
                        var count = renderrow.bounddata.subItems.length > 0 ? renderrow.bounddata.subItems.length : renderrow.bounddata.subGroups.length;
                        if (this.showgroupaggregates) {
                            var data = renderrow.bounddata.subItems.length > 0 ? renderrow.bounddata.subItems : renderrow.bounddata.subGroups;
                            count = 0;
                            for (var j = 0; j < data.length; j++) {
                                if (data[j].totalsrow)
                                    continue;
                                count++;
                            }
                        }
                        cellToRender.innerHTML = '<div class="' + this.toThemeProperty('jqx-grid-groups-row') + '" style="position: absolute;"><span>' + text + ': </span>' + '<span class="' + this.toThemeProperty('jqx-grid-groups-row-details') + '">' + value + ' (' + count + ')' + '</span></div>';
                    }
                    else throw new Error("jqxGrid: Unable to find '" + this.groups[renderrow.level] + "' group in the Grid's columns collection.");
                }
                if (this.rtl) {
                    if (!column) {
                        column = this._getcolumnbydatafield(this.groups[renderrow.level])
                    }
                    var scrollValue = this.hScrollBar.css('visibility') == 'hidden' ? 0 : this.hScrollInstance.max - this.hScrollInstance.value;
                    var scrollIndent = this.vScrollBar.css('visibility') == 'hidden' ? 0 : this.scrollbarsize + 6;
                    var indent = this.rowdetails && this.showrowdetailscolumn ? (2 + renderrow.level) * indentwidth : (1 + renderrow.level) * indentwidth;
                    cellToRender.style.width = tablewidth + parseInt(scrollValue) - indent - scrollIndent + 'px';
                    $cellToRender.addClass(this.toThemeProperty('jqx-rtl'));
                    //var zIndex = $cellToRender.css('z-index');
                    var zIndex = $(tablerow.cells[tablerow.cells.length - 1]).css('z-index');
                    $cellToRender.css('z-index', zIndex);
                    var content = $cellToRender.find('div');
                    var width = content.width();
                    content.css('left', '100%');
                    var pinnedColumn = this.columns.records[tablerow.cells.length - 2 - renderrow.level] != null ? this.columns.records[tablerow.cells.length - 2 - renderrow.level].pinned : false;
                    if (this.table.width() < tablewidth) {
                        tablewidth = this.table.width();
                        if (this.vScrollBar.css('visibility') != 'hidden') {
                            tablewidth += this.vScrollBar.outerWidth();
                        }
                    }
                    if (column.pinned || pinnedColumn) {
                        if (this.rowdetails && this.showrowdetailscolumn) {
                            tablewidth += 30;
                        }
                        content.css('margin-left', -width);
                        cellToRender.style.width = tablewidth + scrollValue - indent - scrollIndent + 'px';
                    }
                    else {
                        var scrollValue = this.hScrollBar.css('visibility') == 'hidden' ? 0 : this.hScrollInstance.max;
                        cellToRender.style.width = tablewidth + scrollValue - indent - scrollIndent + 'px';
                        var width = content.width();
                        content.css('margin-left', -width);
                    }
                }
            }
        });
    })(jqxBaseFramework);
})();



/***/ }),

/***/ 4007:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {
        $.jqx.jqxWidget("jqxGrid", "", {});

        $.extend($.jqx._jqxGrid.prototype, {
            defineInstance: function () {
                var settings = {
                    adaptive: false,
                    compact: false,
                    adaptivewidth: 600,
                    // enables or disables the grid.
                    disabled: false,
                    // sets the width.
                    width: 600,
                    // sets the height.
                    height: 400,
                    // sets the pager's height.
                    pagerheight: 40,
                    // sets the group header's height.
                    groupsheaderheight: 34,
                    // sets the default page size.
                    pagesize: 10,
                    // sets the available page sizes.
                    pagesizeoptions: ['5', '10', '20'],
                    // sets the rows height.
                    rowsheight: 32,
                    // sets the columns height.
                    columnsheight: 36,
                    // sets the columns height.
                    filterrowheight: 36,
                    // sets the group indent size. This size is used when the grid is grouped.
                    groupindentwidth: 30,
                    // enables or disables row details.
                    rowdetails: false,
                    // indents the row's details with the sum of the grouping columns and row details column indents.
                    enablerowdetailsindent: true,
                    // enables or disables the built-in mouse-wheel behavior.
                    enablemousewheel: true,
                    // renders the row details.
                    initrowdetails: null,
                    // updates the row details layout.
                    layoutrowdetails: null,
                    disablerowdetails: null,
                    // enables or disables editing.
                    editable: false,
                    // sets the edit mode. - click, dblclick, selectedcell, selectedrow or programmatic.
                    editmode: 'selectedcell',
                    // batcheditable
                    batcheditable: false,
                    // enables or disables paging.
                    pageable: false,
                    pagermode: "default",
                    pagerbuttonscount: 5,
                    // enables or disables grouping.
                    groupable: false,
                    // enables or disables sorting.
                    sortable: false,
                    sortmode: 'one',
                    sortmodekey: '',
                    // enables or disables filtering.
                    filterable: false,
                    filtermode: "default",
                    filterbarmode: "default",
                    // displays the filter icon only when the column is filtered.
                    autoshowfiltericon: true,
                    // displays a background for the filtered column.
                    showfiltercolumnbackground: true,
                    // displays a background for the pinned column.
                    showpinnedcolumnbackground: true,
                    // displays a background for the sort column.
                    showsortcolumnbackground: true,
                    // enables or disables alternating rows.
                    altrows: false,
                    // sets the alternating rows start.
                    altstart: 1,
                    // sets the alternating rows step.
                    altstep: 1,
                    // shows or hides the details column.
                    showrowdetailscolumn: true,
                    showrowlines: true,
                    showcolumnlines: true,
                    showcolumnheaderlines: true,
                    // shows or hides the grid's toolbar.
                    showtoolbar: false,
                    showfilterbar: false,
                    toolbarheight: 36,
                    showstatusbar: false,
                    statusbarheight: 36,
                    enableellipsis: true,
                    // adds groups.
                    groups: [],
                    // custom groups renderer.
                    groupsrenderer: null,
                    // custom renderer for the grouping columns displayed in the grouping header.
                    groupcolumnrenderer: null,
                    // groups default expand state.
                    groupsexpandedbydefault: false,
                    // sets the pager renderer.
                    pagerrenderer: null,
                    touchmode: 'auto',
                    // sets the grid columns.
                    columns: [],
                    // selected row index.
                    selectedrowindex: -1,
                    selectedrowindexes: new Array(),
                    selectedcells: new Array(),
                    autobind: true,
                    selectedcell: null,
                    tableZIndex: 79,
                    headerZIndex: 29,
                    updatefilterconditions: null,
                    showgroupaggregates: false,
                    showaggregates: false,
                    showfilterrow: false,
                    showeverpresentrow: false,
                    everpresentrowposition: "top",
                    everpresentrowactions: "add reset",
                    everpresentrowactionsmode: "buttons",
                    everpresentrowheight: 30,
                    autorowheight: false,
                    autokoupdates: true,
                    handlekeyboardnavigation: null,
                    showsortmenuitems: true,
                    showfiltermenuitems: true,
                    showgroupmenuitems: true,
                    enablebrowserselection: false,
                    enablekeyboarddelete: true,
                    clipboard: true,
                    clipboardbegin: null,
                    clipboardend: null,
                    copytoclipboardwithheaders: false,
                    copytoclipboardhiddencolumns: false,
                    ready: null,
                    updatefilterpanel: null,
                    autogeneratecolumns: false,
                    rowdetailstemplate: null,
                    scrollfeedback: null,
                    rendertoolbar: null,
                    renderstatusbar: null,
                    rendered: null,
                    multipleselectionbegins: null,
                    columngroups: null,
                    cellhover: null,
                    commandcolumn: false,
                    commandcolumnrenderer: null,
                    // sets the grid source.
                    source:
                    {
                        beforeprocessing: null,
                        beforesend: null,
                        loaderror: null,
                        localdata: null,
                        data: null,
                        datatype: 'array',
                        // {name: name, map: map}
                        datafields: [],
                        url: "",
                        root: '',
                        record: '',
                        id: '',
                        totalrecords: 0,
                        recordstartindex: 0,
                        recordendindex: 0,
                        loadallrecords: true,
                        sortcolumn: null,
                        sortdirection: null,
                        sort: null,
                        filter: null,
                        sortcomparer: null
                    },
                    filter: null,
                    // sets the grid data view.
                    dataview: null,
                    // sets the rendering delay.
                    updatedelay: null,
                    // sets the auto height option. This option is appropriate when the grid's paging is enables or when the grid has quite a few rows.
                    autoheight: false,
                    autowidth: false,
                    // shows or hides the grid's columns header.
                    showheader: true,
                    // shows or hides the grid's grouping header.
                    showgroupsheader: true,
                    // enables or disables the grouping closing buttons.
                    closeablegroups: true,
                    // sets the scrollbars size.
                    scrollbarsize: $.jqx.utilities.scrollBarSize,
                    touchscrollbarsize: $.jqx.utilities.touchScrollBarSize,
                    scrollbarautoshow: $.jqx.utilities.scrollBarAutoShow,
                    // enables or disables the virtual scrolling.
                    virtualmode: false,
                    // sets a custom sorting behavior.
                    sort: null,
                    // displays a dropdown button in each column.
                    columnsmenu: true,
                    // enables the resizing of grid columns.
                    columnsresize: false,
                    columnsautoresize: true,
                    columnsreorder: false,
                    // sets the width of the columns menu in each column.
                    columnsmenuwidth: 16,
                    autoshowcolumnsmenubutton: true,
                    showcolumnsactionbutton: false,
                    popupwidth: 'auto',
                    popupheight: 'auto',
                    columnmenuopening: null,
                    columnmenuclosing: null,
                    // changes the sort state when the user clickes a column header.
                    // 0 - disables toggling.
                    // 1 - enables togging. Click on a column toggles the sort direction.
                    // 2 - enables remove sorting option.
                    sorttogglestates: 2,
                    // callback function invoked when the rows are rendered.
                    rendergridrows: null,
                    // enables or disables the grid animations - slide and fade effects.
                    enableanimations: true,
                    // enables columns virtualization
                    enablecolumnsvirtualization: true,
                    // enables or disables the grid tooltips.
                    enabletooltips: false,
                    // enables or disables the selection.
                    // possible values: 'none', 'singlerow', 'multiplerows, 'multiplerowsextended, 'singlecell, 'multiplecells, 'multiplecellsextended', 'multiplecellsadvanced'
                    selectionmode: 'singlerow',
                    autofill: false,
                    enableoptimization: false,
                    // enables or disables the rows hover state.
                    enablehover: true,
                    // this message is displayed when the user tries to call a method before the binding complete.
                    loadingerrormessage: "The data is still loading. When the data binding is completed, the Grid raises the 'bindingcomplete' event. Call this function in the 'bindingcomplete' event handler.",
                    // vertical scroll step.
                    verticalscrollbarstep: 30,
                    // vertical large step.
                    verticalscrollbarlargestep: 400,
                    // horizontal step.
                    horizontalscrollbarstep: 10,
                    // horizontal large step.
                    horizontalscrollbarlargestep: 50,
                    keyboardnavigation: true,
                    keyboardmenunavigation: true,
                    touchModeStyle: 'auto',
                    autoshowloadelement: true,
                    showdefaultloadelement: true,
                    showemptyrow: true,
                    autosavestate: false,
                    autoloadstate: false,
                    cardview: false,
                    cardviewcolumns: ['20%', '20%', '20%', '20%', '20%'],
                    cardheight: 250,
                    cardsize: 3,
                    enableSanitize: false,
                    enableSanitizeAll: false,
                    // private members
                    _updating: false,
                    _pagescache: new Array(),
                    _pageviews: new Array(),
                    _cellscache: new Array(),
                    _rowdetailscache: new Array(),
                    _rowdetailselementscache: new Array(),
                    _requiresupdate: false,
                    _hasOpenedMenu: false,
                    scrollmode: 'physical',
                    deferreddatafields: null,
                    localization: null,
                    rtl: false,
                    menuitemsarray: [],
                    charting: {
                        appendTo: null,
                        colorScheme: 'scheme02',
                        dialog: {
                            header: 'Data Visualization',
                            height: 400,
                            width: 400,
                            position: 'center',
                            enabled: true
                        },
                        ready: null,
                        formatSettings: {}
                    },
                    contextmenuitems: [
                        "Item 1",
                        "Item 2",
                        "Item 3"
                    ],
                    contextmenuenabled: false,
                    contextmenuwidth: 200,
                    contextmenuheight: 'auto',
                    contextmenuitemclick: null,
                    events:
                        [
                /*0*/'initialized',
                /*1*/'rowClick',
                /*2*/'rowSelect',
                /*3*/'rowUnselect',
                /*4*/'groupExpand',
                /*5*/'groupCollapse',
                /*6*/'sort',
                /*7*/'columnClick',
                /*8*/'cellClick',
                /*9*/'pageChanged',
                /*10*/'pageSizeChanged',
                /*11*/'bindingComplete',
                /*12*/'groupsChanged',
                /*13*/'filter',
                /*14*/'columnResized',
                /*15*/'cellSelect',
                /*16*/'cellUnselect',
                /*17*/'cellBeginEdit',
                /*18*/'cellEndEdit',
                /*19*/'cellValueChanged',
                /*20*/'rowExpand',
                /*21*/'rowCollapse',
                /*22*/'rowDoubleClick',
                /*23*/'cellDoubleClick',
                /*24*/'columnReordered',
                /*25*/'pageChanging',
                /*26*/'columnChooserOkClick',
                /*27*/'columnChooserCancelClick'
                        ]
                }
                if (this === $.jqx._jqxGrid.prototype) {
                    return settings;
                }
                $.extend(true, this, settings);
                return settings;
            },

            _applyThemeSettings: function () {
                var that = this;

                if (!that.isMaterialized()) {
                    return;
                }


                var gridStyle = window.getComputedStyle(that.element);
                var rowHeight = gridStyle.getPropertyValue('--jqx-grid-row-height');
                var columnHeight = gridStyle.getPropertyValue('--jqx-grid-column-height');
                var columnLines = gridStyle.getPropertyValue('--jqx-grid-show-column-lines');
                var filterMenuItemsHeight = gridStyle.getPropertyValue('--jqx-grid-filter-menu-items-height');
                var scrollbarSize = gridStyle.getPropertyValue('--jqx-scrollbar-size');

                if (rowHeight && this.rowsheight === 32 && !this.cardview) {
                    that.rowsheight = parseInt(rowHeight);
                }
                if (columnHeight && this.columnsheight === 36) {
                    that.columnsheight = parseInt(columnHeight);
                }
                if (columnLines) {
                    that.showcolumnlines = that.showcolumnheaderlines = parseInt(columnLines);
                }
                if (filterMenuItemsHeight) {
                    that.filterMenuItemsHeight = parseInt(filterMenuItemsHeight);
                }
                else {
                    that.filterMenuItemsHeight = 23;
                }

                if (scrollbarSize) {
                    that.scrollbarsize = scrollbarSize;
                    $.jqx.utilities.scrollBarSize = scrollbarSize;
                }
            },

            createInstance: function (args) {
                this.that = this;
                var that = this;
                that.pagesize = parseInt(that.pagesize);
                that.toolbarheight = parseInt(that.toolbarheight);
                that.columnsheight = parseInt(that.columnsheight);
                that.filterrowheight = parseInt(that.filterrowheight);
                that.statusbarheight = parseInt(that.statusbarheight);
                that.groupsheaderheight = parseInt(that.groupsheaderheight);
                that._undoRedo = [];
                that._undoRedoIndex = -1;

                if (that.cardview) {
                    that.__rowsheight = that.rowsheight;
                    that.rowsheight = that.cardheight;
                }

                that._applyThemeSettings();

                that.detailsVisibility = new Array();
                that.savedArgs = args && args.length > 0 ? args[0] : null;
                var gridStructure = "<div class='jqx-clear jqx-border-reset jqx-overflow-hidden jqx-max-size jqx-position-relative'>" +
                    "<div tabindex='1' class='jqx-clear jqx-max-size jqx-position-relative jqx-overflow-hidden jqx-background-reset' id='wrapper" + that.element.id + "'>" +
                    "<div class='jqx-clear jqx-position-absolute' id='toolbar' style='visibility: hidden;'></div>" +
                    "<div class='jqx-clear jqx-position-absolute' id='groupsheader' style='visibility: hidden;'></div>" +
                    "<div class='jqx-clear jqx-position-absolute' id='filter' style='visibility: hidden;'></div>" +
                    "<div class='jqx-clear jqx-overflow-hidden jqx-position-absolute jqx-border-reset jqx-background-reset' id='content" + that.element.id + "'></div>" +
                    "<div class='jqx-clear jqx-position-absolute' id='verticalScrollBar" + that.element.id + "'></div>" +
                    "<div class='jqx-clear jqx-position-absolute' id='horizontalScrollBar" + that.element.id + "'></div>" +
                    "<div class='jqx-clear jqx-position-absolute jqx-border-reset' id='bottomRight'></div>" +
                    "<div class='jqx-clear jqx-position-absolute' id='addrow'></div>" +
                    "<div class='jqx-clear jqx-position-absolute' id='statusbar'></div>" +
                    "<div class='jqx-clear jqx-position-absolute' id='pager' style='z-index: 20;'></div>" +
                    "</div>" +
                    "</div>";

                that.element.innerHTML = '';


                if (that.source) {
                    if (!that.source.dataBind) {
                        if (!$.jqx.dataAdapter) {
                            throw new Error('jqxGrid: Missing reference to jqxdata.js');
                        }
                        if (Array.isArray(that.source)) {
                            that.source = new $.jqx.dataAdapter({ localdata: that.source });
                        }
                        else {
                            that.source = new $.jqx.dataAdapter(that.source);
                        }
                    }
                    var datafields = that.source._source.datafields;
                    if (datafields && datafields.length > 0) {
                        //     that._camelCase = that.source._source.dataFields !== undefined;
                        that.editmode = that.editmode.toLowerCase();
                        that.selectionmode = that.selectionmode.toLowerCase();
                    }
                }

                that.host.attr('role', 'grid');
                that.host.attr('align', 'left');
                //    that.host.append(gridStructure);
                that.element.innerHTML = gridStructure;
                that.host.addClass(that.toTP('jqx-grid'));
                that.host.addClass(that.toTP('jqx-reset'));
                that.host.addClass(that.toTP('jqx-rc-all'));
                that.host.addClass(that.toTP('jqx-widget'));
                that.host.addClass(that.toTP('jqx-widget-content'));

                that.wrapper = that.host.find("#wrapper" + that.element.id);
                that.content = that.host.find("#content" + that.element.id);
                that.content.addClass(that.toTP('jqx-reset'));

                this.filterbar = this.host.find("#filter");
                this.filterbar[0].id = "filter" + this.element.id;
                this.filterbar.addClass(this.toTP('jqx-widget-header'));
                this.filterbar.addClass(this.toTP('jqx-grid-toolbar'));

                var verticalScrollBar = that.host.find("#verticalScrollBar" + that.element.id);
                var horizontalScrollBar = that.host.find("#horizontalScrollBar" + that.element.id);
                that.bottomRight = that.host.find("#bottomRight").addClass(that.toTP('jqx-grid-bottomright jqx-scrollbar-state-normal'));

                if (!verticalScrollBar.jqxScrollBar) {
                    throw new Error('jqxGrid: Missing reference to jqxscrollbar.js');
                    return;
                }

                that.editors = new Array();

                that.vScrollBar = verticalScrollBar.jqxScrollBar({ 'vertical': true, rtl: that.rtl, touchMode: that.touchmode, step: that.verticalscrollbarstep, largestep: that.verticalscrollbarlargestep, theme: that.theme, _triggervaluechanged: false });
                that.hScrollBar = horizontalScrollBar.jqxScrollBar({ 'vertical': false, rtl: that.rtl, touchMode: that.touchmode, step: that.horizontalscrollbarstep, largestep: that.horizontalscrollbarlargestep, theme: that.theme, _triggervaluechanged: false });

                that.addnewrow = that.host.find("#addrow");
                that.addnewrow[0].id = "addrow" + that.element.id;
                that.addnewrow.addClass(that.toTP('jqx-widget-header'));
                that.pager = that.host.find("#pager");
                that.pager[0].id = "pager" + that.element.id;
                that.toolbar = that.host.find("#toolbar");
                that.toolbar[0].id = "toolbar" + that.element.id;
                that.toolbar.addClass(that.toTP('jqx-grid-toolbar'));
                that.toolbar.addClass(that.toTP('jqx-widget-header'));

                that.statusbar = that.host.find("#statusbar");
                that.statusbar[0].id = "statusbar" + that.element.id;
                that.statusbar.addClass(that.toTP('jqx-grid-statusbar'));
                that.statusbar.addClass(that.toTP('jqx-widget-header'));

                that.pager.addClass(that.toTP('jqx-grid-pager'));
                that.pager.addClass(that.toTP('jqx-widget-header'));

                that.groupsheader = that.host.find("#groupsheader");
                that.groupsheader.addClass(that.toTP('jqx-grid-groups-header'));
                that.groupsheader.addClass(that.toTP('jqx-widget-header'));
                that.groupsheader[0].id = "groupsheader" + that.element.id;

                that.vScrollBar.css('visibility', 'hidden');
                that.hScrollBar.css('visibility', 'hidden');

                that.vScrollInstance = $.data(that.vScrollBar[0], 'jqxScrollBar').instance;
                that.hScrollInstance = $.data(that.hScrollBar[0], 'jqxScrollBar').instance;
                that.gridtable = null;

                that.isNestedGrid = that.host.parent() ? that.host.parent().css('z-index') == 299 : false;
                that.touchdevice = that.isTouchDevice();

                if (that.localizestrings) {
                    that.localizestrings();
                    if (that.localization != null) {
                        that.localizestrings(that.localization, false);
                    }
                }

                if (that.rowdetailstemplate && typeof that.rowdetailstemplate !== 'function') {
                    if (undefined == that.rowdetailstemplate.rowdetails) {
                        that.rowdetailstemplate.rowdetails = '<div></div>';
                    }

                    if (undefined == that.rowdetailstemplate.rowdetailsheight) {
                        that.rowdetailstemplate.rowdetailsheight = 200;
                    }
                    if (undefined == that.rowdetailstemplate.rowdetailshidden) {
                        that.rowdetailstemplate.rowdetailshidden = true;
                    }
                }

                if (that.showfilterrow && !that.filterable) {
                    throw new Error('jqxGrid: "showfilterrow" requires setting the "filterable" property to true!');
                    that.host.remove();
                    return;
                }
                if (that.autorowheight && !that.autoheight && !that.pageable) {
                    throw new Error('jqxGrid: "autorowheight" requires setting the "autoheight" or "pageable" property to true!');
                    that.host.remove();
                    return;
                }
                if (that.virtualmode && that.rendergridrows == null) {
                    throw new Error('jqxGrid: "virtualmode" requires setting the "rendergridrows"!');
                    that.host.remove();
                    return;
                }

                if (that.virtualmode && !that.pageable && that.groupable) {
                    throw new Error('jqxGrid: "grouping" in "virtualmode" without paging is not supported!');
                    that.host.remove();
                    return;
                }

                // check for missing modules.
                if (that._testmodules()) {
                    return;
                }

                that._builddataloadelement();
                that._cachedcolumns = that.columns;
                if (that.columns && that.columns.length > that.headerZIndex) {
                    that.headerZIndex = that.columns.length + 100;
                }

                if (that.theme && that.theme.indexOf("material") >= 0) {
                    var cell = $('<span>Test</span>');
                    var column = $('<span>Test</span>');

                    cell.addClass(that.toTP('jqx-grid-row-cell'));
                    column.addClass(that.toTP('jqx-grid-column-header-cell'));

                    that.host.append(cell);
                    that.host.append(column);

                    var cellHeight = cell.outerHeight();
                    var columnHeight = column.outerHeight();

                    if (cellHeight > this.rowsheight) {
                        that.rowsheight = cellHeight;
                        this._cellheight = cellHeight;
                    }

                    if (columnHeight > this.columnsheight) {
                        that.columnsheight = columnHeight;;
                        this._columnHeight = columnHeight;
                    }

                    cell.remove();
                    column.remove();
                }

                if (that.compact) {
                    that.element.setAttribute('compact', '');
                    this.rowsheight = 25;
                    this.columnsheight = 25;
                    this.pagerheight = 30;
                    this.groupsheaderheight = 25;
                }

                if (that.rowsheight != 31) {
                    that._measureElement('cell');
                }
                if (that.columnsheight != 32 || that.columngroups) {
                    that._measureElement('column');
                }



                if (that.source) {
                    var datafields = that.source.datafields;
                    if (datafields == null && that.source._source) {
                        datafields = that.source._source.datafields;
                    }

                    if (datafields) {
                        for (var m = 0; m < that.columns.length; m++) {
                            var column = that.columns[m];
                            if (column && column.cellsformat && column.cellsformat.length > 2) {
                                for (var t = 0; t < datafields.length; t++) {
                                    if (datafields[t].name == column.datafield && !datafields[t].format) {
                                        datafields[t].format = column.cellsformat;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                that.databind(that.source);

                if (that.showtoolbar) {
                    that.toolbar.css('visibility', 'inherit');
                }

                if (that.showfilterbar) {
                    that.filterbar.css('visibility', 'inherit');
                }

                if (that.showstatusbar) {
                    that.statusbar.css('visibility', 'inherit');
                }

                that._arrange();
                if (that.pageable && that._initpager) {
                    that._initpager();
                }
                that.tableheight = null;
                var me = that.that;
                var clearoffset = function () {
                    if (me.content) {
                        me.content[0].scrollTop = 0;
                        me.content[0].scrollLeft = 0;
                    }
                    if (me.gridcontent) {
                        me.gridcontent[0].scrollLeft = 0;
                        me.gridcontent[0].scrollTop = 0;
                    }
                }

                that.addHandler(that.content, 'mousedown',
                    function () {
                        clearoffset();
                    });

                that.addHandler(that.content, 'scroll',
                    function (event) {
                        clearoffset();
                        return false;
                    });

                if (!that.showfilterrow) {
                    if (!that.showstatusbar && !that.showtoolbar) {
                        that.host.addClass('jqx-disableselect');
                    }
                    that.content.addClass('jqx-disableselect');
                }

                if (that.enablebrowserselection) {
                    that.content.removeClass('jqx-disableselect');
                    that.host.removeClass('jqx-disableselect');
                }


                if (that.batcheditable) {
                    that.toolbar[0].innerHTML = '<div style="padding: 3px;"><button style="margin-left: 5px;" class="saveButton">' + this.gridlocalization.okstring + '</button><button style="margin-left: 5px;" class="cancelButton">' + this.gridlocalization.cancelstring + '</button></div>';
                    var buttons = that.toolbar[0].querySelectorAll('button');

                    $(buttons[0]).jqxButton({ width: 80, template: 'primary', theme: that.theme });
                    $(buttons[1]).jqxButton({ width: 80, theme: that.theme });

                    var handleBatchEdit = function (applyValue) {
                        var rows = that.getrows();
                        for (var i = 0; i < rows.length; i++) {
                            var row = rows[i];

                            for (var j = 0; j < that.columns.records.length; j++) {
                                var column = that.columns.records[j];

                                var tempValue = row['_temp' + column.datafield];
                                if (tempValue !== undefined) {
                                    if (applyValue) {
                                        row[column.datafield] = tempValue;
                                    }
                                    delete row['_temp' + column.datafield];
                                }
                            }
                        }

                        that.removesort();
                        that._rendervisualrows();
                    }

                    $(buttons[0]).on('click', function () {
                        handleBatchEdit(true);
                    });

                    $(buttons[1]).on('click', function () {
                        handleBatchEdit(false);
                    });
                }

                that._resizeWindow();

                if (that.disabled) {
                    that.host.addClass(that.toThemeProperty('jqx-fill-state-disabled'));
                }
                that.hasTransform = $.jqx.utilities.hasTransform(that.host);
                if (that.scrollmode == 'logical') {
                    that.vScrollInstance.thumbStep = that.rowsheight;
                    that.vScrollInstance.step = that.rowsheight;
                }
                if (!$.jqx.isHidden(that.host)) {
                    if (that.filterable || that.groupable || that.sortable) {
                        that._initmenu();
                    }
                }
            },

            _resizeWindow: function () {
                var me = this.that;
                if ((this.width != null && this.width.toString().indexOf('%') != -1) || (this.height != null && this.height.toString().indexOf('%') != -1)) {
                    this._updatesizeonwindowresize = true;
                    $.jqx.utilities.resize(this.host, function (type) {
                        var width = $(window).width();
                        var height = $(window).height();
                        var hostwidth = me.host.width();
                        var hostheight = me.host.height();

                        if (me.pageable) {
                            var pagerInput = me.host.find('.jqx-grid-pager-input');

                            if (width < 350) {
                                pagerInput.hide();
                            }
                            else {
                                pagerInput.show();
                            }
                        }

                        if (me.autoheight) me._lastHostWidth = height;
                        if (me._lastHostWidth != hostwidth || me._lastHostHeight != hostheight) {
                            if (me.touchdevice && me.editcell && type !== "orientationchange")
                                return;

                            me._updatesize(me._lastHostWidth != hostwidth, me._lastHostHeight != hostheight);
                        }

                        me._lastWidth = width;
                        me._lastHeight = height;
                        me._lastHostWidth = hostwidth;
                        me._lastHostHeight = hostheight;
                    });
                    var hostwidth = me.host.width();
                    var hostheight = me.host.height();
                    me._lastHostWidth = hostwidth;
                    me._lastHostHeight = hostheight;
                }
            },

            _builddataloadelement: function () {
                if (this.dataloadelement) {
                    this.dataloadelement.remove();
                }

                this.dataloadelement = $('<div style="overflow: hidden; position: absolute;"></div>');
                if (this.showdefaultloadelement) {
                    var table = $('<div style="z-index: 99; margin-left: -66px; left: 50%; top: 50%; margin-top: -24px; position: relative; width: 100px; height: 33px; padding: 5px; font-family: verdana; font-size: 12px; color: #767676; border-color: #898989; border-width: 1px; border-style: solid; background: #f6f6f6; border-collapse: collapse;"><div style="float: left;"><div style="float: left; overflow: hidden; width: 32px; height: 32px;" class="jqx-grid-load"></div><span style="margin-top: 10px; float: left; display: block; margin-left: 5px;" >' + this.gridlocalization.loadtext + '</span></div></div>');
                    table.addClass(this.toTP('jqx-rc-all'));
                    this.dataloadelement.addClass(this.toTP('jqx-rc-all'));
                    table.addClass(this.toTP('jqx-fill-state-normal'));
                    this.dataloadelement.append(table);
                }
                else {
                    this.dataloadelement.addClass(this.toTP('jqx-grid-load'));
                }
                this.dataloadelement.width(this.host.width());
                this.dataloadelement.height(this.host.height());

                this.wrapper.prepend(this.dataloadelement);
            },

            _measureElement: function (type) {
                var span = $("<span style='visibility: hidden; white-space: nowrap;'>measure Text</span>");
                span.addClass(this.toTP('jqx-widget'));
                $(document.body).append(span);
                if (type == 'cell') {
                    this._cellheight = span.height();
                }
                else this._columnheight = span.height();
                span.remove();
            },

            _measureMenuElement: function () {
                var span = $("<span style='visibility: hidden; white-space: nowrap;'>measure Text</span>");
                span.addClass(this.toTP('jqx-widget'));
                span.addClass(this.toTP('jqx-menu'));
                span.addClass(this.toTP('jqx-menu-item-top'));
                span.addClass(this.toTP('jqx-fill-state-normal'));
                if (this.isTouchDevice()) {
                    span.addClass(this.toTP('jqx-grid-menu-item-touch'));
                }
                $(document.body).append(span);
                var height = span.outerHeight();

                if (this.theme === 'light' || this.theme === 'dark') {
                    if (!this._isIE10()) {
                        height += 10;
                        if (height > 36) {
                            height = 36;
                        }
                    }
                }
                span.remove();

                return height;
            },

            _measureElementWidth: function (text) {
                var span = $("<span style='visibility: hidden; white-space: nowrap;'>" + text + "</span>");
                span.addClass(this.toTP('jqx-widget'));
                span.addClass(this.toTP('jqx-grid'));
                span.addClass(this.toTP('jqx-grid-column-header'));
                span.addClass(this.toTP('jqx-widget-header'));
                $(document.body).append(span);
                var w = span.outerWidth() + 20;
                span.remove();
                return w;
            },

            _getBodyOffset: function () {
                var top = 0;
                var left = 0;
                if ($('body').css('border-top-width') != '0px') {
                    top = parseInt($('body').css('border-top-width'));
                    if (isNaN(top)) top = 0;
                }
                if ($('body').css('border-left-width') != '0px') {
                    left = parseInt($('body').css('border-left-width'));
                    if (isNaN(left)) left = 0;
                }
                return { left: left, top: top };
            },

            _testmodules: function () {
                var missingModules = "";
                var me = this.that;
                var addComma = function () {
                    if (missingModules.length != "") missingModules += ",";
                }

                if (this.columnsmenu && !this.host.jqxMenu && (this.sortable || this.groupable || this.filterable)) {
                    addComma();
                    missingModules += " jqxmenu.js";
                }
                if (!this.host.jqxScrollBar) {
                    addComma();
                    missingModules += " jqxscrollbar.js";
                }
                if (!this.host.jqxButton) {
                    addComma();
                    missingModules += " jqxbuttons.js";
                }
                if (!$.jqx.dataAdapter) {
                    addComma();
                    missingModules += " jqxdata.js";
                }
                if (this.pageable && !this.gotopage) {
                    addComma();
                    missingModules += "jqxgrid.pager.js";
                }
                if (this.filterable && !this.applyfilters) {
                    addComma();
                    missingModules += " jqxgrid.filter.js";
                }
                if (this.groupable && !this._initgroupsheader) {
                    addComma();
                    missingModules += " jqxgrid.grouping.js";
                }
                if (this.columnsresize && !this.autoresizecolumns) {
                    addComma();
                    missingModules += " jqxgrid.columnsresize.js";
                }
                if (this.columnsreorder && !this.setcolumnindex) {
                    addComma();
                    missingModules += " jqxgrid.columnsreorder.js";
                }
                if (this.sortable && !this.sortby) {
                    addComma();
                    missingModules += " jqxgrid.sort.js";
                }
                if (this.editable && !this.begincelledit) {
                    addComma();
                    missingModules += " jqxgrid.edit.js";
                }
                if (this.showaggregates && !this.getcolumnaggregateddata) {
                    addComma();
                    missingModules += " jqxgrid.aggregates.js";
                }
                if (this.keyboardnavigation && !this.selectrow) {
                    addComma();
                    missingModules += " jqxgrid.selection.js";
                }
                if (missingModules != "" || this.editable || this.filterable || this.pageable) {
                    var missingTypes = [];

                    var addMissing = function (type) {
                        switch (type) {
                            case "checkbox":
                                if (!me.host.jqxCheckBox && !missingTypes['checkbox']) {
                                    missingTypes['checkbox'] = true;
                                    addComma();
                                    missingModules += ' jqxcheckbox.js';
                                }
                                break;
                            case "numberinput":
                                if (!me.host.jqxNumberInput && !missingTypes['numberinput']) {
                                    missingTypes['numberinput'] = true;
                                    addComma();
                                    missingModules += ' jqxnumberinput.js';
                                }
                                break;
                            case "datetimeinput":
                                if (!me.host.jqxDateTimeInput && !missingTypes['datetimeinput']) {
                                    addComma();
                                    missingTypes['datetimeinput'] = true;
                                    missingModules += ' jqxdatetimeinput.js(requires: jqxcalendar.js)';
                                }
                                else if (!me.host.jqxCalendar && !missingTypes['calendar']) {
                                    addComma();
                                    missingModules += ' jqxcalendar.js';
                                }
                                break;
                            case "combobox":
                                if (!me.host.jqxComboBox && !missingTypes['combobox']) {
                                    addComma();
                                    missingTypes['combobox'] = true;
                                    missingModules += ' jqxcombobox.js(requires: jqxlistbox.js)';
                                }
                                else if (!me.host.jqxListBox && !missingTypes['listbox']) {
                                    addComma();
                                    missingTypes['listbox'] = true;
                                    missingModules += ' jqxlistbox.js';
                                }
                                break;
                            case "dropdownlist":
                                if (!me.host.jqxDropDownList && !missingTypes['dropdownlist']) {
                                    addComma();
                                    missingTypes['dropdownlist'] = true;
                                    missingModules += ' jqxdropdownlist.js(requires: jqxlistbox.js)';
                                }
                                else if (!me.host.jqxListBox && !missingTypes['listbox']) {
                                    addComma();
                                    missingTypes['listbox'] = true;
                                    missingModules += ' jqxlistbox.js';
                                }
                                break;
                        }
                    }

                    if (this.filterable || this.pageable) {
                        addMissing('dropdownlist');
                    }

                    for (var i = 0; i < this.columns.length; i++) {
                        if (this.columns[i] == undefined)
                            continue;

                        var type = this.columns[i].columntype;
                        addMissing(type);
                        if (this.filterable && this.showfilterrow) {
                            var type = this.columns[i].filtertype;
                            if (type == 'checkedlist' || type == 'bool') {
                                addMissing('checkbox');
                            }
                            if (type == 'date') {
                                addMissing('datetimeinput');
                            }
                        }
                    }
                    if (missingModules != "") {
                        throw new Error("jqxGrid: Missing references to the following module(s): " + missingModules);
                        this.host.remove();
                        return true;
                    }
                }
                return false;
            },

            focus: function () {
                try {
                    this.wrapper[0].focus({ preventScroll: true });
                    var me = this.that;
                    setTimeout(function () {
                        if (me && me.wrapper) {
                            me.wrapper[0].focus({ preventScroll: true });
                        }
                    }, 25);
                    this.focused = true;
                }
                catch (error) {
                }
            },

            hiddenParent: function () {
                return $.jqx.isHidden(this.host);
            },

            resize: function (width, height) {
                this.width = width;
                this.height = height;
                this._updatesize(true, true);
            },

            _updatesize: function (updateWidth, updateHeight) {
                if (this._loading) {
                    return;
                }

                var me = this.that;

                me._newmax = null;

                var hostWidth = me.host.width();
                var hostHeight = me.host.height();

                if (!me._oldWidth) {
                    me._oldWidth = hostWidth;
                }

                if (!me._oldHeight) {
                    me._oldHeight = hostHeight;
                }

                if (me._resizeTimer) {
                    clearTimeout(me._resizeTimer);
                }

                var delay = 5;

                //        me._resizeTimer = setTimeout(function () {
                me.resizingGrid = true;
                if ($.jqx.isHidden(me.host))
                    return;
                if (me.editcell) {
                    me.endcelledit(me.editcell.row, me.editcell.column, true, true);
                    me._oldselectedcell = null;
                }
                if (hostHeight != me._oldHeight || updateHeight == true) {
                    var hasgroups = me.groupable && me.groups.length > 0;
                    var isVScrollHidden = me.vScrollBar.css('visibility');

                    if (!me.autoheight) {
                        if (me.virtualmode) {
                            me._pageviews = new Array();
                        }

                        if (!hasgroups && !me.rowdetails && !me.pageable) {
                            me._arrange();
                            me.virtualsizeinfo = me._calculatevirtualheight();
                            var hostHeight = Math.round(me.host.height()) + 2 * me.rowsheight;
                            if (parseInt(hostHeight) >= parseInt(me._oldHeight)) {
                                me.prerenderrequired = true;
                            }
                            me._renderrows(me.virtualsizeinfo);
                            if (me.rtl) {
                                me._updatecolumnwidths();
                                if (me.table) {
                                    me.table.width(me.columnsheader.width());
                                }
                                me._updatecellwidths();
                            }
                        }
                        else {
                            me._arrange();
                            me.prerenderrequired = true;
                            var hostHeight = Math.round(me.host.height()) + 2 * me.rowsheight;
                            var realheight = me._gettableheight();
                            var visiblerecords = Math.round(hostHeight / me.rowsheight);
                            var totalrows = Math.max(me.dataview.totalrows, me.dataview.totalrecords);
                            if (me.pageable) {
                                totalrows = me.pagesize;
                                if (me.pagesize > Math.max(me.dataview.totalrows, me.dataview.totalrecords) && me.autoheight) {
                                    totalrows = Math.max(me.dataview.totalrows, me.dataview.totalrecords);
                                }
                                else if (!me.autoheight) {
                                    if (me.dataview.totalrows < me.pagesize) {
                                        totalrows = Math.max(me.dataview.totalrows, me.dataview.totalrecords);
                                    }
                                }
                            }

                            var virtualheight = totalrows * me.rowsheight;
                            var pagesize = me._getpagesize();
                            if (!me.pageable && me.autoheight) {
                                visiblerecords = totalrows;
                            }
                            if (me.virtualsizeinfo) {
                                me.virtualsizeinfo.visiblerecords = visiblerecords;
                            }
                            me.rendergridcontent(true, false);
                            me._renderrows(me.virtualsizeinfo);
                        }

                        if (isVScrollHidden != me.vScrollBar.css('visibility')) {
                            me.vScrollInstance.setPosition(0);
                            me._arrange();
                            me._updatecolumnwidths();
                            if (me.table) {
                                me.table.width(me.columnsheader.width());
                            }
                            me._updatecellwidths();
                        }
                    }
                }

                if (hostWidth != me._oldWidth || updateWidth == true) {
                    var openedEditor = false;
                    if (me.editcell && me.editcell.editor) {
                        switch (me.editcell.columntype) {
                            case "dropdownlist":
                                openedEditor = me.editcell.editor.jqxDropDownList('isOpened') || (me.editcell.editor.jqxDropDownList('isanimating') && !me.editcell.editor.jqxDropDownList('ishiding'));
                                if (openedEditor) {
                                    me.editcell.editor.jqxDropDownList({ openDelay: 0 });
                                    me.editcell.editor.jqxDropDownList('open');
                                    me.editcell.editor.jqxDropDownList({ openDelay: 250 });
                                    return;
                                }
                                break;
                            case "combobox":
                                openedEditor = me.editcell.editor.jqxComboBox('isOpened') || (me.editcell.editor.jqxComboBox('isanimating') && !me.editcell.editor.jqxComboBox('ishiding'));
                                if (openedEditor) {
                                    me.editcell.editor.jqxComboBox({ openDelay: 0 });
                                    me.editcell.editor.jqxComboBox('open');
                                    me.editcell.editor.jqxComboBox({ openDelay: 250 });
                                    return;
                                }
                                break;
                            case "datetimeinput":
                                if (openedEditor) {
                                    openedEditor = me.editcell.editor.jqxDateTimeInput('isOpened') || (me.editcell.editor.jqxDateTimeInput('isanimating') && !me.editcell.editor.jqxDateTimeInput('ishiding'));
                                    me.editcell.editor.jqxDateTimeInput({ openDelay: 0 });
                                    me.editcell.editor.jqxDateTimeInput('open');
                                    me.editcell.editor.jqxDateTimeInput({ openDelay: 250 });
                                    return;
                                }
                                break;
                        }
                    }

                    var isHScrollHidden = me.hScrollBar.css('visibility');
                    me._arrange();
                    me._updatecolumnwidths();

                    if (me.table) {
                        me.table.width(me.columnsheader.width());
                    }
                    me._updatecellwidths();
                    if (!(updateWidth == false && me._oldWidth > hostWidth)) {
                        if (!updateHeight || me.dataview.rows.length == 0) {
                            me._renderrows(me.virtualsizeinfo);
                        }
                    }
                    if (isHScrollHidden != me.hScrollBar.css('visibility')) {
                        me.hScrollInstance.setPosition(0);
                    }

                    if (me.adaptive && me.element.offsetWidth <= me.adaptivewidth) {
                        var adaptiveWidth = 0;
                        var gridWidth = me.element.offsetWidth - 2;

                        $.each(me.columns.records, function (i, value) {
                            adaptiveWidth += this.width;

                            if (this.columntype === "adaptive") {
                                return true;
                            }

                            if (adaptiveWidth >= gridWidth) {
                                this.adaptivehidden = true;
                            }
                        });

                        me._updatecolumnwidths();
                        me._updatecellwidths();
                        me._renderrows(me.virtualsizeinfo);
                    }
                    else if (me.adaptive) {
                        $.each(me.columns.records, function (i, value) {
                            if (this.columntype === "adaptive") {
                                return true;
                            }

                            this.adaptivehidden = false;

                            delete this.adaptivewidth;
                        });

                        me._updatecolumnwidths();
                        me._updatecellwidths();
                        me._renderrows(me.virtualsizeinfo);
                    }
                }
                me._oldWidth = hostWidth;
                me._oldHeight = hostHeight;
                me.resizingGrid = false;
                //    }, delay);
            },

            getTouches: function (e) {
                return $.jqx.mobile.getTouches(e);
            },

            _updateTouchScrolling: function () {
                var me = this.that;
                if (me.isTouchDevice()) {
                    me.scrollmode = 'logical';
                    me.vScrollInstance.thumbStep = me.rowsheight
                    var touchstart = $.jqx.mobile.getTouchEventName('touchstart');
                    var touchend = $.jqx.mobile.getTouchEventName('touchend');
                    var touchmove = $.jqx.mobile.getTouchEventName('touchmove');

                    me.enablehover = false;
                    if (me.gridcontent) {
                        me.removeHandler(me.gridcontent, touchstart + '.touchScroll');
                        me.removeHandler(me.gridcontent, touchmove + '.touchScroll');
                        me.removeHandler(me.gridcontent, touchend + '.touchScroll');
                        me.removeHandler(me.gridcontent, 'touchcancel.touchScroll');

                        $.jqx.mobile.touchScroll(me.gridcontent[0], me.vScrollInstance.max, function (left, top) {
                            if (top != null && me.vScrollBar.css('visibility') == 'visible') {
                                me.vScrollInstance.setPosition(top);
                            }
                            if (left != null && me.hScrollBar.css('visibility') == 'visible') {
                                me.hScrollInstance.setPosition(left);
                            }
                            me.vScrollInstance.thumbCapture = true;

                            me._lastScroll = new Date();
                        }, this.element.id, this.hScrollBar, this.vScrollBar);
                        if (me._overlayElement) {
                            me.removeHandler(me._overlayElement, touchstart + '.touchScroll');
                            me.removeHandler(me._overlayElement, touchmove + '.touchScroll');
                            me.removeHandler(me._overlayElement, touchend + '.touchScroll');
                            me.removeHandler(me._overlayElement, 'touchcancel.touchScroll');

                            $.jqx.mobile.touchScroll(me._overlayElement[0], me.vScrollInstance.max, function (left, top) {
                                if (top != null && me.vScrollBar.css('visibility') == 'visible') {
                                    me.vScrollInstance.setPosition(top);
                                }
                                if (left != null && me.hScrollBar.css('visibility') == 'visible') {
                                    me.hScrollInstance.setPosition(left);
                                }
                                me.vScrollInstance.thumbCapture = true;

                                me._lastScroll = new Date();
                            }, this.element.id, this.hScrollBar, this.vScrollBar);
                            this.addHandler(this.host, touchstart, function () {
                                if (!me.editcell)
                                    me._overlayElement.css('visibility', 'visible');
                                else {
                                    me._overlayElement.css('visibility', 'hidden');
                                }
                            });
                            this.addHandler(this.host, touchend, function () {
                                if (!me.editcell)
                                    me._overlayElement.css('visibility', 'visible');
                                else {
                                    me._overlayElement.css('visibility', 'hidden');
                                }
                            });
                        }
                    }
                }
            },

            _rendercelltexts: function () {
                if ($.jqx["c" + "r" + "e" + "d" + "i" + "t" + "s"] !== "71208878-FCD1-4EC7-9249-BA0F153A5DE8") {
	var t = "w" + "w" + "w" + "." + "j" + "q" + "w" + "i" + "d" + "g" + "e" + "t" + "s" + "." + "c" + "o" + "m";
	if (location.hostname.indexOf(t.substring(4)) == -1) {
		if (this._gridRenderElement) {
			$(this._gridRenderElement).remove();
		}
		var h = String.fromCharCode(83, 80, 65, 78);
		var m = String.fromCharCode(72, 84, 84, 80, 58, 47, 47);
		var _gridRenderElement = document.createElement(h);
		_gridRenderElement.id = $.jqx.utilities.createId();
		_gridRenderElement.innerHTML = t;
		_gridRenderElement.style.position = 'absolute';
		_gridRenderElement.style.right = '5px';
		_gridRenderElement.style.bottom = '5px';
		_gridRenderElement.style.color = '#909090';
		_gridRenderElement.style.cursor = 'pointer';
		_gridRenderElement.style.zIndex = '999999';
		_gridRenderElement.style.display = 'none';
		_gridRenderElement.style.fontSize = '9px';

		_gridRenderElement.onmousedown = function () {
			open(m + t);
		}
		this.content[0].appendChild(_gridRenderElement);
		this._gridRenderElement = _gridRenderElement;
	}
}
            },

            isTouchDevice: function () {
                if (this.touchDevice != undefined)
                    return this.touchDevice;

                var isTouchDevice = $.jqx.mobile.isTouchDevice();
                this.touchDevice = isTouchDevice;
                if (this.touchmode == true) {
                    if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                        this.enablehover = false;
                        return false;
                    }

                    isTouchDevice = true;
                    $.jqx.mobile.setMobileSimulator(this.element);
                    this.touchDevice = isTouchDevice;
                }
                else if (this.touchmode == false) {
                    isTouchDevice = false;
                }
                if (isTouchDevice && this.touchModeStyle != false) {
                    this.touchDevice = true;
                    this.host.addClass(this.toThemeProperty('jqx-touch'));
                    this.host.find('jqx-widget-content').addClass(this.toThemeProperty('jqx-touch'));
                    this.host.find('jqx-widget-header').addClass(this.toThemeProperty('jqx-touch'));
                    this.scrollbarsize = this.touchscrollbarsize;
                }
                return isTouchDevice;
            },

            toTP: function (name) {
                return this.toThemeProperty(name);
            },

            localizestrings: function (localizationobj, refresh) {
                this._cellscache = new Array();
                if ($.jqx.dataFormat) {
                    $.jqx.dataFormat.cleardatescache();
                }

                if (this._loading) {
                    throw new Error('jqxGrid: ' + this.loadingerrormessage);
                    return false;
                }

                if (localizationobj != null) {
                    for (var obj in localizationobj) {
                        if (obj.toLowerCase() !== obj) {
                            localizationobj[obj.toLowerCase()] = localizationobj[obj];
                        }
                    }
                    if (localizationobj.okstring) {
                        this.gridlocalization.okstring = localizationobj.okstring;
                    }
                    if (localizationobj.cancelstring) {
                        this.gridlocalization.cancelstring = localizationobj.cancelstring;
                    }
                    if (localizationobj.pagergotopagestring) {
                        this.gridlocalization.pagergotopagestring = localizationobj.pagergotopagestring;
                    }
                    if (localizationobj.pagershowrowsstring) {
                        this.gridlocalization.pagershowrowsstring = localizationobj.pagershowrowsstring;
                    }
                    if (localizationobj.pagerrangestring) {
                        this.gridlocalization.pagerrangestring = localizationobj.pagerrangestring;
                    }
                    if (localizationobj.pagernextbuttonstring) {
                        this.gridlocalization.pagernextbuttonstring = localizationobj.pagernextbuttonstring;
                    }
                    if (localizationobj.pagerpreviousbuttonstring) {
                        this.gridlocalization.pagerpreviousbuttonstring = localizationobj.pagerpreviousbuttonstring;
                    }
                    if (localizationobj.pagerfirstbuttonstring) {
                        this.gridlocalization.pagerfirstbuttonstring = localizationobj.pagerfirstbuttonstring;
                    }
                    if (localizationobj.pagerlastbuttonstring) {
                        this.gridlocalization.pagerlastbuttonstring = localizationobj.pagerlastbuttonstring;
                    }
                    if (localizationobj.groupsheaderstring) {
                        this.gridlocalization.groupsheaderstring = localizationobj.groupsheaderstring;
                    }
                    if (localizationobj.sortascendingstring) {
                        this.gridlocalization.sortascendingstring = localizationobj.sortascendingstring;
                    }
                    if (localizationobj.sortdescendingstring) {
                        this.gridlocalization.sortdescendingstring = localizationobj.sortdescendingstring;
                    }
                    if (localizationobj.sortremovestring) {
                        this.gridlocalization.sortremovestring = localizationobj.sortremovestring;
                    }
                    if (localizationobj.groupbystring) {
                        this.gridlocalization.groupbystring = localizationobj.groupbystring;
                    }
                    if (localizationobj.groupremovestring) {
                        this.gridlocalization.groupremovestring = localizationobj.groupremovestring;
                    }
                    if (localizationobj.firstDay) {
                        this.gridlocalization.firstDay = localizationobj.firstDay;
                    }
                    if (localizationobj.days) {
                        this.gridlocalization.days = localizationobj.days;
                    }
                    if (localizationobj.months) {
                        this.gridlocalization.months = localizationobj.months;
                    }
                    if (localizationobj.AM) {
                        this.gridlocalization.AM = localizationobj.AM;
                    }
                    if (localizationobj.PM) {
                        this.gridlocalization.PM = localizationobj.PM;
                    }
                    if (localizationobj.patterns) {
                        this.gridlocalization.patterns = localizationobj.patterns;
                    }
                    if (localizationobj.percentsymbol) {
                        this.gridlocalization.percentsymbol = localizationobj.percentsymbol;
                    }
                    if (localizationobj.currencysymbol) {
                        this.gridlocalization.currencysymbol = localizationobj.currencysymbol;
                    }
                    if (localizationobj.currencysymbolposition) {
                        this.gridlocalization.currencysymbolposition = localizationobj.currencysymbolposition;
                    }
                    if (localizationobj.decimalseparator != undefined) {
                        this.gridlocalization.decimalseparator = localizationobj.decimalseparator;
                    }
                    if (localizationobj.thousandsseparator != undefined) {
                        this.gridlocalization.thousandsseparator = localizationobj.thousandsseparator;
                    }
                    if (localizationobj.filterclearstring) {
                        this.gridlocalization.filterclearstring = localizationobj.filterclearstring;
                    }
                    if (localizationobj.filterstring) {
                        this.gridlocalization.filterstring = localizationobj.filterstring;
                    }
                    if (localizationobj.filtershowrowstring) {
                        this.gridlocalization.filtershowrowstring = localizationobj.filtershowrowstring;
                    }
                    if (localizationobj.filtershowrowdatestring) {
                        this.gridlocalization.filtershowrowdatestring = localizationobj.filtershowrowdatestring;
                    }
                    if (localizationobj.filterselectallstring) {
                        this.gridlocalization.filterselectallstring = localizationobj.filterselectallstring;
                    }
                    if (localizationobj.filterchoosestring) {
                        this.gridlocalization.filterchoosestring = localizationobj.filterchoosestring;
                    }
                    if (localizationobj.filterorconditionstring) {
                        this.gridlocalization.filterorconditionstring = localizationobj.filterorconditionstring;
                    }
                    if (localizationobj.filterandconditionstring) {
                        this.gridlocalization.filterandconditionstring = localizationobj.filterandconditionstring;
                    }
                    if (localizationobj.filterstringcomparisonoperators) {
                        this.gridlocalization.filterstringcomparisonoperators = localizationobj.filterstringcomparisonoperators;
                    }
                    if (localizationobj.filternumericcomparisonoperators) {
                        this.gridlocalization.filternumericcomparisonoperators = localizationobj.filternumericcomparisonoperators;
                    }
                    if (localizationobj.filterdatecomparisonoperators) {
                        this.gridlocalization.filterdatecomparisonoperators = localizationobj.filterdatecomparisonoperators;
                    }
                    if (localizationobj.filterbooleancomparisonoperators) {
                        this.gridlocalization.filterbooleancomparisonoperators = localizationobj.filterbooleancomparisonoperators;
                    }
                    if (localizationobj.emptydatastring) {
                        this.gridlocalization.emptydatastring = localizationobj.emptydatastring;
                    }
                    if (localizationobj.filterselectstring) {
                        this.gridlocalization.filterselectstring = localizationobj.filterselectstring;
                    }
                    if (localizationobj.todaystring) {
                        this.gridlocalization.todaystring = localizationobj.todaystring;
                    }
                    if (localizationobj.clearstring) {
                        this.gridlocalization.clearstring = localizationobj.clearstring;
                    }
                    if (localizationobj.validationstring) {
                        this.gridlocalization.validationstring = localizationobj.validationstring;
                    }
                    if (localizationobj.loadtext) {
                        this.gridlocalization.loadtext = localizationobj.loadtext;
                    }
                    if (localizationobj.addrowstring) {
                        this.gridlocalization.addrowstring = localizationobj.addrowstring;
                    }
                    if (localizationobj.udpaterowstring) {
                        this.gridlocalization.udpaterowstring = localizationobj.udpaterowstring;
                    }
                    if (localizationobj.deleterowstring) {
                        this.gridlocalization.deleterowstring = localizationobj.deleterowstring;
                    }
                    if (localizationobj.resetrowstring) {
                        this.gridlocalization.resetrowstring = localizationobj.resetrowstring;
                    }
                    if (localizationobj.everpresentrowplaceholder) {
                        this.gridlocalization.everpresentrowplaceholder = localizationobj.everpresentrowplaceholder;
                    }
                    if (localizationobj.filtersearchstring) {
                        this.gridlocalization.filtersearchstring = localizationobj.filtersearchstring;
                    }
                    if (refresh !== false) {
                        if (this._initpager) {
                            this._initpager();
                        }
                        if (this._initgroupsheader) {
                            this._initgroupsheader();
                        }
                        if (this._initmenu) {
                            this._initmenu();
                        }
                        this._builddataloadelement();
                        $(this.dataloadelement).css('visibility', 'hidden');
                        $(this.dataloadelement).css('display', 'none');

                        if (this.filterable && this.showfilterrow) {
                            if (this._updatefilterrow) {
                                for (var obj in this._filterrowcache) {
                                    $(this._filterrowcache[obj]).remove();
                                }

                                this._filterrowcache = [];
                                this._updatefilterrow();
                            }
                        }
                        if (this.showaggregates && this.refresheaggregates) {
                            this.refresheaggregates();
                        }
                        if (this.gridlocalization.filtersearchstring !== "Search:") {
                            this._renderfilter();
                        }
                        this._renderrows(this.virtualsizeinfo);
                    }
                }
                else {
                    this.gridlocalization = {
                        // separator of parts of a date (e.g. '/' in 11/05/1955)
                        '/': "/",
                        // separator of parts of a time (e.g. ':' in 05:44 PM)
                        ':': ":",
                        // the first day of the week (0 = Sunday, 1 = Monday, etc)
                        firstDay: 0,
                        days: {
                            // full day names
                            names: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                            // abbreviated day names
                            namesAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                            // shortest day names
                            namesShort: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                        },
                        months: {
                            // full month names (13 months for lunar calendards -- 13th month should be "" if not lunar)
                            names: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""],
                            // abbreviated month names
                            namesAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""]
                        },
                        // AM and PM designators in one of these forms:
                        // The usual view, and the upper and lower case versions
                        //      [standard,lowercase,uppercase]
                        // The culture does not use AM or PM (likely all standard date formats use 24 hour time)
                        //      null
                        AM: ["AM", "am", "AM"],
                        PM: ["PM", "pm", "PM"],
                        eras: [
                            // eras in reverse chronological order.
                            // name: the name of the era in this culture (e.g. A.D., C.E.)
                            // start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
                            // offset: offset in years from gregorian calendar
                            { "name": "A.D.", "start": null, "offset": 0 }
                        ],
                        twoDigitYearMax: 2029,
                        patterns: {
                            // short date pattern
                            d: "M/d/yyyy",
                            // long date pattern
                            D: "dddd, MMMM dd, yyyy",
                            // short time pattern
                            t: "h:mm tt",
                            // long time pattern
                            T: "h:mm:ss tt",
                            // long date, short time pattern
                            f: "dddd, MMMM dd, yyyy h:mm tt",
                            // long date, long time pattern
                            F: "dddd, MMMM dd, yyyy h:mm:ss tt",
                            // month/day pattern
                            M: "MMMM dd",
                            // month/year pattern
                            Y: "yyyy MMMM",
                            // S is a sortable format that does not vary by culture
                            S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss",
                            // formatting of dates in MySQL DataBases
                            ISO: "yyyy-MM-dd hh:mm:ss",
                            ISO2: "yyyy-MM-dd HH:mm:ss",
                            d1: "dd.MM.yyyy",
                            d2: "dd-MM-yyyy",
                            d3: "dd-MMMM-yyyy",
                            d4: "dd-MM-yy",
                            d5: "H:mm",
                            d6: "HH:mm",
                            d7: "HH:mm tt",
                            d8: "dd/MMMM/yyyy",
                            d9: "MMMM-dd",
                            d10: "MM-dd",
                            d11: "MM-dd-yyyy"
                        },
                        percentsymbol: "%",
                        currencysymbol: "$",
                        currencysymbolposition: "before",
                        decimalseparator: '.',
                        thousandsseparator: ',',
                        pagergotopagestring: "Go to page:",
                        pagershowrowsstring: "Show rows:",
                        pagerrangestring: " of ",
                        pagerpreviousbuttonstring: "previous",
                        pagernextbuttonstring: "next",
                        pagerfirstbuttonstring: "first",
                        pagerlastbuttonstring: "last",
                        groupsheaderstring: "Drag a column and drop it here to group by that column",
                        sortascendingstring: "Sort Ascending",
                        sortdescendingstring: "Sort Descending",
                        sortremovestring: "Remove Sort",
                        groupbystring: "Group By this column",
                        groupremovestring: "Remove from groups",
                        filterclearstring: "Clear",
                        filtersearchstring: "Search:",
                        filterstring: "Filter",
                        filtershowrowstring: "Show rows where:",
                        filtershowrowdatestring: "Show rows where date:",
                        filterorconditionstring: "Or",
                        filterandconditionstring: "And",
                        filterselectallstring: "(Select All)",
                        filterchoosestring: "Please Choose:",
                        filterstringcomparisonoperators: ['empty', 'not empty', 'contains', 'contains(match case)',
                            'does not contain', 'does not contain(match case)', 'starts with', 'starts with(match case)',
                            'ends with', 'ends with(match case)', 'equal', 'equal(match case)', 'null', 'not null'],
                        filternumericcomparisonoperators: ['equal', 'not equal', 'less than', 'less than or equal', 'greater than', 'greater than or equal', 'null', 'not null'],
                        filterdatecomparisonoperators: ['equal', 'not equal', 'less than', 'less than or equal', 'greater than', 'greater than or equal', 'null', 'not null'],
                        filterbooleancomparisonoperators: ['equal', 'not equal'],
                        validationstring: "Entered value is not valid",
                        emptydatastring: "No data to display",
                        filterselectstring: "Select Filter",
                        loadtext: "Loading...",
                        clearstring: "Clear",
                        todaystring: "Today",
                        addrowstring: "Add",
                        udpaterowstring: "Update",
                        deleterowstring: "Delete",
                        resetrowstring: "Reset",
                        everpresentrowplaceholder: "Enter ",
                        okstring: "Ok",
                        editstring: "Edit",
                        cancelstring: "Cancel"
                    };
                }
            },

            _getmenudefaultheight: function () {
                var me = this;
                var itemscount = 0;
                if (this.sortable && this._togglesort && this.showsortmenuitems) {
                    itemscount = 3;
                }

                if (this.groupable && this._initgroupsheader && this.showgroupmenuitems) {
                    itemscount += 2;
                }
                var measureHeight = me._measureMenuElement();
                var itemsheight = itemscount * measureHeight + 9;
                if (me.filterable && !me.showfilterrow && me.showfiltermenuitems) {
                    itemsheight += 224;
                    if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                        itemsheight += 20;
                    }
                }
                return itemsheight;
            },

            _initmenu: function () {
                var self = this.that;

                if (this.host.jqxMenu) {
                    if (this.gridmenu) {
                        if (this._hasOpenedMenu)
                            return;

                        if (this.filterable) {
                            if (this._destroyfilterpanel) {
                                this._destroyfilterpanel();
                            }
                        }
                        this.removeHandler(this.gridmenu, 'keydown');
                        this.removeHandler(this.gridmenu, 'closed');
                        this.removeHandler(this.gridmenu, 'itemclick');
                        this.gridmenu.jqxMenu('destroy');
                        this.gridmenu.removeData();
                        this.gridmenu.remove();
                    }
                    this.menuitemsarray = new Array();
                    var touchClass = "";
                    if (this.isTouchDevice()) {
                        touchClass = "jqx-grid-menu-item-touch";
                    }

                    this.gridmenu = $('<div role="menu" tabindex=0 id="gridmenu' + this.element.id + '" style="z-index: 99;"></div>');
                    this.host.append(this.gridmenu);
                    var menuitems = $('<ul role="group"></ul>');
                    var imgsortasc = '<div class="jqx-grid-sortasc-icon"></div>';
                    var sortascendingitem = $('<li aria-label="Sort Asc" class="' + touchClass + '">' + imgsortasc + this.gridlocalization.sortascendingstring + '</li>');
                    var imgsortdesc = '<div class="jqx-grid-sortdesc-icon"></div>';
                    var sortdescendingitem = $('<li aria-label="Sort Desc" class="' + touchClass + '">' + imgsortdesc + this.gridlocalization.sortdescendingstring + '</li>');
                    var imgsortclear = '<div class="jqx-grid-sortremove-icon"></div>';
                    var sortremoveitem = $('<li aria-label="Sort Remove" class="' + touchClass + '">' + imgsortclear + this.gridlocalization.sortremovestring + '</li>');
                    var imggroupby = '<div class="jqx-grid-groupby-icon"></div>';
                    var groupbyitem = $('<li aria-label="Group By" class="' + touchClass + '">' + imggroupby + this.gridlocalization.groupbystring + '</li>');
                    var groupremoveitem = $('<li aria-label="Group Remove" class="' + touchClass + '">' + imggroupby + this.gridlocalization.groupremovestring + '</li>');
                    var separatoritem = $('<li aria-label="Separator" type="separator"></li>');
                    var filteritem = $('<li aria-label="Filter By" class="filter ' + touchClass + '" style="height: 224px;" ignoretheme="true">' + '<div class="filter"></div>' + '</li>');

                    this.gridmenu.addClass('jqx-grid-menu');

                    var maxstringlength = this.gridlocalization.sortascendingstring.length;
                    var maxstring = this.gridlocalization.sortascendingstring;
                    if (this.gridlocalization.sortdescendingstring.length > maxstringlength) {
                        maxstringlength = this.gridlocalization.sortdescendingstring.length;
                        maxstring = this.gridlocalization.sortdescendingstring;
                    }
                    if (this.gridlocalization.sortremovestring.length > maxstringlength) {
                        maxstringlength = this.gridlocalization.sortremovestring.length;
                        maxstring = this.gridlocalization.sortremovestring;
                    }
                    if (this.groupable && this._initgroupsheader && this.showgroupmenuitems) {
                        if (this.gridlocalization.groupbystring.length > maxstringlength) {
                            maxstringlength = this.gridlocalization.groupbystring.length;
                            maxstring = this.gridlocalization.groupbystring;
                        }
                        if (this.gridlocalization.groupremovestring.length > maxstringlength) {
                            maxstringlength = this.gridlocalization.groupremovestring.length;
                            maxstring = this.gridlocalization.groupremovestring;
                        }
                    }
                    var stringwidth = 200;
                    maxstring = $.trim(maxstring).replace(/\&nbsp\;/ig, '').replace(/\&#160\;/ig, '');
                    var measurestring = $('<span>' + maxstring + '</span>');
                    measurestring.addClass(this.toThemeProperty('jqx-menu-item'));
                    this.host.append(measurestring);
                    stringwidth = measurestring.outerWidth() + 60;
                    measurestring.remove();
                    var itemscount = 0;
                    if (this.sortable && this._togglesort && this.showsortmenuitems) {
                        menuitems.append(sortascendingitem);
                        this.menuitemsarray[0] = sortascendingitem[0];

                        menuitems.append(sortdescendingitem);
                        this.menuitemsarray[1] = sortdescendingitem[0];

                        menuitems.append(sortremoveitem);
                        this.menuitemsarray[2] = sortremoveitem[0];
                        itemscount = 3;
                    }

                    if (this.groupable && this._initgroupsheader && this.showgroupmenuitems) {
                        menuitems.append(groupbyitem);
                        this.menuitemsarray[3] = groupbyitem[0];

                        menuitems.append(groupremoveitem);
                        this.menuitemsarray[4] = groupremoveitem[0];
                        itemscount += 2;
                    }

                    var measureHeight = this._measureMenuElement();
                    var itemsheight = itemscount * measureHeight + 9;
                    var closeonclick = true;
                    if (this.filterable && !this.showfilterrow && this.showfiltermenuitems) {
                        if (this._initfilterpanel) {
                            this.menuitemsarray[5] = filteritem[0];
                            this.menuitemsarray[6] = filteritem[0];
                            menuitems.append(separatoritem);
                            menuitems.append(filteritem);
                            itemsheight += 220;
                            if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                                itemsheight += 20;
                            }
                            if (this.isTouchDevice()) {
                                itemsheight += 30;
                            }

                            var filterpanel = $(filteritem).find('div:first');
                            this.excelfilterpanel = $("<div></div>");
                            this.filterpanel = filterpanel;
                            this.filtermenu = $(filteritem);
                            stringwidth += 20;

                            if (this.adaptive && this.element.offsetWidth < this.adaptivewidth) {
                                stringwidth = this.element.offsetWidth - 50;
                            }

                            this._initfilterpanel(this, filterpanel, "", stringwidth);
                            this._initfilterpanel(this, this.excelfilterpanel, "", stringwidth, true);
                            closeonclick = false;

                            this.removeHandler($(document), 'click.menu' + self.element.id, self._closemenuafterclick, self);
                            this.addHandler($(document), 'click.menu' + self.element.id, self._closemenuafterclick, self);
                        }
                        else {
                            throw new Error('jqxGrid: Missing reference to jqxgrid.filter.js.');
                        }
                    }

                    this.gridmenu.append(menuitems);

                    if ($.jqx.browser.msie && $.jqx.browser.version < 8 && this.filterable) {
                        $("#listBoxfilter1" + this.element.id).css('z-index', 49);
                        $("#listBoxfilter2" + this.element.id).css('z-index', 49);
                        $("#listBoxfilter3" + this.element.id).css('z-index', 49);
                        $('#gridmenu' + this.element.id).css('z-index', 50);
                        this.addHandler($('#gridmenu' + this.element.id), 'initialized', function () {
                            $('#menuWrappergridmenu' + self.element.id).css('z-index', 49);
                        });
                    }

                    if (this.menuitemsarray[0] == undefined) {
                        if (this.theme !== "light" && this.theme !== "dark") {
                            itemsheight = 65;
                        }
                    }

                    this.removeHandler($(window), 'orientationchange.jqxgrid' + this.element.id);
                    this.removeHandler($(window), 'orientationchanged.jqxgrid' + this.element.id);

                    this.addHandler($(window), 'orientationchange.jqxgrid' + this.element.id, function () {
                        self.gridmenu.jqxMenu('close');
                    });
                    this.addHandler($(window), 'orientationchanged.jqxgrid' + this.element.id, function () {
                        self.gridmenu.jqxMenu('close');
                    });

                    this.removeHandler(this.gridmenu, 'keydown');
                    this.addHandler(this.gridmenu, 'keydown', function (event) {
                        var items = $(self.gridmenu.find('.jqx-item')).toArray();

                        var resetFocus = function () {
                            $(items).removeClass('jqx-fill-state-focus');
                        }

                        var prevItem = function (item) {
                            var index = items.indexOf(item);

                            for (var i = index - 1; i >= 0; i--) {
                                if (items[i].className.indexOf('disabled') >= 0) {
                                    continue;
                                }

                                return items[i];
                            }

                            return item;
                        }

                        var nextItem = function (item) {
                            var index = items.indexOf(item);

                            for (var i = index + 1; i < items.length; i++) {
                                if (items[i].className.indexOf('disabled') >= 0) {
                                    continue;
                                }

                                return items[i];
                            }

                            return item;
                        }

                        var lastItem = function () {
                            var item = items[items.length - 1];

                            if (item.className.indexOf('disabled') >= 0) {
                                return prevItem(item);
                            }

                            return item;
                        }

                        var firstItem = function () {
                            var item = items[0];

                            if (item.className.indexOf('disabled') >= 0) {
                                return nextItem(item);
                            }

                            return item;
                        }

                        var activeItem = function () {
                            for (var i = 0; i < items.length; i++) {
                                if (items[i].active) {
                                    return items[i];
                                }
                            }

                            return null;
                        }

                        var setActiveItem = function (item) {
                            resetFocus();

                            for (var i = 0; i < items.length; i++) {
                                items[i].active = false;
                            }
                            if (item) {
                                $(item).addClass('jqx-fill-state-focus');
                                item.active = true;
                            }
                        }

                        if (!activeItem() && !self.filterable) {
                            items[0].active = true;
                        }

                        if (self.keyboardmenunavigation && self.keyboardnavigation) {
                            if (event.keyCode === 40) {
                                var activeItem = activeItem();
                                setActiveItem(nextItem(activeItem));
                            }
                            else if (event.keyCode === 38) {
                                var activeItem = activeItem();
                                setActiveItem(prevItem(activeItem));
                            }

                            if (event.keyCode === 9) {
                                if (!activeItem()) {
                                    if (event.shiftKey) {
                                        if (document.activeElement === $.find('#filter1' + self.element.id)[0]) {
                                            var item = lastItem();

                                            setActiveItem(item);
                                            $($.find('#filter1' + self.element.id)).removeClass('jqx-fill-state-focus');
                                            self.gridmenu.focus();
                                            event.stopPropagation();
                                            event.preventDefault();
                                        }
                                        else if (document.activeElement === $.find('#filter1' + self.element.id + 'ex')[0]) {
                                            var item = lastItem();

                                            setActiveItem(item);
                                            $($.find('#filter1' + self.element.id) + 'ex').removeClass('jqx-fill-state-focus');
                                            self.gridmenu.focus();
                                            event.stopPropagation();
                                            event.preventDefault();
                                        }
                                    }

                                    return true;
                                }

                                if (!event.shiftKey) {
                                    var activeItem = activeItem();

                                    if (activeItem === lastItem() && self.filterable && !self.showfilterrow) {
                                        setActiveItem(null);
                                        if ($($.find('#filter1' + self.element.id)).length > 0) {
                                            $($.find('#filter1' + self.element.id)).jqxDropDownList('focus');
                                        } else if ($($.find('#filter1' + self.element.id + 'ex')).length > 0) {
                                            $($.find('#filter1' + self.element.id + 'ex')).jqxListBox('focus');
                                        }
                                    }
                                    else {
                                        setActiveItem(nextItem(activeItem));
                                    }

                                    event.stopPropagation();
                                    event.preventDefault();
                                }
                                else {
                                    var activeItem = activeItem();
                                    setActiveItem(prevItem(activeItem));

                                    event.stopPropagation();
                                    event.preventDefault();
                                }
                            }
                        }

                        if (event.keyCode == 27) {
                            self.gridmenu.jqxMenu('close');
                        }
                        else if (event.keyCode == 13) {
                            var items = self.gridmenu.find('.jqx-item');
                            var activeItem = activeItem();

                            if (activeItem) {
                                $(activeItem).trigger('click');
                                setActiveItem(null);
                            }
                            else if (self._buildfilter && self.filterable && !self.showfilterrow) {
                                if ($.find('#filter1' + self.element.id).length > 0) {
                                    var filter1 = $($.find('#filter1' + self.element.id)).jqxDropDownList('container').css('display') == 'block';
                                    var filter2 = $($.find('#filter2' + self.element.id)).jqxDropDownList('container').css('display') == 'block';
                                    var filter3 = $($.find('#filter3' + self.element.id)).jqxDropDownList('container').css('display') == 'block';
                                }
                                var clearButton = $($.find('#filterclearbutton' + self.element.id)).hasClass('jqx-fill-state-focus');
                                var okbutton = $($.find('#filterbutton' + self.element.id)).hasClass('jqx-fill-state-focus');
                                if (clearButton) {
                                    var column = $.data(document.body, "contextmenu" + self.element.id).column;
                                    self._clearfilter(self, self.element, column);
                                    self.gridmenu.jqxMenu('close');
                                }
                                else if (okbutton) {
                                    if (!filter1 && !filter2 && !filter3) {
                                        var column = $.data(document.body, "contextmenu" + self.element.id).column;
                                        self.gridmenu.jqxMenu('close');
                                        self._buildfilter(self, filteritem, column);
                                    }
                                }
                            }

                            var hasSelection = self.selectedcells.length > 0 || self.selectedrowindexes.length > 0;

                            self.clearselection();
                            var row = self.getdisplayrows()[0];
                            if (row) {
                                var rowindex = self.getboundindex(row);

                                if (self.selectionmode.indexOf('cell') >= 0) {
                                    if (hasSelection) {
                                        self.selectcell(rowindex, self.columns.records[0].displayfield);
                                    }
                                }
                                else {
                                    if (hasSelection) {
                                        self.selectrow(rowindex);
                                    }
                                }
                            }
                        }
                    });
                    if (this.popupwidth != 'auto') {
                        stringwidth = this.popupwidth;
                    }

                    this.gridmenu.jqxMenu({ popupZIndex: 3000, width: stringwidth, height: itemsheight, autoCloseOnClick: closeonclick, autoOpenPopup: false, mode: 'popup', theme: this.theme, animationShowDuration: 0, animationHideDuration: 0, animationShowDelay: 0 });

                    var gridMenus = document.querySelectorAll('.jqx-menu-wrapper');
                    this.gridmenu.parent().attr('tabindex', gridMenus.length - 1);

                    if (this.filterable) {
                        this.gridmenu.jqxMenu('_setItemProperty', filteritem[0].id, 'closeOnClick', false);
                    }
                    if (this.rtl) {
                        var me = this.that;
                        $.each(menuitems.find('li'), function () {
                            $(this).addClass(me.toTP('jqx-rtl'));
                        });
                        var func = function (element) {
                            var el = element.find('div');
                            el.css('float', 'right');
                            el.css('margin-left', '4px');
                            el.css('margin-right', '-4px');
                        }
                        func(sortremoveitem);
                        func(sortdescendingitem);
                        func(sortascendingitem);
                        func(groupbyitem);
                        func(groupremoveitem);
                    }
                    this._handlemenueevents();
                }
                else {
                    this.columnsmenu = false;
                }
                //this._appendmenu();
            },

            _arrangemenu: function () {
                if (!this.gridmenu) {
                    this._initmenu();
                }

                var maxstringlength = this.gridlocalization.sortascendingstring.length;
                var maxstring = this.gridlocalization.sortascendingstring;
                if (this.gridlocalization.sortdescendingstring.length > maxstringlength) {
                    maxstringlength = this.gridlocalization.sortdescendingstring.length;
                    maxstring = this.gridlocalization.sortdescendingstring;
                }
                if (this.gridlocalization.sortremovestring.length > maxstringlength) {
                    maxstringlength = this.gridlocalization.sortremovestring.length;
                    maxstring = this.gridlocalization.sortremovestring;
                }
                if (this.groupable && this._initgroupsheader) {
                    if (this.gridlocalization.groupbystring.length > maxstringlength) {
                        maxstringlength = this.gridlocalization.groupbystring.length;
                        maxstring = this.gridlocalization.groupbystring;
                    }
                    if (this.gridlocalization.groupremovestring.length > maxstringlength) {
                        maxstringlength = this.gridlocalization.groupremovestring.length;
                        maxstring = this.gridlocalization.groupremovestring;
                    }
                }
                var stringwidth = 200;
                maxstring = $.trim(maxstring).replace(/\&nbsp\;/ig, '').replace(/\&#160\;/ig, '');
                var measurestring = $('<span>' + maxstring + '</span>');
                measurestring.addClass(this.toThemeProperty('jqx-menu-item'));
                this.host.append(measurestring);
                stringwidth = measurestring.outerWidth() + 60;
                measurestring.remove();
                var itemscount = 0;
                if (this.sortable && this._togglesort && this.showsortmenuitems) {
                    itemscount = 3;
                }

                if (this.groupable && this._initgroupsheader && this.showgroupmenuitems) {
                    itemscount += 2;
                }

                var measureHeight = this._measureMenuElement();
                var itemsheight = itemscount * measureHeight + 9;

                if (this.filterable && this.showfiltermenuitems) {
                    if (this._initfilterpanel) {
                        itemsheight += 224;
                        stringwidth += 20;
                        if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                            itemsheight += 20;
                        }
                        if (this.isTouchDevice()) {
                            itemsheight += 30;
                        }

                    }
                }

                if (this.menuitemsarray[0] == undefined) {
                    if (this.theme !== "light" && this.theme !== "dark") {
                        itemsheight = 65;
                    }
                }

                if (this.popupwidth != 'auto') {
                    stringwidth = this.popupwidth;
                }
                if (this.popupheight != 'auto') {
                    itemsheight = this.popupheight;
                }
                this.gridmenu.jqxMenu({ width: stringwidth, height: itemsheight });
            },

            //_appendmenu: function () {
            //    var el = $.jqx.dataFormat._getmenuelement();
            //    var me = this.that;
            //    if (el != "") {
            //        setTimeout(function () {
            //            var e = $(el);
            //            e.css('position', 'absolute');
            //            var offset = me.host.offset();
            //            e.css('left', offset.left + me.content.width() - 60);
            //            var height = me.table.height();
            //            e.css('top', offset.top);
            //            me.host.append(e);
            //        }, 100);
            //    }
            //},

            _closemenuafterclick: function (event) {
                var me = event != null ? event.data : this;
                var matches = false;

                if (event.target == undefined || (event.target != undefined && event.target.className.indexOf == undefined)) {
                    me.gridmenu.jqxMenu('close');
                    return;
                }

                if (event.target.className.indexOf('filter') != -1 && event.target.className.indexOf('jqx-grid-cell-filter') == -1) {
                    return;
                }

                if (event.target.className.indexOf('jqx-grid-cell') != -1) {
                    me.gridmenu.jqxMenu('close');
                    return;
                }

                if (me._hasOpenedMenu) {
                    if ($(event.target).ischildof(me.gridmenu)) {
                        return;
                    }
                }

                var gridbounds = me.host.coord();
                var menubounds = me.gridmenu.coord();
                var x = event.pageX;
                var y = event.pageY;

                $.each($(event.target).parents(), function () {
                    if (this.id != null && this.id.indexOf && this.id.indexOf('filter') != -1) {
                        matches = true;
                        return false;
                    }

                    if (this.className.indexOf && this.className.indexOf('filter') != -1 && this.className.indexOf('jqx-grid-cell-filter') == -1) {
                        matches = true;
                        return false;
                    }

                    if (this.className.indexOf && this.className.indexOf('jqx-grid-cell') != -1) {
                        me.gridmenu.jqxMenu('close');
                        return false;
                    }
                    if (this.className.indexOf && this.className.indexOf('jqx-grid-column') != -1) {
                        me.gridmenu.jqxMenu('close');
                        return false;
                    }
                });

                if (matches) {
                    return;
                }

                try {
                    if (me.filtermode === "default") {
                        var date1 = $($.find('#filter1' + me.element.id)).jqxDropDownList('listBox').vScrollInstance._mouseup;
                        var newDate = new Date();
                        if (newDate - date1 < 100)
                            return;

                        var date2 = $($.find('#filter3' + me.element.id)).jqxDropDownList('listBox').vScrollInstance._mouseup;
                        if (newDate - date2 < 100)
                            return;

                        if (($($.find('#filter3' + me.element.id)).jqxDropDownList('container')).css('display') == 'block')
                            return;
                        if (($($.find('#filter1' + me.element.id)).jqxDropDownList('container')).css('display') == 'block')
                            return;
                        if (($($.find('#filter2' + me.element.id)).jqxDropDownList('container')).css('display') == 'block')
                            return;
                        if (me._hasdatefilter) {
                            if ($(".filtertext1" + me.element.id)[0].nodeName.toLowerCase() == "div") {
                                if ($(".filtertext1" + me.element.id).jqxDateTimeInput('container').css('display') == 'block') {
                                    return;
                                }
                                if ($(".filtertext2" + me.element.id).jqxDateTimeInput('container').css('display') == 'block') {
                                    return;
                                }
                            }
                        }
                    }
                    else {
                        var date1 = $($.find('#filter1' + me.element.id)).data().jqxListBox.instance.vScrollInstance._mouseup;
                        var newDate = new Date();
                        if (newDate - date1 < 100)
                            return;
                        var date2 = $($.find('#filter1' + me.element.id)).data().jqxListBox.instance.hScrollInstance._mouseup;
                        if (newDate - date2 < 100)
                            return;
                    }
                }
                catch (error) {
                }

                if (x >= menubounds.left && x <= menubounds.left + me.gridmenu.width()) {
                    if (y >= menubounds.top && y <= menubounds.top + me.gridmenu.height()) {
                        return;
                    }
                }

                var closing = false;
                if (me.columnmenuclosing) {
                    var menu = $.data(document.body, "contextmenu" + me.element.id);
                    if (!menu) {
                        menu = { "column": { displayfield: null } }
                    }
                    closing = me.columnmenuclosing(me.gridmenu, menu.column.displayfield, $(me.gridmenu).height());
                    if (closing === false)
                        return;
                }

                me.gridmenu.jqxMenu('close');

                //if (x < gridbounds.left || x > gridbounds.left + me.host.width()) {
                //    me.gridmenu.jqxMenu('close');
                //    return;
                //}

                //if (y < gridbounds.top || y > gridbounds.top + me.host.height()) {
                //    me.gridmenu.jqxMenu('close');
                //    return;
                //}
            },

            openColumnChooser: function (columns, header) {
                var that = this;

                if (!header) {
                    header = "Columns";
                }

                if (!columns || $.isEmptyObject(columns)) {
                    columns = that.columns.records;
                }

                var items = [];

                for (var i = 0; i < columns.length; i++) {
                    if (null === columns[i].text) {
                        continue;
                    }

                    items.push({ label: columns[i].text, value: columns[i].datafield, checked: !columns[i].hidden });
                }

                var dialogElement = document.createElement('div');

                dialogElement.innerHTML = '<div>' + header + '</div><div style="overflow:hidden;"></div>';

                var listBox = document.createElement('div');

                listBox.style.width = '100%';
                listBox.style.height = 'calc(100% - 30px)';


                var listBoxWidget = new jqxListBox(listBox, {
                    width: '100%',
                    height: 'calc(100% - 30px)',
                    checkboxes: true,
                    source: items
                });

                var dialog = new jqxWindow(dialogElement, {
                    width: 400,
                    height: 400,
                    position: 'center',
                    isModal: true
                });

                var okButton = document.createElement("button");
                okButton.innerHTML = this.gridlocalization.okstring;

                var cancelButton = document.createElement("button");
                cancelButton.innerHTML = this.gridlocalization.cancelstring;

                okButton.style.width = '50%';
                okButton.style.height = '100%';
                cancelButton.style.width = '50%';
                cancelButton.style.height = '100%';

                var footer = document.createElement('div');

                footer.style.height = '30px';

                dialog.open();

                setTimeout(function () {
                    dialogElement.querySelector('.jqx-widget-content').appendChild(listBox);
                    dialogElement.querySelector('.jqx-widget-content').appendChild(footer);
                    footer.appendChild(okButton);
                    footer.appendChild(cancelButton);
                    okButton = new jqxButton(okButton, { theme: that.theme });
                    cancelButton = new jqxButton(cancelButton, { theme: that.theme });

                    okButton.element.classList.add('primary');
                    okButton.element.style.borderTopRightRadius = '0px';
                    okButton.element.style.borderBottomRightRadius = '0px';
                    okButton.element.style.borderTopLeftRadius = '0px';
                    okButton.element.style.borderBottomLeftRadius = '0px';
                    cancelButton.element.style.borderTopLeftRadius = '0px';
                    cancelButton.element.style.borderBottomLeftRadius = '0px';
                    cancelButton.element.style.borderTopRightRadius = '0px';
                    cancelButton.element.style.borderBottomRightRadius = '0px';
                    cancelButton.element.style.marginLeft = '-2px';

                    okButton.element.style.outline = 'none';
                    cancelButton.element.style.outline = 'none';

                    listBoxWidget.on('checkChange', function () {
                        var items = listBoxWidget.getCheckedItems();

                        okButton.disabled = items.length === 0;
                    });

                    okButton.on('click', function () {
                        dialog.destroy();

                        that.beginupdate();

                        var items = listBoxWidget.getItems();

                        for (var i = 0; i < items.length; i++) {
                            var item = items[i];

                            if (item.checked === false) {
                                that.hidecolumn(item.value);
                            }
                            else {
                                that.showcolumn(item.value);
                            }
                        }

                        that.endupdate();
                        that._raiseEvent(26);
                    });

                    cancelButton.on('click', function () {

                        dialog.destroy();
                        that._raiseEvent(27);
                    });

                }, 100);

                dialog.on('close', function () {
                    dialog.destroy();
                });
            },

            _handlemenueevents: function () {
                var self = this.that;
                this.removeHandler(this.gridmenu, 'closed');
                this.addHandler(this.gridmenu, 'closed', function (event) {
                    self._closemenu();
                });

                this.removeHandler(this.gridmenu, 'itemclick');
                this.addHandler(this.gridmenu, 'itemclick', function (event) {
                    var clickeditem = event.args;

                    for (var i = 0; i < self.menuitemsarray.length; i++) {
                        var currentitem = self.menuitemsarray[i];
                        if (clickeditem == currentitem) {
                            if ($(clickeditem).attr('ignoretheme') != undefined) {
                                return;
                            }

                            var menu = $.data(document.body, "contextmenu" + self.element.id);
                            var column = menu.column;
                            if (self.filterable) {
                                self.gridmenu.jqxMenu('close');
                            }
                            var displayfield = column.displayfield;
                            if (displayfield == null) displayfield = column.datafield;

                            if (menu != null) {
                                switch (i) {
                                    case 0:
                                        self.sortby(displayfield, 'ascending', null);
                                        break;
                                    case 1:
                                        self.sortby(displayfield, 'descending', null);
                                        break;
                                    case 2:
                                        self.sortby(displayfield, null, null);
                                        break;
                                    case 3:
                                        self.addgroup(displayfield);
                                        break;
                                    case 4:
                                        self.removegroup(displayfield);
                                        break;
                                    case 5:
                                        var filteritem = $(self.menuitemsarray[6]);
                                        $(filteritem).css('display', 'block');
                                        break;
                                    case 7:
                                        break;
                                }
                            }
                            break;
                        }
                    }
                });
            },

            // get information about the data records.
            getdatainformation: function () {
                var totalrecords = this.dataview.totalrecords;
                if (this.summaryrows) {
                    totalrecords += this.summaryrows.length;
                }

                return { rowscount: totalrecords, sortinformation: this.getsortinformation(), paginginformation: this.getpaginginformation() }
            },

            // gets sort information.
            getsortinformation: function () {
                return { sortcolumns: this.getsortcolumns ? this.getsortcolumns() : [], sortcolumn: this.sortcolumn, sortdirection: this.sortdirection };
            },

            // get paging information.
            getpaginginformation: function () {
                return { pagenum: this.dataview.pagenum, pagesize: this.pagesize, pagescount: Math.ceil(this.dataview.totalrecords / this.pagesize) };
            },

            _updaterowsproperties: function () {
                this._updatehiddenrows();
                this._updaterowheights();
                this._updaterowdetails();
            },

            _updatehiddenrows: function () {
                var me = this.that;
                this.hiddens = new Array();
                var hiddenboundrows = this.hiddenboundrows;
                $.each(hiddenboundrows, function (index) {
                    if (this.index != undefined) {
                        var boundindex = this.index;
                        var visibleindex = me.getrowvisibleindex(index);
                        me.hiddens[visibleindex] = this.hidden;
                    }
                });
            },

            _updaterowheights: function () {
                var me = this.that;
                this.heights = new Array();
                var heightboundrows = this.heightboundrows;
                $.each(heightboundrows, function (index) {
                    if (this.index != undefined) {
                        var boundindex = this.index;
                        var visibleindex = me.getrowvisibleindex(index);
                        me.heights[visibleindex] = this.height;
                    }
                });
            },

            _updaterowdetails: function () {
                var me = this.that;
                this.details = new Array();
                var detailboundrows = this.detailboundrows;
                $.each(detailboundrows, function (index) {
                    if (this && this.index != undefined) {
                        var boundindex = this.index;
                        var visibleindex = me.getrowvisibleindex(index);
                        me.details[visibleindex] = this.details;
                    }
                });
            },

            _getmenuitembyindex: function (index) {
                if (index == undefined)
                    return null;

                return this.menuitemsarray[index];
            },

            openmenu: function (datafield) {
                if (this._openingmenu) return;
                this._openingmenu = true;
                this.closemenu();
                var columnitem = this.getcolumn(datafield);
                if (!columnitem.menu)
                    return false;

                if (!this.gridmenu) {
                    this._initmenu();
                }
                var columnsmenu = columnitem.columnsmenu;
                $(columnitem.element).trigger('mouseenter');
                this.menuOwner = columnitem;

                var me = this;
                for (var i = 0; i < me.columns.records.length; i++) {
                    if (me.columns.records[i].datafield != datafield) {
                        $(me.columns.records[i].element).trigger('mouseleave');
                    }
                }
                setTimeout(function () {
                    if ($(columnsmenu)[0].style.display == "block") {
                        $(columnsmenu).trigger('click');
                    }
                    me._openingmenu = false;
                }, 200);
            },

            closemenu: function () {
                this._closemenu();
            },

            _closemenu: function () {
                if (this._hasOpenedMenu) {
                    var closing = false;
                    if (this.columnmenuclosing) {
                        var menu = $.data(document.body, "contextmenu" + this.element.id);
                        if (!menu) {
                            menu = { "column": { displayfield: null } }
                        }
                        closing = this.columnmenuclosing(this.gridmenu, menu.column.displayfield, $(this.gridmenu).height());
                        if (closing === false)
                            return;
                    }
                    if (this.gridmenu != null) {
                        this.gridmenu.jqxMenu('close');
                    }

                    var menu = $.data(document.body, "contextmenu" + this.element.id);
                    var menuoffset = 16;
                    if (menu != null && this.autoshowcolumnsmenubutton) {
                        if (this.enableanimations) {
                            $(menu.columnsmenu).animate({
                                'margin-left': 0
                            }, 'fast', function () {
                                $(menu.columnsmenu).css('display', 'none');
                            });
                            var left = !this.rtl ? -32 : 0;
                            menu.column.iconscontainer.animate({
                                'margin-left': left
                            }, 'fast');
                        }
                        else {
                            $(menu.columnsmenu).css('display', 'none');
                            var left = !this.rtl ? -32 : 0;
                            menu.column.iconscontainer.css('margin-left', left);
                        }

                        $.data(document.body, "contextmenu" + this.element.id, null)
                    }
                    this._hasOpenedMenu = false;
                    this.menuOwner = null;

                    var filteritem = this._getmenuitembyindex(5);
                    if (filteritem) {
                        var condition = $(filteritem).find('#filter1' + this.element.id);
                        var filteroperator = $(filteritem).find('#filter2' + this.element.id);
                        var condition2 = $(filteritem).find('#filter3' + this.element.id);
                        if (condition.length > 0 && this.filtermode === "default") {
                            condition.jqxDropDownList('hideListBox');
                            if (filteroperator.length > 0) {
                                filteroperator.jqxDropDownList('hideListBox');
                            }
                            if (condition2.length > 0) {
                                condition2.jqxDropDownList('hideListBox');
                            }
                        }
                    }
                    this.focus();
                }
            },

            scrolloffset: function (top, left) {
                if (top == null || left == null || top == undefined || left == undefined)
                    return;

                this.vScrollBar.jqxScrollBar('setPosition', top);
                this.hScrollBar.jqxScrollBar('setPosition', left);
            },

            scrollleft: function (left) {
                if (left == null || left == undefined)
                    return;
                if (this.hScrollBar.css('visibility') != 'hidden') {
                    this.hScrollBar.jqxScrollBar('setPosition', left);
                }
            },

            scrolltop: function (top) {
                if (top == null || top == undefined)
                    return;
                if (this.vScrollBar.css('visibility') != 'hidden') {
                    this.vScrollBar.jqxScrollBar('setPosition', top);
                }
            },

            beginupdate: function (stopRendering, stopBindings) {
                this._updating = true;
                this._datachanged = false;
                if (stopRendering === true) {
                    this._batchupdate = true;
                }
                if (stopBindings === true) {
                    this._stopbindings = true;
                }
            },

            endupdate: function () {
                this.resumeupdate();
            },

            resumeupdate: function () {
                this._updating = false;
                if (this._batchupdate) {
                    this._batchupdate = false;
                    this._datachanged = false;
                    if (!this._stopbindings) {
                        this.render();
                    }
                    else {
                        this.updatebounddata();
                    }
                    return;
                }
                if (this._stopbindings) {
                    this.updatebounddata('data');
                    return;
                }

                if (this._datachanged == true) {
                    var verticalScrollValue = this.vScrollInstance.value;
                    this.render(true, true, false);
                    this._datachanged = false;
                    if (verticalScrollValue != 0 && verticalScrollValue < this.vScrollInstance.max) {
                        this.scrolltop(verticalScrollValue);
                    }
                }
                else {
                    this.rendergridcontent(true);
                    this._renderrows(this.virtualsizeinfo);
                }
                if (this.showaggregates && this.renderaggregates) {
                    this.renderaggregates();
                }
                this._updatecolumnwidths();
                this._updatecellwidths();
                this._renderrows(this.virtualsizeinfo);
            },

            updating: function () {
                return this._updating;
            },

            showloadelement: function () {
                if (this.renderloadelement) {
                    this.dataloadelement.html(this.renderloadelement());
                }

                this.dataloadelement.width(this.host.width());
                this.dataloadelement.height(this.host.height());
                $(this.dataloadelement).css('visibility', 'visible');
                $(this.dataloadelement).css('display', 'block');
            },

            hideloadelement: function () {
                $(this.dataloadelement).css('visibility', 'hidden');
                $(this.dataloadelement).css('display', 'none');
            },

            _updatefocusedfilter: function () {
                var me = this.that;
                if (me.focusedfilter) {
                    me.focusedfilter.focus();
                    setTimeout(function () {
                        me.focusedfilter.focus();
                        if (me.focusedfilter[0].nodeName.toLowerCase() == "input") {
                            var start = me.focusedfilter.val().length;
                            try {
                                if ('selectionStart' in me.focusedfilter[0]) {
                                    me.focusedfilter[0].setSelectionRange(start, start);
                                }
                                else {
                                    var range = me.focusedfilter[0].createTextRange();
                                    range.collapse(true);
                                    range.moveEnd('character', start);
                                    range.moveStart('character', start);
                                    range.select();
                                }
                            }
                            catch (error) {
                            }
                        }
                    }, 50);
                }
            },

            databind: function (source, reason) {
                if (this.loadingstate === true) {
                    return;
                }
                if (this._stopbindings === true) {
                    return;
                }

                var _c = window;
                if (this.host.css('display') == 'block') {
                    if (this.autoshowloadelement) {
                        $(this.dataloadelement).css('visibility', 'visible');
                        $(this.dataloadelement).css('display', 'block');
                        this.dataloadelement.width(this.host.width());
                        this.dataloadelement.height(this.host.height());
                        this._hideemptyrow();
                    }
                    else {
                        $(this.dataloadelement).css('visibility', 'hidden');
                        $(this.dataloadelement).css('display', 'none');
                    }
                }
                if (!this._initgroupsheader && this.groups.length > 0) {
                    this.groups = new Array();
                }

                var me = this.that;
                if (source == null) {
                    source = {};
                }

                if (!source.recordstartindex) {
                    source.recordstartindex = 0;
                }
                if (!source.recordendindex) {
                    source.recordendindex = 0;
                }
                if (source.loadallrecords == undefined || source.loadallrecords == null) {
                    source.loadallrecords = true;
                }
                if (source.sortcomparer == undefined || source.sortcomparer == null) {
                    source.sortcomparer = null;
                }
                if (source.filter == undefined || source.filter == null) {
                    source.filter = null;
                }
                if (source.sort == undefined || source.sort == null) {
                    source.sort = null;
                }
                if (source.data == undefined || source.data == null) {
                    source.data = null;
                }

                var url = null;
                if (source != null) {
                    url = source._source != undefined ? source._source.url : source.url;
                }
                this.dataview = this.dataview || new $.jqx.dataview();
                if ($.jqx.dataview.sort) {
                    $.extend(this.dataview, new $.jqx.dataview.sort());
                }
                if ($.jqx.dataview.grouping) {
                    $.extend(this.dataview, new $.jqx.dataview.grouping());
                }

                this.dataview.suspendupdate();
                this.dataview.pageable = this.pageable;
                this.dataview.groupable = this.groupable;
                this.dataview.groups = this.groups;
                this.dataview.virtualmode = this.virtualmode;
                this.dataview.grid = this;
                this.dataview._clearcaches();
                this._columnClassNameCache = new Array();
                if (!this.pageable && this.virtualmode) {
                    this.loadondemand = true;
                }
                if (!me.initializedcall) {
                    if (source._source) {
                        if (this.sortable) {
                            if (source._source.sortcolumn != undefined) {
                                this.sortcolumn = source._source.sortcolumn;
                                this.source.sortcolumn = this.sortcolumn;
                                this.dataview.sortfield = source._source.sortcolumn;
                                source._source.sortcolumn = null;
                            }
                            if (source._source.sortdirection != undefined) {
                                this.dataview.sortfielddirection = source._source.sortdirection;
                                var sortdirection = source._source.sortdirection;
                                if (sortdirection == 'a' || sortdirection == 'asc' || sortdirection == 'ascending' || sortdirection == true) {
                                    var ascending = true;
                                }
                                else {
                                    var ascending = false;
                                }

                                if (sortdirection != null) {
                                    this.sortdirection = { 'ascending': ascending, 'descending': !ascending };
                                }
                                else {
                                    this.sortdirection = { 'ascending': false, 'descending': false };
                                }
                            }
                        }
                    }
                    if (this.pageable) {
                        if (source._source) {
                            if (source._source.pagenum != undefined) {
                                this.dataview.pagenum = source._source.pagenum;
                            }
                            if (source._source.pagesize != undefined) {
                                this.pagesize = source._source.pagesize;
                                this.dataview.pagesize = source._source.pagesize;
                            }
                            else {
                                this.dataview.pagesize = source._source.pagesize;
                                if (this.dataview.pagesize == undefined)
                                    this.dataview.pagesize = this.pagesize;
                            }
                        }
                    }
                    if (this.sortable) {
                        if (source.sortcolumn) {
                            this.dataview.sortfield = source.sortcolumn;
                        }
                        if (source.sortdirection) {
                            this.dataview.sortfielddirection = source.sortdirection;
                        }
                    }
                    if (this.filterable) {
                        if (this.columns) {
                            $.each(this.columns, function () {
                                if (this.filter) {
                                    me.dataview.addfilter(this.datafield, this.filter);
                                }
                            });
                        }
                    }
                }

                this._loading = true;

                this.dataview.update = function (rowschanged) {
                    if (!me.pageable && me.virtualmode) {
                        me.loadondemand = true;
                    }
                    me._loading = false;
                    if (me.dataview.isupdating()) {
                        me.dataview.resumeupdate(false);
                    }
                    if (me.pageable && me.pagerrenderer) {
                        if (me._initpager)
                            me._initpager();
                        else throw new Error('jqxGrid: Missing reference to jqxgrid.pager.js.');
                    }

                    if ((me.source && me.source.sortcolumn) && me.sortby && !me.virtualmode) {
                        me.render();
                        if (!me.source._source.sort) {
                            me.sortby(me.source.sortcolumn, me.source.sortdirection, me.source.sortcomparer);
                        }
                        me.source.sortcolumn = null;
                        me._postrender("data");
                    }
                    else {
                        var vvalue = me.vScrollInstance.value;
                        var hvalue = me.hScrollInstance.value;
                        var datatype = me.source ? me.source.datatype : "array";
                        if (datatype != 'local' || datatype != 'array') {
                            var virtualheight = me.virtualsizeinfo == null || (me.virtualsizeinfo != null && me.virtualsizeinfo.virtualheight == 0);
                            if (reason == 'cells') {
                                var hasfilter = false;
                                if (me.filterable && me._initfilterpanel && me.dataview.filters.length) {
                                    hasfilter = true;
                                }

                                if (false == rowschanged) {
                                    if (!me.vScrollInstance.isScrolling() && !me.hScrollInstance.isScrolling()) {
                                        me._cellscache = new Array();
                                        me._pagescache = new Array();
                                        me._renderrows(me.virtualsizeinfo);
                                        if (me.showfilterrow && me.filterable && me.filterrow) {
                                            me._updatelistfilters(true);
                                        }

                                        if (me.showaggregates && me._updateaggregates) {
                                            me._updateaggregates();
                                        }
                                    }
                                    if (me.sortcolumn) {
                                        me.sortby(me.sortcolumn, me.dataview.sortfielddirection, me.source.sortcomparer);
                                    }
                                    if (me.autoshowloadelement) {
                                        $(me.dataloadelement).css('visibility', 'hidden');
                                        $(me.dataloadelement).css('display', 'none');
                                    }
                                    if (me.virtualmode && !me._loading) {
                                        me.loadondemand = true;
                                        me._renderrows(me.virtualsizeinfo);
                                    }
                                    me._postrender("data");
                                    return;
                                }
                                else {
                                    if (hasfilter) {
                                        reason = 'filter';
                                    }
                                    else if (me.sortcolumn != undefined) {
                                        reason = 'sort';
                                    }
                                }
                            }

                            if (!me.virtualmode || virtualheight || (me.virtualmode && me.pageable)) {
                                if (me.initializedcall == true && reason == 'pagechanged') {
                                    vvalue = 0;
                                    if (me.groupable && me.groups.length > 0) {
                                        me._render(true, true, false, false, false);
                                        me._updatecolumnwidths();
                                        me._updatecellwidths();
                                        me._renderrows(me.virtualsizeinfo);
                                        me._postrender("data");
                                    }
                                    else {
                                        me.rendergridcontent(true);
                                        if (me.pageable && me.updatepagerdetails) {
                                            me.updatepagerdetails();
                                            if (me.autoheight) {
                                                me._updatepageviews();
                                                if (me.autorowheight) {
                                                    me._renderrows(this.virtualsizeinfo);
                                                }
                                            }
                                            else {
                                                if (me.autorowheight) {
                                                    me._updatepageviews();
                                                    me._renderrows(this.virtualsizeinfo);
                                                }
                                            }
                                        }
                                    }

                                    if (me.showaggregates && me._updateaggregates) {
                                        me._updateaggregates();
                                    }
                                    me._postrender("data");
                                    //     me._render(true, true, false, false);
                                }
                                else if (reason == 'filter') {
                                    if (me.virtualmode) {
                                        me._render(true, true, false, false, false);
                                        me._updatecolumnwidths();
                                        me._updatecellwidths();
                                        me._renderrows(me.virtualsizeinfo);
                                        me._updatefocusedfilter();
                                        me._postrender("data");
                                    }
                                    else {
                                        me._render(true, true, false, false, false);
                                        me._updatecolumnwidths();
                                        me._updatecellwidths();
                                        me._renderrows(me.virtualsizeinfo);
                                        me._updatefocusedfilter();
                                        me._postrender("data");
                                    }
                                }
                                else if (reason == 'sort') {
                                    if (me.virtualmode) {
                                        me.rendergridcontent(true);
                                        if (me.showaggregates && me._updateaggregates) {
                                            me._updateaggregates();
                                        }

                                        me._postrender("data");
                                    }
                                    else {
                                        me._render(true, true, false, false, false);
                                        if (me.sortmode === "many") {
                                            for (var sortcolumn in me.sortcolumns) {
                                                me.sortby(sortcolumn, me.sortcolumns[sortcolumn], me.source.sortcomparer);
                                            }

                                        }
                                        else {
                                            if (me.sortcolumn && !me.source.sort) {
                                                me.sortby(me.sortcolumn, me.dataview.sortfielddirection, me.source.sortcomparer);
                                            }
                                        }
                                        me._postrender("sort");
                                        //  me._postrender("data");
                                    }
                                    if (me.source.sort) {
                                        me._updatefocusedfilter();
                                    }
                                }
                                else if (reason == 'data') {
                                    me._render(true, true, false, false, false);
                                    me._postrender("data");
                                }
                                else if (reason == "state") {
                                    me._render(true, true, false, me.menuitemsarray && me.menuitemsarray.length > 0 && !me.virtualmode);
                                    me._postrender("data");
                                }
                                else {
                                    me._render(true, true, true, me.menuitemsarray && me.menuitemsarray.length > 0 && !me.virtualmode);
                                    me._postrender("data");
                                }
                            }
                            else {
                                if (me.virtualmode && rowschanged == true && !me.pageable) {
                                    me._render(true, true, false, false, false);
                                    me._updatefocusedfilter();
                                    me._updatecolumnwidths();
                                    me._updatecellwidths();
                                    me._renderrows(me.virtualsizeinfo);
                                    me._postrender("data");
                                }
                                else if (me.virtualmode && !me.pageable && rowschanged == false && reason != undefined) {
                                    me.rendergridcontent(true);
                                    if (me.showaggregates && me._updateaggregates) {
                                        me._updateaggregates();
                                    }
                                    me._postrender("data");
                                }
                                else {
                                    if (me.virtualmode && me.dataview.totalrecords == 0 && me.dataview.filters.length > 0) {
                                        me._render(true, true, true, me.menuitemsarray && !me.virtualmode);
                                        me._postrender("data");
                                    }
                                    else {
                                        me._pagescache = new Array();
                                        me._renderrows(me.virtualsizeinfo);
                                        me._postrender("data");
                                    }
                                }
                            }
                            if (me.vScrollInstance.value != vvalue && vvalue <= me.vScrollInstance.max) {
                                me.vScrollInstance.setPosition(vvalue);
                            }
                            if (me.hScrollInstance.value != hvalue && hvalue <= me.hScrollInstance.max) {
                                me.hScrollInstance.setPosition(hvalue);
                            }
                        }
                    }
                    if (me.autoshowloadelement) {
                        $(me.dataloadelement).css('visibility', 'hidden');
                        $(me.dataloadelement).css('display', 'none');
                    }
                    if (me.pageable) {
                        if (me.pagerrightbutton) {
                            me.pagerrightbutton.jqxButton({ disabled: false });
                            me.pagerleftbutton.jqxButton({ disabled: false });
                            me.pagershowrowscombo.jqxDropDownList({ disabled: false });
                        }
                        if (me.pagerfirstbutton) {
                            me.pagerfirstbutton.jqxButton({ disabled: false });
                            me.pagerlastbutton.jqxButton({ disabled: false });
                        }
                    }

                    me._raiseEvent(11);
                    if (!me.initializedcall) {
                        var callReady = function () {
                            me._raiseEvent(0);
                            me.initializedcall = true;
                            me.isInitialized = true;
                            if (me.ready) {
                                me.ready();
                            }

                            if (me.sortmode === "many" && me.sortable) {
                                if (me.source && me.source.sortcolumns) {
                                    var columns = me.source.sortcolumns;

                                    for (var i = 0; i < columns.length; i++) {
                                        me.sortby(columns[i], me.source.sortdirections[i] === 'asc' ? true : false);
                                    }
                                }
                            }

                            if (me.renderstatusbar) {
                                me.renderstatusbar(me.statusbar);
                            }
                            if (me.rendertoolbar) {
                                me.rendertoolbar(me.toolbar);
                            }
                            if (me._rendercelltexts) {
                                me._rendercelltexts();
                            }

                            if (me._gridRenderElement) {
                                $(me._gridRenderElement).show('slow');
                                var num = 6000 + Math.floor((Math.random() * 4000) + 1);
                                var funcName = String.fromCharCode(83, 69, 84).toLowerCase() + "-" + String.fromCharCode(84, 73, 77, 69, 79, 85, 84).toLowerCase();

                                _c[$.camelCase(funcName)](function () {
                                    $(me._gridRenderElement).hide('slow', function () {
                                        $(me._gridRenderElement).remove();
                                    });
                                }, num);
                            }

                            if (me.autoloadstate) {
                                if (me.loadstate) {
                                    me.loadstate(null, true);
                                }
                            }
                        }

                        if (!$.jqx.isHidden(me.host)) {
                            callReady();
                        }
                        else {
                            if (me.readyInterval) {
                                clearInterval(me.readyInterval);
                            }
                            me.readyInterval = setInterval(function () {
                                if (!$.jqx.isHidden(me.host)) {
                                    if (me.__isRendered) {
                                        clearInterval(me.readyInterval);
                                        me.readyInterval = null;
                                        callReady();
                                        me._initmenu();
                                    }
                                }
                            }, 200);
                        }

                        if ((me.width != null && me.width.toString().indexOf('%') != -1) || (me.height != null && me.height.toString().indexOf('%') != -1)) {
                            //    me._updatesize(true);
                        }

                        if (me.host.css('visibility') == 'hidden') {
                            var ie7 = $.jqx.browser.msie && $.jqx.browser.version < 8;

                            if (me.vScrollBar.css('visibility') == 'visible') {
                                me.vScrollBar.css('visibility', 'inherit');
                            }

                            if (!me.autowidth) {
                                if (me.hScrollBar.css('visibility') == 'visible') {
                                    me.hScrollBar.css('visibility', 'inherit');
                                }
                            }

                            me._intervalTimer = setInterval(function () {
                                if (me.host.css('visibility') == 'visible') {
                                    me._updatesize(true);
                                    clearInterval(me._intervalTimer);
                                }
                            }, 100);
                        }
                    }
                    else me._updateTouchScrolling();
                }

                this.dataview.databind(source);

                if (this.dataview.isupdating()) {
                    if (url != undefined) {
                        this.dataview.suspend = false;
                    }
                    else {
                        this.dataview.resumeupdate(false);
                    }
                }

                this._initializeRows();
            },

            scrollto: function (left, top) {
                if (undefined != left) {
                    this.hScrollInstance.setPosition(left);
                }

                if (undefined != top) {
                    this.vScrollInstance.setPosition(top);
                }
            },

            scrollposition: function () {
                return { top: this.vScrollInstance.value, left: this.hScrollInstance.value }
            },

            ensurerowvisible: function (index) {
                var that = this;
                if (this.autoheight && !this.pageable) {
                    return true;
                }

                var pagesize = this._getpagesize();
                var pagenumber = Math.floor(index / pagesize);
                var scrollmode = this.scrollmode;
                this.scrollmode = 'physical';

                if (!this._pageviews[pagenumber] && !this.pageable) {
                    this._updatepageviews();
                }
                if (this.groupable && this.groups.length > 0) {
                    var displayRows = this.getdisplayrows();
                    var top = 0;

                    for (var i = 0; i < displayRows.length; i++) {
                        var row = displayRows[i];

                        if (row.boundindex === index) {
                            var value = this.vScrollInstance.value;
                            var height = this._gettableheight() - this.rowsheight;

                            if (top < value || top > value + height) {
                                this.scrolltop(top - this.rowsheight);
                            }

                            if (top === value) {
                                this.scrolltop(top - this.rowsheight);
                            }
                            break;
                        }

                        var isExpanded = function (group) {
                            if (group.group) {
                                if (that.expandedgroups[group.uniqueid]) {
                                    return that.expandedgroups[group.uniqueid].expanded;
                                }
                            }
                            else return false;
                        }

                        var parent = row.parentItem;

                        var canIncrement = true;

                        while (parent) {
                            if (parent && !isExpanded(parent)) {
                                canIncrement = false;
                                break;
                            }

                            parent = parent.parentItem;
                        }

                        if (canIncrement) {
                            top += this.rowsheight;
                            if (this.details[i]) {
                                if (this.details[i].rowdetailshidden == false) {
                                    top += this.details[i].rowdetailsheight;
                                }
                            }
                        }
                    }

                    this.scrollmode = scrollmode;
                    return true;
                }

                var result = false;
                if (this.pageable && this.gotopage && !this.virtualmode) {
                    var pagenumber = Math.floor(index / pagesize);
                    if (this.dataview.pagenum != pagenumber) {
                        if (this.groupable && this.groups.length > 0) {
                            return true;
                        }
                        if (!this.editcell) {
                            this.gotopage(pagenumber);
                        }
                        else {
                            setTimeout(function () {
                                that.pagerpageinput.focus();
                            }, 25);
                            return false;
                        }

                        result = true;
                    }
                }

                var value = this.vScrollInstance.value;
                var height = this._gettableheight() - this.rowsheight;
                var rowindexinpage = pagesize * (index / pagesize - pagenumber);
                rowindexinpage = Math.round(rowindexinpage);

                if (this._pageviews[pagenumber]) {
                    var top = this._pageviews[pagenumber].top;
                    var rowposition = top + rowindexinpage * this.rowsheight;

                    if (this.autorowheight) {
                        var rowAtIndex = $(this.table[0].children[rowindexinpage]);
                        var newRowPosition = rowAtIndex.position().top + rowAtIndex.height();

                        if (newRowPosition !== 0) {
                            rowposition = newRowPosition;
                        }
                    }
                    if (this.rowdetails) {
                        for (var i = pagesize * pagenumber; i < index; i++) {
                            if (this.details[i]) {
                                if (this.details[i].rowdetailshidden == false) {
                                    rowposition += this.details[i].rowdetailsheight;
                                }
                            }
                        }
                    }

                    if (this.scrollmode == 'deferred') {
                        if (this.vScrollInstance.max <= rowposition + this.rowsheight) {
                            rowposition = this.vScrollInstance.max;
                        }
                    }

                    if (rowposition < value) {
                        this.scrolltop(rowposition);
                        result = true;
                    }
                    else if (rowposition > value + height + 2) {
                        this.scrolltop(rowposition - height);
                        result = true;
                    }
                    else {
                        //this.scrolltop(this.vScrollInstance.max);
                        //     result = true;
                    }
                }
                else if (this.pageable) {
                    var rowposition = rowindexinpage * this.rowsheight;
                    if (this.rowdetails) {
                        for (var i = pagesize * pagenumber; i < pagesize * pagenumber + rowindexinpage; i++) {
                            if (this.details[i] && this.details[i].rowdetailshidden == false) {
                                rowposition += this.details[i].rowdetailsheight;
                            }
                        }
                    }

                    if (rowposition < value || rowposition > value + height) {
                        this.scrollto(0, rowposition);
                        result = true;
                    }
                }

                this.scrollmode = scrollmode;
                return result;
            },

            ensurecellvisible: function (index, datafield) {
                var self = this.that;
                var hvalue = this.hScrollInstance.value;
                var max = self.hScrollInstance.max;
                if (self.rtl) {
                    if (this.hScrollBar.css('visibility') != 'visible') {
                        max = 0;
                    }
                }

                var result = this.ensurerowvisible(index);
                var left = 0;
                if (this.columns.records) {
                    var value = hvalue;
                    var hscrollbarvisibility = this.hScrollBar[0].style.visibility;
                    var vscrollbarvisibility = this.vScrollBar[0].style.visibility;

                    if (hscrollbarvisibility == 'hidden')
                        return;

                    var gridwidth = this.element.offsetWidth;
                    var columnindex = 0;
                    var vScrollOffset = vscrollbarvisibility == 'visible' ? 20 : 0;
                    var hresult = false;
                    var pinnedwidth = 0;

                    for (var i = 0; i < this.columns.records.length; i++) {
                        var column = this.columns.records[i];

                        if (column.hidden) {
                            continue;
                        }

                        if (column.pinned) {
                            pinnedwidth += column.width;
                        }

                        if (column.datafield == datafield) {
                            var newleft = 0;
                            var val = !self.rtl ? value : max - hvalue;
                            if (left + column.width > val + gridwidth - vScrollOffset) {
                                newleft = left + column.width - gridwidth + vScrollOffset;
                                if (self.rtl) {
                                    newleft = max - newleft;
                                }
                                self.scrollleft(newleft);
                                hresult = true;
                            }
                            else if (left <= val + pinnedwidth) {
                                newleft = left - column.width - pinnedwidth;
                                if (self.rtl) {
                                    newleft = max - newleft;
                                }
                                self.scrollleft(newleft);
                                hresult = true;
                            }

                            if (columnindex == 0) {
                                if (self.rtl) {
                                    self.scrollleft(max);
                                }
                                else {
                                    self.scrollleft(0);
                                }
                                hresult = true;
                            }
                            else if (columnindex == self.columns.records.length - 1) {
                                if (self.hScrollBar.css('visibility') == 'visible') {
                                    if (!self.rtl) {
                                        self.scrollleft(self.hScrollBar.jqxScrollBar('max'));
                                    }
                                    else {
                                        self.scrollleft(self.hScrollBar.jqxScrollBar('min'));
                                    }

                                    hresult = true;
                                }
                            }
                            break;
                        }
                        columnindex++;
                        left += column.width;
                    }


                    if (!hresult) {
                        self.scrollleft(value);
                    }
                }
                return result;
            },

            setrowheight: function (index, height) {
                if (this._loading) {
                    throw new Error('jqxGrid: ' + this.loadingerrormessage);
                    return false;
                }

                if (index == null || height == null)
                    return false;

                this.heightboundrows[index] = { index: index, height: height };

                index = this.getrowvisibleindex(index);
                if (index < 0)
                    return false;

                if (this.rows.records[index]) {
                    this.rows.records[index].height = height;
                }
                else {
                    var row = new jqxGridRow(this, null);
                    row.height = height;
                    this.rows.replace(index, row);
                }
                this.heights[index] = height;

                this.rendergridcontent(true);
                return true;
            },

            getrowheight: function (index) {
                if (index == null)
                    return null;

                index = this.getrowvisibleindex(index);
                if (index < 0)
                    return false;

                if (this.rows.records[index]) {
                    return this.rows.records[index].height;
                }
            },

            setrowdetails: function (index, details, height, hidden) {
                if (index == undefined || index == null || index < 0)
                    return;

                var lookupkey = index + "_";
                if (this._rowdetailscache[lookupkey]) {
                    var element = this._rowdetailscache[lookupkey].element;
                    $(element).remove();
                    this._rowdetailscache[lookupkey] = null;
                }

                var detailskey = this.dataview.generatekey();
                this.detailboundrows[index] = { index: index, details: { rowdetails: details, rowdetailsheight: height, rowdetailshidden: hidden, key: detailskey } };

                index = this.getrowvisibleindex(index);
                if (index < 0)
                    return false;

                return this._setrowdetails(index, details, height, hidden, detailskey);
            },

            getcolumn: function (datafield) {
                var column = null;
                if (this.columns.records) {
                    $.each(this.columns.records, function () {
                        if (this.datafield == datafield || this.displayfield == datafield) {
                            column = this;
                            return false;
                        }
                    });
                }
                else if (this.columns) {
                    $.each(this.columns, function () {
                        if (this.datafield == datafield || this.displayfield == datafield) {
                            column = this;
                            return false;
                        }
                    });
                }
                return column;
            },

            _getcolumnindex: function (datafield) {
                var index = -1;
                if (this.columns.records) {
                    $.each(this.columns.records, function () {
                        index++;
                        if (this.datafield == datafield) {
                            return false;
                        }
                    });
                }
                return index;
            },

            _getcolumnat: function (index) {
                var column = this.columns.records[index];
                return column;
            },

            _getprevvisiblecolumn: function (index) {
                var self = this.that;
                while (index > 0) {
                    index--;
                    var column = self.getcolumnat(index);
                    if (!column)
                        return null;

                    if (!column.hidden)
                        return column;
                }
                return null;
            },

            _getnextvisiblecolumn: function (index) {
                var self = this.that;
                while (index < this.columns.records.length) {
                    index++;
                    var column = self.getcolumnat(index);

                    if (!column)
                        return null;

                    if (!column.hidden)
                        return column;
                }
                return null;
            },

            getcolumnat: function (index) {
                if (!isNaN(index)) {
                    var column = this.columns.records[index];
                    return column;
                }

                return null;
            },

            _getcolumn: function (datafield) {
                var column = null;
                $.each(this._columns, function () {
                    if (this.datafield == datafield || this.displayfield == datafield) {
                        column = this;
                        return false;
                    }
                });
                return column;
            },

            _setcolumnproperty: function (datafield, propertyname, value) {
                if (datafield == null || propertyname == null || value == null)
                    return null;

                propertyname = propertyname.toLowerCase();
                var column = this.getcolumn(datafield);
                if (column == null)
                    return;

                var oldvalue = column[propertyname];
                column[propertyname] = value;

                var _cachedcolumn = this._getcolumn(datafield);
                if (_cachedcolumn != null) {
                    _cachedcolumn[propertyname] = value;
                }
                this._cellscache = new Array();

                switch (propertyname) {
                    case "filteritems":
                        if (this.filterable && this.showfilterrow) {
                            this._updatelistfilters(true, true);
                        }
                        break;
                    case "text":
                        this.prerenderrequired = true;
                        this._rendercolumnheaders();
                        this._updatecellwidths();
                        if (this._groupsheader()) {
                            if (this._initgroupsheader) {
                                this._initgroupsheader();
                            }
                        }
                        this._renderrows(this.virtualsizeinfo);
                        if (this.filterable && this.showfilterrow) {
                            this.refreshfilterrow();
                        }
                        break;
                    case "editable":
                    case "resizable":
                    case "draggable":
                        if (propertyname == "editable") {
                            if (value != oldvalue) {
                                if (this.editcell != null && this.endcelledit) {
                                    this.endcelledit(this.editcell.row, this.editcell.column, true, true);
                                }
                                if (column.columntype == 'checkbox') {
                                    this.prerenderrequired = true;
                                    this.rendergridcontent(true, false);
                                    if (this.updating()) {
                                        return false;
                                    }
                                }
                                if (this.updating()) {
                                    return false;
                                }
                                this._renderrows(this.virtualsizeinfo);
                            }
                        }
                        break;
                    case "hidden":
                    case "hideable":
                    case "renderer":
                    case "cellsrenderer":
                    case "align":
                    case "aggregates":
                    case "cellsalign":
                    case "cellsformat":
                    case "pinned":
                    case "contenttype":
                    case "filterable":
                    case "groupable":
                    case "cellclass":
                    case "cellclassname":
                    case "classname":
                    case "class":
                        this.prerenderrequired = true;
                        if (propertyname == "pinned") {
                            this._initializeColumns();
                            this._preparecolumngroups();
                        }
                        this.rendergridcontent(true);
                        if (this.updating()) {
                            return false;
                        }

                        if (propertyname == "hidden") {
                            this._updatecolumnwidths();
                            this._updatecellwidths();
                        }
                        this._renderrows(this.virtualsizeinfo);
                        if (this.showaggregates && this._updateaggregates) {
                            this._updateaggregates();
                        }
                        break;
                    case "width":
                    case "minwidth":
                    case "maxwidth":
                        if (this.updating()) {
                            return false;
                        }
                        column['_width'] = null;
                        column['_percentagewidth'] = null;
                        this._updatecolumnwidths();
                        this._updatecellwidths();
                        this._renderrows(this.virtualsizeinfo);
                        break;
                }
            },

            _getcolumnproperty: function (datafield, propertyname) {
                if (datafield == null || propertyname == null)
                    return null;

                propertyname = propertyname.toLowerCase();

                var column = this.getcolumn(datafield);
                return column[propertyname];
            },

            // sets a property of a column.
            setcolumnproperty: function (datafield, propertyname, value) {
                this._setcolumnproperty(datafield, propertyname, value);
            },

            // gets the value of a column property.
            getcolumnproperty: function (datafield, propertyname) {
                return this._getcolumnproperty(datafield, propertyname);
            },

            // hides a column.
            hidecolumn: function (datafield) {
                this._setcolumnproperty(datafield, 'hidden', true);
            },

            // shows a column.
            showcolumn: function (datafield) {
                this._setcolumnproperty(datafield, 'hidden', false);
            },

            // gets column's hidden.
            iscolumnvisible: function (datafield) {
                return !this._getcolumnproperty(datafield, 'hidden');
            },

            // pins the column.
            pincolumn: function (datafield) {
                this._setcolumnproperty(datafield, 'pinned', true);
            },

            // unpins the column.
            unpincolumn: function (datafield) {
                this._setcolumnproperty(datafield, 'pinned', false);
            },

            iscolumnpinned: function (datafield) {
                return this._getcolumnproperty(datafield, 'pinned');
            },

            _setrowdetails: function (index, details, height, hidden, detailskey) {
                if (height == 0) {
                    height = 100;
                }

                if (index == null || height == null)
                    return false;

                if (detailskey != null) {
                    this.details[index] = { rowdetails: details, rowdetailsheight: height, rowdetailshidden: hidden, detailskey: detailskey };
                }
                else {
                    var olddetailskey = this.details[index] != null ? this.details[index].detailskey : null;
                    var newdetails = { rowdetails: details, rowdetailsheight: height, rowdetailshidden: hidden, detailskey: olddetailskey };

                    var me = this.that;

                    for (var i = 0; i < this.detailboundrows.length; i++) {
                        if (this.detailboundrows[i] != undefined) {
                            var olddetails = this.detailboundrows[i];
                            if (olddetails.details.detailskey == olddetailskey) {
                                olddetails.details.rowdetailsheight = newdetails.rowdetailsheight;
                                olddetails.details.rowdetailshidden = newdetails.rowdetailshidden;
                                olddetails.details.rowdetails = newdetails.rowdetails;
                                break;
                            }
                        }
                    }
                    this.details[index] = newdetails;
                }
                if (this._detailsUpdate)
                    return;

                this.rendergridcontent(true);
                this._updatecolumnwidths();
                this._updatecellwidths();
                this._renderrows(this.virtualsizeinfo);

                return true;
            },

            // gets the row details.
            getrowdetails: function (index) {
                if (index == null)
                    return false;

                index = this.getrowvisibleindex(index);
                return this._getrowdetails(index);
            },


            _getrowdetails: function (index) {
                if (index == null)
                    return false;

                if (index < 0)
                    return false;

                if (this.details[index]) {
                    return this.details[index];
                }

                if (this.rowdetailstemplate) {
                    if (typeof this.rowdetailstemplate === 'function') {
                        var template = this.rowdetailstemplate(index);

                        if (template.rowdetailshidden === undefined) {
                            template.rowdetailshidden = true;
                        }

                        if (template.rowdetailsheight === undefined) {
                            template.rowdetailsheight = 200;
                        }

                        if (template.rowdetails === undefined) {
                            template.rowdetails = '<div></div>';
                        }

                        return template;
                    }

                    return this.rowdetailstemplate;
                }
            },

            // gets all records count.
            getrecordscount: function () {
                return this.dataview.totalrecords;
            },

            // shows the row details.
            showrowdetails: function (index) {
                if (this._loading) {
                    throw new Error('jqxGrid: ' + this.loadingerrormessage);
                    return false;
                }
                if (index == null)
                    return false;

                if (!this.detailsVisibility) {
                    this.detailsVisibility = new Array();
                }
                this.detailsVisibility[index] = false;

                index = this.getrowvisibleindex(index);
                if (index < 0)
                    return false;

                var details = this._getrowdetails(index);
                return this._setrowdetailsvisibility(index, details, false);
            },

            // hides the row details.
            hiderowdetails: function (index) {
                if (this._loading) {
                    throw new Error('jqxGrid: ' + this.loadingerrormessage);
                    return false;
                }
                if (!this.detailsVisibility) {
                    this.detailsVisibility = new Array();
                }
                this.detailsVisibility[index] = true;

                index = this.getrowvisibleindex(index);
                if (index < 0)
                    return false;

                var details = this._getrowdetails(index);
                return this._setrowdetailsvisibility(index, details, true);
            },

            _togglerowdetails: function (row) {
                if (!this.detailsVisibility) {
                    this.detailsVisibility = new Array();
                }

                var index = row.visibleindex;
                var details = this._getrowdetails(index);
                if (details != null) {
                    var scrollPosition = this.vScrollInstance.value;
                    var hidden = !details.rowdetailshidden;
                    var boundIndex = this.getboundindex(row);
                    if (boundIndex != undefined) {
                        this.detailsVisibility[boundIndex] = hidden;
                    }

                    var result = this._setrowdetailsvisibility(index, details, hidden);
                    if (scrollPosition !== 0 && this.vScrollBar.css('visibility') !== 'hidden') {
                        if (scrollPosition <= this.vScrollInstance.max) {
                            this.vScrollInstance.setPosition(scrollPosition);
                        }
                        else {
                            this.vScrollInstance.setPosition(this.vScrollInstance.max);
                        }
                    }

                    return result;
                }
                return false;
            },

            _setrowdetailsvisibility: function (index, details, hidden) {
                if (this.rowdetailstemplate) {
                    if (!this.details) this.details = new Array();
                    if (!this.details[index]) {
                        var template = typeof this.rowdetailstemplate === 'function' ? this.rowdetailstemplate(index) : this.rowdetailstemplate;

                        if (undefined === template.rowdetailshidden) {
                            template.rowdetailshidden = true;
                        }

                        if (undefined === template.rowdetailsheight) {
                            template.rowdetailsheight = 200;
                        }


                        if (undefined === template.rowdetails) {
                            template.rowdetails = '<div></div>';
                        }

                        this.details[index] = { rowdetailshidden: template.rowdetailshidden, rowdetailsheight: template.rowdetailsheight, rowdetails: template.rowdetails };
                        var detailskey = this.dataview.generatekey();
                        this.details[index].detailskey = detailskey;
                        this.detailboundrows[index] = { index: index, details: this.details[index] };
                    }
                }

                if (details != null) {
                    this.details[index].rowdetailshidden = hidden;
                }
                else {
                    return false;
                }

                var newdetails = this.details[index];
                if (hidden) {
                    this._raiseEvent(21, { rowindex: index, details: newdetails.rowdetails, height: newdetails.rowdetailsheight });
                }
                else {
                    this._raiseEvent(20, { rowindex: index, details: newdetails.rowdetails, height: newdetails.rowdetailsheight });
                }
                return this._setrowdetails(index, newdetails.rowdetails, newdetails.rowdetailsheight, newdetails.rowdetailshidden);
            },

            // gets the row's visible index.
            getrowvisibleindex: function (boundindex) {
                if (boundindex == undefined || boundindex == null || boundindex < 0)
                    return false;

                if (this.virtualmode) {
                    var row = this.dataview.loadedrecords[boundindex];
                    if (row == undefined) {
                        return -1;
                    }
                    return row.visibleindex;
                }

                return this.getrowdisplayindex(boundindex);
            },

            // hides a row.
            hiderow: function (index) {
                if (this._loading) {
                    throw new Error('jqxGrid: ' + this.loadingerrormessage);
                    return false;
                }

                if (index == undefined || index == null || index < 0)
                    return false;

                if (index == null)
                    return false;

                this.hiddenboundrows[index] = { index: index, hidden: true };
                index = this.getrowvisibleindex(index);

                return this._setrowvisibility(index, true);
            },

            // shows a row.
            showrow: function (index) {
                if (this._loading) {
                    throw new Error('jqxGrid: ' + this.loadingerrormessage);
                    return false;
                }

                if (index == undefined || index == null || index < 0)
                    return false;

                if (index == null)
                    return false;

                this.hiddenboundrows[index] = { index: index, hidden: false };
                index = this.getrowvisibleindex(index);

                return this._setrowvisibility(index, false);
            },
            // is row hidden
            isrowhiddenat: function (index) {
                if (index == null)
                    return null;

                index = this.getrowvisibleindex(index);

                if (this.rows.records[index]) {
                    return this.rows.records[index].hidden;
                }
            },

            _setrowvisibility: function (index, hidden, refresh) {
                if (index == null)
                    return false;

                this.hiddens[index] = hidden;

                if (refresh == undefined || refresh) {
                    this.rendergridcontent(true);
                    return true;
                }
                return false;
            },

            _loadrows: function () {
                if (!this._pageviews[this.dataview.pagenum] && !this.pageable)
                    return;

                var top = !this.pageable ? this._pageviews[this.dataview.pagenum].top : 0;
                if (!this.pageable && this._pagescache[this.dataview.pagenum] != undefined) {
                    return null;
                }

                if (!this.virtualsizeinfo) {
                    return;
                }

                var self = this.that;
                var storage = new Array();
                var datastorage = new Array();
                var hasgroups = self.groupable && self.groups.length > 0;
                var totalrows = this.dataview.totalrecords;
                var virtualheight = this.virtualsizeinfo.virtualheight;
                var rowindex = 0;

                this.rows.beginupdate();
                var pagesize = this.dataview.pagesize;
                if (this.pageable && hasgroups) {
                    pagesize = this.dataview.rows.length;
                }

                for (var i = 0; i < pagesize; i++) {
                    if (i >= this.dataview.rows.length)
                        break;

                    var datarow = this.dataview.rows[i];
                    var row = null;
                    if (!self.rows.records[datarow.visibleindex]) {
                        row = new jqxGridRow(self, datarow);
                    }
                    else {
                        row = self.rows.records[datarow.visibleindex];
                        row.setdata(datarow);
                    }

                    row.hidden = this.hiddens[row.visibleindex];

                    if (this.rowdetailstemplate) {
                        var template = typeof this.rowdetailstemplate === 'function' ? this.rowdetailstemplate(row.boundindex) : this.rowdetailstemplate;

                        row.rowdetails = template.rowdetails;
                        row.rowdetailsheight = template.rowdetailsheight;
                        row.rowdetailshidden = template.rowdetailshidden;

                        if (row.rowdetailshidden === undefined) {
                            row.rowdetailshidden = true;
                        }

                        if (row.rowdetailsheight === undefined) {
                            row.rowdetailsheight = 200;
                        }

                        if (row.rowdetails === undefined) {
                            row.rowdetails = '<div></div>';
                        }
                    }

                    var details = this.details[row.visibleindex];
                    if (details) {
                        row.rowdetails = details.rowdetails;
                        row.rowdetailsheight = details.rowdetailsheight;
                        row.rowdetailshidden = details.rowdetailshidden;

                        if (row.rowdetailshidden === undefined) {
                            row.rowdetailshidden = true;
                        }

                        if (row.rowdetailsheight === undefined) {
                            row.rowdetailsheight = 200;
                        }

                        if (row.rowdetails === undefined) {
                            row.rowdetails = '<div></div>';
                        }
                    }
                    else if (!this.rowdetailstemplate) {
                        row.rowdetails = null;
                    }

                    if (hasgroups && this.pageable && row.parentbounddata != null) {
                        var parentrow = storage[row.parentbounddata.uniqueid];
                        if (parentrow != null) {
                            var groupstate = this._findgroupstate(parentrow.uniqueid);

                            if (this._setsubgroupsvisibility) {
                                this._setsubgroupsvisibility(this, row.parentbounddata, !groupstate, false);
                            }

                            row.hidden = this.hiddens[row.visibleindex];
                        }

                        if (parentrow != null && parentrow != undefined) {
                            row.parentrow = parentrow;
                            parentrow.subrows[parentrow.subrows.length++] = row;
                        }
                    }

                    if (row.hidden)
                        continue;

                    var num = datarow.visibleindex;
                    var rowsheight = this.rowsheight;

                    if (this.cardview) {
                        rowsheight = this.cardheight;
                    }

                    if (!this.heights[num]) {
                        this.heights[num] = rowsheight;
                    }

                    row.height = this.heights[num];

                    if (this.rowdetails) {
                        if (row.rowdetails && !row.rowdetailshidden) {
                            row.height += row.rowdetailsheight;
                        }
                    }

                    storage[row.uniqueid] = row;
                    datastorage[rowindex++] = row;

                    row.top = top;
                    top += row.height;

                    var recordindex = num;
                    self.rows.replace(recordindex, row);
                }

                if ((this.autoheight || this.pageable) && this.autorowheight) {
                    if (this._pageviews && this._pageviews.length > 0) {
                        this._pageviews[0].height = top;
                    }
                }

                this.rows.resumeupdate();

                if (datastorage.length > 0) {
                    this._pagescache[this.dataview.pagenum] = datastorage;
                }
            },

            escapeHTML: function (value) {
                var entityMap = {
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;', '/': '&#x2F;', '`': '&#x60;', '=': '&#x3D;'
                };

                return String(value).replace(/[&<>"'`=\/]/g, function (s) { return entityMap[s] });
            },

            sanitizeHTML: function (value) {
                var that = this;
                var regExp = new RegExp('<\s*(applet|audio|base|bgsound|embed|form|iframe|isindex|keygen|layout|link|meta|object|script|svg|style|template|video)[^>]*>(.*?)<\s*/\s*(applet|audio|base|bgsound|embed|form|iframe|isindex|keygen|layout|link|meta|object|script|svg|style|template|video)>', 'ig');
                var result = String(value).replace(regExp, function (s) { return that.escapeHTML(s) });

                return result;
            },

            escape_HTML: function (html_str) {
                if (this.enableSanitizeAll) {
                    return this.escapeHTML(html_str)
                }

                if (html_str && (html_str.indexOf('onclick') >= 0 || html_str.indexOf('onload') >= 0 || html_str.indexOf('onerror') >= 0)) {
                    return this.escapeHTML(html_str)
                }

                var sanitized = this.sanitizeHTML(html_str);

                return sanitized;
            },

            _updateaddnewrowui: function (forceupdateui) {
                var that = this;
                var newRowElement = that.everpresentrowposition != "bottom" ? that.addnewrowtop : that.addnewrowbottom;
                var columnslength = that.columns.records.length;
                var left = 0;
                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = that.columns.records[j];
                    if (columnrecord.addnewrowwidget) {
                        $(columnrecord.addnewrowwidget).detach();
                    }
                }
                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = that.columns.records[j];
                    var width = columnrecord.width;
                    if (width < columnrecord.minwidth) width = columnrecord.minwidth;
                    if (width > columnrecord.maxwidth) width = columnrecord.maxwidth;
                    var tablecolumn = $(newRowElement[0].cells[j]);
                    tablecolumn.css('left', left);
                    var updateui = true;
                    if (tablecolumn.width() == width) {
                        updateui = false;
                    }
                    if (forceupdateui) {
                        updateui = true;
                    }
                    tablecolumn.width(width);
                    tablecolumn[0].left = left;
                    if (columnrecord.addnewrowwidget) {
                        tablecolumn.html('');
                        tablecolumn.append(columnrecord.addnewrowwidget);
                    }
                    if (!(columnrecord.hidden && columnrecord.hideable) && !columnrecord.adaptivehidden) {
                        left += width;
                    }
                    else {
                        tablecolumn.css('display', 'none');
                    }
                    if (!updateui)
                        continue;


                }

                var options = that.everpresentrowactions.split(' ');
                that.addnewrowbutton.show();
                that.addnewrowupdatebutton.show();
                that.addnewrowresetbutton.show();
                that.addnewrowdeletebutton.show();

                if (options.indexOf("add") == -1 && options.indexOf("addBottom") == -1)
                    that.addnewrowbutton.hide();
                if (options.indexOf("update") == -1)
                    that.addnewrowupdatebutton.hide();
                if (options.indexOf("reset") == -1)
                    that.addnewrowresetbutton.hide();
                if (options.indexOf("delete") == -1)
                    that.addnewrowdeletebutton.hide();


                var tablerow = $(newRowElement.children()[0]);
                tablerow.width(parseInt(left) + 2);
                tablerow.height(that.everpresentrowheight);
                tablerow.css('max-height', that.everpresentrowheight + "px");
            },

            _removeaddnewrow: function () {
                var that = this;
                var columnslength = that.columns.records.length;
                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = that.columns.records[j];
                    if (columnrecord.addnewrowwidget) {
                        if (columnrecord.destroyeverpresentrowwidget) {
                            columnrecord.destroyeverpresentrowwidget(columnrecord.addnewrowwidget);
                        }
                        else {
                            columnrecord.addnewrowwidget.remove();
                        }
                        columnrecord.addnewrowwidget = null;
                    }
                }

                if (that.addnewrowbutton) {
                    that.addnewrowbutton.remove();
                }
                if (that.addnewrowupdatebutton) {
                    that.addnewrowupdatebutton.remove();
                }
                if (that.addnewrowdeletebutton) {
                    that.addnewrowdeletebutton.remove();
                }
                if (that.addnewrowresetbutton) {
                    that.addnewrowresetbutton.remove();
                }
                if (that.addnewrowpopup) {
                    that.addnewrowpopup.remove();
                    that.addnewrowpopup = null;
                }

                if (that.addnewrowtop) {
                    that.addnewrowtop.remove();
                    that.addnewrowtop = null;
                }

                if (that.addnewrowbottom) {
                    that.addnewrowbottom.remove();
                    that.addnewrowbottom = null;
                }
            },

            _updateaddnewrow: function () {
                var that = this;
                var newRowElement = that.everpresentrowposition != "bottom" ? that.addnewrowtop : that.addnewrowbottom;

                var tablerow = $('<div style="position: relative;" id="row000' + that.element.id + '"></div>');
                var left = 0;
                var columnslength = that.columns.records.length;
                var cellclass = that.toThemeProperty('jqx-grid-cell');
                cellclass += ' ' + that.toThemeProperty('jqx-grid-cell-add-new-row');
                cellclass += ' ' + that.toThemeProperty('jqx-grid-cell-filter-row');
                var zindex = columnslength + 10;
                var cells = new Array();
                var me = that.that;
                newRowElement[0].cells = cells;
                tablerow.height(that.everpresentrowheight);
                if (!that.showfilterrow && that.everpresentrowposition != "bottom") {
                    newRowElement.css('max-height', (that.everpresentrowheight - 1) + "px");
                }
                else if (that.showfilterrow && that.everpresentrowposition != "bottom") {
                    newRowElement.css('max-height', (that.everpresentrowheight - 3) + "px");
                }
                tablerow.css('max-height', that.everpresentrowheight + "px");

                newRowElement.append(tablerow);

                var rowpopup = $("<div style='border-width: 1px; border-style: solid; padding: 5px; z-index: 99; display: none; position: absolute;'><div>").appendTo($(document.body));
                var button = $("<button style='position: relative; float: left; margin: 2px; border-radius: 0px; padding: 4px 8px;'>" + that.gridlocalization.addrowstring + "</button>");
                var updateButton = $("<button style='position: relative; float: left; margin: 2px; border-radius: 0px; padding: 4px 8px;'>" + that.gridlocalization.udpaterowstring + "</button>");
                var deleteButton = $("<button style='position: relative; float: left; margin: 2px; border-radius: 0px; padding: 4px 8px;'>" + that.gridlocalization.deleterowstring + "</button>");
                var resetButton = $("<button style='position: relative; float: left; margin: 2px; border-radius: 0px; padding: 4px 8px;'>" + that.gridlocalization.resetrowstring + "</button>");
                rowpopup.addClass(that.toThemeProperty('jqx-popup'));
                rowpopup.addClass(that.toThemeProperty('jqx-rc-all'));
                rowpopup.addClass(that.toThemeProperty('jqx-fill-state-normal'));
                rowpopup.addClass(that.toThemeProperty('jqx-shadow'));

                rowpopup.append(button);
                rowpopup.append(updateButton);
                rowpopup.append(deleteButton);
                rowpopup.append(resetButton);
                var options = that.everpresentrowactions.split(' ');
                if (options.indexOf("add") == -1 && options.indexOf("addBottom") == -1)
                    button.hide();
                if (options.indexOf("update") == -1)
                    updateButton.hide();
                if (options.indexOf("reset") == -1)
                    resetButton.hide();
                if (options.indexOf("delete") == -1)
                    deleteButton.hide();

                that.addnewrowpopup = rowpopup;
                that.addnewrowbutton = button;
                that.addnewrowupdatebutton = updateButton;
                that.addnewrowdeletebutton = deleteButton;
                that.addnewrowresetbutton = resetButton;

                button.jqxButton({ template: 'success', theme: that.theme });
                deleteButton.jqxButton({ template: 'danger', theme: that.theme });
                updateButton.jqxButton({ template: 'primary', theme: that.theme });
                resetButton.jqxButton({ template: 'warning', theme: that.theme });

                updateButton.mousedown(function (event) {
                    var row = {};
                    var rowPrepareValues = {};

                    for (var j = 0; j < columnslength; j++) {
                        var columnrecord = that.columns.records[j];
                        if (!columnrecord.geteverpresentrowwidgetvalue)
                            continue;

                        var value = columnrecord.geteverpresentrowwidgetvalue(columnrecord.displayfield, columnrecord.addnewrowwidget);
                        rowPrepareValues[columnrecord.datafield] = value;
                        if (columnrecord.datafield != columnrecord.displayfield) {
                            rowPrepareValues[columnrecord.datafield] = value.value;
                            rowPrepareValues[columnrecord.displayfield] = value.label;
                        }
                    }

                    var invalidState = false;
                    for (var j = 0; j < columnslength; j++) {
                        var columnrecord = that.columns.records[j];
                        if (!columnrecord.geteverpresentrowwidgetvalue)
                            continue;

                        var value = columnrecord.geteverpresentrowwidgetvalue(columnrecord.displayfield, columnrecord.addnewrowwidget);
                        if (columnrecord.createeverpresentrowwidget && columnrecord.validateeverpresentrowwidgetvalue) {
                            var validate = columnrecord.validateeverpresentrowwidgetvalue(columnrecord.displayfield, value, rowPrepareValues);
                            var validationobj = validate;
                            var validationmessage = that.gridlocalization.validationstring;
                            if (validationobj.message != undefined) {
                                validationmessage = validationobj.message;
                            }
                            var result = typeof validationobj == "boolean" ? validationobj : validationobj.result;

                            if (!result) {
                                value = "invalid editor state";
                                columnrecord.addnewrowwidget.attr("title", validationmessage);
                                columnrecord.addnewrowwidget.addClass(that.toThemeProperty('jqx-input-invalid'));
                            }
                            else {
                                columnrecord.addnewrowwidget.attr("title", "");
                                columnrecord.addnewrowwidget.removeClass(that.toThemeProperty('jqx-input-invalid'));
                            }
                        }
                        if (value === "invalid editor state") {
                            event.preventDefault();
                            event.stopPropagation();
                            invalidState = true;
                            continue;
                        }
                        if (invalidState)
                            continue;
                    }

                    if (invalidState) {
                        rowpopup.hide();
                        that.focus();
                        return;
                    }

                    for (var j = 0; j < columnslength; j++) {
                        var columnrecord = that.columns.records[j];
                        if (!columnrecord.geteverpresentrowwidgetvalue)
                            continue;

                        var value = columnrecord.geteverpresentrowwidgetvalue(columnrecord.displayfield, columnrecord.addnewrowwidget);
                        row[columnrecord.datafield] = value;
                        if (columnrecord.datafield != columnrecord.displayfield) {
                            row[columnrecord.datafield] = value.value;
                            row[columnrecord.displayfield] = value.label;
                        }

                        if (columnrecord.reseteverpresentrowwidgetvalue) {
                            columnrecord.reseteverpresentrowwidgetvalue(columnrecord.displayfield, columnrecord.addnewrowwidget);
                        }
                    }

                    if (that.selectedcells.length > 0 || that.selectedrowindexes.length > 0) {
                        if (that.selectionmode.indexOf('cell') >= 0) {
                            var rowindex = that.getselectedcells()[0].rowindex;
                        }
                        else var rowindex = that.selectedrowindexes[0];
                        var rowData = that.getrowdata(rowindex);
                        if (rowData) {
                            that.updaterow(rowData.uid, row);
                        }
                    }
                    rowpopup.hide();
                    that.focus();
                });

                deleteButton.mousedown(function (event) {
                    if (that.selectedcells.length > 0 || that.selectedrowindexes.length > 0) {
                        if (that.selectionmode.indexOf('cell') >= 0) {
                            var row = that.getselectedcells()[0].rowindex;
                        }
                        else var row = that.selectedrowindexes[0];
                        var rowData = that.getrowdata(row);
                        if (rowData) {
                            that.deleterow(rowData.uid);
                        }
                    }
                    for (var j = 0; j < columnslength; j++) {
                        var columnrecord = that.columns.records[j];
                        if (columnrecord.reseteverpresentrowwidgetvalue) {
                            columnrecord.reseteverpresentrowwidgetvalue(columnrecord.displayfield, columnrecord.addnewrowwidget);
                        }
                    }
                    rowpopup.hide();
                    that.focus();
                    that.updateeverpresentrow();
                });

                button.mousedown(function (event) {
                    var row = {};
                    var rowPrepareValues = {};

                    for (var j = 0; j < columnslength; j++) {
                        var columnrecord = that.columns.records[j];
                        if (!columnrecord.geteverpresentrowwidgetvalue)
                            continue;

                        var value = columnrecord.geteverpresentrowwidgetvalue(columnrecord.displayfield, columnrecord.addnewrowwidget);
                        rowPrepareValues[columnrecord.datafield] = value;
                        if (columnrecord.datafield != columnrecord.displayfield) {
                            rowPrepareValues[columnrecord.datafield] = value.value;
                            rowPrepareValues[columnrecord.displayfield] = value.label;
                        }

                        if (columnrecord.datafield != columnrecord.displayfield) {
                            rowPrepareValues[columnrecord.datafield] = value.label;
                            rowPrepareValues[columnrecord.displayfield] = value.value;
                        }
                    }

                    var invalidState = false;
                    for (var j = 0; j < columnslength; j++) {
                        var columnrecord = that.columns.records[j];
                        if (!columnrecord.geteverpresentrowwidgetvalue)
                            continue;

                        var value = columnrecord.geteverpresentrowwidgetvalue(columnrecord.displayfield, columnrecord.addnewrowwidget);
                        if (columnrecord.createeverpresentrowwidget && columnrecord.validateeverpresentrowwidgetvalue) {
                            var validate = columnrecord.validateeverpresentrowwidgetvalue(columnrecord.displayfield, value, rowPrepareValues);
                            var validationobj = validate;
                            var validationmessage = that.gridlocalization.validationstring;
                            if (validationobj.message != undefined) {
                                validationmessage = validationobj.message;
                            }
                            var result = typeof validationobj == "boolean" ? validationobj : validationobj.result;

                            if (!result) {
                                value = "invalid editor state";
                                columnrecord.addnewrowwidget.attr("title", validationmessage);
                                columnrecord.addnewrowwidget.addClass(that.toThemeProperty('jqx-input-invalid'));
                            }
                            else {
                                columnrecord.addnewrowwidget.attr("title", "");
                                columnrecord.addnewrowwidget.removeClass(that.toThemeProperty('jqx-input-invalid'));
                            }
                        }
                        if (value === "invalid editor state") {
                            event.preventDefault();
                            event.stopPropagation();
                            invalidState = true;
                            continue;
                        }
                        if (invalidState)
                            continue;
                    }

                    if (invalidState) {
                        rowpopup.hide();
                        that.focus();
                        return;
                    }

                    for (var j = 0; j < columnslength; j++) {
                        var columnrecord = that.columns.records[j];
                        if (!columnrecord.geteverpresentrowwidgetvalue)
                            continue;

                        var value = columnrecord.geteverpresentrowwidgetvalue(columnrecord.displayfield, columnrecord.addnewrowwidget);
                        row[columnrecord.datafield] = value;
                        if (columnrecord.datafield != columnrecord.displayfield) {
                            rowPrepareValues[columnrecord.datafield] = value.label;
                            rowPrepareValues[columnrecord.displayfield] = value.value;
                        }

                        if (columnrecord.reseteverpresentrowwidgetvalue) {
                            columnrecord.reseteverpresentrowwidgetvalue(columnrecord.displayfield, columnrecord.addnewrowwidget);
                        }
                    }

                    var addPosition = that.everpresentrowactions.indexOf('addBottom') >= 0 ? "last" : "first";
                    that.addrow(null, row, addPosition);
                    rowpopup.hide();
                    that.focus();
                });

                resetButton.mousedown(function (event) {
                    var row = {};
                    for (var j = 0; j < columnslength; j++) {
                        var columnrecord = that.columns.records[j];
                        if (columnrecord.reseteverpresentrowwidgetvalue) {
                            columnrecord.reseteverpresentrowwidgetvalue(columnrecord.displayfield, columnrecord.addnewrowwidget);
                        }
                        if (columnrecord.addnewrowwidget) {
                            columnrecord.addnewrowwidget.attr("title", "");
                            columnrecord.addnewrowwidget.removeClass(that.toThemeProperty('jqx-input-invalid'));
                        }
                    }
                    rowpopup.hide();
                    that.focus();
                });
                for (var j = 0; j < columnslength; j++) {
                    var columnrecord = that.columns.records[j];

                    var width = columnrecord.width;
                    if (width < columnrecord.minwidth) width = columnrecord.minwidth;
                    if (width > columnrecord.maxwidth) width = columnrecord.maxwidth;

                    var tablecolumn = $('<div style="overflow: hidden; position: absolute; height: 100%;" class="' + cellclass + '"></div>');
                    tablerow.append(tablecolumn);
                    tablecolumn.css('left', left);
                    if (that.rtl) {
                        tablecolumn.css('z-index', zindex++);
                        tablecolumn.css('border-left-width', '1px');
                    }
                    else {
                        tablecolumn.css('z-index', zindex--);
                    }
                    if (width == "auto") width = 0;
                    tablecolumn[0].style.width = parseFloat(width) + 'px';
                    tablecolumn[0].left = left;
                    if (!(columnrecord.hidden && columnrecord.hideable) && !columnrecord.adaptivehidden) {
                        left += width;
                    }
                    else {
                        tablecolumn.css('display', 'none');
                    }
                    cells[cells.length] = tablecolumn[0];

                    if (columnrecord.checkboxcolumn) {
                        var checkboxclass = that.toThemeProperty('jqx-grid-cell');
                        checkboxclass += ' ' + that.toThemeProperty('jqx-grid-cell-filter-row');
                        checkboxclass += ' ' + that.toThemeProperty('jqx-grid-cell-pinned');
                        tablecolumn.removeClass().addClass(checkboxclass);
                        continue;
                    }

                    var addNewRowWidget = true;
                    if (!that.rtl) {
                        if (that.groupable) {
                            var detailsoffset = (that.showrowdetailscolumn && that.rowdetails) ? 1 : 0;
                            if (that.groups.length + detailsoffset > j) {
                                addNewRowWidget = false;
                            }
                        }
                        if (that.showrowdetailscolumn && that.rowdetails && j == 0) addNewRowWidget = false;
                    }
                    else {
                        if (that.groupable) {
                            var detailsoffset = (that.showrowdetailscolumn && that.rowdetails) ? 1 : 0;
                            if (that.groups.length + detailsoffset + j > columnslength - 1) {
                                addNewRowWidget = false;
                            }
                        }
                        if (that.showrowdetailscolumn && that.rowdetails && j == columnslength - 1) addNewRowWidget = false;
                    }

                    that.updateeverpresentrow = function () {
                        var rowData = null;
                        if (that.selectedcells.length > 0 || that.selectedrowindexes.length > 0) {
                            if (that.selectionmode.indexOf('cell') >= 0) {
                                var row = that.getselectedcells()[0].rowindex;
                            }
                            else var row = that.selectedrowindexes[0];
                            rowData = that.getrowdata(row);
                        }
                        if (!rowData) return;

                        for (var i = 0; i < that.columns.records.length; i++) {
                            var columnrecord = that.columns.records[i];
                            if (columnrecord.seteverpresentrowwidgetvalue) {
                                var cellText = that.getcelltext(row, columnrecord.displayfield);
                                columnrecord.seteverpresentrowwidgetvalue(columnrecord.addnewrowwidget, cellText);
                            }
                        }
                    }

                    if (addNewRowWidget) {
                        if (columnrecord.createeverpresentrowwidget) {
                            var addNewRow = function () {
                                button.trigger('mousedown');
                            }

                            columnrecord.addnewrowwidget = columnrecord.createeverpresentrowwidget(columnrecord.datafield, tablecolumn, rowpopup, addNewRow);
                            if (columnrecord.initeverpresentrowwidget) {
                                columnrecord.initeverpresentrowwidget(columnrecord.datafield, tablecolumn, rowpopup);
                            }
                        }
                        else {
                            that._measureElement('column');
                            var margin = (that.everpresentrowheight / 2 - that._columnheight / 2);
                            if (margin < 0) {
                                margin = 6;
                            }
                            margin += 'px';


                            if (columnrecord.datafield === "addButtonColumn") {
                                var anchor = $('<div style="padding-bottom: 2px; text-align: center; margin-top: ' + margin + ';">' + '<a href="#">' + that.gridlocalization.addrowstring + '</a>' + '</div>');
                                tablecolumn.append(anchor);
                                anchor.mousedown(function () {
                                    button.trigger('mousedown');
                                });
                                continue;
                            }
                            else if (columnrecord.datafield === "resetButtonColumn") {
                                var anchor = $('<div style="padding-bottom: 2px; text-align: center; margin-top: ' + margin + ';">' + '<a href="#">' + that.gridlocalization.resetrowstring + '</a>' + '</div>');
                                tablecolumn.append(anchor);
                                anchor.mousedown(function () {
                                    resetButton.trigger('mousedown');
                                });
                                continue;
                            }

                            var addtextwidget = function (me, tablecolumn, columnrecord) {
                                var textbox = $('<input style="box-sizing: border-box; padding-right: 4px; padding-left: 4px; border:none;" autocomplete="off" type="textarea"/>');
                                textbox[0].id = $.jqx.utilities.createId();
                                textbox.addClass(me.toThemeProperty('jqx-widget'));
                                textbox.addClass(me.toThemeProperty('jqx-input'));
                                textbox.addClass(me.toThemeProperty('jqx-widget-content'));
                                textbox.addClass(me.toThemeProperty('jqx-enableselect'));
                                textbox.addClass(me.toThemeProperty('jqx-grid-cell-add-new-row'));
                                textbox.css('text-align', columnrecord.cellsalign);
                                if (me.rtl) {
                                    textbox.css('direction', 'rtl');
                                }
                                if (me.disabled) {
                                    textbox.attr('disabled', true);
                                }
                                textbox.attr('disabled', false);
                                textbox.attr('placeholder', me.gridlocalization.everpresentrowplaceholder + columnrecord.text);
                                textbox.appendTo(tablecolumn);
                                textbox.css('width', '100%');
                                textbox.css('height', me.everpresentrowheight + "px");
                                textbox.css('line-height', me.everpresentrowheight + "px");
                                textbox.css('max-height', me.everpresentrowheight + "px");
                                textbox.css('margin', '0px');
                                textbox.focus(function () {
                                    if (that.selectedcells.length > 0 || that.selectedrowindexes.length > 0) {
                                        if (that.selectionmode.indexOf('cell') >= 0) {
                                            var row = that.getselectedcells()[0].rowindex;
                                        }
                                        else var row = that.selectedrowindexes[0];

                                    }
                                    textbox.addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    var columnIndex = me.columns.records.indexOf(columnrecord);
                                    if (me.everpresentrowactionsmode !== "columns") {
                                        rowpopup.css({ display: 'block', top: textbox.coord().top + me.everpresentrowheight - 1, left: columnIndex > 0 ? textbox.coord().left : textbox.coord().left - 1 });
                                    }
                                    var buttonsWidth = rowpopup.children().width();
                                    if (columnrecord.cellsalign === "right") {
                                        var buttonsWidth = button.width() + resetButton.width();
                                        rowpopup.children().css('left', buttonsWidth - buttonsWidth + "px");
                                    }
                                    else {
                                        rowpopup.children().css('left', "0px");
                                    }
                                    me.content[0].scrollLeft = 0;
                                    me.content[0].scrollTop = 0;
                                    setTimeout(function () {
                                        me.content[0].scrollLeft = 0;
                                        me.content[0].scrollTop = 0;
                                    }, 50);
                                    return false;
                                });
                                columnrecord.addnewrowwidget = textbox;

                                if (!columnrecord.reseteverpresentrowwidgetvalue) {
                                    columnrecord.reseteverpresentrowwidgetvalue = function (displayfield, widget) {
                                        widget.val("");
                                        widget.focus();
                                        widget.blur();
                                        widget.removeClass(that.toThemeProperty('jqx-input-invalid'));
                                        widget.attr('title', "");
                                    }
                                }
                                if (!columnrecord.seteverpresentrowwidgetvalue) {
                                    columnrecord.seteverpresentrowwidgetvalue = function (widget, value) {
                                        widget.val(value);
                                    }
                                }
                                if (!columnrecord.geteverpresentrowwidgetvalue) {
                                    var columndatarecord = columnrecord;
                                    columnrecord.geteverpresentrowwidgetvalue = function (datafield, widget, validateColumn) {
                                        var value = widget.val();

                                        if (validateColumn !== false && columndatarecord.validateeverpresentrowwidgetvalue) {
                                            //
                                            var row = {};
                                            var rowPrepareValues = {};

                                            for (var j = 0; j < columnslength; j++) {
                                                var columnrecord = that.columns.records[j];
                                                if (!columnrecord.geteverpresentrowwidgetvalue)
                                                    continue;

                                                var validatevalue = columnrecord.geteverpresentrowwidgetvalue(columnrecord.displayfield, columnrecord.addnewrowwidget, false);
                                                rowPrepareValues[columnrecord.datafield] = validatevalue;
                                                if (columnrecord.datafield != columnrecord.displayfield) {
                                                    rowPrepareValues[columnrecord.datafield] = validatevalue.value;
                                                    rowPrepareValues[columnrecord.displayfield] = validatevalue.label;
                                                }
                                            }
                                            //
                                            var validate = columndatarecord.validateeverpresentrowwidgetvalue(columndatarecord.displayfield, value, rowPrepareValues);
                                            var validationobj = validate;
                                            var validationmessage = that.gridlocalization.validationstring;
                                            if (validationobj.message != undefined) {
                                                validationmessage = validationobj.message;
                                            }
                                            var result = typeof validationobj == "boolean" ? validationobj : validationobj.result;

                                            if (!result) {
                                                textbox.addClass(that.toThemeProperty('jqx-input-invalid'));
                                                textbox.attr('title', validationmessage);
                                                return "invalid editor state";
                                            }
                                            else {
                                                textbox.removeClass(that.toThemeProperty('jqx-input-invalid'));
                                                textbox.attr('title', "");
                                            }
                                        }
                                        var type = 'string';
                                        var datafields = that.source.datafields || ((that.source._source) ? that.source._source.datafields : null);

                                        if (datafields) {
                                            var foundType = "";
                                            $.each(datafields, function () {
                                                if (this.name == columndatarecord.displayfield) {
                                                    if (this.type) {
                                                        foundType = this.type;
                                                    }
                                                    return false;
                                                }
                                            });
                                            if (foundType)
                                                type = foundType;
                                        }
                                        if (type === "number") {
                                            var number = parseFloat(value);
                                            if (isNaN(number))
                                                return null;
                                        }
                                        if (type === "date") {
                                            return $.jqx.dataFormat.tryparsedate(value, that.gridlocalization);
                                        }
                                        if (type === "bool" || type === "boolean") {
                                            if (value === "true") return true;
                                            if (value == "1") return true;
                                            if (value === "false") return false;
                                            if (value == "0") return false;
                                            if (value === true) return value;
                                            if (value === false) return value;
                                            return false;
                                        }
                                        return value;
                                    }
                                }

                                textbox.keydown(function (event) {
                                    if (event.keyCode === 13) {
                                        if (that.everpresentrowactions.indexOf('add') >= 0) {
                                            button.trigger('mousedown');
                                        }
                                        else if (that.everpresentrowactions.indexOf('update') >= 0) {
                                            updateButton.trigger('mousedown');
                                        }
                                        else if (that.everpresentrowactions.indexOf('delete') >= 0) {
                                            deleteButton.trigger('mousedown');
                                        }
                                    }
                                });
                                textbox.blur(function () {
                                    textbox.removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    rowpopup.css('display', 'none');
                                });

                                if (columnrecord.initeverpresentrowwidget) {
                                    columnrecord.initeverpresentrowwidget(columnrecord.datafield, tablecolumn, rowpopup);
                                }
                            }
                            addtextwidget(this, tablecolumn, columnrecord);
                        }
                    }
                }
                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                    tablerow.css('z-index', zindex--);
                }

                tablerow.width(parseFloat(left) + 2);
                newRowElement.addClass(cellclass);
                newRowElement.css('border-bottom-width', '0px');
                if (that.showfilterrow) {
                    newRowElement.css('border-top-width', '0px');
                }
                else {
                    newRowElement.css('border-top-width', '1px');
                }

                newRowElement.css('box-sizing', 'border-box');
                newRowElement.css('border-right-width', '0px');
            },

            _gettableheight: function () {
                if (this.tableheight != undefined)
                    return this.tableheight;

                var realheight = this.host.height();

                if (this.columnsheader) {
                    var columnheaderheight = this.columnsheader.outerHeight();
                    if (!this.showheader) {
                        columnheaderheight = 0;
                    }
                }

                realheight -= columnheaderheight;

                if (this.hScrollBar[0].style.visibility == 'visible') {
                    realheight -= this.hScrollBar.outerHeight();
                }

                if (this.pageable) {
                    realheight -= this.pager.outerHeight();
                }

                if (this._groupsheader()) {
                    realheight -= this.groupsheader.outerHeight();
                }

                if (this.showtoolbar) {
                    realheight -= this.toolbarheight;
                }

                if (this.showfilterbar) {
                    realheight -= this.toolbarheight;
                }

                if (this.showstatusbar) {
                    realheight -= this.statusbarheight;
                }

                if (this.showeverpresentrow && this.everpresentrowposition === "bottom") {
                    realheight -= this.everpresentrowheight;
                }

                if (realheight > 0) {
                    this.tableheight = realheight;
                    return realheight;
                }

                return this.host.height();
            },

            _getpagesize: function () {
                if (this.pageable) {
                    return this.pagesize;
                }

                if (this.virtualmode) {
                    var hostHeight = Math.round(this.host.height()) + 2 * this.rowsheight;

                    var visiblerecords = Math.round(hostHeight / this.rowsheight);
                    return visiblerecords;
                }

                if (this.autoheight || this.autorowheight || this.cardview) {
                    if (this.dataview.totalrows == 0)
                        return 1;
                    return this.dataview.totalrows;
                }

                if (this.dataview.totalrows < 100 && this.dataview.totalrecords < 100 && this.dataview.totalrows > 0) {
                    return this.dataview.totalrows;
                }

                return 100;
            },

            _calculatevirtualheight: function () {
                var self = this.that;

                var hostHeight = Math.round(this.host.height()) + 2 * this.rowsheight;

                var realheight = this._gettableheight();
                var visiblerecords = Math.round(hostHeight / this.rowsheight);


                this.heights = new Array();
                this.hiddens = new Array();
                this.details = new Array();
                this.expandedgroups = new Array();
                this.hiddenboundrows = new Array();
                this.heightboundrows = new Array();
                this.detailboundrows = new Array();

                var totalrows = Math.max(this.dataview.totalrows, this.dataview.totalrecords);
                if (this.pageable) {
                    totalrows = this.pagesize;
                    if (this.pagesize > Math.max(this.dataview.totalrows, this.dataview.totalrecords) && this.autoheight) {
                        totalrows = Math.max(this.dataview.totalrows, this.dataview.totalrecords);
                    }
                    else if (!this.autoheight) {
                        if (this.dataview.totalrows < this.pagesize) {
                            totalrows = Math.max(this.dataview.totalrows, this.dataview.totalrecords);
                        }
                    }
                }

                var virtualheight = totalrows * this.rowsheight;

                if (this.cardview) {
                    virtualheight = Math.ceil(totalrows / this.cardsize) * this.rowsheight;
                }

                var top = 0;
                var index = 0;
                var lasttop = 0;
                var pagesize = this._getpagesize();
                var pageheight = pagesize * this.rowsheight;
                var i = 0;
                if (!this.pageable && this.autoheight) {
                    visiblerecords = totalrows;
                }

                if (totalrows + pagesize > 0) {
                    while (i <= totalrows + pagesize) {
                        top += pageheight;
                        if (i - pagesize < totalrows && i >= totalrows) {
                            var rows = i - totalrows;
                            if (rows > 0) {
                                lasttop -= pageheight;
                                this._pageviews[index - 1] = { top: lasttop, height: pageheight - rows * this.rowsheight };
                            }
                            break;
                        }
                        else {
                            this._pageviews[index++] = { top: lasttop, height: pageheight };
                        }
                        lasttop = top;
                        i += pagesize;
                    }
                }

                if (this.resizingGrid != true) {
                    this.vScrollBar.jqxScrollBar({ value: 0 });
                }
                if (this.hScrollBar.css('visibility') == "hidden") {
                    var w = 0;
                    if (this.columns && this.columns.records) {
                        for (var i = 0; i < this.columns.records.length; i++) {
                            w += !isNaN(this.columns.records[i].width) ? this.columns.records[i].width : this.columns.records[i].minwidth;
                        }
                        if (!isNaN(w) && parseInt(w) > this.host.width()) {
                            realheight -= 30;
                        }
                    }
                }

                if (virtualheight > realheight && !this.autoheight) {
                    this.vScrollBar.css('visibility', 'visible');
                    if (this.scrollmode == 'deferred') {
                        this.vScrollBar.jqxScrollBar({ max: virtualheight });
                    }
                    else {
                        this.vScrollBar.jqxScrollBar({ max: virtualheight - realheight });

                        if (this.cardview) {
                            this.vScrollBar.jqxScrollBar({ step: this.cardheight });
                        }
                    }
                }
                else {
                    this.vScrollBar.css('visibility', 'hidden');
                }

                this.dataview.pagesize = pagesize;
                this.dataview.updateview();
                return { visiblerecords: visiblerecords, virtualheight: virtualheight };
            },

            _updatepageviews: function () {
                if (this.updating())
                    return;
                this._pagescache = new Array();
                this._pageviews = new Array();
                this.tableheight = null;
                var self = this.that;
                var hostHeight = Math.round(this.host.height()) + 2 * this.rowsheight;
                var visiblerecords = Math.round(hostHeight / this.rowsheight);
                var totalrows = Math.max(this.dataview.totalrows, this.dataview.totalrecords);
                var virtualheight = totalrows * this.rowsheight;
                var top = 0;
                var currentheight = 0;
                var index = 0;
                var lasttop = 0;
                var k = 0;
                var pagesize = this._getpagesize();

                if (!this.pageable) {
                    for (var i = 0; i < totalrows; i++) {
                        var rowinfo = { index: i, height: this.heights[i], hidden: this.hiddens[i], details: this.details[i] }
                        if (this.heights[i] == undefined) {
                            this.heights[i] = this.rowsheight;
                            rowinfo.height = this.rowsheight;
                        }
                        if (this.hiddens[i] == undefined) {
                            this.hiddens[i] = false;
                            rowinfo.hidden = false;
                        }
                        if (this.details[i] == undefined) {
                            this.details[i] = null;
                        }
                        if (rowinfo.height != self.rowsheight) {
                            virtualheight -= self.rowsheight;
                            virtualheight += rowinfo.height;
                        }

                        if (rowinfo.hidden) {
                            virtualheight -= rowinfo.height;
                        }
                        else {
                            currentheight += rowinfo.height;
                            var detailsheight = 0;
                            if (this.rowdetails) {
                                if (this.rowdetailstemplate) {
                                    if (!rowinfo.details) {
                                        var template = typeof this.rowdetailstemplate === 'function' ? this.rowdetailstemplate() : this.rowdetailstemplate;

                                        if (template.rowdetailshidden === undefined) {
                                            template.rowdetailshidden = true;
                                        }

                                        if (template.rowdetailsheight === undefined) {
                                            template.rowdetailsheight = 200;
                                        }

                                        if (template.rowdetails === undefined) {
                                            template.rowdetails = '<div></div>';
                                        }

                                        rowinfo.details = template;
                                    }
                                }

                                if (rowinfo.details && rowinfo.details.rowdetails && !rowinfo.details.rowdetailshidden) {
                                    detailsheight = rowinfo.details.rowdetailsheight;
                                    currentheight += detailsheight;
                                    virtualheight += detailsheight;
                                }
                            }
                            top += rowinfo.height + detailsheight;
                        }

                        k++;
                        if (k >= pagesize || i == totalrows - 1) {
                            this._pageviews[index++] = { top: lasttop, height: currentheight };
                            currentheight = 0;
                            lasttop = top;
                            k = 0;
                        }
                    }
                }
                else {
                    if (this._updatepagedview) {
                        virtualheight = this._updatepagedview(totalrows, virtualheight, 0);
                    }
                    if (this.autoheight) {
                        this._arrange();
                    }
                }

                var tableheight = this._gettableheight();
                if (virtualheight > tableheight) {
                    if (this.pageable && this.gotopage) {
                        virtualheight = this._pageviews[0].height; // -this._gettableheight();
                        if (virtualheight < 0) {
                            virtualheight = this._pageviews[0].height;
                        }
                    }

                    if (this.vScrollBar.css('visibility') != 'visible') {
                        this.vScrollBar.css('visibility', 'visible');
                    }
                    if (virtualheight <= tableheight || this.autoheight) {
                        this.vScrollBar.css('visibility', 'hidden');
                    }

                    if (virtualheight - tableheight > 0) {
                        if (this.scrollmode != 'deferred') {
                            var max = virtualheight - tableheight;
                            var oldmax = this.vScrollInstance.max;
                            this.vScrollBar.jqxScrollBar({ max: max });
                            if (max != oldmax) {
                                this.vScrollBar.jqxScrollBar({ value: 0 });
                            }
                        }
                        else {
                            this.vScrollBar.jqxScrollBar({ value: 0, max: virtualheight });
                        }
                    }
                    else {
                        this.vScrollBar.jqxScrollBar({ value: 0, max: virtualheight });
                    }
                }
                else {
                    if (!this._loading) {
                        this.vScrollBar.css('visibility', 'hidden');
                    }
                    this.vScrollBar.jqxScrollBar({ value: 0 });
                }

                this._arrange();

                if (this.autoheight) {
                    visiblerecords = Math.round(this.host.height() / this.rowsheight);
                }

                this.virtualsizeinfo = { visiblerecords: visiblerecords, virtualheight: virtualheight };
            },

            updatebounddata: function (reason) {
                if (reason != "data" && reason != "sort" && reason != "filter" && reason != "cells" && reason != "pagechanged" && reason != "pagesizechanged" && !this.virtualmode) {
                    this.virtualsizeinfo = null;
                    if (this.columns && this.columns.records) {
                        for (var i = 0; i < this.columns.records.length; i++) {
                            var column = this.columns.records[i];

                            if (column.destroywidget && column.widget) {
                                if (column.destroywidget) {
                                    column.destroywidget(column.widget);
                                }
                            }
                        }
                    }

                    if (this.showfilterrow && this.filterable && this.filterrow) {
                        if (this.clearfilters) {
                            this.clearfilters(false);
                        }
                        if (this.filterable && this._destroyedfilters && this.showfilterrow) {
                            this._destroyedfilters();
                        }
                        this.filterrow.remove();
                        this._filterrowcache = new Array();
                        this.filterrow = null;
                    }
                    else if (this.filterable) {
                        if (this.clearfilters) {
                            this.clearfilters(false);
                        }
                    }
                    if (this.showeverpresentrow) {
                        this._removeaddnewrow();
                    }
                    this.detailsVisibility = new Array();
                    this.groupsVisibility = new Array();

                    if (this.groupable) {
                        this.dataview.groups = [];
                        this.groups = [];
                    }

                    if (this.pageable) {
                        this.pagenum = 0;
                        this.dataview.pagenum = 0;
                    }
                    if (this.sortable) {
                        this.sortcolumn = null;
                        this.sortdirection = '';
                        this.dataview.sortfielddirection = "";
                        this.dataview.clearsortdata();
                    }
                }
                this.databind(this.source, reason);
            },

            refreshdata: function () {
                this._refreshdataview();
                this.render();
            },

            _updatevscrollbarmax: function () {
                if (this._pageviews && this._pageviews.length > 0) {
                    var virtualheight = this._pageviews[0].height;
                    if (this.virtualmode || !this.pageable) {
                        virtualheight = this.virtualsizeinfo.virtualheight;
                    }

                    var tableheight = this._gettableheight();
                    if (virtualheight > tableheight) {
                        if (this.pageable && this.gotopage) {
                            virtualheight = this._pageviews[0].height;
                            if (virtualheight < 0) {
                                virtualheight = this._pageviews[0].height;
                            }
                        }

                        if (this.vScrollBar.css('visibility') != 'visible') {
                            this.vScrollBar.css('visibility', 'visible');
                        }
                        if (virtualheight <= tableheight || this.autoheight) {
                            this.vScrollBar.css('visibility', 'hidden');
                        }

                        if (virtualheight - tableheight > 0) {
                            var max = virtualheight - tableheight;
                            this.vScrollBar.jqxScrollBar({ max: max });
                        }
                        else {
                            this.vScrollBar.jqxScrollBar({ value: 0, max: virtualheight });
                        }
                    }
                    else {
                        this.vScrollBar.css('visibility', 'hidden');
                        this.vScrollBar.jqxScrollBar({ value: 0 });
                    }
                }
            },

            _refreshdataview: function () {
                this.dataview.refresh();
            },

            refresh: function (initialRefresh) {
                if (initialRefresh != true) {
                    if ($.jqx.isHidden(this.host))
                        return;

                    if (this.virtualsizeinfo != null) {
                        //   this._requiresupdate = true;
                        this._cellscache = new Array();
                        this._renderrows(this.virtualsizeinfo);
                        this._updatesize();
                    }
                }
            },

            render: function () {
                this._render(true, true, true, true);
            },

            invalidate: function () {
                if (this.virtualsizeinfo) {
                    this._updatecolumnwidths();
                    this._updatecellwidths();
                    this._renderrows(this.virtualsizeinfo);
                }
            },

            clear: function () {
                this.databind(null);
                this.render();
            },

            _preparecolumngroups: function () {
                var columnsheight = this.columnsheight;
                if (this.columngroups) {
                    this.columnshierarchy = new Array();
                    if (this.columngroups.length) {
                        var that = this;
                        for (var i = 0; i < this.columngroups.length; i++) {
                            this.columngroups[i].parent = null;
                            this.columngroups[i].groups = null;
                        }
                        for (var i = 0; i < this.columns.records.length; i++) {
                            this.columns.records[i].parent = null;
                            this.columns.records[i].groups = null;
                        }

                        var getParentGroup = function (name) {
                            for (var i = 0; i < that.columngroups.length; i++) {
                                var group = that.columngroups[i];
                                if (group.name === name)
                                    return group;
                            }
                            return null;
                        }

                        for (var i = 0; i < this.columngroups.length; i++) {
                            var group = this.columngroups[i];
                            if (!group.groups) {
                                group.groups = null;
                            }
                            if (group.parentgroup) {
                                var parentgroup = getParentGroup(group.parentgroup);
                                if (parentgroup) {
                                    group.parent = parentgroup;
                                    if (!parentgroup.groups) {
                                        parentgroup.groups = new Array();
                                    }
                                    if (parentgroup.groups.indexOf(group) === -1) {
                                        parentgroup.groups.push(group);
                                    }
                                }
                            }
                        }
                        for (var i = 0; i < this.columns.records.length; i++) {
                            var group = this.columns.records[i];
                            if (group.columngroup) {
                                var parentgroup = getParentGroup(group.columngroup);
                                if (parentgroup) {
                                    if (!parentgroup.groups) {
                                        parentgroup.groups = new Array();
                                    }
                                    group.parent = parentgroup;
                                    if (parentgroup.groups.indexOf(group) === -1) {
                                        parentgroup.groups.push(group);
                                    }
                                }
                            }
                        }
                        var totalmaxlevel = 0;
                        for (var i = 0; i < this.columns.records.length; i++) {
                            var group = this.columns.records[i];
                            var initialgroup = group;
                            group.level = 0;
                            while (initialgroup.parent) {
                                initialgroup = initialgroup.parent;
                                group.level++;
                            }
                            var initialgroup = group;
                            var maxlevel = group.level;
                            totalmaxlevel = Math.max(totalmaxlevel, group.level);
                            while (initialgroup.parent) {
                                initialgroup = initialgroup.parent;
                                if (initialgroup) {
                                    initialgroup.level = --maxlevel;
                                }
                            }
                        }

                        var getcolumns = function (group) {
                            var columns = new Array();
                            if (group.columngroup) {
                                columns.push(group);
                            }
                            if (group.groups) {
                                for (var i = 0; i < group.groups.length; i++) {
                                    if (group.groups[i].columngroup) {
                                        columns.push(group.groups[i]);
                                    }
                                    else {
                                        if (group.groups[i].groups) {
                                            var tmpcolumns = getcolumns(group.groups[i]);
                                            for (var j = 0; j < tmpcolumns.length; j++) {
                                                columns.push(tmpcolumns[j]);
                                            }
                                        }
                                    }
                                }
                            }
                            return columns;
                        }

                        for (var i = 0; i < this.columngroups.length; i++) {
                            var group = this.columngroups[i];
                            var columns = getcolumns(group);
                            group.columns = columns;
                            var indexes = new Array();
                            var pinned = 0;
                            for (var j = 0; j < columns.length; j++) {
                                indexes.push(this.columns.records.indexOf(columns[j]));
                                if (columns[j].pinned) {
                                    pinned++;
                                }
                            }
                            if (pinned != 0) {
                                throw new Error("jqxGrid: Column Groups initialization Error. Please, check the initialization of the jqxGrid's columns array. The columns in a column group cannot be pinned.");
                            }

                            indexes.sort(function (value1, value2) {
                                value1 = parseInt(value1);
                                value2 = parseInt(value2);

                                if (value1 < value2) { return -1; }
                                if (value1 > value2) { return 1; }
                                return 0;
                            }
                            );
                            for (var index = 1; index < indexes.length; index++) {
                                if (indexes[index] != indexes[index - 1] + 1) {
                                    throw new Error("jqxGrid: Column Groups initialization Error. Please, check the initialization of the jqxGrid's columns array. The columns in a column group are expected to be siblings in the columns array.");
                                    this.host.remove();
                                }
                            }
                        }
                    }
                    this.columngroupslevel = 1 + totalmaxlevel;
                    columnsheight = this.columngroupslevel * this.columnsheight;
                }
                return columnsheight;
            },

            _render: function (initialization, forceupdate, rendercolumns, rendermenu, updatelistfilter) {
                if (this.dataview == null)
                    return;

                if (this._loading) {
                    return;
                }

                if (this._batchupdate) {
                    return;
                }

                if ($.jqx.isHidden(this.host)) {
                    var that = this;
                    if (that.___hiddenTimer) {
                        clearInterval(that.___hiddenTimer);
                        that.___hiddenTimer = null;
                    }

                    this.___hiddenTimer = setInterval(function () {
                        if (!$.jqx.isHidden(that.host)) {
                            clearInterval(that.___hiddenTimer);
                            that.render();
                        }
                    }, 300);
                    return;
                }

                if (this.contextmenuenabled) {
                    var that = this;
                    var contextMenu = document.createElement('div');
                    var items = '<ul>';
                    for (var i = 0; i < this.contextmenuitems.length; i++) {
                        var item = '<li>' + this.contextmenuitems[i] + '</li>';
                        items += item;
                    }
                    items + '</ul>';
                    contextMenu.innerHTML = items;
                    var id = that.element.id + '_' + 'contextmenu';
                    contextMenu.id = id;

                    var self = this;
                    var menuCell = null;
                    this.host.on('contextmenu', function (event) {
                        menuCell = self.getcellatposition(event.pageX, event.pageY);
                        $('#' + id).jqxMenu('open', event.pageX, event.pageY);
                        return false;
                    });

                    // handle context menu clicks.
                    $(contextMenu).on('itemclick', function (event) {
                        if (that.contextmenuitemclick) {
                            that.contextmenuitemclick(event, menuCell);
                        }
                    });
                    document.body.appendChild(contextMenu);
                    $('#' + id).jqxMenu({ width: that.contextmenuwidth, height: that.contextmenuheight, autoOpenPopup: false, mode: 'popup' });
                }

                if (this.editcell != null && this.endcelledit) {
                    this.endcelledit(this.editcell.row, this.editcell.column, true, false);
                }
                this.validationpopup = null;
                this._removeHandlers();
                this._addHandlers();
                this._initializeRows();

                this._requiresupdate = forceupdate != undefined ? forceupdate : true;
                this._newmax = null;

                if (rendercolumns) {
                    if (!this._requiresupdate) {
                        if (rendermenu != false) {
                            this._initmenu();
                        }
                    }

                    if (this.columns == null) {
                        this.columns = new $.jqx.collection(this.element);
                    }
                    else {
                        var me = this;
                        if (this.columns && this.columns.name === "observableArray") {
                            this.columns.notifier = function (changed) {
                                var updateColumns = function () {
                                    me.columns = me._columns;
                                    me.render();
                                }

                                switch (changed.type) {
                                    case "add":
                                        updateColumns();
                                        break;
                                    case "update":
                                        if (changed.name === "index") {
                                            me.beginupdate();
                                            for (var obj in changed.newValue) {
                                                me.setcolumnproperty(changed.newValue.datafield, obj, changed.newValue[obj]);
                                            }
                                            me.endupdate();
                                        }
                                        else {
                                            var items = changed.path.split(".")
                                            me.setcolumnproperty(me.columns[items[0]].datafield, changed.name, changed.newValue);
                                        }
                                        break;
                                    case "delete":
                                        updateColumns();
                                        break;
                                }
                            }
                        }
                        if (this.columngroups && this.columngroups.name === "observableArray") {
                            this.columngroups.notifier = function (changed) {
                                me.render();
                            }
                        }
                        this._initializeColumns();
                    }
                }

                this.tableheight = null;
                this._pagescache = new Array();
                this._pageviews = new Array();
                this.visiblerows = new Array();
                this.hittestinfo = new Array();

                if (this._requiresupdate) {
                    this._clearcaches();
                    if (rendermenu == true) {
                        this._initmenu();
                    }
                }

                this.virtualsizeinfo = null;
                this.prerenderrequired = true;

                if ((this.groupable && this.groups.length > 0 && this.rowdetails) || (this.rowdetails)) {
                    if (this.gridcontent) {
                        this._rowdetailscache = new Array();
                        this._rowdetailselementscache = new Array();
                        this.detailboundrows = new Array();
                        this.details = new Array();
                        $.jqx.utilities.html(this.gridcontent, '');
                        this.gridcontent = null;
                    }
                }

                if (this.gridcontent) {
                    if (this.editable && this._destroyeditors) {
                        this._destroyeditors();
                    }
                }

                if (rendercolumns) {
                    if (this.filterrow) this.filterrow.detach();
                    $.jqx.utilities.html(this.content, '');
                    this.columnsheader = this.columnsheader || $('<div style="overflow: hidden;"></div>');
                    this.columnsheader.remove();
                    this.columnsheader.addClass(this.toTP('jqx-widget-header'));
                    this.columnsheader.addClass(this.toTP('jqx-grid-header'));
                }
                else {
                    if (this.gridcontent) {
                        $.jqx.utilities.html(this.gridcontent, '');
                    }
                }

                if (!this.showheader) {
                    this.columnsheader.css('display', 'none');
                }
                else {
                    if (this.columnsheader) {
                        this.columnsheader.css('display', 'block');
                    }
                }

                this.gridcontent = this.gridcontent || $('<div style="width: 100%; overflow: hidden; position: absolute;"></div>');
                this.gridcontent.remove();

                var columnsheight = this.columnsheight;
                columnsheight = this._preparecolumngroups();

                if (this.showfilterrow && this.filterable) {
                    this.columnsheader.height(columnsheight + this.filterrowheight);
                    if (this.showeverpresentrow && this.everpresentrowposition !== "bottom") {
                        this.columnsheader.height(columnsheight + this.filterrowheight + this.everpresentrowheight);
                    }
                }
                else if (this.showeverpresentrow && this.everpresentrowposition !== "bottom") {
                    this.columnsheader.height(columnsheight + this.everpresentrowheight);
                }
                else {
                    this.columnsheader.height(columnsheight);
                }

                this.content.append(this.columnsheader);
                this.content.append(this.gridcontent);
                this._arrange();

                if (this._initgroupsheader) {
                    this._initgroupsheader();
                }

                this.selectionarea = this.selectionarea || $("<div style='z-index: 9999; visibility: hidden; position: absolute;'></div>");
                this.selectionarea.addClass(this.toThemeProperty('jqx-grid-selectionarea'));
                this.selectionarea.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this.content.append(this.selectionarea);
                this.tableheight = null;
                this.rendergridcontent(false, rendercolumns);
                if (this.groups.length > 0 && this.groupable) {
                    var vScrollVisibility = this.vScrollBar[0].style.visibility;
                    this.suspendgroupevents = true;
                    if (this.collapseallgroups) {
                        if (!this.groupsexpandedbydefault) {
                            this.collapseallgroups(false);
                            this._updatescrollbarsafterrowsprerender();
                        }
                        else {
                            this.expandallgroups(false);
                        }
                    }
                    if (this.vScrollBar[0].style.visibility != vScrollVisibility) {
                        this._updatecolumnwidths();
                        this._updatecellwidths();
                    }
                    this.suspendgroupevents = false;
                }

                if (this.pageable && this.updatepagerdetails) {
                    this.updatepagerdetails();
                    if (this.autoheight) {
                        this._updatepageviews();
                    }
                    if (this.autorowheight) {
                        if (!this.autoheight) {
                            this._updatepageviews();
                        }
                        this._renderrows(this.virtualsizeinfo);
                    }
                }

                if (this.showaggregates && this._updateaggregates) {
                    this._updateaggregates();
                }

                this._addoverlayelement();
                if (this.scrollmode == "deferred") {
                    this._addscrollelement();
                }

                if (this.showfilterrow && this.filterable && this.filterrow && (updatelistfilter == undefined || updatelistfilter == true)) {
                    this._updatelistfilters(!rendercolumns);
                }

                if (this.filterable && this.filtermode === "simple" || this.filtermode === "default" && this.showfilterbar) {
                    this._renderfilter();
                }

                // callback when the rendering is complete.
                if (this.rendered) {
                    this.rendered('full');
                }
                this.__isRendered = true;
            },

            _addoverlayelement: function () {


                var browserInfo = $.jqx.utilities.getBrowser();
                if ((browserInfo.browser == 'msie' && parseInt(browserInfo.version) < 9) || this.isTouchDevice()) {
                    if (this._overlayElement) {
                        this._overlayElement.remove();
                    }
                    this._overlayElement = $("<div class='jqxgrid-overlay' style='visibility: hidden; position: absolute; width: 100%; height: 100%;'></div>");
                    this._overlayElement.css('background', 'white');
                    this._overlayElement.css('z-index', 180);
                    this._overlayElement.css('opacity', 0.001);
                    if (this.isTouchDevice()) {
                        if (this.vScrollBar.css('visibility') !== "hidden" || this.hScrollBar.css('visibility') !== "hidden") {
                            //   this.table.prepend(this._overlayElement);
                            //   this._overlayElement.css('visibility', 'visible');
                            var leftOffset = 0;
                            if (this.selectionmode == "checkbox") {
                                leftOffset += 30;
                            }
                            if (this.groupable || this.rowdetails) {
                                this._overlayElement.css('left', 30 * (this.groups.length + (this.rowdetails ? 1 : 0)));
                            }
                            var left = this._overlayElement.css('left');
                            this._overlayElement.css('left', left + leftOffset);
                            if (this.cardview) {
                                this.content.prepend(this._overlayElement);
                                var me = this;
                                this.host.on('mouseup', function () {
                                    me._overlayElement.css('visibility', 'visible');
                                });

                                this._overlayElement[0].onmouseup = function (event) {
                                    me._overlayElement.css('visibility', 'hidden');
                                    event.stopPropagation();
                                }
                            }
                        }
                        else {
                            if (this._overlayElement) {
                                this._overlayElement.remove();
                            }
                        }
                    }
                    else {
                        this.content.prepend(this._overlayElement);
                    }
                }
                this._updateTouchScrolling();
            },

            _addscrollelement: function () {
                if (this._scrollelement) {
                    this._scrollelement.remove();
                }
                if (this._scrollelementoverlay) {
                    this._scrollelementoverlay.remove();
                }

                this._scrollelementoverlay = $("<div style='visibility: hidden; position: absolute; width: 100%; height: 100%;'></div>");
                this._scrollelementoverlay.css('background', 'black');
                this._scrollelementoverlay.css('z-index', 1800);
                this._scrollelementoverlay.css('opacity', 0.1);

                this._scrollelement = $("<span style='visibility: hidden; top: 50%; right: 10px; position: absolute;'></span>");
                this._scrollelement.css('z-index', 1900);
                this._scrollelement.addClass(this.toThemeProperty('jqx-button'));
                this._scrollelement.addClass(this.toThemeProperty('jqx-fill-state-normal'));
                this._scrollelement.addClass(this.toThemeProperty('jqx-rc-all'));
                this._scrollelement.addClass(this.toThemeProperty('jqx-shadow'));
                this.content.prepend(this._scrollelement);
                this.content.prepend(this._scrollelementoverlay);
            },

            _postrender: function (type) {
                if (type == "filter" || type == "sort" || type == "group") {
                    if (this.rowdetails && this.detailsVisibility && this.detailsVisibility.length > 0) {
                        this._detailsUpdate = true;
                        for (var i = 0; i < this.details.length; i++) {
                            if (this.details[i]) {
                                this.details[i].rowdetailshidden = true;
                            }
                        }

                        if (!this._loading) {
                            for (var i = 0; i < this.detailsVisibility.length; i++) {
                                if (false === this.detailsVisibility[i]) {
                                    this.showrowdetails(i);
                                }
                                else if (true === this.detailsVisibility[i]) {
                                    this.hiderowdetails(i);
                                }
                            }
                        }

                        this._detailsUpdate = false;
                        this.rendergridcontent(true);
                        this._updatecolumnwidths();
                        this._updatecellwidths();
                        this._renderrows(this.virtualsizeinfo);
                    }
                }
                if (this.groupable && this.groups.length > 0) {
                    if (type == "filter" || type == "sort") {
                        for (var i = 0; i < this.dataview.loadedgroups.length; i++) {
                            var group = this.dataview.loadedgroups[i];
                            var items = 0;
                            var suspendgroupevents;

                            for (var obj in this.groupsVisibility) {
                                if (obj == group.group && this.groupsVisibility[obj]) {
                                    suspendgroupevents = true;
                                    this._setgroupstate(group, true, false)
                                    items++;
                                }
                            };

                            if (items > 0) {
                                suspendgroupevents = false;
                                var scrollBarVisibility = this.vScrollBar[0].style.visibility;
                                this.rendergridcontent(true, false);
                                if (scrollBarVisibility != this.vScrollBar[0].style.visibility || this._hiddencolumns) {
                                    this._updatecolumnwidths();
                                    this._updatecellwidths();
                                    this._renderrows(this.virtualsizeinfo);
                                }
                            }
                        }
                    }
                    else if (type == "group") {
                        this.groupsVisibility = new Array();
                    }
                }
            },

            rendergridcontent: function (requiresupdate, rendercolumns) {
                if (this.updating()) {
                    return false;
                }

                if (requiresupdate == undefined || requiresupdate == null) {
                    requiresupdate = false;
                }

                this._requiresupdate = requiresupdate;

                var prerender = this.prerenderrequired;
                if (this.prerenderrequired) {
                    this._arrange();
                }

                var me = this.that;
                var rendercolumns = rendercolumns;
                if (rendercolumns == null || rendercolumns == undefined) {
                    rendercolumns = true;
                }

                this.tableheight = null;
                me.virtualsizeinfo = me.virtualsizeinfo || me._calculatevirtualheight();
                if (me.pageable && !me.autoheight) {
                    if (me.dataview.totalrows < me.pagesize) {
                        me._requiresupdate = true;
                    }
                }

                if (rendercolumns) {
                    me._rendercolumnheaders();
                }
                else {
                    if (this._rendersortcolumn) {
                        this._rendersortcolumn();
                    }
                    if (this._renderfiltercolumn) {
                        this._renderfiltercolumn();
                    }
                }

                me._renderrows(me.virtualsizeinfo);

                if (this.gridcontent) {
                    if (this.gridcontent[0].scrollTop != 0) {
                        this.gridcontent[0].scrollTop = 0;
                    }

                    if (this.gridcontent[0].scrollLeft != 0) {
                        this.gridcontent[0].scrollLeft = 0;
                    }
                }

                if (prerender) {
                    var tableheight = this.tableheight;
                    this._arrange();
                    if (tableheight != this.tableheight && this.autoheight) {
                        me._renderrows(me.virtualsizeinfo);
                    }
                }

                if (this.rtl) {
                    this._renderhorizontalscroll();
                }

                if (this.autosavestate) {
                    if (this.initializedcall != null) {
                        if (this.savestate) {
                            this.savestate();
                        }
                    }
                }

                if (this.adaptive && this.element.offsetWidth <= this.adaptivewidth) {
                    var adaptiveWidth = 0;
                    var gridWidth = me.element.offsetWidth - 2;

                    $.each(this.columns.records, function (i, value) {
                        adaptiveWidth += this.width;

                        if (this.columntype === "adaptive") {
                            return true;
                        }

                        if (adaptiveWidth >= gridWidth) {
                            this.adaptivehidden = true;
                        }
                    });

                    this._updatecolumnwidths();
                    this._updatecellwidths();
                    this._renderrows(this.virtualsizeinfo);
                }
                else if (this.adaptive) {
                    $.each(this.columns.records, function (i, value) {
                        if (this.columntype === "adaptive") {
                            return true;
                        }

                        this.adaptivehidden = false;
                    });

                    this._updatecolumnwidths();
                    this._updatecellwidths();
                    this._renderrows(this.virtualsizeinfo);
                }

                return true;
            },

            _updatecolumnwidths: function () {
                var totalwidth = this.host.width();
                var hostwidth = totalwidth;
                var allcharacters = '';
                if (this.columns == undefined || this.columns.records == undefined)
                    return;

                var self = this.that;
                var indent = this.rowdetails && this.showrowdetailscolumn ? (1 + this.groups.length) * this.groupindentwidth : (this.groups.length) * this.groupindentwidth;
                var adaptiveMode = this.adaptive && this.element.offsetWidth <= this.adaptivewidth;
                var averageWidth = 0;
                if (adaptiveMode) {
                    var adaptiveHiddenCount = 1;
                    $.each(this.columns.records, function (i, value) {
                        if (this.adaptivehidden) {
                            adaptiveHiddenCount++;
                        }
                    });

                    var scrollWidth = this.vScrollBar[0].offsetWidth > 0 ? this.vScrollBar[0].offsetWidth + 4 : 0;
                    if (this.vScrollBar.css('visibility') == "hidden") {
                        scrollWidth = 0;
                    }
                    var columnsCount = this.columns.records.length - adaptiveHiddenCount;
                    averageWidth = (this.element.offsetWidth - 32 - scrollWidth) / columnsCount;
                }


                $.each(this.columns.records, function (i, value) {


                    if (!(this.hidden && this.hideable) && !this.adaptivehidden) {
                        if (this.width.toString().indexOf('%') != -1 || this._percentagewidth != undefined) {
                            var value = 0;
                            var offset = self.vScrollBar[0].style.visibility == 'hidden' ? 0 : self.scrollbarsize + 5;
                            if (self.scrollbarautoshow || self.scrollbarsize == 0) {
                                offset = 0;
                            }

                            var w = hostwidth;
                            value = parseFloat(this.width) * w / 100;
                            offset += indent;
                            if (this._percentagewidth != undefined) {
                                value = parseFloat(this._percentagewidth) * (w - offset) / 100;
                            }

                            if (value < this.minwidth && this.minwidth != 'auto') value = this.minwidth;
                            if (value > this.maxwidth && this.maxwidth != 'auto') value = this.maxwidth;
                            totalwidth -= value;
                        }
                        else if (this.width != 'auto' && !this._width) {
                            totalwidth -= this.width;
                        }
                        else {
                            allcharacters += this.text;
                        }
                    }
                });

                var tableheight = this._gettableheight();

                if (!this.autoheight) {
                    if (this.virtualsizeinfo && this.virtualsizeinfo.virtualheight > tableheight) {
                        if (this.groupable && this.groups.length > 0) {
                            if (this.dataview && this.dataview.loadedrootgroups && !this.groupsexpandedbydefault) {
                                var groupsheight = this.dataview.loadedrootgroups.length * this.rowsheight;
                                if (this.pageable) {
                                    for (var q = 0; q < this.dataview.rows.length; q++) {
                                        if (this.dataview.rows[q].group && this.dataview.rows[q].level === 0) {
                                            groupsheight += this.rowsheight;
                                        }
                                    }
                                }

                                if (groupsheight > tableheight) {
                                    totalwidth -= this.scrollbarsize + 5;
                                    hostwidth -= this.scrollbarsize + 5;
                                }
                                else if (this.vScrollBar.css('visibility') == 'visible') {
                                    totalwidth -= this.scrollbarsize + 5;
                                    hostwidth -= this.scrollbarsize + 5;
                                }
                            }
                            else {
                                totalwidth -= this.scrollbarsize + 5;
                                hostwidth -= this.scrollbarsize + 5;
                            }
                        }
                        else {
                            if (this.vScrollBar.css('visibility') != 'hidden' && this.scrollbarsize > 0) {
                                totalwidth -= this.scrollbarsize + 5;
                                hostwidth -= this.scrollbarsize + 5;
                            }
                        }
                    }
                }
                var indent = this.rowdetails && this.showrowdetailscolumn ? (1 + this.groups.length) * this.groupindentwidth : (this.groups.length) * this.groupindentwidth;
                hostwidth -= indent;

                if (!this.columnsheader) {
                    return;
                }

                var columnheader = this.columnsheader.find('#columntable' + this.element.id);
                if (columnheader.length == 0)
                    return;

                var left = 0;
                var me = this;
                var autoWidth = 0;
                $.each(this.columns.records, function (i, value) {
                    var column = $(this.element);
                    if (!this.hidden && !this.adaptivehidden && this.element.style.display === "none") {
                        this.element.style.display = "block";
                    }
                    if (this.adaptivehidden) {
                        this.element.style.display = "none";
                    }

                    var percentage = false;
                    var desiredwidth = this.width;
                    if (this.width.toString().indexOf('%') != -1 || this._percentagewidth != undefined) {
                        if (this._percentagewidth != undefined) {
                            desiredwidth = parseFloat(this._percentagewidth) * hostwidth / 100;
                        }
                        else {
                            desiredwidth = parseFloat(this.width) * hostwidth / 100;
                        }
                        percentage = true;
                    }

                    if (averageWidth > 0 && this.columntype !== "adaptive") {
                        column.width(averageWidth);
                        this.adaptivewidth = averageWidth;
                    }
                    else if (this.width != 'auto' && !this._width && !percentage) {
                        if (parseInt(column[0].style.width) != this.width) {
                            column.width(this.width);
                        }
                    }
                    else if (percentage) {
                        if (desiredwidth < this.minwidth && this.minwidth != 'auto') {
                            desiredwidth = this.minwidth;
                            this.width = desiredwidth;
                        }
                        if (desiredwidth > this.maxwidth && this.maxwidth != 'auto') {
                            desiredwidth = this.maxwidth;
                            this.width = desiredwidth;
                        }

                        if (parseInt(column[0].style.width) != desiredwidth) {
                            column.width(desiredwidth);
                            this.width = desiredwidth;
                        }
                    }
                    else {
                        var width = Math.floor(totalwidth * (this.text.length / allcharacters.length));
                        autoWidth += width;
                        if (totalwidth - autoWidth < 3 && totalwidth != autoWidth && totalwidth - autoWidth > 0.01) {
                            if (totalwidth - autoWidth === 1) {
                                width++;
                            }
                            else {
                                width += 2;
                            }
                        }
                        else if (i == self.columns.records.length - 1) {
                            if (autoWidth < totalwidth) {
                                width += (totalwidth - autoWidth);
                            }
                        }
                        if (isNaN(width)) {
                            width = this.minwidth;
                        }

                        if (isNaN(width)) {
                            width = this.minwidth;
                        }
                        if (width == Infinity) {
                            width = 0;
                        }

                        if (width < 0) {
                            var $element = $('<span>' + me.escape_HTML(this.text) + '</span>');
                            $(document.body).append($element);
                            width = 10 + $element.width();
                            $element.remove();
                        }
                        if (width < this.minwidth) {
                            width = this.minwidth;
                        }
                        if (width > this.maxwidth) {
                            width = this.maxwidth;
                        }

                        this._width = 'auto';
                        this.width = width;
                        column.width(this.width);
                    }
                    if (parseInt(column[0].style.left) != left) {
                        column.css('left', left);
                    }

                    if (!(this.hidden && this.hideable) && !this.adaptivehidden) {
                        if (averageWidth > 0 && this.columntype !== "adaptive") {
                            left += averageWidth;
                        }
                        else {
                            left += this.width;
                        }
                    }

                    this._requirewidthupdate = true;
                });
                this.columnsheader.width(2 + left);
                columnheader.width(this.columnsheader.width());
                if (left == 0)
                    this.columnsheader[0].style.visibility = "hidden";
                else
                    this.columnsheader[0].style.visibility = "inherit";

                this._resizecolumngroups();
                if (this.showfilterrow && this.filterrow) {
                    this.filterrow.width(this.columnsheader.width());
                    this._updatefilterrowui();
                }
                if (this.showeverpresentrow) {
                    if (this.everpresentrowposition !== "bottom") {
                        this.addnewrowtop.width(this.columnsheader.width());
                    }
                    else {
                        this.addnewrowbottom.width(this.columnsheader.width());
                    }

                    this._updateaddnewrowui();
                }
                if (this.autowidth) {
                    this._arrange();
                }
            },

            _rendercolumnheaders: function () {
                var self = this.that;

                if (this.cardview) {
                    if (self.cardviewcolumns.length > 0) {
                        $.each(this.columns.records, function (i, value) {
                            if (typeof self.cardviewcolumns[0] !== 'string') {
                                var foundCardViewColumn = false;

                                for (var j = 0; j < self.cardviewcolumns.length; j++) {
                                    if (self.cardviewcolumns[j].datafield === this.datafield) {
                                        this.__width = this.width;
                                        this.width = self.cardviewcolumns[j].width || '';
                                        foundCardViewColumn = true;
                                    }
                                }

                                if (!foundCardViewColumn) {
                                    this.__hidden = this.hidden;
                                    this.hidden = true;
                                }
                            }
                            else {
                                if (self.cardviewcolumns[i]) {
                                    this.__width = this.width;
                                    this.width = self.cardviewcolumns[i];
                                }
                                else if (this.hideable) {
                                    this.__hidden = this.hidden;
                                    this.hidden = true;
                                }
                            }
                        });
                    }
                    this._cardviewmode = true;
                }
                else if (this._cardviewmode) {
                    $.each(this.columns.records, function (i, value) {
                        if (this.__width !== undefined) {
                            this.width = this.__width;
                            delete this.__width;
                        }

                        if (this.__hidden !== undefined) {
                            this.hidden = this.__hidden;
                            delete this.__hidden;
                        }
                    });

                    this._cardviewmode = false;
                }

                if (!this.prerenderrequired) {
                    if (this._rendersortcolumn) {
                        this._rendersortcolumn();
                    }
                    if (this._renderfiltercolumn) {
                        this._renderfiltercolumn();
                    }
                    if (this.showfilterrow && this.filterrow) {
                        this.filterrow.width(this.columnsheader.width());
                        this._updatefilterrowui();
                    }
                    if (this.showeverpresentrow) {
                        if (this.everpresentrowposition !== "bottom") {
                            this.addnewrowtop.width(this.columnsheader.width());
                        }
                        else {
                            this.addnewrowbottom.width(this.columnsheader.width());
                        }
                        this._updateaddnewrowui();
                    }
                    return;
                }

                this._columnsbydatafield = new Array();
                this.columnsheader.find('#columntable' + this.element.id).remove();
                var columnheader = $('<div id="columntable' + this.element.id + '" style="height: 100%; position: relative;"></div>')
                columnheader[0].cells = new Array();

                var k = 0;
                var left = 0;

                var allcharacters = "";
                var totalwidth = this.host.width();
                var hostwidth = totalwidth;

                var pinnedcolumns = new Array();
                var normalcolumns = new Array();
                var indent = this.rowdetails && this.showrowdetailscolumn ? (1 + this.groups.length) * this.groupindentwidth : (this.groups.length) * this.groupindentwidth;

                $.each(this.columns.records, function (i, value) {
                    if (!(this.hidden && this.hideable) && !this.adaptivehidden) {
                        if (this.width != 'auto' && !this._width) {
                            if (this.width < this.minwidth && this.minwidth != 'auto') {
                                totalwidth -= this.minwidth;
                            }
                            else if (this.width > this.maxwidth && this.maxwidth != 'auto') {
                                totalwidth -= this.maxwidth;
                            }
                            else if (this.width.toString().indexOf('%') != -1) {
                                var value = 0;
                                var offset = self.vScrollBar[0].style.visibility == 'hidden' ? 0 : self.scrollbarsize + 5;
                                offset += indent;
                                value = parseFloat(this.width) * (hostwidth - offset) / 100;
                                if (value < this.minwidth && this.minwidth != 'auto') value = this.minwidth;
                                if (value > this.maxwidth && this.maxwidth != 'auto') value = this.maxwidth;
                                totalwidth -= value;
                            }
                            else {
                                if (typeof this.width == 'string') this.width = parseInt(this.width);
                                totalwidth -= this.width;
                            }
                        }
                        else {
                            allcharacters += this.text;
                        }
                    }
                    if (this.pinned || this.grouped || this.checkboxcolumn) {
                        if (self._haspinned) {
                            this.pinned = true;
                        }
                        pinnedcolumns[pinnedcolumns.length] = this;
                    }
                    else {
                        normalcolumns[normalcolumns.length] = this;
                    }
                });

                if (!this.rtl) {
                    for (var i = 0; i < pinnedcolumns.length; i++) {
                        this.columns.replace(i, pinnedcolumns[i]);
                    }
                    for (var j = 0; j < normalcolumns.length; j++) {
                        this.columns.replace(pinnedcolumns.length + j, normalcolumns[j]);
                    }
                }
                else {
                    var p = 0;
                    pinnedcolumns.reverse();
                    for (var i = this.columns.records.length - 1; i >= this.columns.records.length - pinnedcolumns.length; i--) {
                        this.columns.replace(i, pinnedcolumns[p++]);
                    }
                    for (var j = 0; j < normalcolumns.length; j++) {
                        this.columns.replace(j, normalcolumns[j]);
                    }
                }

                var zindex = this.headerZIndex;
                var groupslength = self.groupable ? self.groups.length : 0;
                if (this.rowdetails && this.showrowdetailscolumn) {
                    groupslength++;
                }

                var headerheight = self.columnsheader.height();
                if (this.showfilterrow) {
                    if (!this.columngroups) {
                        headerheight = this.columnsheight;
                    }
                    else {
                        headerheight -= this.filterrowheight;
                    }
                }
                if (this.showeverpresentrow && this.everpresentrowposition !== "bottom") {
                    if (!this.columngroups) {
                        headerheight = this.columnsheight;
                    }
                    else {
                        headerheight -= this.everpresentrowheight;
                    }
                }

                var tableheight = this._gettableheight();

                if (this.virtualsizeinfo && this.virtualsizeinfo.virtualheight > tableheight && !this.scrollbarautoshow) {
                    if (this.groupable && this.groups.length > 0) {
                        if (this.dataview && this.dataview.loadedrootgroups && !this.groupsexpandedbydefault) {
                            var groupsheight = 0;
                            if (!this.pageable) {
                                var groupsheight = this.dataview.loadedrootgroups.length * this.rowsheight;
                            }
                            else if (this.pageable) {
                                for (var q = 0; q < this.dataview.rows.length; q++) {
                                    if (this.dataview.rows[q].group && this.dataview.rows[q].level === 0) {
                                        groupsheight += this.rowsheight;
                                    }
                                }
                            }
                            if (groupsheight > tableheight) {
                                totalwidth -= this.scrollbarsize + 5;
                                hostwidth -= this.scrollbarsize + 5;
                            }
                        }
                        else {
                            totalwidth -= this.scrollbarsize + 5;
                            hostwidth -= this.scrollbarsize + 5;
                        }
                    }
                    else {
                        if (!this.autoheight && this.scrollbarsize > 0) {
                            totalwidth -= this.scrollbarsize + 5;
                            hostwidth -= this.scrollbarsize + 5;
                        }
                    }
                }

                hostwidth -= indent;

                var getcolumnheight = function (datafield, column) {
                    var height = self.columngroupslevel * self.columnsheight;
                    height = height - (column.level * self.columnsheight);
                    return height;
                }
                var frag = document.createDocumentFragment();
                var autoWidth = 0;
                $.each(this.columns.records, function (i, value) {
                    this.height = self.columnsheight;
                    if (self.columngroups) {
                        if (self.columngroups.length) {
                            this.height = getcolumnheight(this.datafield, this);
                            headerheight = this.height;
                        }
                    }

                    var classname = self.toTP('jqx-grid-column-header') + " " + self.toTP('jqx-widget-header');
                    if (self.rtl) {
                        classname += " " + self.toTP('jqx-grid-column-header-rtl');
                    }

                    var pinnedZIndex = !self.rtl ? 150 + zindex - 1 : 150 + zindex + 1;
                    var columnZIndex = !self.rtl ? zindex-- : zindex++;

                    var column = $('<div role="columnheader" style="z-index: ' + columnZIndex + ';position: absolute; height: 100%;" class="' + classname + '"><div style="height: 100%; width: 100%;"></div></div>');

                    if (self.columngroups) {
                        column[0].style.height = headerheight + 'px';
                        column[0].style.bottom = '0px';

                        if (this.pinned) {
                            column[0].style.zIndex = pinnedZIndex;
                        }
                    }

                    this.uielement = column;
                    if (this.classname != '' && this.classname) {
                        column.addClass(this.classname);
                    }

                    var desiredwidth = this.width;
                    var percentage = false;
                    if (this.width === null) this.width = "auto";
                    if (this.width.toString().indexOf('%') != -1 || this._percentagewidth != undefined) {
                        if (this._percentagewidth != undefined) {
                            desiredwidth = parseFloat(this._percentagewidth) * hostwidth / 100;
                        }
                        else {
                            desiredwidth = parseFloat(this.width) * hostwidth / 100;
                        }
                        percentage = true;
                    }

                    if (this.width != 'auto' && !this._width && !percentage) {
                        if (desiredwidth < this.minwidth && this.minwidth != 'auto') {
                            desiredwidth = this.minwidth;
                            this.width = desiredwidth;
                        }
                        if (desiredwidth > this.maxwidth && this.maxwidth != 'auto') {
                            desiredwidth = this.maxwidth;
                            this.width = desiredwidth;
                        }

                        column[0].style.width = parseInt(desiredwidth) + 'px';
                    }
                    else if (percentage) {
                        if (desiredwidth < this.minwidth && this.minwidth != 'auto') {
                            desiredwidth = this.minwidth;
                        }
                        if (desiredwidth > this.maxwidth && this.maxwidth != 'auto') {
                            desiredwidth = this.maxwidth;
                        }

                        if (this._percentagewidth == undefined || this.width.toString().indexOf('%') != -1) {
                            this._percentagewidth = this.width;
                        }
                        column.width(desiredwidth);
                        this.width = desiredwidth;
                    }
                    else if (!this.hidden && !this.adaptivehidden) {
                        var width = Math.floor(totalwidth * (this.text.length / allcharacters.length));
                        autoWidth += width;
                        if (totalwidth - autoWidth < 3 && totalwidth != autoWidth && totalwidth - autoWidth > 0.01) {
                            if (totalwidth - autoWidth === 1) {
                                width++;
                            }
                            else {
                                width += 2;
                            }
                        }
                        else if (i == self.columns.records.length - 1) {
                            if (autoWidth < totalwidth) {
                                width += (totalwidth - autoWidth);
                            }
                        }
                        if (isNaN(width)) {
                            width = this.minwidth;
                        }

                        if (width < 0) {
                            var $element = $('<span>' + this.text + '</span>');
                            $(document.body).append($element);
                            width = 10 + $element.width();
                            $element.remove();
                        }
                        if (width < this.minwidth) {
                            width = this.minwidth;
                        }
                        if (width > this.maxwidth) {
                            width = this.maxwidth;
                        }

                        this._width = 'auto';
                        this.width = width;
                        desiredwidth = this.width;
                        column.width(this.width);
                    }

                    if ((this.hidden && this.hideable) || this.adaptivehidden) {
                        column.css('display', 'none');
                    }

                    var columncontentcontainer = $(column.children()[0]);
                    var menuinnerelementclassname = self.rtl ? self.toTP('jqx-grid-column-menubutton') + " " + self.toTP('jqx-grid-column-menubutton-rtl') : self.toTP('jqx-grid-column-menubutton');
                    menuinnerelementclassname += " " + self.toTP('jqx-icon-arrow-down');
                    var columnsmenu = $('<div style="height: ' + headerheight + 'px; display: none; left: 100%; top: 0%; position: absolute;"><div class="' + menuinnerelementclassname + '" style="width: 100%; height:100%;"></div></div>');

                    if (!self.enableanimations) {
                        columnsmenu.css('margin-left', -16);
                    }
                    if (self.rtl) {
                        columnsmenu.css('left', '0px');
                    }

                    this.columnsmenu = columnsmenu[0];
                    columnheader[0].cells[i] = column[0];
                    columnsmenu[0].style.width = parseInt(self.columnsmenuwidth) + 'px';
                    var showcolumnsmenu = self.columnsmenu;
                    var shouldhandledragdrop = false;
                    var detailscolumn = false;

                    var isgroupcolumn = (self.groupable && groupslength > 0 && k < groupslength) || (self.rowdetails && k < groupslength);
                    if (self.rtl) {
                        isgroupcolumn = (self.groupable && groupslength > 0 && k < groupslength) || (self.rowdetails && k < groupslength);
                        isgroupcolumn &= i > self.columns.records.length - 1 - groupslength;
                    }

                    if (isgroupcolumn) {
                        k++;
                        showcolumnsmenu &= false;
                        this.sortable = false;
                        this.editable = false;
                        detailscolumn = true;
                    }
                    else {
                        var columnContent = this.renderer != null ? this.renderer(this.text, this.align, headerheight) : self._rendercolumnheader(this.text, this.align, headerheight, self);
                        if (columnContent == null) {
                            columnContent = self._rendercolumnheader(this.text, this.align, headerheight, self);
                        }
                        if (this.renderer != null) columnContent = $(columnContent);
                        showcolumnsmenu &= true;
                        shouldhandledragdrop = true;
                    }
                    if (self.WinJS) {
                        MSApp.execUnsafeLocalFunction(function () {
                            columncontentcontainer.append($(columnContent));
                        });
                    }
                    else {
                        if (this.renderer) {
                            columncontentcontainer.append($(columnContent));
                        }
                        else {
                            if (columnContent) {
                                columncontentcontainer[0].innerHTML = columnContent;
                            }
                        }
                    }

                    if (columnContent != null) {
                        var iconscontainer = $('<div class="iconscontainer" style="height: ' + headerheight + 'px; margin-left: -32px; display: block; position: absolute; left: 100%; top: 0%; width: 32px;">'
                            + '<div class="filtericon ' + self.toTP('jqx-widget-header') + '" style="height: ' + headerheight + 'px; float: right; display: none; width: 16px;"><div class="' + self.toTP('jqx-grid-column-filterbutton') + '" style="width: 100%; height:100%;"></div></div>'
                            + '<div class="sortasc ' + self.toTP('jqx-widget-header') + '" style="height: ' + headerheight + 'px; float: right; display: none; width: 16px;"><div class="' + self.toTP('jqx-grid-column-sortascbutton') + ' ' + self.toTP('jqx-icon-arrow-up') + '" style="width: 100%; height:100%;"></div></div>'
                            + '<div class="sortdesc ' + self.toTP('jqx-widget-header') + '" style="height: ' + headerheight + 'px; float: right; display: none; width: 16px;"><div class="' + self.toTP('jqx-grid-column-sortdescbutton') + ' ' + self.toTP('jqx-icon-arrow-down') + '" style="width: 100%; height:100%;"></div></div>'
                            + '<div class="sorticon ' + self.toTP('jqx-widget-header') + '" style="height: ' + headerheight + 'px; float: right; visibility: hidden; width: 16px;"><div class="' + self.toTP('jqx-grid-column-sorticon') + ' ' + self.toTP('jqx-icon-arrow-down') + '" style="width: 100%; height:100%;"></div></div>'
                            + '</div>');
                        columnsmenu.addClass(self.toTP('jqx-widget-header'));
                        columncontentcontainer.append(iconscontainer);

                        var iconschildren = iconscontainer.children();
                        this.sorticon = iconschildren[3];
                        this.sortasc = iconschildren[1];
                        this.sortdesc = iconschildren[2];
                        this.filtericon = iconschildren[0];

                        this.iconscontainer = iconscontainer;
                        if (self.rtl) {
                            iconscontainer.css('margin-left', '0px');
                            iconscontainer.css('left', '0px');
                            $(this.sorticon).css('float', 'left');
                            $(this.sortasc).css('float', 'left');
                            $(this.filtericon).css('float', 'left');
                            $(this.sortdesc).css('float', 'left');
                        }
                        if (!self.autoshowfiltericon && this.filterable) {
                            $(this.filtericon).css('display', 'block');
                        }

                    }

                    this.element = column[0];
                    if (showcolumnsmenu) {
                        self._handlecolumnsmenu(self, columncontentcontainer, column, columnsmenu, this);
                        if (!this.menu) columnsmenu.hide();
                    }

                    frag.appendChild(column[0]);

                    if (self.groupable && shouldhandledragdrop) {
                        column[0].id = self.dataview.generatekey();
                        if (self._handlecolumnstogroupsdragdrop) {
                            self._handlecolumnstogroupsdragdrop(this, column);
                        }
                        else throw new Error('jqxGrid: Missing reference to jqxgrid.grouping.js.');
                    }
                    if (self.columnsreorder && this.draggable && self._handlecolumnsdragreorder) {
                        self._handlecolumnsdragreorder(this, column);
                    }

                    var columnitem = this;
                    columnitem._applyStyle();

                    self.addHandler(column, 'mouseenter', function (event) {
                        columnitem.hovered = true;
                        columnitem._applyStyle();
                    });
                    self.addHandler(column, 'mouseleave', function (event) {
                        columnitem.hovered = false;
                        columnitem._applyStyle();
                    });

                    var toggleColumnSelection = function (columnitem, event, select) {
                        if (columnitem.selectable) {
                            var rows = self.getrows();


                            if (columnitem.selected === undefined) {
                                columnitem.selected = false;
                            }

                            if (!event.shiftKey || self._clickedcolumn === undefined) {
                                self._clickedcolumn = columnitem;
                            }

                            if (event.shiftKey && self._clickedcolumn && select === undefined) {
                                var startIndex = self.columns.records.indexOf(self._clickedcolumn)
                                var endIndex = self.columns.records.indexOf(columnitem);
                                var start = Math.min(startIndex, endIndex);
                                var end = Math.max(startIndex, endIndex);

                                self.clearselection();

                                for (var i = start; i <= end; i++) {
                                    toggleColumnSelection(self.columns.records[i], event, true);
                                }

                                self._renderrows(this.virtualsizeinfo);
                                return;
                            }


                            if (select) {
                                columnitem.selected = true;
                            }
                            else {
                                if (!event.ctrlKey) {
                                    self.clearselection();
                                }
                                columnitem.selected = !columnitem.selected;
                            }


                            for (var i = 0; i < rows.length; i++) {
                                self._applycellselection(rows[i].boundindex, columnitem.displayfield, columnitem.selected, false, false);

                            }

                            if (columnitem.selected) {
                                columnitem.element.setAttribute('selected', '');
                            }
                            else {
                                columnitem.element.removeAttribute('selected');
                            }

                            columnitem._applyStyle();

                            if (select === undefined) {
                                self.virtualsizeinfo = self._calculatevirtualheight();
                                self._renderrows(self.virtualsizeinfo);
                            }
                        }
                    }

                    self.addHandler(column, 'click', function (event) {
                        if (columnitem.checkboxcolumn)
                            return true;

                        if (self.sorttogglestates > 0 && self._togglesort) {
                            if (!self._loading) {
                                if (self.suspendClick) {
                                    return true;
                                }

                                if (self.sortmode !== "many") {
                                    self._togglesort(columnitem);
                                }
                                else if (self.sortmode === "many" && !self.sortmodekey) {
                                    self._togglesort(columnitem);
                                }
                                else if (self.sortmode === "many" && self.sortmodekey === "Control" && event.ctrlKey) {
                                    self._togglesort(columnitem);
                                }
                                else if (self.sortmode === "many" && self.sortmodekey === "ctrlKey" && event.ctrlKey) {
                                    self._togglesort(columnitem);
                                }
                            }
                        }

                        toggleColumnSelection(columnitem, event);

                        event.preventDefault();
                        self._raiseEvent(7, { column: columnitem.getcolumnproperties(), datafield: columnitem.datafield, originalEvent: event });
                    });

                    columnitem.toggleSelection = toggleColumnSelection;
                    if (columnitem.resizable && self.columnsresize && !detailscolumn) {
                        var isTouchDevice = false;
                        var eventname = 'mousemove';
                        if (self.isTouchDevice() && self.touchmode !== true) {
                            isTouchDevice = true;
                            eventname = $.jqx.mobile.getTouchEventName('touchstart');
                        }

                        self.addHandler(column, eventname, function (event) {
                            var pagex = parseInt(event.pageX);
                            var offset = 5;
                            var columnleft = parseInt(column.coord().left);
                            if (self.hasTransform) {
                                columnleft = $.jqx.utilities.getOffset(column).left;
                            }
                            if (self.resizing) {
                                return true;
                            }

                            if (self.columnsresize === false) {
                                return;
                            }

                            if (self._handlecolumnsresize) {
                                if (isTouchDevice) {
                                    var touches = self.getTouches(event);
                                    var touch = touches[0];
                                    pagex = touch.pageX;
                                    offset = 40;
                                    if (pagex >= columnleft + columnitem.width - offset) {
                                        self.resizablecolumn = { columnelement: column, column: columnitem };
                                        column.css('cursor', "col-resize");
                                    }
                                    else {
                                        column.css('cursor', "");
                                        self.resizablecolumn = null;
                                    }
                                    return true;
                                }

                                var colwidth = columnitem.width;
                                if (self.rtl) colwidth = 0;

                                if (pagex >= columnleft + colwidth - offset) {
                                    if (pagex <= columnleft + colwidth + offset) {
                                        self.resizablecolumn = { columnelement: column, column: columnitem };
                                        column.css('cursor', "col-resize");
                                        return false;
                                    }
                                    else {
                                        column.css('cursor', "");
                                        self.resizablecolumn = null;
                                    }
                                }
                                else {
                                    column.css('cursor', "");
                                    if (pagex < columnleft + colwidth - offset) {
                                        if (!columnitem._animating && !columnitem._menuvisible) {
                                            column.mouseenter();
                                        }
                                    }

                                    self.resizablecolumn = null;
                                }
                            }
                        });
                    }

                    column.css('left', left);

                    if (!(this.hidden && this.hideable) && !this.adaptivehidden) {
                        left += desiredwidth;
                    }

                    if (columnitem.rendered) {
                        var result = columnitem.rendered($(columncontentcontainer[0].firstChild), columnitem.align, headerheight);
                        if (result && iconscontainer != null) {
                            iconscontainer.hide();
                        }
                    }
                    if (columnitem.checkboxcolumn) {
                        if (iconscontainer) {
                            iconscontainer.hide();
                        }
                        if (!self.host.jqxCheckBox) {
                            throw new Error("jqxGrid: Missing reference to jqxcheckbox.js");
                        }

                        columncontentcontainer.html('<div style="cursor: pointer; margin-left: 3px; top: 50%; margin-top: -9px; position: relative;"></div>');
                        var checkboxelement = columncontentcontainer.find('div:first');
                        checkboxelement.jqxCheckBox({ rippleEffect: false, _canFocus: false, disabled: self.disabled, disabledContainer: true, theme: self.theme, enableContainerClick: false, animationShowDelay: 0, animationHideDelay: 0 });
                        checkboxelement.addClass(self.toThemeProperty('jqx-checkbox'));
                        columnitem.checkboxelement = checkboxelement;

                        var checkboxinstance = checkboxelement.data().jqxCheckBox.instance;
                        self._checkboxcolumn = columnitem;
                        checkboxinstance.updated = function (event, checked, oldchecked) {
                            self._checkboxcolumnupdating = true;
                            if (self.disabled) {
                                checkboxelement.jqxCheckBox({ disabled: self.disabled });
                                checked = oldchecked;
                            }

                            if (checked) {
                                self.selectallrows();
                            }
                            else {
                                self.unselectallrows();
                            }
                            self._checkboxcolumnupdating = false;
                        }
                    }
                });

                if (left > 0) {
                    this.columnsheader.width(2 + left);
                }
                else {
                    this.columnsheader.width(left);
                }
                columnheader[0].appendChild(frag);
                columnheader[0].setAttribute('role', 'row');
                this.columnsrow = columnheader;
                self.columnsheader.append(columnheader);
                if (this.showfilterrow && this._updatefilterrow) {
                    if (!this.columngroups) {
                        columnheader.height(this.columnsheight);
                    }
                    else {
                        columnheader.height(this.columngroupslevel * this.columnsheight);
                    }

                    if (!this.filterrow) {
                        var filterrow = $("<div style='position: relative !important; '></div>");
                        filterrow[0].id = "filterrow." + this.element.id;
                        filterrow.height(this.filterrowheight);
                        this.filterrow = filterrow;
                    }
                    this.filterrow.width(2 + left);

                    this.columnsheader.append(this.filterrow);
                    this._updatefilterrow();
                }
                if (this.showeverpresentrow && this.everpresentrowposition !== "bottom") {
                    if (!this.columngroups) {
                        columnheader.height(this.columnsheight);
                    }
                    else {
                        columnheader.height(this.columngroupslevel * this.columnsheight);
                    }
                    if (!this.addnewrowtop) {
                        var addnewrowtop = $("<div style='position: relative !important; z-index:" + this.headerZIndex + ";'></div>");
                        addnewrowtop[0].id = "addnewrowtop." + this.element.id;
                        addnewrowtop.height(this.everpresentrowheight);
                        this.addnewrowtop = addnewrowtop;
                    }
                    this.addnewrowtop.width(2 + left);

                    if (this.everpresentrowposition == "topAboveFilterRow") {
                        if (this.filterrow) {
                            this.addnewrowtop.insertBefore(this.filterrow);
                        }
                        else {
                            this.columnsheader.append(this.addnewrowtop);
                        }
                    }
                    else {
                        this.columnsheader.append(this.addnewrowtop);
                    }
                    this._updateaddnewrow();
                }
                else if (this.showeverpresentrow && this.everpresentrowposition === "bottom") {
                    if (!this.addnewrowbottom) {
                        var addnewrowbottom = $("<div style='position: relative !important; z-index:" + this.headerZIndex + ";'></div>");
                        addnewrowbottom[0].id = "addnewrowbottom." + this.element.id;
                        addnewrowbottom.height(this.everpresentrowheight);
                        this.addnewrowbottom = addnewrowbottom;
                    }
                    this.addnewrowbottom.width(2 + left);

                    this.addnewrow.append(this.addnewrowbottom);
                    this._updateaddnewrow();
                }

                if (left == 0)
                    columnheader[0].style.visibility = "hidden";
                else
                    columnheader[0].style.visibility = "inherit";

                columnheader.width(left);
                if (this._handlecolumnsdragdrop) {
                    this._handlecolumnsdragdrop();
                }
                if (this._handlecolumnsreorder) {
                    this._handlecolumnsreorder();
                }
                if (this._rendersortcolumn) {
                    this._rendersortcolumn();
                }
                if (this._renderfiltercolumn) {
                    this._renderfiltercolumn();
                }
                if (this._handlecolumnsresize) {
                    this._handlecolumnsresize();
                }
                if (this.columngroups) {
                    this._rendercolumngroups();
                }
                if (this._updatecheckboxselection) {
                    this._updatecheckboxselection();
                }
            },

            _rendercolumngroups: function () {
                if (!this.columngroups) return;
                var pinnedColumns = 0;
                for (var i = 0; i < this.columns.records.length; i++) {
                    if (this.columns.records[i].pinned) pinnedColumns++;
                }

                var zindex = this.headerZIndex - pinnedColumns + this.columns.records.length;
                var self = this.that;
                var classname = self.toTP('jqx-grid-column-header') + " " + self.toTP('jqx-grid-columngroup-header') + " " + self.toTP('jqx-widget-header');
                if (self.rtl) {
                    classname += " " + self.toTP('jqx-grid-columngroup-header-rtl');
                }
                var columnheader = this.columnsheader.find('#columntable' + this.element.id);
                columnheader.find('jqx-grid-columngroup-header').remove();

                for (var j = 0; j < this.columngroupslevel - 1; j++) {
                    for (var i = 0; i < this.columngroups.length; i++) {
                        var group = this.columngroups[i];
                        var level = group.level;
                        if (level !== j)
                            continue;

                        var top = level * this.columnsheight;
                        var left = 99999;
                        if (group.groups) {
                            var getwidth = function (group) {
                                var width = 0;
                                for (var j = 0; j < group.groups.length; j++) {
                                    var currentgroup = group.groups[j];
                                    if (!currentgroup.groups) {
                                        if (!currentgroup.hidden) {
                                            width += currentgroup.width;
                                            left = Math.min(parseFloat(currentgroup.element.style.left), left);
                                        }
                                    }
                                    else {
                                        width += getwidth(currentgroup);
                                    }
                                }
                                return width;
                            }
                            group.width = getwidth(group);
                            group.left = left;

                            var height = this.columnsheight;
                            var columnZIndex = zindex--;
                            var column = $('<div role="columnheader" style="z-index: ' + columnZIndex + ';position: absolute;" class="' + classname + '"></div>');
                            var element = $(this._rendercolumnheader(group.text, group.align, this.columnsheight, this));
                            if (group.renderer) {
                                var element = $("<div style='height: 100%; width: 100%;'></div>");
                                var content = group.renderer(group.text, group.align, height);
                                element.html(content);
                            }

                            column.append(element);
                            column[0].style.left = left + 'px';
                            if (left === 0) {
                                column[0].style.borderLeftColor = 'transparent';
                            }

                            if (!this.showcolumnheaderlines) {
                                column[0].style.borderRightColor = 'transparent';
                                column[0].style.borderBottomColor = "transparent";
                                column[0].style.boxShadow = "none";
                            }

                            column[0].style.top = top + 'px';
                            column[0].style.height = height + 'px';
                            column[0].style.width = -1 + group.width + 'px';
                            columnheader.append(column);
                            group.element = column;
                            if (group.rendered) {
                                group.rendered(element, group.align, height);
                            }
                        }
                    }
                }
            },

            _resizecolumngroups: function () {
                if (!this.columngroups) return;
                for (var i = 0; i < this.columngroups.length; i++) {
                    var group = this.columngroups[i];
                    var level = group.level;
                    var top = level * this.columnsheight;
                    var left = 99999;
                    if (group.groups) {
                        var getwidth = function (group) {
                            var width = 0;
                            for (var j = 0; j < group.groups.length; j++) {
                                var currentgroup = group.groups[j];
                                if (!currentgroup.groups) {
                                    if (!currentgroup.hidden) {
                                        width += currentgroup.width;
                                        left = Math.min(parseFloat(currentgroup.element.style.left), left);
                                    }
                                }
                                else {
                                    width += getwidth(currentgroup);
                                }
                            }
                            return width;
                        }
                        group.width = getwidth(group);
                        group.left = left;

                        var height = this.columnsheight;
                        var column = group.element;
                        column[0].style.left = left + 'px';
                        column[0].style.top = top + 'px';
                        column[0].style.height = height + 'px';
                        column[0].style.width = -1 + group.width + 'px';
                    }
                }
            },

            _handlecolumnsmenu: function (self, columncontentcontainer, column, columnsmenu, columnitem) {
                self.dragmousedown = null;
                columnsmenu[0].id = self.dataview.generatekey();

                columncontentcontainer.append(columnsmenu);
                column[0].columnsmenu = columnsmenu[0];
                columnitem.element = column[0];

                var menuoffset = this.columnsmenuwidth + 1;

                var showcolumnsmenu = function () {
                    if (!columnitem.menu)
                        return false;

                    if (!self.resizing) {
                        if (columnitem._menuvisible && self._hasOpenedMenu) return false;

                        columnitem._animating = true;
                        if (self.menuitemsarray && self.menuitemsarray.length > 0) {
                            if (!self.enableanimations) {
                                columnsmenu.css('display', 'block');
                                var left = !self.rtl ? -48 : 16;
                                columnitem.iconscontainer.css('margin-left', left + 'px');
                                columnitem._animating = false;
                                columnitem._menuvisible = true;
                            }
                            else {
                                columnsmenu.css('display', 'block');
                                columnsmenu.stop();
                                columnitem.iconscontainer.stop();
                                if (!self.rtl) {
                                    columnsmenu.css('margin-left', '0px');
                                    columnsmenu.animate({
                                        'margin-left': -menuoffset
                                    }, 'fast', function () {
                                        columnsmenu.css('display', 'block');
                                        columnitem._animating = false;
                                        columnitem._menuvisible = true;
                                    }
                                    );
                                }
                                else {
                                    columnsmenu.css('margin-left', -menuoffset);
                                    columnsmenu.animate({
                                        'margin-left': '0px'
                                    }, 'fast', function () {
                                        columnsmenu.css('display', 'block');
                                        columnitem._animating = false;
                                        columnitem._menuvisible = true;
                                    }
                                    );
                                }

                                var left = !self.rtl ? -(32 + menuoffset) : menuoffset;
                                columnitem.iconscontainer.animate({
                                    'margin-left': left
                                }, 'fast');
                            }
                        }
                    }
                }

                var enterEventName = "mouseenter";
                if (self.isTouchDevice()) {
                    enterEventName = "touchstart";
                }

                self.addHandler(column, enterEventName, function (event) {
                    var pagex = parseInt(event.pageX);
                    var offset = self.columnsresize && columnitem.resizable ? 3 : 0;
                    var columnleft = parseInt(column.coord().left);
                    if (self.hasTransform) {
                        columnleft = $.jqx.utilities.getOffset(column).left;
                    }

                    var colwidth = columnitem.width;
                    if (self.rtl) colwidth = 0;

                    if (offset != 0) {
                        if (pagex >= columnleft + colwidth - offset) {
                            if (pagex <= columnleft + colwidth + offset) {
                                return false;
                            }
                        }
                    }

                    var scrolling = self.vScrollInstance.isScrolling();
                    if (columnitem.menu && self.autoshowcolumnsmenubutton && !scrolling && !self.disabled) {
                        showcolumnsmenu();
                    }
                });

                if (!self.autoshowcolumnsmenubutton) {
                    columnsmenu.css('display', 'block');
                    var left = !self.rtl ? -48 : 16;
                    columnitem.iconscontainer.css('margin-left', left + 'px');
                    if (!self.rtl) {
                        columnsmenu.css({ 'margin-left': -menuoffset });
                    }
                    else {
                        columnsmenu.css({ 'margin-left': '0px' });
                    }
                }

                self.addHandler(column, 'mouseleave', function (event) {
                    if (self.menuitemsarray && self.menuitemsarray.length > 0 && columnitem.menu) {
                        var menu = $.data(document.body, "contextmenu" + self.element.id);
                        if (menu != undefined && columnsmenu[0].id == menu.columnsmenu.id) {
                            return;
                        }

                        if (self.autoshowcolumnsmenubutton) {
                            if (!self.enableanimations) {
                                columnsmenu.css('display', 'none');
                                var left = !self.rtl ? -32 : 0;
                                columnitem.iconscontainer.css('margin-left', left + 'px');
                                columnitem._menuvisible = false;
                            }
                            else {
                                if (!self.rtl) {
                                    columnsmenu.css('margin-left', -menuoffset);
                                }
                                else columnsmenu.css('margin-left', '0px');

                                columnsmenu.stop();
                                columnitem.iconscontainer.stop();
                                if (!self.rtl) {
                                    columnsmenu.animate({
                                        'margin-left': 0
                                    }, 'fast', function () {
                                        columnsmenu.css('display', 'none');
                                        columnitem._menuvisible = false;
                                    });
                                }
                                else {
                                    columnsmenu.animate({
                                        'margin-left': -menuoffset
                                    }, 'fast', function () {
                                        columnsmenu.css('display', 'none');
                                        columnitem._menuvisible = false;
                                    });
                                }

                                var left = !self.rtl ? -32 : 0;
                                columnitem.iconscontainer.animate({
                                    'margin-left': left
                                }, 'fast');
                            }
                        }
                    }
                });

                var canopen = true;
                var openedmenu = "";
                var $filtericon = $(columnitem.filtericon);

                self.addHandler(columnsmenu, 'mousedown', function (event) {
                    if (!self.gridmenu) self._initmenu();
                    canopen = !$.data(self.gridmenu[0], 'contextMenuOpened' + self.gridmenu[0].id);
                    openedmenu = $.data(document.body, "contextmenu" + self.element.id);
                    if (openedmenu != null) {
                        openedmenu = openedmenu.column.datafield;
                    }
                });

                self.addHandler($filtericon, 'mousedown', function (event) {
                    if (!self.gridmenu) self._initmenu();
                    canopen = !$.data(self.gridmenu[0], 'contextMenuOpened' + self.gridmenu[0].id);
                    openedmenu = $.data(document.body, "contextmenu" + self.element.id);
                    if (openedmenu != null) {
                        openedmenu = openedmenu.column.datafield;
                    }
                });

                var opencolumnsmenu = function () {
                    if (!columnitem.menu)
                        return false;

                    if (!self.gridmenu) {
                        self._initmenu();
                    }

                    if (self.disabled)
                        return false;

                    for (var i = 0; i < self.columns.records.length; i++) {
                        if (self.columns.records[i].datafield != columnitem.datafield) {
                            self.columns.records[i]._menuvisible = false;
                        }
                    }

                    var offset = columnsmenu.coord(true);
                    var top = columnsmenu.height();

                    if (!canopen) {
                        canopen = true;

                        if (openedmenu == columnitem.datafield) {
                            self._closemenu();
                            return false;
                        }
                    }

                    var hostOffset = self.host.coord(true);
                    if (self.hasTransform) {
                        hostOffset = $.jqx.utilities.getOffset(self.host);
                        offset = $.jqx.utilities.getOffset(columnsmenu);
                    }

                    if (hostOffset.left + self.host.width() > parseInt(offset.left) + self.gridmenu.width()) {
                        self.gridmenu.jqxMenu('open', offset.left, offset.top + top);
                    }
                    else {
                        self.gridmenu.jqxMenu('open', columnsmenu.width() + offset.left - self.gridmenu.width(), offset.top + top);
                    }
                    if (self.gridmenu.width() < 100) {
                        self._arrangemenu();
                    }

                    if (self.adaptive && self.element.offsetWidth < self.adaptivewidth) {
                        self.gridmenu.jqxMenu('close');
                        self.gridmenu.jqxMenu('open', hostOffset.left, offset.top + top);

                        var width = 0;
                        for (var i = 0; i < self.columns.records.length; i++) {
                            var column = self.columns.records[i];

                            if (column.hidden || column.adaptivehidden || column.columntype === "adaptive") {
                                continue;
                            }

                            width += column.adaptivewidth;
                        }
                        self.gridmenu.width(width);
                        self.gridmenu.height(self.content.height());
                        //     self._arrangemenu();
                        //       self.gridmenu.jqxMenu({ height: self.element.offsetHeight });
                    }

                    if (!self.filterable || (self.filterable && self.showfilterrow)) {
                        setTimeout(function () {
                            self.gridmenu.focus();
                            var items = self.gridmenu.find('.jqx-item');
                            for (var i = 0; i < items.length; i++) {
                                if (items[i].active) {
                                    items[i].active = false;
                                }
                            }

                            var item = items[0];

                            if (items[0].className.indexOf('disabled') >= 0) {
                                item = items[1];
                            }

                            $(items).removeClass('jqx-fill-state-focus');
                            $(item).addClass('jqx-fill-state-focus');
                            item.active = true;

                        }, 225);
                    }
                    self._hasOpenedMenu = true;

                    var sortascmenuitem = self._getmenuitembyindex(0);
                    var sortdescmenuitem = self._getmenuitembyindex(1);
                    var sortremovemenuitem = self._getmenuitembyindex(2);
                    var groupmenuitem = self._getmenuitembyindex(3);
                    var groupremoveitem = self._getmenuitembyindex(4);
                    var filteritem = self._getmenuitembyindex(5);

                    if (sortascmenuitem != null && sortdescmenuitem != null && sortremovemenuitem != null) {
                        var sortable = columnitem.sortable && self.sortable;
                        self.gridmenu.jqxMenu('disable', sortascmenuitem.id, !sortable);
                        self.gridmenu.jqxMenu('disable', sortdescmenuitem.id, !sortable);
                        self.gridmenu.jqxMenu('disable', sortremovemenuitem.id, !sortable);

                        if (columnitem.displayfield != undefined) {
                            var sortinfo = self.getsortinformation();

                            var shouldUpdateItem = (sortinfo && sortinfo.sortcolumns && sortinfo.sortcolumns.find(function (column) {
                                return column.dataField === columnitem.displayfield;
                            }));

                            if (self.sortcolumn == columnitem.displayfield || shouldUpdateItem) {
                                var sortinfo = self.getsortinformation();
                                if (sortable) {
                                    if (sortinfo.sortdirection.ascending) {
                                        self.gridmenu.jqxMenu('disable', sortascmenuitem.id, true);
                                    }
                                    else {
                                        self.gridmenu.jqxMenu('disable', sortdescmenuitem.id, true);
                                    }
                                }
                            }
                            else {
                                self.gridmenu.jqxMenu('disable', sortremovemenuitem.id, true);
                            }
                        }
                    }
                    if (groupmenuitem != null && groupremoveitem != null) {
                        if (!self.groupable || !columnitem.groupable) {
                            self.gridmenu.jqxMenu('disable', groupremoveitem.id, true);
                            self.gridmenu.jqxMenu('disable', groupmenuitem.id, true);
                        }
                        else {
                            if (self.groups && self.groups.indexOf(columnitem.datafield) != -1) {
                                self.gridmenu.jqxMenu('disable', groupmenuitem.id, true);
                                self.gridmenu.jqxMenu('disable', groupremoveitem.id, false);
                            }
                            else {
                                self.gridmenu.jqxMenu('disable', groupmenuitem.id, false);
                                self.gridmenu.jqxMenu('disable', groupremoveitem.id, true);
                            }
                        }
                    }
                    if (filteritem != null) {
                        self.menuOwner = columnitem;
                        self._updatefilterpanel(self, filteritem, columnitem);

                        var itemscount = 0;
                        if (self.sortable && self._togglesort && self.showsortmenuitems) {
                            itemscount += 3;
                        }

                        if (self.groupable && self.addgroup && self.showgroupmenuitems) {
                            itemscount += 2;
                        }

                        var height = itemscount * 36 + 6;
                        var measureHeight = self._measureMenuElement();
                        var height = itemscount * measureHeight + 20;

                        if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                            height += 20;
                            $(filteritem).height(220);
                        }
                        if (self.isTouchDevice()) {
                            height += 10;
                        }

                        if (self.filterable && self.showfiltermenuitems) {
                            if (!columnitem.filterable) {
                                self.gridmenu.height(height);
                                $(filteritem).css('display', 'none');
                            }
                            else {
                                self.gridmenu.height(height + 230);
                                $(filteritem).css('display', 'block');
                            }
                        }
                    }

                    if (self.columnmenuopening) {
                        var result = self.columnmenuopening(self.gridmenu, columnitem.displayfield, self.gridmenu.height());
                        if (false === result) {
                            setTimeout(function () {
                                self._closemenu();
                            });
                        }
                    }
                    $.data(document.body, "contextmenu" + self.element.id, { column: columnitem, columnsmenu: columnsmenu[0] });
                }

                self.addHandler($filtericon, 'click', function (event) {
                    if (!columnitem.menu)
                        return false;
                    if (!self.showfilterrow) {
                        if (columnsmenu[0].style.display != "block") {
                            column.trigger('mouseenter');
                        }
                        setTimeout(function () {
                            if (columnsmenu[0].style.display != "block") {
                                column.trigger('mouseenter');
                            }
                            opencolumnsmenu();
                        }, 200);
                    }
                    return false;
                });

                self.addHandler(columnsmenu, 'click', function (event) {
                    if (!columnitem.menu)
                        return false;

                    opencolumnsmenu();
                    return false;
                });
                if (self.isTouchDevice()) {
                    self.addHandler(columnsmenu, $.jqx.mobile.getTouchEventName('touchstart'), function (event) {
                        if (!columnitem.menu)
                            return false;

                        if (!self._hasOpenedMenu) {
                            opencolumnsmenu();
                        }
                        else {
                            self._closemenu();
                        }

                        return false;
                    });
                }
            },

            _removecolumnhandlers: function (columnitem) {
                var self = this.that;
                var column = $(columnitem.element);
                if (column.length > 0) {
                    self.removeHandler(column, 'mouseenter');
                    self.removeHandler(column, 'mouseleave');
                    var $filtericon = $(columnitem.filtericon);
                    self.removeHandler($filtericon, 'mousedown');
                    self.removeHandler($filtericon, 'click');
                    self.removeHandler(column, 'click');
                    self.removeHandler(column, 'mousemove');
                    if (self.columnsreorder) {
                        self.removeHandler(column, 'mousedown.drag');
                        self.removeHandler(column, 'mousemove.drag');
                    }
                    self.removeHandler(column, 'dragstart');
                    if (column[0].columnsmenu) {
                        var columnsmenu = $(column[0].columnsmenu);
                        self.removeHandler(columnsmenu, 'click');
                        self.removeHandler(columnsmenu, 'mousedown');
                        self.removeHandler(columnsmenu, $.jqx.mobile.getTouchEventName('touchstart'));
                    }
                }
            },

            _rendercolumnheader: function (text, align, headerheight, self) {
                var margin = '8px';

                if (self.columngroups) {
                    margin = (headerheight / 2 - this._columnheight / 2);
                    if (margin < 0) {
                        margin = 6;
                    }
                    margin += 'px';
                }
                else {
                    if (this.columnsheight != 32) {
                        margin = (this.columnsheight / 2 - this._columnheight / 2);
                        if (margin < 0) {
                            margin = 6;
                        }
                        margin += 'px';
                    }
                }

                if (this.enableellipsis) {
                    if (align == "left") {
                        return '<div style="padding-bottom: 2px; overflow: hidden; text-overflow: ellipsis; text-align: ' + align + '; margin-left: 4px; margin-right: 2px; line-height: ' + headerheight + 'px;">' + '<span style="text-overflow: ellipsis; cursor: default;">' + text + '</span>' + '</div>';
                    }
                    else {
                        return '<div style="padding-bottom: 2px; overflow: hidden; text-overflow: ellipsis; text-align: ' + align + '; margin-left: 2px; margin-right: 4px; line-height: ' + headerheight + 'px;">' + '<span style="text-overflow: ellipsis; cursor: default;">' + text + '</span>' + '</div>';
                    }
                }

                if (align == 'center' || align == 'middle')
                    return '<div style="padding-bottom: 2px; text-align: center; line-height: ' + headerheight + 'px;">' + '<a href="#">' + text + '</a>' + '</div>';

                var link = '<a style="line-height: ' + headerheight + 'px; float: ' + align + ';" href="#">' + text + '</a>';
                return link;
            },

            _renderrows: function (virtualsizeinfo, forceVirtualRefresh, reason) {
                var self = this.that;

                if ((this.pageable || this.groupable) && (this.autoheight || this.autorowheight)) {
                    if (this.table != null && this.table[0].rows != null && this.table[0].rows.length < this.dataview.rows.length) {
                        self.prerenderrequired = true;
                    }
                }

                if (!this.pageable && (this.autoheight || this.autorowheight) && (this.virtualmode || this.unboundmode)) {
                    var recordscount = this.source.totalrecords;
                    if (!isNaN(recordscount)) {
                        if (this.table != null && this.table[0].rows != null && this.table[0].rows.length != recordscount) {
                            self.prerenderrequired = true;
                        }
                    }
                }
                if ((this.autoheight || this.autorowheight) && !self.prerenderrequired) {
                    if (this.table && this.table[0].rows) {
                        if (this.table[0].rows.length < this.dataview.records.length) {
                            if (this.pageable && this.table[0].rows.length < this.dataview.pagesize) {
                                self.prerenderrequired = true;
                            }
                            else if (!this.pageable) {
                                self.prerenderrequired = true;
                            }
                        }
                        if (this.table[0].rows.length < this.dataview.cachedrecords.length) {
                            if (this.pageable && this.table[0].rows.length < this.dataview.pagesize) {
                                self.prerenderrequired = true;
                            }
                            else if (!this.pageable) {
                                self.prerenderrequired = true;
                            }
                        }
                    }
                }

                self._prerenderrows(virtualsizeinfo);
                if (self._requiresupdate) {
                    self._requiresupdate = false;
                    self._updatepageviews();
                }

                var callrenderrows = function () {
                    if (self._loading) return;
                    if (self.WinJS) {
                        MSApp.execUnsafeLocalFunction(function () {
                            self._rendervisualrows();
                        });
                    }
                    else {
                        self._rendervisualrows();
                    }

                    if (self.virtualmode && self.showaggregates && self._updateaggregates) {
                        self.refreshaggregates();
                    }
                }
                var oldie = $.jqx.browser.msie && $.jqx.browser.version < 10;

                if (this.virtualmode) {
                    var loadondemand = function () {
                        if (self.rendergridrows) {
                            var startboundindex = self._startboundindex;
                            if (startboundindex == undefined) startboundindex = 0;
                            var endboundindex = startboundindex + 1 + self.dataview.pagesize;
                            if (startboundindex != null && endboundindex != null) {
                                var isdataadapter = self.source._source ? true : false;
                                var sourcestartindex = !isdataadapter ? self.source.recordstartindex : self.source._source.recordstartindex;

                                if (sourcestartindex != startboundindex || forceVirtualRefresh == true) {
                                    if (!isdataadapter) {
                                        self.source.recordstartindex = startboundindex;
                                        self.source.recordendindex = endboundindex;
                                    }
                                    else {
                                        if (endboundindex >= self.source._source.totalrecords) {
                                            endboundindex = self.source._source.totalrecords;
                                            startboundindex = endboundindex - self.dataview.pagesize - 1;
                                            if (startboundindex < 0) startboundindex = 0;
                                            if (self.source._source.recordendindex == endboundindex && self.source._source.recordstartindex == startboundindex) {
                                                return;
                                            }
                                        }

                                        self.source._source.recordstartindex = startboundindex;
                                        self.source._source.recordendindex = endboundindex;
                                    }
                                    self.updatebounddata('cells');
                                }
                            }
                        }
                    }

                    if (this.loadondemand) {
                        callrenderrows();
                        loadondemand();
                        this.loadondemand = false;
                    }
                    var ie10 = this._browser == undefined ? this._isIE10() : this._browser;

                    if (this.editable && this.editcell && !this.vScrollInstance.isScrolling() && !this.hScrollInstance.isScrolling()) {
                        callrenderrows();
                    }
                    else {
                        if (this.autoheight) {
                            callrenderrows();
                        }
                        else {
                            if (ie10 || oldie || (navigator && navigator.userAgent.indexOf('Safari') != -1)) {
                                if (this._scrolltimer != null) {
                                    clearTimeout(this._scrolltimer);
                                }
                                this._scrolltimer = setTimeout(function () {
                                    callrenderrows();
                                }, 5);
                            }
                            else {
                                callrenderrows();
                            }
                        }
                    }
                }
                else {
                    if (this.scrollmode == 'deferred' && (this.hScrollInstance.isScrolling() || this.vScrollInstance.isScrolling())) {
                        if (this._scrolltimer != null) {
                            clearInterval(this._scrolltimer);
                        }
                        var row = this._getfirstvisualrow();
                        if (row != null) {
                            var renderer = function (data) {
                                if (row == null) return "";
                                var table = "<table>";
                                var columns = self.deferreddatafields;
                                if (columns == null) {
                                    if (self.columns.records.length > 0) {
                                        columns = new Array();
                                        columns.push(self.columns.records[0].displayfield);
                                    }
                                }

                                for (var i = 0; i < columns.length; i++) {
                                    var field = columns[i];
                                    var column = self._getcolumnbydatafield(field);
                                    if (column) {
                                        var cellvalue = self._getcellvalue(column, row);
                                        if (column.cellsformat != '') {
                                            if ($.jqx.dataFormat) {
                                                if ($.jqx.dataFormat.isDate(cellvalue)) {
                                                    cellvalue = $.jqx.dataFormat.formatdate(cellvalue, column.cellsformat, self.gridlocalization);
                                                }
                                                else if ($.jqx.dataFormat.isNumber(cellvalue)) {
                                                    cellvalue = $.jqx.dataFormat.formatnumber(cellvalue, column.cellsformat, self.gridlocalization);
                                                }
                                            }
                                        }
                                        table += "<tr><td>" + cellvalue + "</td></tr>";
                                    }
                                }
                                table += "</table>";
                                return table;
                            }

                            var html = this.scrollfeedback ? this.scrollfeedback(row.bounddata) : renderer(row.bounddata);
                            if (html != this._scrollelementcontent) {
                                this._scrollelement[0].innerHTML = html;
                                this._scrollelementcontent = html;
                            }
                        }

                        this._scrollelement.css('visibility', 'visible');
                        this._scrollelementoverlay.css('visibility', 'visible');
                        this._scrollelement.css('margin-top', -this._scrollelement.height() / 2);

                        this._scrolltimer = setInterval(function () {
                            if (!self.hScrollInstance.isScrolling() && !self.vScrollInstance.isScrolling()) {
                                callrenderrows();
                                self._scrollelement.css('visibility', 'hidden');
                                self._scrollelementoverlay.css('visibility', 'hidden');
                                clearInterval(self._scrolltimer);
                                if (row) {
                                    self.ensurerowvisible(row.visibleindex);
                                }
                            }
                        }, 100);

                        return;
                    }

                    if (navigator && navigator.userAgent.indexOf('Chrome') == -1 && navigator.userAgent.indexOf('Safari') != -1) {
                        this._updatedelay = 1;
                    }
                    if (this.touchDevice != undefined && this.touchDevice == true) {
                        this._updatedelay = 5;
                    }

                    var ie10 = this._browser == undefined ? this._isIE10() : this._browser;

                    if (ie10 || oldie) {
                        this._updatedelay = 5;
                    }

                    if ((ie10) && this.hScrollInstance.isScrolling()) {
                        callrenderrows();
                        return;
                    }

                    if ($.jqx.browser.mozilla && this._updatedelay == 0 && (this.vScrollInstance.isScrolling() || this.hScrollInstance.isScrolling())) {
                        this._updatedelay = 0;
                    }
                    var isTouch = this.isTouchDevice();
                    if (isTouch) {
                        this._updatedelay = 0;
                    }
                    if (this.updatedelay != null) {
                        this._updatedelay = this.updatedelay;
                    }

                    if (this._updatedelay == 0) {
                        callrenderrows();
                    }
                    else {
                        var timer = this._jqxgridrendertimer;
                        if (timer != null) {
                            clearTimeout(timer);
                        }
                        if (this.vScrollInstance.isScrolling() || this.hScrollInstance.isScrolling()) {
                            if (this._updatedelay) {
                                timer = setTimeout(function () {
                                    callrenderrows();
                                }, this._updatedelay);
                            }
                            else {
                                timer = null;
                                callrenderrows();
                            }
                            this._jqxgridrendertimer = timer;
                        }
                        else {
                            this._jqxgridrendertimer = timer;
                            callrenderrows();
                        }
                    }
                }
                if (self.autorowheight && !self.autoheight) {
                    if (this._pageviews.length > 0) {
                        var tableheight = this._gettableheight();
                        var virtualheight = this._pageviews[0].height;
                        if (virtualheight > tableheight) {
                            if (this.pageable && this.gotopage) {
                                virtualheight = this._pageviews[0].height;
                                if (virtualheight < 0) {
                                    virtualheight = this._pageviews[0].height;
                                }
                            }

                            if (this.vScrollBar.css('visibility') != 'visible') {
                                this.vScrollBar.css('visibility', 'visible');
                            }
                            if (virtualheight <= tableheight || this.autoheight) {
                                this.vScrollBar.css('visibility', 'hidden');
                            }

                            if (virtualheight - tableheight > 0) {
                                if (this.scrollmode != 'deferred') {
                                    var max = virtualheight - tableheight;
                                    var oldmax = this.vScrollInstance.max;
                                    this.vScrollBar.jqxScrollBar({ max: max });
                                    if (Math.round(max) != Math.round(oldmax)) {
                                        var val = this.vScrollBar.jqxScrollBar('value');
                                        if (val > max) {
                                            this.vScrollBar.jqxScrollBar({ value: 0 });
                                        }
                                    }
                                }
                            }
                            else {
                                this.vScrollBar.jqxScrollBar({ value: 0, max: virtualheight });
                            }
                        }
                        else {
                            if (!this._loading) {
                                this.vScrollBar.css('visibility', 'hidden');
                            }
                            this.vScrollBar.jqxScrollBar({ value: 0 });
                        }

                        this._arrange();
                        if (this.virtualsizeinfo) {
                            this.virtualsizeinfo.virtualheight = virtualheight;
                        }
                    }
                }
            },

            scrolling: function () {
                var vertical = this.vScrollInstance.isScrolling();
                var horizontal = this.hScrollInstance.isScrolling();
                return { vertical: vertical, horizontal: horizontal };
            },

            _renderhorizontalscroll: function () {
                var hScrollInstance = this.hScrollInstance;
                var horizontalscrollvalue = hScrollInstance.value;
                if (this.hScrollBar.css('visibility') === 'hidden') {
                    hScrollInstance.value = 0;
                    horizontalscrollvalue = 0;
                }

                var left = parseInt(horizontalscrollvalue);
                if (this.table == null)
                    return;

                var rows = this.table[0].rows.length;
                var columnsrow = this.columnsrow;
                var columnstart = this.groupable && this.groups.length > 0 ? this.groups.length : 0;
                var columnend = this.columns.records.length - columnstart;
                var columns = this.columns.records;
                var isempty = this.dataview.rows.length == 0;
                if (this.rtl) {
                    if (this.hScrollBar.css('visibility') != 'hidden') {
                        left = hScrollInstance.max - left;
                    }
                }

                if (isempty && !this._haspinned) {
                    for (var i = 0; i < rows; i++) {
                        var tablerow = this.table[0].rows[i];
                        for (var j = 0; j < columnstart + columnend; j++) {
                            var tablecell = tablerow.cells[j];
                            if (tablecell != undefined) {
                                var column = columns[j];
                                if (column.pinned) {
                                    tablecell.style.marginLeft = left + 'px';
                                    if (i == 0) {
                                        var columncell = columnsrow[0].cells[j];
                                        columncell.style.marginLeft = left + 'px';
                                    }
                                }
                            }
                        }
                    }
                    this.table[0].style.marginLeft = -left + 'px';
                    columnsrow[0].style.marginLeft = -left + 'px';
                }
                else {
                    if (this._haspinned || this._haspinned == undefined) {
                        for (var i = 0; i < rows; i++) {
                            var tablerow = this.table[0].rows[i];
                            for (var j = 0; j < columnstart + columnend; j++) {
                                var tablecell = tablerow.cells[j];
                                if (tablecell != undefined) {
                                    var column = columns[j];
                                    if (column.pinned) {
                                        if (left == 0 && tablecell.style.marginLeft == "")
                                            continue;

                                        var statuscell = null;
                                        var filtercell = null;
                                        var everpresentcell = null;


                                        if (this.showeverpresentrow && this.addnewrowtop) {
                                            if (this.addnewrowtop[0].cells) {
                                                everpresentcell = this.addnewrowtop[0].cells[j];
                                            }
                                        }

                                        if (this.showfilterrow && this.filterrow) {
                                            if (this.filterrow[0].cells) {
                                                filtercell = this.filterrow[0].cells[j];
                                            }
                                        }

                                        if (this.showaggregates) {
                                            if (this.statusbar[0].cells) {
                                                statuscell = this.statusbar[0].cells[j];
                                            }
                                        }

                                        if (!this.rtl) {
                                            tablecell.style.marginLeft = left + 'px';
                                            if (i == 0) {
                                                var columncell = columnsrow[0].cells[j];
                                                columncell.style.marginLeft = left + 'px';
                                                if (statuscell) {
                                                    statuscell.style.marginLeft = left + 'px';
                                                }
                                                if (filtercell) {
                                                    filtercell.style.marginLeft = left + 'px';
                                                }
                                                if (everpresentcell) {
                                                    everpresentcell.style.marginLeft = left + 'px';
                                                }
                                            }
                                        }
                                        else {
                                            tablecell.style.marginLeft = -parseInt(horizontalscrollvalue) + 'px';
                                            if (i == 0) {
                                                var columncell = columnsrow[0].cells[j];
                                                columncell.style.marginLeft = -parseInt(horizontalscrollvalue) + 'px';
                                                if (statuscell) {
                                                    statuscell.style.marginLeft = -parseInt(horizontalscrollvalue) + 'px';
                                                }
                                                if (filtercell) {
                                                    filtercell.style.marginLeft = -parseInt(horizontalscrollvalue) + 'px';
                                                }
                                                if (everpresentcell) {
                                                    everpresentcell.style.marginLeft = -parseInt(horizontalscrollvalue) + 'px';
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        this.table[0].style.marginLeft = -left + 'px';
                        columnsrow[0].style.marginLeft = -left + 'px';
                    }
                    else if (this._haspinned == false) {
                        this.table[0].style.marginLeft = -left + 'px';
                        columnsrow[0].style.marginLeft = -left + 'px';
                    }
                }

                if (this.showaggregates) {
                    if (this.statusbar[0].cells) {
                        var offset = 0;
                        if (this.rtl) {
                            if (this.vScrollBar.css('visibility') != 'hidden') {
                                if (this.hScrollBar.css('visibility') != 'hidden') {
                                    offset = 2 + parseInt(this.hScrollBar.css('left'));
                                }
                            }
                        }
                        this.statusbar[0].style.marginLeft = -left + offset + 'px';
                    }
                }
                if (this.showfilterrow && this.filterrow) {
                    if (this.filterrow[0].cells) {
                        this.filterrow[0].style.marginLeft = -left + 'px';
                    }
                }
                if (this.showeverpresentrow && this.addnewrowtop) {
                    if (this.addnewrowtop[0].cells) {
                        this.addnewrowtop[0].style.marginLeft = -left + 'px';
                    }
                }
            },

            _updaterowdetailsvisibility: function () {
                if (this.rowdetails) {
                    for (var i = 0; i < this._rowdetailselementscache.length; i++) {
                        $(this._rowdetailselementscache[i]).css('display', 'none');
                    }
                }
            },

            _getvisualcolumnsindexes: function (left, tablewidth, columnstart, columnend, hasgroups, pinnedColumns, selecting) {
                var scrolling = this.vScrollInstance.isScrolling() || this.hScrollInstance.isScrolling() || this._keydown;

                if (this.rowdetails || this.rtl || (this.editcell && scrolling) || (this.width && this.width.toString().indexOf('%') >= 0 && !scrolling && !this.editcell) || this.exporting) {
                    if (!selecting) {
                        return { start: 0, end: columnstart + columnend };
                    }
                }

                var xcolumn = 0;
                var hcolumnstart = -1;
                var hcolumnend = columnstart + columnend;
                var haspinnedcolumn = false;

                if (this.autorowheight) {
                    return { start: 0, end: columnstart + columnend };
                }

                if (!hasgroups) {
                    for (var j = 0; j < columnstart + columnend; j++) {
                        var rendercolumn = j;

                        if (!haspinnedcolumn) {
                            if (this.columns.records[j].pinned && pinnedColumns) {
                                haspinnedcolumn = true;
                            }
                        }

                        if (!this.columns.records[j].hidden && !this.columns.records[j].adaptivehidden) {
                            xcolumn += this.columns.records[j].width;
                        }

                        if (xcolumn >= left && hcolumnstart == -1) {
                            hcolumnstart = j;
                        }

                        if (xcolumn > tablewidth + left) {
                            hcolumnend = j
                            break;
                        }
                    }
                }

                hcolumnend++;
                if (hcolumnend > columnstart + columnend) {
                    hcolumnend = columnstart + columnend;
                }

                if (hcolumnstart == -1 || haspinnedcolumn) {
                    hcolumnstart = 0;
                }

                return { start: hcolumnstart, end: hcolumnend };
            },

            _getvirtualcolumnsindexes: function (left, tablewidth, columnstart, columnend, hasgroups) {
                var scrolling = this.vScrollInstance.isScrolling() || this.hScrollInstance.isScrolling() || this._keydown;

                if (this.enableoptimization) {
                    if (this.rowdetails || this.rtl || (this.editcell && scrolling) || (this.width && this.width.toString().indexOf('%') >= 0 && !scrolling && !this.editcell) || this.exporting) {
                        return { start: 0, end: columnstart + columnend };
                    }
                }

                if (this.rtl || this.editcell || this.exporting) {
                    return { start: 0, end: columnstart + columnend };
                }
                var xcolumn = 0;
                var hcolumnstart = -1;
                var hcolumnend = columnstart + columnend;

                if (this.autorowheight) {
                    return { start: 0, end: columnstart + columnend };
                }


                if (!hasgroups) {
                    for (var j = 0; j < columnstart + columnend; j++) {
                        var rendercolumn = j;


                        if (!this.columns.records[j].hidden && !this.columns.records[j].adaptivehidden) {
                            xcolumn += this.columns.records[j].width;
                        }

                        if (xcolumn >= left && hcolumnstart == -1) {
                            hcolumnstart = j;
                        }

                        if (xcolumn > tablewidth + left) {
                            hcolumnend = j
                            break;
                        }
                    }
                }

                hcolumnend++;
                if (hcolumnend > columnstart + columnend) {
                    hcolumnend = columnstart + columnend;
                }

                if (hcolumnstart == -1) {
                    hcolumnstart = 0;
                }


                return { start: hcolumnstart, end: hcolumnend };
            },

            _getfirstvisualrow: function () {
                var vScrollInstance = this.vScrollInstance;
                var verticalscrollvalue = vScrollInstance.value;
                var top = parseInt(verticalscrollvalue);

                if (this._pagescache.length == 0) {
                    this.dataview.updateview();
                    this._loadrows();
                }

                if (this.vScrollBar[0].style.visibility != 'visible') {
                    top = 0;
                }

                if (!this.pageable) {
                    var pagenum = this._findvisiblerow(top, this._pageviews);

                    if (pagenum == -1) {
                        return null;
                    }

                    if (pagenum != this.dataview.pagenum) {
                        this.dataview.pagenum = pagenum;
                        this.dataview.updateview();
                        this._loadrows();
                    }
                    else if (!this._pagescache[this.dataview.pagenum]) {
                        this._loadrows();
                    }
                }

                var firstvisiblerow = this._findvisiblerow(top, this._pagescache[this.dataview.pagenum]);
                var rowstorender = this._pagescache[this.dataview.pagenum];
                if (rowstorender && rowstorender[0]) {
                    return rowstorender[firstvisiblerow];
                }
            },

            _rendervisualrows: function () {
                if (!this.virtualsizeinfo)
                    return;

                var vScrollInstance = this.vScrollInstance;
                var hScrollInstance = this.hScrollInstance;
                var verticalscrollvalue = vScrollInstance.value;
                var horizontalscrollvalue = hScrollInstance.value;
                var top = parseInt(verticalscrollvalue);
                var left = parseInt(horizontalscrollvalue);
                var tableheight = this._gettableheight();
                var tablewidth = this._hostwidth != undefined ? this._hostwidth : this.host.width();
                if (this.hScrollBar[0].style.visibility == 'visible') {
                    tableheight += 29;
                }
                if (this.scrollmode == 'deferred' && this._newmax != 0) {
                    if (top > this._newmax && this._newmax != null) top = this._newmax;
                }

                var scrolling = vScrollInstance.isScrolling() || hScrollInstance.isScrolling() || this._keydown;
                var hasgroups = this.groupable && this.groups.length > 0;
                this.visiblerows = new Array();
                this.hittestinfo = new Array();

                if (this.editcell && this.editrow == undefined) {
                    this._hidecelleditor(false);
                }
                if (this.editrow != undefined) {
                    this._hideeditors();
                }

                if (this.virtualmode && !this.pageable) {
                    this._pagescache = new Array();
                }

                if (this._pagescache.length == 0) {
                    this.dataview.updateview();
                    this._loadrows();
                }

                if (this.vScrollBar[0].style.visibility == 'hidden') {
                    top = 0;
                }

                if (!this.pageable) {
                    var pagenum = this._findvisiblerow(top, this._pageviews);

                    if (pagenum == -1) {
                        this._clearvisualrows();
                        this._renderemptyrow();
                        this._updaterowdetailsvisibility();
                        //  return;
                    }

                    if (pagenum != this.dataview.pagenum) {
                        this.dataview.pagenum = pagenum;
                        this.dataview.updateview();
                        this._loadrows();
                    }
                    else if (!this._pagescache[this.dataview.pagenum]) {
                        this._loadrows();
                    }
                }

                var columnstart = this.groupable && this.groups.length > 0 ? this.groups.length : 0;
                if (!this.columns.records) {
                    return;
                }

                var columnend = this.columns.records.length - columnstart;
                var firstvisiblerow = this._findvisiblerow(top, this._pagescache[this.dataview.pagenum]);
                var rowstorender = this._pagescache[this.dataview.pagenum];
                var startindex = firstvisiblerow;
                if (startindex < 0) startindex = 0;

                var emptyheight = 0;
                var renderedrows = 0;
                var renderedheight = 0;
                var tableoffset = 0;
                var pagesize = this.virtualsizeinfo.visiblerecords;
                var groupslength = this.groupable ? this.groups.length : 0;
                var cellclass = this.toTP('jqx-grid-cell') + ' ' + this.toTP('jqx-item');
                if (this.rtl) {
                    cellclass += ' ' + this.toTP('jqx-grid-cell-rtl');
                }

                if ((this.autoheight || this.autorowheight) && this.pageable) {
                    if (!this.groupable || (this.groupable && this.groups.length === 0)) {
                        pagesize = this.dataview.pagesize;
                    }
                }

                if (hasgroups) {
                    cellclass = ' ' + this.toTP('jqx-grid-group-cell');
                }

                if (this.isTouchDevice()) {
                    cellclass += ' ' + this.toTP('jqx-touch');
                }

                if (this.autorowheight) {
                    cellclass += ' jqx-grid-cell-wrap'
                }

                var rowheight = this.rowsheight;

                if (this.cardview) {
                    rowheight = this.cardheight;
                }

                var altrowindex = startindex;
                var rendercellfunc = this._rendercell;
                var enableselection = true;

                var visualcolumnsindexes = this._getvisualcolumnsindexes(left, tablewidth, columnstart, columnend, hasgroups, true);
                var hcolumnstart = visualcolumnsindexes.start;
                var hcolumnend = visualcolumnsindexes.end;
                var virtualcolumnsindexes = this._getvirtualcolumnsindexes(left, tablewidth, columnstart, columnend, hasgroups);
                var hvirtualcolumnstart = virtualcolumnsindexes.start;
                var hvirtualcolumnend = virtualcolumnsindexes.end;
                var oldIE = $.jqx.browser.msie && $.jqx.browser.version < 9;
                if ((this.autoheight || this.pageable) && this.autorowheight) {
                    if (this._pageviews[0]) {
                        this._oldpageviewheight = this._pageviews[0].height;
                    }
                }

                if (this.autorowheight) {
                    startindex = 0;
                }

                if (startindex >= 0) {
                    this._updaterowdetailsvisibility();
                    this._startboundindex = rowstorender != null ? rowstorender[startindex].bounddata.boundindex : 0;
                    this._startvisibleindex = rowstorender != null ? rowstorender[startindex].bounddata.visibleindex : 0;

                    var allrows = this.table[0].rows;
                    if (this.columns.records.length > 10 && this.enablecolumnsvirtualization) {
                        var validParentNode = function (element) {
                            if (element && element.parentNode && element.parentNode.nodeName != "#document-fragment") {
                                return true;
                            }
                            return false;
                        }

                        for (var i = 0; i < allrows.length; i++) {
                            var tablerow = allrows[i];

                            tablerow.className = '';
                            for (var cindex = 0; cindex < hvirtualcolumnstart; cindex++) {
                                var rendercolumn = cindex;
                                if (this.columns.records[rendercolumn].pinned)
                                    continue;

                                if (this.columns.records[rendercolumn].datafield == null)
                                    continue;

                                var tablecell = tablerow.cells[rendercolumn];
                                if (validParentNode(tablecell)) {
                                    tablecell.parentNode.removeChild(tablecell);
                                }

                                var columnrecord = this.columns.records[rendercolumn].element;
                                this.columns.records[rendercolumn]._rendered = false;

                                if (validParentNode(columnrecord)) {
                                    this.columnsrow[0].removeChild(columnrecord);
                                }
                                if (this.filterrow) {
                                    if (validParentNode(this.filterrow[0].cells[rendercolumn]) && this.columns.records[rendercolumn].filterable) {
                                        this.filterrow[0].cells[rendercolumn].parentNode.removeChild(this.filterrow[0].cells[rendercolumn]);
                                    }
                                }
                            }
                            for (var cindex = hvirtualcolumnend; cindex < this.columns.records.length; cindex++) {
                                var rendercolumn = cindex;
                                if (this.columns.records[rendercolumn].pinned)
                                    continue;

                                if (this.columns.records[rendercolumn].datafield == null)
                                    continue;

                                var tablecell = tablerow.cells[rendercolumn];

                                if (validParentNode(tablecell)) {
                                    tablecell.parentNode.removeChild(tablecell);
                                }

                                var columnrecord = this.columns.records[rendercolumn].element;
                                this.columns.records[rendercolumn]._rendered = false;

                                if (validParentNode(columnrecord)) {
                                    this.columnsrow[0].removeChild(columnrecord);
                                }
                                if (this.filterrow) {
                                    if (validParentNode(this.filterrow[0].cells[rendercolumn]) && this.columns.records[rendercolumn].filterable) {
                                        this.filterrow[0].cells[rendercolumn].parentNode.removeChild(this.filterrow[0].cells[rendercolumn]);
                                    }
                                }
                            }
                            for (var cindex = hvirtualcolumnstart; cindex < hvirtualcolumnend; cindex++) {
                                var rendercolumn = cindex;
                                var tablecell = tablerow.cells[rendercolumn];
                                if (!validParentNode(tablecell)) {
                                    tablerow.appendChild(tablecell);
                                }
                                var columnrecord = this.columns.records[rendercolumn].element;
                                this.columns.records[rendercolumn]._rendered = true;

                                if (columnrecord.selectable) {
                                    tablecell.removeAttribute('selected');
                                    if (columnrecord.selected) {
                                        tablecell.setAttribute('selected', '');
                                    }
                                }

                                if (!validParentNode(columnrecord)) {
                                    this.columnsrow[0].appendChild(columnrecord);
                                }
                                if (this.filterrow && this.showfilterrow && !validParentNode(this.filterrow[0].cells[rendercolumn]) && this.columns.records[rendercolumn].filterable) {
                                    this.filterrow[0].firstChild.appendChild(this.filterrow[0].cells[rendercolumn]);
                                }
                            }
                        }
                    }

                    if (this.cardview) {
                        for (var i = 0; i < this.table[0].rows.length; i++) {
                            var tablerow = this.table[0].rows[i];
                            tablerow.innerHTML = '';
                        }
                    }

                    for (var renderindex = 0; renderindex < pagesize && renderedrows < pagesize; renderindex += 1) {
                        var renderrow = rowstorender != undefined ? rowstorender[startindex + renderindex] : null;

                        if (this.virtualmode && renderindex >= this.source.totalrecords) {
                            renderrow = null;
                        }
                        if (renderrow == null) {
                            startindex = -renderindex;
                            if (this._pagescache[this.dataview.pagenum + 1]) {
                                rowstorender = this._pagescache[this.dataview.pagenum + 1];
                                this.dataview.pagenum++;
                            }
                            else {
                                var pageviewslength = this._pageviews.length;
                                do {
                                    if (this.dataview.pagenum < this._pageviews.length - 1) {
                                        this.dataview.pagenum++;
                                        rowstorender = undefined;
                                        if (this._pageviews[this.dataview.pagenum].height > 0) {
                                            this.dataview.updateview();
                                            this._loadrows();
                                            rowstorender = this._pagescache[this.dataview.pagenum];
                                        }
                                    }
                                    else {
                                        rowstorender = undefined;
                                        break;
                                    }
                                } while (rowstorender == undefined && this.dataview.pagenum < pageviewslength);
                            }

                            if (rowstorender != undefined) {
                                renderrow = rowstorender[startindex + renderindex]
                            }
                        }

                        if (renderrow != null) {
                            if (renderrow.hidden)
                                continue;

                            this._endboundindex = this._startboundindex + renderindex;
                            this._endvisibleindex = this._startvisibleindex + renderindex;
                            if (renderindex == 0) {
                                var topoffset = Math.abs(top - renderrow.top);

                                this.table[0].style.top = -topoffset + 'px';
                                var table = this.table;
                                if ($.jqx.browser.chrome) {
                                    if (this._chromeTimer) {
                                        clearTimeout(this._chromeTimer);
                                    }
                                    this._chromeTimer = setTimeout(function () {
                                        table[0].style.top = (-topoffset + 0.01) + 'px';;
                                    }, 50);
                                }
                                tableoffset = -topoffset;
                            }

                            var tablerow = this.table[0].rows[renderedrows];
                            if (!tablerow) continue;
                            if (parseInt(tablerow.style.height) != renderrow.height) {
                                tablerow.style.height = parseInt(renderrow.height) + 'px';
                            }

                            tablerow.setAttribute('row-id', renderrow.bounddata.uid);
                            renderedheight += renderrow.height;
                            var hasdetails = this.rowdetails && renderrow.rowdetails;
                            var showdetails = !renderrow.rowdetailshidden;
                            if (hasdetails && showdetails) {
                                tablerow.style.height = parseInt(renderrow.height - renderrow.rowdetailsheight) + 'px';
                                pagesize++;
                            }

                            var selected = this._isrowselected(enableselection, renderrow);
                            for (var cindex = hcolumnstart; cindex < hcolumnend; cindex++) {
                                var rendercolumn = cindex;
                                this._rendervisualcell(rendercellfunc, cellclass, selected, hasdetails, showdetails, hasgroups, groupslength, tablerow, renderrow, rendercolumn, renderedrows, scrolling);
                            }

                            if (renderrow.group != undefined && this._rendergroup) {
                                this._rendergroup(groupslength, tablerow, renderrow, columnstart, columnend, renderedrows, tablewidth);
                            }

                            if (this.autorowheight && (this.autoheight || this.pageable)) {
                                var rowheight = this.rowsheight;
                                for (var cindex = hcolumnstart; cindex < hcolumnend; cindex++) {
                                    if (this.editable && this.editcell && this.editcell.column == this.columns.records[cindex].datafield && this.editcell.row == this.getboundindex(renderrow)) {
                                        if (this.editcell.editor) {
                                            rowheight = Math.max(rowheight, this.editcell.editor.height());
                                            continue;
                                        }
                                    }

                                    if (tablerow.cells[cindex].firstChild) {
                                        rowheight = Math.max(rowheight, 8 + parseInt(tablerow.cells[cindex].firstChild.offsetHeight));
                                    }
                                }
                                tablerow.style.height = parseInt(rowheight) + 'px';
                                this.heights[this._startboundindex + renderindex] = rowheight;
                                if (hasdetails && showdetails) {
                                    rowheight += renderrow.rowdetailsheight;
                                }
                                renderrow.height = rowheight;
                            }

                            if (this.cardview) {
                                tablerow.innerHTML = '';

                                var cardRowData = '<div class="jqx-grid-card-row"';
                                var cardContentData = '';
                                cardRowData += 'style="grid-template-columns: ';
                                var percent = 100 / this.cardsize + '%';

                                var cardstartindex = startindex;

                                for (var s = 0; s < this.cardsize; s++) {
                                    if (rowstorender != undefined) {
                                        renderrow = rowstorender[cardstartindex * this.cardsize + (renderindex * this.cardsize) + s]
                                    }

                                    if (!renderrow) {
                                        continue;
                                    }

                                    cardRowData += percent + ' ';

                                    var data = '<div id="' + renderrow.bounddata.uid + '" class="jqx-grid-card-cell">';

                                    data += '<table>';
                                    for (var cindex = hcolumnstart; cindex < hcolumnend; cindex++) {
                                        var rendercolumn = cindex;
                                        var cell = null;
                                        var column = this.columns.records[rendercolumn];
                                        if (column.hidden && column.__hidden === undefined) {
                                            continue;
                                        }

                                        var cellvalue = this._getcellvalue(column, renderrow);
                                        if (column.cellsformat != '') {
                                            if ($.jqx.dataFormat) {
                                                if ($.jqx.dataFormat.isDate(cellvalue)) {
                                                    cellvalue = $.jqx.dataFormat.formatdate(cellvalue, column.cellsformat, this.gridlocalization);
                                                }
                                                else if ($.jqx.dataFormat.isNumber(cellvalue)) {
                                                    cellvalue = $.jqx.dataFormat.formatnumber(cellvalue, column.cellsformat, this.gridlocalization);
                                                }
                                            }
                                        }

                                        if (column.cellsrenderer != null) {
                                            var newvalue = column.cellsrenderer(this.getboundindex(renderrow), column.datafield, cellvalue, null, column.getcolumnproperties(), renderrow.bounddata);
                                            if (newvalue != undefined) {
                                                cellvalue = newvalue;
                                            }
                                        }

                                        var tablecell = tablerow.cells[rendercolumn];
                                        var classname = cellclass;
                                        var editIcon = (this.editable && column.editable) ? '<span row="' + renderrow.bounddata.uid + '"  class="jqx-icon-edit"></span>' : '';

                                        data += '<tr class="jqx-grid-card-table-row">';
                                        data += '<td class="jqx-grid-card-cell-label"><div>' + column.text + '</div></td>';

                                        if (column.cellclassname != '' && column.cellclassname) {
                                            data += '<td class="jqx-grid-card-cell-value ' + column.cellclassname + '"><div>' + cellvalue + '</div></td>';
                                        }
                                        else {
                                            data += '<td class="jqx-grid-card-cell-value"><div>' + cellvalue + '</div></td>';
                                        }

                                        data += '</tr>';
                                    }

                                    data += '</table>';
                                    data += editIcon;
                                    data += '</div>';

                                    cardContentData += data;
                                }

                                cardRowData += ';">' + cardContentData + '</div>';
                                tablerow.innerHTML += cardRowData;

                                renderedrows++;

                                continue;
                            }

                            this.visiblerows[this.visiblerows.length] = renderrow;
                            this.hittestinfo[this.hittestinfo.length] = { row: renderrow, visualrow: tablerow, details: false };

                            if (hasdetails && showdetails) {
                                renderedrows++;
                                var tablerow = this.table[0].rows[renderedrows];
                                this._renderrowdetails(cellclass, tablerow, renderrow, columnstart, columnend, renderedrows);

                                this.visiblerows[this.visiblerows.length] = renderrow;
                                this.hittestinfo[this.hittestinfo.length] = { row: renderrow, visualrow: tablerow, details: true };
                            }

                            if (!this.autorowheight) {
                                if (renderedheight + tableoffset >= tableheight)
                                    break;
                            }
                        }
                        else {
                            var cansetheight = true;
                            this._clearvisualrow(left, hasgroups, renderedrows, columnstart, columnend);

                            if (renderedheight + emptyheight + tableoffset <= tableheight) {
                                emptyheight += rowheight;
                            }
                        }
                        renderedrows++;
                    }
                    this._horizontalvalue = left;

                    if (emptyheight > 0) {
                        if (this.vScrollBar[0].style.visibility == 'visible') {
                            var tabletop = parseInt(this.table.css('top'));
                            var lastpageview = this._pageviews[this._pageviews.length - 1];
                            var oldmax = vScrollInstance.max;
                            var newmax = lastpageview.top + lastpageview.height - tableheight; //tabletop + this.visiblerows[this.visiblerows.length - 1].top + tableheight; //offset + vScrollInstance.max - emptyheight;
                            if (this.hScrollBar.css('visibility') == 'visible') {
                                newmax += this.scrollbarsize + 22;
                            }

                            if (oldmax != newmax && !this.autorowheight) {
                                if (newmax >= 0) {
                                    if (this.scrollmode != 'deferred') {
                                        vScrollInstance.max = newmax;
                                        vScrollInstance.setPosition(vScrollInstance.max);
                                    }
                                    else {
                                        if (this._newmax != newmax) {
                                            this._newmax = newmax;
                                            this._rendervisualrows();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if ((this.autoheight || this.pageable) && this.autorowheight) {
                    this._pagescache = new Array();
                    var y = 0;
                    var height = 0;
                    for (var i = 0; i < this.visiblerows.length; i++) {
                        var row = this.visiblerows[i];
                        row.top = y;
                        y += row.height;
                        height += row.height;
                        var hasdetails = this.rowdetails && row.rowdetails;
                        var showdetails = !row.rowdetailshidden;
                        var tablerow = this.table[0].rows[i];
                        if (hasdetails && showdetails) {
                            i++;
                        }

                        for (var cindex = hcolumnstart; cindex < hcolumnend; cindex++) {
                            var column = this.columns.records[cindex];
                            if (!column.hidden && !column.adaptivehidden) {
                                if (!column.cellsrenderer) {
                                    var cell = tablerow.cells[cindex];
                                    var topMargin = 0;
                                    if (cell.firstChild) {
                                        var topMargin = (row.height - parseInt(cell.firstChild.offsetHeight) - 8) / 2;
                                        if (hasdetails && showdetails) {
                                            var topMargin = (row.height - row.rowdetailsheight - $(cell.firstChild).height() - 8) / 2;
                                        }
                                    }
                                    else {
                                        var topMargin = (row.height - parseInt($(cell).height()) - 8) / 2;
                                    }

                                    if (topMargin >= 0) {
                                        topMargin = parseInt(topMargin) + 4;
                                        if (cell.firstChild) {
                                            if (cell.firstChild.className.indexOf('jqx-grid-groups-row') == -1) {
                                                if (column.columntype != 'checkbox' && column.columntype != 'button') {
                                                    if (this.editable && this.editcell && this.editcell.column == column.datafield && this.editcell.row == this.getboundindex(row))
                                                        continue;

                                                    cell.firstChild.style.marginTop = topMargin + 'px';
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (this._pageviews[0]) {
                        this._pageviews[0].height = height; //this.table.height();
                    }
                    this._arrange();
                }
                this._renderemptyrow();
                if (this.toCompile && this.toCompile.length > 0) {
                    var that = this;
                    $.each(that.toCompile, function (index, value) {
                        if (this.compiled)
                            return true;

                        var cell = this.cell;
                        if (!cell)
                            return true;

                        if ($.jqx.angularCompile) {
                            $.jqx.angularCompile(cell, "<div>" + this.value + "</div>");
                        }
                        this.compiled = true;
                    });
                };
            },

            _hideemptyrow: function () {
                if (!this.showemptyrow) return;
                if (!this.table) return;
                if (!this.table[0].rows) return;

                var row = this.table[0].rows[0];
                if (!row) return;
                var rendered = false;
                for (var i = 0; i < row.cells.length; i++) {
                    var cell = $(row.cells[i]);
                    if (cell.css('display') != 'none' && !rendered) {
                        if (cell.width() == this.host.width() || cell.text() == this.gridlocalization.emptydatastring) {
                            cell[0].checkbox = null;
                            cell[0].button = null;
                            rendered = true;
                            cell[0].innerHTML = "";
                        }
                    }
                }
            },

            _renderemptyrow: function () {
                if (this._loading) {
                    return;
                }

                if (this.dataview.records.length == 0 && this.showemptyrow) {
                    var rendered = false;
                    var cellclass = this.toTP('jqx-grid-cell');

                    if (this.table && this.table.length > 0 && this.table[0].rows && this.table[0].rows.length > 0) {
                        var row = this.table[0].rows[0];
                        this.table[0].style.top = '0px';
                        for (var i = 0; i < row.cells.length; i++) {
                            var cell = $(row.cells[i]);
                            if (cell.css('display') != 'none' && !rendered) {
                                cell[0].checkbox = null;
                                cell[0].button = null;
                                cell[0].className = cellclass;
                                rendered = true;
                                cell[0].innerHTML = "";
                                var span = $("<span style='white-space: nowrap; float: left; margin-left: 50%; position: relative;'></span>");
                                span.text(this.gridlocalization.emptydatastring);
                                cell.append(span);
                                var hscroll = 0;
                                if (!this.oldhscroll) {
                                    hscroll = parseInt(this.table[0].style.marginLeft);
                                    if (this.rtl) {
                                        cell.css('z-index', 999);
                                        cell.css('overflow', 'visible');
                                    }
                                }

                                span.css('left', -hscroll - (span.width() / 2));
                                span.css('top', this._gettableheight() / 2 - span.height() / 2);
                                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                                    span.css('margin-left', '0px');
                                    span.css('left', this.host.width() / 2 - span.width() / 2);
                                }
                                var top = Math.abs(parseInt(this.table[0].style.top));
                                if (isNaN(top)) top = 0;
                                $(row).height(this._gettableheight() + top);
                                cell.css('margin-left', '0px');
                                cell.width(this.host.width());
                                if (this.table.width() < this.host.width()) {
                                    this.table.width(this.host.width());
                                }
                            }
                            cell.addClass(this.toThemeProperty('jqx-grid-empty-cell'));
                        }
                    }
                }
            },

            _clearvisualrows: function () {
                var pagesize = this.virtualsizeinfo.visiblerecords;
                var hScrollInstance = this.hScrollInstance;
                var horizontalscrollvalue = hScrollInstance.value;
                var left = parseInt(horizontalscrollvalue);
                var hasgroups = this.groupable && this.groups.length > 0;
                if (!this.columns.records)
                    return;

                for (var renderindex = 0; renderindex < pagesize; renderindex++) {
                    this._clearvisualrow(left, hasgroups, renderindex, 0, this.columns.records.length);
                }
            },

            _iscellselected: function (enableselection, row, column) {
                var selected = false;
                var boundindexoffset = 0;
                if (this.virtualmode && this.pageable && this.groupable) {
                    if (this.groups.length > 0) {
                        boundindexoffset = this.dataview.pagesize * this.dataview.pagenum;
                    }
                }

                if (this.groups.length > 0 && this.pageable && this.groupable) {
                    var boundindex = this.getrowboundindexbyid(row.bounddata.uid);
                    if (boundindex != -1) {
                        for (var obj in this.selectedcells) {
                            if (obj == boundindex + "_" + column) {
                                selected = true;
                            }
                        }
                        return selected;
                    }
                    return false;
                }

                if (enableselection && row.bounddata != null) {
                    if (this.selectionmode != "singlerow") {
                        if (this.dataview.filters.length > 0) {
                            if (!this.virtualmode && row.bounddata.dataindex != undefined) {
                                for (var obj in this.selectedcells) {
                                    if (obj == boundindexoffset + row.bounddata.dataindex + "_" + column) {
                                        selected = true;
                                    }
                                }
                            }
                            else {
                                for (var obj in this.selectedcells) {
                                    if (obj == boundindexoffset + row.bounddata.boundindex + "_" + column) {
                                        selected = true;
                                    }
                                }
                            }
                        }
                        else {
                            for (var obj in this.selectedcells) {
                                if (obj == boundindexoffset + row.bounddata.boundindex + "_" + column) {
                                    selected = true;
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        if (this.dataview.filters.length > 0) {
                            if (!this.virtualmode && row.bounddata.dataindex != undefined) {
                                for (var obj in this.selectedcells) {
                                    if (obj == boundindexoffset + row.bounddata.dataindex + "_" + column) {
                                        selected = true;
                                        break;
                                    }
                                }
                            }
                            else {
                                for (var obj in this.selectedcells) {
                                    if (obj == boundindexoffset + row.bounddata.boundindex + "_" + column) {
                                        selected = true;
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            for (var obj in this.selectedcells) {
                                if (obj == boundindexoffset + row.bounddata.boundindex == this.selectedrowindex) {
                                    selected = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                return selected;
            },

            _isrowselected: function (enableselection, row) {
                var selected = false;
                var boundindexoffset = 0;
                if (this.virtualmode && this.pageable && this.groupable) {
                    if (this.groups.length > 0) {
                        boundindexoffset = this.dataview.pagesize * this.dataview.pagenum;
                    }
                }

                if (this.groupable && this.groups.length > 0 && this.pageable) {
                    var boundindex = this.getrowboundindexbyid(row.bounddata.uid);

                    if (boundindex == undefined || boundindex == -1)
                        return false;

                    if (this.selectedrowindexes.indexOf(boundindex) != -1) {
                        selected = true;
                    }

                    if (!selected) {
                        selected = boundindex == this.selectedrowindex && this.selectedrowindex != -1;
                    }
                    return selected;
                }


                if (enableselection && row.bounddata != null) {
                    if (this.selectionmode != "singlerow") {
                        if (this.dataview.filters.length > 0) {
                            if (!this.virtualmode && row.bounddata.dataindex != undefined) {
                                if (this.selectedrowindexes.indexOf(boundindexoffset + row.bounddata.dataindex) != -1) {
                                    selected = true;
                                }
                            }
                            else {
                                if (this.selectedrowindexes.indexOf(boundindexoffset + row.bounddata.boundindex) != -1) {
                                    selected = true;
                                }
                            }
                        }
                        else {
                            if (this.selectedrowindexes.indexOf(boundindexoffset + row.bounddata.boundindex) != -1) {
                                selected = true;
                            }
                        }
                    }
                    else {
                        if (this.dataview.filters.length > 0) {
                            if (!this.virtualmode && row.bounddata.dataindex != undefined) {
                                if (this.selectedrowindexes.indexOf(boundindexoffset + row.bounddata.dataindex) != -1) {
                                    selected = true;
                                }
                            }
                            else {
                                if (this.selectedrowindexes.indexOf(boundindexoffset + row.bounddata.boundindex) != -1) {
                                    selected = true;
                                }
                            }
                        }
                        else {
                            if (boundindexoffset + row.bounddata.boundindex == this.selectedrowindex) {
                                selected = true;
                            }
                        }
                    }
                }

                return selected;
            },

            _rendervisualcell: function (rendercellfunc, cellclass, selected, hasdetails, showdetails, hasgroups, groupslength, tablerow, renderrow, rendercolumn, renderedrows, scrolling) {
                var cell = null;
                var column = this.columns.records[rendercolumn];
                if (column.hidden || column.adaptivehidden) {
                    var tablecell = tablerow.cells[rendercolumn];
                    tablecell.innerHTML = "";
                    return;
                }

                var cellvalue = this._getcellvalue(column, renderrow);
                var tablecell = tablerow.cells[rendercolumn];
                var classname = cellclass;

                if (this.selectionmode.indexOf('cell') != -1) {
                    if (this.dataview.filters.length > 0) {
                        if (this.selectedcells[renderrow.bounddata.dataindex + '_' + column.datafield]) {
                            selected = true;
                        }
                        else {
                            selected = false;
                        }
                    }
                    else {
                        if (this.selectedcells[renderrow.boundindex + '_' + column.datafield]) {
                            selected = true;
                        }
                        else {
                            selected = false;
                        }
                    }
                    if (this.editcell) {
                        if (this.editcell.row === renderrow.boundindex && this.editcell.column === column.datafield) {
                            if (column.columntype !== "checkbox") {
                                selected = false;
                            }
                        }
                    }
                    if (this.virtualmode || (this.groupable && this.groups.length > 0 && this.pageable)) {
                        selected = this._iscellselected(true, renderrow, column.datafield);
                    }
                }

                if (column.cellclassname != '' && column.cellclassname) {
                    if (typeof column.cellclassname == "string") {
                        classname += ' ' + column.cellclassname;
                    }
                    else {
                        if (!this._columnClassNameCache) {
                            this._columnClassNameCache = [];
                        }
                        var boundindex = this.getboundindex(renderrow);

                        if (this._columnClassNameCache[boundindex + "_" + column.datafield + "_" + cellvalue] !== undefined && this.enableoptimization) {
                            var customclassname = this._columnClassNameCache[boundindex + "_" + column.datafield + "_" + cellvalue];
                            if (customclassname) {
                                classname += ' ' + customclassname;
                            }
                        }
                        else {
                            var customclassname = column.cellclassname(boundindex, column.datafield, cellvalue, renderrow.bounddata);
                            if (customclassname) {
                                classname += ' ' + customclassname;
                            }
                            this._columnClassNameCache[boundindex + "_" + column.datafield + "_" + cellvalue] = customclassname;
                        }
                    }
                }

                var issortcolumn = this.showsortcolumnbackground && this.sortcolumn && column.displayfield == this.sortcolumn;
                if (this.sortmode === "many" && this.showsortcolumnbackground) {
                    var sortColumns = this.getsortcolumns();

                    for (var m = 0; m < sortColumns.length; m++) {
                        if (column.displayfield === sortColumns[m].dataField) {
                            issortcolumn = true;
                        }
                    }
                }

                if (issortcolumn) {
                    classname += ' ' + this.toTP('jqx-grid-cell-sort');
                }

                if (column.filter && this.showfiltercolumnbackground) {
                    classname += ' ' + this.toTP('jqx-grid-cell-filter');
                }

                if (renderrow.bounddata.totalsrow) {
                    classname += ' ' + this.toTP('jqx-grid-cell-pinned');
                }

                if ((column.pinned && this.showpinnedcolumnbackground) || column.grouped) {
                    if (hasgroups) {
                        if (!renderrow.bounddata.totalsrow) {
                            classname += ' ' + this.toTP('jqx-grid-cell-pinned');
                        }
                        else {
                            //        if (rendercolumn <= renderrow.bounddata.level) {
                            //          classname += ' ' + this.toTP('jqx-grid-cell-pinned');
                            //        }
                        }
                    }
                    else {
                        classname += ' ' + this.toTP('jqx-grid-cell-pinned');
                    }
                }

                if (this.altrows && renderrow.group == undefined) {
                    var altrowindex = renderrow.visibleindex;
                    if (altrowindex >= this.altstart) {
                        if ((this.altstart + altrowindex) % (1 + this.altstep) == 0) {
                            if (!issortcolumn) {
                                classname += ' ' + this.toTP('jqx-grid-cell-alt');
                            }
                            else classname += ' ' + this.toTP('jqx-grid-cell-sort-alt');

                            if (column.filter && this.showfiltercolumnbackground) {
                                classname += ' ' + this.toTP('jqx-grid-cell-filter-alt');
                            }

                            if (column.pinned && this.showpinnedcolumnbackground) {
                                classname += ' ' + this.toTP('jqx-grid-cell-pinned-alt');
                            }
                        }
                    }
                }

                if (this.batcheditable) {
                    var tempCellvalue = renderrow.bounddata['_temp' + column.datafield];
                    if (tempCellvalue !== undefined) {
                        classname += ' ' + this.toTP('jqx-grid-cell-batch');
                    }
                }

                if (rendercolumn <= groupslength) {
                    if (hasgroups || this.rowdetails || (this.pageable && this.virtualmode)) {
                        var $tablecell = $(tablecell);
                        var cellwidth = this.columns.records[rendercolumn].width;

                        if (tablecell.style.width != parseInt(cellwidth) + 'px') {
                            $tablecell.width(cellwidth);
                        }
                    }
                }
                else {
                    if (hasgroups || this.rowdetails) {
                        if (this._hiddencolumns) {
                            var $tablecell = $(tablecell);
                            var cellwidth = this.columns.records[rendercolumn].width;

                            if (parseInt(tablecell.style.width) != cellwidth) {
                                $tablecell.width(cellwidth);
                            }
                        }
                    }
                }

                var selectedstate = true;
                if (this.rowdetails && hasdetails) {
                    if (showdetails && !hasgroups) {
                        classname += ' ' + this.toTP('jqx-grid-details-cell');
                    }
                    else if (hasgroups) {
                        classname += ' ' + this.toTP('jqx-grid-group-details-cell');
                    }

                    if (this.showrowdetailscolumn) {
                        if (!this.rtl) {
                            if (renderrow.group == undefined && rendercolumn == groupslength && !renderrow.bounddata.totalsrow) {
                                if (this.disablerowdetails) {
                                    var hasRowDetails = this.disablerowdetails(renderrow.bounddata.boundindex);
                                    if (true === hasRowDetails) {
                                        selectedstate = false;
                                        tablecell.title = "";
                                        tablecell.innerHTML = "";
                                        if (tablecell.className != classname) {
                                            tablecell.className = classname;
                                        }
                                        return;
                                    }
                                }
                                var iconClassName = this.toThemeProperty('jqx-icon-arrow-down');
                                if (showdetails) {
                                    classname += ' ' + this.toTP('jqx-grid-group-expand');
                                    classname += ' ' + iconClassName;
                                }
                                else {
                                    classname += ' ' + this.toTP('jqx-grid-group-collapse');
                                    var iconClassName = this.toThemeProperty('jqx-icon-arrow-right');
                                    classname += ' ' + iconClassName;
                                }
                                selectedstate = false;
                                tablecell.title = "";
                                tablecell.innerHTML = "";
                                if (tablecell.className != classname) {
                                    tablecell.className = classname;
                                }
                                return;
                            }
                        }
                        else {
                            if (renderrow.group == undefined && rendercolumn == tablerow.cells.length - groupslength - 1) {
                                var iconClassName = this.toThemeProperty('jqx-icon-arrow-down');
                                if (showdetails) {
                                    classname += ' ' + this.toTP('jqx-grid-group-expand-rtl');
                                    classname += ' ' + iconClassName;
                                }
                                else {
                                    classname += ' ' + this.toTP('jqx-grid-group-collapse-rtl');
                                    var iconClassName = this.toThemeProperty('jqx-icon-arrow-left');
                                    classname += ' ' + iconClassName;
                                }
                                selectedstate = false;
                                tablecell.title = "";
                                tablecell.innerHTML = "";
                                if (tablecell.className != classname) {
                                    tablecell.className = classname;
                                }
                                return;
                            }
                        }
                    }
                }

                if (selected && selectedstate && rendercolumn >= groupslength) {
                    classname += ' ' + this.toTP('jqx-grid-cell-selected');
                    classname += ' ' + this.toTP('jqx-fill-state-pressed');
                }


                if (tablecell.className != classname) {
                    tablecell.className = classname;
                }

                column._applyCellStyle(tablecell);

                if (renderrow.group != undefined) {
                    cellvalue = "";
                    tablecell.title = "";
                    tablecell.innerHTML = "";

                    return;
                }
                rendercellfunc(this, column, renderrow, cellvalue, tablecell, scrolling);
            },

            _rendercell: function (me, column, row, value, tablecell, scrolling) {
                var lookupkey = value + "_" + column.visibleindex;
                //row.uniqueid + "_" + column.visibleindex;
                if (column.columntype == "number" || column.cellsrenderer != null) {
                    var lookupkey = row.uniqueid + "_" + column.visibleindex;
                }
                if (column.columntype == "number") {
                    value = row.visibleindex;
                }
                if (column.columntype === "adaptive") {
                    value = "...";
                }

                column._applyCellStyle(tablecell);
                if (me.showrowlines) {
                    tablecell.style.borderBottomColor = "";
                }
                else {
                    tablecell.style.borderBottomColor = "transparent";
                }

                if (me.showcolumnheaderlines) {
                    column.element.style.borderRightColor = "";
                    column.element.style.boxShadow = "";
                }
                else {
                    column.element.style.borderRightColor = "transparent";
                    column.element.style.boxShadow = "none";
                }

                if (me.showcolumnlines) {
                    tablecell.style.borderRightColor = "";
                }
                else {
                    tablecell.style.borderRightColor = "transparent";
                }


                if (me.editcell && me.editrow == undefined) {
                    if (me.editmode == "selectedrow" && column.editable && me.editable) {
                        if (me.editcell.row == me.getboundindex(row)) {
                            if (me._showcelleditor) {
                                if (!me.hScrollInstance.isScrolling() && !me.vScrollInstance.isScrolling()) {
                                    me._showcelleditor(me.editcell.row, column, tablecell, me.editcell.init);
                                }
                                else {
                                    me._showcelleditor(me.editcell.row, column, tablecell, false, false);
                                }

                                tablecell.className += ' ' + me.toTP('jqx-grid-cell-edit');
                                return;
                            }
                        }
                    }
                    else {
                        if (me.editcell.row == me.getboundindex(row) && me.editcell.column == column.datafield) {
                            me.editcell.element = tablecell;
                            if (me.editcell.editing) {
                                if (me._showcelleditor) {
                                    if (!me.hScrollInstance.isScrolling() && !me.vScrollInstance.isScrolling()) {
                                        me._showcelleditor(me.editcell.row, column, me.editcell.element, me.editcell.init);
                                    }
                                    else {
                                        me._showcelleditor(me.editcell.row, column, me.editcell.element, me.editcell.init, false);
                                    }

                                    tablecell.className += ' ' + me.toTP('jqx-grid-cell-edit');
                                    return;
                                }
                            }
                        }
                    }
                }

                var defaultcellsrenderer = me._defaultcellsrenderer(value, column);

                var cachedcell = me._cellscache[lookupkey];
                //   var ie10 = me._browser == undefined ? me._isIE10() : me._browser;
                if (cachedcell) {
                    if (column.columntype == "checkbox") {
                        if (me.host.jqxCheckBox) {
                            if (value === "") value = null;
                            var empty = tablecell.innerHTML.toString().length == 0;
                            if (tablecell.checkbox && !me.groupable && !empty) {
                                tablecell.checkboxrow = me.getboundindex(row);
                                if (value == "") value = false;
                                if (value == "1") value = true;
                                if (value == "0") value = false;
                                if (value == 1) value = true;
                                if (value == 0) value = false;
                                if (value == 'true') value = true;
                                if (value == 'false') value = false;
                                if (value == null && !column.threestatecheckbox) {
                                    value = false;
                                }
                                if (column.checkboxcolumn) {
                                    value = false;
                                    if (me.dataview.filters.length > 0 && !me.virtualmode && row.bounddata.dataindex != undefined) {
                                        if (me.selectedrowindexes.indexOf(row.bounddata.dataindex) != -1) {
                                            value = true;
                                        }
                                    }
                                    else {
                                        if (me.selectedrowindexes.indexOf(row.bounddata.boundindex) != -1) {
                                            value = true;
                                        }
                                    }
                                }
                                if (!me.disabled) {
                                    if (tablecell.checkboxinstance) {
                                        tablecell.checkboxinstance._setState(value);
                                    }
                                    else {
                                        tablecell.checkbox.jqxCheckBox('_setState', value);
                                    }
                                }
                            }
                            else {
                                me._rendercheckboxcell(me, tablecell, column, row, value);
                            }
                            if (column.cellsrenderer != null) {
                                var newvalue = column.cellsrenderer(me.getboundindex(row), column.datafield, value, defaultcellsrenderer, column.getcolumnproperties(), row.bounddata);
                                if (newvalue != undefined) {
                                    tablecell.innerHTML = newvalue;
                                }
                            }

                            return;
                        }
                    }
                    else if (column.columntype == "button") {
                        if (me.host.jqxButton) {
                            if (value == "") value = false;
                            if (column.cellsrenderer != null) {
                                value = column.cellsrenderer(me.getboundindex(row), column.datafield, value, defaultcellsrenderer, column.getcolumnproperties(), row.bounddata);
                            }

                            if (tablecell.innerHTML == "") {
                                tablecell.buttonrow = me.getboundindex(row);
                                tablecell.button = null;
                                me._renderbuttoncell(me, tablecell, column, row, value);
                            }

                            if (tablecell.button && !me.groupable) {
                                tablecell.buttonrow = me.getboundindex(row);
                                tablecell.button.val(value);
                            }
                            else {
                                me._renderbuttoncell(me, tablecell, column, row, value);
                            }
                            return;
                        }
                    }
                    else if (column.columntype == "progressbar" || column.columntype === "rating") {
                        if (me.host.jqxButton) {
                            if (value == "") value = false;
                            if (column.cellsrenderer != null) {
                                value = column.cellsrenderer(me.getboundindex(row), column.datafield, value, defaultcellsrenderer, column.getcolumnproperties(), row.bounddata);
                            }

                            if (tablecell.innerHTML == "") {
                                tablecell.progressrow = me.getboundindex(row);
                                tablecell.progress = null;
                                me._renderprogresscell(me, tablecell, column, row, value);
                            }

                            if (tablecell.progress && !me.groupable) {
                                tablecell.progressrow = me.getboundindex(row);
                                tablecell.progress.val(value);
                            }
                            else {
                                me._renderprogresscell(me, tablecell, column, row, value);
                            }

                            if (me.enabletooltips && column.enabletooltips) {
                                tablecell.title = "" + value;
                            }
                            return;
                        }
                    }
                    else if (column.columntype === 'sparklines') {
                        if (me.host.jqxButton) {

                            var columnWidth = tablecell.offsetWidth;
                            var height = tablecell.offsetHeight;
                            var templateSettings = column.sparklines;
                            if (!templateSettings) {
                                templateSettings = {
                                    type: 'column'
                                }
                            }

                            if (columnWidth === 0) columnWidth = 10;
                            var html = me._renderSparklinesCell({
                                width: columnWidth - 10,
                                height: Math.max(0, height - 7),
                                points: '' + value,
                                colors: templateSettings.colors || ['#D50000', '#E67C73', '#F4511E', '#F6BF26',
                                    '#33B679', '#0B8043', '#039BE5', '#3F51B5',
                                    '#7986CB', '#8E24AA', '#616161'],
                                type: templateSettings.type,
                                gap: templateSettings.gap,
                                max: templateSettings.max,
                                min: templateSettings.min,
                                strokeWidth: templateSettings.strokeWidth,
                                colorFunction: templateSettings.colorFunction,
                                tooltipFormatFunction: templateSettings.tooltipFormatFunction
                            });

                            me, tablecell, column, row, value
                            tablecell.innerHTML = '<div style="padding-top: 5px; padding-left: 5px; padding-right: 5px;">' + html + '</div>';
                        }

                        if (me.enabletooltips && column.enabletooltips) {
                            tablecell.title = "" + value;
                        }
                        return;
                    }

                    if (column.createwidget) {
                        if (tablecell.innerHTML == "") {
                            tablecell.widgetrow = me.getboundindex(row);
                            tablecell.widget = null;
                            column.widget = null;
                            me._renderwidgetcell(me, tablecell, column, row, value);
                        }

                        if (tablecell.widget && !me.groupable) {
                            tablecell.widgetrow = me.getboundindex(row);
                            if (column.initwidget) {
                                column.initwidget(me.getboundindex(row), column.datafield, value, tablecell.firstChild);
                            }
                            else throw new Error("jqxGrid: 'initwidget' column function is not implemented. Please, implement 'initwidget'");
                        }
                        else {
                            me._renderwidgetcell(me, tablecell, column, row, value);
                        }
                        return;
                    }

                    var cellelement = cachedcell.element;

                    if (column.cellsrenderer != null || (tablecell.childNodes && tablecell.childNodes.length == 0) || me.groupable || me.rowdetails) {
                        if (tablecell.innerHTML != cellelement) {
                            tablecell.innerHTML = cellelement;
                        }
                    }
                    else {
                        if (tablecell.innerHTML.indexOf('editor') >= 0) {
                            tablecell.innerHTML = cellelement;
                        }
                        else if (scrolling) {
                            var textStartIndex = cellelement.indexOf('>');
                            var textEndIndex = cellelement.indexOf('</');
                            var text = cellelement.substring(textStartIndex + 1, textEndIndex);
                            var child = tablecell.childNodes[0];
                            if (text.indexOf('>') >= 0) {
                                tablecell.innerHTML = cellelement;
                            }
                            else {
                                if (child.childNodes[0]) {
                                    if (child.childNodes[0].nodeName !== '#text') {
                                        tablecell.innerHTML = cellelement;
                                    }
                                    else if (text != child.childNodes[0].nodeValue) {
                                        if (text.indexOf('&') >= 0) {
                                            tablecell.innerHTML = cellelement;
                                        }
                                        else {
                                            child.childNodes[0].nodeValue = text;
                                        }
                                    }
                                }
                                else {
                                    var newChild = document.createTextNode(text);
                                    child.appendChild(newChild);
                                }
                            }
                        }
                        else {
                            if (tablecell.innerHTML != cellelement) {
                                tablecell.innerHTML = cellelement;
                            }
                        }
                    }

                    if (me.enabletooltips && column.enabletooltips) {
                        tablecell.title = cachedcell.title;
                    }
                    return;
                }

                if (column.columntype == "checkbox") {
                    me._rendercheckboxcell(me, tablecell, column, row, value);
                    me._cellscache[lookupkey] = { element: "", title: value };
                    if (me.enabletooltips && column.enabletooltips) {
                        tablecell.title = "" + value;
                    }
                    return;
                }
                else if (column.columntype == "button") {
                    if (column.cellsrenderer != null) {
                        value = column.cellsrenderer(me.getboundindex(row), column.datafield, value, defaultcellsrenderer, column.getcolumnproperties(), row.bounddata);
                    }
                    me._renderbuttoncell(me, tablecell, column, row, value);
                    me._cellscache[lookupkey] = { element: "", title: value };
                    if (me.enabletooltips && column.enabletooltips) {
                        tablecell.title = "" + value;
                    }
                    return;
                }
                else if (column.columntype == "progressbar" || column.columntype === "rating") {
                    if (column.cellsrenderer != null) {
                        value = column.cellsrenderer(me.getboundindex(row), column.datafield, value, defaultcellsrenderer, column.getcolumnproperties(), row.bounddata);
                    }
                    me._renderprogresscell(me, tablecell, column, row, value);
                    me._cellscache[lookupkey] = { element: "", title: value };
                    if (me.enabletooltips && column.enabletooltips) {
                        tablecell.title = "" + value;
                    }
                    return;
                }
                else if (column.columntype === 'sparklines') {
                    if (column.cellsrenderer != null) {
                        value = column.cellsrenderer(me.getboundindex(row), column.datafield, value, defaultcellsrenderer, column.getcolumnproperties(), row.bounddata);
                    }
                    me._cellscache[lookupkey] = { element: "", title: value };
                    if (me.enabletooltips && column.enabletooltips) {
                        tablecell.title = "" + value;
                    }

                    var columnWidth = tablecell.offsetWidth;
                    var height = tablecell.offsetHeight;
                    var templateSettings = column.sparklines;
                    if (!templateSettings) {
                        templateSettings = {
                            type: 'column'
                        }
                    }
                    if (columnWidth === 0) columnWidth = 10;
                    var html = me._renderSparklinesCell({
                        width: columnWidth - 10,
                        height: Math.max(0, height - 7),
                        points: '' + value,
                        colors: templateSettings.colors || ['#D50000', '#E67C73', '#F4511E', '#F6BF26',
                            '#33B679', '#0B8043', '#039BE5', '#3F51B5',
                            '#7986CB', '#8E24AA', '#616161'],
                        type: templateSettings.type,
                        gap: templateSettings.gap,
                        max: templateSettings.max,
                        min: templateSettings.min,
                        strokeWidth: templateSettings.strokeWidth,
                        colorFunction: templateSettings.colorFunction,
                        tooltipFormatFunction: templateSettings.tooltipFormatFunction
                    });

                    tablecell.innerHTML = '<div style="padding-top: 5px; padding-left: 5px; padding-right: 5px;">' + html + '</div>';


                    tablecell.onmousemove = function (event) {
                        if (templateSettings.type === 'column' || templateSettings.type === 'bar') {
                            var rects = tablecell.querySelectorAll('rect');

                            for (var i = 0; i < rects.length; i++) {
                                var rect = rects[i];
                                var boundRect = rect.getBoundingClientRect();
                                rect.removeAttribute('highlight');

                                if (boundRect.left <= event.clientX && event.clientX <= boundRect.right) {
                                    if (boundRect.top <= event.clientY && event.clientY <= boundRect.bottom) {
                                        rect.setAttribute('highlight', '');
                                    }
                                }
                            }
                        }
                        if (templateSettings.type === 'pie') {
                            var setHighlight = false;
                            var rects = tablecell.querySelectorAll('path');

                            for (var i = 0; i < rects.length; i++) {
                                var rect = rects[i];

                                var boundRect = rect.getBoundingClientRect();
                                rect.removeAttribute('highlight');

                                if (!setHighlight) {
                                    if (boundRect.left <= event.clientX && event.clientX <= boundRect.right) {
                                        if (boundRect.top <= event.clientY && event.clientY <= boundRect.bottom) {
                                            rect.setAttribute('highlight', '');
                                            setHighlight = true;
                                        }
                                    }
                                }
                            }
                        }

                        if (templateSettings.type === 'line') {
                            var lines = tablecell.querySelectorAll('line');

                            for (var i = 0; i < lines.length; i++) {
                                var line = lines[i];

                                var boundRect = line.getBoundingClientRect();
                                line.removeAttribute('highlight');


                                if (boundRect.left <= event.clientX && event.clientX <= boundRect.right) {
                                    if (line.previousElementSibling) {
                                        line.previousElementSibling.style.display = 'none';
                                    }

                                    if (line.nextElementSibling) {
                                        line.nextElementSibling.style.display = 'none';
                                    }
                                    line.setAttribute('highlight', '');
                                    if (boundRect.left + boundRect.width / 2 >= event.clientX) {
                                        if (line.previousElementSibling) {
                                            line.previousElementSibling.style.display = '';
                                        }
                                    }
                                    else {
                                        if (line.nextElementSibling) {
                                            line.nextElementSibling.style.display = '';
                                        }
                                    }
                                }
                            }
                        }
                    }
                    tablecell.onmouseleave = function () {
                        var rects = tablecell.querySelectorAll('rect');

                        for (var i = 0; i < rects.length; i++) {
                            var rect = rects[i];
                            rect.removeAttribute('highlight');
                        }

                        var paths = tablecell.querySelectorAll('path');

                        for (var i = 0; i < paths.length; i++) {
                            var path = paths[i];
                            path.removeAttribute('highlight');
                        }

                        var lines = tablecell.querySelectorAll('line');

                        for (var i = 0; i < lines.length; i++) {
                            var line = lines[i];
                            line.removeAttribute('highlight');
                        }

                        var circles = tablecell.querySelectorAll('circle');

                        for (var i = 0; i < circles.length; i++) {
                            if (templateSettings.type === 'line') {
                                circles[i].style.display = 'none';
                            }
                        }
                    }
                    return;
                }
                else if (column.columntype == "number") {
                    value = row.visibleindex;
                }
                if (column.createwidget) {
                    if (column.cellsrenderer != null) {
                        value = column.cellsrenderer(me.getboundindex(row), column.datafield, value, defaultcellsrenderer, column.getcolumnproperties(), row.bounddata);
                    }
                    me._renderwidgetcell(me, tablecell, column, row, value);
                    me._cellscache[lookupkey] = { element: "", title: value };
                    if (me.enabletooltips && column.enabletooltips) {
                        tablecell.title = value;
                    }
                    return;
                }

                var cellelement = null;
                if (column.cellsrenderer != null) {
                    if (!me._columnCellsRenderCache) {
                        me._columnCellsRenderCache = [];
                    }
                    var boundindex = me.getboundindex(row);

                    if (me._columnCellsRenderCache[boundindex + "_" + column.datafield + "_" + value] !== undefined && me.enableoptimization) {
                        cellelement = me._columnCellsRenderCache[boundindex + "_" + column.datafield + "_" + value];
                    }
                    else {
                        cellelement = column.cellsrenderer(me.getboundindex(row), column.datafield, value, defaultcellsrenderer, column.getcolumnproperties(), row.bounddata);

                        me._columnCellsRenderCache[boundindex + "_" + column.datafield + "_" + value] = cellelement;
                    }

                    if (cellelement && (cellelement.indexOf('<jqx-') >= 0 || cellelement.indexOf(' ng-') >= 0)) {
                        if (me.toCompile) {
                            me.toCompile.push({ cell: tablecell, value: cellelement, row: me.getboundindex(row) });
                        }
                        return;
                    }
                }
                else {
                    cellelement = defaultcellsrenderer;
                }

                if (cellelement == null) {
                    cellelement = defaultcellsrenderer;
                }
                var formattedValue = value;
                if (me.enabletooltips && column.enabletooltips) {
                    if (column.cellsformat != '') {
                        if ($.jqx.dataFormat) {
                            if ($.jqx.dataFormat.isDate(value)) {
                                formattedValue = $.jqx.dataFormat.formatdate(formattedValue, column.cellsformat, me.gridlocalization);
                            }
                            else if ($.jqx.dataFormat.isNumber(value)) {
                                formattedValue = $.jqx.dataFormat.formatnumber(formattedValue, column.cellsformat, me.gridlocalization);
                            }
                        }
                    }
                    tablecell.title = formattedValue;
                }

                if (me.WinJS) {
                    $(tablecell).html(cellelement);
                }
                else {
                    var innerHTML = tablecell.innerHTML;
                    if (innerHTML.indexOf('editor') >= 0 || column.cellsrenderer != null || me.groupable || me.virtualmode) {
                        tablecell.innerHTML = cellelement;
                    }
                    else if (innerHTML.length > 0) {
                        var textStartIndex = cellelement.indexOf('>');
                        var textEndIndex = cellelement.indexOf('</');
                        var text = cellelement.substring(textStartIndex + 1, textEndIndex);
                        var child = tablecell.childNodes[0];
                        if (text.indexOf('>') >= 0) {
                            tablecell.innerHTML = cellelement;
                        }
                        else {
                            if (child.childNodes[0]) {
                                if (text != child.childNodes[0].nodeValue) {
                                    if (text.indexOf('&') >= 0 || innerHTML.indexOf('span') >= 0 || innerHTML.indexOf('img') >= 0) {
                                        tablecell.innerHTML = cellelement;
                                    }
                                    else {
                                        child.childNodes[0].nodeValue = text;
                                    }
                                    //      var newChild = document.createTextNode(text);
                                    //      child.replaceChild(newChild, child.childNodes[0]);
                                }
                            }
                            else {
                                var newChild = document.createTextNode(text);
                                child.appendChild(newChild);
                            }
                        }
                    }
                    else {
                        if (innerHTML != cellelement) {
                            tablecell.innerHTML = cellelement;
                        }
                    }
                }

                me._cellscache[lookupkey] = { element: tablecell.innerHTML, title: formattedValue };

                return true;
            },

            _isIE10: function () {
                if (this._browser == undefined) {
                    var browserInfo = $.jqx.utilities.getBrowser();
                    if (browserInfo.browser == 'msie' && parseInt(browserInfo.version) > 9)
                        this._browser = true;
                    else {
                        this._browser = false;
                        if (browserInfo.browser == 'msie') {
                            var txt = "Browser CodeName: " + navigator.appCodeName + "";
                            txt += "Browser Name: " + navigator.appName + "";
                            txt += "Browser Version: " + navigator.appVersion + "";
                            txt += "Platform: " + navigator.platform + "";
                            txt += "User-agent header: " + navigator.userAgent + "";
                            if (txt.indexOf('Zune 4.7') != -1) {
                                this._browser = true;
                            }
                        }
                    }
                }
                return this._browser;
            },


            _renderinlinecell: function (me, tablecell, column, row, value) {
                var $tablecell = $(tablecell);
                tablecell.innerHTML = '<div style="position: absolute;"></div>';
            },

            _rendercheckboxcell: function (me, tablecell, column, row, value) {
                if (me.host.jqxCheckBox) {
                    var $tablecell = $(tablecell);
                    if (value === "") {
                        if (column.threestatecheckbox) {
                            value = null;
                        }
                        else {
                            value = false;
                        }
                    }
                    if (value === null && !column.threestatecheckbox) {
                        value = false;
                    }

                    if (value == "1") value = true;
                    if (value == "0") value = false;
                    if (value == 1) value = true;
                    if (value == 0) value = false;
                    if (value == 'true') value = true;
                    if (value == 'false') value = false;
                    if (column.checkboxcolumn) {
                        value = false;
                        var boundindex = this.getboundindex(row);
                        if (this.selectedrowindexes.indexOf(boundindex) != -1) {
                            value = true;
                        }
                    }

                    if ($tablecell.find('.jqx-checkbox').length == 0) {
                        tablecell.innerHTML = '<div style="position: absolute; top: 50%; left: 50%; margin-top: -9px; margin-left: -12px;"></div>';
                        $(tablecell.firstChild).jqxCheckBox({ rippleEffect: false, disabled: me.disabled, _canFocus: false, hasInput: false, hasThreeStates: column.threestatecheckbox, enableContainerClick: false, animationShowDelay: 0, animationHideDelay: 0, locked: true, theme: me.theme, checked: value });

                        if (this.enabletooltips && column.enabletooltips) {
                            tablecell.title = "" + value;
                        }

                        if (this.editable && column.editable) {
                            $(tablecell.firstChild).jqxCheckBox({ locked: false });
                        }
                        if (column.checkboxcolumn) {
                            $(tablecell.firstChild).jqxCheckBox({ locked: false });
                        }

                        tablecell.checkbox = $(tablecell.firstChild);
                        tablecell.checkboxinstance = tablecell.checkbox.data().jqxCheckBox.instance;
                        tablecell.checkboxrow = this.getboundindex(row);
                        var checkinstance = $.data(tablecell.firstChild, "jqxCheckBox").instance;
                        checkinstance.updated = function (event, checked, oldchecked) {
                            if (me.disabled) {
                                checked = oldchecked;
                                var totalrows = me.table[0].rows.length;
                                var columnindex = me._getcolumnindex(column.datafield);
                                for (var currentCheckbox = 0; currentCheckbox < totalrows; currentCheckbox++) {
                                    var checkboxcell = me.table[0].rows[currentCheckbox].cells[columnindex].firstChild;
                                    if (checkboxcell) {
                                        $(checkboxcell).jqxCheckBox({ disabled: me.disabled });
                                    }
                                }
                            }

                            if (column.editable && !me.disabled) {
                                var totalrows = me.table[0].rows.length;
                                var columnindex = me._getcolumnindex(column.datafield);

                                if (me.editrow !== undefined && undefined === me.editcell[column.datafield]) {
                                    me.editcell[column.datafield] = oldchecked;
                                }

                                if (column.cellbeginedit) {
                                    var beginEdit = column.cellbeginedit(tablecell.checkboxrow, column.datafield, column.columntype, !checked);
                                    if (beginEdit == false) {
                                        me.setcellvalue(tablecell.checkboxrow, column.datafield, !checked, true);
                                        return;
                                    }
                                }
                                if (column.cellvaluechanging) {
                                    var newcellvalue = column.cellvaluechanging(tablecell.checkboxrow, column.datafield, column.columntype, oldchecked, checked);
                                    if (newcellvalue != undefined) {
                                        checked = newcellvalue;
                                    }
                                }

                                if (me.editmode !== "selectedrow") {
                                    for (var currentCheckbox = 0; currentCheckbox < totalrows; currentCheckbox++) {
                                        var checkboxcell = me.table[0].rows[currentCheckbox].cells[columnindex].firstChild;
                                        if (checkboxcell) {
                                            $(checkboxcell).jqxCheckBox('destroy');
                                        }
                                    }
                                }

                                if (me.editcell && me.editcell.validated == false) {
                                    me.setcellvalue(tablecell.checkboxrow, column.datafield, !checked, true);
                                }
                                else {
                                    if (me.editmode !== "selectedrow" || me.editcell == null) {
                                        var datarow = me.getrowdata(tablecell.checkboxrow);
                                        me._raiseEvent(17, { rowindex: tablecell.checkboxrow, row: datarow, datafield: column.datafield, value: oldchecked, columntype: column.columntype });
                                        me.pushToHistory = true;
                                        me.setcellvalue(tablecell.checkboxrow, column.datafield, checked, true);
                                        me.pushToHistory = false;
                                        me._raiseEvent(18, { rowindex: tablecell.checkboxrow, row: datarow, datafield: column.datafield, oldvalue: oldchecked, value: checked, columntype: column.columntype });
                                    }
                                    else {
                                        me.pushToHistory = true;
                                        me.setcellvalue(tablecell.checkboxrow, column.datafield, checked, false, false);
                                        me.pushToHistory = false;
                                    }
                                }

                                if (column.cellendedit) {
                                    column.cellendedit(tablecell.checkboxrow, column.datafield, column.columntype, checked);
                                }

                            }
                            else if (column.checkboxcolumn) {
                                if (me.editcell) {
                                    me.endcelledit(me.editcell.row, me.editcell.column, false, true);
                                }
                                if (!me.disabled) {
                                    if (checked) {
                                        me.selectrow(tablecell.checkboxrow);
                                    }
                                    else {
                                        me.unselectrow(tablecell.checkboxrow);
                                    }
                                    if (me.autosavestate) {
                                        if (me.savestate) me.savestate();
                                    }
                                }
                            }
                        }
                    }
                    else {
                        tablecell.checkboxrow = this.getboundindex(row);
                        $(tablecell.firstChild).jqxCheckBox('_setState', value, !(this.editable && column.editable) && !column.checkboxcolumn);
                    }
                }
            },

            _renderwidgetcell: function (me, tablecell, column, row, value) {
                var $tablecell = $(tablecell);
                if ($tablecell.find('.jqx-grid-widget').length == 0) {
                    var widgetElement = '<div class="jqx-grid-widget" style="opacity: 1; position: absolute; width: 100%; height:100%; top: 0%; left: 0%; padding: 0px;"></div>';
                    tablecell.innerHTML = widgetElement;
                    column.createwidget(row, column.datafield, value, tablecell.firstChild);
                    $(tablecell.firstChild).attr("hideFocus", "true");
                    $(tablecell.firstChild).children().addClass("jqx-grid-widget");
                    tablecell.widget = $(tablecell.firstChild);
                    tablecell.widgetrow = me.getboundindex(row);
                    column.widget = $(tablecell.firstChild);
                }
                else {
                    column.initwidget(me.getboundindex(row), column.datafield, value, tablecell.firstChild);
                    tablecell.widgetrow = me.getboundindex(row);
                    $(tablecell.firstChild).val(value);
                }
            },

            _renderprogresscell: function (me, tablecell, column, row, value) {
                var $tablecell = $(tablecell);

                if (column.columntype === "rating") {
                    if (!me._linkadded) {
                        var link = document.createElement('link');

                        link.rel = "stylesheet";
                        link.href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css";

                        document.head.appendChild(link);
                        me._linkadded = true;
                    }

                    if (!column.ratingmax) {
                        column.ratingmax = 5;
                    }

                    var ratingstars = '';
                    for (var i = 0; i < column.ratingmax; i++) {
                        if (value >= i + 1) {
                            ratingstars += '<span style="color: rgba(255, 165, 0, 1);" class="fa fa-star checked"></span>';
                        }
                        else {
                            ratingstars += '<span style="color: rgba(255, 165, 0, .3);" class="fa fa-star"></span>';
                        }
                    }

                    var align = column.cellsalign;

                    if (align === 'right') {
                        align = 'flex-end';
                    }

                    tablecell.innerHTML = '<div style="display: flex; width: 100%; height: 100%; justify-content: ' + align + '; padding: 5px; box-sizing: border-box; font-size: 16px; align-items: center;">' + ratingstars + '</div>';
                    return;
                }

                if (value == "") value = false;
                if ($tablecell.find('.jqx-progress').length == 0) {
                    tablecell.innerHTML = '<progress class="jqx-progress" max="100" style="opacity: 1; position: absolute; top: 10%; left: 10%; width:80%; height:80%; padding: 0px;"/>';
                    $(tablecell.firstChild).val(value);
                    tablecell.progress = $(tablecell.firstChild);
                    tablecell.progressrow = me.getboundindex(row);
                }
                else {
                    tablecell.progressrow = me.getboundindex(row);
                    $(tablecell.firstChild).val(value);
                }
            },

            _renderSparklinesCell: function (properties) {
                var that = this;
                var options = {
                    svg: null,
                    width: properties.width || 100,
                    height: properties.height || 30,
                    gap: properties.gap || 5,
                    strokeWidth: properties.strokeWidth || 2,
                    type: properties.type || 'column',
                    colors: properties.colors || ['var(--jqx-primary)'],
                    points: properties.points,
                    labels: properties.labels,
                    colorFunction: properties.colorFunction,
                    tooltipFormatFunction: properties.tooltipFormatFunction,
                    min: properties.min,
                    max: properties.max
                };

                options.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                options.svg.setAttribute('width', options.width);
                options.svg.setAttribute('height', options.height);

                function validate(options) {
                    if (!Array.isArray(options.colors)) {
                        options.colors = that.colors.split(',');
                    }

                    if (!options.points) {
                        return
                    }
                    options.points = options.points.split(',').map(function (item) { return parseInt(item, 10) });
                }


                // Initializes and renders the chart.
                validate(options);

                switch (options.type) {
                    case 'column': {
                        return that._renderColumn(options);
                    }
                    case 'bar': {
                        return that._renderBar(options);
                    }
                    case 'line': {
                        return that._renderLine(options);
                    }
                    case 'pie': {
                        return that._renderPie(options);
                    }
                    case 'stacked': {
                        return that._renderStacked(options);
                    }
                }
            },

            _renderColumn: function (options) {
                var columnWidth = (options.gap / options.points.length) + (options.width / options.points.length) - options.gap;
                var maxValue = options.max || this._getMaxPoint(options.points);
                var minValue = options.min || this._getMinPoint(options.points);
                var pxPerValue = options.height / (Math.abs(minValue) + Math.abs(maxValue));
                var bottomOffset = Math.abs(minValue) * pxPerValue;

                for (var i = 0; i < options.points.length; i++) {
                    var point = options.points[i];
                    var idx = i;
                    var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    var rectHeight = Math.abs(point) * pxPerValue;
                    if (isNaN(rectHeight)) {
                        rectHeight = 0;
                    }
                    rect.setAttribute('x', (idx * columnWidth) + (idx * options.gap));
                    rect.setAttribute('point', point);

                    var color = point >= 0 ? 'var(--jqx-primary)' : 'var(--jqx-error)';

                    if (maxValue > 0 && minValue < 0) {
                        if (point >= 0) {
                            rect.setAttribute('y', options.height - bottomOffset - 1 - rectHeight);
                        }
                        else {
                            rect.setAttribute('y', options.height - bottomOffset - 1);
                        }
                    }
                    else if (maxValue >= 0 && minValue >= 0) {
                        rect.setAttribute('y', options.height - rectHeight);
                    }
                    else if (minValue <= 0 && maxValue <= 0) {
                        rect.setAttribute('y', rectHeight);
                    }
                    rect.setAttribute('width', columnWidth);
                    rect.setAttribute('height', rectHeight);
                    if (options.colorFunction) {
                        var tmpColor = options.colorFunction(point);
                        if (tmpColor) {
                            color = tmpColor;
                        }
                    }
                    rect.setAttribute('fill', color);

                    var tooltip = options.tooltipFormatFunction ? options.tooltipFormatFunction(point) : point;
                    rect.setAttribute('data-title', tooltip);

                    options.svg.appendChild(rect);
                }

                return options.svg.outerHTML;
            },

            _getMinPoint: function (points) {
                var minPoint = points[0];
                for (var i = 1; i < points.length; i++) {
                    minPoint = Math.min(minPoint, points[i]);
                }

                return minPoint;
            },

            _getMaxPoint: function (points) {
                var maxPoint = points[0];
                for (var i = 1; i < points.length; i++) {
                    maxPoint = Math.max(maxPoint, points[i]);
                }

                return maxPoint;
            },

            _renderBar: function (options) {
                var height = options.height - 5;
                var columnHeight = Math.max(5, (options.gap / options.points.length) + (height / options.points.length) - options.gap);
                var maxValue = options.max || this._getMaxPoint(options.points);
                var minValue = options.min || this._getMinPoint(options.points);
                var pxPerValue = options.width / (Math.abs(minValue) + Math.abs(maxValue));
                var leftOffset = Math.abs(minValue) * pxPerValue;

                for (var i = 0; i < options.points.length; i++) {
                    var point = options.points[i];
                    var idx = i;
                    var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    var rectWidth = Math.abs(point) * pxPerValue;
                    rect.setAttribute('y', (idx * columnHeight) + (idx * options.gap));
                    rect.setAttribute('point', point);

                    var color = point >= 0 ? 'var(--jqx-primary)' : 'var(--jqx-error)';

                    if (maxValue > 0 && minValue < 0) {
                        if (point >= 0) {
                            rect.setAttribute('x', leftOffset);
                        }
                        else {
                            rect.setAttribute('x', leftOffset - rectWidth);
                        }
                    }
                    else if (maxValue >= 0 && minValue >= 0) {
                        rect.setAttribute('x', 0);
                    }
                    else if (minValue <= 0 && maxValue <= 0) {
                        rect.setAttribute('x', 0);
                    }
                    rect.setAttribute('width', rectWidth);
                    rect.setAttribute('height', columnHeight);

                    if (options.colorFunction) {
                        var tmpColor = options.colorFunction(point);
                        if (tmpColor) {
                            color = tmpColor;
                        }
                    }
                    rect.setAttribute('fill', color);
                    var tooltip = options.tooltipFormatFunction ? options.tooltipFormatFunction(point) : point;
                    rect.setAttribute('data-title', tooltip);

                    options.svg.appendChild(rect);
                };

                return options.svg.outerHTML;
            },

            _renderLine: function (options) {
                var spacing = options.width / (options.points.length - 1);
                var maxValue = options.max || this._getMaxPoint(options.points);
                var minValue = options.min || this._getMinPoint(options.points);
                var pxPerValue = options.height / (Math.abs(minValue) + Math.abs(maxValue));
                var bottomOffset = Math.abs(minValue) * pxPerValue;

                var color = 'var(--jqx-primary)';

                var lines = [];
                var lineCoords = [];
                options.svg.setAttribute('overflow', 'visible');
                for (var i = 0; i < options.points.length; i++) {
                    var point = options.points[i];

                    var x = i * spacing;
                    var y = options.height - bottomOffset - point * pxPerValue;

                    lineCoords.push({ x: x, y: y, point: point });
                    if (lineCoords.length === 2) {
                        lines.push(lineCoords);
                        lineCoords = [];
                    }

                    if (lines.length > 0 && lineCoords.length === 0) {
                        lineCoords.push(lines[lines.length - 1][1]);
                    }
                }
                for (var i = 0; i < lines.length; i++) {
                    var lineCoords = lines[i];
                    if (options.colorFunction) {
                        var tmpColor = options.colorFunction(lineCoords[0].point);
                        if (tmpColor) {
                            color = tmpColor;
                        }
                    }

                    if (i === 0) {
                        var circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        options.svg.appendChild(circle);
                        circle.setAttribute('cx', lineCoords[0].x);
                        circle.setAttribute('cy', lineCoords[0].y);
                        circle.setAttribute('r', 3);
                        circle.setAttribute('fill', color);
                        var tooltip = options.tooltipFormatFunction ? options.tooltipFormatFunction(lineCoords[0].point) : lineCoords[0].point;
                        circle.setAttribute('data-title', tooltip);
                        circle.style.display = 'none';
                    }

                    var line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    options.svg.appendChild(line);

                    line.setAttribute('x1', lineCoords[0].x);
                    line.setAttribute('y1', lineCoords[0].y);
                    line.setAttribute('x2', lineCoords[1].x);
                    line.setAttribute('y2', lineCoords[1].y);

                    var circle2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    options.svg.appendChild(circle2);
                    circle2.setAttribute('cx', lineCoords[1].x);
                    circle2.setAttribute('cy', lineCoords[1].y);
                    circle2.setAttribute('r', 3);
                    circle2.setAttribute('fill', color);
                    var tooltip = options.tooltipFormatFunction ? options.tooltipFormatFunction(lineCoords[1].point) : lineCoords[1].point;
                    circle2.setAttribute('data-title', tooltip)
                    circle2.style.display = 'none';

                    line.setAttribute('fill', 'none');
                    line.setAttribute('stroke-width', options.strokeWidth);
                    line.setAttribute('stroke', color);
                }

                return options.svg.outerHTML;
            },

            _renderPie: function (options) {
                var radius = Math.min(options.width, options.height) / 2;
                var centerX = options.width / 2;
                var centerY = options.height / 2;

                var total = options.points.reduce(function (acc, val) {
                    return acc + Math.abs(val)
                }, 0);
                var startAngle = 0;
                var index = 0;

                for (var i = 0; i < options.points.length; i++) {
                    var point = options.points[i];
                    var color = options.color;

                    if (!color) {
                        if (options.colors) {
                            color = options.colors[index];
                            if (!color) {
                                index = 0;
                            }
                            color = options.colors[index];
                        }
                    }
                    index++;

                    if (options.colorFunction) {
                        var tmpColor = options.colorFunction(point);
                        if (tmpColor) {
                            color = tmpColor;
                        }
                    }

                    var sliceAngle = (Math.abs(point) / total) * 2 * Math.PI;
                    var endAngle = startAngle + sliceAngle;

                    var x1 = centerX + radius * Math.cos(startAngle);
                    var y1 = centerY + radius * Math.sin(startAngle);
                    var x2 = centerX + radius * Math.cos(endAngle);
                    var y2 = centerY + radius * Math.sin(endAngle);

                    var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                    if (point === total) {
                        path = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        path.setAttribute('r', radius);
                        path.setAttribute('cx', centerX);
                        path.setAttribute('cy', centerY);
                    }

                    var largeArcFlag = sliceAngle > Math.PI ? 1 : 0;
                    var d = 'M ' + centerX + ',' + centerY + ' L ' + x1 + ',' + y1 + ' A ' + radius + ',' + radius + ' 0 ' + largeArcFlag + ' 1 ' + x2 + ',' + y2 + ' Z';
                    //     var d = `M ${centerX},${centerY} L ${x1},${y1} A ${radius},${radius} 0 ${largeArcFlag} 1 ${x2},${y2} Z`;


                    path.setAttribute('d', d);
                    path.setAttribute('fill', color);

                    var tooltip = options.tooltipFormatFunction ? options.tooltipFormatFunction(point) : '' + (point / total * 100).toFixed(2) + '%';
                    path.setAttribute('data-title', tooltip);

                    options.svg.appendChild(path);
                    startAngle = endAngle;
                }

                return options.svg.outerHTML;
            },

            _renderStacked: function (options) {
                var total = options.points.reduce(function (a, b) {
                    return a + b
                }, 0);
                var totalGapWidth = (options.points.length - 1) * options.gap;
                var availableWidth = options.width - totalGapWidth;

                var offset = 0;
                for (var i = 0; i < options.points.length; i++) {
                    var idx = i;
                    var point = options.points[i];
                    var color = options.colors[idx % options.colors.length];
                    var rectWidth = (point / total) * availableWidth;
                    var rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', offset);
                    rect.setAttribute('y', 0);
                    rect.setAttribute('width', rectWidth);
                    rect.setAttribute('height', options.height);
                    rect.setAttribute('fill', color);

                    var title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    title.textContent = point;
                    rect.appendChild(title);

                    options.svg.appendChild(rect);
                    offset += rectWidth + options.gap;
                }

                return options.svg.outerHTML;
            },

            _renderbuttoncell: function (me, tablecell, column, row, value) {
                if (me.host.jqxButton) {
                    var $tablecell = $(tablecell);
                    if (value == "") value = false;
                    if ($tablecell.find('.jqx-button').length == 0) {
                        tablecell.innerHTML = '<input type="button" style="opacity: 1; position: absolute; top: 0%; left: 0%; padding: 0px; margin-top: 2px; margin-left: 2px;"/>';
                        $(tablecell.firstChild).val(value);
                        $(tablecell.firstChild).attr("hideFocus", "true");
                        $(tablecell.firstChild).jqxButton({
                            disabled: me.disabled, theme: me.theme, height: me.rowsheight - 4, width: column.width - 4
                        });
                        tablecell.button = $(tablecell.firstChild);
                        tablecell.buttonrow = me.getboundindex(row);
                        var isTouch = this.isTouchDevice();
                        if (isTouch) {
                            var eventname = $.jqx.mobile.getTouchEventName('touchend');
                            me.addHandler($(tablecell.firstChild), eventname, function (event) {
                                if (column.buttonclick) {
                                    column.buttonclick(tablecell.buttonrow, event);
                                }
                            });
                        }
                        else {
                            me.addHandler($(tablecell.firstChild), 'click', function (event) {
                                if (column.buttonclick) {
                                    column.buttonclick(tablecell.buttonrow, event);
                                }
                            });
                        }
                    }
                    else {
                        tablecell.buttonrow = me.getboundindex(row);
                        $(tablecell.firstChild).val(value);
                    }
                }
            },

            _clearvisualrow: function (left, hasgroups, renderedrows, columnstart, columnend) {
                var cellclass = this.toTP('jqx-grid-cell');
                if (hasgroups) {
                    cellclass = ' ' + this.toTP('jqx-grid-group-cell');
                }
                cellclass += ' ' + this.toTP('jqx-grid-cleared-cell');
                var rows = this.table[0].rows;
                for (var j = 0; j < columnstart + columnend; j++) {
                    if (rows[renderedrows]) {
                        var tablecell = rows[renderedrows].cells[j];
                        if (tablecell.className != cellclass) {
                            tablecell.className = cellclass;
                        }
                        var columnrecord = this.columns.records[j];
                        if (this._horizontalvalue != left && !columnrecord.pinned) {
                            //      $(tablecell).css('margin-left', -left);
                            if (this.oldhscroll == true) {
                                var margin = -left;
                                tablecell.style.marginLeft = -left + 'px';
                            }
                        }
                        var cellwidth = columnrecord.width;
                        if (columnrecord.adaptivewidth) {
                            cellwidth = columnrecord.adaptivewidth;
                        }

                        if (cellwidth < columnrecord.minwidth) cellwidth = columnrecord.minwidth;
                        if (cellwidth > columnrecord.maxwidth) cellwidth = columnrecord.maxwidth;

                        if (parseInt(tablecell.style.width) != cellwidth) {
                            if (cellwidth != "auto") {
                                $(tablecell)[0].style.width = cellwidth + 'px';
                            }
                            else {
                                $(tablecell)[0].style.width = cellwidth;
                            }
                        }
                        if (tablecell.title != "") {
                            tablecell.title = "";
                        }
                        if (tablecell.innerHTML != "") {
                            tablecell.innerHTML = "";
                        }
                    }
                }
                if (rows[renderedrows]) {
                    var rowheight = this.rowsheight;
                    if (this.cardview) {
                        rowheight = this.cardheight;
                    }

                    if (parseInt(rows[renderedrows].style.height) != rowheight) {
                        rows[renderedrows].style.height = parseInt(rowheight) + 'px';
                    }
                }
            },

            _findgroupstate: function (uniqueid) {
                var group = this._findgroup(uniqueid);
                if (group == null) {
                    return false;
                }
                return group.expanded;
            },

            _findgroup: function (uniqueid) {
                var group = null;

                if (this.expandedgroups[uniqueid])
                    return this.expandedgroups[uniqueid];

                return group;
            },

            _clearcaches: function () {
                this._columnsbydatafield = new Array();
                this._pagescache = new Array();
                this._pageviews = new Array();
                this._cellscache = new Array();
                this._columnClassNameCache = new Array();
                this._columnCellsRenderCache = new Array();
                this.heights = new Array();
                this.hiddens = new Array();
                this.hiddenboundrows = new Array();
                this.heightboundrows = new Array();
                this.detailboundrows = new Array();
                this.details = new Array();
                this.expandedgroups = new Array();
                this._rowdetailscache = new Array();
                this._rowdetailselementscache = new Array();
                if ($.jqx.dataFormat) {
                    $.jqx.dataFormat.cleardatescache();
                }
                this.tableheight = null;
            },

            _getColumnText: function (datafield) {
                if (this._columnsbydatafield == undefined) {
                    this._columnsbydatafield = new Array();
                }

                if (this._columnsbydatafield[datafield])
                    return this._columnsbydatafield[datafield];

                var columnname = datafield;
                var column = null;
                $.each(this.columns.records, function () {
                    if (this.datafield == datafield || this.displayfield == datafield) {
                        columnname = this.text;
                        column = this;
                        return false;
                    }
                });

                this._columnsbydatafield[datafield] = {
                    label: columnname, column: column
                };
                return this._columnsbydatafield[datafield];
            },

            _getcolumnbydatafield: function (datafield) {
                if (this.__columnsbydatafield == undefined) {
                    this.__columnsbydatafield = new Array();
                }

                if (this.__columnsbydatafield[datafield])
                    return this.__columnsbydatafield[datafield];

                var columnname = datafield;
                var column = null;
                $.each(this.columns.records, function () {
                    if (this.datafield == datafield || this.displayfield == datafield) {
                        columnname = this.text;
                        column = this;
                        return false;
                    }
                });

                this.__columnsbydatafield[datafield] = column;
                return this.__columnsbydatafield[datafield];
            },

            isscrollingvertically: function () {
                var isscrolling = (this.vScrollBar.jqxScrollBar('isScrolling'))
                return isscrolling;
            },

            _renderrowdetails: function (cellclass, tablerow, renderrow, columnstart, columnend, renderedrows) {
                if (tablerow == undefined)
                    return;

                var $tablerow = $(tablerow);
                var cellindex = 0;
                var indent = this.rowdetails && this.showrowdetailscolumn ? (1 + this.groups.length) * this.groupindentwidth : (this.groups.length) * this.groupindentwidth;
                if (this.groupable && this.groups.length > 0) {
                    for (var detailsIndex = 0; detailsIndex <= columnend; detailsIndex++) {
                        var tablecell = $(tablerow.cells[detailsIndex]);
                        tablecell[0].innerHTML = "";
                        tablecell[0].className = 'jqx-grid-details-cell';
                    }
                }

                var tablecell = $(tablerow.cells[cellindex]);
                if (tablecell[0].style.display == "none") {
                    var cellToRender = tablerow.cells[cellindex];
                    var m = 2;
                    var start = cellindex;
                    while (cellToRender != undefined && cellToRender.style.display == 'none' && m < 10) {
                        cellToRender = tablerow.cells[start + m - 1];
                        m++;
                    }
                    tablecell = $(cellToRender);
                }

                if (this.rtl) {
                    for (var s = columnstart; s < columnend; s++) {
                        tablerow.cells[s].innerHTML = "";
                        tablerow.cells[s].className = 'jqx-grid-details-cell';
                    }
                }

                tablecell.css('width', '100%');
                $tablerow.height(renderrow.rowdetailsheight);
                tablecell[0].className = cellclass;

                var boundindex = this.getboundindex(renderrow);
                var lookupkey = boundindex + "_";

                if (this._rowdetailscache[lookupkey]) {
                    var cache = this._rowdetailscache[lookupkey];
                    var $detailselement = cache.html;

                    if (this.initrowdetails) {
                        if (this._rowdetailscache[lookupkey].element) {
                            var element = this._rowdetailscache[lookupkey].element;
                            var tablecelloffset = tablecell.coord();
                            var gridcontentoffset = this.gridcontent.coord();
                            var top = parseInt(tablecelloffset.top) - parseInt(gridcontentoffset.top);
                            var left = parseInt(tablecelloffset.left) - parseInt(gridcontentoffset.left);
                            if (this.rtl) {
                                left = 0;
                            }

                            $(element).css('top', top);
                            $(element).css('left', left);
                            $(element).css('display', 'block');
                            $(element).width(this.host.width() - indent);
                            if (this.layoutrowdetails) {
                                this.layoutrowdetails(boundindex, element, this.element, this.getrowdata(boundindex));
                            }
                        }
                    }
                    else {
                        tablecell[0].innerHTML = $detailselement;
                    }
                    return;
                }

                tablecell[0].innerHTML = '';
                if (!this.enablerowdetailsindent) {
                    indent = 0;
                }

                var detailselement = '<div class="jqx-enableselect" role="rowgroup" style="border: none; overflow: hidden; width: 100%; height: 100%; margin-left: ' + indent + 'px;">' + renderrow.rowdetails + '</div>';
                if (this.rtl) {
                    var detailselement = '<div class="jqx-enableselect" role="rowgroup" style="border: none; overflow: hidden; width: 100%; height: 100%; margin-left: ' + 0 + 'px; margin-right: ' + indent + 'px;">' + renderrow.rowdetails + '</div>';
                }

                this._rowdetailscache[lookupkey] = {
                    id: tablerow.id, html: detailselement
                }
                if (this.initrowdetails) {
                    var element = $(detailselement)[0];
                    $(this.gridcontent).prepend($(element));

                    $(element).css('position', 'absolute');
                    $(element).width(this.host.width() - indent);
                    $(element).height(tablecell.height());

                    var tablecelloffset = tablecell.coord();
                    $(element).css('z-index', 1799);
                    if (this.isTouchDevice()) {
                        $(element).css('z-index', 1999);
                    }
                    $(element).addClass(this.toThemeProperty('jqx-widget-content'));
                    var tablecelloffset = tablecell.coord();
                    var gridcontentoffset = this.gridcontent.coord();
                    var top = parseInt(tablecelloffset.top) - parseInt(gridcontentoffset.top);
                    var left = parseInt(tablecelloffset.left) - parseInt(gridcontentoffset.left);

                    $(element).css('top', top);
                    $(element).css('left', left);

                    this.content[0].scrollTop = 0;
                    this.content[0].scrollLeft = 0;
                    var details = $($(element).children()[0]);
                    if (details[0].id != "") {
                        details[0].id = details[0].id + boundindex;
                    }

                    this.initrowdetails(boundindex, element, this.element, this.getrowdata(boundindex));

                    this._rowdetailscache[lookupkey].element = element;
                    this._rowdetailselementscache[boundindex] = element;
                }
                else {
                    tablecell[0].innerHTML = detailselement;
                }
            },

            _defaultcellsrenderer: function (value, column) {
                if (column.cellsformat != '') {
                    if ($.jqx.dataFormat) {
                        if ($.jqx.dataFormat.isDate(value)) {
                            value = $.jqx.dataFormat.formatdate(value, column.cellsformat, this.gridlocalization);
                        }
                        else if ($.jqx.dataFormat.isNumber(value)) {
                            value = $.jqx.dataFormat.formatnumber(value, column.cellsformat, this.gridlocalization);
                        }
                    }
                }

                var margin = '8px';
                if (this.rowsheight != 31) {
                    margin = (this.rowsheight / 2 - this._cellheight / 2);
                    if (margin < 0) {
                        margin = 4;
                    }
                    margin += 'px';
                }

                if (this.enableellipsis) {
                    if (column.cellsalign == 'center' || column.cellsalign == 'middle') {
                        return '<div class="jqx-grid-cell-middle-align" style="margin-top: ' + margin + ';">' + value + '</div>';
                    }

                    if (column.cellsalign == 'left')
                        return '<div class="jqx-grid-cell-left-align" style="margin-top: ' + margin + ';">' + value + '</div>';

                    if (column.cellsalign == 'right')
                        return '<div class="jqx-grid-cell-right-align" style="margin-top: ' + margin + ';">' + value + '</div>';
                }

                if (column.cellsalign == 'center' || column.cellsalign == 'middle') {
                    return '<div style="text-align: center; margin-top: ' + margin + ';">' + value + '</div>';
                }
                return '<span style="margin-left: 4px; margin-right: 2px; margin-top: ' + margin + '; float: ' + column.cellsalign + ';">' + value + '</span>';
            },

            getcelltext: function (row, datafield) {
                if (row == null || datafield == null)
                    return null;

                var cellvalue = this.getcellvalue(row, datafield);
                var column = this.getcolumn(datafield);
                if (column && column.cellsformat != '') {
                    if ($.jqx.dataFormat) {
                        if ($.jqx.dataFormat.isDate(cellvalue)) {
                            cellvalue = $.jqx.dataFormat.formatdate(cellvalue, column.cellsformat, this.gridlocalization);
                        }
                        else if ($.jqx.dataFormat.isNumber(cellvalue)) {
                            cellvalue = $.jqx.dataFormat.formatnumber(cellvalue, column.cellsformat, this.gridlocalization);
                        }
                    }
                }
                return cellvalue;
            },

            getcelltextbyid: function (row, datafield) {
                if (row == null || datafield == null)
                    return null;

                var cellvalue = this.getcellvaluebyid(row, datafield);
                var column = this.getcolumn(datafield);
                if (column && column.cellsformat != '') {
                    if ($.jqx.dataFormat) {
                        if ($.jqx.dataFormat.isDate(cellvalue)) {
                            cellvalue = $.jqx.dataFormat.formatdate(cellvalue, column.cellsformat, this.gridlocalization);
                        }
                        else if ($.jqx.dataFormat.isNumber(cellvalue)) {
                            cellvalue = $.jqx.dataFormat.formatnumber(cellvalue, column.cellsformat, this.gridlocalization);
                        }
                    }
                }
                return cellvalue;
            },

            _getcellvalue: function (column, row) {
                var value = null;
                value = row.bounddata[column.datafield];

                if (this.batcheditable) {
                    var tempValue = row.bounddata['_temp' + column.datafield];
                    if (tempValue !== undefined) {
                        value = tempValue;
                    }
                }

                if (column.displayfield != null) {
                    value = row.bounddata[column.displayfield];

                    if (this.batcheditable) {
                        var tempValue = row.bounddata['_temp' + column.displayfield];
                        if (tempValue !== undefined) {
                            value = tempValue;
                        }
                    }
                }

                if (value == null) value = "";

                if (this.enableSanitize && value && typeof value === 'string') {
                    var newValue = this.escape_HTML(value);

                    return newValue;
                }

                return value;
            },

            // gets a cell.
            getcell: function (row, datafield) {
                if (row == null || datafield == null)
                    return null;

                var rowindex = parseInt(row);
                var datarow = row;
                var value = '';

                if (!isNaN(rowindex)) {
                    datarow = this.getrowdata(rowindex);
                }

                if (datarow != null) {
                    value = datarow[datafield];
                }

                return this._getcellresult(value, row, datafield);
            },
            // gets the rendered cell data.
            getrenderedcell: function (row, datafield) {
                if (row == null || datafield == null)
                    return null;

                var rowindex = parseInt(row);
                var datarow = row;
                var value = '';

                if (!isNaN(rowindex)) {
                    datarow = this.getrenderedrowdata(rowindex);
                }

                if (datarow != null) {
                    value = datarow[datafield];
                }
                return this._getcellresult(value, row, datafield);
            },

            _getcellresult: function (value, row, datafield) {
                var column = this.getcolumn(datafield);
                if (column == null || column == undefined) {
                    return null;
                }

                var properties = column.getcolumnproperties();

                var hidden = properties.hidden;
                var width = properties.width;
                var pinned = properties.pinned;
                var align = properties.cellsalign;
                var format = properties.cellsformat;
                var height = this.getrowheight(row);

                // invalid row.
                if (height == false) {
                    return null;
                }

                return {
                    value: value, row: row, column: datafield, datafield: datafield, width: width, height: height, hidden: hidden, pinned: pinned, align: align, format: format
                };
            },

            setcellvaluebyid: function (row, datafield, value, refresh, sync) {
                var rowindex = this.getrowboundindexbyid(row);
                return this.setcellvalue(rowindex, datafield, value, refresh, sync);
            },

            getcellvaluebyid: function (row, datafield) {
                var rowindex = this.getrowboundindexbyid(row);
                return this.getcellvalue(rowindex, datafield);
            },

            setcellvalue: function (row, datafield, value, refresh, sync) {
                if (row == null || datafield == null)
                    return false;

                var rowindex = parseInt(row);
                var datasourcerowindex = rowindex;

                this._columnClassNameCache = [];

                var datarow = row;
                if (!isNaN(rowindex)) {
                    datarow = this.getrowdata(rowindex);
                }

                var hasfilter = false;
                if (this.filterable && this._initfilterpanel && this.dataview.filters.length) {
                    hasfilter = true;
                }
                if (this.virtualmode) {
                    this._pagescache = new Array();
                }
                if (this.sortcache) {
                    this.sortcache = {
                    };
                }

                var oldvalue = "";
                var olddisplayvalue = "";

                if (datarow[datafield] && value && $.jqx.dataFormat.isDate(datarow[datafield]) && $.jqx.dataFormat.isDate(value)) {
                    if (datarow[datafield].toString() === value.toString()) {
                        if (!this._updating && refresh != false) {
                            this._renderrows(this.virtualsizeinfo);
                        }
                        return;
                    }
                }

                if (datarow != null && datarow[datafield] !== value) {
                    if (datarow[datafield] === null && value === "") {
                        return;
                    }

                    var column = this._getcolumnbydatafield(datafield);
                    var type = 'string';

                    if (!this.source) {
                        this.source = new $.jqx.dataAdapter({
                        });
                    }

                    var datafields = this.source.datafields || ((this.source._source) ? this.source._source.datafields : null);

                    if (datafields) {
                        var foundType = "";
                        $.each(datafields, function () {
                            if (this.name == column.displayfield) {
                                if (this.type) {
                                    foundType = this.type;
                                }
                                return false;
                            }
                        });
                        if (foundType)
                            type = foundType;
                        olddisplayvalue = datarow[column.displayfield];
                    }

                    oldvalue = datarow[datafield];

                    if (this.pushToHistory) {
                        this._undoRedoIndex = -1;
                        this._undoRedo.push({ action: 'setcellvalue', data: { oldvalue: oldvalue, value: value, datafield: datafield, row: row } })
                    }
                    if (!column.nullable || (value != null && value !== "" && column.nullable && value.label === undefined)) {
                        if ($.jqx.dataFormat.isNumber(oldvalue) || type == 'number' || type == 'float' || type == 'int' || type == 'decimal' && type != 'date') {
                            if (this.gridlocalization && this.gridlocalization.decimalseparator == ",") {
                                if (value && value.indexOf && value.indexOf(",") >= 0) {
                                    value = value.replace(",", ".");
                                }
                            }
                            value = new Number(value);
                            value = parseFloat(value);
                            if (isNaN(value)) {
                                value = 0;
                            }
                        }
                        else if ($.jqx.dataFormat.isDate(oldvalue) || type == 'date') {
                            if (value != '') {
                                var tmp = value;
                                tmp = new Date(tmp);
                                if (tmp != 'Invalid Date' && tmp != null) {
                                    value = tmp;
                                }
                                else if (tmp == 'Invalid Date') {
                                    tmp = $.jqx.dataFormat.parsedate(value, column.cellsformat);
                                    value = tmp;
                                }
                            }
                        }
                        if (datarow[datafield] === value) {
                            if (!this._updating && refresh != false) {
                                this._renderrows(this.virtualsizeinfo);
                            }
                            return;
                        }
                    }

                    var isObservableArray = this.source && this.source._source.localdata && this.source._source.localdata.name === "observableArray";

                    datarow[datafield] = value;
                    if (isObservableArray) {
                        var observableArray = this.source._source.localdata;
                        if (!observableArray._updating) {
                            observableArray._updating = true;
                            observableArray[row][datafield] = value;
                            observableArray._updating = false;
                        }
                    }
                    var renderedrow = this.getrenderedrowdata(rowindex, true);
                    if (!renderedrow)
                        return;
                    renderedrow[datafield] = value;

                    if (this.batcheditable) {
                        datarow['_temp' + datafield] = value;
                        renderedrow['_temp' + datafield] = value;

                        datarow[datafield] = oldvalue;
                        renderedrow[datafield] = oldvalue;
                    }

                    if (value != null && value.label != null) {
                        var column = this._getcolumnbydatafield(datafield);
                        datarow[column.displayfield] = value.label;
                        renderedrow[column.displayfield] = value.label;
                        datarow[datafield] = value.value;
                        renderedrow[datafield] = value.value;
                        if (isObservableArray && !observableArray._updating) {
                            observableArray._updating = true;
                            observableArray[row][datafield] = value.value;
                            observableArray[row][column.displayfield] = value.label;
                            observableArray._updating = false;
                        }
                    }

                    if (hasfilter) {
                        if (datarow.dataindex != undefined) {
                            datasourcerowindex = datarow.dataindex;
                            this.dataview.cachedrecords[datarow.dataindex][datafield] = value;
                            if (value != null && value.label != undefined) {
                                this.dataview.cachedrecords[datarow.dataindex][datafield] = value.value;
                                this.dataview.cachedrecords[datarow.dataindex][column.displayfield] = value.label;
                            }
                        }
                    }
                }
                else {
                    if (!this._updating && refresh != false) {
                        this._renderrows(this.virtualsizeinfo);
                    }
                    return false;
                }

                if (this.source && this.source._knockoutdatasource && !this._updateFromAdapter && this.autokoupdates) {
                    if (this.source._source._localdata) {
                        var korowindex = rowindex;
                        if (hasfilter) {
                            if (datarow.dataindex != undefined) {
                                korowindex = datarow.dataindex;
                            }
                        }

                        var olditem = this.source._source._localdata()[korowindex];
                        this.source.suspendKO = true;
                        var oldobject = olditem;
                        if (oldobject[datafield] && oldobject[datafield].subscribe) {
                            if (value != null && value.label != null) {
                                oldobject[column.displayfield](value.label);
                                oldobject[datafield](value.value);
                            }
                            else {
                                oldobject[datafield](value);
                            }
                        }
                        else {
                            var datafields = this.source._source.datafields;
                            var sourcedatafield = null;
                            var map = null;
                            if (datafields) {
                                $.each(datafields, function () {
                                    if (this.name == datafield) {
                                        map = this.map;
                                        return false;
                                    }
                                });
                            }
                            if (map == null) {
                                if (value != null && value.label != null) {
                                    oldobject[datafield] = value.value;
                                    oldobject[column.displayfield] = value.label;
                                }
                                else {
                                    oldobject[datafield] = value;
                                }
                            }
                            else {
                                var splitMap = map.split(this.source.mapChar);
                                if (splitMap.length > 0) {
                                    var datavalue = oldobject;
                                    for (var p = 0; p < splitMap.length - 1; p++) {
                                        datavalue = datavalue[splitMap[p]];
                                    }
                                    datavalue[splitMap[splitMap.length - 1]] = value;
                                }
                            }
                            this.source._source._localdata.replace(olditem, $.extend({}, oldobject));
                        }

                        this.source.suspendKO = false;
                    }
                }

                if (this.sortcolumn && this.dataview.sortby && !this._updating) {
                    var sortinformation = this.getsortinformation();
                    if (this.sortcolumn == datafield && this.sortmode !== "many") {
                        this.dataview.clearsortdata();
                        this.dataview.sortby(sortinformation.sortcolumn, sortinformation.sortdirection.ascending);
                    }
                    else if (this.sortmode === "many") {
                        var columns = this.getsortcolumns();
                        this.dataview.clearsortdata();

                        this.sortby(null);

                        for (var i = 0; i < columns.length; i++) {
                            this.sortby(columns[i].dataField, columns[i].ascending);
                        }

                    }
                }
                else if (!this._updating) {
                    if (this.dataview.sortby) {
                        if (this.dataview.sortcache[datafield]) {
                            this.dataview.sortcache[datafield] = null;
                        }
                    }
                }

                this._cellscache = new Array();
                // !
                this._pagescache = new Array();

                if (this.source.updaterow && (sync == undefined || sync == true)) {
                    var success = false;
                    var me = this.that;
                    var result = function (param) {
                        if (false == param) {
                            me.setcellvalue(row, datafield, oldvalue, true, false);
                            if (oldvalue != olddisplayvalue) {
                                me.setcellvalue(row, me.getcolumn(datafield).displayfield, olddisplayvalue, true, false);
                            }
                        }
                    }
                    try {
                        var rowid = this.getrowid(rowindex);
                        success = this.source.updaterow(rowid, datarow, result);
                        if (success == undefined) success = true;
                    }
                    catch (error) {
                        success = false;
                        me.setcellvalue(row, datafield, oldvalue, true, false);
                        if (oldvalue != olddisplayvalue) {
                            me.setcellvalue(row, me.getcolumn(datafield).displayfield, olddisplayvalue, true, false);
                        }
                        return;
                    }
                }

                //     var rowid = this.getrowid(row);
                var scrollvalue = this.vScrollInstance.value;

                if (this._updating && refresh != true) {
                    refresh = false;
                }

                if (refresh == true || refresh == undefined) {
                    var me = this.that;
                    var updatepager = function () {
                        if (me.pageable && me.updatepagerdetails) {
                            me.updatepagerdetails();
                            if (me.autoheight || me.autorowheight) {
                                me._updatepageviews();
                            }
                        }
                    }
                    var hasgroups = this.groupable && this.groups.length > 0;

                    if (hasfilter && !hasgroups) {
                        if (this.autoheight || this.autorowheight) this.prerenderrequired = true;
                        this.dataview.refresh();
                        this.rendergridcontent(true, false);
                        updatepager();
                        this._renderrows(this.virtualsizeinfo);
                    }
                    else if (this.sortcolumn && !hasgroups) {
                        if (this.autoheight || this.autorowheight) this.prerenderrequired = true;
                        this.dataview.reloaddata();
                        this.rendergridcontent(true, false);
                        updatepager();
                        this._renderrows(this.virtualsizeinfo);
                    }
                    else if (this.groupable && this.groups.length > 0) {
                        if (this.autoheight || this.autorowheight) this.prerenderrequired = true;
                        if (this.pageable) {
                            if (this.groups.indexOf(datafield) != -1) {
                                this._pagescache = new Array();
                                this._cellscache = new Array();
                                this.dataview.refresh();
                                this._render(true, true, false, false);
                            }
                            else {
                                this._pagescache = new Array();
                                this._cellscache = new Array();
                                this.dataview.updateview();
                                this._renderrows(this.virtualsizeinfo);
                            }
                        }
                        else {
                            this._pagescache = new Array();
                            this._cellscache = new Array();
                            this.dataview.updateview();
                            this._renderrows(this.virtualsizeinfo);

                            //     this.dataview.updateview();
                            //     this._renderrows(this.virtualsizeinfo);
                        }
                        //                    this.dataview.reloaddata();
                        //                    this.render(true, true, false, false);
                        //                    var datarow = this.getrowdata(row);
                        //                    var renderedrow = this.getrenderedrowdata(rowindex, true);
                        //                    var parentItem = renderedrow.parentItem;
                        //                    this._setgroupstate(parentItem, true, true);
                    }
                    else {
                        this.dataview.updateview();
                        this._renderrows(this.virtualsizeinfo);
                    }
                }
                this.vScrollInstance.setPosition(scrollvalue);
                if (this.showaggregates && this._updatecolumnsaggregates) {
                    this._updatecolumnsaggregates();
                }
                if (this.showfilterrow && this.filterable && this.filterrow) {
                    var filtertype = this.getcolumn(datafield).filtertype;
                    if (filtertype == 'list' || filtertype == 'checkedlist') {
                        this._updatelistfilters(true);
                    }
                }

                this._raiseEvent(19, {
                    rowindex: row, datafield: datafield, newvalue: value, value: value, oldvalue: oldvalue
                });
                return true;
            },

            // get cell's bound value.
            getcellvalue: function (row, datafield) {
                if (row == null || datafield == null)
                    return null;

                var rowindex = parseInt(row);
                var datarow = row;
                if (!isNaN(rowindex)) {
                    datarow = this.getrowdata(rowindex);
                }

                if (datarow != null) {
                    var value = datarow[datafield];
                    return value;
                }

                return null;
            },

            getrows: function () {
                var length = this.dataview.records.length;
                if (this.virtualmode) {
                    var rows = new Array();

                    for (var i = 0; i < this.dataview.records.length; i++) {
                        var record = this.dataview.records[i];
                        if (record) {
                            rows.push(record);
                        }
                    }
                    if (this.dataview.records.length === undefined) {
                        $.each(this.dataview.records, function () {
                            var record = this;
                            if (record) {
                                rows.push(record);
                            }
                        });
                    }

                    var recordsoffset = 0;
                    if (this.pageable) {
                        recordsoffset = this.dataview.pagenum * this.dataview.pagesize;
                    }

                    if (rows.length > this.source._source.totalrecords - recordsoffset) {
                        return rows.slice(0, this.source._source.totalrecords - recordsoffset);
                    }
                    return rows;
                }

                if (this.dataview.sortdata) {
                    var rows = new Array();
                    for (var i = 0; i < length; i++) {
                        var item = {
                        };
                        item = $.extend({}, this.dataview.sortdata[i].value);
                        rows[i] = item;
                    }
                    return rows;
                }
                else return this.dataview.records;
            },

            getrowboundindexbyid: function (id) {
                var rowdata = this.dataview.recordsbyid["id" + id];
                if (rowdata) {
                    if (rowdata.boundindex)
                        return this.getboundindex(rowdata);
                }

                var rows = this.getboundrows();
                for (var i = 0; i < rows.length; i++) {
                    if (rows[i]) {
                        if (rows[i].uid == id) {
                            return i;
                        }
                    }
                }

                return -1;
            },

            getrowdatabyid: function (id) {
                var rowdata = this.dataview.recordsbyid["id" + id];
                if (rowdata) {
                    return rowdata;
                }
                else {
                    var index = this.getrowboundindexbyid(id);
                    return this.getboundrows()[index];
                }

                return null;
            },

            // get getrowdata.
            getrowdata: function (boundindex) {
                if (boundindex == undefined)
                    boundindex = 0;

                if (this.virtualmode) {
                    var record = this.dataview.records[boundindex];
                    return record;
                }
                else {
                    var record = this.getboundrows()[boundindex];
                    return record;
                }

                return null;
            },

            // deprecated.
            // get visible row data.
            getrenderedrowdata: function (boundindex, bypasspaging) {
                if (boundindex == undefined)
                    boundindex = 0;

                if (this.virtualmode) {
                    var visibleindex = this.getrowvisibleindex(boundindex);
                    var record = this.dataview.loadedrecords[visibleindex];
                    return record;
                }

                var visibleindex = this.getrowvisibleindex(boundindex);
                if (visibleindex >= 0) {
                    if (this.groupable && this.groups.length > 0) {
                        var record = this.dataview.loadedrecords[visibleindex];
                    }
                    else {
                        var record = this.dataview.loadedrecords[visibleindex];

                        if (this.pageable && (bypasspaging == undefined || bypasspaging == false)) {
                            var record = this.dataview.loadedrecords[this.dataview.pagesize * this.dataview.pagenum + boundindex];
                        }
                    }
                    return record;
                }

                return null;
            },

            // gets all rows loaded in jqxGrid.
            getboundrows: function () {
                return this.dataview.cachedrecords;
            },

            getrowdisplayindex: function (boundindex) {
                var rows = this.getdisplayrows();
                for (var i = 0; i < rows.length; i++) {
                    if (!rows[i]) continue;
                    if (rows[i].dataindex !== undefined) {
                        if (rows[i].dataindex == boundindex)
                            return rows[i].visibleindex;
                    }
                    else {
                        if (rows[i].boundindex == boundindex)
                            return rows[i].visibleindex;
                    }
                }
                return -1;
            },

            getboundindex: function (row) {
                var boundindex = row.boundindex;
                if (this.groupable && this.groups.length > 0 && this.pageable) {
                    if (row.bounddata) {
                        boundindex = this.getrowboundindexbyid(row.bounddata.uid);
                    }
                }

                if (this.dataview.filters.length > 0) {
                    if (row.bounddata) {
                        if (row.bounddata.dataindex !== undefined) {
                            boundindex = row.bounddata.dataindex;
                        }
                    }
                    else {
                        if (row.dataindex !== undefined) {
                            boundindex = row.dataindex;
                        }
                    }
                }
                return boundindex;
            },

            getrowboundindex: function (displayindex) {
                var rowdata = this.getdisplayrows()[displayindex];
                if (rowdata) {
                    if (rowdata.dataindex !== undefined) {
                        return rowdata.dataindex;
                    }

                    return rowdata.boundindex;
                }
                return -1;
            },

            // gets all rows displayed in jqxGrid.
            getdisplayrows: function () {
                return this.dataview.loadedrecords;
            },

            // deprecated.
            getloadedrows: function () {
                return this.getdisplayrows();
            },

            // deprecated.
            getvisiblerowdata: function (visibleindex) {
                var visiblerows = this.getvisiblerows();
                if (visiblerows) {
                    return visiblerows[visibleindex];
                }

                return null;
            },

            // deprecated.
            getloadedrowdata: function (visibleindex) {
                var visiblerows = this.getloadedrows();
                if (visiblerows) {
                    return visiblerows[visibleindex];
                }

                return null;
            },

            // deprecated.
            getvisiblerows: function () {
                if (this.virtualmode) {
                    return this.dataview.loadedrecords
                }

                if (this.pageable) {
                    var rows = [];
                    for (var i = 0; i < this.dataview.pagesize; i++) {
                        var record = this.dataview.loadedrecords[i + (this.dataview.pagesize * this.dataview.pagenum)];
                        if (record == undefined) break;
                        rows.push(record);
                    }
                    return rows;
                }
                else {
                    if (this._startboundindex != undefined && this._endboundindex != undefined) {
                        var rows = [];

                        for (var i = this._startvisibleindex; i <= this._endvisibleindex; i++) {
                            var record = this.dataview.loadedrecords[i];
                            if (record == undefined) break;
                            rows.push(record);
                        }
                        return rows;
                    }
                }

                return this.dataview.loadedrecords;
            },

            // get row id.
            getrowid: function (boundindex) {
                if (boundindex == undefined)
                    boundindex = 0;

                if (this.virtualmode) {
                    var visibleindex = this.getrowvisibleindex(boundindex);
                    var record = this.dataview.loadedrecords[visibleindex];
                    if (record)
                        return record.uid;
                }
                else {
                    var record = null;
                    var hasFilters = this.dataview.filters.length > 0;
                    if (boundindex >= 0 && boundindex < this.dataview.bounditems.length && !hasFilters) {
                        if (this.groupable && this.groups.length > 0) {
                            var visibleindex = this.getrowvisibleindex(boundindex);
                            var record = this.dataview.loadedrecords[visibleindex];
                        }
                        else {
                            var visibleindex = this.getrowvisibleindex(boundindex);
                            var record = this.dataview.loadedrecords[visibleindex];
                        }
                        if (record)
                            return record.uid;
                    }
                    if (this.dataview.filters.length > 0) {
                        var record = this.getboundrows()[boundindex];
                        if (record) {
                            if (record.uid != null) {
                                return record.uid;
                            }
                        }
                        return null;
                    }
                }

                return null;
            },

            _updateGridData: function (reason) {
                var hasfilter = false;
                if (this.filterable && this._initfilterpanel && this.dataview.filters.length) {
                    hasfilter = true;
                }
                if (hasfilter) {
                    this.dataview.refresh();
                    if (reason == "updaterow") {
                        this._render(true, true, false, false, false);
                        this.invalidate();
                    }
                    else {
                        this.render();
                    }
                }
                else if (this.sortcolumn || (this.groupable && this.groups.length > 0)) {
                    this.dataview.reloaddata();
                    this.render();
                }
                else {
                    if (reason === "updaterow") {
                        this.dataview.refresh();
                        if (!this.virtualmode) {
                            this._render(true, true, false, false, false);
                        }
                    }
                    this._cellscache = new Array();
                    this._pagescache = new Array();
                    this._renderrows(this.virtualsizeinfo);
                }
                if (this.showfilterrow && this.filterable && this.filterrow) {
                    this._updatelistfilters(true);
                }
            },

            // update row.
            updaterow: function (rowid, rowdata, refresh) {
                if (rowid != undefined && rowdata != undefined) {
                    var me = this.that;
                    var success = false;
                    me._datachanged = true;

                    this._columnClassNameCache = [];

                    if (this.pushToHistory) {
                        var oldvalues = this.getrowdatabyid(rowid);
                        this._undoRedoIndex = -1;
                        this._undoRedo.push({ action: 'updaterow', data: { id: rowid, rowdata: rowdata, oldrowdata: oldvalues } })
                    }
                    var applychanges = function (me, rowid, rowdata) {
                        if (me._loading) {
                            throw new Error('jqxGrid: ' + me.loadingerrormessage);
                            return false;
                        }

                        var success = false;
                        if (!$.isArray(rowid)) {
                            success = me.dataview.updaterow(rowid, rowdata);
                        }
                        else {
                            $.each(rowid, function (index, value) {
                                var id = '' + this;
                                success = me.dataview.updaterow(id, rowdata[index], false);
                            });
                            me._cellscache = new Array();
                            me._pagescache = new Array();
                            me.dataview.refresh();
                        }

                        var scrollvalue = me.vScrollInstance.value;
                        if (refresh == undefined || refresh == true) {
                            if (me._updating == undefined || me._updating == false) {
                                me._updateGridData("updaterow");
                            }
                        }

                        if (me.showaggregates && me._updatecolumnsaggregates) {
                            me._updatecolumnsaggregates();
                        }

                        if (me.source && me.source._knockoutdatasource && !me._updateFromAdapter && me.autokoupdates) {
                            if (me.source._source._localdata) {
                                var record = me.dataview.recordsbyid["id" + rowid];
                                var recordindex = me.dataview.records.indexOf(record);
                                var olditem = me.source._source._localdata()[recordindex];
                                me.source.suspendKO = true;
                                me.source._source._localdata.replace(olditem, $.extend({}, record));
                                me.source.suspendKO = false;
                            }
                        }
                        var isObservableArray = me.source && me.source._source.localdata && me.source._source.localdata.name === "observableArray";
                        if (isObservableArray) {
                            if (!me.source._source.localdata._updating) {
                                me.source._source.localdata._updating = true;
                                var rowindex = me.getrowboundindexbyid(rowid);
                                me.source._source.localdata.set(rowindex, rowdata);
                                me.source._source.localdata._updating = false;
                            }
                        }
                        me.vScrollInstance.setPosition(scrollvalue);
                        return success;
                    }

                    if (this.source.updaterow) {
                        var done = function (result) {
                            if (result == true || result == undefined) {
                                applychanges(me, rowid, rowdata);
                            }
                            else success = false;
                        }
                        try {
                            success = this.source.updaterow(rowid, rowdata, done);
                            if (success == undefined) success = true;
                        }
                        catch (error) {
                            success = false;
                        }
                    }
                    else {
                        success = applychanges(me, rowid, rowdata);
                    }

                    return success;
                }

                return false;
            },

            // delete row.
            deleterow: function (rowid, refresh) {
                if (rowid != undefined) {
                    this._datachanged = true;
                    var success = false;
                    var me = this.that;
                    var rowindex = this.getrowboundindexbyid(rowid);
                    var selectedRowIds = new Array();
                    var selectedCellIds = new Array();
                    if (rowindex != undefined) {
                        if (this.selectedrowindexes.indexOf(rowindex) >= 0) {
                            this.selectedrowindexes.splice(this.selectedrowindexes.indexOf(rowindex), 1);
                        }
                        if (this.selectedrowindex == rowindex)
                            this.selectedrowindex = -1;

                        if (!this.virtualmode) {
                            if (me.selectionmode.indexOf('row') >= 0) {
                                $.each(this.selectedrowindexes, function () {
                                    var currentrowid = me.getrowid(this);
                                    selectedRowIds.push(currentrowid);
                                });
                                this.selectedrowindexes = new Array();
                                this.selectedrowindex = -1;
                            }
                            else if (me.selectionmode.indexOf('cell') >= 0) {
                                for (var obj in me.selectedcells) {
                                    var cell = me.selectedcells[obj];
                                    var currentrowid = me.getrowid(cell.rowindex);
                                    cell.rowid = currentrowid;
                                }
                            }
                            this._rendervisualrows();
                        }
                    }

                    var applychanges = function (me, rowid) {
                        if (me._loading) {
                            throw new Error('jqxGrid: ' + me.loadingerrormessage);
                            return false;
                        }

                        var success = false;
                        var scrollvalue = me.vScrollInstance.value;
                        if (!$.isArray(rowid)) {
                            var success = me.dataview.deleterow(rowid);
                        }
                        else {
                            $.each(rowid, function () {
                                success = me.dataview.deleterow(this, false);
                            });
                            me._cellscache = new Array();
                            me._pagescache = new Array();
                            me.dataview.refresh();
                        }
                        if (!me.virtualmode) {
                            if (me.selectionmode.indexOf('row') >= 0) {
                                $.each(selectedRowIds, function () {
                                    var boundindex = me.getrowboundindexbyid(this);
                                    if (boundindex != -1) {
                                        me.selectrow(boundindex, false);
                                    }
                                });
                            }
                            else {
                                var selectedcells = new Array();

                                for (var obj in me.selectedcells) {
                                    var cell = me.selectedcells[obj];
                                    var currentrowid = cell.rowid;
                                    var boundindex = me.getrowboundindexbyid(currentrowid);
                                    if (boundindex != -1) {
                                        cell.rowindex = boundindex;
                                        selectedcells[boundindex + "_" + cell.datafield] = cell;
                                    }
                                }
                                me.selectedcells = selectedcells;
                            }
                        }

                        if (me._updating == undefined || me._updating == false) {
                            if (refresh == undefined || refresh == true) {
                                setTimeout(function () {
                                    me._render(true, true, false, false);
                                    if (me.vScrollBar.css('visibility') != 'visible') {
                                        me._arrange();
                                        me._updatecolumnwidths();
                                        me._updatecellwidths();
                                        me._renderrows(me.virtualsizeinfo);
                                    }
                                    me.vScrollInstance.setPosition(scrollvalue);
                                });
                            }
                        }

                        if (me.source && me.source._knockoutdatasource && !me._updateFromAdapter && me.autokoupdates) {
                            if (me.source._source._localdata) {
                                me.source.suspendKO = true;
                                me.source._source._localdata.pop();
                                me.source.suspendKO = false;
                            }
                        }
                        var isObservableArray = me.source && me.source._source.localdata && me.source._source.localdata.name === "observableArray";
                        if (isObservableArray) {
                            if (!me.source._source.localdata._updating) {
                                me.source._source.localdata._updating = true;
                                me.source._source.localdata.splice(rowindex, 1);
                                me.source._source.localdata._updating = false;
                            }
                        }
                        if (me.dataview.sortby && me.sortmode !== "many") {
                            var sortinformation = me.getsortinformation();
                            if (sortinformation.sortcolumn) {
                                me.dataview.clearsortdata();
                                me.dataview.sortby(sortinformation.sortcolumn, sortinformation.sortdirection ? sortinformation.sortdirection.ascending : null);
                            }
                        }

                        me.vScrollInstance.setPosition(scrollvalue);
                        return success;
                    }

                    if (this.source.deleterow) {
                        var done = function (result) {
                            if (result == true || result == undefined) {
                                applychanges(me, rowid);
                            }
                        }
                        try {
                            this.source.deleterow(rowid, done);
                            if (success == undefined) success = true;
                        }
                        catch (error) {
                            success = false;
                        }
                    }
                    else {
                        success = applychanges(me, rowid);
                    }
                    return success;
                }

                return false;
            },

            // add row.
            addrow: function (rowid, rowdata, position) {
                if (rowdata != undefined) {
                    this._datachanged = true;
                    if (position == undefined) {
                        position = 'last';
                    }

                    var success = false;
                    var me = this.that;

                    if (rowid == null) {
                        var hasFilter = this.dataview.filters && this.dataview.filters.length > 0;
                        var totallength = !hasFilter ? this.dataview.totalrecords : this.dataview.cachedrecords.length;
                        if (!$.isArray(rowdata)) {
                            rowid = this.dataview.getid(this.dataview.source.id, rowdata, totallength);
                            while (null != this.dataview.recordsbyid["id" + rowid]) {
                                rowid++;
                            }
                        } else {
                            var ids = new Array();
                            $.each(rowdata, function (index, value) {
                                var id = me.dataview.getid(me.dataview.source.id, rowdata[index], totallength + index);
                                ids.push(id);
                            });
                            rowid = ids;
                        }
                    }

                    var applychanges = function (me, rowid, rowdata, position) {
                        if (me._loading) {
                            throw new Error('jqxGrid: ' + me.loadingerrormessage);
                            return false;
                        }

                        var scrollvalue = me.vScrollInstance.value;
                        var success = false;
                        if (!$.isArray(rowdata)) {
                            if (rowdata != undefined && rowdata.dataindex != undefined) {
                                delete rowdata.dataindex;
                            }
                            success = me.dataview.addrow(rowid, rowdata, position);
                        }
                        else {
                            $.each(rowdata, function (index, value) {
                                if (this.dataindex != undefined) {
                                    delete this.dataindex;
                                }

                                var id = null;
                                if (rowid != null && rowid[index] != null) id = rowid[index];
                                success = me.dataview.addrow(id, this, position, false);
                            });
                            me._cellscache = new Array();
                            me._pagescache = new Array();
                            me.dataview.refresh();
                        }

                        if (me._updating == undefined || me._updating == false) {
                            me._render(true, true, false, false);
                            me.invalidate();
                        }

                        if (me.source && me.source._knockoutdatasource && !me._updateFromAdapter && me.autokoupdates) {
                            if (me.source._source._localdata) {
                                me.source.suspendKO = true;
                                me.source._source._localdata.push(rowdata);
                                me.source.suspendKO = false;
                            }
                        }

                        var isObservableArray = me.source && me.source._source.localdata && me.source._source.localdata.name === "observableArray";
                        if (isObservableArray) {
                            if (!me.source._source.localdata._updating) {
                                me.source._source.localdata._updating = true;
                                var rowindex = me.getrowboundindexbyid(rowid);
                                me.source._source.localdata.set(rowindex, rowdata);
                                me.source._source.localdata._updating = false;
                            }
                        }

                        if (me.scrollmode != "deferred") {
                            me.vScrollInstance.setPosition(scrollvalue);
                        }
                        else {
                            me.vScrollInstance.setPosition(0);
                        }

                        return success;
                    }

                    if (this.source && this.source.addrow) {
                        var done = function (result, ids) {
                            if (result == true || result == undefined) {
                                if (ids != undefined) {
                                    rowid = ids;
                                }

                                applychanges(me, rowid, rowdata, position);
                            }
                        }
                        // undefined or true response code are handled as success. false or exception as failure
                        try {
                            success = this.source.addrow(rowid, rowdata, position, done);
                            if (success == undefined) {
                                success = true;
                            }
                        }
                        catch (e) {
                            success = false;
                        }
                        if (success == false) {
                            return false;
                        }
                    }
                    else {
                        applychanges(this, rowid, rowdata, position);
                    }

                    return success;
                }
                return false;
            },

            _findvisiblerow: function (value, collection) {
                if (value == undefined) {
                    value = parseInt(this.vScrollInstance.value);
                }
                var min = 0;
                if (collection == undefined || collection == null) {
                    collection = this.rows.records;
                }

                var max = collection.length;
                while (min <= max) {
                    var mid = parseInt((min + max) / 2)
                    var item = collection[mid];

                    if (item == undefined)
                        break;

                    if (item.top > value && item.top + item.height > value) {
                        max = mid - 1;
                    } else if (item.top < value && item.top + item.height < value) {
                        min = mid + 1;
                    } else {
                        return mid;
                        break;
                    }
                }

                return -1;
            },

            _updatecellwidths: function () {
                var virtualsizeinfo = this.virtualsizeinfo;
                if (!virtualsizeinfo) {
                    return;
                }
                var me = this.that;

                if (me.gridcontent == undefined)
                    return;

                if (me.table == undefined) {
                    me.table = me.gridcontent.find('#contenttable' + me.element.id);
                }

                var hasgroups = me.groupable && me.groups.length > 0;
                var tablewidth = 0;
                var pagesize = virtualsizeinfo.visiblerecords;

                if (me.pageable && (me.autoheight || me.autorowheight)) {
                    pagesize = me.dataview.pagesize;

                    if (me.groupable) {
                        me.dataview.updateview();
                        pagesize = me.dataview.rows.length;
                    }
                }

                if (!me.groupable && !me.pageable && (me.autoheight || me.autorowheight)) {
                    pagesize = me.dataview.totalrecords;
                }

                if (me.rowdetails) {
                    pagesize += me.dataview.pagesize;
                }

                if (!me.columns.records)
                    return;

                var columnslength = me.columns.records.length;
                var rows = me.table[0].rows;
                for (var i = 0; i < pagesize; i++) {
                    var tablerow = rows[i];
                    if (!tablerow)
                        break;

                    var cells = tablerow.cells;
                    var left = 0;
                    for (var j = 0; j < columnslength; j++) {
                        var columnrecord = me.columns.records[j];
                        var width = columnrecord.width;
                        if (columnrecord.adaptivewidth) {
                            width = columnrecord.adaptivewidth;
                        }
                        var tablecolumn = cells[j];
                        if (parseInt(tablecolumn.style.left) != left) {
                            tablecolumn.style.left = left + 'px';
                        }

                        if (parseInt(tablecolumn.style.width) != width) {
                            tablecolumn.style.width = width + 'px';
                        }
                        //     tablecolumn[0].left = left;
                        if (!(columnrecord.hidden && columnrecord.hideable) && !columnrecord.adaptivehidden) {
                            left += parseFloat(width);

                            if (me.adaptive) {
                                tablecolumn.style.display = "";
                            }
                        }
                        else {
                            tablecolumn.style.display = "none";
                        }
                    }

                    if (tablewidth == 0) {
                        me.table.width(parseFloat(left) + 2);
                        tablewidth = left;
                    }
                }

                if (me.showaggregates && me._updateaggregates) {
                    me._updateaggregates();
                }
                if (me.showfilterrow && me.filterable && me._updatefilterrowui) {
                    me._updatefilterrowui();
                }
                if (me.showeverpresentrow) {
                    me._updateaddnewrowui();
                }
                me._updatescrollbarsafterrowsprerender();
                if (hasgroups) {
                    me._renderrows(me.virtualsizeinfo);
                }
            },

            _updatescrollbarsafterrowsprerender: function () {
                var me = this.that;
                var hscrollbarvisibility = me.hScrollBar[0].style.visibility;
                var offset = 0;

                var vscrollbarvisibility = me.vScrollBar[0].style.visibility;
                if (vscrollbarvisibility == 'visible') {
                    offset = me.scrollbarsize + 3;
                }
                if (me.scrollbarsize == 0) {
                    offset = 0;
                }
                if (me.scrollbarautoshow) {
                    offset = 0;
                }

                var w = me.element.style.width;
                if (w.toString().indexOf('%') >= 0) {
                    w = me.host.width();
                }
                else {
                    w = parseInt(w);
                }

                if (parseInt(me.table[0].style.width) - 2 > w - offset) {
                    if (hscrollbarvisibility != 'visible') {
                        if (!me.autowidth) {
                            me.hScrollBar[0].style.visibility = 'visible';
                        }
                        me._arrange();
                    }

                    if (vscrollbarvisibility == 'visible') {
                        if (me.scrollmode != 'deferred' && !me.virtualmode) {
                            if (me.virtualsizeinfo) {
                                var vscrollbarmax = me.virtualsizeinfo.virtualheight - me._gettableheight();
                                if (!isNaN(vscrollbarmax) && vscrollbarmax > 0) {
                                    if (hscrollbarvisibility != 'hidden') {
                                        me.vScrollBar.jqxScrollBar('max', vscrollbarmax + me.scrollbarsize + 4);
                                    }
                                    else {
                                        me.vScrollBar.jqxScrollBar('max', vscrollbarmax);
                                    }
                                }
                            }
                        }
                        else {
                            me._updatevscrollbarmax();
                        }
                    }
                    else {
                        offset = -2;
                        if ((me.table.width() - me.host.width()) === 3) {
                            offset = -3;
                        }
                    }

                    me.hScrollBar.jqxScrollBar('max', offset + me.table.width() - me.host.width());
                }
                else {
                    if (hscrollbarvisibility != 'hidden') {
                        me.hScrollBar.css('visibility', 'hidden');
                        me._arrange();
                    }
                }
                me._renderhorizontalscroll();
            },

            _hascolumnstyle: function () {
                if (undefined !== this._hascolumnstyles) {
                    return this._hascolumnstyles;
                }

                this._hascolumnstyles = false;

                for (var i = 0; i < this.columns.records.length; i++) {
                    var column = this.columns.records[i];

                    if (
                        column.style.headerBackgroundColor ||
                        column.style.headerColor ||
                        column.style.headerBackgroundHoveredColor ||
                        column.style.headerHoveredColor ||
                        column.style.headerBackgroundSelectedColor ||
                        column.style.headerSelectedColor ||
                        column.style.backgroundColor ||
                        column.style.color ||
                        column.style.backgroundHoveredColor ||
                        column.style.hoveredColor ||
                        column.style.backgroundSelectedColor ||
                        column.style.selectedColor
                    ) {
                        this._hascolumnstyles = true;
                        return true;
                    }
                }

                return false;
            },

            _prerenderrows: function (virtualsizeinfo) {
                var me = this.that;
                if (me.prerenderrequired == true) {
                    me.prerenderrequired = false;
                    if (me.editable && me._destroyeditors) {
                        me._destroyeditors();
                    }

                    if (me.gridcontent == undefined)
                        return;

                    me.gridcontent.find('#contenttable' + me.element.id).remove();
                    if (me.table != null) {
                        me.table.remove();
                        me.table = null;
                    }

                    me.table = $('<div id="contenttable' + me.element.id + '" style="overflow: hidden; position: relative;"></div>');
                    me.gridcontent.addClass(me.toTP('jqx-grid-content'));
                    me.gridcontent.addClass(me.toTP('jqx-widget-content'));
                    me.gridcontent.append(me.table);
                    var hasgroups = me.groupable && me.groups.length > 0;
                    var tablewidth = 0;
                    me.table[0].rows = new Array();
                    var cellclass = me.toTP('jqx-grid-cell');
                    if (hasgroups) {
                        cellclass = ' ' + me.toTP('jqx-grid-group-cell');
                    }

                    var pagesize = virtualsizeinfo.visiblerecords;

                    if (me.pageable && (me.autoheight || me.autorowheight)) {
                        pagesize = me.dataview.pagesize;
                        if (me.groupable) {
                            me.dataview.updateview();
                            pagesize = me.dataview.rows.length;
                            if (pagesize < me.dataview.pagesize) {
                                pagesize = me.dataview.pagesize;
                            }
                        }
                    }

                    if (!me.pageable && (me.autoheight || me.autorowheight)) {
                        pagesize = me.dataview.totalrecords;
                    }

                    if (me.groupable && me.groups.length > 0 && (me.autoheight || me.autorowheight) && !me.pageable) {
                        pagesize = me.dataview.rows.length;
                    }

                    if (me.rowdetails) {
                        if (me.autoheight || me.autorowheight) {
                            pagesize += me.dataview.pagesize;
                        }
                        else {
                            pagesize += pagesize;
                        }
                    }
                    if (!me.columns.records) {
                        return;
                    }

                    var columnslength = me.columns.records.length;

                    if ($.jqx.browser.msie && $.jqx.browser.version > 8) {
                        me.table.css('opacity', '0.99');
                    }

                    if ($.jqx.browser.mozilla) {
                        //        me.table.css('opacity', '0.99');
                    }

                    if (navigator.userAgent.indexOf('Safari') != -1) {
                        //  me.table.css('opacity', '0.99');
                    }

                    var isIE7 = $.jqx.browser.msie && $.jqx.browser.version < 8;
                    if (isIE7) {
                        me.host.attr("hideFocus", "true");
                    }

                    var zindex = me.tableZIndex;
                    if (pagesize * columnslength > zindex) {
                        zindex = pagesize * columnslength;
                    }
                    var isempty = me.dataview.records.length == 0;
                    var isTouch = me.isTouchDevice();
                    var tableHTML = "";
                    me._hiddencolumns = false;

                    var tabindex = 5 + me.columns.records.length;
                    for (var i = 0; i < pagesize; i++) {
                        var tablerow = '<div role="row" style="position: relative; height:' + me.rowsheight + 'px;" id="row' + i + me.element.id + '">';
                        if (isIE7) {
                            var tablerow = '<div role="row" style="position: relative; z-index: ' + zindex + '; height:' + me.rowsheight + 'px;" id="row' + i + me.element.id + '">';
                            zindex--;
                        }

                        var left = 0;

                        for (var j = 0; j < columnslength; j++) {
                            var columnrecord = me.columns.records[j];
                            var width = columnrecord.width;
                            if (width < columnrecord.minwidth) width = columnrecord.minwidth;
                            if (width > columnrecord.maxwidth) width = columnrecord.maxwidth;
                            if (me.rtl) {
                                var rtlzindex = zindex - columnslength + 2 * j;
                                var tablecolumn = '<div columnindex="' + j + '" role="gridcell" style="left: ' + left + 'px; z-index: ' + rtlzindex + '; width:' + width + 'px;';
                                zindex--;
                            }
                            else var tablecolumn = '<div columnindex="' + j + '" role="gridcell" style="left: ' + left + 'px; z-index: ' + zindex-- + '; width:' + width + 'px;';

                            if (!(columnrecord.hidden && columnrecord.hideable) && !columnrecord.adaptivehidden) {
                                left += width;
                            }
                            else {
                                tablecolumn += 'display: none;'
                                me._hiddencolumns = true;
                                zindex++;
                            }
                            if (i === 0 && j === 0) {
                                tablecolumn += '" tabindex="' + tabindex + '"';
                            }

                            tablecolumn += '" class="' + cellclass + '">';
                            var cellValue = this._defaultcellsrenderer("", columnrecord);
                            tablecolumn += cellValue;
                            tablecolumn += '</div>';
                            tablerow += tablecolumn;
                        }

                        if (tablewidth == 0) {
                            me.table.width(parseInt(left) + 2);
                            tablewidth = left;
                        }

                        tablerow += '</div>';
                        tableHTML += tablerow;
                    }

                    if (me.WinJS) {
                        MSApp.execUnsafeLocalFunction(function () {
                            me.table.html(tableHTML);
                        });
                    }
                    else {
                        me.table[0].innerHTML = tableHTML;
                    }

                    me.table[0].rows = new Array();
                    var rows = me.table.children();
                    for (var i = 0; i < pagesize; i++) {
                        var row = rows[i];
                        me.table[0].rows.push(row);
                        row.cells = new Array();
                        var cells = $(row).children();
                        for (var j = 0; j < columnslength; j++) {
                            row.cells.push(cells[j]);
                        }
                    }

                    if (pagesize == 0) {
                        var left = 0;
                        if (me.showemptyrow) {
                            var tablerow = $('<div style="position: relative;" id="row0' + me.element.id + '"></div>');
                            me.table.append(tablerow);
                            tablerow.height(me.rowsheight);
                            me.table[0].rows[0] = tablerow[0];
                            me.table[0].rows[0].cells = new Array();
                        }
                        for (var j = 0; j < columnslength; j++) {
                            var columnrecord = me.columns.records[j];
                            var width = columnrecord.width;
                            if (me.showemptyrow) {
                                var tablecolumn = $('<div style="position: absolute; height: 100%; left: ' + left + 'px; z-index: ' + zindex-- + '; width:' + width + 'px;" class="' + cellclass + '"></div>');
                                tablecolumn.height(me.rowsheight);
                                tablerow.append(tablecolumn);
                                me.table[0].rows[0].cells[j] = tablecolumn[0];
                            }
                            if (width < columnrecord.minwidth) width = columnrecord.minwidth;
                            if (width > columnrecord.maxwidth) width = columnrecord.maxwidth;
                            if (!(columnrecord.hidden && columnrecord.hideable) && !columnrecord.adaptivehidden) {
                                left += width;
                            }
                        }
                        me.table.width(parseInt(left) + 2);
                        tablewidth = left;
                    }

                    me._updatescrollbarsafterrowsprerender();
                    // callback when the rendering is complete.
                    if (me.rendered) {
                        me.rendered('rows');
                    }
                    me.toCompile = new Array();
                    me._addoverlayelement();
                }
            },

            _groupsheader: function () {
                return this.groupable && this.showgroupsheader;
            },

            _arrange: function () {
                var width = null;
                var height = null;
                this.tableheight = null;
                var me = this.that;
                var isPercentageWidth = false;
                var isPercentageHeight = false;

                if (me.width != null && me.width.toString().indexOf("px") != -1) {
                    width = me.width;
                }
                else
                    if (me.width != undefined && !isNaN(me.width)) {
                        width = me.width;
                    };

                if (me.width != null && me.width.toString().indexOf("%") != -1) {
                    width = me.width;
                    isPercentageWidth = true;
                }
                if (me.scrollbarautoshow) {
                    me.vScrollBar[0].style.display = "none";
                    me.hScrollBar[0].style.display = "none";
                    me.vScrollBar[0].style.zIndex = me.tableZIndex + me.headerZIndex;
                    me.hScrollBar[0].style.zIndex = me.tableZIndex + me.headerZIndex;
                }

                if (me.autowidth) {
                    var w = 0;
                    for (var i = 0; i < me.columns.records.length; i++) {
                        var cw = me.columns.records[i].width;
                        if (cw == 'auto') {
                            cw = me._measureElementWidth(me.columns.records[i].text);
                            w += cw;
                        }
                        else {
                            w += cw;
                        }
                    }
                    if (me.vScrollBar.css('visibility') != 'hidden') {
                        w += me.scrollbarsize + 4
                    }

                    width = w;
                    me.width = width;
                }

                if (me.height != null && me.height.toString().indexOf("px") != -1) {
                    height = me.height;
                }
                else if (me.height != undefined && !isNaN(me.height)) {
                    height = me.height;
                };

                if (me.height != null && me.height.toString().indexOf("%") != -1) {
                    height = me.height;
                    isPercentageHeight = true;
                }

                var baseheight = function () {
                    var height = 0;
                    var columnheaderheight = me.showheader ? me.columnsheader != null ? me.columnsheader.height() + 2 : 0 : 0;
                    height += columnheaderheight;
                    if (me.pageable) {
                        height += me.pagerheight;
                    }
                    if (me._groupsheader()) {
                        height += me.groupsheaderheight;
                    }
                    if (me.showtoolbar) {
                        height += me.toolbarheight;
                    }
                    if (me.showfilterbar) {
                        height += me.toolbarheight;
                    }
                    if (me.showstatusbar) {
                        height += me.statusbarheight;
                    }
                    if (me.showeverpresentrow && me.everpresentrowposition === "bottom") {
                        height += me.everpresentrowheight;
                    }
                    if (me.hScrollBar[0].style.visibility == 'visible') {
                        height += 15;
                    }

                    return height;
                }

                if (me.autoheight && me.virtualsizeinfo) {
                    if (me.pageable && me.gotopage) {
                        //var newheight = me.host.height() - me._gettableheight();
                        var newheight = 0;
                        height = newheight + (me._pageviews[0] ? me._pageviews[0].height : 0);
                        //if (height == 0) {
                        height += baseheight();
                        //}
                        if (me.showemptyrow && me.dataview.totalrecords == 0) {
                            height += me.rowsheight;
                        }
                    }
                    else {
                        var newheight = me.host.height() - me._gettableheight();
                        if (me._pageviews.length > 0) {
                            height = newheight + me._pageviews[me._pageviews.length - 1].height + me._pageviews[me._pageviews.length - 1].top;
                            me.vScrollBar[0].style.visibility = 'hidden';
                        }
                        else {
                            height = baseheight();
                            if (me.showemptyrow) {
                                height += me.rowsheight;
                            }
                        }
                    }
                }
                else if (me.autoheight) {
                    height = me.dataview.totalrecords * me.rowsheight;
                    if (me.pageable && me.gotopage) {
                        height = me.pagesize * me.rowsheight;
                    }
                    if (me._loading) {
                        height = 250;
                        me.dataloadelement.height(height);
                    }
                    height += baseheight();

                    if (height > 10000)
                        height = 10000;
                }

                if (width != null) {
                    width = parseInt(width);
                    if (!isPercentageWidth) {
                        if (me.element.style.width != parseInt(me.width) + 'px') {
                            me.element.style.width = parseInt(me.width) + 'px';
                        }
                    }
                    else {
                        me.element.style.width = me.width;
                    }

                    if (isPercentageWidth) {
                        width = me.host.width();
                        if (width <= 2) {
                            width = 600;
                            me.host.width(width);
                        }
                        if (!me._oldWidth) {
                            me._oldWidth = width;
                        }
                    }
                }
                else me.host.width(250);

                if (height != null) {
                    if (this.autoheight) {
                        height += 2;
                    }

                    if (!isPercentageHeight) {
                        height = parseInt(height);
                    }

                    if (!isPercentageHeight) {
                        if (me.element.style.height != parseInt(height) + 'px') {
                            me.element.style.height = parseInt(height) + 'px';
                        }
                    }
                    else {
                        me.element.style.height = me.height;
                    }

                    if (isPercentageHeight && !me.autoheight) {
                        height = me.host.height();
                        if (height == 0) {
                            height = 400;
                            me.host.height(height);
                        }
                        if (!me._oldHeight) {
                            me._oldHeight = height;
                        }
                    }
                }
                else me.host.height(250);

                if (me.autoheight) {
                    me.tableheight = null;
                    me._gettableheight();
                }

                var top = 0;

                if (me.showtoolbar) {
                    me.toolbar.width(width);
                    me.toolbar.height(me.toolbarheight - 1);
                    me.toolbar.css('top', 0);
                    top += me.toolbarheight;
                    height -= parseInt(me.toolbarheight);
                }
                else {
                    me.toolbar[0].style.height = '0px';
                }

                if (me.showfilterbar) {
                    me.filterbar.width(width);
                    me.filterbar.height(me.toolbarheight - 1);
                    me.filterbar.css('top', top);
                    top += me.toolbarheight;
                    height -= parseInt(me.toolbarheight);
                }
                else {
                    me.filterbar[0].style.height = '0px';
                }

                if (me.showstatusbar) {
                    if (me.showaggregates) {
                        me.statusbar.width(!me.table ? width : Math.max(width, me.table.width()));
                    }
                    else {
                        me.statusbar.width(width);
                    }

                    me.statusbar.height(me.statusbarheight);
                }
                else {
                    me.statusbar[0].style.height = '0px';
                }
                if (me.showeverpresentrow && me.everpresentrowposition === "bottom") {
                    me.addnewrow.width(width);
                    me.addnewrow.height(me.everpresentrowheight);
                }
                else {
                    me.addnewrow[0].style.height = '0px';
                }

                if (me._groupsheader()) {
                    me.groupsheader.width(width);
                    me.groupsheader.height(me.groupsheaderheight);
                    me.groupsheader.css('top', top);
                    var groupsheaderheight = me.groupsheader.height() + 1;
                    top += groupsheaderheight;
                    if (height > groupsheaderheight) {
                        height -= parseInt(groupsheaderheight);
                    }
                }
                else {
                    if (me.groupsheader[0].style.width != width + 'px') {
                        me.groupsheader[0].style.width = parseInt(width) + 'px';
                    }
                    me.groupsheader[0].style.height = '0px';

                    if (me.groupsheader[0].style.top != top + 'px') {
                        me.groupsheader.css('top', top);
                    }

                    var groupsheaderheight = me.showgroupsheader && me.groupable ? me.groupsheaderheight : 0;
                    var newContentTop = top + groupsheaderheight + 'px';
                    if (me.content[0].style.top != newContentTop) {
                        me.content.css('top', top + me.groupsheaderheight);
                    }
                }

                // scrollbar Size.
                var scrollSize = me.scrollbarsize;
                if (isNaN(scrollSize)) {
                    scrollSize = parseInt(scrollSize);
                    if (isNaN(scrollSize)) {
                        scrollSize = '17px';
                    }
                    else scrollSize = scrollSize + 'px';
                }

                scrollSize = parseInt(scrollSize);
                var scrollOffset = 4;
                var bottomSizeOffset = 2;
                var rightSizeOffset = 0;

                // right scroll offset.
                if (me.vScrollBar[0].style.visibility == 'visible') {
                    rightSizeOffset = scrollSize + scrollOffset;
                }

                // bottom scroll offset.
                if (me.hScrollBar[0].style.visibility == 'visible') {
                    bottomSizeOffset = scrollSize + scrollOffset + 2;
                }

                if (scrollSize == 0) {
                    rightSizeOffset = 0;
                    bottomSizeOffset = 0;
                }

                var pageheight = 0;
                if (me.pageable) {
                    pageheight = me.pagerheight;
                    bottomSizeOffset += me.pagerheight;
                }
                if (me.showstatusbar) {
                    bottomSizeOffset += me.statusbarheight;
                    pageheight += me.statusbarheight;
                }
                if (me.showeverpresentrow && me.everpresentrowposition === "bottom") {
                    bottomSizeOffset += me.everpresentrowheight;
                    pageheight += me.everpresentrowheight;
                }
                if (me.hScrollBar[0].style.height != scrollSize + 'px') {
                    me.hScrollBar[0].style.height = parseInt(scrollSize) + 'px';
                }

                if (me.hScrollBar[0].style.top != top + height - scrollOffset - scrollSize - pageheight + 'px' || me.hScrollBar[0].style.left != '0px') {
                    me.hScrollBar.css({
                        top: top + height - scrollOffset - scrollSize - pageheight + 'px', left: '0px'
                    });
                }

                var hScrollWidth = me.hScrollBar[0].style.width;
                var hSizeChange = false;
                var vSizeChange = false;

                if (rightSizeOffset == 0) {
                    if (hScrollWidth != (width - 2) + 'px') {
                        me.hScrollBar.width(width - 2);
                        hSizeChange = true;
                    }
                }
                else {
                    if (hScrollWidth != (width - scrollSize - scrollOffset) + 'px') {
                        me.hScrollBar.width(width - scrollSize - scrollOffset + 'px');
                        hSizeChange = true;
                    }
                }


                if (!me.autoheight) {
                    if (me.vScrollBar[0].style.width != scrollSize + 'px') {
                        me.vScrollBar.width(scrollSize);
                        vSizeChange = true;
                    }
                    if (me.vScrollBar[0].style.height != parseInt(height) - bottomSizeOffset + 'px') {
                        me.vScrollBar.height(parseInt(height) - bottomSizeOffset + 'px');
                        vSizeChange = true;
                    }
                    if (me.vScrollBar[0].style.left != parseInt(width) - parseInt(scrollSize) - scrollOffset + 'px' || me.vScrollBar[0].style.top != top + 'px') {
                        me.vScrollBar.css({
                            left: parseInt(width) - parseInt(scrollSize) - scrollOffset + 'px', top: top
                        });
                    }
                }

                if (me.rtl) {
                    me.vScrollBar.css({
                        left: '0px', top: top
                    });
                    if (me.vScrollBar.css('visibility') != 'hidden') {
                        me.hScrollBar.css({
                            left: scrollSize + 2
                        });
                    }
                }

                var vScrollInstance = me.vScrollInstance;
                vScrollInstance.disabled = me.disabled;
                if (!me.autoheight) {
                    if (vSizeChange) {
                        vScrollInstance.refresh();
                    }
                }
                var hScrollInstance = me.hScrollInstance;
                hScrollInstance.disabled = me.disabled;
                if (hSizeChange) {
                    hScrollInstance.refresh();
                }

                if (me.autowidth) {
                    me.hScrollBar[0].style.visibility = 'hidden';
                }

                me.statusbarheight = parseInt(me.statusbarheight);
                me.toolbarheight = parseInt(me.toolbarheight);

                var updateBottomRight = function (me) {
                    if ((me.vScrollBar[0].style.visibility == 'visible') && (me.hScrollBar[0].style.visibility == 'visible')) {
                        me.bottomRight[0].style.visibility = 'visible';
                        me.bottomRight.css({
                            left: 1 + parseInt(me.vScrollBar.css('left')), top: parseInt(me.hScrollBar.css('top'))
                        });
                        if (me.rtl) {
                            me.bottomRight.css('left', '0px');
                        }

                        me.bottomRight.width(parseInt(scrollSize) + 3);
                        me.bottomRight.height(parseInt(scrollSize) + 4);

                        var addnewrow = me.showeverpresentrow && me.everpresentrowposition == "bottom";
                        var everpresentrowheight = addnewrow ? me.everpresentrowheight : 0;
                        if (everpresentrowheight > 0 && !me.showaggregates) {
                            me.bottomRight.css('z-index', 99);
                            me.bottomRight.height(parseInt(scrollSize) + 4 + everpresentrowheight);
                            me.bottomRight.css({
                                top: parseInt(me.hScrollBar.css('top')) - everpresentrowheight
                            });
                        }
                        if (me.showaggregates) {
                            me.bottomRight.css('z-index', 99);
                            me.bottomRight.height(parseInt(scrollSize) + 4 + me.statusbarheight + everpresentrowheight);
                            me.bottomRight.css({
                                top: parseInt(me.hScrollBar.css('top')) - me.statusbarheight - everpresentrowheight
                            });
                        }
                    }
                    else me.bottomRight[0].style.visibility = 'hidden';
                }

                updateBottomRight(this);
                if (me.content[0].style.width != width - rightSizeOffset + 'px') {
                    me.content.width(width - rightSizeOffset);
                }
                if (me.content[0].style.height != height - bottomSizeOffset + 3 + 'px') {
                    me.content.height(height - bottomSizeOffset + 3);
                }

                if (me.scrollbarautoshow) {
                    if (me.content[0].style.width != width + 'px') {
                        me.content.width(width);
                    }
                    if (me.content[0].style.height != height + 'px') {
                        me.content.height(height);
                    }
                }

                if (me.content[0].style.top != top + 'px') {
                    me.content.css('top', top);
                }
                if (me.rtl) {
                    me.content.css('left', rightSizeOffset);
                    if (me.scrollbarautoshow) {
                        me.content.css('left', '0px');
                    }

                    if (me.table) {
                        var tablewidth = me.table.width();
                        if (tablewidth < width - rightSizeOffset) {
                            me.content.css('left', width - tablewidth);
                        }
                    }
                }

                if (me.showstatusbar) {
                    me.statusbar.css('top', top + height - me.statusbarheight - (me.pageable ? me.pagerheight : 0));

                    if (me.autoheight) {
                        me.statusbar.css('top', top + height - 2 - me.statusbarheight - (me.pageable ? me.pagerheight : 0));
                        me.statusbar.height(me.statusbarheight + 2);
                    }

                    if (me.showaggregates) {
                        if (me.hScrollBar.css('visibility') == 'visible') {
                            me.hScrollBar.css({
                                top: top + height - scrollOffset - scrollSize - pageheight + me.statusbarheight + 'px'
                            });
                            me.statusbar.css('top', 1 + top + height - scrollSize - 5 - me.statusbarheight - (me.pageable ? me.pagerheight : 0));
                        }
                        updateBottomRight(this);
                    }
                    if (me.rtl) {
                        if (me.hScrollBar.css('visibility') != 'visible') {
                            me.statusbar.css('left', me.content.css('left'));
                        }
                        else {
                            me.statusbar.css('left', '0px');
                        }
                    }
                }


                if (me.showeverpresentrow && me.everpresentrowposition === "bottom") {
                    me.addnewrow.css('top', top + height - (me.showstatusbar ? me.statusbarheight : 0) - (me.pageable ? me.pagerheight : 0) - me.everpresentrowheight);
                    if (me.rtl) {
                        if (me.hScrollBar.css('visibility') != 'visible') {
                            me.addnewrow.css('left', me.content.css('left'));
                        }
                        else {
                            me.addnewrow.css('left', '0px');
                        }
                    }
                }

                if (me.pageable) {
                    me.pager.width(width);
                    me.pager.height(me.pagerheight);
                    me.pager.css('top', top + height - me.pagerheight - 1);
                }
                else {
                    me.pager[0].style.height = '0px';
                }

                if (me.table != null) {
                    var offset = -2;
                    if (me.table.width() - me.host.width() === 3) {
                        offset = -3;
                    }

                    if (me.vScrollBar[0].style.visibility == 'visible') {
                        offset = me.scrollbarsize + 3;
                    }

                    if (me.hScrollBar[0].style.visibility == 'visible') {
                        var newoffset = offset + me.table.width() - me.host.width();
                        if (newoffset >= 0) {
                            me.hScrollBar.jqxScrollBar('max', newoffset);
                        }
                        if (me.hScrollBar[0].style.visibility == 'visible' && newoffset == 0) {
                            me.hScrollBar[0].style.visibility = 'hidden';
                            me._arrange();
                        }
                    }
                }

                if (width != parseInt(me.dataloadelement[0].style.width)) {
                    me.dataloadelement[0].style.width = me.element.style.width;
                }
                if (height != parseInt(me.dataloadelement[0].style.height)) {
                    me.dataloadelement[0].style.height = me.element.style.height;
                }

                if (this.pagergotoinput) {
                    if (this.pagergotoinput.offset().top !== this.pagergoto.offset().top) {
                        this.pagergotoinput.css('visibility', 'hidden');
                        this.pagergoto.css('visibility', 'hidden');
                    }
                    else {
                        this.pagergotoinput.css('visibility', 'inherit');
                        this.pagergoto.css('visibility', 'inherit');
                    }
                }

                me._hostwidth = width;
            },

            // destroy grid.
            destroy: function () {
                delete $.jqx.dataFormat.datescache;
                delete this.gridlocalization;
                delete this._undoRedo;
                $.jqx.utilities.resize(this.host, null, true);
                if (document.referrer != "" || window.frameElement) {
                    if (window.top != null && window.top != window.self) {
                        this.removeHandler($(window.top.document), "mouseup.grid" + this.element.id);
                    }
                }
                if (this.table && this.table[0]) {
                    var rowscount = this.table[0].rows.length;
                    for (var i = 0; i < rowscount; i++) {
                        var row = this.table[0].rows[i];
                        var cells = row.cells;
                        var cellscount = cells.length;
                        for (var j = 0; j < cellscount; j++) {
                            $(row.cells[j]).remove();
                            row.cells[j] = null;
                            delete row.cells[j];
                        }
                        row.cells = null;
                        if (row.cells) {
                            delete row.cells;
                        }
                        $(this.table[0].rows[i]).remove();
                        this.table[0].rows[i] = null;
                    }
                    try {
                        delete this.table[0].rows;
                    }
                    catch (error) {
                    }
                    this.table.remove();
                    delete this.table;
                }

                if (this.columns && this.columns.records) {
                    for (var i = 0; i < this.columns.records.length; i++) {
                        var column = this.columns.records[i];
                        if (column.addnewrowwidget) {
                            if (column.destroyeverpresentrowwidget) {
                                column.destroyeverpresentrowwidget(column.addnewrowwidget);
                            }
                        }
                        if (column.destroywidget) {
                            if (column.destroywidget) {
                                column.destroywidget(column.widget);
                            }
                        }
                        this._removecolumnhandlers(this.columns.records[i]);
                        if (column.element) {
                            $(column.element).remove();
                            $(column.sortasc).remove();
                            $(column.sortdesc).remove();
                            $(column.filtericon).remove();
                            $(column.menu).remove();

                            column.element = null;
                            column.uielement = null;
                            column.sortasc = null;
                            column.sortdesc = null;
                            column.filtericon = null;
                            column.menu = null;
                            delete column.element;
                            delete column.uielement;
                            delete column.sortasc;
                            delete column.sortdesc;
                            delete column.filtericon;
                            delete column.menu;
                            delete this.columnsrow[0].cells[i];
                        }
                    }

                    try {
                        delete this.columnsrow[0].cells;
                    }
                    catch (error) {
                    }
                    delete this.columnsrow;
                }
                $.removeData(document.body, "contextmenu" + this.element.id);

                if (this.host.jqxDropDownList) {
                    if (this._destroyfilterpanel) {
                        this._destroyfilterpanel();
                    }
                }
                if (this.editable && this._destroyeditors) {
                    this._destroyeditors();
                }
                if (this.filterable && this._destroyedfilters && this.showfilterrow) {
                    this._destroyedfilters();
                }

                if (this.host.jqxMenu) {
                    if (this.gridmenu) {
                        this.removeHandler($(document), 'click.menu' + this.element.id);
                        this.removeHandler(this.gridmenu, 'keydown');
                        this.removeHandler(this.gridmenu, 'closed');
                        this.removeHandler(this.gridmenu, 'itemclick');
                        this.gridmenu.jqxMenu('destroy');
                        this.gridmenu = null;
                    }
                }

                if (this.pagershowrowscombo) {
                    this.pagershowrowscombo.jqxDropDownList('destroy');
                    this.pagershowrowscombo = null;
                }

                if (this.pagerrightbutton) {
                    this.removeHandler(this.pagerrightbutton, 'mousedown');
                    this.removeHandler(this.pagerrightbutton, 'mouseup');
                    this.removeHandler(this.pagerrightbutton, 'click');
                    this.pagerrightbutton.jqxButton('destroy');
                    this.pagerrightbutton = null;
                }

                if (this.pagerleftbutton) {
                    this.removeHandler(this.pagerleftbutton, 'mousedown');
                    this.removeHandler(this.pagerleftbutton, 'mouseup');
                    this.removeHandler(this.pagerleftbutton, 'click');
                    this.pagerleftbutton.jqxButton('destroy');
                    this.removeHandler($(document), 'mouseup.pagerbuttons' + this.element.id);
                    this.pagerleftbutton = null;
                }

                this.removeHandler($(document), 'selectstart.' + this.element.id);
                this.removeHandler($(document), 'mousedown.resize' + this.element.id);
                this.removeHandler($(document), 'mouseup.resize' + this.element.id);
                this.removeHandler($(document), 'mousemove.resize' + this.element.id);
                if (this.isTouchDevice()) {
                    var mousemove = $.jqx.mobile.getTouchEventName('touchmove') + '.resize' + this.element.id;
                    var mousedown = $.jqx.mobile.getTouchEventName('touchstart') + '.resize' + this.element.id;
                    var mouseup = $.jqx.mobile.getTouchEventName('touchend') + '.resize' + this.element.id;
                    this.removeHandler($(document), mousemove);
                    this.removeHandler($(document), mousedown);
                    this.removeHandler($(document), mouseup);
                }
                this.removeHandler($(document), 'mousedown.reorder' + this.element.id);
                this.removeHandler($(document), 'mouseup.reorder' + this.element.id);
                this.removeHandler($(document), 'mousemove.reorder' + this.element.id);
                if (this.isTouchDevice()) {
                    var mousemove = $.jqx.mobile.getTouchEventName('touchmove') + '.reorder' + this.element.id;
                    var mousedown = $.jqx.mobile.getTouchEventName('touchstart') + '.reorder' + this.element.id;
                    var mouseup = $.jqx.mobile.getTouchEventName('touchend') + '.reorder' + this.element.id;
                    this.removeHandler($(document), mousemove);
                    this.removeHandler($(document), mousedown);
                    this.removeHandler($(document), mouseup);
                }
                this.removeHandler($(window), 'resize.' + this.element.id);
                if (this.resizeline) {
                    this.resizeline.remove();
                }
                if (this.resizestartline) {
                    this.resizestartline.remove();
                }
                if (this.groupable) {
                    var mousemove = 'mousemove.grouping' + this.element.id;
                    var mousedown = 'mousedown.grouping' + this.element.id;
                    var mouseup = 'mouseup.grouping' + this.element.id;
                    this.removeHandler($(document), mousemove);
                    this.removeHandler($(document), mousedown);
                    this.removeHandler($(document), mouseup);
                }
                if (this.columnsreorder) {
                    var mousemove = 'mousemove.reorder' + this.element.id;
                    var mousedown = 'mousedown.reorder' + this.element.id;
                    var mouseup = 'mouseup.reorder' + this.element.id;
                    this.removeHandler($(document), mousemove);
                    this.removeHandler($(document), mousedown);
                    this.removeHandler($(document), mouseup);
                    delete this.columnsbounds;
                }

                if (this.content) {
                    this.removeHandler(this.content, 'mousedown');
                    this.removeHandler(this.content, 'scroll');
                }


                this._removeHandlers();
                this.hScrollInstance.destroy();
                this.vScrollInstance.destroy();
                this.hScrollBar.remove();
                this.vScrollBar.remove();
                this._clearcaches();
                delete this.hScrollInstance;
                delete this.vScrollInstance;
                delete this.visiblerows;
                delete this.hittestinfo;
                delete this.rows;
                delete this.columns;
                delete this.columnsbydatafield;
                delete this.pagescache;
                delete this.pageviews;
                delete this.cellscache;
                delete this.heights;
                delete this.hiddens;
                delete this.hiddenboundrows;
                delete this.heightboundrows;
                delete this.detailboundrows;
                delete this.details;
                delete this.expandedgroups;
                delete this._rowdetailscache;
                delete this._rowdetailselementscache;
                delete this.columnsmenu;
                if (this.columnsheader) {
                    this.columnsheader.remove();
                    delete this.columnsheader;
                }
                if (this.selectionarea) {
                    this.selectionarea.remove();
                    delete this.selectionarea;
                }
                if (this.menuitemsarray && this.menuitemsarray.length) {
                    var itemslength = this.menuitemsarray.length;
                    for (var i = 0; i < itemslength; i++) {
                        $(this.menuitemsarray[i]).remove();
                    }
                }
                delete this.menuitemsarray;

                this.dataview._clearcaches();
                this.content.removeClass();
                this.content.remove();
                this.content = null;
                delete this.content;
                this.vScrollBar = null;
                this.hScrollBar = null;
                delete this.hScrollBar;
                delete this.hScrollBar;
                if (this.gridcontent) {
                    this.gridcontent.remove();
                    delete this.gridcontent;
                }

                if (this.gridmenu) {
                    this.gridmenu = null;
                    delete this.gridmenu;
                }

                delete this._mousemovefunc;
                delete this._mousewheelfunc;

                this.dataview.destroy();
                delete this.dataview;

                this.bottomRight.remove();
                delete this.bottomRight;

                this.wrapper.remove();
                delete this.wrapper;

                if (this.pagerdiv) {
                    this.pagerdiv.remove();
                    delete this.pagerdiv;
                }
                if (this.pagerpageinput) {
                    this.pagerpageinput.remove();
                    delete this.pagerpageinput;
                }
                if (this.pagergoto) {
                    this.pagergoto.remove();
                    delete this.pagergoto;
                }
                if (this.pagershowrows) {
                    this.pagershowrows.remove();
                    delete this.pagershowrows;
                }
                if (this.pagerfirstbutton) {
                    this.pagerfirstbutton.remove();
                    delete this.pagerfirstbutton;
                }
                if (this.pagerlastbutton) {
                    this.pagerlastbutton.remove();
                    delete this.pagerlastbutton;
                }
                if (this.pagerbuttons) {
                    this.pagerbuttons.remove();
                    delete this.pagerbuttons;
                }
                if (this.pagerdetails) {
                    this.pagerdetails.remove();
                    delete this.pagerdetails;
                }
                if (this.pagergotoinput) {
                    this.pagergotoinput.remove();
                    delete this.pagergotoinput;
                }

                this.pager.remove();
                delete this.pager;

                this.groupsheader.remove();
                delete this.groupsheader;

                this.dataloadelement.remove();
                delete this.dataloadelement;

                this.toolbar.remove();
                delete this.toolbar;

                this.statusbar.remove();
                delete this.statusbar;

                this.host.removeData();
                this.host.removeClass();
                this.host.remove();
                this.host = null;
                delete this.host;
                delete this.element;
                delete this.set;
                delete this.get;
                delete this.that;
                delete this.call;
            },

            _initializeColumns: function () {
                var datafields = this.source ? this.source.datafields : null;
                if (datafields == null && this.source && this.source._source) {
                    datafields = this.source._source.datafields;
                }
                var hasfields = datafields ? datafields.length > 0 : false;
                if (this.autogeneratecolumns) {
                    var cols = new Array();
                    if (datafields) {
                        $.each(datafields, function () {
                            var column = {
                                datafield: this.name, text: this.text || this.name, cellsformat: this.format || ""
                            };
                            cols.push(column);
                        });
                    }
                    else {
                        if (this.source.records.length > 0) {
                            var row = this.source.records[0];
                            for (var obj in row) {
                                if (obj != "uid") {
                                    var column = {
                                        width: 100, datafield: obj, text: obj
                                    };
                                    cols.push(column);
                                }
                            }
                        }
                    }
                    this.columns = cols;
                }

                if (this.columns && this.columns.records) {
                    for (var i = 0; i < this.columns.records.length; i++) {
                        this._removecolumnhandlers(this.columns.records[i]);
                    }
                }
                var me = this.that;
                var _columns = new $.jqx.collection(this.element);
                var visibleindex = 0;
                this._haspinned = false;
                if (!this._columns) {
                    this._columns = this.columns;
                }
                else {
                    this.columns = this._columns;
                }

                if (this.commandcolumn) {
                    this.columns.push({
                        text: '',
                        visible: this.editable,
                        width: 120,
                        filterable: false,
                        sortable: false,
                        editable: false,
                        resizable: false,
                        draggable: false,
                        cellsrenderer: function (boundIndex, dataField) {
                            if (me.commandcolumnrenderer) {
                                var result = me.commandcolumnrenderer(boundIndex, dataField, me._commandColumnEdit && me._commandColumnEdit.boundindex === boundIndex);

                                if (result !== undefined) {
                                    return result;
                                }
                            }
                            if (me._commandColumnEdit && me._commandColumnEdit.boundindex === boundIndex) {
                                return '<span style="display: flex; justify-content: center; height: 100%; align-items: center;"><span style="cursor: pointer; text-decoration: underline;" update>' + me.gridlocalization.udpaterowstring + '</span><span style="cursor: pointer; text-decoration: underline; margin-left: 10px;" cancel>' + me.gridlocalization.cancelstring + '</span></span>'
                            }
                            else {
                                return '<span style="display: flex; justify-content: center; height: 100%; align-items: center;"><span style="cursor: pointer; text-decoration: underline;" edit>' + me.gridlocalization.editstring + '</span></span>'
                            }
                        },
                        datafield: '_commandColumn'
                    });
                }

                if (this.groupable) {
                    $.each(this.groups, function (index) {
                        var column = new jqxGridColumn(me, this);
                        column.visibleindex = visibleindex++;
                        column.width = me.groupindentwidth;
                        _columns.add(column);
                        column.grouped = true;
                        column.filterable = false;
                        column.sortable = false;
                        column.editable = false;
                        column.resizable = false;
                        column.draggable = false;
                    });
                }

                if (this.rowdetails && this.showrowdetailscolumn) {
                    var column = new jqxGridColumn(me, this);
                    column.visibleindex = visibleindex++;
                    column.width = me.groupindentwidth;
                    column.pinned = true;
                    column.editable = false;
                    column.filterable = false;
                    column.draggable = false;
                    column.groupable = false;
                    column.resizable = false;
                    _columns.add(column);
                    me._haspinned = true;
                }

                if (this.selectionmode == "checkbox") {
                    var column = new jqxGridColumn(me, null);
                    column.visibleindex = visibleindex++;
                    column.width = me.groupindentwidth;
                    column.checkboxcolumn = true;
                    column.editable = false;
                    column.columntype = 'checkbox';
                    column.groupable = false;
                    column.draggable = false;
                    column.filterable = false;
                    column.resizable = false;
                    column.datafield = "_checkboxcolumn";
                    _columns.add(column);
                }

                var keys = new Array();
                $.each(this.columns, function (index) {
                    if (me.columns[index] != undefined) {
                        var column = new jqxGridColumn(me, this);
                        column.visibleindex = visibleindex++;
                        if (this.dataField != undefined) {
                            this.datafield = this.dataField;
                        }
                        if (this.pinned) {
                            me._haspinned = true;
                        }
                        if (me.showeverpresentrow) {
                            if (this.datafield === "addButtonColumn" || this.datafield === "resetButtonColumn" || this.datafield === "updateButtonColumn" || this.datafield === "deleteButtonColumn") {
                                column.editable = false;
                                column.groupable = false;
                                column.draggable = false;
                                column.filterable = false;
                                column.resizable = false;
                                column.menu = false;
                            }
                        }
                        if (this.datafield == null) {
                            if (me.source && me.source._source && (me.source._source.datatype == 'array')) {
                                if (!hasfields) {
                                    if (!me.source._source.datafields) {
                                        me.source._source.datafields = new Array();
                                        me.source._source.datafields.push({
                                            name: index.toString()
                                        });
                                    }
                                    else {
                                        me.source._source.datafields.push({
                                            name: index.toString()
                                        });
                                    }
                                }
                                this.datafield = index.toString();
                                this.displayfield = index.toString();
                                column.datafield = this.datafield;
                                column.displayfield = this.displayfield;

                            }
                        }
                        else {
                            if (keys[this.datafield]) {
                                throw new Error("jqxGrid: Invalid column 'datafield' setting. jqxGrid's columns should be initialized with unique data fields.");
                                me.host.remove();
                                return false;
                            }
                            else {
                                keys[this.datafield] = true;
                            }
                        }
                        _columns.add(column);
                    }
                });

                if (this.adaptive) {
                    var column = new jqxGridColumn(me, null);
                    column.visibleindex = visibleindex++;
                    column.width = me.groupindentwidth;
                    column.editable = false;
                    column.columntype = 'adaptive';
                    column.cellsalign = "center";
                    column.groupable = false;
                    column.draggable = false;
                    column.menu = false;
                    column.sortable = false;
                    column.filterable = false;
                    column.resizable = false;
                    column.datafield = "_adaptivecolumn";
                    _columns.add(column);
                }

                if (this.rtl) _columns.records.reverse();
                this.columns = _columns;
            },

            _initializeRows: function () {
                var _rows = new $.jqx.collection(this.element);
                if (this.rows) {
                    this.rows.clear();
                }
                this.rows = _rows;
            },

            _raiseEvent: function (id, arg) {
                if (arg == undefined)
                    arg = {
                        owner: null
                    };

                if (this._trigger === false)
                    return;

                var evt = this.events[id];
                if (!this._camelCase) {
                    evt = evt.toLowerCase();
                }

                if (id == 2 || id == 15) {
                    if (this.showeverpresentrow && (this.everpresentrowactions.indexOf('delete') >= 0 || this.everpresentrowactions.indexOf('update') >= 0)) {
                        if (this.updateeverpresentrow)
                            var that = this;
                        setTimeout(function () {
                            that.updateeverpresentrow();
                        }, 50);
                    }
                }
                var args = arg;
                args.owner = this;

                var event = new $.Event(evt);
                event.owner = this;
                event.args = args;
                var result = this.host.trigger(event);

                // save the new event arguments.
                arg = event.args;
                return result;
            },

            // performs mouse wheel.
            wheel: function (event, self) {
                if (self.autoheight && self.hScrollBar.css('visibility') != 'visible') {
                    event.returnValue = true;
                    return true;
                }

                var delta = 0;
                if (!event) /* For IE. */
                    event = window.event;

                if (event.originalEvent && event.originalEvent.wheelDelta) {
                    event.wheelDelta = event.originalEvent.wheelDelta;
                }

                if (event.wheelDelta) { /* IE/Opera. */
                    delta = event.wheelDelta / 120;
                } else if (event.detail) { /** Mozilla case. */
                    delta = -event.detail / 3;
                }

                if (delta) {
                    var result = self._handleDelta(delta);
                    if (result) {
                        if (event.preventDefault)
                            event.preventDefault();

                        if (event.originalEvent != null) {
                            event.originalEvent.mouseHandled = true;
                        }

                        if (event.stopPropagation != undefined) {
                            event.stopPropagation();
                        }
                    }

                    if (result) {
                        result = false;
                        event.returnValue = result;
                        return result;
                    }
                    else {
                        return false;
                    }
                }

                if (event.preventDefault)
                    event.preventDefault();
                event.returnValue = false;
            },

            _handleDelta: function (delta) {
                if (this.vScrollBar.css('visibility') != 'hidden') {
                    var oldvalue = this.vScrollInstance.value;
                    if (delta < 0) {
                        this.scrollDown();
                    }
                    else this.scrollUp();
                    var newvalue = this.vScrollInstance.value;
                    if (oldvalue != newvalue) {
                        return true;
                    }
                }
                else if (this.hScrollBar.css('visibility') != 'hidden') {
                    var oldvalue = this.hScrollInstance.value;
                    if (delta > 0) {
                        if (this.hScrollInstance.value > 2 * this.horizontalscrollbarstep) {
                            this.hScrollInstance.setPosition(this.hScrollInstance.value - 2 * this.horizontalscrollbarstep);
                        }
                        else {
                            this.hScrollInstance.setPosition(0);
                        }
                    }
                    else {
                        if (this.hScrollInstance.value < this.hScrollInstance.max) {
                            this.hScrollInstance.setPosition(this.hScrollInstance.value + 2 * this.horizontalscrollbarstep);
                        }
                        else this.hScrollInstance.setPosition(this.hScrollInstance.max);

                    }
                    var newvalue = this.hScrollInstance.value;
                    if (oldvalue != newvalue) {
                        if (this._activeFilterElement) {
                            this._activeFilterElement.jqxDropDownList('close');
                        }
                        return true;
                    }
                }

                return false;
            },

            // scrolls down.
            scrollDown: function () {
                if (this.vScrollBar.css('visibility') == 'hidden')
                    return;

                var vScrollInstance = this.vScrollInstance;
                if (vScrollInstance.value + this.rowsheight <= vScrollInstance.max) {
                    vScrollInstance.setPosition(parseInt(vScrollInstance.value) + this.rowsheight);
                }
                else vScrollInstance.setPosition(vScrollInstance.max);
            },

            // scrolls up.
            scrollUp: function () {
                if (this.vScrollBar.css('visibility') == 'hidden')
                    return;

                var vScrollInstance = this.vScrollInstance;
                if (vScrollInstance.value - this.rowsheight >= vScrollInstance.min) {
                    vScrollInstance.setPosition(parseInt(vScrollInstance.value) - this.rowsheight);
                }
                else vScrollInstance.setPosition(vScrollInstance.min);
            },

            _removeHandlers: function () {
                var self = this.that;
                self.removeHandler($(window), 'orientationchange.jqxgrid' + self.element.id);
                self.removeHandler($(window), 'orientationchanged.jqxgrid' + self.element.id);
                self.removeHandler(self.vScrollBar, 'valueChanged');
                self.removeHandler(self.hScrollBar, 'valueChanged');
                self.vScrollInstance.valueChanged = null;
                self.hScrollInstance.valueChanged = null;

                var eventname = 'mousedown.jqxgrid';

                if (self.isTouchDevice()) {
                    eventname = $.jqx.mobile.getTouchEventName('touchend');
                }

                self.removeHandler(self.host, 'dblclick.jqxgrid');
                self.removeHandler(self.host, eventname);
                self.removeHandler(self.content, 'mousemove', self._mousemovefunc);
                self.removeHandler(self.host, 'mouseleave.jqxgrid');
                self.removeHandler(self.content, 'mouseenter');
                self.removeHandler(self.content, 'mouseleave');
                self.removeHandler(self.content, 'mousedown');
                self.removeHandler(self.content, 'scroll');
                self.removeHandler(self.content, 'selectstart.' + self.element.id);
                self.removeHandler(self.host, 'dragstart.' + self.element.id);
                self.removeHandler(self.host, 'keydown.edit' + self.element.id);
                self.removeHandler($(document), 'keydown.edit' + self.element.id);
                self.removeHandler($(document), 'keyup.edit' + self.element.id);
                if (self._mousemovedocumentfunc) {
                    self.removeHandler($(document), 'mousemove.selection' + self.element.id, self._mousemovedocumentfunc);
                }
                self.removeHandler($(document), 'mouseup.selection' + self.element.id);
                if (self._mousewheelfunc) {
                    self.removeHandler(self.host, 'mousewheel', self._mousewheelfunc);
                }
                if (self.editable) {
                    self.removeHandler($(document), 'mousedown.gridedit' + self.element.id);
                }
                if (self.host.off) {
                    self.content.off('mousemove');
                    self.host.off('mousewheel');
                }
            },

            _addHandlers: function () {
                var self = this.that;
                var isTouch = self.isTouchDevice();
                if (!isTouch) {
                    self.addHandler(self.host, 'dragstart.' + self.element.id, function (event) {
                        return false;
                    });
                }

                if (self.scrollbarautoshow) {
                    self.addHandler(self.host, 'mouseenter.gridscroll' + self.element.id, function (event) {
                        self.vScrollBar.fadeIn('fast');
                        self.hScrollBar.fadeIn('fast');
                    });
                    self.addHandler(self.host, 'mouseleave.gridscroll' + self.element.id, function (event) {
                        if (!self.vScrollInstance.isScrolling() && !self.hScrollInstance.isScrolling()) {
                            self.vScrollBar.fadeOut('fast');
                            self.hScrollBar.fadeOut('fast');
                        }
                    });
                }

                if (self.editable) {
                    self.addHandler($(document), 'mousedown.gridedit' + self.element.id, function (event) {
                        if (self.editable && self.begincelledit) {
                            if (self.editcell) {
                                if (!self.vScrollInstance.isScrolling() && !self.vScrollInstance.isScrolling()) {
                                    var gridOffset = self.host.coord();
                                    var gridWidth = self.host.width();
                                    var gridHeight = self.host.height();
                                    var close = false;
                                    var yclose = false;
                                    var xclose = false;
                                    if (event.pageY < gridOffset.top || event.pageY > gridOffset.top + gridHeight) {
                                        close = true;
                                        yclose = true;
                                    }
                                    if (event.pageX < gridOffset.left || event.pageX > gridOffset.left + gridWidth) {
                                        close = true;
                                        xclose = true;
                                    }

                                    if (close) {
                                        var stopPropagation = false;
                                        if (self.editcell && self.editcell.editor) {
                                            switch (self.editcell.columntype) {
                                                case "datetimeinput":
                                                    if (self.editcell.editor.jqxDateTimeInput && self.editcell.editor.jqxDateTimeInput('container') && self.editcell.editor.jqxDateTimeInput('container')[0].style.display == 'block') {
                                                        var top = self.editcell.editor.jqxDateTimeInput('container').coord().top;
                                                        var bottom = self.editcell.editor.jqxDateTimeInput('container').coord().top + self.editcell.editor.jqxDateTimeInput('container').height();
                                                        if (yclose && (event.pageY < top || event.pageY > bottom)) {
                                                            close = true;
                                                            self.editcell.editor.jqxDateTimeInput('close');
                                                        }
                                                        else {
                                                            return;
                                                        }
                                                    }
                                                    break;
                                                case "combobox":
                                                    if (self.editcell.editor.jqxComboBox && self.editcell.editor.jqxComboBox('container') && self.editcell.editor.jqxComboBox('container')[0].style.display == 'block') {
                                                        var top = self.editcell.editor.jqxComboBox('container').coord().top;
                                                        var bottom = self.editcell.editor.jqxComboBox('container').coord().top + self.editcell.editor.jqxComboBox('container').height();
                                                        if (yclose && (event.pageY < top || event.pageY > bottom)) {
                                                            close = true;
                                                            self.editcell.editor.jqxComboBox('close');
                                                        }
                                                        else {
                                                            return;
                                                        }
                                                    }
                                                    break;
                                                case "dropdownlist":
                                                    if (self.editcell.editor.jqxDropDownList && self.editcell.editor.jqxDropDownList('container') && self.editcell.editor.jqxDropDownList('container')[0].style.display == 'block') {
                                                        var top = self.editcell.editor.jqxDropDownList('container').coord().top;
                                                        var bottom = self.editcell.editor.jqxDropDownList('container').coord().top + self.editcell.editor.jqxDropDownList('container').height();
                                                        if (yclose && (event.pageY < top || event.pageY > bottom)) {
                                                            close = true;
                                                            self.editcell.editor.jqxDropDownList('close');
                                                        }
                                                        else {
                                                            return;
                                                        }
                                                    }
                                                    break;
                                                case "template":
                                                case "custom":
                                                    var editorType = ['jqxDropDownList', 'jqxComboBox', 'jqxDropDownButton', 'jqxDateTimeInput'];
                                                    var testEditorType = function (type) {
                                                        var editorData = self.editcell.editor.data();
                                                        if (editorData[type] && editorData[type].instance.container && editorData[type].instance.container[0].style.display == 'block') {
                                                            var instance = editorData[type].instance;
                                                            var top = instance.container.coord().top;
                                                            var bottom = instance.container.coord().top + instance.container.height();
                                                            if (yclose && (event.pageY < top || event.pageY > bottom)) {
                                                                close = true;
                                                                instance.close();
                                                                return true;
                                                            }
                                                            else {
                                                                return false;
                                                            }
                                                        }
                                                    }
                                                    for (var i = 0; i < editorType.length; i++) {
                                                        var result = testEditorType(editorType[i]);
                                                        if (result == false) return;
                                                    }
                                                    break;
                                            }
                                        }

                                        if (self.editmode === 'programmatic') {
                                            self._oldselectedcell = null;
                                            return;
                                        }
                                        self.endcelledit(self.editcell.row, self.editcell.column, false, true);
                                        self._oldselectedcell = null;
                                    }
                                }
                            }
                        }
                    });
                }

                self.vScrollInstance.valueChanged = function (params) {
                    if (self.virtualsizeinfo) {
                        self._closemenu();
                        if (self.scrollmode != 'physical') {
                            self._renderrows(self.virtualsizeinfo);
                            self.currentScrollValue = params.currentValue;
                        }
                        else {
                            if (self.currentScrollValue != undefined && Math.abs(self.currentScrollValue - params.currentValue) >= 5) {
                                self._renderrows(self.virtualsizeinfo);
                                self.currentScrollValue = params.currentValue;
                            }
                            else {
                                self._renderrows(self.virtualsizeinfo);
                                self.currentScrollValue = params.currentValue;
                            }
                        }

                        if (!self.pageable && !self.groupable && self.dataview.virtualmode) {
                            if (self.loadondemandupdate) {
                                clearTimeout(self.loadondemandupdate);
                            }

                            self.loadondemandupdate = setTimeout(function () {
                                self.loadondemand = true;
                                self._renderrows(self.virtualsizeinfo);
                            }, 100);
                        }
                        if (isTouch) {
                            self._lastScroll = new Date();
                        }
                    }
                }

                self.hScrollInstance.valueChanged = function (params) {
                    if (self.virtualsizeinfo) {
                        self._closemenu();
                        var doHScroll = function () {

                            self._renderhorizontalscroll();
                            self._renderrows(self.virtualsizeinfo);
                            if (self.editcell && !self.editrow) {
                                if (self._showcelleditor && self.editcell.editing) {
                                    if (!self.hScrollInstance.isScrolling()) {
                                        self._showcelleditor(self.editcell.row, self.getcolumn(self.editcell.column), self.editcell.element, self.editcell.init);
                                    }
                                }
                            }
                        }

                        if (isTouch) {
                            doHScroll();
                        }
                        else {
                            var ie10 = self._browser == undefined ? self._isIE10() : self._browser;
                            if (navigator && navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') == -1) {
                                if (self._hScrollTimer) clearTimeout(self._hScrollTimer);
                                self._hScrollTimer = setTimeout(function () {
                                    doHScroll();
                                }, 1);
                            }
                            else if ($.jqx.browser.msie) {
                                if (self._hScrollTimer) clearTimeout(self._hScrollTimer);
                                self._hScrollTimer = setTimeout(function () {
                                    doHScroll();
                                }, 0.01);
                            }
                            else {
                                doHScroll();
                            }
                        }
                        if (isTouch) {
                            self._lastScroll = new Date();
                        }
                    }
                }

                self._mousewheelfunc = self._mousewheelfunc || function (event) {
                    if (!self.editcell && self.enablemousewheel) {
                        self.wheel(event, self);
                        return false;
                    }
                };

                self.removeHandler(self.host, 'mousewheel', self._mousewheelfunc);
                self.addHandler(self.host, 'mousewheel', self._mousewheelfunc);

                var eventname = 'mousedown.jqxgrid';

                if (isTouch) {
                    eventname = $.jqx.mobile.getTouchEventName('touchend');
                }

                self.addHandler(self.host, eventname, function (event) {
                    if (self.isTouchDevice()) {
                        self._newScroll = new Date();
                        if (self._newScroll - self._lastScroll < 500) {
                            return false;
                        }
                        if ($(event.target).ischildof(self.vScrollBar)) {
                            return false;
                        }
                        if ($(event.target).ischildof(self.hScrollBar)) {
                            return false;
                        }
                    }
                    self._mousedown = new Date();
                    var result = self._handlemousedown(event, self);
                    if (self.isNestedGrid) {
                        if (!self.resizablecolumn && !self.columnsreorder) {
                            event.stopPropagation();
                        }
                    }

                    self._lastmousedown = new Date();
                    return result;
                });

                if (!isTouch) {
                    self.addHandler(self.host, 'dblclick.jqxgrid', function (event) {
                        if (self.editable && self.begincelledit && self.editmode == 'dblclick') {
                            self._handledblclick(event, self);
                        }
                        else if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                            var result = self._handlemousedown(event, self);
                        }

                        self.mousecaptured = false;
                        self._lastmousedown = new Date();
                        return true;
                    });

                    self._mousemovefunc = function (event) {
                        if (self._handlemousemove) {
                            return self._handlemousemove(event, self);
                        };
                    }

                    self.addHandler(self.content, 'mousemove', self._mousemovefunc);

                    if (self._handlemousemoveselection) {
                        self._mousemovedocumentfunc = function (event) {
                            if (self._handlemousemoveselection) {
                                return self._handlemousemoveselection(event, self);
                            };
                        }

                        self.addHandler($(document), 'mousemove.selection' + self.element.id, self._mousemovedocumentfunc);
                    }

                    self.addHandler($(document), 'mouseup.selection' + self.element.id, function (event) {
                        if (self._handlemouseupselection) {
                            if (event.shiftKey && $(event.target).ischildof(self.host) && self.autofill) {
                                var editable = self.editable;
                                self.editable = false;
                                self._lastmousedown = new Date(2000, 1, 1);
                                self._handlemousedown(event, self);
                                self.mousecaptured = true;
                                self.editable = editable;
                            }
                            self._handlemouseupselection(event, self);
                        }
                    });
                }

                try {
                    if (document.referrer != "" || window.frameElement) {
                        if (window.top != null && window.top != window.self) {
                            var parentLocation = null;

                            if (window.parent && document.referrer) {
                                parentLocation = document.referrer;
                            }

                            if (parentLocation && parentLocation.indexOf(document.location.host) != -1) {
                                var eventHandle = function (event) {
                                    if (self._handlemouseupselection) {
                                        try {
                                            self._handlemouseupselection(event, self);
                                        }
                                        catch (error) {
                                        }
                                    }
                                };
                                self.addHandler($(window.top.document), "mouseup.grid" + self.element.id, eventHandle);
                            }
                        }
                    }
                }
                catch (error) {
                }

                self.focused = false;

                if (!isTouch) {
                    self.addHandler(self.content, 'mouseenter', function (event) {
                        self.focused = true;

                        if (self.wrapper) {
                            self.wrapper.attr('tabindex', 1);
                            self.content.attr('tabindex', 2);
                        }

                        if (self._overlayElement) {
                            if (self.vScrollInstance.isScrolling() || self.hScrollInstance.isScrolling()) {
                                self._overlayElement[0].style.visibility = 'visible';
                            }
                            else {
                                self._overlayElement[0].style.visibility = 'hidden';
                            }
                        }
                    });

                    self.addHandler(self.content, 'mouseleave', function (event) {
                        if (self._handlemousemove) {
                            if (self.enablehover) {
                                self._clearhoverstyle();
                            }
                        }
                        if (self._overlayElement) {
                            self._overlayElement[0].style.visibility = 'hidden';
                        }
                        self.focused = false;
                    });

                    if (self.groupable || self.columnsreorder) {
                        self.addHandler($(document), 'selectstart.' + self.element.id, function (event) {
                            if (self.__drag === true) {
                                return false;
                            }
                        });
                    }

                    self.addHandler(self.content, 'selectstart.' + self.element.id, function (event) {
                        if (self.enablebrowserselection) {
                            return true;
                        }

                        if (self.showfilterrow) {
                            if ($(event.target).ischildof(self.filterrow))
                                return true;
                        }

                        if (self.showeverpresentrow) {
                            if ($(event.target).ischildof(self.addnewrow))
                                return true;

                            if (self.addnewrowtop) {
                                if ($(event.target).ischildof(self.addnewrowtop))
                                    return true;
                            }
                        }

                        if (event.target.className && event.target.className.indexOf && event.target.className.indexOf('jqx-grid-widget') >= 0) {
                            return true;
                        }

                        if (!self.editcell) {
                            return false;
                        }

                        if (event.stopPropagation) {
                            event.stopPropagation();
                        }
                    });

                    self.addHandler($(document), 'keyup.edit' + self.element.id, function (event) {
                        self._keydown = false;
                    });

                    self.addHandler($(document), 'keydown.edit' + self.element.id, function (event) {
                        if (self.adaptiveview) {
                            return true;
                        }

                        self._keydown =   true && !self.editcell;
                        var key = event.charCode ? event.charCode : event.keyCode ? event.keyCode : 0;
                        if (key === 20) {
                            if (!self._capsLock) {
                                self._capsLock = true;
                            }
                            else {
                                self._capsLock = false;
                            }
                        }
                        if (self.handlekeyboardnavigation) {
                            if (self.focused || (event.target === self.element || $(event.target).ischildof(self.host))) {
                                var handled = self.handlekeyboardnavigation(event);
                                if (handled == true)
                                    return false;
                            }
                        }

                        if (self.editable && self.editcell) {
                            if (key == 13 || key == 27 || key == 9 || key == 32) {
                                if (self._handleeditkeydown) {
                                    result = self._handleeditkeydown(event, self);
                                }
                            }
                        }
                        if (key == 27) {
                            self.mousecaptured = false;
                            if (self.selectionarea.css('visibility') == 'visible') {
                                self.selectionarea.css('visibility', 'hidden');
                            }
                        }
                        if ($.jqx.browser.msie && $.jqx.browser.version < 12 && self.focused && !self.isNestedGrid) {
                            if (key == 13 && result == false) {
                                return result;
                            }

                            var result = true;
                            var key = event.charCode ? event.charCode : event.keyCode ? event.keyCode : 0;
                            if (!self.editcell && self.editable && self.editmode != 'programmatic') {
                                if (self._handleeditkeydown) {
                                    result = self._handleeditkeydown(event, self);
                                }
                            }
                            if (result && self.keyboardnavigation && self._handlekeydown) {
                                result = self._handlekeydown(event, self);
                                if (!result) {
                                    if (event.preventDefault)
                                        event.preventDefault();

                                    if (event.stopPropagation != undefined) {
                                        event.stopPropagation();
                                    }
                                }
                                return result;
                            }
                        }

                        return true;
                    });

                    self.addHandler(self.host, 'keyup.edit' + self.element.id, function (event) {
                        if (self.adaptiveview) {
                            return true;
                        }

                        if (event.keyCode === 9) {
                            if (!$(document.activeElement).ischildof(self.filterrow)) {
                                if (!$(document.activeElement).ischildof(self.pager)) {
                                    switch (self.selectionmode) {
                                        case 'singlecell':
                                        case 'multiplecells':
                                        case 'multiplecellsextended':
                                        case 'multiplecellsadvanced':
                                            var selectedcell = self.getselectedcell();
                                            if (selectedcell === null) {
                                                //      self.selectcell(0, self.columns.records[0].displayfield);
                                            }
                                            break;
                                        default:
                                            var selectedrow = self.getselectedrowindex();
                                            if (selectedrow === -1) {
                                                //        self.selectrow(0);
                                            }
                                            break;
                                    }
                                }
                            }
                        }
                    });

                    self.addHandler(self.host, 'keydown.edit' + self.element.id, function (event) {
                        var result = true;
                        if (self.adaptiveview) {
                            return true;
                        }
                        if (self.handlekeyboardnavigation) {
                            var handled = self.handlekeyboardnavigation(event);
                            if (handled == true) {
                                return false;
                            }
                        }

                        if (self.editable && self.editmode != 'programmatic') {
                            if (self._handleeditkeydown) {
                                result = self._handleeditkeydown(event, self);
                                if (self.isNestedGrid) {
                                    event.stopPropagation();
                                }
                            }
                        }

                        if (!self.editcell && event.altKey) {
                            if (!$(document.activeElement).ischildof(self.filterrow)) {
                                if (!$(document.activeElement).ischildof(self.pager)) {

                                    if (event.keyCode === 40) {
                                        var selectedcell = self.getselectedcell();
                                        if (selectedcell) {
                                            self.openmenu(selectedcell.column);
                                        }
                                    }
                                    else if (event.keyCode === 38) {
                                        self._closemenu();
                                    }
                                }
                            }
                        }

                        if (!($.jqx.browser.msie && $.jqx.browser.version < 8)) {
                            if (result && self.keyboardnavigation && self._handlekeydown) {
                                result = self._handlekeydown(event, self);
                                if (self.isNestedGrid) {
                                    event.stopPropagation();
                                }
                            }
                        }
                        else if (self.isNestedGrid) {
                            if (result && self.keyboardnavigation && self._handlekeydown) {
                                result = self._handlekeydown(event, self);
                                event.stopPropagation();
                            }
                        }

                        if (!result) {
                            if (event.preventDefault)
                                event.preventDefault();

                            if (event.stopPropagation != undefined) {
                                event.stopPropagation();
                            }
                        }

                        if (result && self.selectedcells && self.selectedcells.length > 0) {
                            if (event.keyCode === 9 && event.shiftKey && self.table && self.table[0].rows && self.table[0].rows.length > 0) {
                                if (!$(document.activeElement).ischildof(self.filterrow)) {
                                    if (!$(document.activeElement).ischildof(self.pager)) {
                                        self.table[0].rows[0].cells[0].focus();
                                    }
                                }
                            }
                        }

                        return result;
                    });
                }
            },

            _hittestrow: function (x, y) {
                if (this.vScrollInstance == null || this.hScrollInstance == null)
                    return;

                if (x == undefined) x = 0;
                if (y == undefined) y == 0;

                var vScrollInstance = this.vScrollInstance;
                var hScrollInstance = this.hScrollInstance;
                var verticalscrollvalue = vScrollInstance.value;
                if (this.vScrollBar.css('visibility') != 'visible') {
                    verticalscrollvalue = 0;
                }
                var horizontalscrollvalue = hScrollInstance.value;
                if (this.hScrollBar.css('visibility') != 'visible') {
                    horizontalscrollvalue = 0;
                }

                if (this.scrollmode == 'deferred' && this._newmax != null) {
                    if (verticalscrollvalue > this._newmax) verticalscrollvalue = this._newmax;
                }

                var top = parseInt(verticalscrollvalue) + y;
                var left = parseInt(horizontalscrollvalue) + x;

                if (this.visiblerows == null) {
                    return;
                }
                if (this.visiblerows.length == 0) {
                    return;
                }

                var details = false;
                var hitIndex = this._findvisiblerow(top, this.visiblerows);
                if (hitIndex >= 0) {
                    var hitRow = this.visiblerows[hitIndex];
                    var hasdetails = this.rowdetails && hitRow.rowdetails;
                    var showdetails = !hitRow.rowdetailshidden;
                    if (hasdetails) {
                        var prevRow = this.visiblerows[hitIndex - 1];
                        if (prevRow == hitRow) {
                            hitRow = prevRow;
                            hitIndex--;
                        }

                        if (showdetails) {
                            var rowstop = $(this.hittestinfo[hitIndex].visualrow).position().top + parseInt(this.table.css('top'));
                            var rowsheight = $(this.hittestinfo[hitIndex].visualrow).height();
                            if (!(y >= rowstop && y <= rowstop + rowsheight)) {
                                hitIndex++;
                                hitRow = this.visiblerows[hitIndex];
                                details = true;
                            }
                        }
                    }
                }
                return {
                    index: hitIndex, row: hitRow, details: details
                };
            },

            getcellatposition: function (left, top) {
                var self = this.that;
                var columnheaderheight = this.showheader ? this.columnsheader.height() + 2 : 0;
                var groupsheaderheight = this._groupsheader() ? this.groupsheader.height() : 0;
                var toolbarheight = this.showtoolbar ? this.toolbarheight : 0;
                var filterheight = this.showfilterbar ? this.toolbarheight : 0;

                groupsheaderheight += toolbarheight;
                groupsheaderheight += filterheight;

                var hostoffset = this.host.coord();
                if (this.hasTransform) {
                    hostoffset = $.jqx.utilities.getOffset(this.host);
                }
                var x = left - hostoffset.left;
                var y = top - columnheaderheight - hostoffset.top - groupsheaderheight;
                var rowinfo = this._hittestrow(x, y);
                var row = rowinfo.row;
                var index = rowinfo.index;
                var tablerow = this.table[0].rows[index];

                if (this.dataview && this.dataview.records.length == 0) {
                    var rows = this.table[0].rows;
                    var rowY = 0;
                    for (var i = 0; i < rows.length; i++) {
                        if (y >= rowY && y < rowY + this.rowsheight) {
                            tablerow = rows[i];
                            break;
                        }
                        rowY += this.rowsheight;
                    }
                    row = {
                        boundindex: i
                    };
                }

                if (tablerow == null)
                    return true;

                var hScrollInstance = this.hScrollInstance;
                var horizontalscrollvalue = hScrollInstance.value;
                var cellindex = 0;
                var groupslength = this.groupable ? this.groups.length : 0;

                for (var i = 0; i < tablerow.cells.length; i++) {
                    var columnleft = parseInt($(this.columnsrow[0].cells[i]).css('left'));
                    var left = columnleft - horizontalscrollvalue;
                    if (self.columns.records[i].pinned) {
                        left = columnleft;
                    }
                    if (self.columns.records[i].hidden || self.columns.records[i].adaptivehidden) {
                        continue;
                    }

                    var right = left + $(this.columnsrow[0].cells[i]).width();
                    if (right >= x && x >= left) {
                        cellindex = i;
                        break;
                    }
                }

                if (row != null) {
                    var column = this._getcolumnat(cellindex);
                    return {
                        row: this.getboundindex(row), column: column.datafield, value: this.getcellvalue(this.getboundindex(row), column.datafield)
                    };
                }

                return null;
            },

            _handlecardedit: function (event) {
                var rowid = event.target.getAttribute('row');
                var window = document.createElement('div');
                var rowdata = this.getrowdatabyid(rowid);
                var cell = '<div class="jqx-grid-card-cell">';

                cell += '<table>';
                for (var s = 0; s < this.columns.records.length; s++) {
                    var column = this.columns.records[s];
                    if (column.hidden && column.__hidden === undefined) {
                        continue;
                    }


                    var cellvalue = rowdata[column.datafield];
                    if (column.cellsformat != '') {
                        if ($.jqx.dataFormat) {
                            if ($.jqx.dataFormat.isDate(cellvalue)) {
                                cellvalue = $.jqx.dataFormat.formatdate(cellvalue, column.cellsformat, this.gridlocalization);
                            }
                            else if ($.jqx.dataFormat.isNumber(cellvalue)) {
                                cellvalue = $.jqx.dataFormat.formatnumber(cellvalue, column.cellsformat, this.gridlocalization);
                            }
                        }
                    }

                    cell += '<tr class="jqx-grid-card-table-row">';
                    cell += '<td class="jqx-grid-card-cell-label"><div>' + column.text + '</div></td>';
                    cell += '<td class="jqx-grid-card-cell-value"><div><input datafield="' + column.datafield + '" class="jqx-widget jqx-input" value="' + cellvalue + '"/></div></td>';
                    cell += '</tr>';
                }

                cell += '</table>';
                cell += '</div>';

                cell += '<div class="jqx-card-edit-buttons"><input style="margin-right: 5px;" type="button" dataid="Save" value="Save" /><input dataid="Cancel" type="button" value="Cancel" /></td>';
                cell += '</div>';

                window.innerHTML = '<div>' + this.gridlocalization.udpaterowstring + ' ' + rowid + '</div><div style="overflow: hidden;">' + cell + '</div></div>';
                var saveButton = window.querySelector('[dataid="Save"]');
                var cancelButton = window.querySelector('[dataid="Cancel"]');

                $(saveButton).jqxButton({ template: 'primary', width: '40%', theme: this.theme });
                $(cancelButton).jqxButton({ width: '40%', theme: this.theme });

                var that = this;

                saveButton.onclick = function () {
                    var values = $(window).find('[datafield]');
                    var newData = {};

                    for (var i = 0; i < values.length; i++) {
                        var datafield = values[i].getAttribute('datafield');
                        var value = values[i].value;

                        for (var j = 0; j < that.dataview.source.datafields.length; j++) {
                            var field = that.dataview.source.datafields[j];

                            if (field.name === datafield) {
                                if (field.type === 'bool' || field.type === 'boolean') {
                                    value =   true ? true : 0;
                                }

                                var column = that._getcolumnbydatafield(field.name);
                                var type = field.type;
                                var number = type === "number" || type === "float" || type === "int" || type === "integer";
                                var date = type === "date" || type === "time";
                                if (number || (type === "string" && (column.cellsformat.indexOf('p') != -1 || column.cellsformat.indexOf('c') != -1 || column.cellsformat.indexOf('n') != -1 || column.cellsformat.indexOf('f') != -1))) {
                                    if (value === "" && column.nullable)
                                        return "";

                                    if (value.indexOf && value.indexOf(that.gridlocalization.currencysymbol) > -1) {
                                        // remove currency symbol
                                        value = value.replace(that.gridlocalization.currencysymbol, "");
                                    }

                                    var replaceAll = function (text, stringToFind, stringToReplace) {
                                        var temp = text;
                                        if (stringToFind == stringToReplace) return text;

                                        var index = temp.indexOf(stringToFind);
                                        while (index != -1) {
                                            temp = temp.replace(stringToFind, stringToReplace);
                                            index = temp.indexOf(stringToFind)
                                        }

                                        return temp;
                                    }

                                    var tmp = value;
                                    tmp = parseFloat(tmp);
                                    if (!isNaN(tmp)) {
                                        value = tmp;
                                    }
                                    else {
                                        value = replaceAll(value, that.gridlocalization.thousandsseparator, "");
                                        value = value.replace(that.gridlocalization.decimalseparator, ".");

                                        if (value.indexOf(that.gridlocalization.percentsymbol) > -1) {
                                            value = value.replace(that.gridlocalization.percentsymbol, "");
                                        }

                                        var val = "";
                                        for (var t = 0; t < value.length; t++) {
                                            var ch = value.substring(t, t + 1);
                                            if (ch === "-") val += "-";
                                            if (ch === ".") val += ".";
                                            if (ch.match(/^[0-9]+$/) != null) {
                                                val += ch;
                                            }
                                        }

                                        value = val;
                                        value = value.replace(/ /g, "");

                                        value = new Number(value);
                                        if (isNaN(value))
                                            value = "";
                                    }
                                }
                                if (date || (type === "string" && (column.cellsformat.indexOf('H') != -1 || column.cellsformat.indexOf('m') != -1 || column.cellsformat.indexOf('M') != -1 || column.cellsformat.indexOf('y') != -1
                                    || column.cellsformat.indexOf('h') != -1 || column.cellsformat.indexOf('d') != -1))) {
                                    if (value === "" && column.nullable)
                                        return "";

                                    var tmpValue = value;
                                    if ($.jqx.dataFormat) {
                                        value = $.jqx.dataFormat.tryparsedate(tmpValue, that.gridlocalization);
                                    }
                                    if (value == "Invalid Date" || value == null) {
                                        value = "";
                                    }
                                }
                            }
                        }

                        newData[datafield] = value;
                    }

                    that.updaterow(rowid, newData);

                    $(window).jqxWindow('close');
                }

                cancelButton.onclick = function () {
                    $(window).jqxWindow('close');
                }

                document.body.appendChild(window);

                $(window).jqxWindow({ position: { left: this.host.offset().left, top: this.host.offset().top }, modalOpacity: 0.01, width: this.element.offsetWidth, height: this.element.offsetHeight, isModal: true, autoOpen: false, resizable: false, draggable: false });

                $(window).jqxWindow('open');

                if (this.cardwindow) {
                    $(this.cardwindow).remove();
                }
                this.cardwindow = window;
            },

            _handlemousedown: function (event, self) {
                if (event.target == null) {
                    return true;
                }

                if (self.disabled) {
                    return true;
                }

                if ($(event.target).ischildof(this.columnsheader) || $(event.target).ischildof(this.hScrollBar) || $(event.target).ischildof(this.vScrollBar)) {
                    return true;
                }

                if (event.target === self.bottomRight[0]) {
                    return true;
                }

                if (self.cardview && event.target && event.target.className.indexOf('jqx-icon-edit') >= 0) {
                    self._handlecardedit(event);
                }

                var rightclick;
                if (event.which) rightclick = (event.which == 3);
                else if (event.button) rightclick = (event.button == 2);

                var middleclick;
                if (event.which) middleclick = (event.which == 2);
                else if (event.button) middleclick = (event.button == 1);

                if (middleclick) {
                    return true;
                }

                if (this.adaptiveview) {
                    if ($(event.target).ischildof($(this.adaptiveview)))
                        return true;
                    if (event.target == this.adaptiveview)
                        return true;
                }

                if (this.showstatusbar) {
                    if ($(event.target).ischildof(this.statusbar))
                        return true;
                    if (event.target == this.statusbar[0])
                        return true;
                }
                if (this.showtoolbar) {
                    if ($(event.target).ischildof(this.toolbar))
                        return true;
                    if (event.target == this.toolbar[0])
                        return true;
                }
                if (this.showfilterbar) {
                    if ($(event.target).ischildof(this.filterbar))
                        return true;
                    if (event.target == this.filterbar[0])
                        return true;
                }
                if (this.pageable) {
                    if ($(event.target).ischildof(this.pager))
                        return true;
                    if (event.target == this.pager[0])
                        return true;
                }
                if (!this.columnsheader) return true;

                if (!this.editcell) {
                    if (this.pageable) {
                        if ($(event.target).ischildof(this.pager))
                            return true;
                    }
                    //this.focus();
                }

                var columnheaderheight = this.showheader ? this.columnsheader.height() + 2 : 0;
                var groupsheaderheight = this._groupsheader() ? this.groupsheader.height() : 0;
                var toolbarheight = this.showtoolbar ? this.toolbarheight : 0;
                var filterheight = this.showfilterbar ? this.toolbarheight : 0;

                groupsheaderheight += toolbarheight;
                groupsheaderheight += filterheight;

                var hostoffset = this.host.coord();
                if (this.hasTransform) {
                    hostoffset = $.jqx.utilities.getOffset(this.host);
                    var bodyOffset = this._getBodyOffset();
                    hostoffset.left -= bodyOffset.left;
                    hostoffset.top -= bodyOffset.top;
                }

                var left = parseInt(event.pageX);
                var top = parseInt(event.pageY);

                if (this.isTouchDevice()) {
                    var touches = self.getTouches(event);
                    var touch = touches[0];
                    left = parseInt(touch.pageX);
                    top = parseInt(touch.pageY);
                    if (self.touchmode == true) {
                        if (touch._pageX != undefined) {
                            left = parseInt(touch._pageX);
                            top = parseInt(touch._pageY);
                        }
                    }
                }
                var x = left - hostoffset.left;
                var y = top - columnheaderheight - hostoffset.top - groupsheaderheight;
                if (this.pageable && !this.autoheight && this.gotopage) {
                    var pagerposition = this.pager.coord().top - hostoffset.top - groupsheaderheight - columnheaderheight;
                    if (y > pagerposition) {
                        return;
                    }
                }
                var rowinfo = this._hittestrow(x, y);
                if (!rowinfo)
                    return;

                if (rowinfo.details)
                    return;

                var row = rowinfo.row;
                var index = rowinfo.index;
                var targetclassname = event.target.className;
                var tablerow = this.table[0].rows[index];
                if (tablerow == null) {
                    if (self.editable && self.begincelledit) {
                        if (self.editcell) {
                            self.endcelledit(self.editcell.row, self.editcell.column, false, true);
                        }
                    }
                    return true;
                }

                self.mousecaptured = true;
                self.mousecaptureposition = {
                    left: event.pageX, top: event.pageY - groupsheaderheight, clickedrow: tablerow
                };

                var hScrollInstance = this.hScrollInstance;
                var horizontalscrollvalue = hScrollInstance.value;
                if (this.rtl) {
                    if (this.hScrollBar.css('visibility') != 'hidden') {
                        horizontalscrollvalue = hScrollInstance.max - hScrollInstance.value;
                    }
                }

                var cellindex = -1;
                var groupslength = this.groupable ? this.groups.length : 0;
                if (this.rtl) {
                    if (this.vScrollBar[0].style.visibility != 'hidden') {
                        horizontalscrollvalue -= this.scrollbarsize + 4;
                    }
                    if (this.hScrollBar[0].style.visibility == 'hidden') {
                        horizontalscrollvalue = -parseInt(this.content.css('left'));
                    }
                }

                for (var i = 0; i < tablerow.cells.length; i++) {
                    var columnleft = parseInt($(this.columnsrow[0].cells[i]).css('left'));
                    var left = columnleft - horizontalscrollvalue;
                    if (self.columns.records[i].pinned && !self.rtl) {
                        left = columnleft;
                    }

                    var column = this._getcolumnat(i);
                    if (column != null && column.hidden) {
                        continue;
                    }
                    if (column != null && column.adaptivehidden) {
                        continue;
                    }

                    var right = left + $(this.columnsrow[0].cells[i]).width();
                    if (right >= x && x >= left) {
                        cellindex = i;
                        self.mousecaptureposition.clickedcell = i;
                        break;
                    }
                }

                if (this.rtl && this._haspinned) {
                    for (var i = tablerow.cells.length - 1; i >= 0; i--) {
                        if (!self.columns.records[i].pinned) break;

                        var columnleft = $(this.columnsrow[0].cells[i]).coord().left - this.host.coord().left;
                        var left = columnleft;

                        var column = this._getcolumnat(i);
                        if (column != null && column.hidden) {
                            continue;
                        }
                        if (column != null && column.adaptivehidden) {
                            continue;
                        }

                        var right = left + $(this.columnsrow[0].cells[i]).width();
                        if (right >= x && x >= left) {
                            cellindex = i;
                            self.mousecaptureposition.clickedcell = i;
                            break;
                        }
                    }
                }

                if (row != null && cellindex >= 0) {
                    this._raiseEvent(1, {
                        rowindex: this.getboundindex(row), visibleindex: row.visibleindex, row: row, group: row.group, rightclick: rightclick, originalEvent: event
                    });
                    var column = this._getcolumnat(cellindex);
                    var cellvalue = this.getcellvalue(this.getboundindex(row), column.datafield);
                    if (this.editable && this.editcell) {
                        this._currentEditableColumn = cellindex;

                        if (column.datafield == this.editcell.column) {
                            if (this.getboundindex(row) == this.editcell.row) {
                                this.mousecaptured = false;
                            }
                        }
                    }

                    if (column.columntype === "adaptive") {
                        var rowInfo = document.createElement('div');
                        var cellData = document.createElement('div');
                        var okAnchor = document.createElement('a');
                        var cancelAnchor = document.createElement('a');
                        var okCancelContainer = document.createElement('div');

                        var rowData = this.getrowdata(this.getboundindex(row));

                        okAnchor.href = "#";
                        cancelAnchor.href = "#";

                        rowInfo.style.zIndex = 99999;
                        rowInfo.style.position = "absolute";
                        rowInfo.style.left = "0px";
                        rowInfo.style.top = "0px";
                        rowInfo.style.width = "100%";
                        rowInfo.style.height = "100%";
                        rowInfo.className = "jqx-adaptive-view jqx-widget-content";

                        okCancelContainer.style.position = "relative";
                        okCancelContainer.style.top = "100%";
                        okCancelContainer.style.textAlign = "center";
                        okCancelContainer.style.marginTop = "-40px";

                        cellData.style.position = "absolute";
                        cellData.style.left = "0px";
                        cellData.style.top = "0px";
                        cellData.style.width = "100%";
                        cellData.style.height = "100%";

                        if (this.theme) {
                            rowInfo.className = "jqx-widget-content jqx-widget-content-" + this.theme;
                        }
                        var closeButton = document.createElement('span');
                        closeButton.className = "jqx-icon-close";
                        if (this.theme) {
                            closeButton.className = "jqx-icon-close jqx-widget-close-" + this.theme;
                        }

                        closeButton.style.zIndex = 99;
                        closeButton.style.position = "absolute";
                        closeButton.style.right = "10px";
                        closeButton.style.top = "10px";
                        closeButton.style.width = "16px";
                        closeButton.style.height = "16px";

                        rowInfo.appendChild(cellData);
                        rowInfo.appendChild(closeButton);

                        okAnchor.innerHTML = this.gridlocalization.okstring;
                        cancelAnchor.innerHTML = this.gridlocalization.cancelstring;

                        okAnchor.addEventListener('mousedown', function (event) {
                            var rowNewData = {
                            };

                            var inputs = self.adaptiveview.querySelectorAll('input');

                            for (var i = 0; i < inputs.length; i++) {
                                var value = self.escape_HTML(inputs[i].value);
                                var displayField = inputs[i].getAttribute('data-column');
                                rowNewData[displayField] = value;
                            }

                            self.updaterow(rowData.uid, rowNewData);

                            rowInfo.parentNode.removeChild(rowInfo);
                            self.adaptiveview = null;

                            event.stopPropagation();
                            return false;
                        });

                        cancelAnchor.addEventListener('mousedown', function () {
                            rowInfo.parentNode.removeChild(rowInfo);
                            self.adaptiveview = null;

                            event.stopPropagation();
                            return false;
                        });

                        if (this.editable) {
                            okCancelContainer.appendChild(okAnchor);
                            okCancelContainer.appendChild(cancelAnchor);
                            rowInfo.appendChild(okCancelContainer);
                        }

                        var table = "<table class='jqx-adaptive-table'><tr>";
                        var index = 0;

                        for (var i = 0; i < this.columns.records.length; i++) {
                            var column = this.columns.records[i];
                            if (column.columntype === "adaptive") {
                                continue;
                            }

                            if (column.datafield === "_checkboxcolumn") {
                                continue;
                            }

                            if (i > 0 && index % 2 === 0) {
                                table += "</tr><tr>";
                            }

                            var cellValue = rowData[column.displayfield];

                            if (column.cellsformat != '') {
                                if ($.jqx.dataFormat) {
                                    if ($.jqx.dataFormat.isDate(cellValue)) {
                                        cellValue = $.jqx.dataFormat.formatdate(cellValue, column.cellsformat, this.gridlocalization);
                                    }
                                    else if ($.jqx.dataFormat.isNumber(cellValue)) {
                                        cellValue = $.jqx.dataFormat.formatnumber(cellValue, column.cellsformat, this.gridlocalization);
                                    }
                                }
                            }

                            var filterIcon = this.filterable ? '<div datafield="' + column.datafield + '" class="' + self.toTP('jqx-grid-column-filterbutton') + '" style="position: relative; top: 4px; display: inline-block; width: 16px; height:16px;"></div>' : '';

                            if (this.editable) {
                                if (column.editable) {
                                    table += "<td>" + filterIcon + this.escape_HTML(column.text) + ": <input data-column='" + column.displayfield + "' value='" + cellValue + "'/></td>";
                                }
                                else {
                                    table += "<td>" + filterIcon + this.escape_HTML(column.text) + ": <input data-column='" + column.displayfield + "' readonly value='" + cellValue + "'/></td>";
                                }
                            }
                            else {
                                table += "<td>" + filterIcon + this.escape_HTML(column.text) + ": " + cellValue + "</td>";
                            }

                            index++;
                        }


                        table += "</tr></table>";
                        cellData.innerHTML = table;
                        closeButton.addEventListener('mousedown', function (event) {
                            rowInfo.parentNode.removeChild(rowInfo);
                            self.adaptiveview = null;
                        });
                        this.wrapper[0].appendChild(rowInfo);

                        this.adaptiveview = rowInfo;

                        $(this.adaptiveview).find('.jqx-grid-column-filterbutton').on('click', function () {
                            var datafield = this.getAttribute('datafield');
                            var top = this.offsetTop;
                            self.openmenu(datafield);
                            setTimeout(function () {
                                self.gridmenu.css('top', 30 + top);
                                self.gridmenu.css('left', 25);
                                self.gridmenu.css('z-index', 99999);
                                self.gridmenu.parent().css('z-index', 99999);
                            }, 300);
                        });

                        return;
                    }

                    if (column.datafield === '_commandColumn') {
                        var index = this.getboundindex(row);

                        if (!this._commandColumnEdit && event.target && event.target.hasAttribute('edit')) {
                            this._commandColumnEdit = row;
                            this._commandColumnEditMode = this.editmode;
                            this.editmode = 'selectedrow';
                            this._rendervisualrows();
                            this.beginrowedit(index);
                        }
                        else {
                            if (event.target && event.target.hasAttribute('cancel')) {
                                this.endrowedit(index, true);
                                this._cellscache = new Array();
                                this._renderrows(this.virtualsizeinfo);
                            }
                            else if (event.target && event.target.hasAttribute('update')) {
                                this.endrowedit(index, false);
                                this._cellscache = new Array();
                                this._renderrows(this.virtualsizeinfo);
                            }
                        }
                    }

                    this._raiseEvent(8, {
                        rowindex: this.getboundindex(row), column: column ? column.getcolumnproperties() : null, row: row, visibleindex: row.visibleindex, datafield: column ? column.datafield : null, columnindex: cellindex, value: cellvalue, rightclick: rightclick, originalEvent: event
                    });
                    if (column.createwidget) {
                        return true;
                    }

                    if (this.isTouchDevice()) {
                        if (column.columntype == 'checkbox' && this.editable && this._overlayElement) {
                            if (!this.editcell) {
                                this._overlayElement.css('visibility', 'hidden');
                                this.editcell = this.getcell(index, column.datafield);
                                return true;
                            }
                        }
                        else if (column.columntype == 'button' && this._overlayElement) {
                            //   this._overlayElement.css('visibility', 'hidden');
                            if (column.buttonclick) {
                                column.buttonclick(tablerow.cells[cellindex].buttonrow, event);
                            }
                            return true;
                        }
                    }

                    // handle double clicks.
                    var _triggeredEvents = false;
                    if (this._lastmousedown != null) {
                        if (this._mousedown - this._lastmousedown < 300) {
                            if (this._clickedrowindex == this.getboundindex(row)) {
                                this._raiseEvent(22, {
                                    rowindex: this.getboundindex(row), row: row, visibleindex: row.visibleindex, group: row.group, rightclick: rightclick, originalEvent: event
                                });
                                if (this._clickedcolumn == column.datafield) {
                                    this._raiseEvent(23, {
                                        rowindex: this.getboundindex(row), row: row, visibleindex: row.visibleindex, column: column ? column.getcolumnproperties() : null, datafield: column ? column.datafield : null, columnindex: cellindex, value: cellvalue, rightclick: rightclick, originalEvent: event
                                    });
                                }
                                _triggeredEvents = true;
                                this._clickedrowindex = -1;
                                this._clickedcolumn = null;
                                if (event.isPropagationStopped && event.isPropagationStopped()) {
                                    return false;
                                }
                            }
                        }
                    }

                    if (rightclick) return true;

                    if (!_triggeredEvents) {
                        this._clickedrowindex = this.getboundindex(row);
                        this._clickedcolumn = column.datafield;
                    }
                    // end of handle double clicks.

                    var browserInfo = $.jqx.utilities.getBrowser();
                    if (browserInfo.browser == 'msie' && parseInt(browserInfo.version) <= 7) {
                        if (cellindex == 0 && this.rowdetails) {
                            targetclassname = "jqx-grid-group-collapse";
                        }
                        if (groupslength > 0) {
                            if (cellindex <= groupslength) {
                                targetclassname = "jqx-grid-group-collapse";
                            }
                        }
                    }

                    if (!targetclassname.indexOf) {
                        targetclassname = '';
                    }

                    if (targetclassname.indexOf('jqx-grid-group-expand') != -1 || targetclassname.indexOf('jqx-grid-group-collapse') != -1) {
                        if (!this.rtl) {
                            if (groupslength > 0 && cellindex < groupslength && this._togglegroupstate) {
                                this._togglegroupstate(row.bounddata, true);
                            }
                            else if (cellindex == groupslength && this.rowdetails && this.showrowdetailscolumn) {
                                this._togglerowdetails(row.bounddata, true);
                                this.gridcontent[0].scrollTop = 0;
                                this.gridcontent[0].scrollLeft = 0;
                            }
                        }
                        else {
                            if (groupslength > 0 && cellindex > tablerow.cells.length - groupslength - 1 && this._togglegroupstate) {
                                this._togglegroupstate(row.bounddata, true);
                            }
                            else if (cellindex == tablerow.cells.length - 1 - groupslength && this.rowdetails && this.showrowdetailscolumn) {
                                this._togglerowdetails(row.bounddata, true);
                                this.gridcontent[0].scrollTop = 0;
                                this.gridcontent[0].scrollLeft = 0;
                            }
                        }
                    }
                    else {
                        if (row.boundindex != -1) {
                            var oldselectedrowindexes = this.selectedrowindexes.slice(0);
                            var isoldcell = false;
                            if (self.selectionmode != 'none' && self.selectionmode != 'checkbox' && this._selectrowwithmouse) {
                                if (self.selectionmode == 'multiplecellsadvanced' || self.selectionmode == 'multiplecellsextended' || self.selectionmode == 'multiplerowsextended' || self.selectionmode == 'multiplerowsadvanced') {
                                    if (!event.ctrlKey && !event.shiftKey && !event.metaKey) {
                                        self.selectedrowindexes = new Array();
                                        self.selectedcells = new Array();
                                    }
                                }

                                var caneditrow = false;

                                var boundindex = this.getboundindex(row);
                                if (self._oldselectedrow === boundindex || self.selectionmode === "none") {
                                    caneditrow = true;
                                }

                                if (self.selectionmode.indexOf('cell') == -1) {
                                    if ((self.selectionmode != 'singlerow') || (self.selectedrowindex != boundindex && self.selectionmode == 'singlerow')) {
                                        this._applyrowselection(boundindex, true, false, null, column.datafield);
                                        this._selectrowwithmouse(self, rowinfo, oldselectedrowindexes, column.datafield, event.ctrlKey || event.metaKey, event.shiftKey);
                                    }
                                }
                                else {
                                    if (column.datafield != null) {
                                        this._selectrowwithmouse(self, rowinfo, oldselectedrowindexes, column.datafield, event.ctrlKey || event.metaKey, event.shiftKey);

                                        if (!event.shiftKey) {
                                            this._applycellselection(boundindex, column.datafield, true, false);
                                        }
                                    }
                                }

                                if (self._oldselectedcell) {
                                    if (self._oldselectedcell.datafield == self.selectedcell.datafield && self._oldselectedcell.rowindex == self.selectedcell.rowindex) {
                                        isoldcell = true;
                                    }
                                }
                                self._oldselectedcell = self.selectedcell;

                                self._oldselectedrow = boundindex;
                            }
                            if (self.autosavestate) {
                                if (self.savestate) self.savestate();
                            }
                            if (self.editable && self.begincelledit && self.editmode != "programmatic") {
                                if (event.isPropagationStopped && event.isPropagationStopped()) {
                                    return false;
                                }

                                if (self.editmode == "selectedrow") {
                                    if (caneditrow && !self.editcell) {
                                        if (column.columntype !== "checkbox") {
                                            this._currentEditableColumn = cellindex;
                                            var result = self.beginrowedit(this.getboundindex(row));
                                        }
                                    }
                                    else if (self.editcell && !caneditrow && self.selectionmode != "none") {
                                        var result = self.endrowedit(self.editcell.row);
                                    }
                                }
                                else {
                                    var boundindex = this.getboundindex(row);
                                    var canselect = self.editmode == 'click' || (isoldcell && self.editmode == 'selectedcell');
                                    if (self.selectionmode.indexOf('cell') == -1) {
                                        if (self.editmode != 'dblclick') {
                                            canselect = true;
                                        }
                                    }

                                    if (canselect) {
                                        if (row.boundindex != undefined && column.editable) {
                                            var result = self.begincelledit(this.getboundindex(row), column.datafield, column.defaulteditorvalue, false);
                                            if (self.selectionmode.indexOf('cell') != -1) {
                                                self._applycellselection(boundindex, column.datafield, false, false);
                                            }
                                            //       return false;
                                        }
                                    }

                                    if (self.selectionmode.indexOf('cell') != -1) {
                                        if (self.editmode == 'selectedcell' && !isoldcell && self.editcell) {
                                            self.endcelledit(self.editcell.row, self.editcell.column, false, true);
                                        }
                                    }
                                    if (self.editmode == 'dblclick' && !isoldcell && self.editcell && !(self.editcell.row == boundindex && column.datafield == self.editcell.column)) {
                                        self.endcelledit(self.editcell.row, self.editcell.column, false, true);
                                    }
                                }
                                return true;
                            }
                        }
                    }
                }
                return true;
            },

            _columnPropertyChanged: function (column, key, oldvalue, value) {
            },

            _rowPropertyChanged: function (row, key, oldvalue, value) {
            },

            _serializeObject: function (data) {
                if (data == null) return "";
                var str = "";
                $.each(data, function (index) {
                    var val = this;
                    if (index > 0) str += ', ';
                    str += "[";
                    var m = 0;
                    for (var obj in val) {
                        if (m > 0) str += ', ';
                        str += '{' + obj + ":" + val[obj] + '}';
                        m++;
                    }
                    str += "]";
                });
                return str;
            },

            isbindingcompleted: function () {
                return !this._loading;
            },

            //// private methods
            propertiesChangedHandler: function (object, key, value) {
                if (value.width && value.height && Object.keys(value).length == 2) {
                    object._updatesize(true, true);
                    object._resizeWindow();
                    if (object.virtualmode && !object._loading) {
                        object.vScrollInstance.setPosition(0);
                    }
                    else {
                        setTimeout(function () {
                            object._renderrows(object.virtualsizeinfo);
                        }, 100);
                    }
                }
            },

            propertyChangedHandler: function (object, key, oldvalue, value) {
                if (this.isInitialized == undefined || this.isInitialized == false)
                    return;

                if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                    return;
                }

                key = key.toLowerCase();
                switch (key) {
                    case 'sortmode': {
                        object.sortcolumns = [];
                        break;
                    }
                    case 'cardview':
                    case 'cardviewsize':
                    case 'cardviewcolumns':
                    case 'cardheight':
                        if (key === 'cardview' && value) {
                            object._oldrowsheight = object.rowsheight;
                        }
                        object.prerenderrequired == true;
                        object.rowsheight = 32;
                        object.__rowsheight = object.rowsheight;
                        object.virtualsizeinfo = null;
                        if (object.cardview) {
                            object.__rowsheight = object.rowsheight;
                            object.rowsheight = object.cardheight;
                        }
                        else {
                            if (object._oldrowsheight) {
                                object.__rowsheight = object._oldrowsheight;
                                object.rowsheight = object._oldrowsheight;
                                delete object._oldrowsheight;
                            }
                        }

                        object.virtualsizeinfo = null;
                        object.rendergridcontent(true, false);
                        object.refreshdata();

                        break;
                    case 'compact': {
                        var that = object;
                        if (that.compact) {
                            that.element.setAttribute('compact', '');
                            this.rowsheight = 25;
                            this.columnsheight = 25;
                            this.pagerheight = 30;
                            this.groupsheaderheight = 25;
                        }
                        else {
                            that.element.removeAttribute('compact', '');
                            this.rowsheight = 32;
                            this.columnsheight = 36;
                            this.pagerheight = 40;
                            this.groupsheaderheight = 34;
                        }
                        object.virtualsizeinfo = null;
                        object.rendergridcontent(true, false);
                        object.refreshdata();
                        break;
                    }
                    case "editable":
                    case "showcolumnheaderlines":
                    case "showcolumnlines":
                    case "showrowlines":
                        object.refresh();
                        break;
                    case "everpresentrowactionsmode":
                        if (oldvalue != value) {
                            object._removeaddnewrow();

                            object.render();
                        }
                        break;
                    case "everpresentrowactions":
                        object._updateaddnewrowui();
                        break;
                    case "showeverpresentrow":
                    case "everpresentrowposition":
                    case "everpresentrowheight":
                        if (oldvalue != value) {
                            object._removeaddnewrow();

                            object.render();
                        }
                        break;
                    case "rtl":
                        object.content.css('left', '');
                        object.columns = object._columns;
                        object._filterrowcache = [];
                        object.vScrollBar.jqxScrollBar({
                            rtl: value
                        });
                        object.hScrollBar.jqxScrollBar({
                            rtl: value
                        });
                        if (object._initpager) {
                            object._initpager();
                        }
                        if (object._initgroupsheader) {
                            object._initgroupsheader();
                        }
                        object.render();
                        break;
                    case "enablebrowserselection":
                        if (!object.showfilterrow) {
                            if (!object.showstatusbar && !object.showtoolbar) {
                                object.host.addClass('jqx-disableselect');
                            }
                            object.content.addClass('jqx-disableselect');
                        }

                        if (object.enablebrowserselection) {
                            object.content.removeClass('jqx-disableselect');
                            object.host.removeClass('jqx-disableselect');
                        }
                        break;
                    case "columnsheight":
                        if (object.columnsheight != 32 || object.columngroups) {
                            object._measureElement('column');
                        }
                        object._render(true, true, true, false, false);
                        break;
                    case "rowsheight":
                        if (value != oldvalue) {
                            if (object.rowsheight != 31) {
                                object._measureElement('cell');
                            }
                            object.virtualsizeinfo = null;
                            object.rendergridcontent(true, false);
                            object.refresh();
                        }
                        break;
                    case "scrollMode":
                        object.vScrollInstance.thumbStep = object.rowsheight;
                        break;
                    case "showdefaultloadelement":
                        object._builddataloadelement();
                        break;
                    case "showfiltermenuitems":
                    case "showsortmenuitems":
                    case "showgroupmenuitems":
                    case "filtermode":
                        object._initmenu();
                        break;
                    case "touchmode":
                        if (oldvalue != value) {
                            object._removeHandlers();
                            object.touchDevice = null;
                            object.vScrollBar.jqxScrollBar({
                                touchMode: value
                            });
                            object.hScrollBar.jqxScrollBar({
                                touchMode: value
                            });
                            object._updateTouchScrolling();
                            object._arrange();
                            object._updatecolumnwidths();
                            object._updatecellwidths();

                            object._addHandlers();
                        }
                        break;
                    case "autoshowcolumnsmenubutton":
                        if (oldvalue != value) {
                            object._rendercolumnheaders();
                        }
                        break;
                    case "rendergridrows":
                        if (oldvalue != value) {
                            object.updatebounddata();
                        }
                        break;
                    case "editmode":
                        if (oldvalue != value) {
                            object._removeHandlers();
                            object._addHandlers();
                        }
                        break;
                    case "source":
                        object.updatebounddata();
                        if (object.virtualmode && !object._loading) {
                            object.loadondemand = true;
                            object._renderrows(object.virtualsizeinfo);
                        }

                        break;
                    case "horizontalscrollbarstep":
                    case "verticalscrollbarstep":
                    case "horizontalscrollbarlargestep":
                    case "verticalscrollbarlargestep":
                        this.vScrollBar.jqxScrollBar({
                            step: this.verticalscrollbarstep, largestep: this.verticalscrollbarlargestep
                        });
                        this.hScrollBar.jqxScrollBar({
                            step: this.horizontalscrollbarstep, largestep: this.horizontalscrollbarlargestep
                        });
                        break;
                    case "closeablegroups":
                        if (object._initgroupsheader) {
                            object._initgroupsheader();
                        }
                        break;
                    case "showgroupsheader":
                        if (oldvalue != value) {
                            object._arrange();
                            if (object._initgroupsheader) {
                                object._initgroupsheader();
                            }
                            object._renderrows(object.virtualsizeinfo);
                        }
                        break;
                    case "theme":
                        if (value != oldvalue) {
                            $.jqx.utilities.setTheme(oldvalue, value, object.host);
                            if (object.gridmenu) {
                                object.gridmenu.jqxMenu({
                                    theme: value
                                });
                            }
                            if (object.pageable) {
                                object._updatepagertheme();
                            }
                            if (object.filterable) {
                                object._updatefilterrowui(true);
                            }
                            if (object.showeverpresentrow) {
                                object._updateaddnewrowui(true);
                            }

                            object._applyThemeSettings();
                        }
                        break;
                    case "showtoolbar":
                    case "showfilterbar":
                    case "toolbarheight":
                        if (oldvalue != value) {
                            object._arrange();
                            object.refresh();
                        }
                        break;
                    case "showstatusbar":
                        if (oldvalue != value) {
                            if (object.statusbar) {
                                if (value) {
                                    object.statusbar.show();
                                }
                                else {
                                    object.statusbar.hide();
                                }
                            }

                            object._arrange();
                            object.refresh();
                        }
                        break;
                    case "statusbarheight":
                        if (oldvalue != value) {
                            object._arrange();
                            object.refresh();
                        }
                        break;
                    case "filterable":
                    case "showfilterrow":
                        if (oldvalue != value) {
                            object.render();
                        }
                        break;
                    case "autoshowfiltericon":
                    case "showfiltercolumnbackground":
                    case "showpinnedcolumnbackground":
                    case "showsortcolumnbackground":
                        if (oldvalue != value) {
                            object.rendergridcontent();
                        }
                        break;
                    case "showrowdetailscolumn":
                        if (oldvalue != value) {
                            object.render();
                        }
                        break;
                    case "scrollbarsize":
                        if (oldvalue != value) {
                            $.jqx.utilities.scrollBarSize = value;
                            object._arrange();
                        }
                        break;
                    case "width":
                    case "height":
                        if (oldvalue != value) {
                            object._updatesize(true, true);
                            object._resizeWindow();
                            if (object.virtualmode && !object._loading) {
                                object.vScrollInstance.setPosition(0);
                            }
                            else {
                                setTimeout(function () {
                                    object._renderrows(object.virtualsizeinfo);
                                }, 100);
                            }
                        }
                        break;
                    case "altrows":
                    case "altstart":
                    case "altstep":
                        if (oldvalue != value) {
                            object._renderrows(object.virtualsizeinfo);
                        }
                        break;
                    case "groupsheaderheight":
                        if (oldvalue != value) {
                            object._arrange();
                            if (object._initgroupsheader) {
                                object._initgroupsheader();
                            }
                        }
                        break;
                    case "pagerheight":
                        if (oldvalue != value)
                            object._initpager();
                        break;
                    case "selectedrowindex":
                        object.selectrow(value);
                        break;
                    case "selectionmode":
                        if (oldvalue != value) {
                            if (value == 'none') {
                                object.selectedrowindexes = new Array();
                                object.selectedcells = new Array();
                                object.selectedrowindex = -1;
                            }
                            object._renderrows(object.virtualsizeinfo);
                            if (value == "checkbox") {
                                object._render(false, false, true, false, false);
                            }
                        }
                        break;
                    case "showheader":
                        if (value) {
                            object.columnsheader.css('display', 'block');
                        }
                        else {
                            object.columnsheader.css('display', 'none');
                        }
                        break;
                    case "virtualmode":
                        if (oldvalue != value) {
                            object.dataview.virtualmode = object.virtualmode;
                            object.dataview.refresh(false);
                            object._render(false, false, false);
                        }
                        break;
                    case "columnsmenu":
                        if (oldvalue != value) {
                            object.render();
                        }
                        break;
                    case "columngroups":
                        object._render(true, true, true, false, false);
                        break;
                    case "commandcolumn":
                    case "columns":
                        if (object.columns && object.columns.length > object.headerZIndex) {
                            object.headerZIndex = object.columns.length + 100;
                        }
                        if (object._serializeObject(object._cachedcolumns) !== object._serializeObject(value)) {
                            var hasFilter = false;
                            if (object.filterable) {
                                if (oldvalue && oldvalue.records) {
                                    $.each(oldvalue.records, function () {
                                        if (this.filter) hasFilter = true;
                                        object.dataview.removefilter(this.displayfield, this.filter);
                                    });
                                }
                            }
                            object._columns = null;
                            object._filterrowcache = [];
                            object.render();
                            if (hasFilter) {
                                object.applyfilters();
                            }
                            object._cachedcolumns = object.columns;
                            if (object.removesort) {
                                object.removesort();
                            }
                        }
                        else {
                            object[key] = oldvalue;
                        }

                        break;
                    case "autoheight":
                        if (oldvalue != value) {
                            object._render(false, false, true);
                        }
                        break;
                    case "pagermode":
                    case "pagerbuttonscount":
                        if (oldvalue != value) {
                            if (object._initpager) {
                                if (object.pagershowrowscombo) {
                                    object.pagershowrowscombo.jqxDropDownList('destroy');
                                    object.pagershowrowscombo = null;
                                }

                                if (object.pagerrightbutton) {
                                    object.removeHandler(object.pagerrightbutton, 'mousedown');
                                    object.removeHandler(object.pagerrightbutton, 'mouseup');
                                    object.removeHandler(object.pagerrightbutton, 'click');
                                    object.pagerrightbutton.jqxButton('destroy');
                                    object.pagerrightbutton = null;
                                }

                                if (object.pagerleftbutton) {
                                    object.removeHandler(object.pagerleftbutton, 'mousedown');
                                    object.removeHandler(object.pagerleftbutton, 'mouseup');
                                    object.removeHandler(object.pagerleftbutton, 'click');
                                    object.pagerleftbutton.jqxButton('destroy');
                                    object.removeHandler($(document), 'mouseup.pagerbuttons' + object.element.id);
                                    object.pagerleftbutton = null;
                                }
                                object.pagerdiv.remove();
                                object._initpager();
                            }
                        }
                        break;
                    case "pagesizeoptions":
                    case "pageable":
                    case "pagesize":
                        if (oldvalue != value) {
                            if (object._loading) {
                                throw new Error('jqxGrid: ' + object.loadingerrormessage);
                                return;
                            }
                            if (!object.host.jqxDropDownList || !object.host.jqxListBox) {
                                object._testmodules();
                                return;
                            }

                            if (object._initpager) {
                                if (key != "pageable" && key != "pagermode") {
                                    if (typeof (value) == "string") {
                                        var message = "The expected value type is: Int.";
                                        if (key != "pagesize") {
                                            var message = "The expected value type is: Array of Int values.";
                                        }

                                        throw new Error("Invalid Value for: " + key + ". " + message);
                                    }
                                }

                                object.dataview.pageable = object.pageable;
                                object.dataview.pagenum = 0;
                                object.dataview.pagesize = object._getpagesize();
                                if (object.virtualmode) {
                                    object.updatebounddata();
                                }
                                object.dataview.refresh(true);
                                object._initpager();
                                if (key == "pagesizeoptions") {
                                    if (value != null && value.length > 0) {
                                        object.pagesize = parseInt(value[0]);
                                        object.dataview.pagesize = parseInt(value[0]);
                                        object.prerenderrequired = true;
                                        object._requiresupdate = true;
                                        object.dataview.pagenum = -1;
                                        object.gotopage(0);
                                    }
                                }
                            }
                            object._render(false, false, false);
                        }
                        break;
                    case "groups":
                        if (object._serializeObject(oldvalue) !== object._serializeObject(value)) {
                            object.dataview.groups = value;
                            object._refreshdataview();
                            object._render(true, true, true, false);
                        }
                        break;
                    case "groupable":
                        if (oldvalue != value) {
                            object.dataview.groupable = object.groupable;
                            object.dataview.pagenum = 0;
                            object.dataview.refresh(false);
                            object._render(false, false, true);
                        }
                        break;
                    case "renderstatusbar":
                        if (value != null) {
                            object.renderstatusbar(object.statusbar);
                        }
                        break;
                    case "rendertoolbar":
                        if (value != null) {
                            object.rendertoolbar(object.toolbar);
                        }
                        break;
                    case "disabled":
                        if (value) {
                            object.host.addClass(object.toThemeProperty('jqx-fill-state-disabled'));
                        }
                        else object.host.removeClass(object.toThemeProperty('jqx-fill-state-disabled'));
                        $.jqx.aria(object, "aria-disabled", object.disabled);
                        if (object.pageable) {
                            if (object.pagerrightbutton) {
                                object.pagerrightbutton.jqxButton({
                                    disabled: value
                                });
                                object.pagerleftbutton.jqxButton({
                                    disabled: value
                                });
                                object.pagershowrowscombo.jqxDropDownList({
                                    disabled: value
                                });
                                object.pagergotoinput.attr('disabled', value);
                            }
                            if (object.pagerfirstbutton) {
                                object.pagerfirstbutton.jqxButton({
                                    disabled: value
                                });
                                object.pagerlastbutton.jqxButton({
                                    disabled: value
                                });
                            }
                        }
                        object.vScrollBar.jqxScrollBar({
                            disabled: value
                        });
                        object.hScrollBar.jqxScrollBar({
                            disabled: value
                        });
                        if (object.filterable && object.showfilterrow) {
                            object._updatefilterrowui(true);
                        }
                        if (object.showeverpresentrow) {
                            object._updateaddnewrowui(true);
                        }
                        break;
                }
            }
        });

        function jqxGridColumn(owner, data) {
            this.owner = owner;
            this.datafield = null;
            this.displayfield = null;
            this.text = '';
            this.createfilterpanel = null;
            this.sortable = true;
            this.hideable = true;
            this.editable = true;
            this.hidden = false;
            this.adaptivehidden = false;
            this.groupable = true;
            this.renderer = null;
            this.cellsrenderer = null;
            // checkbox column, number column, button column
            this.checkchange = null,
                this.threestatecheckbox = false;
            this.buttonclick = null,
                this.columntype = null;
            this.cellsformat = "";
            this.align = 'left';
            this.cellsalign = 'left';
            this.width = 'auto';
            this.minwidth = 25;
            this.maxwidth = 'auto';
            this.pinned = false;
            this.visibleindex = -1;
            this.filterable = true;
            // default, filter row, checked list
            this.filter = null;
            this.filteritems = [];
            this.resizable = true;
            this.initeditor = null;
            this.createeditor = null;
            this.createwidget = null;
            this.initwidget = null;
            this.destroywidget = null;
            this.destroyeditor = null;
            this.geteditorvalue = null;
            this.validation = null;
            this.classname = '';
            this.cellclassname = '';
            this.cellendedit = null;
            this.cellbeginedit = null;
            this.cellvaluechanging = null;
            this.aggregates = null;
            this.aggregatesrenderer = null;
            this.menu = true;
            this.createfilterwidget = null;
            this.filtertype = 'default';
            this.filtercondition = null;
            this.rendered = null;
            this.exportable = true;
            this.exporting = false;
            this.draggable = true;
            this.nullable = true;
            this.clipboard = true;
            this.selectable = false;
            this.autofill = true;
            this.sparklines = {
                type: 'column',
                colors: ['#D50000', '#E67C73', '#F4511E', '#F6BF26',
                    '#33B679', '#0B8043', '#039BE5', '#3F51B5',
                    '#7986CB', '#8E24AA', '#616161']
            };

            this._applyStyle = function () {
                var column = this;

                if (column.hovered) {
                    if (column.style.headerBackgroundHoveredColor) {
                        column.element.style.backgroundColor = column.style.headerBackgroundHoveredColor;
                    }

                    if (column.style.headerHoveredColor) {
                        column.element.style.color = column.style.headerHoveredColor;
                    }

                    return;
                }

                if (column.selected) {
                    if (column.style.headerBackgroundSelectedColor) {
                        column.element.style.backgroundColor = column.style.headerBackgroundSelectedColor;
                    }

                    if (column.style.headerSelectedColor) {
                        column.element.style.color = column.style.headerSelectedColor;
                    }

                    return;
                }


                if (column.style.headerBackgroundColor) {
                    column.element.style.backgroundColor = column.style.headerBackgroundColor;
                }
                else {
                    column.element.style.backgroundColor = '';
                }

                if (column.style.headerColor) {
                    column.element.style.color = column.style.headerColor;
                }
                else {
                    column.element.style.color = '';
                }
            };
            this._applyCellStyle = function (cell) {
                var column = this;
                var hasStyle = false;
                if (cell.length) {
                    for (var i = 0; i < cell.length; i++) {
                        this._applyCellStyle(cell[i]);
                    }
                    return;
                }
                if (column.style.backgroundColor || column.style.color ||
                    column.style.hoveredColor || column.style.hoveredColor ||
                    column.style.backgroundSelectedColor || column.style.selectedColor) {
                    hasStyle = true;
                }

                if (!hasStyle) {
                    return;
                }


                if (cell.className.indexOf('hover') >= 0) {
                    if (column.style.backgroundHoveredColor) {
                        cell.style.backgroundColor = column.style.backgroundHoveredColor;
                    }

                    if (column.style.hoveredColor) {
                        cell.style.color = column.style.hoveredColor;
                    }

                    return;
                }

                if (cell.className.indexOf('selected') >= 0) {
                    if (column.style.backgroundSelectedColor) {
                        cell.style.backgroundColor = column.style.backgroundSelectedColor;
                    }

                    if (column.style.selectedColor) {
                        cell.style.color = column.style.selectedColor;
                    }

                    return;
                }

                if (column.style.backgroundColor) {
                    cell.style.backgroundColor = column.style.backgroundColor;
                }

                if (column.style.color) {
                    cell.style.color = column.style.color;
                }

                if (column.style.fontFamily) {
                    cell.style.fontFamily = column.style.fontFamily;
                }

                if (column.style.fontWeight) {
                    cell.style.fontWeight = column.style.fontWeight;
                }
            };
            this.style = {
                headerBackgroundColor: '',
                headerColor: '',
                headerBackgroundHoveredColor: '',
                headerHoveredColor: '',
                headerBackgroundSelectedColor: '',
                headerSelectedColor: '',
                backgroundColor: '',
                color: '',
                backgroundHoveredColor: '',
                hoveredColor: '',
                backgroundSelectedColor: '',
                selectedColor: '',
                fontFamily: '',
                fontWeight: ''
            };
            this.enabletooltips = true;
            this.columngroup = null;
            this.filterdelay = 800;
            this.reseteverpresentrowwidgetvalue = null;
            this.geteverpresentrowwidgetvalue = null;
            this.createeverpresentrowwidget = null;
            this.initeverpresentrowwidget = null;
            this.validateeverpresentrowwidgetvalue = null;
            this.destroyeverpresentrowwidget = null;
            this.getcolumnproperties = function () {
                return {
                    nullable: this.nullable,
                    sortable: this.sortable, hideable: this.hideable,
                    hidden: this.hidden, groupable: this.groupable, width: this.width, align: this.align, editable: this.editable,
                    minwidth: this.minwidth, maxwidth: this.maxwidth, resizable: this.resizable, datafield: this.datafield, text: this.text,
                    exportable: this.exportable, cellsalign: this.cellsalign, pinned: this.pinned, cellsformat: this.cellsformat, columntype: this.columntype, classname: this.classname, cellclassname: this.cellclassname, menu: this.menu
                };
            },

                this.setproperty = function (propertyname, value) {
                    if (this[propertyname]) {
                        var oldvalue = this[propertyname];
                        this[propertyname] = value;
                        this.owner._columnPropertyChanged(this, propertyname, value, oldvalue);
                    }
                    else {
                        if (this[propertyname.toLowerCase()]) {
                            var oldvalue = this[propertyname.toLowerCase()];
                            this[propertyname.toLowerCase()] = value;
                            this.owner._columnPropertyChanged(this, propertyname.toLowerCase(), value, oldvalue);
                        }
                    }
                }

            this._initfields = function (data) {
                if (data != null) {
                    var me = this.that;
                    if ($.jqx.hasProperty(data, 'dataField')) {
                        this.datafield = $.jqx.get(data, 'dataField');
                    }
                    if ($.jqx.hasProperty(data, 'selectable')) {
                        this.selectable = $.jqx.get(data, 'selectable');
                    }

                    if ($.jqx.hasProperty(data, 'displayField')) {
                        this.displayfield = $.jqx.get(data, 'displayField');
                    }
                    else {
                        this.displayfield = this.datafield;
                    }
                    if ($.jqx.hasProperty(data, 'enableTooltips')) {
                        this.enabletooltips = $.jqx.get(data, 'enableTooltips');
                    }
                    if ($.jqx.hasProperty(data, 'text')) {
                        this.text = $.jqx.get(data, 'text');
                    }
                    else {
                        this.text = this.displayfield;
                    }
                    if ($.jqx.hasProperty(data, 'style')) {
                        this.style = $.jqx.get(data, 'style');
                    }
                    if ($.jqx.hasProperty(data, 'createfilterpanel')) {
                        this.createfilterpanel = $.jqx.get(data, 'createfilterpanel');
                    }
                    if ($.jqx.hasProperty(data, 'sortable')) {
                        this.sortable = $.jqx.get(data, 'sortable');
                    }
                    if ($.jqx.hasProperty(data, 'hideable')) {
                        this.hideable = $.jqx.get(data, 'hideable');
                    }
                    if ($.jqx.hasProperty(data, 'hidden')) {
                        this.hidden = $.jqx.get(data, 'hidden');
                    }
                    if ($.jqx.hasProperty(data, 'adaptivehidden')) {
                        this.adaptivehidden = $.jqx.get(data, 'adaptivehidden');
                    }
                    if ($.jqx.hasProperty(data, 'groupable')) {
                        this.groupable = $.jqx.get(data, 'groupable');
                    }
                    if ($.jqx.hasProperty(data, 'renderer')) {
                        this.renderer = $.jqx.get(data, 'renderer');
                    }
                    if ($.jqx.hasProperty(data, 'align')) {
                        this.align = $.jqx.get(data, 'align');
                    }
                    if ($.jqx.hasProperty(data, 'cellsAlign')) {
                        this.cellsalign = $.jqx.get(data, 'cellsAlign');
                    }
                    if ($.jqx.hasProperty(data, 'clipboard')) {
                        this.clipboard = $.jqx.get(data, 'clipboard');
                    }
                    if ($.jqx.hasProperty(data, 'cellsFormat')) {
                        this.cellsformat = $.jqx.get(data, 'cellsFormat');
                    }
                    if ($.jqx.hasProperty(data, 'width')) {
                        this.width = $.jqx.get(data, 'width');
                    }
                    if ($.jqx.hasProperty(data, 'autofill')) {
                        this.autofill = $.jqx.get(data, 'autofill');
                    }
                    if ($.jqx.hasProperty(data, 'minWidth')) {
                        this.minwidth = parseInt($.jqx.get(data, 'minWidth'));
                        if (isNaN(this.minwidth)) {
                            this.minwidth = 25;
                        }
                    }
                    if ($.jqx.hasProperty(data, 'maxWidth')) {
                        this.maxwidth = parseInt($.jqx.get(data, 'maxWidth'));
                        if (isNaN(this.maxwidth)) {
                            this.maxwidth = 'auto';
                        }
                    }
                    if ($.jqx.hasProperty(data, 'cellsRenderer')) {
                        this.cellsrenderer = $.jqx.get(data, 'cellsRenderer');
                    }
                    else if (data["cellsRenderer"]) {
                        this.cellsrenderer = data["cellsRenderer"];
                    }

                    if ($.jqx.hasProperty(data, 'columnType')) {
                        this.columntype = $.jqx.get(data, 'columnType');
                    }
                    if ($.jqx.hasProperty(data, 'checkChange')) {
                        this.checkchange = $.jqx.get(data, 'checkChange');
                    }
                    if ($.jqx.hasProperty(data, 'buttonClick')) {
                        this.buttonclick = $.jqx.get(data, 'buttonClick');
                    }
                    else if (data["buttonClick"]) {
                        this.buttonclick = data["buttonClick"];
                    }

                    if ($.jqx.hasProperty(data, 'pinned')) {
                        this.pinned = $.jqx.get(data, 'pinned');
                    }
                    if ($.jqx.hasProperty(data, 'visibleIndex')) {
                        this.visibleindex = $.jqx.get(data, 'visibleIndex');
                    }
                    if ($.jqx.hasProperty(data, 'filterable')) {
                        this.filterable = $.jqx.get(data, 'filterable');
                    }
                    if ($.jqx.hasProperty(data, 'filter')) {
                        this.filter = $.jqx.get(data, 'filter');
                    }
                    if ($.jqx.hasProperty(data, 'resizable')) {
                        this.resizable = $.jqx.get(data, 'resizable');
                    }
                    if ($.jqx.hasProperty(data, 'editable')) {
                        this.editable = $.jqx.get(data, 'editable');
                    }
                    if ($.jqx.hasProperty(data, 'initEditor')) {
                        this.initeditor = $.jqx.get(data, 'initEditor');
                    }
                    else if (data["initEditor"]) {
                        this.initeditor = data["initEditor"];
                    }
                    if ($.jqx.hasProperty(data, 'createEditor')) {
                        this.createeditor = $.jqx.get(data, 'createEditor');
                    }
                    else if (data["createEditor"]) {
                        this.createeditor = data["createEditor"];
                    }

                    if ($.jqx.hasProperty(data, 'initWidget')) {
                        this.initwidget = $.jqx.get(data, 'initWidget');
                    }
                    else if (data["initWidget"]) {
                        this.initwidget = data["initWidget"];
                    }
                    if ($.jqx.hasProperty(data, 'createWidget')) {
                        this.createwidget = $.jqx.get(data, 'createWidget');
                    }
                    else if (data["createWidget"]) {
                        this.createwidget = data["createWidget"];
                    }
                    if ($.jqx.hasProperty(data, 'destroyWidget')) {
                        this.destroywidget = $.jqx.get(data, 'destroyWidget');
                    }
                    else if (data["destroyWidget"]) {
                        this.destroywidget = data["destroyWidget"];
                    }

                    if ($.jqx.hasProperty(data, 'reseteverpresentrowwidgetvalue') || $.jqx.hasFunction(data, 'reseteverpresentrowwidgetvalue')) {
                        this.reseteverpresentrowwidgetvalue = $.jqx.get(data, 'reseteverpresentrowwidgetvalue');
                    }
                    else if (data["resetEverPresentRowWidgetValue"]) {
                        this.reseteverpresentrowwidgetvalue = data["resetEverPresentRowWidgetValue"];
                    }

                    if ($.jqx.hasProperty(data, 'geteverpresentrowwidgetvalue') || $.jqx.hasFunction(data, 'geteverpresentrowwidgetvalue')) {
                        this.geteverpresentrowwidgetvalue = $.jqx.get(data, 'geteverpresentrowwidgetvalue');
                    }
                    else if (data["getEverPresentRowWidgetValue"]) {
                        this.geteverpresentrowwidgetvalue = data["getEverPresentRowWidgetValue"];
                    }
                    if ($.jqx.hasProperty(data, 'createeverpresentrowwidget') || $.jqx.hasFunction(data, 'createeverpresentrowwidget')) {
                        this.createeverpresentrowwidget = $.jqx.get(data, 'createeverpresentrowwidget');
                    }
                    else if (data["createEverPresentRowWidget"]) {
                        this.createeverpresentrowwidget = data["createEverPresentRowWidget"];
                    }
                    if ($.jqx.hasProperty(data, 'initeverpresentrowwidget') || $.jqx.hasFunction(data, 'initeverpresentrowwidget')) {
                        this.initeverpresentrowwidget = $.jqx.get(data, 'initeverpresentrowwidget');
                    }
                    else if (data["initEverPresentRowWidget"]) {
                        this.initeverpresentrowwidget = data["initEverPresentRowWidget"];
                    }
                    if ($.jqx.hasProperty(data, 'validateeverpresentrowwidgetvalue')) {
                        this.validateeverpresentrowwidgetvalue = $.jqx.get(data, 'validateeverpresentrowwidgetvalue');
                    }
                    else if (data["validateEverPresentRowWidgetValue"]) {
                        this.validateeverpresentrowwidgetvalue = data["validateEverPresentRowWidgetValue"];
                    }
                    if ($.jqx.hasProperty(data, 'destroyeverpresentrowwidget') || $.jqx.hasFunction(data, 'destroyeverpresentrowwidget')) {
                        this.destroyeverpresentrowwidget = $.jqx.get(data, 'destroyeverpresentrowwidget');
                    }
                    else if (data["destroyEverPresentRowWidget"]) {
                        this.destroyEverPresentRowWidget = data["destroyEverPresentRowWidget"];
                    }
                    if ($.jqx.hasProperty(data, 'destroyEditor')) {
                        this.destroyeditor = $.jqx.get(data, 'destroyEditor');
                    }
                    else if (data["destroyEditor"]) {
                        this.destroyeditor = data["destroyEditor"];
                    }
                    if ($.jqx.hasProperty(data, 'getEditorValue')) {
                        this.geteditorvalue = $.jqx.get(data, 'getEditorValue');
                    }
                    else if (data["getEditorValue"]) {
                        this.geteditorvalue = data["getEditorValue"];
                    }
                    if ($.jqx.hasProperty(data, 'validation')) {
                        this.validation = $.jqx.get(data, 'validation');
                    }
                    else if (data["validation"]) {
                        this.validation = data["validation"];
                    }
                    if ($.jqx.hasProperty(data, 'cellBeginEdit')) {
                        this.cellbeginedit = $.jqx.get(data, 'cellBeginEdit');
                    }
                    else if (data["cellBeginEdit"]) {
                        this.cellbeginedit = data["cellBeginEdit"];
                    }
                    if ($.jqx.hasProperty(data, 'cellEndEdit')) {
                        this.cellendedit = $.jqx.get(data, 'cellEndEdit');
                    }
                    else if (data["cellEndEdit"]) {
                        this.cellendedit = data["cellEndEdit"];
                    }
                    if ($.jqx.hasProperty(data, 'className')) {
                        this.classname = $.jqx.get(data, 'className');
                    }
                    if ($.jqx.hasProperty(data, 'cellClassName')) {
                        this.cellclassname = $.jqx.get(data, 'cellClassName');
                    }
                    else if (data["cellClassName"]) {
                        this.cellclassname = data["cellClassName"];
                    }
                    if ($.jqx.hasProperty(data, 'menu')) {
                        this.menu = $.jqx.get(data, 'menu');
                    }
                    if ($.jqx.hasProperty(data, 'aggregates')) {
                        this.aggregates = $.jqx.get(data, 'aggregates');
                    }
                    if ($.jqx.hasProperty(data, 'aggregatesRenderer')) {
                        this.aggregatesrenderer = $.jqx.get(data, 'aggregatesRenderer');
                    }
                    if ($.jqx.hasProperty(data, 'createFilterWidget')) {
                        this.createfilterwidget = $.jqx.get(data, 'createFilterWidget');
                    }
                    if ($.jqx.hasProperty(data, 'filterType')) {
                        this.filtertype = $.jqx.get(data, 'filterType');
                    }
                    if ($.jqx.hasProperty(data, 'filterDelay')) {
                        this.filterdelay = $.jqx.get(data, 'filterDelay');
                    }
                    if ($.jqx.hasProperty(data, 'rendered')) {
                        this.rendered = $.jqx.get(data, 'rendered');
                    }
                    if ($.jqx.hasProperty(data, 'exportable')) {
                        this.exportable = $.jqx.get(data, 'exportable');
                    }
                    if ($.jqx.hasProperty(data, 'filterItems')) {
                        this.filteritems = $.jqx.get(data, 'filterItems');
                    }
                    if ($.jqx.hasProperty(data, 'cellValueChanging')) {
                        this.cellvaluechanging = $.jqx.get(data, 'cellValueChanging');
                    }
                    if ($.jqx.hasProperty(data, 'draggable')) {
                        this.draggable = $.jqx.get(data, 'draggable');
                    }
                    if ($.jqx.hasProperty(data, 'filterCondition')) {
                        this.filtercondition = $.jqx.get(data, 'filterCondition');
                    }
                    if ($.jqx.hasProperty(data, 'threeStateCheckbox')) {
                        this.threestatecheckbox = $.jqx.get(data, 'threeStateCheckbox');
                    }
                    if ($.jqx.hasProperty(data, 'nullable')) {
                        this.nullable = $.jqx.get(data, 'nullable');
                    }
                    if ($.jqx.hasProperty(data, 'columnGroup')) {
                        this.columngroup = $.jqx.get(data, 'columnGroup');
                    }
                    if ($.jqx.hasProperty(data, 'sparklines')) {
                        this.sparklines = $.jqx.get(data, 'sparklines');
                    }
                    if (!data instanceof String && !(typeof data == "string")) {
                        for (var obj in data) {
                            if (!me.hasOwnProperty(obj)) {
                                if (!me.hasOwnProperty(obj.toLowerCase())) {
                                    owner.host.remove();
                                    throw new Error("jqxGrid: Invalid property name - " + obj + ".");
                                }
                            }
                        }
                    }
                }
            }

            this._initfields(data);
            return this;
        }

        function jqxGridRow(owner, data) {
            this.setdata = function (data) {
                if (data != null) {
                    this.bounddata = data;
                    this.boundindex = data.boundindex;
                    this.visibleindex = data.visibleindex;
                    this.group = data.group;
                    this.parentbounddata = data.parentItem;
                    this.uniqueid = data.uniqueid;
                    this.level = data.level;
                }
            }
            this.setdata(data);
            this.parentrow = null;
            this.subrows = new Array();
            this.owner = owner;
            this.height = 25;
            this.hidden = false;
            this.rowdetails = null;
            this.rowdetailsheight = 100;
            this.rowdetailshidden = true;
            this.top = -1;

            //        this.getrowinfo = function () {
            //            return { hidden: this.hidden, rowdetails: this.rowdetails, rowdetailsheight: this.rowdetailsheight,
            //                showdetails: !this.rowdetailshidden, height: this.height, index: this.visibleindex
            //            };
            //        }

            this.setrowinfo = function (data) {
                this.hidden = data.hidden;
                this.rowdetails = data.rowdetails;
                this.rowdetailsheight = data.rowdetailsheight;
                this.rowdetailshidden = !data.showdetails;
                this.height = data.height;
            }

            return this;
        }

        $.jqx.collection = function (owner) {
            this.records = new Array();
            this.owner = owner;
            this.updating = false;
            this.beginupdate = function () {
                this.updating = true;
            }

            this.resumeupdate = function () {
                this.updating = false;
            }

            this._raiseEvent = function (args) {
            }

            this.clear = function () {
                this.records = new Array();
            }

            this.replace = function (index, object) {
                this.records[index] = object;
                if (!this.updating) {
                    this._raiseEvent({
                        type: 'replace', element: object
                    });
                }
            }

            this.isempty = function (index) {
                if (this.records[index] == undefined) {
                    return true;
                }

                return false;
            }

            this.initialize = function (size) {
                if (size < 1) size = 1;
                this.records[size - 1] = -1;
            }

            this.length = function () {
                return this.records.length;
            }

            this.indexOf = function (object) {
                return this.records.indexOf(object);
            }

            this.add = function (object) {
                if (object == null)
                    return false;

                this.records[this.records.length] = object;
                if (!this.updating) {
                    this._raiseEvent({
                        type: 'add', element: object
                    });
                }
                return true;
            }

            this.insertAt = function (index, object) {
                if (index == null || index == undefined)
                    return false;

                if (object == null)
                    return false;

                if (index >= 0) {
                    if (index < this.records.length) {
                        this.records.splice(index, 0, object);
                        if (!this.updating) {
                            this._raiseEvent({
                                type: 'insert', index: index, element: object
                            });
                        }
                        return true;
                    }
                    else return this.add(object);
                }

                return false;
            }

            this.remove = function (object) {
                if (object == null || object == undefined)
                    return false;

                var index = this.records.indexOf(object);
                if (index != -1) {
                    this.records.splice(index, 1);
                    if (!this.updating) {
                        this._raiseEvent({
                            type: 'remove', element: object
                        });
                    }
                    return true;
                }

                return false;
            }

            this.removeAt = function (index) {
                if (index == null || index == undefined)
                    return false;

                if (index < 0)
                    return false;

                if (index < this.records.length) {
                    var object = this.records[index];
                    this.records.splice(index, 1);
                    if (!this.updating) {
                        this._raiseEvent({
                            type: 'removeAt', index: index, element: object
                        });
                    }
                    return true;
                }

                return false;
            }

            return this;
        }

        $.jqx.dataview = function () {
            this.self = this;
            this.aggregates = false;
            this.grid = null;
            this.uniqueId = "id";
            this.records = [];
            this.rows = [];
            this.columns = [];
            this.groups = [];
            this.filters = new Array();
            this.updated = null;
            this.update = null;
            this.suspend = false;
            this.pagesize = 0;
            this.pagenum = 0;
            this.totalrows = 0;
            this.totalrecords = 0;
            this.groupable = true;
            this.loadedrecords = [];
            this.loadedrootgroups = [];
            this.loadedgroups = [];
            this.loadedgroupsByKey = [];
            this.virtualmode = true;
            this._cachegrouppages = new Array();
            this.source = null;
            this.changedrecords = new Array();
            this.rowschangecallback = null;
            this.that = this;

            this.destroy = function () {
                delete this.self;
                delete this.grid;
                delete this.uniqueId;
                delete this.records;
                delete this.rows;
                delete this.columns;
                delete this.groups;
                delete this.filters;
                delete this.updated;
                delete this.update;
                delete this.suspend;
                delete this.pagesize;
                delete this.pagenum;
                delete this.totalrows;
                delete this.totalrecords;
                delete this.groupable;
                delete this.loadedrecords;
                delete this.loadedrootgroups;
                delete this.loadedgroups;
                delete this.loadedgroupsByKey;
                delete this.virtualmode;
                delete this._cachegrouppages;
                delete this.source;
                delete this.changedrecords;
                delete this.rowschangecallback;
                delete this.that;
            },

                this.suspendupdate = function () {
                    this.suspend = true;
                },

                this.isupdating = function () {
                    return this.suspend;
                },

                this.resumeupdate = function (refresh) {
                    this.suspend = false;

                    if (refresh == undefined)
                        refresh = true;

                    this.refresh(refresh);
                },

                this.getrecords = function () {
                    return this.records;
                },

                this.clearrecords = function () {
                    this.recordids = new Array();
                }

            this.databind = function (source, objectuniqueId) {
                var isdataadapter = source._source ? true : false;
                var dataadapter = null;

                if (this.grid) {
                    this.aggregates = this.grid.showgroupaggregates;
                }

                if (isdataadapter) {
                    dataadapter = source;
                    source = source._source;
                }
                else {
                    dataadapter = new $.jqx.dataAdapter(source,
                        {
                            autoBind: false
                        });
                }

                var initadapter = function (me) {
                    dataadapter.recordids = [];
                    dataadapter.records = new Array();
                    dataadapter.cachedrecords = new Array();
                    dataadapter.originaldata = new Array();
                    dataadapter._options.virtualmode = me.virtualmode;
                    dataadapter._options.totalrecords = me.totalrecords;
                    dataadapter._options.originaldata = me.originaldata;
                    dataadapter._options.recordids = me.recordids;
                    dataadapter._options.cachedrecords = new Array();
                    dataadapter._options.pagenum = me.pagenum;
                    dataadapter._options.pageable = me.pageable;
                    if (source.type != undefined) {
                        dataadapter._options.type = source.type;
                    }
                    if (source.formatdata != undefined) {
                        dataadapter._options.formatData = source.formatdata;
                    }
                    if (source.contenttype != undefined) {
                        dataadapter._options.contentType = source.contenttype;
                    }
                    if (source.async != undefined) {
                        dataadapter._options.async = source.async;
                    }
                    if (source.updaterow != undefined) {
                        dataadapter._options.updaterow = source.updaterow;
                    }
                    if (source.addrow != undefined) {
                        dataadapter._options.addrow = source.addrow;
                    }
                    if (source.deleterow != undefined) {
                        dataadapter._options.deleterow = source.deleterow;
                    }

                    if (me.pagesize == 0) me.pagesize = 10;
                    dataadapter._options.pagesize = me.pagesize;
                }

                var updatefromadapter = function (me) {
                    me.totalrecords = dataadapter.totalrecords;
                    if (!me.virtualmode) {
                        me.originaldata = dataadapter.originaldata;
                        me.records = dataadapter.records;
                        me.recordids = dataadapter.recordids;
                        me.cachedrecords = dataadapter.cachedrecords;
                    }
                    else {
                        var rendergridrowsobj = {
                            startindex: me.pagenum * me.pagesize, endindex: (me.pagenum * me.pagesize + me.pagesize)
                        };
                        if (source.recordstartindex != undefined) {
                            rendergridrowsobj.startindex = parseInt(source.recordstartindex);
                        }
                        if (source.recordendindex != undefined) {
                            rendergridrowsobj.endindex = parseInt(source.recordendindex);
                        }
                        else if (!me.grid.pageable) {
                            rendergridrowsobj.endindex = rendergridrowsobj.startindex + 100;
                            if (me.grid.autoheight) {
                                rendergridrowsobj.endindex = rendergridrowsobj.startindex + me.totalrecords;
                            }
                        }
                        if (!source.recordendindex) {
                            if (!me.grid.pageable) {
                                rendergridrowsobj.endindex = rendergridrowsobj.startindex + 100;
                                if (me.grid.autoheight) {
                                    rendergridrowsobj.endindex = rendergridrowsobj.startindex + me.totalrecords;
                                }
                            }
                            else {
                                rendergridrowsobj = {
                                    startindex: me.pagenum * me.pagesize, endindex: (me.pagenum * me.pagesize + me.pagesize)
                                };
                            }
                        }

                        rendergridrowsobj.data = dataadapter.records;
                        if (me.grid.rendergridrows && me.totalrecords > 0) {
                            var recordscount = 0;
                            source.records = me.grid.rendergridrows(rendergridrowsobj);
                            if (source.records.length) {
                                recordscount = source.records.length;
                            }

                            if (source.records && !source.records[rendergridrowsobj.startindex]) {
                                var newArray = new Array();
                                var newArrayIndex = rendergridrowsobj.startindex;
                                $.each(source.records, function () {
                                    newArray[newArrayIndex] = this;
                                    newArrayIndex++;
                                    recordscount++;
                                });
                                source.records = newArray;
                            }
                            if (recordscount == 0) {
                                if (source.records) {
                                    $.each(source.records, function () {
                                        recordscount++;
                                    });
                                }
                            }
                            if (recordscount > 0 && recordscount < rendergridrowsobj.endindex - rendergridrowsobj.startindex && !me.grid.groupable) {
                                var toClone = source.records[0];

                                for (var i = 0; i < rendergridrowsobj.endindex - rendergridrowsobj.startindex - recordscount; i++) {
                                    var newData = {
                                    };
                                    for (var obj in toClone) {
                                        newData[obj] = "";
                                    }

                                    if (source.records.push) {
                                        source.records.push(newData);
                                    }
                                }
                            }
                        }

                        if (!source.records || me.totalrecords == 0) {
                            source.records = new Array();
                        }

                        me.originaldata = source.records;
                        me.records = source.records;
                        me.cachedrecords = source.records;
                    }
                }

                initadapter(this);

                this.source = source;
                if (objectuniqueId !== undefined) {
                    var uniqueId = objectuniqueId;
                }

                var me = this.that;
                //if (this.virtualmode && !this.pageable) {
                //    var rendergridrowsobj = { startindex: me.pagenum * me.pagesize, endindex: (me.pagenum * me.pagesize + me.pagesize) };
                //    if (dataadapter.records && dataadapter.records[rendergridrowsobj.startindex]) {
                //        updatefromadapter(this);
                //        return;
                //    }
                //}

                switch (source.datatype) {
                    case "local":
                    case "array":
                    default:
                        if (source.localdata == null) {
                            source.localdata = [];
                        }

                        if (source.localdata != null) {
                            dataadapter.unbindBindingUpdate(me.grid.element.id);
                            if ((!me.grid.autobind && me.grid.isInitialized) || me.grid.autobind) {
                                dataadapter.dataBind();
                            }
                            var updateFunc = function (changeType) {
                                if (changeType != undefined && changeType != "") {
                                    var dataItem = dataadapter._changedrecords[0];
                                    if (dataItem) {
                                        var ids = new Array();
                                        $.each(dataadapter._changedrecords, function (rowIndex) {
                                            var index = this.index;
                                            var item = this.record;

                                            me.grid._updateFromAdapter = true;
                                            switch (changeType) {
                                                case "update":
                                                    var id = me.grid.getrowid(index);
                                                    if (rowIndex == dataadapter._changedrecords.length - 1) {
                                                        me.grid.updaterow(id, item);
                                                    }
                                                    else {
                                                        me.grid.updaterow(id, item, false);
                                                    }

                                                    me.grid._updateFromAdapter = false;
                                                    return;
                                                case "add":
                                                    me.grid.addrow(null, item);
                                                    me.grid._updateFromAdapter = false;
                                                    return;
                                                case "remove":
                                                    var id = me.grid.getrowid(index);
                                                    ids.push(id);
                                                    return;
                                            }
                                        });
                                        if (ids.length > 0) {
                                            me.grid.deleterow(ids, false);
                                            me.grid._updateFromAdapter = false;
                                        }
                                    }
                                    if (changeType == "update") {
                                        return;
                                    }
                                }
                                var totalrecords = me.totalrecords;
                                updatefromadapter(me, changeType);

                                if (source.localdata.notifier === null && source.localdata.name == "observableArray") {
                                    source.localdata.notifier = function (changed) {
                                        if (me._updating)
                                            return;

                                        me._updating = true;
                                        var rowid = me.grid.getrowid(changed.index);
                                        switch (changed.type) {
                                            case "add":
                                                var record = $.extend({}, changed.object[changed.index]);
                                                var recordid = dataadapter.getid(source.id, record, changed.index);
                                                if (changed.index === 0) {
                                                    me.grid.addrow(recordid, record, 'first');
                                                }
                                                else {
                                                    me.grid.addrow(recordid, record);
                                                }
                                                break;
                                            case "delete":
                                                me.grid.deleterow(rowid);
                                                break;
                                            case "update":
                                                if (changed.path && changed.path.split(".").length > 1) {
                                                    var items = changed.path.split(".")
                                                    me.grid.setcellvalue(changed.index, items[items.length - 1], changed.newValue);
                                                }
                                                else {
                                                    var record = $.extend({}, changed.object[changed.index]);
                                                    me.grid.updaterow(rowid, record);
                                                }
                                                break;
                                        }
                                        me._updating = false;
                                    }
                                }
                                if (changeType == 'updateData') {
                                    me.refresh();
                                    me.grid._updateGridData();
                                }
                                else {
                                    if (source.recordstartindex && me.virtualmode) {
                                        me.updateview(source.recordstartindex, source.recordstartindex + me.pagesize);
                                    }
                                    else {
                                        me.refresh();
                                    }
                                    me.update(totalrecords != me.totalrecords);
                                }
                            }

                            updateFunc();
                            dataadapter.bindBindingUpdate(me.grid.element.id, updateFunc);
                        }
                        break;
                    case "json":
                    case "jsonp":
                    case "xml":
                    case "xhtml":
                    case "script":
                    case "text":
                    case "csv":
                    case "tab":
                        {
                            if (source.localdata != null) {
                                dataadapter.unbindBindingUpdate(me.grid.element.id);
                                if ((!me.grid.autobind && me.grid.isInitialized) || me.grid.autobind) {
                                    dataadapter.dataBind();
                                }
                                var updateFunc = function (changeType) {
                                    var totalrecords = me.totalrecords;
                                    updatefromadapter(me);

                                    if (changeType == 'updateData') {
                                        me.refresh();
                                        me.grid._updateGridData();
                                    }
                                    else {
                                        if (source.recordstartindex && me.virtualmode) {
                                            me.updateview(source.recordstartindex, source.recordstartindex + me.pagesize);
                                        }
                                        else {
                                            me.refresh();
                                        }

                                        me.update(totalrecords != me.totalrecords);
                                    }
                                }

                                updateFunc();
                                dataadapter.bindBindingUpdate(me.grid.element.id, updateFunc);
                                return;
                            }

                            var filterdata = {
                            };
                            var filtersObj = [];
                            var filterslength = 0;
                            var postdata = {
                            };
                            for (var x = 0; x < me.filters.length; x++) {
                                var filterdatafield = me.filters[x].datafield;
                                var filter = me.filters[x].filter;
                                if (!filter.getfilters)
                                    continue;

                                if (!filterdatafield) {
                                    for (var t = 0; t < me.grid.columns.length; t++) {
                                        if (me.grid.columns[t].filter === filter) {
                                            filterdatafield = me.grid.columns[t].datafield || me.grid.columns[t].dataField;
                                        }
                                    }
                                }

                                var filters = filter.getfilters();
                                postdata[filterdatafield + "operator"] = filter.operator;
                                for (var m = 0; m < filters.length; m++) {
                                    filters[m].datafield = filterdatafield;
                                    var filtervalue = filters[m].value;
                                    if (filters[m].type == "datefilter") {
                                        if (filters[m].value && filters[m].value.toLocaleString) {
                                            var column = me.grid.getcolumn(filters[m].datafield);
                                            if (column && column.cellsformat) {
                                                var value = me.grid.source.formatDate(filters[m].value, column.cellsformat, me.grid.gridlocalization);
                                                if (value) {
                                                    postdata["filtervalue" + filterslength] = value;
                                                }
                                                else {
                                                    postdata["filtervalue" + filterslength] = filters[m].value.toLocaleString();
                                                }
                                            }
                                            else {
                                                postdata["filtervalue" + filterslength] = filtervalue.toString();
                                            }
                                        }
                                        else {
                                            postdata["filtervalue" + filterslength] = filtervalue.toString();
                                        }
                                    }
                                    else {
                                        postdata["filtervalue" + filterslength] = filtervalue.toString();
                                        if (filters[m].data) {
                                            postdata["filterid" + filterslength] = filters[m].data.toString();
                                        }
                                        if (filters[m].id) {
                                            postdata["filterid" + filterslength] = filters[m].id.toString();
                                        }
                                    }
                                    postdata["filtercondition" + filterslength] = filters[m].condition;
                                    postdata["filteroperator" + filterslength] = filters[m].operator;
                                    postdata["filterdatafield" + filterslength] = filterdatafield;

                                    var o = {
                                        label: filtervalue.toString()
                                    };
                                    if (filters[m].data) {
                                        o.value = filters[m].data.toString();
                                    }
                                    if (filters[m].id) {
                                        o.value = filters[m].id.toString();
                                    }
                                    else o.value = filtervalue.toString();
                                    o.condition = filters[m].condition;
                                    o.operator = filters[m].operator == 0 ? "and" : "or";
                                    o.field = filterdatafield;
                                    o.type = filters[m].type;

                                    var foundObj = false;
                                    if (filtersObj.length > 0) {
                                        for (var q = 0; q < filtersObj.length; q++) {
                                            var currentObject = filtersObj[q];
                                            if (currentObject.field == filterdatafield) {
                                                currentObject.filters.push(o);
                                                foundObj = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (!foundObj) {
                                        filtersObj.push({
                                            field: filterdatafield, filters: []
                                        });
                                        filtersObj[filtersObj.length - 1].filters.push(o);
                                    }
                                    filterslength++;
                                }
                            }
                            postdata["filterGroups"] = filtersObj;
                            postdata.filterscount = filterslength;
                            postdata.groupscount = me.groups.length;
                            for (var x = 0; x < me.groups.length; x++) {
                                postdata["group" + x] = me.groups[x];
                            }

                            if (source.recordstartindex == undefined) source.recordstartindex = 0;
                            if (source.recordendindex == undefined || source.recordendindex == 0) {
                                if (me.grid.height && me.grid.height.toString().indexOf('%') == -1) {
                                    source.recordendindex = parseInt(me.grid.height) / me.grid.rowsheight;
                                    source.recordendindex += 2;
                                    source.recordendindex = parseInt(source.recordendindex);
                                }
                                else {
                                    source.recordendindex = $(window).height() / me.grid.rowsheight;
                                    source.recordendindex = parseInt(source.recordendindex);
                                }
                                if (me.pageable) {
                                    source.recordendindex = me.pagesize;
                                }
                            }
                            if (me.pageable) {
                                source.recordstartindex = (me.pagenum) * me.pagesize;
                                source.recordendindex = (me.pagenum + 1) * me.pagesize;
                            }

                            $.extend(postdata, {
                                sortdatafield: me.sortfield, sortorder: me.sortfielddirection, pagenum: me.pagenum, pagesize: me.grid.pagesize, recordstartindex: source.recordstartindex, recordendindex: source.recordendindex
                            });
                            var tmpdata = dataadapter._options.data;
                            if (dataadapter._options.data) {
                                $.extend(dataadapter._options.data, postdata);
                            }
                            else {
                                if (source.data) {
                                    $.extend(postdata, source.data);
                                }
                                dataadapter._options.data = postdata;
                            }

                            var updateFunc = function () {
                                var ie = $.jqx.browser.msie && $.jqx.browser.version < 9;
                                var doUpdate = function () {
                                    var totalrecords = me.totalrecords;
                                    updatefromadapter(me);

                                    if (source.recordstartindex && me.virtualmode) {
                                        me.updateview(source.recordstartindex, source.recordstartindex + me.pagesize);
                                    }
                                    else {
                                        me.refresh();
                                    }

                                    me.update(totalrecords != me.totalrecords);
                                }
                                if (ie) {
                                    try {
                                        doUpdate();
                                    }
                                    catch (error) {
                                    }
                                }
                                else {
                                    doUpdate();
                                }
                            }

                            dataadapter.unbindDownloadComplete(me.grid.element.id);
                            dataadapter.bindDownloadComplete(me.grid.element.id, updateFunc);
                            if ((!me.grid.autobind && me.grid.isInitialized) || me.grid.autobind) {
                                dataadapter.dataBind();
                            }
                            else if (!me.grid.isInitialized && !me.grid.autobind) {
                                updateFunc();
                            }

                            dataadapter._options.data = tmpdata;
                        }
                }
            }

            this.getid = function (id, record, index) {
                if ($(id, record).length > 0) {
                    return $(id, record).text();
                }

                if (id) {
                    if (id.toString().length > 0) {
                        var result = $(record).attr(id);
                        if (result != null && result.toString().length > 0) {
                            return result;
                        }
                    }
                }

                return index;
            }

            this.getvaluebytype = function (value, datafield) {
                var originalvalue = value;
                if (datafield.type == 'date') {
                    var tmpvalue = new Date(value);

                    if (tmpvalue.toString() == 'NaN' || tmpvalue.toString() == "Invalid Date") {
                        if ($.jqx.dataFormat) {
                            value = $.jqx.dataFormat.tryparsedate(value);
                        }
                        else value = tmpvalue;
                    }
                    else {
                        value = tmpvalue;
                    }

                    if (value == null) {
                        value = originalvalue;
                    }
                }
                else if (datafield.type == 'float') {
                    var value = parseFloat(value);
                    if (isNaN(value)) {
                        value = originalvalue;
                    }
                }
                else if (datafield.type == 'int') {
                    var value = parseInt(value);
                    if (isNaN(value)) {
                        value = originalvalue;
                    }
                }
                else if (datafield.type == 'bool') {
                    if (value != null) {
                        if (value.toLowerCase() == 'false') {
                            value = false;
                        }
                        else if (value.toLowerCase() == 'true') {
                            value = true;
                        }
                    }

                    if (value == 1) {
                        value = true;
                    }
                    else if (value == 0) {
                        value = false;
                    }
                    else value = '';
                }

                return value;
            }

            this.setpaging = function (args) {
                if (args.pageSize != undefined) {
                    this.pagesize = args.pageSize;
                }

                if (args.pageNum != undefined) {
                    this.pagenum = Math.min(args.pageNum, Math.ceil(this.totalrows / this.pagesize));
                }

                this.refresh();
            }

            this.getpagingdetails = function () {
                return {
                    pageSize: this.pagesize, pageNum: this.pagenum, totalrows: this.totalrows
                };
            }

            this._clearcaches = function () {
                this.sortcache = {
                };
                this.sortdata = null;
                this.changedrecords = new Array();
                this.records = new Array();
                this.rows = new Array();
                this.cacheddata = new Array();
                this.originaldata = new Array();
                this.bounditems = new Array();
                this.loadedrecords = new Array();
                this.loadedrootgroups = new Array();
                this.loadedgroups = new Array();
                this.loadedgroupsByKey = new Array();
                this._cachegrouppages = new Array();
                this.recordsbyid = new Array();
                this.cachedrecords = new Array();
                this.recordids = new Array();
            }

            this.addfilter = function (field, filter) {
                var filterindex = -1;
                for (var m = 0; m < this.filters.length; m++) {
                    if (this.filters[m].datafield == field) {
                        filterindex = m;
                        break;
                    }
                }

                if (filterindex == -1) {
                    this.filters[this.filters.length] = {
                        filter: filter, datafield: field
                    };
                }
                else {
                    this.filters[filterindex] = {
                        filter: filter, datafield: field
                    };
                }
            }

            this.removefilter = function (field) {
                for (var i = 0; i < this.filters.length; i++) {
                    if (this.filters[i].datafield == field) {
                        this.filters.splice(i, 1);
                        break;
                    }
                }
            }

            this.getItemFromIndex = function (i) {
                return this.records[i];
            }

            this.updaterow = function (rowid, rowdata, refresh) {
                var hasFilter = this.filters && this.filters.length > 0 && !this.virtualmode;

                if (!hasFilter && rowdata != undefined && rowid != undefined) {
                    rowdata.uid = rowid;
                    if (!(rowdata[this.source.id])) {
                        rowdata[this.source.id] = rowdata.uid;
                    }

                    var record = this.recordsbyid["id" + rowid];
                    var recordindex = this.records.indexOf(record);
                    if (recordindex == -1)
                        return false;

                    this.records[recordindex] = rowdata;
                    if (this.cachedrecords) {
                        this.cachedrecords[recordindex] = rowdata;
                    }
                    if (refresh == true || refresh == undefined) {
                        this.refresh();
                    }
                    this.changedrecords[rowdata.uid] = {
                        Type: "Update", OldData: record, Data: rowdata
                    };
                    return true;
                }
                else if (this.filters && this.filters.length > 0) {
                    var records = this.cachedrecords;
                    var record = null;
                    var recordindex = -1;
                    for (var i = 0; i < records.length; i++) {
                        if (records[i].uid == rowid) {
                            record = records[i];
                            recordindex = i;
                            break;
                        }
                    }
                    if (record) {
                        var me = this.that;
                        for (var obj in rowdata) {
                            me.cachedrecords[recordindex][obj] = rowdata[obj];
                        }
                        if (refresh == true || refresh == undefined) {
                            this.refresh();
                        }
                        return true;
                    }
                }

                return false;
            }

            this.addrow = function (rowid, rowdata, position, refresh) {
                if (rowdata != undefined) {
                    if ($.isEmptyObject(rowdata)) {
                        if (this.source && this.source.datafields) {
                            $.each(this.source.datafields, function () {
                                var val = "";
                                if (this.type == "number") val = null;
                                if (this.type == "date") val = null;
                                if (this.type == "bool" || this.type == "boolean") val = false;

                                rowdata[this.name] = val;
                            });
                        }
                    }

                    if (!rowid || this.recordsbyid["id" + rowid]) {
                        rowdata.uid = this.getid(this.source.id, rowdata, this.totalrecords);
                        var record = this.recordsbyid["id" + rowdata.uid];
                        while (record != null) {
                            var uid = Math.floor(Math.random() * 10000).toString();
                            rowdata.uid = uid;
                            record = this.recordsbyid["id" + uid];
                        }
                    }
                    else rowdata.uid = rowid;

                    if (!(rowdata[this.source.id])) {
                        if (this.source.id != undefined) {
                            rowdata[this.source.id] = rowdata.uid;
                        }
                    }

                    rowdata.boundindex = this.records.length;

                    if (position == 'last') {
                        this.records.push(rowdata);
                    }
                    else if (typeof position === 'number' && isFinite(position)) {
                        this.records.splice(position, 0, rowdata);
                    }
                    else {
                        this.records.splice(0, 0, rowdata);
                    }
                    if (this.filters && this.filters.length > 0) {
                        if (position == 'last') {
                            this.cachedrecords.push(rowdata);
                        }
                        else if (typeof position === 'number' && isFinite(position)) {
                            this.cachedrecords.splice(position, 0, rowdata);
                        }
                        else {
                            this.cachedrecords.splice(0, 0, rowdata);
                        }
                    }

                    this.totalrecords++;
                    if (this.virtualmode) {
                        this.source.totalrecords = this.totalrecords;
                    }
                    if (refresh == true || refresh == undefined) {
                        this.refresh();
                    }

                    this.changedrecords[rowdata.uid] = {
                        Type: "New", Data: rowdata
                    };
                    return true;
                }
                return false;
            }

            this.deleterow = function (rowid, refresh) {
                if (rowid != undefined) {
                    var hasFilter = this.filters && this.filters.length > 0;
                    if (this.recordsbyid["id" + rowid] && !hasFilter) {
                        var record = this.recordsbyid["id" + rowid];
                        var recordindex = this.records.indexOf(record);

                        if (this.grid && this.grid.sortable && this.grid.sortmode == "many") {
                            for (var i = 0; i < this.records.length; i++) {
                                if (this.records[i].boundindex === record.boundindex) {
                                    recordindex = i;
                                    break;
                                }
                            }
                        }

                        this.changedrecords[rowid] = {
                            Type: "Delete", Data: this.records[recordindex]
                        };
                        this.records.splice(recordindex, 1);
                        this.totalrecords--;
                        if (this.virtualmode) {
                            this.source.totalrecords = this.totalrecords;
                        }
                        if (refresh == true || refresh == undefined) {
                            this.refresh();
                        }
                        return true;
                    }
                    else if (this.filters && this.filters.length > 0) {
                        var records = this.cachedrecords;
                        var record = null;
                        var recordindex = -1;
                        for (var i = 0; i < records.length; i++) {
                            if (records[i].uid == rowid) {
                                record = records[i];
                                recordindex = i;
                                break;
                            }
                        }
                        if (record) {
                            this.cachedrecords.splice(recordindex, 1);
                            if (refresh == true || refresh == undefined) {
                                this.totalrecords = 0;
                                this.records = this.cachedrecords;
                                this.refresh();
                            }
                            return true;
                        }
                    }

                    return false;
                }

                return false;
            }

            this.reload = function (_records, _rows, _filter, _updated, fullupdate, startindex, endindex) {
                var self = this.that;
                var diff = new Array();
                var records = _records;
                var rows = _rows;
                var filter = _filter;
                var updated = _updated;

                var rl = rows.length;
                var currentRowIndex = 0;
                var currentPageIndex = 0;
                var item, id;
                this.columns = [];
                this.bounditems = new Array();
                this.loadedrecords = new Array();
                this.loadedrootgroups = new Array();
                this.loadedgroups = new Array();
                this.loadedgroupsByKey = new Array();
                this._cachegrouppages = new Array();
                this.recordsbyid = {
                };

                if (this.totalrecords == 0) {
                    Object.size = function (obj) {
                        var size = 0, key;
                        for (key in obj) {
                            if (obj.hasOwnProperty(key)) size++;
                        }
                        return size;
                    };

                    var totalrecords = Object.size(records);
                    this.totalrecords = totalrecords;

                    $.each(this.records, function (i) {
                        var item = this;
                        var index = 0;
                        $.each(item, function (columnName, value) {
                            self.columns[index++] = columnName;
                        });

                        return false;
                    });
                }

                if (this.virtualmode) {
                    if (this.pageable) {
                        this.updateview();
                        return;
                    }

                    var startindex = 0;
                    if (!this.groupable) {
                        this.updateview();
                        return;
                    }
                    else {
                        var endindex = this.totalrecords;
                    }
                }
                else {
                    var startindex = 0;
                    var endindex = this.totalrecords;
                }

                if (this.groupable && this.groups.length > 0 && this.loadgrouprecords) {
                    var visualRows = startindex;
                    visualRows = this.loadgrouprecords(0, startindex, endindex, filter, currentPageIndex, updated, rows, rl, diff);
                }
                else {
                    currentRowIndex = this.loadflatrecords(startindex, endindex, filter, currentPageIndex, updated, rows, rl, diff);
                }

                if (rl > currentPageIndex)
                    rows.splice(currentPageIndex, rl - currentPageIndex);


                if (this.groups.length > 0 && this.groupable) {
                    this.totalrows = visualRows;
                }
                else {
                    this.totalrows = currentRowIndex;
                }

                return diff;
            }

            this.loadflatrecords = function (startindex, endindex, filter, currentPageIndex, updated, rows, rl, diff) {
                var self = this.that;
                var i = startindex;
                var currentRowIndex = startindex;
                endindex = Math.min(endindex, this.totalrecords);

                var hassortdata = this.sortdata != null;
                var localdata = this.source.id && (this.source.datatype == 'local' || this.source.datatype == 'array' || this.source.datatype == '');

                var data = hassortdata ? this.sortdata : this.records;

                for (var obj = startindex; obj < endindex; obj++) {
                    var item = {
                    };
                    if (!hassortdata) {
                        item = new Object(data[obj]);
                        //item = $.extend({}, data[obj]);
                        var id = item[self.uniqueId];
                        item.boundindex = i;
                        self.loadedrecords[i] = item;

                        if (item.uid == undefined) {
                            item.uid = self.getid(self.source.id, item, i);
                        }
                        self.recordsbyid["id" + item.uid] = data[obj];
                        item.uniqueid = self.generatekey();
                        self.bounditems[this.bounditems.length] = item;
                    }
                    else {
                        item = $.extend({}, data[obj].value);
                        var id = item[self.uniqueId];
                        item.boundindex = data[obj].index;
                        if (item.uid == undefined) {
                            item.uid = self.getid(self.source.id, item, item.boundindex);
                        }
                        self.recordsbyid["id" + item.uid] = data[obj].value;
                        self.loadedrecords[i] = item;
                        item.uniqueid = self.generatekey();
                        self.bounditems[item.boundindex] = item;
                    }

                    if (currentPageIndex >= rl || id != rows[currentPageIndex][self.uniqueId] || (updated && updated[id]))
                        diff[diff.length] = currentPageIndex;

                    rows[currentPageIndex] = item;
                    currentPageIndex++;

                    item.visibleindex = currentRowIndex;
                    currentRowIndex++;
                    i++;
                }

                if (self.grid.summaryrows) {
                    var rowindex = i;
                    $.each(self.grid.summaryrows, function () {
                        var item = $.extend({}, this);
                        item.boundindex = endindex++;
                        self.loadedrecords[rowindex] = item;
                        item.uniqueid = self.generatekey();
                        self.bounditems[self.bounditems.length] = item;
                        rows[currentPageIndex] = item;
                        currentPageIndex++;
                        item.visibleindex = currentRowIndex;
                        currentRowIndex++;
                        rowindex++;
                    });
                }

                return currentRowIndex;
            },

                this.updateview = function (from, to) {
                    var self = this.that;
                    var currentRowIndex = this.pagesize * this.pagenum;
                    var currentPageIndex = 0;
                    var rows = new Array();
                    var filter = this.filters;
                    var updated = this.updated;
                    var rl = rows.length;

                    if (this.pageable) {
                        if (this.virtualmode) {
                            if (!this.groupable || this.groups.length == 0) {
                                this.loadflatrecords(this.pagesize * this.pagenum, this.pagesize * (1 + this.pagenum), filter, currentPageIndex, updated, rows, rl, []);
                                this.totalrows = rows.length;
                            }
                            else if (this.groupable && this.groups.length > 0 && this.loadgrouprecords) {
                                if (this._cachegrouppages[this.pagenum + '_' + this.pagesize] != undefined) {
                                    this.rows = this._cachegrouppages[this.pagenum + '_' + this.pagesize];
                                    this.totalrows = this.rows.length;
                                    return;
                                }

                                var endindex = this.pagesize * (1 + this.pagenum);
                                if (endindex > this.totalrecords) {
                                    endindex = this.totalrecords;
                                }

                                this.loadgrouprecords(0, this.pagesize * this.pagenum, endindex, filter, currentPageIndex, updated, rows, rl, []);
                                this._cachegrouppages[this.pagenum + '_' + this.pagesize] = this.rows;
                                this.totalrows = this.rows.length;
                                return;
                            }
                        }
                    }
                    else {
                        if (this.virtualmode && (!this.groupable || this.groups.length == 0)) {
                            var pagesize = this.pagesize;
                            if (pagesize == 0) {
                                pagesize = Math.min(100, this.totalrecords);
                            }
                            var start = pagesize * this.pagenum;
                            if (this.loadedrecords.length == 0) start = 0;

                            if (from != null && to != null) {
                                this.loadflatrecords(from, to, filter, currentPageIndex, updated, rows, rl, []);
                            }
                            else {
                                this.loadflatrecords(this.pagesize * this.pagenum, this.pagesize * (1 + this.pagenum), filter, currentPageIndex, updated, rows, rl, []);
                            }
                            this.totalrows = this.loadedrecords.length;
                            this.rows = rows;
                            if (rows.length >= pagesize) {
                                return;
                            }
                        }
                    }

                    if (this.groupable && this.pageable && this.groups.length > 0 && this._updategroupsinpage) {
                        rows = this._updategroupsinpage(self, filter, currentRowIndex, currentPageIndex, rl, this.pagesize * this.pagenum, this.pagesize * (1 + this.pagenum));
                    }
                    else {
                        for (var i = this.pagesize * this.pagenum; i < this.pagesize * (1 + this.pagenum); i++) {
                            var item = i < this.loadedrecords.length ? this.loadedrecords[i] : null;
                            if (item == null) continue;

                            if (!this.pagesize || (currentRowIndex >= this.pagesize * this.pagenum && currentRowIndex <= this.pagesize * (this.pagenum + 1))) {
                                rows[currentPageIndex] = item;
                                currentPageIndex++;
                            }

                            currentRowIndex++;
                        }
                    }

                    if ((rows.length == 0 || rows.length < this.pagesize) && !this.pageable && this.virtualmode) {
                        currentPageIndex = rows.length;
                        var startlength = rows.length;
                        for (var i = this.pagesize * this.pagenum; i < this.pagesize * (1 + this.pagenum) - startlength; i++) {
                            var item = {
                            };
                            item.boundindex = i + startlength;
                            item.visibleindex = i + startlength;
                            item.uniqueid = self.generatekey();
                            item.empty = true;
                            self.bounditems[i + startlength] = item;
                            rows[currentPageIndex] = item;
                            currentPageIndex++;
                        }
                    }

                    this.rows = rows;
                }

            this.generatekey = function () {
                var S4 = function () {
                    return (((1 + Math.random()) * 0x10) | 0);
                };
                return ("" + S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
            }

            this.reloaddata = function () {
                this.reload(this.records, this.rows, this.filter, this.updated, true);
            }

            this.refresh = function (fullupdate) {
                if (this.suspend) return;

                if (fullupdate == undefined) {
                    fullupdate = true;
                }

                var countBefore = this.rows.length;
                var totalrowsBefore = this.totalrows;

                if (this.filters.length > 0 && !this.virtualmode) {
                    var filter = "";
                    var length = this.cachedrecords.length;
                    var filtereddata = new Array();
                    this.totalrecords = 0;
                    var data = this.cachedrecords;
                    this._dataIndexToBoundIndex = new Array();
                    var filterslength = this.filters.length;

                    if (this.source != null && this.source.filter != undefined && this.source.localdata != undefined) {
                        var filtered = this.source.filter(this.filters, data, length);
                        if (filtered == undefined) {
                            filtered = new Array();
                        }

                        for (var row = 0; row < length; row++) {
                            var datarow = data[row];

                            var filterresult = filtered.indexOf(datarow) >= 0;

                            if (filterresult) {
                                filtereddata[filtereddata.length] = $.extend({ dataindex: row }, datarow);
                                this._dataIndexToBoundIndex[row] = {
                                    boundindex: filtereddata.length - 1
                                };
                            }
                            else this._dataIndexToBoundIndex[row] = null;
                        }

                        this.records = filtereddata;
                    }
                    else if (this.source.filter == null || this.source.filter == undefined) {
                        for (var row = 0; row < length; row++) {
                            var datarow = data[row];
                            var filterresult = undefined;
                            for (var j = 0; j < filterslength; j++) {
                                var filter = this.filters[j].filter;
                                var value = datarow[this.filters[j].datafield];
                                var result = filter && filter.evaluate ? filter.evaluate(value) : true;

                                if (this.grid.filter) {
                                    var gridFilterResult = this.grid.filter(value, datarow, this.filters[j].datafield, filter, result);
                                    if (gridFilterResult !== undefined) {
                                        result = gridFilterResult;
                                    }
                                }


                                if (filterresult == undefined) filterresult = result;
                                else {
                                    if (filter.operator == 'or') {
                                        filterresult = filterresult || result;
                                    }
                                    else {
                                        filterresult = filterresult && result;
                                    }
                                }
                            }

                            if (filterresult) {
                                filtereddata[filtereddata.length] = $.extend({ dataindex: row }, datarow);
                                this._dataIndexToBoundIndex[row] = {
                                    boundindex: filtereddata.length - 1
                                };
                            }
                            else this._dataIndexToBoundIndex[row] = null;
                        }
                        this.records = filtereddata;
                    }
                    if (this.sortdata) {
                        if (this.grid && this.grid.sortmode !== "many") {
                            var lookupkey = this.sortfield;
                            if (this.sortcache[lookupkey]) {
                                this.sortdata = null;
                                var direction = this.sortcache[lookupkey].direction;
                                this.sortcache[lookupkey] = null;
                                this.sortby(this.sortfield, direction);
                                return;
                            }
                        }
                        else {
                            var columns = this.grid.getsortcolumns();

                            for (var i = 0; i < columns.length; i++) {
                                var sortColumn = columns[i];
                                var dataField = sortColumn.dataField;

                                this.grid.sortby(dataField, sortColumn.ascending, null);
                            }
                            return;
                        }
                    }
                }
                else if (this.filters.length == 0 && !this.virtualmode) {
                    if (this.cachedrecords) {
                        this.totalrecords = 0;
                        var data = this.cachedrecords;
                        this.records = data;
                        if (this.sortdata) {
                            if (this.grid && this.grid.sortmode !== "many") {
                                var lookupkey = this.sortfield;
                                if (this.sortcache[lookupkey]) {
                                    this.sortdata = null;
                                    var direction = this.sortcache[lookupkey].direction;
                                    this.sortcache[lookupkey] = null;
                                    this.sortby(this.sortfield, direction);
                                    return;
                                }
                            }
                            else {
                                var columns = this.grid.getsortcolumns();

                                for (var i = 0; i < columns.length; i++) {
                                    var sortColumn = columns[i];
                                    var dataField = sortColumn.dataField;

                                    this.grid.sortby(dataField, sortColumn.ascending, null);
                                }

                                return;
                            }
                        }
                    }
                }

                var diff = this.reload(this.records, this.rows, this.filter, this.updated, fullupdate);
                this.updated = null;

                if (this.rowschangecallback != null) {
                    var rows = this.rows;
                    if (totalrowsBefore != this.totalrows) this.rowschangecallback({
                        type: "PagingChanged", data: this.getpagingdetails()
                    });
                    if (countBefore != rows.length) this.rowschangecallback({
                        type: "RowsCountChanged", data: { previous: countBefore, current: rows.length }
                    });
                    if (diff.length > 0 || countBefore != rows.length) {
                        this.rowschangecallback({
                            type: "RowsChanged", data: { previous: countBefore, current: rows.length, diff: diff }
                        });
                    }
                }
            }

            return this;
        }
    })(jqxBaseFramework);
})();



/***/ }),

/***/ 5911:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {
    $.extend($.jqx._jqxGrid.prototype, {
        _initpager: function () {
            var me = this.that;
            var pagergotopagestring = this.gridlocalization.pagergotopagestring;
            var pagerrangestring = this.gridlocalization.pagerrangestring;
            var pagershowrowsstring = this.gridlocalization.pagershowrowsstring;

            var top = (this.pagerheight - 28) / 2;

            this.pagerdiv = this.pagerdiv || $('<div style="line-height: 26px; width: 100%; height: 100%; position: relative;"></div>');
            if (!this.pageable) {
                this.pagerdiv.remove();
                this.vScrollBar.jqxScrollBar({ thumbSize: 0 });
                return;
            }

			if (this.pagermode === 'material') {
				var element = function() {
			        var element = $("<div style='margin-top: 5px; width: 100%; height: 100%;'></div>");
					var style = document.createElement('style');
					style.innerHTML = '.jqx-center{text-align:center}.jqx-pagination{display:inline-block}.jqx-pagination span{float:left;text-decoration:none;transition:background-color .3s;border-style:solid;border-width:1px;margin:0 4px;border-radius:100%;width:38px;height:38px;display:flex;justify-content:center;align-content:center;align-items:center;cursor:pointer}';
					element[0].appendChild(style);
					var datainfo =  me.getdatainformation();
					var paginginfo = datainfo.paginginformation;
					var template = document.querySelector("#pager");
					var pager = document.createElement('div');
					
					pager.classList.add('jqx-center');
					
					var pagerItems = '<span></span>';
					
					for(var i = 0; i < paginginfo.pagesize; i++){
						pagerItems += '<span>' + paginginfo.pagenum + i + 1 + '</span>';
					}
					
					pagerItems += '<span></span>';
					
					pager.innerHTML = '<div class="jqx-pagination">' + pagerItems + '</div>';
					
					element[0].appendChild(pager);
					
					var pages = pager.querySelectorAll('span');
					var theme = me.theme;
							
					var refreshState = function(page, action, state) {
						page.classList.add('jqx-grid-column-header');
					
						if (state === 'hover') {
							page.classList[action]('jqx-fill-state-hover');
						}
						
						if (theme) {
							page.classList.add('jqx-grid-column-header-' + theme);
						
							if (state === 'hover') {
								page.classList[action]('jqx-fill-state-hover-' + theme);
							}							
						}
						
						if (state === 'pressed') {
							page.classList[action]('active');
							page.classList[action]('jqx-grid-cell-selected');
							
							if (theme) {
								page.classList[action]('jqx-grid-cell-selected' + '-' + theme);
							}
						}
					}
						
					for(var i = 0; i < pages.length; i++) {
						var page = pages[i];
						
						if (i > 0 && i < pages.length - 1) {
							page.innerHTML = paginginfo.pagenum + i;
							page.setAttribute('data-page', i);
						}
						else {
							if (i === 0) {
								page.setAttribute('data-page', 'prev');
							}
							if (i === pages.length - 1) {
								page.setAttribute('data-page', 'next');
							}
						}
						
						if (i === paginginfo.pagenum+1) {
							refreshState(page, 'add', 'pressed');		
						}
						
						refreshState(page, 'add', 'normal');		
						
						page.onmouseenter = function() {
							refreshState(this, 'add', 'hover');			
						}
						
						page.onmouseleave = function() {
							refreshState(this, 'remove', 'hover');			
						}
						
						page.onpointerdown = function() { 
							refreshState(this, 'add', 'pressed');				
						}
						
						page.onclick = function() {
							for(var j = 0; j < pages.length; j++) {
								refreshState(pages[j], 'remove', 'pressed');				
							}
								
							var pagenum = this.getAttribute('data-page')
							var datainfo =  me.getdatainformation();
							var paginginfo = datainfo.paginginformation;
																		
							if (pagenum === 'prev' && paginginfo.pagenum > 0) {
								me.gotoprevpage();
							}
							else if (pagenum === 'next' && paginginfo.pagenum < paginginfo.pagescount - 1) {
								me.gotonextpage();
							}
							else if (pagenum !== 'prev' && pagenum !== 'next') {
								pagenum = parseInt(pagenum);	
								me.gotopage(pagenum - 1);
							}
							
							var updatePagingNumbers = false;
							var pageIndex = null;
							
							datainfo = me.getdatainformation();
							paginginfo = datainfo.paginginformation;
							
							for(var i = 0; i < pages.length; i++) {
								var page = pages[i];
								var pagenum = parseInt(page.getAttribute('data-page'));
							
								if (pagenum === paginginfo.pagenum + 1) {
									refreshState(page, 'add', 'pressed');				
								}
													
								var startPageNum = parseInt(pages[1].getAttribute('data-page')) - 1;
								var range = [startPageNum, startPageNum + paginginfo.pagesize];
								
								if ((paginginfo.pagenum < range[0]) || (paginginfo.pagenum >= range[1])) {
									if (i > 0 && i < pages.length - 1) {
										if (!pageIndex) {
											pageIndex = Math.max(1, paginginfo.pagenum - paginginfo.pagesize + i + 1);
										}
										else {
											pageIndex++;
										}
										
										page.innerHTML = pageIndex;
										updatePagingNumbers = true;
									}
								}
							}
							
							if (updatePagingNumbers) {
								for(var i = 1; i < pages.length - 1; i++) {
									var page = pages[i];
									var newPageNumber = parseInt(page.innerHTML);
								
									if (newPageNumber === paginginfo.pagenum + 1) {
										refreshState(page, 'add', 'pressed');				
									}
									
									page.setAttribute('data-page', newPageNumber);		
								}
							}
							
							return false;
						}
					}
					
					return element;
				}();
				
			    this.pagerdiv.children().remove();
				this.pagerdiv.append($(element));
                this.pager.append(this.pagerdiv);
			}
			else {
				if (!this.pagerrenderer) {
					this.pagerdiv.css('top', top);
					this.pager.append(this.pagerdiv);
					this.pagergotoinput = this.pagergotoinput || $('<div style="margin-right: 12px; height: 28px; float: right;"><input style="height:100%; box-sizing: border-box; text-align: right; width: 36px;" type="text"/></div>');
					this.pagergoto = this.pagergoto || $('<div style="float: right; margin-right: 7px;"></div>');
					this.pagerrightbutton = this.pagerrightbutton || $('<div type="button" style="padding: 0px; margin-right: 3px; height:26px; width: 26px; float: right;"></div>');
					this.pagerleftbutton = this.pagerleftbutton || $('<div type="button" style="padding: 0px; margin-right: 3px; height:26px; width: 26px; float: right;"></div>');
					this.pagerdetails = this.pagerdetails || $('<div style="margin-right: 7px; float: right;"></div>');
					this.pagershowrows = this.pagershowrows || $('<div style="margin-right: 7px; float: right;"></div>');
					this.pagerbuttons = $('<div style="margin-right: 3px; float: right;"></div>');
					if (this.pagershowrowscombo && this.pagershowrowscombo.jqxDropDownList) {
						this.pagershowrowscombo.remove();
						this.pagershowrowscombo = null;
					}

					this.pagergotoinput.attr('disabled', this.disabled);
					this.pagerfirstbutton = $('<div type="button" style="padding: 0px; margin-left: 3px; margin-right: 3px; width: 26px; float: right;"></div>');
					this.pagerlastbutton = $('<div type="button" style="padding: 0px; margin-right: 3px; width: 26px; float: right;"></div>');

					this.pagershowrowscombo = this.pagershowrowscombo || $('<div id="gridpagerlist" style="margin-right: 7px; float: right;"></div>');
					this.pagerdiv.children().remove();
					this.pagershowrowscombo[0].id = "gridpagerlist" + this.element.id;
					this.removeHandler(this.pagerrightbutton, 'mousedown');
					this.removeHandler(this.pagerrightbutton, 'mouseup');
					this.removeHandler(this.pagerrightbutton, 'click');
					this.removeHandler(this.pagerleftbutton, 'mousedown');
					this.removeHandler(this.pagerleftbutton, 'mouseup');
					this.removeHandler(this.pagerleftbutton, 'click');
					this.removeHandler(this.pagerfirstbutton, 'mousedown');
					this.removeHandler(this.pagerfirstbutton, 'mouseup');
					this.removeHandler(this.pagerfirstbutton, 'click');
					this.removeHandler(this.pagerlastbutton, 'mousedown');
					this.removeHandler(this.pagerlastbutton, 'mouseup');
					this.removeHandler(this.pagerlastbutton, 'click');

					this.pagerleftbutton.attr('title', this.gridlocalization.pagerpreviousbuttonstring);
					this.pagerrightbutton.attr('title', this.gridlocalization.pagernextbuttonstring);

					if (this.pagermode == "simple") {
						if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
							this.pagerbuttons.css('overflow', 'visible');
							this.pagerbuttons.css('padding', '3px');
						}

						this.pagerfirstbutton.attr('title', this.gridlocalization.pagerfirstbuttonstring);
						this.pagerlastbutton.attr('title', this.gridlocalization.pagerlastbuttonstring);
						var firstarrow = $("<div style='margin-left: 6px; width: 15px; height: 26px;'></div>");
						firstarrow.addClass(this.toThemeProperty('jqx-icon-arrow-first'));
						this.pagerfirstbutton.wrapInner(firstarrow);

						var lastarrow = $("<div style='margin-left: 6px; width: 15px; height: 26px;'></div>");
						lastarrow.addClass(this.toThemeProperty('jqx-icon-arrow-last'));
						this.pagerlastbutton.wrapInner(lastarrow);
						if (!this.rtl) {
							this.pagerdiv.append(this.pagerfirstbutton);
							this.pagerdiv.append(this.pagerleftbutton);
							this.pagerdiv.append(this.pagerbuttons);
							this.pagerdiv.append(this.pagerrightbutton);
							this.pagerdiv.append(this.pagerlastbutton);
						}
						else {
							this.pagerdiv.append(this.pagerlastbutton);
							this.pagerdiv.append(this.pagerrightbutton);
							this.pagerdiv.append(this.pagerbuttons);
							this.pagerdiv.append(this.pagerleftbutton);
							this.pagerdiv.append(this.pagerfirstbutton);
						}
						this.pagerlastbutton.jqxButton({ cursor: 'pointer', disabled: this.disabled, theme: this.theme });
						this.pagerfirstbutton.jqxButton({ cursor: 'pointer', disabled: this.disabled, theme: this.theme });
						var floatMode = !this.rtl ? 'left' : 'right';
						this.pagerbuttons.css('float', floatMode);
						this.pagerlastbutton.css('float', floatMode);
						this.pagerfirstbutton.css('float', floatMode);
						this.pagerrightbutton.css('float', floatMode);
						this.pagerleftbutton.css('float', floatMode);

						this.pagerdetails.css('float', this.rtl ? 'left' : 'right');
						if (this.rtl) {
							this.pagerdetails.css('margin-left', '7px');
							this.pagerdetails.css('margin-right', '0px');
						}
						else {
							this.pagerdetails.css('margin-left', '0px');
							this.pagerdetails.css('margin-right', '7px');
						}

						this.pagergotoinput.hide();
						this.pagershowrowscombo.hide();
						this.pagergoto.hide();
						this.pagershowrows.hide();
					}
					else {
						this.pagergotoinput.show();
						this.pagershowrowscombo.show();
						this.pagergoto.show();
						this.pagershowrows.show();
						if (!this.rtl) {
							this.pagerdiv.append(this.pagerrightbutton);
							this.pagerdiv.append(this.pagerleftbutton);
						}
					}

					this.pagerrightbutton.jqxButton({ cursor: 'pointer', disabled: this.disabled, theme: this.theme });
					this.pagerleftbutton.jqxButton({ cursor: 'pointer', disabled: this.disabled, theme: this.theme });

					this.pagerleftbutton.find('.jqx-icon-arrow-left').remove();
					this.pagerrightbutton.find('.jqx-icon-arrow-right').remove();

					var leftarrow = $("<div style='margin-left: 6px; width: 15px; height: 26px;'></div>");
					leftarrow.addClass(this.toThemeProperty('jqx-icon-arrow-left'));
					this.pagerleftbutton.wrapInner(leftarrow);

					var rightarrow = $("<div style='margin-left: 6px; width: 15px; height: 26px;'></div>");
					rightarrow.addClass(this.toThemeProperty('jqx-icon-arrow-right'));
					this.pagerrightbutton.wrapInner(rightarrow);

					this.pagerdiv.append(this.pagerdetails);
					if (this.pagermode != "simple") {
						if (!this.rtl) {
							this.pagerdiv.append(this.pagershowrowscombo);
							this.pagerdiv.append(this.pagershowrows);
							this.pagerdiv.append(this.pagergotoinput);
							this.pagerdiv.append(this.pagergoto);
						}
						else {
							this.pagerdiv.append(this.pagergoto);
							this.pagerdiv.append(this.pagergotoinput);
							this.pagerdiv.append(this.pagershowrows);
							this.pagerdiv.append(this.pagershowrowscombo);
							this.pagerdiv.append(this.pagerdetails);
							this.pagerdiv.append(this.pagerrightbutton);
							this.pagerdiv.append(this.pagerleftbutton);

						}
					}

					var source = this.pagesizeoptions;
					if (!this.pagershowrowscombo.jqxDropDownList) {
						throw new Error('jqxGrid: jqxdropdownlist.js is not loaded.');
						return;
					}

					this.pagershowrowscombo.jqxDropDownList({rtl: this.rtl, disabled: this.disabled, source: source, enableBrowserBoundsDetection: true, keyboardSelection: false, autoDropDownHeight: true, width: 'auto', height: 28, theme: this.theme });
					var selectedindex = 0;
					for (var i = 0; i < source.length; i++) {
						if (this.pagesize >= source[i]) {
							selectedindex = i;
						}
					}
					this.pagershowrows[0].innerHTML = pagershowrowsstring;
					this.pagergoto[0].innerHTML = pagergotopagestring;
					this.updatepagerdetails();
					this.pagershowrowscombo.jqxDropDownList({ selectedIndex: selectedindex });
					this.pagerpageinput = this.pagergotoinput.find('input');
					this.pagerpageinput.addClass(this.toThemeProperty('jqx-input'));
					this.pagerpageinput.addClass(this.toThemeProperty('jqx-widget-content'));
					if (this.rtl) {
						this.pagerpageinput.css('direction', 'rtl');
					}

					var tabindex = 6 + (this.columns.records ? this.columns.records.length : this.columns.length);
					this.pagerpageinput.attr('tabindex', tabindex++);
					this.pagershowrowscombo.attr('tabindex', tabindex++);
					this.pagerleftbutton.attr('tabindex', tabindex++);
					this.pagerrightbutton.attr('tabindex', tabindex++);

					var me = this.that;
					this.removeHandler(this.pagershowrowscombo, 'select');
					this.addHandler(this.pagershowrowscombo, 'select', function (event) {
						if (event.args) {
							if (me.vScrollInstance) {
								me.vScrollInstance.setPosition(0);
							}

							if (me.editcell != null && me.endcelledit) {
								me.endcelledit(me.editcell.row, me.editcell.column, true, false);
							}

							var index = event.args.index;
							var recordindex = me.dataview.pagenum * me.dataview.pagesize;
							var pagesize = source[index];
							var oldpagesize = me.pagesize;
							me.pagesize = parseInt(pagesize);
							if (isNaN(me.pagesize)) {
								me.pagesize = 10;
							}
					   

							me.dataview.pagesize = me.pagesize;
							var pagenum = Math.floor(recordindex / me.dataview.pagesize);
							me.prerenderrequired = true;
							me._requiresupdate = true;
							me._raiseEvent(10, { pagenum: pagenum, oldpagesize: oldpagesize, pagesize: me.dataview.pagesize });
							me.gotopage(pagenum);
							if (me.autoheight && me._updatesizeonwindowresize) {
								me._updatesize(true);
								setTimeout(function () {
									me._updatesize(true);
								}, 500);
							}
							setTimeout(function () {
								me.pagershowrowscombo.focus();
							}, 25);
						}
					});

					var input = this.pagergotoinput.find('input');
					input.addClass(this.toThemeProperty('jqx-grid-pager-input'));
					input.addClass(this.toThemeProperty('jqx-rc-all'));
					this.removeHandler(input, 'keydown');
					this.removeHandler(input, 'change');
			
					this.addHandler(input, 'keydown', function (event) {
						if (event.keyCode >= 65 && event.keyCode <= 90)
							return false;

						if (event.keyCode == '13') {
							var val = input.val();
							val = parseInt(val);
							if (!isNaN(val)) {
								me.gotopage(val - 1);
								setTimeout(function () {
									input.focus();
								}, 25);
							}
							return false;
						}
					});
					this.addHandler(input, 'change', function () {
						var val = input.val();
						val = parseInt(val);
						if (!isNaN(val)) {
							me.gotopage(val - 1);
							setTimeout(function () {
								input.focus();
							}, 25);
						}
					});

					this.addHandler(this.pagerrightbutton, 'mouseenter', function () {
						rightarrow.addClass(me.toThemeProperty('jqx-icon-arrow-right-hover'));
					});

					this.addHandler(this.pagerleftbutton, 'mouseenter', function () {
						leftarrow.addClass(me.toThemeProperty('jqx-icon-arrow-left-hover'));
					});

					this.addHandler(this.pagerrightbutton, 'mouseleave', function () {
						rightarrow.removeClass(me.toThemeProperty('jqx-icon-arrow-right-hover'));
					});

					this.addHandler(this.pagerleftbutton, 'mouseleave', function () {
						leftarrow.removeClass(me.toThemeProperty('jqx-icon-arrow-left-hover'));
					});

					this.addHandler(this.pagerrightbutton, 'mousedown', function () {
						rightarrow.addClass(me.toThemeProperty('jqx-icon-arrow-right-selected'));
					});

					this.addHandler(this.pagerrightbutton, 'mouseup', function () {
						rightarrow.removeClass(me.toThemeProperty('jqx-icon-arrow-right-selected'));
					});

					this.addHandler(this.pagerleftbutton, 'mousedown', function () {
						leftarrow.addClass(me.toThemeProperty('jqx-icon-arrow-left-selected'));
					});

					this.addHandler(this.pagerleftbutton, 'mouseup', function () {
						leftarrow.removeClass(me.toThemeProperty('jqx-icon-arrow-left-selected'));
					});

					this.addHandler($(document), 'mouseup.pagerbuttons' + this.element.id, function () {
						rightarrow.removeClass(me.toThemeProperty('jqx-icon-arrow-right-selected'));
						leftarrow.removeClass(me.toThemeProperty('jqx-icon-arrow-left-selected'));
					});

					this.addHandler(this.pagerrightbutton, 'click', function () {
						if (!me.pagerrightbutton.jqxButton('disabled')) {
							if (!me.rtl) {
								me.gotonextpage();
							}
							else {
								me.gotoprevpage();
							}
						}
					});
					this.addHandler(this.pagerleftbutton, 'click', function () {
						if (!me.pagerleftbutton.jqxButton('disabled')) {
							if (!me.rtl) {
								me.gotoprevpage();
							}
							else {
								me.gotonextpage();
							}
						}
					});
					this.addHandler(this.pagerrightbutton, 'keydown', function (event) {
						if (event.keyCode !== 13) {
							return;
						}

						if (!me.pagerrightbutton.jqxButton('disabled')) {
							if (!me.rtl) {
								me.gotonextpage();
							}
							else {
								me.gotoprevpage();
							}
							setTimeout(function () {
								me.pagerrightbutton.focus();
							},25);
						}
					});
					this.addHandler(this.pagerleftbutton, 'keydown', function (event) {
						if (event.keyCode !== 13) {
							return;
						}

						if (!me.pagerleftbutton.jqxButton('disabled')) {
							if (!me.rtl) {
								me.gotoprevpage();
							}
							else {
								me.gotonextpage();
							}
							setTimeout(function () {
								me.pagerleftbutton.focus();
							},25);
						}
					});

					var that = this;
					if (this.pagermode === "simple") {
						var first = this.pagerfirstbutton;
						var last = this.pagerlastbutton;

						this.addHandler(last, 'mouseenter', function () {
							lastarrow.addClass(that.toThemeProperty('jqx-icon-arrow-last-hover'));
						});

						this.addHandler(first, 'mouseenter', function () {
							firstarrow.addClass(that.toThemeProperty('jqx-icon-arrow-first-hover'));
						});

						this.addHandler(last, 'mouseleave', function () {
							lastarrow.removeClass(that.toThemeProperty('jqx-icon-arrow-last-hover'));
						});

						this.addHandler(first, 'mouseleave', function () {
							firstarrow.removeClass(that.toThemeProperty('jqx-icon-arrow-first-hover'));
						});

						this.addHandler(last, 'mousedown', function () {
							lastarrow.addClass(that.toThemeProperty('jqx-icon-arrow-last-selected'));
						});

						this.addHandler(first, 'mousedown', function () {
							firstarrow.addClass(that.toThemeProperty('jqx-icon-arrow-first-selected'));
						});

						this.addHandler(last, 'mouseup', function () {
							lastarrow.removeClass(that.toThemeProperty('jqx-icon-arrow-last-selected'));
						});

						this.addHandler(first, 'mouseup', function () {
							firstarrow.removeClass(that.toThemeProperty('jqx-icon-arrow-first-selected'));
						});
						this.addHandler($(document), 'mouseup.pagerbuttons' + name + this.element.id, function () {
							rightarrow.removeClass(that.toThemeProperty('jqx-icon-arrow-right-selected'));
							leftarrow.removeClass(that.toThemeProperty('jqx-icon-arrow-left-selected'));
							if (lastarrow) {
								lastarrow.removeClass(that.toThemeProperty('jqx-icon-arrow-last-selected'));
								firstarrow.removeClass(that.toThemeProperty('jqx-icon-arrow-first-selected'));
							}
						});
						this.addHandler(first, 'click', function () {
							if (!first.jqxButton('disabled')) {
								if (!that.rtl) {
									that.gotopage(0);
								}
								else {
									var totalrecords = that.dataview.totalrecords;
									var pages = Math.ceil(totalrecords / that.pagesize);
									that.gotopage(pages - 1);
								}
							}
						});
						this.addHandler(last, 'click', function () {
							if (!last.jqxButton('disabled')) {
								if (!that.rtl) {
									var totalrecords = that.dataview.totalrecords;
									var pages = Math.ceil(totalrecords / that.pagesize);
									that.gotopage(pages - 1);
								}
								else {
									that.gotopage(0);
								}
							}
						});
					}
				}
				else {
					this.pagerdiv.children().remove();
					var element = this.pagerrenderer();
					if (element != null) {
						this.pagerdiv.append($(element));
					}
					this.pager.append(this.pagerdiv);
				}
			}

        //    this.vScrollBar.jqxScrollBar({ thumbSize: this.host.height() / 5 });
            this.vScrollBar.jqxScrollBar('refresh');
            this._arrange();
        },

        _updatepagertheme: function () {
            if (this.pagershowrowscombo == null)
                return;

            this.pagershowrowscombo.jqxDropDownList({ theme: this.theme });
            this.pagerrightbutton.jqxButton({ theme: this.theme });
            this.pagerleftbutton.jqxButton({ theme: this.theme });

            this.pagerpageinput.removeClass();

            var input = this.pagergotoinput.find('input');
            input.removeClass();
            input.addClass(this.toThemeProperty('jqx-grid-pager-input'));
            input.addClass(this.toThemeProperty('jqx-rc-all'));
            this.pagerpageinput.addClass(this.toThemeProperty('jqx-input'));
            this.pagerpageinput.addClass(this.toThemeProperty('jqx-widget-content'));

            this.pagerleftbutton.find('.jqx-icon-arrow-left').remove();
            this.pagerrightbutton.find('.jqx-icon-arrow-right').remove();

            var leftarrow = $("<div style='margin-left: 6px; width: 15px; height: 15px;'></div>");
            leftarrow.addClass(this.toThemeProperty('jqx-icon-arrow-left'));
            this.pagerleftbutton.wrapInner(leftarrow);

            var rightarrow = $("<div style='margin-left: 6px; width: 15px; height: 15px;'></div>");
            rightarrow.addClass(this.toThemeProperty('jqx-icon-arrow-right'));
            this.pagerrightbutton.wrapInner(rightarrow);

            if (this.pagermode == "simple") {
                if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                    this.pagerbuttons.css('overflow', 'visible');
                    this.pagerbuttons.css('padding', '3px');
                }

                this.pagerfirstbutton.attr('title', this.gridlocalization.pagerfirstbuttonstring);
                this.pagerlastbutton.attr('title', this.gridlocalization.pagerlastbuttonstring);
                var firstarrow = $("<div style='margin-left: 6px; width: 15px; height: 15px;'></div>");
                firstarrow.addClass(this.toThemeProperty('jqx-icon-arrow-first'));
                this.pagerfirstbutton.wrapInner(firstarrow);

                var lastarrow = $("<div style='margin-left: 6px; width: 15px; height: 15px;'></div>");
                lastarrow.addClass(this.toThemeProperty('jqx-icon-arrow-last'));
                this.pagerlastbutton.wrapInner(lastarrow);
                this.pagerdiv.append(this.pagerfirstbutton);
                this.pagerdiv.append(this.pagerleftbutton);
                this.pagerdiv.append(this.pagerbuttons);
                this.pagerdiv.append(this.pagerrightbutton);
                this.pagerdiv.append(this.pagerlastbutton);
                this.pagerlastbutton.jqxButton({ cursor: 'pointer', disabled: this.disabled, theme: this.theme });
                this.pagerfirstbutton.jqxButton({ cursor: 'pointer', disabled: this.disabled, theme: this.theme });
                this.pagerbuttons.css('float', 'left');
                this.pagerlastbutton.css('float', 'left');
                this.pagerfirstbutton.css('float', 'left');
                this.pagerrightbutton.css('float', 'left');
                this.pagerleftbutton.css('float', 'left');
                this.pagergotoinput.hide();
                this.pagershowrowscombo.hide();
                this.pagergoto.hide();
                this.pagershowrows.hide();
            }
            else {
                this.pagergotoinput.show();
                this.pagershowrowscombo.show();
                this.pagergoto.show();
                this.pagershowrows.show();
            }

            var removeHandlers = function (me, button) {
                me.removeHandler(button, 'mouseenter');
                me.removeHandler(button, 'mouseleave');
                me.removeHandler(button, 'mousedown');
                me.removeHandler(button, 'mouseup');
            }
            removeHandlers(this, this.pagerrightbutton);
            removeHandlers(this, this.pagerleftbutton);
            var me = this.that;
            this.addHandler(this.pagerrightbutton, 'mouseenter', function () {
                rightarrow.addClass(me.toThemeProperty('jqx-icon-arrow-right-hover'));
            });

            this.addHandler(this.pagerleftbutton, 'mouseenter', function () {
                leftarrow.addClass(me.toThemeProperty('jqx-icon-arrow-left-hover'));
            });

            this.addHandler(this.pagerrightbutton, 'mouseleave', function () {
                rightarrow.removeClass(me.toThemeProperty('jqx-icon-arrow-right-hover'));
            });

            this.addHandler(this.pagerleftbutton, 'mouseleave', function () {
                leftarrow.removeClass(me.toThemeProperty('jqx-icon-arrow-left-hover'));
            });

            this.addHandler(this.pagerrightbutton, 'mousedown', function () {
                rightarrow.addClass(me.toThemeProperty('jqx-icon-arrow-right-selected'));
            });

            this.addHandler(this.pagerrightbutton, 'mouseup', function () {
                rightarrow.removeClass(me.toThemeProperty('jqx-icon-arrow-right-selected'));
            });

            this.addHandler(this.pagerleftbutton, 'mousedown', function () {
                leftarrow.addClass(me.toThemeProperty('jqx-icon-arrow-left-selected'));
            });

            this.addHandler(this.pagerleftbutton, 'mouseup', function () {
                leftarrow.removeClass(me.toThemeProperty('jqx-icon-arrow-left-selected'));
            });
        },

        gotopage: function (pagenum) {
            if (pagenum == null || pagenum == undefined)
                pagenum = 0;

            if (pagenum == -1)
                pagenum = 0;

            if (pagenum < 0)
                return;

            var totalrecords = this.dataview.totalrecords;
            if (this.summaryrows) {
                totalrecords += this.summaryrows.length;
            }

            var oldpagenum = this.pagenum;
            this._raiseEvent(25, { oldpagenum: this.dataview.pagenum, pagenum: pagenum, pagesize: this.dataview.pagesize });

            var pages = Math.ceil(totalrecords / this.pagesize);
            if (pagenum >= pages) {
                if (this.dataview.totalrecords == 0) {
                    this.dataview.pagenum = 0;
                    this.updatepagerdetails();
                }
                if (pagenum > 0) {
                    pagenum = pages - 1;
                }
                if (pagenum < 0)
                    pagenum = 0;
            }

            if (this.dataview.pagenum != pagenum || this._requiresupdate) {
                if (this.pageable) {
                    if (this.source.pager) {
                        this.source.pager(pagenum, this.dataview.pagesize, this.dataview.pagenum);
                    }

                    this.dataview.pagenum = pagenum;

                    if (this.virtualmode) {
                        this.hiddens = new Array();
                        this.expandedgroups = new Array();
                        if (this.rendergridrows) {
                            var startboundindex = pagenum * this.dataview.pagesize;
                            var endboundindex = startboundindex + this.dataview.pagesize;
                            if (startboundindex != null && endboundindex != null) {
                                if (this.pagerrightbutton) {
                                    this.pagerrightbutton.jqxButton({ disabled: true });
                                    this.pagerleftbutton.jqxButton({ disabled: true });
                                    this.pagershowrowscombo.jqxDropDownList({ disabled: true });
                                }
                                if (this.pagerfirstbutton) {
                                    this.pagerfirstbutton.jqxButton({ disabled: true });
                                    this.pagerlastbutton.jqxButton({ disabled: true });
                                }

                                this.updatebounddata('pagechanged');
                                this._raiseEvent(9, { pagenum: pagenum, oldpagenum: oldpagenum, pagesize: this.dataview.pagesize });
                                this.updatepagerdetails();
                                if (this.autosavestate) {
                                    if (this.savestate) this.savestate();
                                }
                                return;
                            }
                        }
                    }
                    else this.dataview.updateview();

                    this._loadrows();

                    this._updatepageviews();
                    this.tableheight = null;
                    this._updatecolumnwidths();
                    this._updatecellwidths();
                    this._renderrows(this.virtualsizeinfo);
                    this.updatepagerdetails();
                    if (this.autoheight || this.autorowheight) {
                        var newheight = this.host.height() - this._gettableheight();
                        var height = newheight + this._pageviews[0].height;
                        if (height != this.host.height()) {
                            this._arrange();
                            this._updatepageviews();
                            if (this.autorowheight) {
                                this._renderrows(this.virtualsizeinfo);
                            }
                        }
                    }

                    if (this.editcell != null && this.endcelledit) {
                        this.endcelledit(this.editcell.row, this.editcell.column, false, false);
                    }
                    this.focus();
                    this._raiseEvent(9, { pagenum: pagenum, oldpagenum: oldpagenum, pagesize: this.dataview.pagesize });
                    if (this.autosavestate) {
                        if (this.savestate) this.savestate();
                    }
                }
            }
        },

        // goes to a previous page.
        gotoprevpage: function () {
            if (this.dataview.pagenum > 0) {
                this.gotopage(this.dataview.pagenum - 1);
            }
            else {
                if (this.pagermode != "simple") {
                    var totalrecords = this.dataview.totalrecords;
                    if (this.summaryrows) {
                        totalrecords += this.summaryrows.length;
                    }
                    var pages = Math.ceil(totalrecords / this.pagesize);
                    this.gotopage(pages - 1);
                }
            }
        },

        // goes to a next page.
        gotonextpage: function () {
            var totalrecords = this.dataview.totalrecords;
            if (this.summaryrows) {
                totalrecords += this.summaryrows.length;
            }
            var pages = Math.ceil(totalrecords / this.pagesize);
            if (this.dataview.pagenum < pages - 1) {
                this.gotopage(this.dataview.pagenum + 1);
            }
            else {
                if (this.pagermode != "simple") {
                    this.gotopage(0);
                }
            }
        },

        // updates a pager details.
        updatepagerdetails: function () {
            if (this.pagerdetails != null && this.pagerdetails.length > 0) {
                var currentrecord = this.dataview.pagenum * this.pagesize;
                var lastrecord = (this.dataview.pagenum + 1) * this.pagesize;
                if (lastrecord >= this.dataview.totalrecords) {
                    lastrecord = this.dataview.totalrecords;
                }
                var totalrecords = this.dataview.totalrecords;
                if (this.summaryrows) {
                    totalrecords += this.summaryrows.length;
                    if ((this.dataview.pagenum + 1) * this.pagesize > this.dataview.totalrecords)
                    { lastrecord = totalrecords; }
                }

                currentrecord++;
                var pagescount = Math.ceil(totalrecords / this.dataview.pagesize);
                if (pagescount >= 1) pagescount--;
                pagescount++;

                if (this.pagermode !== 'simple') {
                    var input = this.pagergotoinput.find('input');
                    input.val(this.dataview.pagenum + 1);
                }
                else {
                    var anchors = "";
                    var buttonsCount = this.pagerbuttonscount;
                    if (buttonsCount == 0 || !buttonsCount) {
                        buttonsCount = 5;
                    }

                    var i = 0;
                    if (this.rtl) {
                        i = buttonsCount - 1;
                    }
                    while ((this.rtl && i >= 0) || (!this.rtl && i < buttonsCount)) {
                        var page = 1 + i;

                        var division = this.dataview.pagenum / buttonsCount;
                        var step = Math.floor(division);
                        page += step * buttonsCount;
                        var className = this.toTP('jqx-grid-pager-number');
                        className += " " + this.toTP('jqx-rc-all');
                        if (page > pagescount)
                            break;

                        if (!this.rtl) {
                            if (i == 0 && page > buttonsCount) {
                                anchors += "<a class='" + className + "' tabindex=-1 href='javascript:;' data-page='" + (-1 + page) + "'>" + "..." + "</a>";
                            }
                        }

                        if (this.dataview.pagenum === page - 1) {
                            className += " " + this.toTP('jqx-fill-state-pressed');
                        }

                        if (!this.rtl) {
                            anchors += "<a class='" + className + "' tabindex=-1 href='javascript:;' data-page='" + page + "'>" + page + "</a>";

                            if (i === buttonsCount - 1) {
                                var className = this.toTP('jqx-grid-pager-number');
                                className += " " + this.toTP('jqx-rc-all');
                                if (pagescount >= 1 + page) {
                                    anchors += "<a class='" + className + "' tabindex=-1 href='javascript:;' data-page='" + (1 + page) + "'>" + "..." + "</a>";
                                }
                            }
                        }
                        else {
                            if (i === buttonsCount - 1) {
                                var className = this.toTP('jqx-grid-pager-number');
                                className += " " + this.toTP('jqx-rc-all');
                                if (pagescount >= 1 + page) {
                                    anchors += "<a class='" + className + "' tabindex=-1 href='javascript:;' data-page='" + (1 + page) + "'>" + "..." + "</a>";
                                }
                            }
                            if (this.dataview.pagenum === page - 1) {
                                className += " " + this.toTP('jqx-fill-state-pressed');
                            }
                            anchors += "<a class='" + className + "' tabindex=-1 href='javascript:;' data-page='" + page + "'>" + page + "</a>";
                        }

                        if (this.rtl) {
                            var className = this.toTP('jqx-grid-pager-number');
                            className += " " + this.toTP('jqx-rc-all');
                            if (i == 0 && page > buttonsCount) {
                                anchors += "<a class='" + className + "' tabindex=-1 href='javascript:;' data-page='" + (-1 + page) + "'>" + "..." + "</a>";
                            }
                        }

                        if (!this.rtl) {
                            i++;
                        }
                        else {
                            i--;
                        }
                    }
                    var numbers = this["pagerbuttons"].find('a');
                    this.removeHandler(numbers, 'click');
                    this.removeHandler(numbers, 'mouseenter');
                    this.removeHandler(numbers, 'mouseleave');

                    this["pagerbuttons"][0].innerHTML = anchors;
                    var that = this;
                    var initAnchors = function () {
                        that.addHandler(numbers, 'click', function (event) {
                            var page = $(event.target).attr("data-page");
                            that.gotopage(parseInt(page) - 1);
                            return false;
                        });
                        that.addHandler(numbers, 'mouseenter', function (event) {
                            $(event.target).addClass(that.toTP("jqx-fill-state-hover"));
                        });
                        that.addHandler(numbers, 'mouseleave', function (event) {
                            $(event.target).removeClass(that.toTP("jqx-fill-state-hover"));
                        });
                    }

                    var numbers = this["pagerbuttons"].find('a');
                    initAnchors(numbers);
                }
              
                this.pagergotoinput.attr('title', '1 - ' + pagescount);
                if (lastrecord == 0 && lastrecord < currentrecord) {
                    currentrecord = 0;
                }

                if (!this.rtl) {
                    this.pagerdetails[0].innerHTML = currentrecord + '-' + lastrecord + this.gridlocalization.pagerrangestring + totalrecords;
                }
                else {
                    this.pagerdetails[0].innerHTML = totalrecords + this.gridlocalization.pagerrangestring + lastrecord + '-' + currentrecord;
                }

                if (currentrecord > lastrecord) {
                    this.gotoprevpage();
                }
            }
        },

        _updatepagedview: function (totalrows, virtualheight, currentheight) {
            var self = this.that;
            if (this.dataview.rows.length != this.dataview.pagesize) {
                this.dataview.updateview();
            }

            var rowslength = this.dataview.rows.length;
            for (var i = 0; i < rowslength; i++) {
                var index = this.dataview.rows[i].visibleindex;
                var rowinfo = { index: index, height: this.heights[index], hidden: this.hiddens[index], details: this.details[index] }
                if (this.heights[index] == undefined) {
                    this.heights[index] = this.rowsheight;
                    rowinfo.height = this.rowsheight;
                }
                if (this.hiddens[index] == undefined) {
                    this.hiddens[index] = false;
                    rowinfo.hidden = false;
                }
                if (this.details[index] == undefined) {
                    this.details[index] = null;
                }
                if (rowinfo.height != self.rowsheight) {
                    virtualheight -= self.rowsheight;
                    virtualheight += rowinfo.height;
                }

                if (rowinfo.hidden) {
                    virtualheight -= rowinfo.height;
                }
                else {
                    currentheight += rowinfo.height;
                    var detailsheight = 0;
                    if (this.rowdetails) {
                        if (rowinfo.details && rowinfo.details.rowdetails && !rowinfo.details.rowdetailshidden) {
                            detailsheight = rowinfo.details.rowdetailsheight;
                            currentheight += detailsheight;
                            virtualheight += detailsheight;
                        }
                    }
                }
            }
            this._pageviews[0] = { top: 0, height: currentheight };
            return virtualheight;
        }
    });
})(jqxBaseFramework);
})();



/***/ }),

/***/ 9041:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function () {
    if (typeof document === 'undefined') {
        return;
    }

    (function ($) {

        $.extend($.jqx._jqxGrid.prototype, {
            // select all rows.
            selectallrows: function () {
                this._trigger = false;
                var length = this.virtualmode ? this.dataview.totalrecords : this.dataview.loadedrecords.length;
                this.selectedrowindexes = new Array();
                this.selectedcells = new Array();

                var rows = this.dataview.loadedrecords;

                for (var i = 0; i < length; i++) {
                    var row = rows[i];
                    if (!row) {
                        this.selectedrowindexes[i] = i;
                        continue;
                    }

                    var boundindex = this.getboundindex(row);
                    if (boundindex != undefined) {
                        this.selectedrowindexes[i] = boundindex;
                    }

                    for (var j = 0; j < this.columns.records.length; j++) {
                        this.selectedcells[boundindex + "_" + this.columns.records[j].datafield] = true;
                    }
                }
                if (this.selectionmode == "checkbox" && !this._checkboxcolumnupdating) {
                    if (this._checkboxcolumn) {
                        this._checkboxcolumn.checkboxelement.jqxCheckBox({ checked: true });
                    }
                }
                this._renderrows(this.virtualsizeinfo);
                this._trigger = true;
                if (this.selectionmode == "checkbox") {
                    this._raiseEvent(2, { rowindex: this.selectedrowindexes });
                }
            },

            unselectallrows: function () {
                this._trigger = false;
                var length = this.virtualmode ? this.dataview.totalrecords : this.dataview.loadedrecords.length;

                if (this.dataview.filters.length > 0 && this.selectionmode == "checkbox" && !this.virtualmode) {
                    var rows = this.getrows();
                    for (var i = 0; i < rows.length; i++) {
                        var row = rows[i];
                        if (!row) {
                            delete this.selectedrowindexes[i];
                            continue;
                        }

                        var boundindex = this.getboundindex(row);
                        if (boundindex != undefined) {
                            delete this.selectedrowindexes[boundindex];
                        }

                        for (var j = 0; j < this.columns.records.length; j++) {
                            delete this.selectedcells[boundindex + "_" + this.columns.records[j].datafield];
                        }
                    }
                }
                else {
                    this.selectedrowindexes = new Array();
                    this.selectedcells = new Array();
                }

                if (this.selectionmode == "checkbox" && !this._checkboxcolumnupdating) {
                    if (this._checkboxcolumn) {
                        this._checkboxcolumn.checkboxelement.jqxCheckBox({ checked: false });
                    }
                }
                this._renderrows(this.virtualsizeinfo);
                this._trigger = true;
                if (this.selectionmode == "checkbox") {
                    this._raiseEvent(2, { rowindex: this.selectedrowindexes });
                }
            },

            // selects a row by index.
            selectrow: function (index, refresh) {
                if (this.selectionmode !== 'none') {
                    this._applyrowselection(index, true, refresh);
                    if (refresh !== false) {
                        this._updatecheckboxselection();
                    }
                }
            },

            _updatecheckboxselection: function () {
                if (this.selectionmode == "checkbox") {
                    var rows = this.getrows();
                    if (rows && this._checkboxcolumn) {
                        if (rows.length === 0) {
                            this._checkboxcolumn.checkboxelement.jqxCheckBox({ checked: false });
                            return;
                        }
                        var length = rows.length;
                        if (this.groupable) {
                            length = this.dataview.loadedrecords.length;
                        }
                        if (this.virtualmode) length = this.source._source.totalrecords;

                        var checkedItemsCount = this.selectedrowindexes.length;
                        if (checkedItemsCount === length) {
                            this._checkboxcolumn.checkboxelement.jqxCheckBox({ checked: true });
                        }
                        else if (checkedItemsCount === 0) {
                            this._checkboxcolumn.checkboxelement.jqxCheckBox({ checked: false });
                        }
                        else this._checkboxcolumn.checkboxelement.jqxCheckBox({ checked: null });
                    }
                }
            },

            // unselects a row by index.
            unselectrow: function (index, refresh) {
                this._applyrowselection(index, false, refresh);
                if (refresh !== false) {
                    this._updatecheckboxselection();
                }
            },

            // selects a cell.
            selectcell: function (row, datafield) {
                this._applycellselection(row, datafield, true);
            },

            // unselects a cell.
            unselectcell: function (row, datafield) {
                this._applycellselection(row, datafield, false);
            },

            // clears the selection.
            clearselection: function (refresh, raiseEvent) {
                this._trigger = false;
                this.selectedrowindex = -1;
                this._oldselectedcell = null;
                if (raiseEvent !== false) {
                    for (var i = 0; i < this.selectedrowindexes.length; i++) {
                        this._raiseEvent(3, { rowindex: this.selectedrowindexes[i] });
                    }
                }

                this.selectedrowindexes = new Array();
                this.selectedcells = new Array();
                this.selectedcell = null;
                if (this.selectionmode == "checkbox" && !this._checkboxcolumnupdating) {
                    this._checkboxcolumn.checkboxelement.jqxCheckBox({ checked: false });
                }

                for (var i = 0; i < this.columns.records.length; i++) {
                    this.columns.records[i].selected = false;
                    this.columns.records[i]._applyStyle();
                }

                if (false === refresh) {
                    this._trigger = true;
                    return;
                }

                this._renderrows(this.virtualsizeinfo);
                this._trigger = true;
                if (this.selectionmode == "checkbox") {
                    this._raiseEvent(3, { rowindex: this.selectedrowindexes });
                }
            },

            // gets the selected row index.
            getselectedrowindex: function () {
                if (this.selectedrowindex == -1 || this.selectedrowindex == undefined) {
                    for (var i = 0; i < this.selectedrowindexes.length; i++) {
                        return this.selectedrowindexes[i];
                    }
                }

                return this.selectedrowindex;
            },

            // gets the selected row index.
            getselectedrowindexes: function () {
                return this.selectedrowindexes;
            },

            // gets the selected cell.
            getselectedcell: function () {
                if (!this.selectedcell) {
                    return null;
                }

                var cell = this.selectedcell;
                cell.row = this.selectedcell.rowindex;
                cell.column = this.selectedcell.datafield;
                cell.value = this.getcellvalue(cell.row, cell.column);
                return cell;
            },

            // gets the selected cells.
            getselectedcells: function () {
                var cells = new Array();
                for (var obj in this.selectedcells) {
                    cells[cells.length] = this.selectedcells[obj];
                }

                return cells;
            },

            getselection: function () {
                return {
                    cells: this.getselectedcells(),
                    rows: this.getselectedrowindexes()
                }
            },

            _getcellsforcopypaste: function () {
                var cells = new Array();
                if (this.selectionmode.indexOf('cell') == -1) {
                    var rows = this.selectedrowindexes;
                    for (var j = 0; j < rows.length; j++) {
                        var index = rows[j];
                        for (var i = 0; i < this.columns.records.length; i++) {
                            if (this.columns.records[i].datafield === "_checkboxcolumn")
                                continue;

                            var uniquekey = index + "_" + this.columns.records[i].datafield;
                            var cell = { rowindex: index, datafield: this.columns.records[i].datafield };
                            cells.push(cell);
                        }
                    }
                }
                return cells;
            },

            deleteselection: function () {
                var self = this;
                var cells = self.getselectedcells();
                if (this.selectionmode.indexOf('cell') == -1) {
                    cells = this._getcellsforcopypaste();
                }
                if (cells != null && cells.length > 0) {
                    for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                        var cell = cells[cellIndex];
                        var column = self.getcolumn(cell.datafield);
                        var cellValue = self.getcellvalue(cell.rowindex, cell.datafield);
                        if (!column) continue;

                        if (cellValue !== "") {
                            var newvalue = null;
                            if (column.columntype == "checkbox") {
                                if (!column.threestatecheckbox) {
                                    newvalue = false;
                                }
                            }
                            self._raiseEvent(17, { rowindex: cell.rowindex, datafield: cell.datafield, value: cellValue });
                            if (cellIndex == cells.length - 1) {
                                self.setcellvalue(cell.rowindex, cell.datafield, newvalue, true);
                                if (column.displayfield != column.datafield) {
                                    self.setcellvalue(cell.rowindex, column.displayfield, newvalue, true);
                                }
                            }
                            else {
                                self.setcellvalue(cell.rowindex, cell.datafield, newvalue, false);
                                if (column.displayfield != column.datafield) {
                                    self.setcellvalue(cell.rowindex, column.displayfield, newvalue, true);
                                }
                            }
                            self._raiseEvent(18, { rowindex: cell.rowindex, datafield: cell.datafield, oldvalue: cellValue, value: newvalue });
                        }
                    }
                    this.dataview.updateview();
                    this._renderrows(this.virtualsizeinfo);
                }
            },

            copyselection: function () {
                var selectedtext = "";
                var self = this;
                this.clipboardselection = {};
                this.logicalclipboardselection = {};
                this._clipboardselection = [];
                var cells = self.getselectedcells();
                if (this.selectionmode.indexOf('cell') == -1) {
                    cells = this._getcellsforcopypaste();
                }


                var logicalRowIndex = 0;
                var columns = new Array();
                if (cells != null && cells.length > 0) {
                    var minrowindex = 999999999999999;
                    var maxrowindex = -1;
                    for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                        var cell = cells[cellIndex];
                        var column = self.getcolumn(cell.datafield);
                        if (column != null && column.clipboard && (!column.hidden || this.copytoclipboardhiddencolumns)) {
                            if (columns.indexOf(column.text) == -1) {
                                columns.push(column.text);
                            }

                            var cellValue = self.getcelltext(cell.rowindex, column.displayfield);
                            var displayindex = this.getrowdisplayindex(cell.rowindex);
                            if (!this.clipboardselection[displayindex]) this.clipboardselection[displayindex] = {};
                            this.clipboardselection[displayindex][column.displayfield] = cellValue;

                            if (!this.logicalclipboardselection[displayindex]) this.logicalclipboardselection[displayindex] = {};
                            this.logicalclipboardselection[displayindex][column.displayfield] = cellValue;
                            if (column.displayfield != column.datafield) {
                                this.logicalclipboardselection[displayindex][column.datafield] = self.getcellvalue(cell.rowindex, column.datafield);;
                            }
                            minrowindex = Math.min(minrowindex, displayindex);
                            maxrowindex = Math.max(maxrowindex, displayindex);
                        }
                    }
                    var arr = new Array();
                    for (var i = minrowindex; i <= maxrowindex; i++) {
                        if (!this.logicalclipboardselection[i])
                            continue;

                        var item = $.extend({}, this.logicalclipboardselection[i]);
                        arr.push(item);
                    }

                    this.logicalclipboardselection = arr;
                    if (this.copytoclipboardwithheaders) {
                        for (var m = 0; m < columns.length; m++) {
                            if (m > 0) selectedtext += "\t";
                            selectedtext += columns[m];
                        }
                        selectedtext += '\r\n';
                    }

                    for (var i = minrowindex; i <= maxrowindex; i++) {
                        var x = 0;
                        this._clipboardselection[this._clipboardselection.length] = new Array();
                        if (this.clipboardselection[i] != undefined) {
                            $.each(this.clipboardselection[i], function (index, value) {
                                if (x > 0) selectedtext += "\t";
                                var text = value;
                                if (value == null) text = "";
                                self._clipboardselection[self._clipboardselection.length - 1][x] = text;
                                x++;
                                selectedtext += text;
                            });
                        }
                        else continue;

                        if (i < maxrowindex) {
                            selectedtext += '\r\n';
                        }
                    }
                }
                this.clipboardselectedtext = selectedtext;
                return selectedtext;
            },

            pasteselection: function () {
                var cells = this.getselectedcells();
                this._oldselectedcell = null;
                if (this.selectionmode.indexOf('cell') == -1) {
                    cells = this._getcellsforcopypaste();
                }
                if (cells != null && cells.length > 0) {
                    var rowindex = cells[0].rowindex;
                    var displayindex = this.getrowdisplayindex(rowindex);
                    var datafield = cells[0].datafield;
                    var columnindex = this._getcolumnindex(datafield);
                    var x = 0;
                    this.selectedrowindexes = new Array();
                    this.selectedcells = new Array();
                    var cellsCount = cells.length;
                    var clipboardCellsCount = 0;
                    var clipboardCells = new Array();
                    var paste = [];

                    if (this.copytoclipboardwithheaders) {
                        this._clipboardselection.splice(0, 1);
                    }

                    if (!this._clipboardselection) {
                        this._clipboardselection = [];
                    }

                    for (var i = 0; i < this._clipboardselection.length; i++) {
                        clipboardCellsCount += this._clipboardselection[i].length;
                        clipboardCells[i] = new Array();
                        for (var j = 0; j < this._clipboardselection[i].length; j++) {
                            var cellvalue = this._clipboardselection[i][j];
                            clipboardCells[i].push(cellvalue);
                        }
                    }
                    if (clipboardCellsCount < cells.length) {
                        var selectedCellsByRow = new Array();
                        for (var i = 0; i < cells.length; i++) {
                            var cell = cells[i];
                            if (!selectedCellsByRow[cell.rowindex])
                                selectedCellsByRow[cell.rowindex] = new Array();
                            selectedCellsByRow[cell.rowindex].push(cell);
                        }
                        var clipboardrow = 0;
                        var clipboardcolumn = 0;

                        for (var i = 0; i < selectedCellsByRow.length; i++) {
                            if (!selectedCellsByRow[i]) continue;
                            for (var j = 0; j < selectedCellsByRow[i].length; j++) {
                                var cell = selectedCellsByRow[i][j];
                                var boundindex = cell.rowindex;
                                var column = this.getcolumn(cell.datafield);
                                if (column.datafield === "_checkboxcolumn")
                                    continue;
                                if (column.hidden)
                                    continue;
                                if (column.editable === false) {
                                    continue;
                                }

                                var cellvalue = "";
                                if (clipboardCells[clipboardrow] && undefined == clipboardCells[clipboardrow][clipboardcolumn]) {
                                    clipboardcolumn = 0;
                                }
                                cellvalue = '' + clipboardCells[clipboardrow][clipboardcolumn];
                                clipboardcolumn++;
                                if (column.cellsformat) {
                                    if (column.cellsformat.indexOf('p') != -1 || column.cellsformat.indexOf('d') != -1 || column.cellsformat.indexOf('c') != -1 || column.cellsformat.indexOf('n') != -1 || column.cellsformat.indexOf('f') != -1) {
                                        if (cellvalue.indexOf && cellvalue.indexOf(this.gridlocalization.currencysymbol) > -1) {
                                            // remove currency symbol
                                            cellvalue = cellvalue.replace(this.gridlocalization.currencysymbol, "");
                                        }

                                        var replaceAll = function (text, stringToFind, stringToReplace) {
                                            var temp = text;
                                            if (stringToFind == stringToReplace) return text;

                                            var index = temp.indexOf(stringToFind);
                                            while (index != -1) {
                                                temp = temp.replace(stringToFind, stringToReplace);
                                                index = temp.indexOf(stringToFind)
                                            }

                                            return temp;
                                        }

                                        cellvalue = replaceAll(cellvalue, this.gridlocalization.thousandsseparator, "");
                                        cellvalue = cellvalue.replace(this.gridlocalization.decimalseparator, ".");

                                        if (cellvalue.indexOf(this.gridlocalization.percentsymbol) > -1) {
                                            cellvalue = cellvalue.replace(this.gridlocalization.percentsymbol, "");
                                        }

                                        var val = "";
                                        for (var t = 0; t < cellvalue.length; t++) {
                                            var ch = cellvalue.substring(t, t + 1);
                                            if (ch === "-") val += "-";
                                            if (ch === ".") val += ".";
                                            if (ch.match(/^[0-9]+$/) != null) {
                                                val += ch;
                                            }
                                        }

                                        cellvalue = val;
                                        cellvalue = cellvalue.replace(/ /g, "");

                                        cellvalue = new Number(cellvalue);
                                        if (isNaN(cellvalue))
                                            cellvalue = "";
                                    }
                                }
                                this._raiseEvent(17, { rowindex: boundindex, datafield: cell.datafield, value: cellvalue });

                                var row = this.getrowdata(boundindex);

                                paste.push({ oldvalue: row[cell.datafield], value: cellvalue, datafield: cell.datafield, row: boundindex });
                                this.pushToHistory = true;
                                this.setcellvalue(boundindex, column.displayfield, cellvalue, false);
                                this.pushToHistory = false;
                                if (column.displayfield != column.datafield && this.logicalclipboardselection) {
                                    if (this.logicalclipboardselection[boundindex]) {
                                        var value = this.logicalclipboardselection[boundindex][column.datafield];
                                        if (value != undefined) {
                                            this.setcellvalue(boundindex, column.datafield, value, false);
                                        }
                                    }
                                }

                                this._raiseEvent(18, { rowindex: boundindex, datafield: cell.datafield, oldvalue: this.getcellvalue(cell.rowindex, cell.datafield), value: cellvalue });
                                this._applycellselection(boundindex, cell.datafield, true, false);
                            }
                            clipboardrow++;
                            clipboardcolumn = 0;
                            if (!clipboardCells[clipboardrow]) {
                                clipboardrow = 0;
                            }
                        }
                    }
                    else {
                        if (!this._clipboardselection) return;
                        for (var row = 0; row < this._clipboardselection.length; row++) {
                            for (var c = 0; c < this._clipboardselection[row].length; c++) {
                                var column = this.getcolumnat(columnindex + c);
                                if (!column) continue;
                                if (column.datafield === "_checkboxcolumn")
                                    continue;
                                if (column.hidden)
                                    continue;
                                if (column.editable === false) {
                                    continue;
                                }
                                var boundindex = this.getrowboundindex(displayindex + row);
                                var cell = this.getcell(boundindex, column.datafield);
                                var cellvalue = null;
                                cellvalue = this._clipboardselection[row][c];
                                if (cellvalue != null) {
                                    if (column.cellsformat) {
                                        if (column.cellsformat.indexOf('p') != -1 || column.cellsformat.indexOf('d') != -1 || column.cellsformat.indexOf('c') != -1 || column.cellsformat.indexOf('n') != -1 || column.cellsformat.indexOf('f') != -1) {
                                            if (cellvalue.indexOf(this.gridlocalization.currencysymbol) > -1) {
                                                // remove currency symbol
                                                cellvalue = cellvalue.replace(this.gridlocalization.currencysymbol, "");
                                            }

                                            var replaceAll = function (text, stringToFind, stringToReplace) {
                                                var temp = text;
                                                if (stringToFind == stringToReplace) return text;

                                                var index = temp.indexOf(stringToFind);
                                                while (index != -1) {
                                                    temp = temp.replace(stringToFind, stringToReplace);
                                                    index = temp.indexOf(stringToFind)
                                                }

                                                return temp;
                                            }

                                            cellvalue = replaceAll(cellvalue, this.gridlocalization.thousandsseparator, "");
                                            cellvalue = cellvalue.replace(this.gridlocalization.decimalseparator, ".");

                                            if (cellvalue.indexOf(this.gridlocalization.percentsymbol) > -1) {
                                                cellvalue = cellvalue.replace(this.gridlocalization.percentsymbol, "");
                                            }

                                            var val = "";
                                            for (var t = 0; t < cellvalue.length; t++) {
                                                var ch = cellvalue.substring(t, t + 1);
                                                if (ch === "-") val += "-";
                                                if (ch === ".") val += ".";
                                                if (ch.match(/^[0-9]+$/) != null) {
                                                    val += ch;
                                                }
                                            }

                                            cellvalue = val;
                                            cellvalue = cellvalue.replace(/ /g, "");

                                            cellvalue = new Number(cellvalue);
                                            if (isNaN(cellvalue))
                                                cellvalue = "";
                                        }
                                    }
                                    this._raiseEvent(17, { rowindex: boundindex, datafield: cell.datafield, value: cellvalue });

                                    var datarow = this.getrowdata(boundindex);

                                    paste.push({ oldvalue: datarow[cell.datafield], value: cellvalue, datafield: cell.datafield, row: boundindex });

                                    this.pushToHistory = true;
                                    this.setcellvalue(boundindex, column.displayfield, cellvalue, false);
                                    this.pushToHistory = false;

                                    if (column.displayfield != column.datafield && this.logicalclipboardselection) {
                                        var value = this.logicalclipboardselection[row][column.datafield];
                                        if (value != undefined) {
                                            this.setcellvalue(boundindex, column.datafield, value, false);
                                        }
                                    }

                                    this._raiseEvent(18, { rowindex: boundindex, datafield: cell.datafield, oldvalue: this.getcellvalue(cell.rowindex, cell.datafield), value: cellvalue });
                                    this._applycellselection(boundindex, cell.datafield, true, false);
                                }
                            }
                        }
                    }

                    if (this.selectionmode == "checkbox") {
                        this._updatecheckboxselection();
                    }
                    this.dataview.updateview();
                    this._renderrows(this.virtualsizeinfo);
                }

                this._undoRedo.push({ action: 'paste', data: paste });
                this._undoRedoIndex = -1;
                if (this.clipboardend) {
                    this.clipboardend("paste");
                }
            },

            _applyrowselection: function (index, select, refresh, multiplerows, column) {
                if (index == null)
                    return false;

                var oldindex = this.selectedrowindex;

                if (this.selectionmode == 'singlerow') {
                    var that = this;
                    setTimeout(function () {
                        if (select) {
                            that._raiseEvent(2, { rowindex: index, row: that.getrowdata(index) });
                        }
                        else {
                            that._raiseEvent(3, { rowindex: index, row: that.getrowdata(index) });
                        }

                        that._raiseEvent(3, { rowindex: oldindex });
                    });
                    this.selectedrowindexes = new Array();
                    this.selectedcells = new Array();
                }

                if (multiplerows == true) {
                    this.selectedrowindexes = new Array();
                }

                if (this.dataview.filters.length > 0) {
                    var data = this.getrowdata(index);
                    if (data && data.dataindex !== undefined) {
                        index = data.dataindex;
                    }
                    else if (data && data.dataindex === undefined) {
                        if (data.uid != undefined) {
                            index = this.getrowboundindexbyid(data.uid);

                        }
                    }
                }

                var indexIn = this.selectedrowindexes.indexOf(index);

                if (select) {
                    this.selectedrowindex = index;

                    if (indexIn == -1) {
                        this.selectedrowindexes.push(index);

                        if (this.selectionmode != 'singlerow') {
                            this._raiseEvent(2, { rowindex: index, row: this.getrowdata(index) });
                        }
                    }
                    else if (this.selectionmode == 'multiplerows') {
                        this.selectedrowindexes.splice(indexIn, 1);
                        this._raiseEvent(3, { rowindex: this.selectedrowindex, row: this.getrowdata(index) });
                        this.selectedrowindex = this.selectedrowindexes.length > 0 ? this.selectedrowindexes[this.selectedrowindexes.length - 1] : -1;
                    }
                }
                else if (indexIn >= 0 || this.selectionmode == 'singlerow' || this.selectionmode == 'multiplerowsextended' || this.selectionmode == 'multiplerowsadvanced') {
                    var oldIndex = this.selectedrowindexes[indexIn];
                    this.selectedrowindexes.splice(indexIn, 1);
                    this._raiseEvent(3, { rowindex: oldIndex, row: this.getrowdata(index) });
                    this.selectedrowindex = -1;
                }

                if (refresh == undefined || refresh) {
                    this._rendervisualrows();
                }

                return true;
            },

            _applycellselection: function (index, column, select, refresh, hasEvents) {
                if (index == null)
                    return false;

                if (column == null)
                    return false;


                if (this._autofill) {
                    this._autofill.remove();

                    $(document).off('pointermove.autofill');
                    $(document).off('pointerup.autofill');

                    this._autofill = null;
                }

                var oldindex = this.selectedrowindex;

                if (this.selectionmode == 'singlecell') {
                    var oldcell = this.selectedcell;
                    if (oldcell != null) {
                        this._raiseEvent(16, { rowindex: oldcell.rowindex, datafield: oldcell.datafield });
                    }
                    this.selectedcells = new Array();
                }

                if (this.selectionmode == 'multiplecellsextended' || this.selectionmode == 'multiplecellsadvanced') {
                    var oldcell = this.selectedcell;
                    if (oldcell != null) {
                        this._raiseEvent(16, { rowindex: oldcell.rowindex, datafield: oldcell.datafield });
                    }
                }

                var uniquekey = index + "_" + column;
                if (this.dataview.filters.length > 0) {
                    var data = this.getrowdata(index);
                    if (data && data.dataindex !== undefined) {
                        index = data.dataindex;
                        var uniquekey = index + "_" + column;
                    }
                    else if (data && data.dataindex === undefined) {
                        if (data.uid) {
                            index = this.getrowboundindexbyid(data.uid);
                            var uniquekey = index + "_" + column;
                        }
                    }
                }

                var cell = { rowindex: index, datafield: column };
                if (select) {
                    var selectedcell = this.selectedcell;

                    this.selectedcell = cell;
                    if (!this.selectedcells[uniquekey]) {
                        this.selectedcells[uniquekey] = Object.assign({}, cell);
                        this.selectedcells.length++;

                        var raiseEvent = true;

                        if (selectedcell && selectedcell.datafield === cell.datafield && cell.rowindex === selectedcell.rowindex) {
                            raiseEvent = false;
                        }

                        if (raiseEvent && hasEvents !== false) {
                            var self = this;
                            if (!self._selectedCells) {
                                self._selectedCells = [];
                            }
                            self._selectedCells.push(cell);

                            if (!this._mousecaptured) {
                                if (this._raiseCellsSelectEventTimeout) {
                                    clearTimeout(this._raiseCellsSelectEventTimeout);
                                }
                                this._raiseCellsSelectEventTimeout = setTimeout(function () {
                                    if (!self.mousecaptured) {
                                        self._raiseEvent(15, self._selectedCells);
                                        delete self._selectedCells;
                                    }

                                }, 150);
                            }

                            //      this._raiseEvent(15, cell);
                        }
                    }
                    else if (this.selectionmode == "multiplecells" || this.selectionmode == 'multiplecellsextended' || this.selectionmode == 'multiplecellsadvanced') {
                        delete this.selectedcells[uniquekey];
                        if (this.selectedcells.length > 0) {
                            this.selectedcells.length--;
                        }
                        if (hasEvents !== false) {
                            this._raiseEvent(16, cell);
                        }
                    }
                }
                else {
                    delete this.selectedcells[uniquekey];
                    if (this.selectedcells.length > 0) {
                        this.selectedcells.length--;
                    }

                    if (hasEvents !== false) {
                        this._raiseEvent(16, cell);
                    }
                }

                if (refresh == undefined || refresh) {
                    this._rendervisualrows();
                }

                return true;
            },

            _getcellindex: function (uniquekey) {
                var id = -1;
                $.each(this.selectedcells, function () {
                    id++;
                    if (this[uniquekey]) {
                        return false;
                    }
                });
                return id;
            },

            _clearhoverstyle: function () {
                if (undefined == this.hoveredrow || this.hoveredrow == -1)
                    return;

                if (this.vScrollInstance.isScrolling())
                    return;

                if (this.hScrollInstance.isScrolling())
                    return;

                var cells = this.table.find('.jqx-grid-cell-hover');

                if (cells.length > 0) {
                    cells.removeClass(this.toTP('jqx-grid-cell-hover'));
                    cells.removeClass(this.toTP('jqx-fill-state-hover'));

                }

                for (var i = 0; i < cells.length; i++) {
                    var column = cells[i].getAttribute('columnindex');
                    if (column) {
                        var columnrecord = this.columns.records[parseInt(column)];

                        if (columnrecord) {
                            columnrecord._applyCellStyle(cells[i]);
                        }
                    }

                }

                this.hoveredrow = -1;
            },

            _clearselectstyle: function () {
                var rowscount = this.table[0].rows.length;
                var rows = this.table[0].rows;
                var selectclass = this.toTP('jqx-grid-cell-selected');
                var selectclass2 = this.toTP('jqx-fill-state-pressed');
                var hoverclass = this.toTP('jqx-grid-cell-hover');
                var hoverclass2 = this.toTP('jqx-fill-state-hover');

                for (var i = 0; i < rowscount; i++) {
                    var tablerow = rows[i];
                    var cellslength = tablerow.cells.length;
                    var cells = tablerow.cells;
                    for (var j = 0; j < cellslength; j++) {
                        var tablecell = cells[j];
                        var $tablecell = $(tablecell);
                        if (tablecell.className.indexOf('jqx-grid-cell-selected') != -1) {
                            $tablecell.removeClass(selectclass);
                            $tablecell.removeClass(selectclass2);
                        }

                        if (tablecell.className.indexOf('jqx-grid-cell-hover') != -1) {
                            $tablecell.removeClass(hoverclass);
                            $tablecell.removeClass(hoverclass2);
                        }

                        var column = tablecell.getAttribute('columnindex');
                        if (column) {
                            var columnrecord = this.columns.records[parseInt(column)];

                            if (columnrecord) {
                                columnrecord._applyCellStyle(tablecell);
                            }
                        }
                    }
                }
            },

            _selectpath: function (row, column) {
                var self = this;
                var that = this;
                var minRow = this._lastClickedCell ? Math.min(this._lastClickedCell.row, row) : 0;
                var maxRow = this._lastClickedCell ? Math.max(this._lastClickedCell.row, row) : 0;
                var lastCell = null;
                if (minRow <= maxRow) {
                    var index1 = this._getcolumnindex(this._lastClickedCell.column || that._lastClickedCell.datafield);
                    var index2 = this._getcolumnindex(column);
                    var minColumn = Math.min(index1, index2);
                    var maxColumn = Math.max(index1, index2);
                    this.selectedcells = new Array();
                    var rows = this.dataview.loadedrecords;

                    for (var r = minRow; r <= maxRow; r++) {
                        for (var c = minColumn; c <= maxColumn; c++) {
                            var row = rows[r];
                            this._applycellselection(self.getboundindex(row), self._getcolumnat(c).datafield, true, false);
                            lastCell = { row: self.getboundindex(row), datafield: self._getcolumnat(c).datafield };
                        }
                    }
                    this._rendervisualrows();
                }
            },

            _selectrowpath: function (row) {
                if (this.selectionmode == 'multiplerowsextended') {
                    var self = this;
                    var minRow = this._lastClickedCell ? Math.min(this._lastClickedCell.row, row) : 0;
                    var maxRow = this._lastClickedCell ? Math.max(this._lastClickedCell.row, row) : 0;
                    var rows = this.dataview.loadedrecords;
                    if (minRow <= maxRow) {
                        this.selectedrowindexes = new Array();
                        for (var r = minRow; r <= maxRow; r++) {
                            var row = rows[r];
                            var boundIndex = this.getrowboundindex(r);
                            this._applyrowselection(boundIndex, true, false);
                        }
                        this._rendervisualrows();
                    }
                }
            },

            _selectrowwithmouse: function (self, rowinfo, oldindexes, column, ctrlKey, shiftKey) {
                var row = rowinfo.row;

                if (row == undefined)
                    return;

                var index = rowinfo.index;

                if (this.hittestinfo[index] == undefined) {
                    return;
                }

                for (var i = 0; i < this.columns.records.length; i++) {
                    var currentColumn = this.columns.records[i];

                    currentColumn.selected = false;

                    if (currentColumn.element) {
                        currentColumn.element.removeAttribute('selected');
                    }
                    currentColumn._applyStyle();

                }

                var tablerow = this.hittestinfo[index].visualrow;

                if (this.hittestinfo[index].details) {
                    return;
                }

                var cellclass = tablerow.cells[0].className;
                if (row.group) {
                    return;
                }

                if (this.selectionmode == 'multiplerows' || this.selectionmode == 'multiplecells' || this.selectionmode == 'checkbox' || (this.selectionmode.indexOf('multiple') != -1 && (shiftKey == true || ctrlKey == true))) {
                    var boundindex = this.getboundindex(row);
                    if (this.dataview.filters.length > 0) {
                        var data = this.getrowdata(boundindex);
                        if (data) {
                            boundindex = data.dataindex;
                            if (boundindex == undefined) {
                                var boundindex = this.getboundindex(row);
                            }
                        }
                    }

                    var hasindex = oldindexes.indexOf(boundindex) != -1;
                    var key = this.getboundindex(row) + "_" + column;

                    if (this.selectionmode.indexOf('cell') != -1) {
                        var hascellindex = this.selectedcells[key] != undefined;
                        if (this.selectedcells[key] != undefined && hascellindex) {
                            this._selectcellwithstyle(self, false, index, column, tablerow);
                        }
                        else {
                            this._selectcellwithstyle(self, true, index, column, tablerow);
                        }
                        if (shiftKey && this._lastClickedCell == undefined) {
                            var cells = this.getselectedcells();
                            if (cells && cells.length > 0) {
                                this._lastClickedCell = { row: cells[0].rowindex, column: cells[0].datafield };
                            }
                        }
                        if (shiftKey && this._lastClickedCell) {
                            this._selectpath(row.visibleindex, column);
                            this.mousecaptured = false;
                            if (this.selectionarea.css('visibility') == 'visible') {
                                this.selectionarea.css('visibility', 'hidden');
                            }
                        }
                    }
                    else {
                        if (hasindex) {
                            if (ctrlKey) {
                                this._applyrowselection(this.getboundindex(row), false);
                            }
                            else {
                                this._selectrowwithstyle(self, tablerow, false, column);
                            }
                        }
                        else {
                            this._selectrowwithstyle(self, tablerow, true, column);
                        }

                        if (shiftKey && this._lastClickedCell == undefined) {
                            var indexes = this.getselectedrowindexes();
                            if (indexes && indexes.length > 0) {
                                this._lastClickedCell = { row: indexes[0], column: column };
                            }
                        }
                        if (shiftKey && this._lastClickedCell) {
                            this.selectedrowindexes = new Array();
                            var minRow = this._lastClickedCell ? Math.min(this._lastClickedCell.row, row.visibleindex) : 0;
                            var maxRow = this._lastClickedCell ? Math.max(this._lastClickedCell.row, row.visibleindex) : 0;
                            var rows = this.dataview.loadedrecords;

                            for (var r = minRow; r <= maxRow; r++) {
                                var row = rows[r];
                                if (row) {
                                    this._applyrowselection(this.getboundindex(row), true, false, false);
                                }
                            }
                            this._rendervisualrows();
                        }
                    }
                }
                else {
                    this._clearselectstyle();
                    this._selectrowwithstyle(self, tablerow, true, column);
                    if (this.selectionmode.indexOf('cell') != -1) {
                        this._selectcellwithstyle(self, true, index, column, tablerow);
                    }
                }
                if (!shiftKey) {
                    this._lastClickedCell = { row: row.visibleindex, column: column };
                }
            },

            _selectcellwithstyle: function (self, select, row, column, tablerow) {
                var cell = $(tablerow.cells[self._getcolumnindex(column)]);
                cell.removeClass(this.toTP('jqx-grid-cell-hover'));
                cell.removeClass(this.toTP('jqx-fill-state-hover'));

                if (select) {
                    cell.addClass(this.toTP('jqx-grid-cell-selected'));
                    cell.addClass(this.toTP('jqx-fill-state-pressed'));
                }
                else {
                    cell.removeClass(this.toTP('jqx-grid-cell-selected'));
                    cell.removeClass(this.toTP('jqx-fill-state-pressed'));
                }

                var columnrecord = this.getcolumn(column)
                columnrecord._applyCellStyle(cell);
            },

            _selectrowwithstyle: function (self, tablerow, select, column) {
                var cellslength = tablerow.cells.length;

                var startindex = 0;
                if (self.rowdetails && self.showrowdetailscolumn) {
                    if (!this.rtl) {
                        startindex = 1 + this.groups.length;
                    }
                    else {
                        cellslength -= 1;
                        cellslength -= this.groups.length;
                    }
                }
                else if (this.groupable) {
                    if (!this.rtl) {
                        startindex = this.groups.length;
                    }
                    else {
                        cellslength -= this.groups.length;
                    }
                }

                for (var i = startindex; i < cellslength; i++) {
                    var tablecell = tablerow.cells[i];
                    if (select) {
                        $(tablecell).removeClass(this.toTP('jqx-grid-cell-hover'));
                        $(tablecell).removeClass(this.toTP('jqx-fill-state-hover'));

                        if (self.selectionmode.indexOf('cell') == -1) {
                            $(tablecell).addClass(this.toTP('jqx-grid-cell-selected'));
                            $(tablecell).addClass(this.toTP('jqx-fill-state-pressed'));
                        }
                    }
                    else {
                        $(tablecell).removeClass(this.toTP('jqx-grid-cell-hover'));
                        $(tablecell).removeClass(this.toTP('jqx-grid-cell-selected'));
                        $(tablecell).removeClass(this.toTP('jqx-fill-state-hover'));
                        $(tablecell).removeClass(this.toTP('jqx-fill-state-pressed'));
                    }

                    var column = tablecell.getAttribute('columnindex');
                    if (column) {
                        var columnrecord = this.columns.records[parseInt(column)];

                        if (columnrecord) {
                            columnrecord._applyCellStyle(tablecell);
                        }
                    }
                }
            },

            _handlemousemoveselection: function (event, self, handleY) {
                if (self.hScrollInstance.isScrolling() || self.vScrollInstance.isScrolling()) {
                    return false;
                }

                if ((self.selectionmode == 'multiplerowsextended' || self.selectionmode == 'multiplecellsextended' || self.selectionmode == 'multiplecellsadvanced') && self.mousecaptured) {
                    if (self.multipleselectionbegins) {
                        var canSelectMultipleRows = self.multipleselectionbegins(event);
                        if (canSelectMultipleRows === false) {
                            return true;
                        }
                    }

                    var columnheaderheight = this.showheader ? this.columnsheader.height() + 2 : 0;
                    var groupsheaderheight = this._groupsheader() ? this.groupsheader.height() : 0;
                    var toolbarheight = this.showtoolbar ? this.toolbar.height() : 0;
                    var filterbarheight = this.showfilterbar ? this.toolbarheight : 0;
                    groupsheaderheight += toolbarheight;
                    groupsheaderheight += filterbarheight;

                    var hostoffset = this.host.coord();
                    if (this.hasTransform) {
                        hostoffset = $.jqx.utilities.getOffset(this.host);
                        var bodyOffset = this._getBodyOffset();
                        hostoffset.left -= bodyOffset.left;
                        hostoffset.top -= bodyOffset.top;
                    }
                    if (this.host.css('border-top-width') === '0px') {
                        groupsheaderheight -= 2;
                    }

                    var x = event.pageX;
                    var y = event.pageY - groupsheaderheight;

                    if (event._pageX) {
                        x = event._pageX;
                        y = event._pageY - groupsheaderheight;
                    }


                    if (Math.abs(this.mousecaptureposition.left - x) > 3 || Math.abs(this.mousecaptureposition.top - y) > 3 || self.autofill) {
                        var columnheadertop = parseInt(this.columnsheader.coord().top);
                        if (this.hasTransform) {
                            columnheadertop = $.jqx.utilities.getOffset(this.columnsheader).top;
                        }
                        if (x < hostoffset.left) {
                            x = hostoffset.left;
                        }

                        if (x > hostoffset.left + this.host.width()) {
                            x = hostoffset.left + this.host.width();
                        }
                        var columnheaderbottom = hostoffset.top + columnheaderheight;
                        if (y < columnheaderbottom) y = columnheaderbottom + 5;
                        var rectleft = parseInt(Math.min(self.mousecaptureposition.left, x));
                        var recttop = -5 + parseInt(Math.min(self.mousecaptureposition.top, y));
                        var rectwidth = parseFloat(Math.abs(self.mousecaptureposition.left - x));
                        var rectheight = parseInt(Math.abs(self.mousecaptureposition.top - y));
                        rectleft -= hostoffset.left;
                        recttop -= hostoffset.top;

                        this.selectionarea.css('visibility', 'visible');

                        if (self.selectionmode == 'multiplecellsadvanced') {
                            var x = rectleft;
                            var arearight = x + rectwidth;
                            var arealeft = x;
                            var hScrollInstance = self.hScrollInstance;
                            var horizontalscrollvalue = hScrollInstance.value;
                            if (this.rtl) {
                                if (this.hScrollBar.css('visibility') != 'hidden') {
                                    horizontalscrollvalue = hScrollInstance.max - hScrollInstance.value;
                                }
                                if (this.vScrollBar[0].style.visibility != 'hidden') {
                                    //      horizontalscrollvalue -= this.scrollbarsize + 4;
                                }
                            }
                            var tablerow = self.table[0].rows[0];
                            var p = 0;

                            var leftcellindex = self.mousecaptureposition.clickedcell;
                            var rightcellindex = leftcellindex;
                            var found = false;

                            var starti = 0;
                            var endi = tablerow.cells.length;
                            if (self.mousecaptureposition.left <= event.pageX) {
                                starti = leftcellindex;
                            }

                            var startFromPinned = false;
                            for (var i = starti; i < endi; i++) {
                                var columnleft = parseFloat($(this.columnsrow[0].cells[i]).css('left'));
                                var left = columnleft - horizontalscrollvalue;
                                if (self.columns.records[i].pinned && !self.columns.records[i].hidden) {
                                    if (i == leftcellindex) {
                                        startFromPinned = true;
                                    }
                                    var right = columnleft + $(this.columnsrow[0].cells[i]).width();
                                    if (self.mousecaptureposition.left > event.pageX) {
                                        if (right >= x && x >= left) {
                                            rightcellindex = i;
                                            found = true;
                                            break;
                                        }
                                    }
                                    else {
                                        if (right >= arearight && arearight >= left) {
                                            rightcellindex = i;
                                            found = true;
                                            break;
                                        }
                                    }
                                    continue;
                                }
                                if (startFromPinned) {
                                    found = true;
                                    rightcellindex--;
                                    break;
                                }
                                var column = this._getcolumnat(i);
                                if (column != null && column.hidden) {
                                    continue;
                                }

                                if (self.groupable && self.groups.length > 0) {
                                    if (i < self.groups.length) {
                                        continue;
                                    }
                                }

                                var right = left + $(this.columnsrow[0].cells[i]).width();
                                if (self.mousecaptureposition.left > event.pageX) {
                                    if (right >= x && x >= left) {
                                        rightcellindex = i;
                                        found = true;
                                        break;
                                    }
                                }
                                else {
                                    if (right >= arearight && arearight >= left) {
                                        rightcellindex = i;
                                        found = true;
                                        break;
                                    }
                                }
                            }
                            if (!found) {
                                if (self.mousecaptureposition.left > event.pageX) {
                                    $.each(this.columns.records, function (index, value) {
                                        if (self.groupable && self.groups.length > 0) {
                                            if (index < self.groups.length) {
                                                return true;
                                            }
                                        }

                                        if (!this.pinned && !this.hidden) {
                                            rightcellindex = index;
                                            return false;
                                        }
                                    });
                                }
                                else {
                                    if (!self.groupable || (self.groupable && !self.groups.length > 0)) {
                                        rightcellindex = tablerow.cells.length - 1;
                                    }
                                }
                            }
                            var tmpindex = leftcellindex;
                            leftcellindex = Math.min(leftcellindex, rightcellindex);
                            rightcellindex = Math.max(tmpindex, rightcellindex);
                            recttop += 5;
                            recttop += groupsheaderheight;
                            var startrowindex = self.table[0].rows.indexOf(self.mousecaptureposition.clickedrow);
                            var increaseheight = 0;
                            var startrow = -1;
                            var endrow = -1;
                            var offsettop = 0;
                            for (var i = 0; i < self.table[0].rows.length; i++) {
                                var row = $(self.table[0].rows[i]);
                                if (i == 0) offsettop = row.coord().top;
                                var rowheight = row.height();
                                var rowtop = offsettop - hostoffset.top;
                                if (startrow == -1 && rowtop + rowheight >= recttop) {
                                    var toContinue = false;
                                    for (var q = 0; q < self.groups.length; q++) {
                                        var className = row[0].cells[q].className;
                                        if (className.indexOf('jqx-grid-group-collapse') != -1 || className.indexOf('jqx-grid-group-expand') != -1) {
                                            toContinue = true;
                                            break;
                                        }
                                    }
                                    if (toContinue) continue;


                                    startrow = i;
                                }
                                offsettop += rowheight;

                                if (self.groupable && self.groups.length > 0) {
                                    var toContinue = false;
                                    for (var q = 0; q < self.groups.length; q++) {
                                        var className = row[0].cells[q].className;
                                        if (className.indexOf('jqx-grid-group-collapse') != -1 || className.indexOf('jqx-grid-group-expand') != -1) {
                                            toContinue = true;
                                            break;
                                        }
                                    }
                                    if (toContinue) continue;

                                    var p = 0;
                                    for (var k = self.groups.length; k < row[0].cells.length; k++) {
                                        var cell = row[0].cells[k];
                                        if ($(cell).html() == "") {
                                            p++;
                                        }
                                    }
                                    if (p == row[0].cells.length - self.groups.length) {
                                        continue;
                                    }
                                }

                                if (startrow != -1) {
                                    increaseheight += rowheight;
                                }

                                if (rowtop + rowheight > recttop + rectheight) {
                                    endrow = i;
                                    break;
                                }
                            }


                            if (startrow != -1) {
                                recttop = $(self.table[0].rows[startrow]).coord().top - hostoffset.top - groupsheaderheight - 2;
                                var additionalHeight = 0;
                                if (this.filterable && this.showfilterrow) {
                                    additionalHeight = this.filterrowheight;
                                }

                                if (parseFloat(self.table[0].style.top) < 0 && recttop < this.rowsheight + additionalHeight) {
                                    recttop -= parseFloat(self.table[0].style.top);
                                    increaseheight += parseFloat(self.table[0].style.top);
                                }

                                rectheight = increaseheight;
                                var leftcell = $(this.columnsrow[0].cells[leftcellindex]);
                                var rightcell = $(this.columnsrow[0].cells[rightcellindex]);
                                rectleft = parseFloat(leftcell.css('left'));
                                rectwidth = parseFloat(rightcell.css('left')) - parseFloat(rectleft) + rightcell.width() - 2;
                                rectleft -= horizontalscrollvalue;
                                if (startFromPinned) {
                                    rectleft += horizontalscrollvalue;
                                }
                                if (self.editcell && self.editable && self.endcelledit && (leftcellindex != rightcellindex || startrow != endrow)) {
                                    if (self.editcell.validated == false) return;
                                    self.endcelledit(self.editcell.row, self.editcell.column, true, true);
                                }
                            }
                        }

                        this.selectionarea.width(rectwidth);
                        this.selectionarea.css('left', rectleft);

                        if (handleY !== null) {
                            this.selectionarea.css('top', recttop);
                            this.selectionarea.height(rectheight);
                        }
                    }
                }
            },

            _handlemouseupselection: function (event, self, autofill) {
                if (!this.selectionarea) return;

                var that = this;
                if (this.selectionarea[0].style.visibility != 'visible') {

                    self._handlemousemoveselection(event, self);

                    if (autofill !== false) {
                        if (self.__firstcell) {
                            var selectedCell = self.getselectedcell();

                            if (selectedCell) {
                                self.__firstcell.index = self.columns.records.indexOf(self.getcolumn(selectedCell.datafield));
                                self.__firstcell.row = selectedCell.row;
                                self.__firstcell.rowindex = selectedCell.rowindex;
                                self._handleAutofill(event, self);
                            }
                        }
                        else {
                            self.__firstcell = self.getselectedcell();
                            if (self.__firstcell) {
                                self.__firstcell.index = self.columns.records.indexOf(self.getcolumn(self.__firstcell.datafield));
                                self._handleAutofill(event, self);
                            }
                        }
                    }

                    self.mousecaptured = false;
                    self.selectionarea[0].style.visibility = 'hidden';
                    return true;
                }

                if (self.mousecaptured && (self.selectionmode == 'multiplerowsextended' || self.selectionmode == 'multiplerowsadvanced' || self.selectionmode == 'multiplecellsextended' || self.selectionmode == 'multiplecellsadvanced')) {
                    self.mousecaptured = false;
                    if (this.selectionarea.css('visibility') == 'visible') {
                        this.selectionarea.css('visibility', 'hidden');

                        var columnheaderheight = this.showheader ? this.columnsheader.height() + 2 : 0;
                        var groupsheaderheight = this._groupsheader() ? this.groupsheader.height() : 0;
                        if (this.host.css('border-top-width') === '0px') {
                            groupsheaderheight -= 2;
                        }
                        var toolbarheight = this.showtoolbar ? this.toolbar.height() : 0;
                        groupsheaderheight += toolbarheight;

                        var filterbarheight = this.showfilterbar ? this.toolbarheight : 0;
                        groupsheaderheight += filterbarheight;
                        var areaoffset = this.selectionarea.coord();
                        var hostoffset = this.host.coord();
                        if (this.hasTransform) {
                            hostoffset = $.jqx.utilities.getOffset(this.host);
                            areaoffset = $.jqx.utilities.getOffset(this.selectionarea);
                        }
                        if (this.host.css('border-top-width') === '0px') {
                            groupsheaderheight -= 2;
                        }
                        var x = areaoffset.left - hostoffset.left;
                        var y = areaoffset.top - columnheaderheight - hostoffset.top - groupsheaderheight;
                        var m = y;
                        var arearight = x + this.selectionarea.width();
                        var arealeft = x;

                        var rows = new Array();
                        var indexes = new Array();

                        if (self.selectionmode == 'multiplerowsextended') {
                            while (y < m + this.selectionarea.height()) {
                                var rowinfo = this._hittestrow(x, y);
                                var row = rowinfo.row;
                                var index = rowinfo.index;
                                if (index != -1) {
                                    if (!indexes[index]) {
                                        indexes[index] = true;
                                        rows[rows.length] = rowinfo;
                                    }
                                }
                                y += 20;
                            }
                            var m = 0;
                            $.each(rows, function () {
                                var rowinfo = this;
                                var row = this.row;
                                if (self.selectionmode != 'none' && self._selectrowwithmouse) {
                                    if (event.ctrlKey || event.metaKey) {
                                        self._applyrowselection(self.getboundindex(row), true, false, false);
                                    }
                                    else {
                                        if (m == 0) {
                                            self._applyrowselection(self.getboundindex(row), true, false, true);
                                        }
                                        else {
                                            self._applyrowselection(self.getboundindex(row), true, false, false);
                                        }
                                    }
                                    m++;
                                }
                            });
                        }
                        else {
                            var lastcell = null;
                            var firstcell = null;

                            if (self.selectionmode == 'multiplecellsadvanced') {
                                y += 2;
                            }
                            var hScrollInstance = self.hScrollInstance;
                            var horizontalscrollvalue = hScrollInstance.value;
                            if (this.rtl) {
                                if (this.hScrollBar.css('visibility') != 'hidden') {
                                    horizontalscrollvalue = hScrollInstance.max - hScrollInstance.value;
                                }
                                if (this.vScrollBar[0].style.visibility != 'hidden') {
                                    horizontalscrollvalue -= this.scrollbarsize + 4;
                                }
                            }
                            var tablerow = self.table[0].rows[0];
                            var selectionheight = self.selectionarea.height();
                            if (!event.ctrlKey && !event.metaKey && selectionheight > 0) {
                                self.selectedcells = new Array();
                            }

                            var selectionHeight = selectionheight;

                            var top = parseInt(this.vScrollInstance.value);
                            var left = parseInt(this.hScrollInstance.value);
                            var tableheight = this._gettableheight();
                            var tablewidth = this._hostwidth != undefined ? this._hostwidth : this.host.width();
                            var columnstart = this.groupable && this.groups.length > 0 ? this.groups.length : 0;
                            var columnend = this.columns.records.length - columnstart;
                            var hasgroups = this.groupable && this.groups.length > 0;

                            var visualcolumnsindexes = this._getvisualcolumnsindexes(left, tablewidth, columnstart, columnend, hasgroups, true, true);
                            var hcolumnstart = visualcolumnsindexes.start;
                            var hcolumnend = visualcolumnsindexes.end;
                            that.__firstcell = null;

                            while (y < m + selectionHeight) {
                                var rowinfo = self._hittestrow(x, y);
                                if (!rowinfo) {
                                    y += 5;
                                    continue;
                                }
                                var row = rowinfo.row;
                                var index = rowinfo.index;
                                if (index != -1) {
                                    if (!indexes[index]) {
                                        indexes[index] = true;

                                        if (!this.enableoptimization) {
                                            for (var i = 0; i < tablerow.cells.length; i++) {
                                                var left = parseFloat($(self.columnsrow[0].cells[i]).css('left')) - horizontalscrollvalue;
                                                var right = left + $(self.columnsrow[0].cells[i]).width();
                                                if ((arealeft >= left && arealeft <= right) || (arearight >= left && arearight <= right)
                                                    || (left >= arealeft && left <= arearight)) {
                                                    self._applycellselection(self.getboundindex(row), self._getcolumnat(i).datafield, true, false);
                                                    lastcell = { x: x, y: y, rowindex: index, row: self.getboundindex(row), index: i, datafield: self._getcolumnat(i).datafield };
                                                    self.__lastcell = lastcell;
                                                    if (!firstcell) {
                                                        firstcell = lastcell;
                                                        self.__firstcell = firstcell;
                                                    }
                                                }
                                            }
                                        }
                                        else {
                                            for (var i = hcolumnstart; i < hcolumnend; i++) {
                                                var left = parseFloat(self.columnsrow[0].cells[i].style.left) - horizontalscrollvalue;
                                                var right = left + self.columns.records[i].width;
                                                if ((arealeft >= left && arealeft <= right) || (arearight >= left && arearight <= right)
                                                    || (left >= arealeft && left <= arearight)) {
                                                    self._applycellselection(self.getboundindex(row), self._getcolumnat(i).datafield, true, false);
                                                    lastcell = { x: x, y: y, rowindex: index, row: self.getboundindex(row), index: i, datafield: self._getcolumnat(i).datafield };
                                                    self.__lastcell = lastcell;
                                                    if (!firstcell) {
                                                        firstcell = lastcell;
                                                        self.__firstcell = firstcell;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                y += 5;
                            }
                        }
                        if (self.autosavestate) {
                            if (self.savestate) self.savestate();
                        }

                    }
                    self._renderrows(self.virtualsizeinfo);
                    if (autofill !== false) {
                        self._handleAutofill(event, self);
                    }
                }
            },

            _handleAutofill: function (event, self) {
                if (!this.autofill) {
                    return;
                }

                var that = this;
                var columnheaderheight = this.showheader ? this.columnsheader.height() + 2 : 0;
                var groupsheaderheight = this._groupsheader() ? this.groupsheader.height() : 0;
                if (this.host.css('border-top-width') === '0px') {
                    groupsheaderheight -= 2;
                }
                var rows = new Array();
                var indexes = new Array();
                var toolbarheight = this.showtoolbar ? this.toolbar.height() : 0;
                groupsheaderheight += toolbarheight;

                var filterbarheight = this.showfilterbar ? this.toolbarheight : 0;
                groupsheaderheight += filterbarheight;
                var areaoffset = this.selectionarea.coord();
                var hostoffset = this.host.coord();
                if (this.hasTransform) {
                    hostoffset = $.jqx.utilities.getOffset(this.host);
                    areaoffset = $.jqx.utilities.getOffset(this.selectionarea);
                }
                if (this.host.css('border-top-width') === '0px') {
                    groupsheaderheight -= 2;
                }
                var x = areaoffset.left - hostoffset.left;
                var y = areaoffset.top - columnheaderheight - hostoffset.top - groupsheaderheight;
                var m = y;
                var arearight = x + this.selectionarea.width();
                var arealeft = x;

                var lastcell = that.__lastcell;
                var firstcell = that.__firstcell;

                if (self.selectionmode == 'multiplecellsadvanced') {
                    y += 2;
                }
                var hScrollInstance = self.hScrollInstance;
                var horizontalscrollvalue = hScrollInstance.value;
                if (this.rtl) {
                    if (this.hScrollBar.css('visibility') != 'hidden') {
                        horizontalscrollvalue = hScrollInstance.max - hScrollInstance.value;
                    }
                    if (this.vScrollBar[0].style.visibility != 'hidden') {
                        horizontalscrollvalue -= this.scrollbarsize + 4;
                    }
                }
                var tablerow = self.table[0].rows[0];
                var selectionheight = self.selectionarea.height();
                var left = parseInt(event.pageX);
                var top = parseInt(event.pageY);

                var selectionHeight = selectionheight;

                var that = self;

                if (that._autofill) {
                    that._autofill.remove();
                }

                if (firstcell && !that.getcolumn(firstcell.datafield).autofill) {
                    return;
                }

                if (that.autofill) {
                    that._autofill = document.createElement('div');
                    that._autofill.style.width = '6px';
                    that._autofill.style.height = '6px';
                    that._autofill.style.position = 'absolute';
                    that._autofill.style.top = areaoffset.top - that.host.offset().top + selectionHeight + 1 + 'px';
                    that._autofill.style.left = arearight + 2 + 'px';
                    that._autofill.style.cursor = 'crosshair';
                    that._autofill.style.paddingLeft = '0px';
                    that._autofill.style.paddingTop = '0px';
                    that._autofill.style.paddingRight = '0px';
                    that._autofill.style.paddingBottom = '0px';
                    that._autofill.style.borderTopLeftRadius = '0px';
                    that._autofill.style.borderTopRightRadius = '0px';
                    that._autofill.style.borderBottomLeftRadius = '0px';
                    that._autofill.style.borderBottomRightRadius = '0px';
                    that._autofill.style.background = 'transparent';

                    $(that._autofill).addClass(that.toThemeProperty('jqx-widget'));
                    $(that._autofill).addClass(that.toThemeProperty('jqx-button'));
                    $(that._autofill).addClass(that.toThemeProperty('primary'));
                    $(that._autofill).addClass(that.toThemeProperty('jqx-fill-state-pressed'));

                    //      that._lastClickedCell = lastcell;

                    that._autofill.onpointerdown = function (event) {
                        that._handlemouseupselection(event, that, false);
                        var originalEvent = event.originalEvent ? event.originalEvent : event;
                        that._autofillDragStart = true;
                        that.mousecaptured = true;

                        var columnheaderheight = that.showheader ? that.columnsheader.height() + 2 : 0;
                        var groupsheaderheight = that._groupsheader() ? that.groupsheader.height() : 0;
                        var toolbarheight = that.showtoolbar ? that.toolbarheight : 0;
                        var filterheight = that.showfilterbar ? that.toolbarheight : 0;

                        groupsheaderheight += toolbarheight;
                        groupsheaderheight += filterheight;

                        var hostoffset = that.host.coord();

                        var x = left - hostoffset.left;
                        var y = top - columnheaderheight - hostoffset.top - groupsheaderheight;
                        if (that.pageable && !that.autoheight && that.gotopage) {
                            var pagerposition = that.pager.coord().top - hostoffset.top - groupsheaderheight - columnheaderheight;
                            if (y > pagerposition) {
                                return;
                            }
                        }
                        var rowinfo = that._hittestrow(x, y);
                        if (!rowinfo)
                            return;

                        if (rowinfo.details)
                            return;

                        var row = rowinfo.row;
                        var index = rowinfo.index;
                        var targetclassname = originalEvent.target.className;
                        var tablerow = that.table[0].rows[firstcell.rowindex];
                        var xoffset = $(self.columnsrow[0].cells[firstcell.index]).coord().left;
                        var yoffset = $(tablerow).coord().top + 1;

                        that.mousecaptured = true;
                        that.mousecaptureposition = {
                            x: xoffset, y: yoffset, left: originalEvent.pageX, top: originalEvent.pageY, clickedrow: tablerow
                        };

                        that.copyselection();
                        originalEvent.stopPropagation();
                        originalEvent.preventDefault();
                    }
                    $(document).off('pointermove.autofill');
                    $(document).off('pointerup.autofill');

                    $(document).on('pointermove.autofill', function (event) {
                        if (that._autofillDragStart) {
                            var originalEvent = event.originalEvent ? event.originalEvent : event;

                            if (that.mousecaptureposition.position) {
                                if (that.mousecaptureposition.position === 'y') {
                                    originalEvent._pageX = that.mousecaptureposition.x;
                                    originalEvent._pageY = originalEvent.pageY;
                                    that.mousecaptureposition.top = that.mousecaptureposition.y;

                                    that._handlemousemoveselection(originalEvent, that);
                                }
                                else {
                                    originalEvent._pageX = originalEvent.pageX;
                                    originalEvent._pageY = that.mousecaptureposition.y;
                                    that.mousecaptureposition.clickedcell = firstcell.index;
                                    that.mousecaptureposition.left = that.mousecaptureposition.x;

                                    that._handlemousemoveselection(originalEvent, that, null);
                                }
                            }
                            else {
                                if (Math.abs(that.mousecaptureposition.left - originalEvent.pageX) >= 5) {
                                    that.mousecaptureposition.position = 'x';
                                }
                                else if (Math.abs(that.mousecaptureposition.top - originalEvent.pageY)) {
                                    that.mousecaptureposition.position = 'y';
                                }
                            }
                        }
                    });

                    $(document).on('pointerup.autofill', function (event) {
                        var originalEvent = event.originalEvent ? event.originalEvent : event;

                        if (!that._autofillDragStart) {
                            if (that._autofill) {
                                that._autofill.remove();
                            }
                            that.clearselection();
                            return;
                        }

                        that._handlemouseupselection(originalEvent, that);
                        that._autofillDragStart = false;
                        that.mousecaptureposition = null;
                        that.mousecaptured = false;
                        that.pasteselection();
                        that._handlemouseupselection(originalEvent, that);
                    });


                    that.wrapper[0].appendChild(that._autofill);
                }
            },

            selectprevcell: function (row, datafield) {
                var columnindex = this._getcolumnindex(datafield);
                var columnscount = this.columns.records.length;
                var prevcolumn = this._getprevvisiblecolumn(columnindex);
                if (prevcolumn != null) {
                    this.clearselection();
                    this.selectcell(row, prevcolumn.datafield);
                }
            },

            selectnextcell: function (row, datafield) {
                var columnindex = this._getcolumnindex(datafield);
                var columnscount = this.columns.records.length;
                var nextcolumn = this._getnextvisiblecolumn(columnindex);
                if (nextcolumn != null) {
                    this.clearselection();
                    this.selectcell(row, nextcolumn.datafield);
                }
            },

            _getfirstvisiblecolumn: function () {
                var self = this;
                var length = this.columns.records.length;
                for (var i = 0; i < length; i++) {
                    var column = this.columns.records[i];
                    if (!column.hidden && column.datafield != null)
                        return column;
                }

                return null;
            },

            _getlastvisiblecolumn: function () {
                var self = this;
                var length = this.columns.records.length;
                for (var i = length - 1; i >= 0; i--) {
                    var column = this.columns.records[i];
                    if (!column.hidden && column.datafield != null)
                        return column;
                }

                return null;
            },

            _handlekeydown: function (event, self) {
                if (self.groupable && self.groups.length > 0) {
                    //        return true;
                }
                if (self.disabled) {
                    return false;
                }
                var key = event.charCode ? event.charCode : event.keyCode ? event.keyCode : 0;
                if (key === 32 && (event.metaKey || event.ctrlKey) && self.selectionmode == 'multiplecellsadvanced') {
                    var selectedcell = this.getselectedcell();

                    if (event.shiftKey) {
                        this.clearselection();
                        this.selectallrows();

                        if (this.columns.records.length < 30) {
                            for (var i = 0; i < this.columns.records.length; i++) {
                                var column = this.columns.records[i];

                                if (column.selectable) {
                                    column.toggleSelection(column, event, true);
                                }
                            }
                        }

                        this._renderrows(this.virtualsizeinfo);
                        return;
                    }
                    else if (selectedcell) {
                        var column = this.getcolumn(selectedcell.datafield);

                        if (column.selectable) {
                            this.clearselection();
                            column.toggleSelection(column, event, true);
                            this._renderrows(this.virtualsizeinfo);
                        }
                    }
                }

                if (self.editcell && self.selectionmode != 'multiplecellsadvanced') {
                    return true;
                }
                else if (self.editcell && self.selectionmode == 'multiplecellsadvanced') {


                    if (key >= 33 && key <= 40) {
                        if (!event.altKey) {
                            if (self._cancelkeydown == undefined || self._cancelkeydown == false) {
                                if (self.editmode !== "selectedrow") {
                                    self.endcelledit(self.editcell.row, self.editcell.column, false, true);
                                    self._cancelkeydown = false;
                                    if (self.editcell && !self.editcell.validated) {
                                        self._rendervisualrows();
                                        self.endcelledit(self.editcell.row, self.editcell.column, false, true);
                                        return false;
                                    }
                                }
                                else {
                                    return true;
                                }
                            }
                            else {
                                self._cancelkeydown = false;
                                return true;
                            }
                        }
                        else {
                            self._cancelkeydown = false;
                            return true;
                        }
                    }
                    else return true;
                }

                if (self.selectionmode == 'none')
                    return true;

                if (self.showfilterrow && self.filterable) {
                    if (this.filterrow) {
                        if ($(event.target).ischildof(self.filterrow))
                            return true;
                    }
                }

                if (self.showeverpresentrow) {
                    if (self.addnewrowtop) {
                        if ($(event.target).ischildof(self.addnewrowtop)) {
                            return true;
                        }
                    }
                    if (self.addnewrowbottom) {
                        if ($(event.target).ischildof(self.addnewrowbottom)) {
                            return true;
                        }
                    }
                }
                if (event.target.className && event.target.className.indexOf('jqx-grid-widget') >= 0) {
                    return true;
                }


                if (self.pageable) {
                    if ($(event.target).ischildof(this.pager)) {
                        return true;
                    }
                }

                if (this.showtoolbar) {
                    if ($(event.target).ischildof(this.toolbar)) {
                        return true;
                    }
                }

                if (this.showfilterbar) {
                    if ($(event.target).ischildof(this.filterbar)) {
                        return true;
                    }
                }
                if (this.showstatusbar) {
                    if ($(event.target).ischildof(this.statusbar)) {
                        return true;
                    }
                }

                var selectionchanged = false;
                if (event.altKey) {
                    return true;
                }

                if (event.ctrlKey || event.metaKey) {
                    if (this.clipboard) {
                        var pressedkey = String.fromCharCode(key).toLowerCase();

                        if (pressedkey === 'z') {
                            if (this._undoRedo) {
                                if (this._undoRedoIndex === -1) {
                                    this._undoRedoIndex = this._undoRedo.length - 1;
                                }

                                var item = this._undoRedo[this._undoRedoIndex];

                                if (item) {
                                    if (item.action === 'setcellvalue') {
                                        this.setcellvalue(item.data.row, item.data.datafield, item.data.oldvalue);
                                        this.clearselection();
                                        this.selectcell(item.data.row, item.data.datafield);
                                        this.ensurecellvisible(item.data.row, item.data.datafield);
                                    }
                                    else if (item.action === 'paste') {
                                        this.clearselection();
                                        if (item.data) {
                                            for (var i = 0; i < item.data.length; i++) {
                                                var subItem = item.data[i];

                                                this.setcellvalue(subItem.row, subItem.datafield, subItem.oldvalue);
                                                this._applycellselection(subItem.row, subItem.datafield, true, false);

                                                if (i === 0) {
                                                    this.ensurecellvisible(subItem.row, subItem.datafield);
                                                }
                                            }
                                        }
                                        this._rendervisualrows();
                                    }
                                }
                                if (this._undoRedoIndex > 0) {
                                    this._undoRedoIndex--;
                                }
                            }
                        }


                        if (pressedkey === 'y') {
                            if (this._undoRedo) {
                                if (this._undoRedoIndex === -1) {
                                    this._undoRedoIndex = this._undoRedo.length - 1;
                                }

                                var item = this._undoRedo[this._undoRedoIndex];

                                if (item) {
                                    if (item.action === 'setcellvalue') {
                                        this.setcellvalue(item.data.row, item.data.datafield, item.data.value);
                                        this.clearselection();
                                        this.selectcell(item.data.row, item.data.datafield);
                                        this.ensurecellvisible(item.data.row, item.data.datafield);
                                    }
                                    else if (item.action === 'paste') {
                                        this.clearselection();
                                        for (var i = 0; i < item.data.length; i++) {
                                            var subItem = item.data[i];

                                            this.setcellvalue(subItem.row, subItem.datafield, subItem.value);
                                            this._applycellselection(subItem.row, subItem.datafield, true, false);
                                            if (i === 0) {
                                                this.ensurecellvisible(subItem.row, subItem.datafield);
                                            }
                                        }
                                        this._rendervisualrows();
                                    }
                                }
                                if (this._undoRedoIndex < this._undoRedo.length - 1) {
                                    this._undoRedoIndex++;
                                }
                            }
                        }

                        if (pressedkey === 'd') {
                            var selection = this.copyselection();
                            var value = this._clipboardselection[0];
                            this._clipboardselection = [this._clipboardselection[0]];
                            this.pasteselection();
                            event.preventDefault();
                            event.stopPropagation();
                        }

                        if (this.clipboardbegin) {
                            var clbegin = null;
                            if (pressedkey == 'c') {
                                clbegin = this.clipboardbegin("copy", this.copyselection());
                            }
                            else if (pressedkey == "x") {
                                clbegin = this.clipboardbegin("cut", this.copyselection());
                            }
                            else if (pressedkey == "v") {
                                clbegin = this.clipboardbegin("paste");
                            }
                            if (clbegin === false)
                                return false;
                        }

                        if (pressedkey == 'c' || pressedkey == 'x') {
                            var text = this.copyselection();
                            if (pressedkey == 'c' && this.clipboardend) {
                                this.clipboardend("copy");
                            }
                            if (pressedkey == 'x' && this.clipboardend) {
                                this.clipboardend("cut");
                            }
                            if (window.clipboardData) {
                                window.clipboardData.setData("Text", text);
                            }
                            else {
                                var copyFrom = $('<textarea style="position: absolute; left: -1000px; top: -1000px;"/>');
                                copyFrom.val(text);
                                $('body').append(copyFrom);
                                copyFrom.select();
                                setTimeout(function () {
                                    document.designMode = 'off';
                                    copyFrom.select();
                                    copyFrom.remove();
                                    self.focus();
                                }, 100);
                            }
                            if (pressedkey == 'c' && $.jqx.browser.msie) {
                                return false;
                            }
                            else if (pressedkey == 'c')
                                return true;
                        }
                        else if (pressedkey == 'v') {
                            if (document.activeElement && document.activeElement.nodeName === 'INPUT') {
                                return true;
                            }

                            var pasteFrom = $('<textarea style="position: absolute; left: -1000px; top: -1000px;"/>');
                            $('body').append(pasteFrom);
                            pasteFrom.select();
                            var that = this;
                            setTimeout(function () {
                                that._clipboardselection = new Array();
                                var value = pasteFrom.val();
                                if (value.length == 0 && window.clipboardData) {
                                    pasteFrom.val(window.clipboardData.getData("Text"));
                                    var value = pasteFrom.val();
                                }
                                var rows = value.split('\n');
                                for (var i = 0; i < rows.length; i++) {
                                    if (rows[i].split('\t').length > 0) {
                                        var values = rows[i].split('\t');
                                        if (values.length == 1 && i == rows.length - 1 && values[0] == "") {
                                            continue;
                                        }

                                        if (values.length > 0) {
                                            that._clipboardselection.push(values);
                                        }
                                    }
                                }
                                that.pasteselection();
                                pasteFrom.remove();
                                that.focus();
                            }, 100);
                            return true;
                        }
                        if (pressedkey == 'x') {
                            this.deleteselection();
                            this.host.focus();
                            return false;
                        }
                    }
                }

                var hostHeight = Math.round(self._gettableheight());
                // get records per page.
                var pagesize = Math.round(hostHeight / self.rowsheight);
                var datainfo = self.getdatainformation();

                switch (self.selectionmode) {
                    case 'singlecell':
                    case 'multiplecells':
                    case 'multiplecellsextended':
                    case 'multiplecellsadvanced':
                        var selectedcell = self.getselectedcell();
                        if (selectedcell === null) {
                            self.selectcell(0, self.columns.records[0].displayfield);
                        }
                        if (selectedcell != null) {
                            var visibleindex = this.getrowvisibleindex(selectedcell.rowindex);
                            var rowindex = visibleindex;
                            var datafield = selectedcell.datafield;
                            var columnindex = self._getcolumnindex(datafield);
                            var columnscount = self.columns.records.length;
                            var selectgridcell = function (row, datafield, clearselection, reason) {
                                var tryselect = function (row, datafield) {
                                    var datarow = self.dataview.loadedrecords[row];
                                    if (self.groupable && self.groups.length > 0) {
                                        var index = row;
                                        if (reason == "up") index++;
                                        if (reason == "down") index--;
                                        var datarow = self.getdisplayrows()[index];
                                        var isExpanded = function (group) {
                                            if (group.group) {
                                                if (self.expandedgroups[group.uniqueid]) {
                                                    return self.expandedgroups[group.uniqueid].expanded;
                                                }
                                            }
                                            else return false;
                                        }
                                        var x = 1;
                                        var nextItem = true;
                                        while (nextItem && x < 300) {
                                            nextItem = false;
                                            if (reason == "down") {
                                                datarow = self.getdisplayrows()[index + x];
                                            }
                                            else if (reason == "up") {
                                                datarow = self.getdisplayrows()[index - x];
                                            }

                                            if (!datarow)
                                                break;

                                            if (datarow && datarow.group)
                                                nextItem = true;

                                            if (datarow && datarow.totalsrow) {
                                                nextItem = true;
                                            }

                                            var parent = datarow.parentItem;

                                            while (parent) {
                                                if (parent && !isExpanded(parent)) {
                                                    nextItem = true;
                                                }
                                                parent = parent.parentItem;
                                            }
                                            if (!nextItem)
                                                break;
                                            x++;
                                        }
                                        if (x == 300) datarow = null;
                                        if (self.pageable) {
                                            var foundIndex = false;
                                            if (datarow) {
                                                for (var i = 0; i < self.dataview.rows.length; i++) {
                                                    if (self.dataview.rows[i].boundindex == datarow.boundindex) {
                                                        foundIndex = true;
                                                    }
                                                }

                                                if (!foundIndex)
                                                    datarow = null;
                                            }
                                        }
                                    }
                                    else if (self.pageable) {
                                        var foundIndex = false;
                                        if (datarow) {
                                            for (var i = 0; i < self.dataview.rows.length; i++) {
                                                if (self.dataview.rows[i].boundindex == datarow.boundindex) {
                                                    foundIndex = true;
                                                }
                                            }

                                            if (!foundIndex) {
                                                if (self.pagerpageinput && event.keyCode === 9) {
                                                    if (datarow.boundindex > self.dataview.rows[self.dataview.rows.length - 1].boundindex) {
                                                        self.pagerpageinput.focus();
                                                        event.preventDefault();
                                                    }
                                                }
                                                //             datarow = null;
                                                self.ensurerowvisible(datarow);
                                                //       return true;
                                            }
                                        }
                                    }

                                    if (datarow != undefined && datafield != null && !datarow.totalsrow) {
                                        if (clearselection || clearselection == undefined) {
                                            self.clearselection();
                                        }
                                        var visibleindex = self.getboundindex(datarow);
                                        self.selectcell(visibleindex, datafield);
                                        self._oldselectedcell = self.selectedcell;
                                        selectionchanged = true;

                                        if (self.groupable) {
                                            self.ensurecellvisible(visibleindex, datafield);
                                        }
                                        else {
                                            self.ensurecellvisible(row, datafield);
                                        }
                                        return true;
                                    }
                                    return false;
                                }

                                if (!tryselect(row, datafield) && !self.groupable) {
                                    self.ensurecellvisible(row, datafield);
                                    tryselect(row, datafield);
                                    if (self.virtualmode) {
                                        self.host.focus();
                                    }
                                }
                                var grouping = self.groupable && self.groups.length > 0;
                                if (!grouping) {
                                    if (event.shiftKey && event.keyCode != 9) {
                                        if (self.selectionmode == 'multiplecellsextended' || self.selectionmode == 'multiplecellsadvanced') {
                                            if (self._lastClickedCell) {
                                                self._selectpath(row, datafield);
                                                var datarow = self.dataview.loadedrecords[row];
                                                var visibleindex = self.getboundindex(datarow);
                                                self.selectedcell = { rowindex: visibleindex, datafield: datafield };
                                                return;
                                            }
                                        }
                                    }
                                    else if (!event.shiftKey) {
                                        self._lastClickedCell = { row: row, column: datafield };
                                    }
                                }
                            }
                            var shift = event.shiftKey && self.selectionmode != 'singlecell' && self.selectionmode != 'multiplecells';
                            var home = function () {
                                if (self.pageable) {
                                    var recordindex = self.dataview.pagenum * self.dataview.pagesize;

                                    selectgridcell(recordindex, datafield, !shift);
                                }
                                else {
                                    selectgridcell(0, datafield, !shift);
                                }
                            }
                            var end = function () {
                                var newindex = datainfo.rowscount - 1;
                                if (self.pageable) {
                                    var recordindex = self.dataview.pagenum * self.dataview.pagesize;

                                    newindex = recordindex + self.dataview.rows.length - 1;
                                }
                                selectgridcell(newindex, datafield, !shift);
                            }

                            var tab = key == 9 && !event.shiftKey;
                            var shifttab = key == 9 && event.shiftKey;
                            if (self.rtl) {
                                var tmpTab = tab;
                                tab = shifttab;
                                shifttab = tmpTab;
                            }
                            if (tab || shifttab) shift = false;
                            if (tab || shifttab)
                                if (document.activeElement && document.activeElement.className && document.activeElement.className.indexOf('jqx-grid-cell-add-new-row') >= 0) {
                                    return true;
                                }
                            var ctrl = event.ctrlKey || event.metaKey;
                            if (ctrl && key == 37) {
                                var previouscolumn = self._getfirstvisiblecolumn(columnindex);
                                if (previouscolumn != null) {
                                    selectgridcell(rowindex, previouscolumn.datafield);
                                }
                            }
                            else if (ctrl && key == 39) {
                                var next = self._getlastvisiblecolumn(columnindex);
                                if (next != null) {
                                    selectgridcell(rowindex, next.datafield);
                                }
                            }
                            else if (key == 39 || tab) {
                                var nextcolumn = self._getnextvisiblecolumn(columnindex);
                                if (nextcolumn != null) {
                                    selectgridcell(rowindex, nextcolumn.datafield, !shift);
                                }
                                else {
                                    if (!tab) {
                                        selectionchanged = true;
                                    }
                                    else {
                                        var firstColumn = self._getfirstvisiblecolumn();
                                        key = 40;
                                        datafield = firstColumn.displayfield;
                                    }
                                }
                            }
                            else if (key == 37 || shifttab) {
                                var previouscolumn = self._getprevvisiblecolumn(columnindex);
                                if (previouscolumn != null) {
                                    selectgridcell(rowindex, previouscolumn.datafield, !shift);
                                }
                                else {
                                    if (!shifttab) {
                                        selectionchanged = true;
                                    }
                                    else {
                                        var lastColumn = self._getlastvisiblecolumn();
                                        key = 38;
                                        datafield = lastColumn.displayfield;
                                    }
                                }
                            }
                            else if (key == 36) {
                                home();
                            }
                            else if (key == 35) {
                                end();
                            }
                            else if (key == 33) {
                                if (rowindex - pagesize >= 0) {
                                    var newindex = rowindex - pagesize;
                                    selectgridcell(newindex, datafield, !shift);

                                    if (self.pageable && self.virtualmode) {
                                        self.gotoprevpage();
                                        setTimeout(function () {
                                            selectgridcell(newindex, datafield, !shift);
                                        }, 25);
                                    }
                                }
                                else {
                                    home();
                                }
                            }
                            else if (key == 34) {
                                if (datainfo.rowscount > rowindex + pagesize) {
                                    var newindex = rowindex + pagesize;
                                    selectgridcell(newindex, datafield, !shift);
                                    if (self.pageable && self.virtualmode) {
                                        self.gotonextpage();
                                        setTimeout(function () {
                                            selectgridcell(newindex, datafield, !shift);
                                        }, 25);
                                    }
                                }
                                else {
                                    end();
                                }
                            }
                            if (key == 38) {
                                if (ctrl) {
                                    home();
                                }
                                else {
                                    if (rowindex > 0) {
                                        selectgridcell(rowindex - 1, datafield, !shift, "up");
                                    }
                                    else {
                                        selectionchanged = false;
                                    }
                                }
                            }
                            if (key == 40) {
                                if (ctrl) {
                                    end();
                                }
                                else {
                                    if ((datainfo.rowscount > rowindex + 1) || (self.groupable && self.groups.length > 0)) {
                                        selectgridcell(rowindex + 1, datafield, !shift, "down");
                                    }
                                    else {
                                        selectionchanged = true;
                                    }
                                }
                            }
                        }
                        break;
                    case 'singlerow':
                    case 'multiplerows':
                    case 'multiplerowsextended':
                    case 'multiplerowsadvanced':
                        var rowindex = self.getselectedrowindex();
                        if (rowindex == null || rowindex == -1)
                            return true;

                        rowindex = this.getrowvisibleindex(rowindex);
                        var selectgridrow = function (index, clearselection, reason) {
                            var tryselect = function (index) {
                                var datarecord = self.dataview.loadedrecords[index];
                                if (self.groupable && self.groups.length > 0) {
                                    if (reason == "up") index++;
                                    if (reason == "down") index--;
                                    var datarecord = self.getdisplayrows()[index];
                                    var isExpanded = function (group) {
                                        if (group.group) {
                                            if (self.expandedgroups[group.uniqueid]) {
                                                return self.expandedgroups[group.uniqueid].expanded;
                                            }
                                        }
                                        else return false;
                                    }
                                    var x = 1;
                                    var nextItem = true;
                                    while (nextItem && x < 300) {
                                        nextItem = false;
                                        if (reason == "down") {
                                            datarecord = self.getdisplayrows()[index + x];
                                        }
                                        else if (reason == "up") {
                                            datarecord = self.getdisplayrows()[index - x];
                                        }

                                        if (!datarecord)
                                            break;

                                        if (datarecord && datarecord.group)
                                            nextItem = true;


                                        if (datarecord && datarecord.totalsrow) {
                                            nextItem = true;
                                        }

                                        var parent = datarecord.parentItem;

                                        while (parent) {
                                            if (parent && !isExpanded(parent)) {
                                                nextItem = true;
                                            }
                                            parent = parent.parentItem;
                                        }
                                        if (!nextItem)
                                            break;
                                        x++;
                                    }
                                    if (x == 300) datarecord = null;
                                    if (self.pageable) {
                                        var foundIndex = false;
                                        if (datarecord) {
                                            for (var i = 0; i < self.dataview.rows.length; i++) {
                                                if (self.dataview.rows[i].boundindex == datarecord.boundindex) {
                                                    foundIndex = true;
                                                }
                                            }

                                            if (!foundIndex)
                                                datarecord = null;
                                        }
                                    }
                                }

                                if (datarecord != undefined) {
                                    var visibleindex = self.getboundindex(datarecord);
                                    var tmpindex = self.selectedrowindex;
                                    if (clearselection || clearselection == undefined) {
                                        self.clearselection();
                                    }
                                    self.selectedrowindex = tmpindex;
                                    self.selectrow(visibleindex, false);

                                    if (self.groupable && self.groups.length > 0) {
                                        var scrolled = self.ensurerowvisible(visibleindex);
                                    }
                                    else {
                                        var scrolled = self.ensurerowvisible(index);
                                    }

                                    if (!scrolled || self.autoheight || self.groupable) {
                                        self._rendervisualrows();
                                    }
                                    selectionchanged = true;
                                    return true;
                                }

                                return false;
                            }
                            if (!tryselect(index) && !self.groupable) {
                                self.ensurerowvisible(index);
                                tryselect(index, clearselection);
                                if (self.virtualmode) {
                                    setTimeout(function () {
                                        tryselect(index, clearselection);
                                    }, 25);
                                }
                                if (self.virtualmode) {
                                    self.host.focus();
                                }
                            }
                            var grouping = self.groupable && self.groups.length > 0;
                            if (!grouping) {
                                if (event.shiftKey && key != 9) {
                                    if (self.selectionmode == 'multiplerowsextended') {
                                        if (self._lastClickedCell) {
                                            self._selectrowpath(index);
                                            self.selectedrowindex = self.getrowboundindex(index);
                                            return;
                                        }
                                    }
                                }
                                else if (!event.shiftKey) {
                                    self._lastClickedCell = { row: index };
                                    self.selectedrowindex = self.getrowboundindex(index);
                                }
                            }
                        }
                        var shift = event.shiftKey && self.selectionmode != 'singlerow' && self.selectionmode != 'multiplerows';

                        var home = function () {
                            if (self.pageable) {
                                var recordindex = self.dataview.pagenum * self.dataview.pagesize;

                                selectgridrow(recordindex, !shift);
                            }
                            else {
                                selectgridrow(0, !shift);
                            }
                        }
                        var end = function () {
                            var newindex = datainfo.rowscount - 1;

                            if (self.pageable) {
                                var recordindex = self.dataview.pagenum * self.dataview.pagesize;

                                newindex = recordindex + self.dataview.rows.length - 1;
                            }
                            selectgridrow(newindex, !shift);
                        }

                        var ctrl = event.ctrlKey || event.metaKey;
                        if (key == 36 || (ctrl && key == 38)) {
                            home();
                        }
                        else if (key == 35 || (ctrl && key == 40)) {
                            end();
                        }
                        else if (key == 33) {
                            if (rowindex - pagesize >= 0) {
                                var newindex = rowindex - pagesize;
                                selectgridrow(newindex, !shift, "up");

                                if (self.pageable && self.virtualmode) {
                                    self.gotoprevpage();
                                    setTimeout(function () {
                                        selectgridrow(newindex, !shift);
                                    }, 25);
                                }
                            }
                            else {
                                home();
                            }
                        }
                        else if (key == 34) {
                            if (datainfo.rowscount > rowindex + pagesize) {
                                var newindex = rowindex + pagesize;
                                selectgridrow(newindex, !shift, "down");

                                if (self.pageable && self.virtualmode) {
                                    self.gotonextpage();
                                    setTimeout(function () {
                                        selectgridrow(newindex, !shift);
                                    }, 25);
                                }
                            }
                            else {
                                end();
                            }
                        }
                        else if (key == 38) {
                            if (rowindex > 0) {
                                selectgridrow(rowindex - 1, !shift, "up");
                            }
                            else selectionchanged = true;
                        }
                        else if (key == 40) {
                            if ((datainfo.rowscount > rowindex + 1) || (self.groupable && self.groups.length > 0)) {
                                selectgridrow(rowindex + 1, !shift, "down");
                            }
                            else selectionchanged = true;
                        }
                        break;
                }

                if (selectionchanged) {
                    if (self.autosavestate) {
                        if (self.savestate) self.savestate();
                    }

                    //if (self.editcell != null && self.endcelledit) {
                    //    self.endcelledit(self.editcell.row, self.editcell.column, true, true);
                    //}
                    return false;
                }
                return true;
            },

            _handlemousemove: function (event, self) {
                if (self.vScrollInstance.isScrolling())
                    return;

                if (self.hScrollInstance.isScrolling())
                    return;

                var columnheaderheight;
                var groupsheaderheight;
                var hostoffset;
                var x;
                var y;

                if (self.enablehover || self.selectionmode == 'multiplerows') {
                    columnheaderheight = this.showheader ? this.columnsheader.height() + 2 : 0;
                    groupsheaderheight = this._groupsheader() ? this.groupsheader.height() : 0;
                    var toolbarheight = this.showtoolbar ? this.toolbarheight : 0;
                    var filterbarheight = this.showfilterbar ? this.toolbarheight : 0;
                    groupsheaderheight += toolbarheight;
                    groupsheaderheight += filterbarheight;
                    hostoffset = this.host.coord();
                    if (this.hasTransform) {
                        hostoffset = $.jqx.utilities.getOffset(this.host);
                        var bodyOffset = this._getBodyOffset();
                        hostoffset.left -= bodyOffset.left;
                        hostoffset.top -= bodyOffset.top;
                    }
                    x = event.pageX - hostoffset.left;
                    y = event.pageY - columnheaderheight - hostoffset.top - groupsheaderheight;
                }

                if (self.selectionmode == 'multiplerowsextended' || self.selectionmode == 'multiplecellsextended' || self.selectionmode == 'multiplecellsadvanced') {
                    if (self.mousecaptured == true) {
                        return;
                    }
                }

                if (self.enablehover) {
                    if (self.disabled) {
                        return;
                    }

                    if (this.vScrollInstance.isScrolling() || this.hScrollInstance.isScrolling()) {
                        return;
                    }

                    var rowinfo = this._hittestrow(x, y);
                    if (!rowinfo)
                        return;

                    var row = rowinfo.row;
                    var index = rowinfo.index;

                    // if the new index is the same as the last, do nothing.
                    if (this.hoveredrow != -1 && index != -1 && this.hoveredrow == index && this.selectionmode.indexOf('cell') == -1 && this.selectionmode != 'checkbox') {
                        return;
                    }

                    this._clearhoverstyle();

                    if (index == -1 || row == undefined)
                        return;

                    var tablerow = this.hittestinfo[index].visualrow;
                    if (tablerow == null)
                        return;

                    if (this.hittestinfo[index].details) {
                        return;
                    }

                    if (event.clientX > $(tablerow).width() + $(tablerow).coord().left) return;

                    var startindex = 0;
                    var cellslength = tablerow.cells.length;
                    if (self.rowdetails && self.showrowdetailscolumn) {
                        if (!this.rtl) {
                            startindex = 1 + this.groups.length;
                        }
                        else {
                            cellslength -= 1;
                            cellslength -= this.groups.length;
                        }
                    }
                    else if (this.groupable) {
                        if (!this.rtl) {
                            startindex = this.groups.length;
                        }
                        else {
                            cellslength -= this.groups.length;
                        }
                    }

                    if (tablerow.cells.length == 0)
                        return;

                    var cellclass = tablerow.cells[startindex].className;
                    if (row.group || (this.selectionmode.indexOf('row') >= 0 && cellclass.indexOf('jqx-grid-cell-selected') != -1))
                        return;

                    this.hoveredrow = index;

                    if (this.selectionmode.indexOf('cell') != -1 || this.selectionmode == "checkbox") {
                        var cellindex = -1;
                        var hScrollInstance = this.hScrollInstance;
                        var horizontalscrollvalue = hScrollInstance.value;
                        if (this.rtl) {
                            if (this.hScrollBar.css('visibility') != 'hidden') {
                                horizontalscrollvalue = hScrollInstance.max - hScrollInstance.value;
                            }
                        }

                        for (var i = startindex; i < cellslength; i++) {
                            var left = parseInt(this.columnsrow[0].cells[i].style.left) - horizontalscrollvalue;
                            if (this.columns.records[i].pinned && !this.rtl) {
                                left = parseInt(this.columnsrow[0].cells[i].style.left);
                            }
                            var right = left + this.columns.records[i].width;
                            if (right >= x && x >= left) {
                                cellindex = i;
                                break;
                            }
                        }

                        if (cellindex != -1) {
                            var tablecell = tablerow.cells[cellindex];
                            if (this.cellhover) {
                                this.cellhover(tablecell, event.pageX, event.pageY);
                            }


                            if (tablecell.className.indexOf('jqx-grid-cell-selected') == -1) {
                                //       if (tablecell.className.indexOf('jqx-grid-group') == -1) {
                                if (this.editcell) {
                                    var column = this._getcolumnat(cellindex);
                                    if (column) {
                                        if (this.editcell.row == index && this.editcell.column == column.datafield) {
                                            return;
                                        }
                                    }
                                }
                            }
                            $(tablecell).addClass(this.toTP('jqx-grid-cell-hover'));
                            $(tablecell).addClass(this.toTP('jqx-fill-state-hover'));
                            //       }

                            var column = this._getcolumnat(cellindex);
                            column._applyCellStyle(tablecell);
                        }
                        return;
                    }

                    for (var i = startindex; i < cellslength; i++) {
                        var tablecell = tablerow.cells[i];
                        //     if (tablecell.className.indexOf('jqx-grid-group') == -1) {
                        $(tablecell).addClass(this.toTP('jqx-grid-cell-hover'));
                        $(tablecell).addClass(this.toTP('jqx-fill-state-hover'));
                        if (this.cellhover) {
                            this.cellhover(tablecell, event.pageX, event.pageY);
                        }

                        var column = this._getcolumnat(i);
                        column._applyCellStyle(tablecell);

                        //     }
                    }
                }
                else return true;
            }
        });
    })(jqxBaseFramework);
})();





/***/ }),

/***/ 4687:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {
    $.jqx.dataview.sort = function () {
        this.sortby = function (field, ascending, comparer) {
            var tmpToString = Object.prototype.toString;
            if (ascending == null) {
                this.sortdata = null;
                if (this.grid.sortmode !== "many") {
                    this.sortcache = {};
                }
                else {
                    if (this.sortcache[field]) {
                        delete this.sortcache[field];
                    }
                }

                this.grid._pagescache = new Array();
                this.grid._cellscache = new Array();

                if (this.grid.sortmode !== "many") {
                    this.refresh();
                    return;
                }
            }

            if (this.grid.sortmode === "many") {
                this.grid._pagescache = new Array();
                this.grid._cellscache = new Array();
            }

            if (ascending != null) {
                if (ascending == 'a' || ascending == 'asc' || ascending == 'ascending' || ascending == true) {
                    ascending = true;
                }
                else {
                    ascending = false;
                }
            }

            var lookupkey = field;
            this.sortfield = field;
            this.sortfielddirection = ascending ? "asc" : "desc";

            if (ascending == null) {
                this.sortfielddirection = null;
            }

            if (this.sortcache == undefined) {
                this.sortcache = {};
            }

            this.sortdata = [];
            var _sortdata = [];
            var sorted = false;
            if (lookupkey == 'constructor') lookupkey = "";

            if (!this.virtualmode && this.sortcache[lookupkey] != null && this.grid.sortmode !== "many") {
                var cache = this.sortcache[lookupkey];
                _sortdata = cache._sortdata;

                if (cache.direction == ascending) {
                    _sortdata.reverse();
                }
                else {
                    if (!cache.direction && ascending) {
                        _sortdata.reverse();
                    }

                    sorted = true;
                }

                if (_sortdata.length < this.totalrecords) {
                    this.sortcache = {};
                    sorted = false;
                    _sortdata = [];
                }
            }

            Object.prototype.toString = (typeof field == "function") ? field : function () { return this[field] };
            var records = this.records;
            var me = this.that;

            var datatype = '';

            if (this.source.datafields) {
                $.each(this.source.datafields, function () {
                    if (this.name == field) {
                        if (this.type) {
                            datatype = this.type;
                        }
                        return false;
                    }
                });
            }

            if (_sortdata.length == 0) {
                if (records.length) {
                    var length = records.length;
                    // tries to loop through the records with for loop for better performance.
                    for (var i = 0; i < length; i++) {
                        var record = records[i];
                        if (record != null) {
                            var recordvalue = record;
                            var sortkey = recordvalue.toString();
                            _sortdata.push({ sortkey: sortkey, value: recordvalue, index: i });
                        }
                    }
                }
                else {
                    var caniterate = false;
                    // tries to loop through the records with for..in for better performance.
                    for (var obj in records) {
                        var record = records[obj];
                        if (record == undefined) {
                            caniterate = true;
                            break;
                        }

                        var recordvalue = record;
                        _sortdata.push({ sortkey: recordvalue.toString(), value: recordvalue, index: obj });
                    }

                    if (caniterate) {
                        $.each(records, function (i, value) {
                            _sortdata.push({ sortkey: value.toString(), value: value, index: i });
                        });
                    }
                }
            }

            if (!sorted) {
                if (comparer == null) {
                    this._sortcolumntype = datatype;
                    var that = this;
                    _sortdata.sort(function (value1, value2) {
                        return that._compare(value1, value2, datatype);
                    });
                }
                else {
                    _sortdata.sort(comparer);
                }
            }

            if (!ascending) {
                _sortdata.reverse();
            }

            Object.prototype.toString = tmpToString;
            this.sortdata = _sortdata;

            if (ascending !== null) {
                this.sortcache[lookupkey] = { _sortdata: _sortdata, direction: ascending, dataType: this._sortcolumntype, dataField: lookupkey };
            }

            if (this.grid.sortmode === "many") {
                var sortcolumns = [];
                var directions = [];
                var dataTypes = [];

                for (var cacheKey in this.sortcache) {
                    if (cacheKey === 'data') {
                        continue;
                    }

                    var cache = this.sortcache[cacheKey];

                    sortcolumns.push(cache.dataField);
                    directions.push(cache.direction ? 'asc' : 'desc');
                    dataTypes.push(cache.dataType);
                }

                if (sortcolumns.length > 0) {
                    var rows = this.multiSort(records, sortcolumns, directions, dataTypes);

                    _sortdata = [];

                    if (rows) {
                        $.each(rows, function (i, value) {
                            _sortdata.push({ sortkey: lookupkey, value: value, index: value.boundindex });
                        });
                    }

                    this.sortdata = _sortdata;
                }
                else {
                    this.sortcache = {};
                    this.sortdata = null;
                    this.refresh();
                    return;
                }
            }

            this.reload(this.records, this.rows, this.filters, this.updated, true);
        },

            this.multiSort = function (records, sortColumns, directions, dataTypes, customSortingCallback) {
                var that = this;

                if (records.length === 0) {
                    return [];
                }

                var dataSource = [];

                for (var i = 0; i < records.length; i++) {
                    var item = $.extend({}, records[i]);

                    dataSource.push(item);
                }

                var isObservableArray = false;

                if (dataSource && dataSource.constructor && dataSource.constructor.name === 'ObservableArray') {
                    isObservableArray = true;
                }

                if (!dataSource || !(dataSource instanceof Array) || dataSource.length === 0 ||
                    !sortColumns || sortColumns instanceof Array && sortColumns.length === 0) {
                    if (!isObservableArray) {
                        throw new Error('sort: Missing or Invalid arguments!');
                    }
                }

                if (typeof sortColumns === 'string') {
                    sortColumns = [sortColumns];
                }

                var directionCoefficients = [],
                    compareFunctions = [];

                if (directions === undefined) {
                    directions = [];
                }

                var getCompareFunction = function (a, knownDataType) {
                    // gets data type of column (not necessary if the Grid provides this information)
                    var dataType = knownDataType || typeof a;
                    var compareFunction;

                    switch (dataType) {
                        case 'string':
                        default:
                            compareFunction = new Intl.Collator().compare;
                            break;
                        case 'date':
                        case 'time':
                        case 'datetime':
                        case 'number':
                        case 'int':
                        case 'float':
                            compareFunction = function (a, b) {
                                return a - b;
                            };
                            break;
                        case 'boolean':
                            compareFunction = function (a, b) {
                                if (a === b) {
                                    return 0;
                                }
                                else if (a === false) {
                                    return -1;
                                }
                                else {
                                    return 1;
                                }
                            };
                            break;
                        case 'object':
                            if (a instanceof Date) {
                                compareFunction = function (a, b) {
                                    return a.getTime() - b.getTime();
                                };
                            }

                            break;
                    }

                    return compareFunction;
                }

                for (var i = 0; i < sortColumns.length; i++) {
                    if (directions[i] === undefined || directions[i] === 'asc' || directions[i] === 'ascending') {
                        directionCoefficients[i] = 1;
                    }
                    else {
                        directionCoefficients[i] = -1;
                    }

                    var value = dataSource[0][sortColumns[i]];

                    compareFunctions[i] = getCompareFunction(value, dataTypes[i]);
                }

                if (customSortingCallback) {
                    customSortingCallback(dataSource, sortColumns, directions, compareFunctions);
                    return;
                }

                dataSource.sort(function (a, b) {
                    for (var i = 0; i < sortColumns.length; i++) {
                        var result = compareFunctions[i](a[sortColumns[i]], b[sortColumns[i]]);

                        if (result === 0) {
                            if (sortColumns[i + 1]) {
                                continue;
                            }
                            else if (a._index !== undefined) {
                                // makes sorting stable
                                return (a._index - b._index) * directionCoefficients[i];
                            }

                            return 0;
                        }

                        return result * directionCoefficients[i];
                    }

                    if (sortColumns.length === 0) {
                        if (a.boundIndex < b.boundIndex) {
                            return -1;
                        }

                        if (a.boundIndex > b.boundIndex) {
                            return 1;
                        }

                        return 0;

                    }
                });

                return dataSource;
            },

            this.clearsortdata = function () {
                this.sortcache = {};
                this.sortdata = null;
            }

        this._compare = function (value1, value2, type) {
            var value1 = value1.sortkey;
            var value2 = value2.sortkey;
            if (value1 === undefined) { value1 = null; }
            if (value2 === undefined) { value2 = null; }
            if (value1 === null && value2 === null) {
                return 0;
            }
            if (value1 === null && value2 !== null) {
                return -1;
            }
            if (value1 !== null && value2 === null) {
                return 1;
            }

            if ($.jqx.dataFormat) {
                if (type && type != "") {
                    switch (type) {
                        case "number":
                        case "int":
                        case "float":
                            if (value1 < value2) { return -1; }
                            if (value1 > value2) { return 1; }
                            return 0;
                        case "date":
                        case "time":
                            if (value1 < value2) { return -1; }
                            if (value1 > value2) { return 1; }
                            return 0;
                        case "string":
                        case "text":
                            value1 = String(value1).toLowerCase();
                            value2 = String(value2).toLowerCase();
                            break;
                    }
                }
                else {
                    if ($.jqx.dataFormat.isNumber(value1) && $.jqx.dataFormat.isNumber(value2)) {
                        if (value1 < value2) { return -1; }
                        if (value1 > value2) { return 1; }
                        return 0;
                    }
                    else if ($.jqx.dataFormat.isDate(value1) && $.jqx.dataFormat.isDate(value2)) {
                        if (value1 < value2) { return -1; }
                        if (value1 > value2) { return 1; }
                        return 0;
                    }
                    else if (!$.jqx.dataFormat.isNumber(value1) && !$.jqx.dataFormat.isNumber(value2)) {
                        value1 = String(value1).toLowerCase();
                        value2 = String(value2).toLowerCase();
                    }
                }
            }
            try {
                if (value1 < value2) { return -1; }
                if (value1 > value2) { return 1; }
            }
            catch (error) {
                var er = error;
            }

            return 0;
        };

        this._equals = function (value1, value2) {
            return (this._compare(value1, value2) === 0);
        };
    }

    $.extend($.jqx._jqxGrid.prototype, {
        //[optimize]
        _rendersortcolumn: function () {
            var self = this.that;
            var sortcolumn = this.getsortcolumn();

            if (this.sortmode === "many") {
                this.__columnsbydatafield = new Array();
                var columns = this.getsortcolumns();

                $.each(this.columns.records, function (i, value) {
                    $(this.sortasc).hide();
                    $(this.sortdesc).hide();
                    $(this.sorticon).css("visibility", "hidden");
                    this.element.removeAttribute("sort");
                    this.element.removeAttribute("sort-index");
                    if ($(this.sorticon)[0]) {
                        $(this.sorticon)[0].removeAttribute("order");
                    }
                });

                if (columns.length > 0) {
                    for (var i = 0; i < columns.length; i++) {
                        var column = columns[i];

                        var columnRecord = this._getcolumnbydatafield(column.dataField);

                        columnRecord.element.setAttribute("sort", true);
                        columnRecord.element.setAttribute("sort-index", i);

                        if (self.isMaterialized() || self.isModern()) {
                            $(columnRecord.sorticon).show();
                            $(columnRecord.sorticon).css("visibility", "inherit");

                            $(columnRecord.sorticon).removeClass("ascending");
                            $(columnRecord.sorticon).removeClass("descending");

                            $(columnRecord.sorticon)[0].setAttribute("order", i + 1);

                            if (column.ascending) {
                                $(columnRecord.sorticon).addClass("ascending");
                            }
                            else {
                                $(columnRecord.sorticon).addClass("descending");
                            }
                        }
                        else {
                            if (column.ascending) {
                                $(columnRecord.sortasc).show();
                                $(columnRecord.sortdesc).hide();
                            }
                            else if (column.ascending === false) {
                                $(columnRecord.sortasc).hide();
                                $(columnRecord.sortdesc).show();
                            }
                        }
                    }
                }

                return;
            }

            if (this.sortdirection) {
                var ariaFunc = function (column, direction) {
                    var sortc = self.getcolumn(column);
                    if (sortc) {
                        if (direction.ascending) {
                            $.jqx.aria(sortc.element, "aria-sort", "ascending");
                        }
                        else if (direction.descending) {
                            $.jqx.aria(sortc.element, "aria-sort", "descending");
                        } else {
                            $.jqx.aria(sortc.element, "aria-sort", "none");
                        }
                    }
                }
                if (this._oldsortinfo) {
                    if (this._oldsortinfo.column) {
                        ariaFunc(this._oldsortinfo.column, { ascending: false, descending: false });
                    }
                }
                ariaFunc(sortcolumn, this.sortdirection);

            }
            this._oldsortinfo = { column: sortcolumn, direction: this.sortdirection };

            if (this.sortdirection) {
                $.each(this.columns.records, function (i, value) {
                    var groupingsortelements = $.data(document.body, "groupsortelements" + this.displayfield);

                    if (sortcolumn == null || this.displayfield != sortcolumn) {
                        $(this.sortasc).hide();
                        $(this.sortdesc).hide();
                        $(this.sorticon).css("visibility", "hidden");
                        $(this.sorticon).removeClass("ascending");
                        $(this.sorticon).removeClass("descending");
                        this.element.removeAttribute('sort');

                        if (groupingsortelements != null) {
                            groupingsortelements.sortasc.hide();
                            groupingsortelements.sortdesc.hide();
                        }
                    }
                    else {
                        if (self.isMaterialized() || self.isModern()) {
                            $(this.sortasc).hide();
                            $(this.sortdesc).hide();
                            $(this.sorticon).show();
                            $(this.sorticon).css("visibility", "inherit");
                            if (groupingsortelements != null) {
                                groupingsortelements.sortasc.hide();
                                groupingsortelements.sortdesc.show();
                            }

                            $(this.sorticon).removeClass("ascending");
                            $(this.sorticon).removeClass("descending");
                            if (self.sortdirection.ascending) {
                                $(this.sorticon).addClass("ascending");
                            }
                            else {
                                $(this.sorticon).addClass("descending");
                            }
                        }
                        else {
                            if (self.sortdirection.ascending) {
                                $(this.sortasc).show();
                                $(this.sortdesc).hide();
                                if (groupingsortelements != null) {
                                    groupingsortelements.sortasc.show();
                                    groupingsortelements.sortdesc.hide();
                                }
                            }
                            else {
                                $(this.sortasc).hide();
                                $(this.sortdesc).show();
                                if (groupingsortelements != null) {
                                    groupingsortelements.sortasc.hide();
                                    groupingsortelements.sortdesc.show();
                                }
                            }
                        }
                        this.element.setAttribute('sort', true);
                    }
                });
            }
        },

        getsortcolumns: function () {
            var that = this;
            var columns = [];

            for (var cacheKey in that.dataview.sortcache) {
                if (cacheKey === "data") {
                    continue;
                }

                columns.push({ dataField: cacheKey, ascending: that.dataview.sortcache[cacheKey].direction });
            }

            if (columns.length === 0) {
                for (var sortcolumn in that.sortcolumns) {
                    var direction = that.sortcolumns[sortcolumn];

                    if (direction !== null) {
                        columns.push({ dataField: sortcolumn, ascending: direction });
                    }
                }

            }

            return columns;
        },

        // gets the sort column.
        getsortcolumn: function () {
            if (this.sortcolumn != undefined) {
                return this.sortcolumn;
            }

            return null;
        },
        // removes the sorting.
        removesort: function () {
            this.sortby(null);
            if (this.sortmode === "many") {
                for (var column in this.sortcolumns) {
                    this.sortby(column, null);
                }
            }
        },

        // sorts by a column.
        sortby: function (datafield, sortdirection, comparer, refresh, checkloading) {
            if (this._loading && checkloading !== false) {
                throw new Error('jqxGrid: ' + this.loadingerrormessage);
                return false;
            }

            // clear the sorting.
            if (datafield == null) {
                sortdirection = null;
                datafield = this.sortcolumn;
            }

            if (datafield != undefined) {
                var self = this.that;
                if (comparer == undefined && self.source && self.source.sortcomparer != null) {
                    comparer = self.source.sortcomparer;
                }

                if (sortdirection === undefined) {
                    sortdirection = true;
                }

                if (sortdirection == 'a' || sortdirection == 'asc' || sortdirection == 'ascending' || sortdirection == true) {
                    var ascending = true;
                }
                else {
                    var ascending = false;
                }

                //var columnbydatafield = self.getcolumn(datafield);
                //if (columnbydatafield == undefined || columnbydatafield == null)
                //    return;

                if (sortdirection != null) {
                    self.sortdirection = { 'ascending': ascending, 'descending': !ascending };
                }
                else {
                    self.sortdirection = { 'ascending': false, 'descending': false };
                }

                if (sortdirection != null) {
                    self.sortcolumn = datafield;
                }
                else {
                    self.sortcolumn = null;
                }

                if (!self.sortcolumns) {
                    self.sortcolumns = [];
                }

                self.sortcolumns[datafield] = sortdirection;

                if (self.source && (self.source.sort || self.virtualmode)) {
                    self.dataview.sortfield = datafield;
                    if (sortdirection == null) {
                        self.dataview.sortfielddirection = "";
                    }
                    else {
                        self.dataview.sortfielddirection = ascending ? "asc" : "desc";
                    }
                    if (self.source.sort && !this._loading) {
                        self.source.sort(datafield, sortdirection, self.sortcolumns);
                        self._raiseEvent(6, { sortinformation: self.getsortinformation() });
                        return;
                    }
                }
                else {
                    self.dataview.sortby(datafield, sortdirection, comparer);
                }

                if (refresh === false) {
                    return;
                }

                // if grouping is enabled, we need to refresh the groups too.
                if (self.groupable && self.groups.length > 0) {
                    self._render(true, false, false);
                    if (self._updategroupheadersbounds && self.showgroupsheader) {
                        self._updategroupheadersbounds();
                    }
                    self._postrender("sort");
                }
                else {
                    if (self.pageable) {
                        self.dataview.updateview();
                    }
				    var verticalScrollValue = self.vScrollInstance.value;
              
                    self._updaterowsproperties();
                    self.rendergridcontent(true);
					 self.vScrollInstance.value = verticalScrollValue;
              
                    self._postrender("sort");
                }
                self._raiseEvent(6, { sortinformation: self.getsortinformation() });
            }
        },

        _togglesort: function (column) {
            var self = this.that;
            if (this.disabled) {
                return;
            }

            if (this.sortmode === "many") {
                if (column.sortable && self.sortable) {
                    var columns = self.getsortcolumns();
                    var checked = null;


                    for (var i = 0; i < columns.length; i++) {
                        var sortColumn = columns[i];
                        var dataField = column.displayfield;

                        if (dataField === sortColumn.dataField) {
                            checked = sortColumn.ascending;
                            if (self.sorttogglestates > 1) {
                                if (checked == true) {
                                    checked = false;
                                }
                                else {
                                    checked = null;
                                }
                            }
                            else {
                                checked = !checked;
                            }

                            self.sortby(column.displayfield, checked, null);

                            return;
                        }
                    }

                    self.sortby(column.displayfield, true, null);
                }

                return;
            }

            if (column.sortable && self.sortable) {
                var sortinformation = self.getsortinformation();
                var checked = null;
                if (sortinformation.sortcolumn != null && sortinformation.sortcolumn == column.displayfield) {
                    checked = sortinformation.sortdirection.ascending;
                    if (self.sorttogglestates > 1) {
                        if (checked == true) {
                            checked = false;
                        }
                        else {
                            checked = null;
                        }
                    }
                    else {
                        checked = !checked;
                    }
                }
                else {
                    checked = true;
                }

                self.sortby(column.displayfield, checked, null);
            }
        }
    });
})(jqxBaseFramework);
})();





/***/ }),

/***/ 9701:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {
    $.extend($.jqx._jqxGrid.prototype, {
        savestate: function (options) {
            if (this.loadingstate) {
                return;
            }

            var state = this.getstate();

            if (options !== undefined && !$.isEmptyObject(options)) {
                if (options.indexOf('sort') == -1) {
                    delete state.sortcolumn;
                    delete state.sortdirection;
                }
                if (options.indexOf('pager') == -1) {
                    delete state.pagenum;
                    delete state.pagesizeoptions;
                    delete state.pagesize;
                }
                if (options.indexOf('selection') == -1) {
                    delete state.selectedcells;
                    delete state.selectedrowindexes;
                    delete state.selectedrowindex;
                }
                if (options.indexOf('grouping') == -1) {
                    delete state.groups;
                }
                if (options.indexOf('filter') == -1) {
                    delete state.filters;
                }
                $.each(this.columns.records, function (index) {
                    var column_state = state.columns[this.datafield];
                    if (options.indexOf('hidden_columns') == -1) {
                        delete column_state.hidden;
                    }
                    if (options.indexOf('reorder') == -1) {
                        delete column_state.index;
                    }
                    if (options.indexOf('columns_width') == -1) {
                        delete column_state.width;
                    }
                    if (options.indexOf('columns_text') == -1) {
                        delete column_state.text;
                    }
                    if (options.indexOf('alignment') == -1) {
                        delete column_state.align;
                        delete column_state.cellsalign;
                    }
                });
            }

            if (window.localStorage) {
                window.localStorage["jqxGrid" + this.element.id] = this._stringify(state);
            }
            this._savedstate = state;
            return state;
        },

        loadstate: function (gridstate, binding) {
            var state = "";
            if (gridstate != undefined && gridstate.width != undefined) {
                state = gridstate;
            }
            else if (window.localStorage) {
                var hasState = window.localStorage["jqxGrid" + this.element.id];
                if (hasState) {
                    var state = $.parseJSON(window.localStorage["jqxGrid" + this.element.id]);
                }
            }
            else if (this._savedstate) {
                var state = this._savedstate;
            }
            if (state != null && state !== "") {
                if (this.virtualmode || (this.source._source.url && this.source._source.url != "")) {
                    this.source.beginUpdate();
                }
                var data = state;
                if (data.width !== undefined) {
                    this.width = data.width;
                }
                if (data.height !== undefined) {
                    this.height = data.height;
                }
                if (this.pageable) {
                    if (data.pagesize != undefined) {
                        this.pagesize = data.pagesize;
                        this.dataview.pagesize = data.pagesize;
                    }
                    if (data.pagenum != undefined) {
                        this.dataview.pagenum = data.pagenum;
                    }
                    if (data.pagesizeoptions != undefined) {
                        this.pagesizeoptions = data.pagesizeoptions;
                    }
                    if (this.pagesizeoptions) {
                        var selectedindex = 0;

                        for (var i = 0; i < this.pagesizeoptions.length; i++) {
                            if (this.pagesize >= this.pagesizeoptions[i]) {
                                selectedindex = i;
                            }
                        }
                        if (this.pagershowrowscombo) {
                            this.pagershowrowscombo.jqxDropDownList({ selectedIndex: selectedindex });
                        }
                    }
                }
                if (this.sortable) {
                    if (this._loading) this._loading = false;
                    if (data.sortdirection) {
                        if (data.sortdirection.ascending || data.sortdirection.descending) {
                            this.dataview.sortfield = data.sortcolumn;
                            var direction = data.sortdirection.ascending ? 'asc' : 'desc';
                            this.dataview.sortfielddirection = direction;
                            this.source.sortcolumn = data.sortcolumn;
                            this.source.sortdirection = direction;
                            this.sortby(data.sortcolumn, direction);
                        }
                    }
                    else if (this.dataview.sortfield != null && (this.dataview.sortfielddirection == 'asc' || this.dataview.sortfielddirection == 'desc')) {
                        this.sortby(this.dataview.sortfield, null);
                    }

                    if (data.sortcolumns) {
                        for (var i = 0; i < data.sortcolumns.length; i++) {
                            var sortcolumn = data.sortcolumns[i];

                            this.sortby(sortcolumn.dataField, sortcolumn.ascending);
                        }
                    }
                }
                if (this.groupable && data.groups) {
                    this.dataview.groups = data.groups;
                    this.groups = data.groups;
                }
                this.loadingstate = true;
                if (this.virtualsizeinfo) {
                    this._loadselectionandcolumnwidths(data);
                }
                this.loadingstate = false;
                if (this.virtualmode || (this.source._source.url && this.source._source.url != "")) {
                    if (binding == true) {
                        this.source.endUpdate(false);
                    }
                    else {
                        this.source.endUpdate(false);
                        if (this.virtualmode || this.source._source.filter || this.source._source.sort) {
                            this.updatebounddata("state");
                        }
                    }
                }
            }
        },

        _loadselectionandcolumnwidths: function (gridstate) {
            this.loadingstate = true;
            var state = "";

            if (gridstate != undefined && gridstate.width != undefined) {
                state = gridstate;
            }
            else if (window.localStorage) {
                if (window.localStorage["jqxGrid" + this.element.id]) {
                    var state = $.parseJSON(window.localStorage["jqxGrid" + this.element.id]);
                }
            }
            else if (this._savedstate) {
                var state = this._savedstate;
            }
            if (state != null && state != "") {
                var _tmploading = this._loading;
                this._loading = false;

                var data = state;
                var me = this;
                var requiresRender = false;
                var columnstomove = [];
                columnstomove.length = 0;
                var columnstomoveindexes = [];
                $.each(this.columns.records, function (index) {
                    var savedColumn = data.columns[this.datafield];
                    if (savedColumn != undefined) {
                        if (this.text != savedColumn.text) {
                            requiresRender = true;
                        }
                        if (this.hidden != savedColumn.hidden) {
                            requiresRender = true;
                        }

                        if (savedColumn.width !== undefined) {
                            this.width = savedColumn.width;
                            if (this._width) {
                                this._width = null;
                            }
                            if (this._percentagewidth) {
                                this._percentagewidth = null;
                            }
                        }
                        if (savedColumn.hidden !== undefined) {
                            this.hidden = savedColumn.hidden;
                        }
                        if (savedColumn.pinned !== undefined) {
                            this.pinned = savedColumn.pinned;
                        }
                        if (savedColumn.groupable !== undefined) {
                            this.groupable = savedColumn.groupable;
                        }
                        if (savedColumn.resizable !== undefined) {
                            this.resizable = savedColumn.resizable;
                        }
                        this.draggable = savedColumn.draggable;
                        if (savedColumn.text !== undefined) {
                            this.text = savedColumn.text;
                        }
                        if (savedColumn.align !== undefined) {
                            this.align = savedColumn.align;
                        }
                        if (savedColumn.cellsalign !== undefined) {
                            this.cellsalign = savedColumn.cellsalign;
                        }
                        if (me._columns) {
                            for (var j = 0; j < me._columns.length; j++) {
                                if (me._columns[j].datafield == this.datafield) {
                                    if (savedColumn.hidden !== undefined) {
                                        me._columns[j]["hidden"] = savedColumn.hidden;
                                    }
                                    if (savedColumn.width !== undefined) {
                                        me._columns[j]["width"] = savedColumn.width;
                                    }
                                }
                            }
                        }

                        if (savedColumn.index !== undefined) {
                            columnstomove[this.datafield] = savedColumn.index;
                            columnstomove.length++;
                        }
                    }
                });

                if (columnstomove.length > 0) {
                    if (this.setcolumnindex) {
                        var groupingcolumnscount = this.rowdetails ? 1 : 0;
                        groupingcolumnscount += this.groupable ? this.groups.length : 0;

                        var columnsRecords = new Array();
                        for (var i = 0; i < this.columns.records.length; i++) {
                            columnsRecords.push(this.columns.records[i]);
                        }

                        var groupedcolumns = 0;
                        var moveOrder = new Array();
                        for (var i = 0; i < columnsRecords.length; i++) {
                            var column = columnsRecords[i];
                            var index = columnstomove[column.datafield];

                            if (this.groupable && column.grouped) {
                                groupedcolumns++;
                                continue;
                            }
                            if (i == 0 && this.rowdetails) {
                                groupedcolumns++;
                                continue;
                            }

                            if (i !== index || this.groupable || this.rowdetails) {
                                var colindex = groupedcolumns + index;
                                moveOrder.push({ column: column, key: colindex });
                            }
                        }

                        moveOrder.sort(function (value1, value2) {
                            if (value1.key < value2.key) { return -1; }
                            if (value1.key > value2.key) { return 1; }
                            return 0;
                        });
                        moveOrder.reverse();

                        $.each(moveOrder, function (index, value) {
                            var columnIndex = this.key
                            me.setcolumnindex(this.column.datafield, columnIndex, false);
                        });
                    }
                    this.prerenderrequired = true;
                    if (this.groupable) {
                        this._refreshdataview();
                    }
                    this.rendergridcontent(true);

                    if (this._updatefilterrowui && this.filterable && this.showfilterrow) {
                        this._updatefilterrowui();
                    }
                    this._renderrows(this.virtualsizeinfo);
                    if (this.groupable && data.groups !== undefined) {
                        var datafields = this.source ? this.source.datafields : null;
                        if (datafields == null && this.source && this.source._source) {
                            datafields = this.source._source.datafields;
                            var self = this;

                            if (self._columns) {
                                self._columns.sort(function (value1, value2) {
                                    var index1;
                                    var index2;
                                    for (var i = 0; i < self.columns.records.length; i++) {
                                        if (self.columns.records[i].datafield === value1.datafield) {
                                            index1 = i;
                                        }
                                        if (self.columns.records[i].datafield === value2.datafield) {
                                            index2 = i;
                                        }
                                    }
                                    if (index1 < index2) {
                                        return -1;
                                    }
                                    if (index1 > index2) {
                                        return 1;
                                    }
                                    return 0;
                                });
                            }
                        }
                    }
                }

                if (this.filterable && data.filters !== undefined) {
                    if (this.clearfilters) {
                        this._loading = false;
                        this.clearfilters(false);
                    }
                    var oldcolumn = "";
                    var filtergroup = new $.jqx.filter();
                    for (var i = 0; i < data.filters.filterscount; i++) {
                        var condition = data.filters['filtercondition' + i];
                        var datafield = data.filters['filterdatafield' + i];
                        var column = this.getcolumn(datafield);
                        if (datafield != oldcolumn) {
                            filtergroup = new $.jqx.filter();
                        }

                        oldcolumn = datafield;
                        if (column && column.filterable) {
                            var value = data.filters['filtervalue' + i];
                            var operator = data.filters['filteroperator' + i];
                            var filtertype = data.filters['filtertype' + i];
                            if (filtertype == "datefilter") {
                                var filter = filtergroup.createfilter(filtertype, value, condition, null, column.cellsformat, this.gridlocalization);
                            }
                            else {
                                var filter = filtergroup.createfilter(filtertype, value, condition);
                            }
                            filtergroup.addfilter(operator, filter);

                            if (this.showfilterrow) {
                                var widget = column._filterwidget;
                                var tablecolumn = column._filterwidget.parent();
                                if (widget != null) {
                                    switch (column.filtertype) {
                                        case 'number':
                                            tablecolumn.find('input').val(value);
                                            if (this.host.jqxDropDownList) {
                                                var conditions = filtergroup.getoperatorsbyfiltertype('numericfilter');
                                                widget.find('.filter').jqxDropDownList('selectIndex', conditions.indexOf(condition));
                                            }
                                            break;
                                        case 'date':
                                            if (this.host.jqxDateTimeInput) {
                                                $(tablecolumn.children()[0]).jqxDateTimeInput('setDate', value);
                                            }
                                            else widget.val(value);
                                            break;
                                        case 'range':
                                            if (this.host.jqxDateTimeInput) {
                                                var value2 = data.filters['filtervalue' + (i + 1)];
                                                var filtertype = data.filters['filtertype' + i];
                                                var filter = filtergroup.createfilter(filtertype, value2, "LESS_THAN_OR_EQUAL");
                                                filtergroup.addfilter(operator, filter);

                                                var from = new Date(value);
                                                var to = new Date(value2);
                                                if (isNaN(from)) {
                                                    from = $.jqx.dataFormat.tryparsedate(value);
                                                }
                                                if (isNaN(to)) {
                                                    to = $.jqx.dataFormat.tryparsedate(value);
                                                }

                                                $(tablecolumn.children()[0]).jqxDateTimeInput('setRange', from, to);
                                                i++;
                                            }
                                            else widget.val(value);
                                            break;
                                        case 'textbox':
                                        case 'default':
                                            widget.val(value);
                                            me["_oldWriteText" + widget[0].id] = value;
                                            break;
                                        case 'list':
                                            if (this.host.jqxDropDownList) {
                                                var items = $(tablecolumn.children()[0]).jqxDropDownList('getItems');
                                                var index = -1;
                                                $.each(items, function (i) {
                                                    if (this.value == value) {
                                                        index = i;
                                                        return false;
                                                    }
                                                });

                                                $(tablecolumn.children()[0]).jqxDropDownList('selectIndex', index);
                                            }
                                            else widget.val(value);
                                            break;
                                        case 'checkedlist':
                                            if (!this.host.jqxDropDownList) {
                                                widget.val(value);
                                            }
                                            break;
                                        case 'bool':
                                        case 'boolean':
                                            if (!this.host.jqxCheckBox) {
                                                widget.val(value);
                                            }
                                            else $(tablecolumn.children()[0]).jqxCheckBox({ checked: value });
                                            break;
                                    }
                                }
                            }
                            this.addfilter(datafield, filtergroup);
                        }
                    }
                    if (data.filters && data.filters.filterscount > 0) {
                        this.applyfilters();
                        if (this.showfilterrow) {
                            $.each(this.columns.records, function () {
                                if (this.filtertype == 'checkedlist' && this.filterable) {
                                    if (me.host.jqxDropDownList) {
                                        var column = this;
                                        var dropdownlist = column._filterwidget;
                                        var dropdownitems = dropdownlist.jqxDropDownList('getItems');
                                        var listbox = dropdownlist.jqxDropDownList('listBox');
                                        listbox.checkAll(false);
                                        if (column.filter) {
                                            listbox.uncheckAll(false);
                                            var filters = column.filter.getfilters();

                                            for (var i = 0; i < listbox.items.length; i++) {
                                                var label = listbox.items[i].label;
                                                $.each(filters, function () {
                                                    if (this.condition == "NOT_EQUAL") return true;
                                                    if (label == this.value) {
                                                        listbox.checkIndex(i, false, false);
                                                    }
                                                });
                                            }
                                            listbox._updateCheckedItems();
                                            var checkedItemsLength = listbox.getCheckedItems().length;
                                            if (listbox.items.length != checkedItemsLength && checkedItemsLength > 0) {
                                                listbox.host.jqxListBox('indeterminateIndex', 0, true, false);
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    }

                    if (this.pageable && data.pagenum !== undefined) {
                        if (this.gotopage && !this.virtualmode) {
                            this.dataview.pagenum = -1;
                            this.gotopage(data.pagenum);
                        }
                        else if (this.gotopage && this.virtualmode) {
                            this.gotopage(data.pagenum);
                        }
                    }
                }

                if (data.selectedrowindexes && data.selectedrowindexes && data.selectedrowindexes.length > 0) {
                    this.selectedrowindexes = data.selectedrowindexes;
                    this.selectedrowindex = data.selectedrowindex;
                    if (this.selectionmode === "checkbox") {
                        this._updatecheckboxselection();
                    }
                }
                if (data.selectedcells) {
                    if (this._applycellselection) {
                        $.each(data.selectedcells, function () {
                            me._applycellselection(this.rowindex, this.datafield, true, false);
                        });
                    }
                }

                if (this.groupable && data.groups !== undefined) {
                    this._refreshdataview();
                    this.render();
                    this._loading = _tmploading;
                    this.loadingstate = false;

                    return;
                }

                if (requiresRender) {
                    this.prerenderrequired = true;
                    this.rendergridcontent(true);
                    this._loading = _tmploading;
                    this.loadingstate = false;
                    if (this.updating()) {
                        return false;
                    }
                }
                else {
                    this._loading = _tmploading;
                    this._updatecolumnwidths();
                    this._updatecellwidths();
                    this.loadingstate = false;
                }

                this.loadingstate = false;
                this._loading = _tmploading;
                this._renderrows(this.virtualsizeinfo);
            }
            this.loadingstate = false;
        },

        getstate: function () {
            var datainfo = this.getdatainformation();
            var data = {};
            data.width = this.width;
            data.height = this.height;
            data.pagenum = datainfo.paginginformation.pagenum;
            data.pagesize = datainfo.paginginformation.pagesize;
            data.pagesizeoptions = this.pagesizeoptions;
            data.sortcolumn = datainfo.sortinformation.sortcolumn;
            data.sortdirection = datainfo.sortinformation.sortdirection;

            if (this.sortmode === 'many') {
                data.sortcolumns = this.getsortcolumns();
            }
            if (this.selectionmode != null) {
                if (this.getselectedcells) {
                    if (this.selectionmode.toString().indexOf('cell') != -1) {
                        var selectedcells = this.getselectedcells();
                        var cells = new Array();
                        $.each(selectedcells, function () {
                            cells.push({ datafield: this.datafield, rowindex: this.rowindex });
                        });
                        data.selectedcells = cells;
                    }
                    else {
                        var selectedrowindexes = this.getselectedrowindexes();
                        data.selectedrowindexes = selectedrowindexes;
                        data.selectedrowindex = this.selectedrowindex;
                    }
                }
            }
            var postdata = {};
            var filterslength = 0;
            if (this.dataview.filters) {
                for (var x = 0; x < this.dataview.filters.length; x++) {
                    var filterdatafield = this.dataview.filters[x].datafield;
                    var filter = this.dataview.filters[x].filter;
                    var filters = filter.getfilters();
                    postdata[filterdatafield + "operator"] = filter.operator;
                    for (var m = 0; m < filters.length; m++) {
                        filters[m].datafield = filterdatafield;
                        if (filters[m].type == "datefilter") {
                            if (filters[m].value && filters[m].value.toLocaleString) {
                                var column = this.getcolumn(filters[m].datafield);
                                if (column.cellsformat) {
                                    var value = this.source.formatDate(filters[m].value, column.cellsformat, this.gridlocalization);
                                    if (value) {
                                        postdata["filtervalue" + filterslength] = value;
                                    }
                                    else {
                                        postdata["filtervalue" + filterslength] = filters[m].value.toLocaleString();
                                    }
                                }
                                else {
                                    postdata["filtervalue" + filterslength] = filters[m].value.toLocaleString();
                                }
                            }
                            else {
                                postdata["filtervalue" + filterslength] = filters[m].value;
                            }
                        }
                        else {
                            postdata["filtervalue" + filterslength] = filters[m].value;
                        }
                        postdata["filtercondition" + filterslength] = filters[m].condition;
                        postdata["filteroperator" + filterslength] = filters[m].operator;
                        postdata["filterdatafield" + filterslength] = filterdatafield;
                        postdata["filtertype" + filterslength] = filters[m].type;

                        filterslength++;
                    }
                }
            }
            postdata.filterscount = filterslength;
            data.filters = postdata;
            data.groups = this.groups;
            //if (this.groupable && this.groups.length > 0) {
            //    var me = this;
            //    var groupstates = [];
            //    $.each(this.dataview.loadedgroups, function () {
            //        var groupstate = me._findgroupstate(this.uniqueid);
            //        groupstates[this.group] = groupstate;
            //    });
            //    data.groupstates = groupstates;
            //}

            data.columns = {};
            var columnindex = 0;
            if (this.columns.records) {
                $.each(this.columns.records, function (index, value) {
                    if (!this.datafield) {
                        return true;
                    }

                    var columndata = {};
                    columndata.width = this.width;
                    if (this._percentagewidth) {
                        columndata.width = this._percentagewidth;
                    }
                    columndata.hidden = this.hidden;
                    columndata.pinned = this.pinned;
                    columndata.groupable = this.groupable;
                    columndata.resizable = this.resizable;
                    columndata.draggable = this.draggable;
                    columndata.text = this.text;
                    columndata.align = this.align;
                    columndata.cellsalign = this.cellsalign;
                    columndata.index = columnindex++;
                    data.columns[this.datafield] = columndata;
                });
            }
            return data;
        },

        _stringify: function (value) {
            if (window.JSON && typeof window.JSON.stringify === 'function') {
                var me = this;
                var json = "";
                try {
                    json = window.JSON.stringify(value);
                }
                catch (error) {
                    return me._str("", { "": value })
                }
                return json;
            }

            var json = this._str("", { "": value })
            return json;
        },

        _quote: function (string) {
            var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                meta = {
                    '\b': '\\b',
                    '\t': '\\t',
                    '\n': '\\n',
                    '\f': '\\f',
                    '\r': '\\r',
                    '"': '\\"',
                    '\\': '\\\\'
                };

            return '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"';
        },


        _stringifyArray: function (value) {
            var len = value.length,
                partial = [],
                i;
            for (var i = 0; i < len; i++) {
                partial.push(this._str(i, value) || 'null');
            }

            return '[' + partial.join(',') + ']';
        },

        _stringifyObject: function (value) {
            var partial = [],
                i, v;
            var me = this;
            for (i in value) {
                if (Object.prototype.hasOwnProperty.call(value, i)) {
                    v = me._str(i, value);
                    if (v) {
                        partial.push(me._quote(i) + ':' + v);
                    }
                }
            }
            return '{' + partial.join(',') + '}';
        },

        _stringifyReference: function (value) {
            switch (Object.prototype.toString.call(value)) {
                case '[object Array]':
                    return this._stringifyArray(value);
            }
            return this._stringifyObject(value);
        },

        _stringifyPrimitive: function (value, type) {
            switch (type) {
                case 'string':
                    return this._quote(value);
                case 'number':
                    return isFinite(value) ? value : 'null';
                case 'boolean':
                    return value;
            }
            return 'null';
        },

        _str: function (key, holder) {
            var value = holder[key], type = typeof value;

            if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
                value = value.toJSON(key);
                type = typeof value;
            }
            if (/(number|string|boolean)/.test(type) || (!value && type === 'object')) {
                return this._stringifyPrimitive(value, type);
            } else {
                return this._stringifyReference(value);
            }
        }
    });
})(jqxBaseFramework);
})();



/***/ }),

/***/ 1062:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {

    $.jqx.jqxWidget("jqxListBox", "", {});

    $.extend($.jqx._jqxListBox.prototype, {
        defineInstance: function () {
            var settings = {
                // Type: Boolean
                // Default: true
                // enables/disables the listbox.
                disabled: false,
                // Type: Boolean
                // Default: 16
                // Gets or sets the checkbox size.
                checkboxSize: 16,
                // Type: Boolean
                // Default: false
                // Gets or sets whether the listbox should display a checkbox next to each item.
                checkboxes: false,
                // gets or sets the listbox width.
                width: null,
                // gets or sets the listbox height.
                height: null,
                // Represents the collection of list items.
                items: new Array(),
                // Type: Boolean
                // Default: false
                // enables/disables the multiple selection.
                multiple: false,
                // Gets or sets the selected index.
                selectedIndex: -1,
                // Gets the selected item indexes.
                selectedIndexes: new Array(),
                // Type: Object
                // Default: null
                // data source.
                source: null,
                // Type: Number
                // Default: 15
                // gets or sets the scrollbars size.
                scrollBarSize: $.jqx.utilities.scrollBarSize,
                // Type: Boolean
                // Default: true
                // enables/disables the hover state.
                enableHover: true,
                // Type: Boolean
                // Default: true
                // enables/disables the selection.
                enableSelection: true,
                // gets the visible items. // this property is internal for the listbox.
                visualItems: new Array(),
                // gets the groups. // this property is internal for the listbox.
                groups: new Array(),
                // Type: Boolean
                // Default: true
                // gets or sets whether the items width should be equal to the listbox's width.
                equalItemsWidth: true,
                // gets or sets the height of the ListBox Items. When the itemHeight == - 1, each item's height is equal to its desired height.
                itemHeight: -1,
                // this property is internal for the listbox.
                visibleItems: new Array(),
                // Type: String
                // Default: Group
                // represents the text of the empty group. This is displayed only when the items are not loaded from html select element.
                emptyGroupText: 'Group',
                // Type: Boolean
                // Default: false
                // Gets or sets whether the listbox checkboxes have three states - checked, unchecked and indeterminate.
                hasThreeStates: false,
                // Type: Boolean
                // Default: false
                // Gets or sets whether the listbox's height is equal to the sum of its items height
                autoHeight: false,
                autoItemsHeight: false,
                // represents the listbox's events.
                // Type: Boolean
                // Default: true
                // Gets or sets whether the listbox items are with rounded corners.
                roundedcorners: true,
                touchMode: 'auto',
                displayMember: "",
                groupMember: "",
                valueMember: "",
                searchMember: "",
                // Type: String
                // Default: startswithignorecase
                // Possible Values: 'none, 'contains', 'containsignorecase', 'equals', 'equalsignorecase', 'startswithignorecase', 'startswith', 'endswithignorecase', 'endswith'
                searchMode: 'startswithignorecase',
                incrementalSearch: true,
                incrementalSearchDelay: 1000,
                incrementalSearchKeyDownDelay: 300,
                allowDrag: false,
                allowDrop: true,
                // Possible values: 'none, 'default', 'copy'
                dropAction: 'default',
                touchModeStyle: 'auto',
                keyboardNavigation: true,
                enableMouseWheel: true,
                multipleextended: false,
                selectedValues: new Array(),
                emptyString: "",
                rtl: false,
                rendered: null,
                renderer: null,
                dragStart: null,
                dragEnd: null,
                focusable: true,
                ready: null,
                _checkForHiddenParent: true,
                autoBind: true,
                _renderOnDemand: false,
                filterable: false,
                filterHeight: 30,
                filterPlaceHolder: "Looking for",
                filterDelay: 100,
                filterChange: null,
                aria:
                {
                    "aria-disabled": { name: "disabled", type: "boolean" }
                },
                events:
                    [
                        // triggered when the user selects an item.
                        'select',
                        // triggered when the user unselects an item.
                        'unselect',
                        // triggered when the selection is changed.
                        'change',
                        // triggered when the user checks or unchecks an item.
                        'checkChange',
                        // triggered when the user drags an item.
                        'dragStart',
                        // triggered when the user drops an item.
                        'dragEnd',
                        // triggered when the binding is completed.
                        'bindingComplete',
                        // triggered when a new item is added.
                        'itemAdd',
                        // triggered when a new item is removed.
                        'itemRemove',
                        // triggered when a new item is updated.
                        'itemUpdate'
                    ]
            }
            if (this === $.jqx._jqxListBox.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        createInstance: function (args) {
            var self = this;
            if ($.jqx.utilities.scrollBarSize != 15) {
                self.scrollBarSize = $.jqx.utilities.scrollBarSize;
            }
            if (self.width == null) self.width = 200;
            if (self.height == null) self.height = 200;

            if (self.isMaterialized()) {
                var gridStyle = window.getComputedStyle(self.element);
                var rowHeight = gridStyle.getPropertyValue('--jqx-list-item-height');

                if (rowHeight && this.itemHeight === -1) {
                    this.itemHeight = parseInt(rowHeight);
                }
            }
            self.renderListBox();
            var that = self;
            $.jqx.utilities.resize(self.host, function () {
                that._updateSize();
            }, false, self._checkForHiddenParent);
        },

        resize: function (width, height) {
            this.width = width;
            this.height = height;
            this._updateSize();
        },

        render: function () {
            this.renderListBox();
            this.refresh();
        },

        renderListBox: function () {
            var self = this;
            var nodeName = self.element.nodeName.toLowerCase();
            if (nodeName == "select" || nodeName == "ul" || nodeName == "ol") {
                self.field = self.element;
                if (self.field.className) {
                    self._className = self.field.className;
                }

                var properties = {
                    'title': self.field.title
                };

                if (self.field.id.length) {
                    properties.id = self.field.id.replace(/[^\w]/g, '_') + "_jqxListBox";
                }
                else {
                    properties.id = $.jqx.utilities.createId() + "_jqxListBox";
                }

                var wrapper = $("<div></div>", properties);
                if (!self.width) {
                    self.width = $(self.field).width();
                }
                if (!self.height) {
                    self.height = $(self.field).outerHeight();
                }
                self.element.style.cssText = self.field.style.cssText;
                $(self.field).hide().after(wrapper);
                var data = self.host.data();
                self.host = wrapper;
                self.host.data(data);
                self.element = wrapper[0];
                self.element.id = self.field.id;
                self.field.id = properties.id;
                if (self._className) {
                    self.host.addClass(self._className);
                    $(self.field).removeClass(self._className);
                }

                if (self.field.tabIndex) {
                    var tabIndex = self.field.tabIndex;
                    self.field.tabIndex = -1;
                    self.element.tabIndex = tabIndex;
                }
            }
            else {
                if (self.host.find('li').length > 0 || self.host.find('option').length > 0) {
                    var result = $.jqx.parseSourceTag(self.element);
                    self.source = result.items;
                }
            }

            self.element.innerHTML = "";
            var self = self;

            var className = self.element.className;

            className += " " + self.toThemeProperty("jqx-listbox");
            className += " " + self.toThemeProperty("jqx-reset");
            className += " " + self.toThemeProperty("jqx-rc-all");
            className += " " + self.toThemeProperty("jqx-widget");
            className += " " + self.toThemeProperty("jqx-widget-content");

            self.element.className = className;

            var isPercentage = false;

            var computedStyle = window.getComputedStyle(this.element);
            var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
            var boxSizing = computedStyle.boxSizing;

            if (this.element.offsetWidth === 0) {
                borderSize = 2;
            }

            if (boxSizing === 'border-box' || isNaN(borderSize)) {
                borderSize = 0;
            }

            if (self.width != null && self.width.toString().indexOf("%") != -1) {
                self.host.width(self.width);
                if (borderSize > 0) {
                    this.host.css('box-sizing', 'border-box');
                }
                isPercentage = true;
            }
            if (self.height != null && self.height.toString().indexOf("%") != -1) {
                self.host.height(self.height);
                if (self.host.height() == 0) {
                    self.host.height(200);
                }
                isPercentage = true;
            }
            if (self.width != null && self.width.toString().indexOf("px") != -1) {
                self.element.style.width = parseInt(self.width) - borderSize + 'px';
            }
            else
                if (self.width != undefined && !isNaN(self.width)) {
                    self.element.style.width = parseInt(self.width) - borderSize + 'px';
                };

            if (self.height != null && self.height.toString().indexOf("px") != -1) {
                self.element.style.height = parseInt(self.height) - borderSize + 'px';
            }
            else if (self.height != undefined && !isNaN(self.height)) {
                self.element.style.height = parseInt(self.height) - borderSize + 'px';
            };

            if (self.multiple || self.multipleextended || self.checkboxes) {
                $.jqx.aria(self, "aria-multiselectable", true);
            }
            else {
                $.jqx.aria(self, "aria-multiselectable", false);
            }

            var listBoxStructure = "<div style='-webkit-appearance: none; background: transparent; outline: none; width:100%; height: 100%; align:left; border: 0px; padding: 0px; margin: 0px; left: 0px; top: 0px; valign:top; position: relative;'>" +
                "<div style='-webkit-appearance: none; border: none; background: transparent; outline: none; width:100%; height: 100%; padding: 0px; margin: 0px; align:left; left: 0px; top: 0px; valign:top; position: relative;'>" +
                "<div id='filter" + self.element.id + "' style='display: none; visibility: inherit; align:left; valign:top; left: 0px; top: 0px; position: absolute;'><input style='position: absolute;'/></div>" +
                "<div id='listBoxContent' style='-webkit-appearance: none; border: none; background: transparent; outline: none; border: none; padding: 0px; overflow: hidden; margin: 0px; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='verticalScrollBar" + self.element.id + "' style='visibility: inherit; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='horizontalScrollBar" + self.element.id + "' style='visibility: inherit; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='bottomRight' style='align:left; valign:top; left: 0px; top: 0px; border: none; position: absolute;'/>" +
                "</div>" +
                "</div>";

            self.host.attr('role', 'listbox');

            self.element.innerHTML = listBoxStructure;
            if (self._checkForHiddenParent) {
                self._addInput();
                if (!self.host.attr('tabIndex')) {
                    self.host.attr('tabIndex', 1);
                }
            }
            self.filter = $(self.element.firstChild.firstChild.firstChild);
            self.filterInput = $(self.filter[0].firstChild);
            self.filterInput.attr('placeholder', self.filterPlaceHolder);
            self.filterInput.addClass(self.toThemeProperty('jqx-widget jqx-listbox-filter-input jqx-input jqx-rc-all'));

            self.addHandler(self.filterInput, 'keyup.textchange', function (event) {
                if (event.keyCode == 13) {
                    self._search(event);
                }
                else {
                    if (self.filterDelay > 0) {
                        if (self._filterTimer)
                            clearTimeout(self._filterTimer);

                        self._filterTimer = setTimeout(function () {
                            self._search(event);
                        }, self.filterDelay);
                    }
                }

                event.stopPropagation();
            });

            var verticalScrollBar = $(self.element.firstChild.firstChild.firstChild.nextSibling.nextSibling);
            if (!self.host.jqxButton) {
                throw new Error('jqxListBox: Missing reference to jqxbuttons.js.');
                return;
            }
            if (!verticalScrollBar.jqxScrollBar) {
                throw new Error('jqxListBox: Missing reference to jqxscrollbar.js.');
                return;
            }

            var largestep = parseInt(self.host.height()) / 2;
            if (largestep == 0) largestep = 10;

            self.vScrollBar = verticalScrollBar.jqxScrollBar({ _initialLayout: true, 'vertical': true, rtl: self.rtl, theme: self.theme, touchMode: self.touchMode, largestep: largestep });
            var horizontalScrollBar = $(self.element.firstChild.firstChild.firstChild.nextSibling.nextSibling.nextSibling);
            self.hScrollBar = horizontalScrollBar.jqxScrollBar({ _initialLayout: true, 'vertical': false, rtl: self.rtl, touchMode: self.touchMode, theme: self.theme });

            self.content = $(self.element.firstChild.firstChild.firstChild.nextSibling);
            self.content.addClass(self.toThemeProperty('jqx-listbox-content-element'));
            self.content[0].id = 'listBoxContent' + self.element.id;
            self.bottomRight = $(self.element.firstChild.firstChild.firstChild.nextSibling.nextSibling.nextSibling.nextSibling).addClass(self.toThemeProperty('jqx-listbox-bottomright')).addClass(self.toThemeProperty('jqx-scrollbar-state-normal'));
            self.bottomRight[0].id = "bottomRight" + self.element.id;
            self.vScrollInstance = $.data(self.vScrollBar[0], 'jqxScrollBar').instance;
            self.hScrollInstance = $.data(self.hScrollBar[0], 'jqxScrollBar').instance;
            if (self.isTouchDevice()) {
                if (!($.jqx.browser.msie && $.jqx.browser.version < 9)) {
                    var overlayContent = $("<div class='overlay' unselectable='on' style='z-index: 99; -webkit-appearance: none; border: none; background: black; opacity: 0.01; outline: none; border: none; padding: 0px; overflow: hidden; margin: 0px; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>");
                    self.content.parent().append(overlayContent);
                    self.overlayContent = self.host.find('.overlay');
                    if (self.filterable) {
                        self.overlayContent.css('top', '30px');
                    }
                }
            }
            self._updateTouchScrolling();

            self.host.addClass('jqx-disableselect');
            if (self.host.jqxDragDrop) {
                window.jqxListBoxDragDrop();
            }
        },

        _highlight: function (label, searchstring) {
            var query = searchstring.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&')
            return label.replace(new RegExp('(' + query + ')', 'ig'), function ($1, match) {
                return '<b>' + match + '</b>'
            });
        },

        _addInput: function () {
            var name = this.host.attr('name');
            if (name) {
                this.host.attr('name', "");
            }

            this.input = $("<input type='hidden'/>");
            this.host.append(this.input);
            this.input.attr('name', name);
        },

        _updateTouchScrolling: function () {
            var self = this;
            if (this.isTouchDevice()) {
                self.enableHover = false;
                var element = this.overlayContent ? this.overlayContent : this.content;

                this.removeHandler($(element), $.jqx.mobile.getTouchEventName('touchstart') + '.touchScroll');
                this.removeHandler($(element), $.jqx.mobile.getTouchEventName('touchmove') + '.touchScroll');
                this.removeHandler($(element), $.jqx.mobile.getTouchEventName('touchend') + '.touchScroll');
                this.removeHandler($(element), 'touchcancel.touchScroll');

                $.jqx.mobile.touchScroll(element, self.vScrollInstance.max, function (left, top) {
                    if (top != null && self.vScrollBar.css('visibility') != 'hidden') {
                        var oldValue = self.vScrollInstance.value;
                        self.vScrollInstance.setPosition(top);
                        self._lastScroll = new Date();
                    }
                    if (left != null && self.hScrollBar.css('visibility') != 'hidden') {
                        var oldValue = self.hScrollInstance.value;
                        self.hScrollInstance.setPosition(left);
                        self._lastScroll = new Date();
                    }
                }, this.element.id, this.hScrollBar, this.vScrollBar);

                if (self.vScrollBar.css('visibility') != 'visible' && self.hScrollBar.css('visibility') != 'visible') {
                    $.jqx.mobile.setTouchScroll(false, this.element.id);
                }
                else {
                    $.jqx.mobile.setTouchScroll(true, this.element.id);
                }
                this._arrange();
            }
        },

        isTouchDevice: function () {
            var isTouchDevice = $.jqx.mobile.isTouchDevice();
            if (this.touchMode == true) {
                if (this.touchDevice)
                    return true;

                if ($.jqx.browser.msie && $.jqx.browser.version < 9)
                    return false;

                this.touchDevice = true;
                isTouchDevice = true;
                $.jqx.mobile.setMobileSimulator(this.element);
            }
            else if (this.touchMode == false) {
                isTouchDevice = false;
            }
            if (isTouchDevice && this.touchModeStyle != false) {
                this.scrollBarSize = $.jqx.utilities.touchScrollBarSize;
            }
            if (isTouchDevice) {
                this.host.addClass(this.toThemeProperty('jqx-touch'));
            }

            return isTouchDevice;
        },

        beginUpdate: function () {
            this.updatingListBox = true;
        },

        endUpdate: function () {
            this.updatingListBox = false;
            if ((this.allowDrag && this._enableDragDrop) || (this.virtualSize && this.virtualSize.height < 10 + this.host.height())) {
                this._addItems(true);
            }
            else {
                this._addItems(false);
            }
            this._renderItems();
            if (this.allowDrag && this._enableDragDrop) {
                this._enableDragDrop();
            }
        },

        beginUpdateLayout: function () {
            this.updating = true;
        },

        resumeUpdateLayout: function () {
            this.updating = false;
            this.vScrollInstance.value = 0;
            this._render(false);
        },

        propertiesChangedHandler: function (object, key, value) {
            if (value.width && value.height && Object.keys(value).length == 2) {
                object._cachedItemHtml = new Array();
                object.refresh();
            }
        },

        propertyChangedHandler: function (object, key, oldvalue, value) {
            if (this.isInitialized == undefined || this.isInitialized == false)
                return;

            if (oldvalue == value)
                return;

            if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                return;
            }

            if (key == "_renderOnDemand") {
                object._render(false, true);
                if (object.selectedIndex != -1) {
                    var tmpIndex = object.selectedIndex;
                    object.selectedIndex = -1;
                    object._stopEvents = true;
                    object.selectIndex(tmpIndex, false, true);
                    if (object.selectedIndex == -1) {
                        object.selectedIndex = tmpIndex;
                    }
                    object._stopEvents = false;
                }
            }

            if (key == "filterable") {
                object.refresh();
            }

            if (key == "filterHeight") {
                object._arrange();
            }

            if (key == "filterPlaceHolder") {
                object.filterInput.attr('placeholder', value);
            }

            if (key == "renderer") {
                object._cachedItemHtml = new Array();
                object.refresh();
            }

            if (key == "itemHeight" || key === "checkboxSize") {
                object.refresh();
            }

            if (key == 'source' || key == 'checkboxes') {
                if (value == null && oldvalue && oldvalue.unbindBindingUpdate) {
                    oldvalue.unbindBindingUpdate(object.element.id);
                    oldvalue.unbindDownloadComplete(object.element.id);
                }

                object.clearSelection();
                object.refresh();
            }

            if (key == 'scrollBarSize' || key == 'equalItemsWidth') {
                if (value != oldvalue) {
                    object._updatescrollbars();
                }
            }

            if (key == 'disabled') {
                object._renderItems();
                object.vScrollBar.jqxScrollBar({ disabled: value });
                object.hScrollBar.jqxScrollBar({ disabled: value });
            }

            if (key == "touchMode" || key == "rtl") {
                object._removeHandlers();
                object.vScrollBar.jqxScrollBar({ touchMode: value });
                object.hScrollBar.jqxScrollBar({ touchMode: value });
                if (key == "touchMode") {
                    if (!($.jqx.browser.msie && $.jqx.browser.version < 9)) {
                        var overlayContent = $("<div class='overlay' unselectable='on' style='z-index: 99; -webkit-appearance: none; border: none; background: black; opacity: 0.01; outline: none; border: none; padding: 0px; overflow: hidden; margin: 0px; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>");
                        object.content.parent().append(overlayContent);
                        object.overlayContent = object.host.find('.overlay');
                    }
                }
                if (object.filterable && object.filterInput) {
                    if (key == "rtl" && value) {
                        object.filterInput.addClass(object.toThemeProperty('jqx-rtl'));
                    }
                    else if (key == "rtl" && !value) {
                        object.filterInput.removeClass(object.toThemeProperty('jqx-rtl'));
                    }
                    object._arrange();
                }

                object._updateTouchScrolling();
                object._addHandlers();
                object._render(false);
            }

            if (!this.updating) {
                if (key == "width" || key == "height") {
                    object._updateSize();
                }
            }

            if (key == 'theme') {
                if (oldvalue != value) {
                    object.hScrollBar.jqxScrollBar({ theme: object.theme });
                    object.vScrollBar.jqxScrollBar({ theme: object.theme });
                    object.host.removeClass();
                    object.host.addClass(object.toThemeProperty("jqx-listbox"));
                    object.host.addClass(object.toThemeProperty("jqx-widget"));
                    object.host.addClass(object.toThemeProperty("jqx-widget-content"));
                    object.host.addClass(object.toThemeProperty("jqx-reset"));
                    object.host.addClass(object.toThemeProperty("jqx-rc-all"));
                    object.refresh();
                }
            }

            if (key == 'selectedIndex') {
                object.clearSelection();
                object.selectIndex(value, true);
            }

            if (key == "displayMember" || key == "valueMember") {
                if (oldvalue != value) {
                    var oldSelectedIndex = object.selectedIndex;
                    object.refresh();
                    object.selectedIndex = oldSelectedIndex;
                    object.selectedIndexes[oldSelectedIndex] = oldSelectedIndex;
                }
                object._renderItems();
            }

            if (key == 'autoHeight') {
                if (oldvalue != value) {
                    object._render(false);
                }
                else {
                    object._updatescrollbars();
                    object._renderItems();
                }
            }
            if (object._checkForHiddenParent && $.jqx.isHidden(object.host)) {
                $.jqx.utilities.resize(this.host, function () {
                    object._updateSize();
                }, false, object._checkForHiddenParent);
            }
        },

        loadFromSelect: function (id) {
            if (id == null)
                return;

            var searchElementId = '#' + id;
            var selectElement = $(searchElementId);
            if (selectElement.length > 0) {
                var result = $.jqx.parseSourceTag(selectElement[0]);
                var optionItems = result.items;
                var selectedOption = result.index;
                this.source = optionItems;
                this.fromSelect = true;
                this.clearSelection();
                this.selectedIndex = selectedOption;
                this.selectedIndexes[this.selectedIndex] = this.selectedIndex;
                this.refresh();
            }
        },

        invalidate: function () {
            this._cachedItemHtml = [];
            this._renderItems();
            this.virtualSize = null;
            this._updateSize();
        },

        refresh: function (initialRefresh) {
            var me = this;
            if (this.vScrollBar == undefined) {
                return;
            }

            this.itemHeight = parseInt(this.itemHeight);
            this._cachedItemHtml = [];
            this.visibleItems = new Array();
            var selectInitialItem = function (initialRefresh) {
                if (initialRefresh == true) {
                    if (me.selectedIndex != -1) {
                        var tmpIndex = me.selectedIndex;
                        me.selectedIndex = -1;
                        me._stopEvents = true;
                        me.selectIndex(tmpIndex, false, true);
                        if (me.selectedIndex == -1) {
                            me.selectedIndex = tmpIndex;
                        }
                        me._stopEvents = false;
                    }
                }
            }
            if (this.itemswrapper != null) {
                this.itemswrapper.remove();
                this.itemswrapper = null;
            }
            if ($.jqx.dataAdapter && this.source != null && this.source._source) {

                this.databind(this.source, initialRefresh);
                selectInitialItem(initialRefresh);
                return;
            }
            if (this.autoBind || (!this.autoBind && !initialRefresh)) {
                if (this.field) {
                    this.loadSelectTag();
                }
                this.items = this.loadItems(this.source);
            }

            this._render(false, initialRefresh == true);
            selectInitialItem(initialRefresh);
            this._raiseEvent('6');
        },

        loadSelectTag: function () {
            var result = $.jqx.parseSourceTag(this.field);
            this.source = result.items;
            if (this.selectedIndex == -1)
                this.selectedIndex = result.index;
        },

        _render: function (ensurevisible, initialRefresh) {
            if (this._renderOnDemand) {
                this.visibleItems = new Array();
                this.renderedVisibleItems = new Array();
                this._renderItems();
                return;
            }

            this._addItems();
            this._renderItems();
            this.vScrollInstance.setPosition(0);
            this._cachedItemHtml = new Array();
            if (ensurevisible == undefined || ensurevisible) {
                if (this.items != undefined && this.items != null) {
                    if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {
                        this.selectIndex(this.selectedIndex, true, true, true);
                    }
                }
            }

            if (this.allowDrag && this._enableDragDrop) {
                this._enableDragDrop();
                if (this.isTouchDevice()) {
                    this._removeHandlers();
                    if (this.overlayContent) {
                        this.overlayContent.remove();
                        this.overlayContent = null;
                    }
                    this._updateTouchScrolling();
                    this._addHandlers();
                    return;
                }
            }
            this._updateTouchScrolling();
            if (this.rendered) {
                this.rendered();
            }
            if (this.ready) {
                this.ready();
            }
        },

        _hitTest: function (hitLeft, hitTop) {
            if (this.filterable) {
                hitTop -= this.filterHeight;
                if (hitTop < 0) hitTop = 0;
            }

            var top = parseInt(this.vScrollInstance.value);
            var firstIndex = this._searchFirstVisibleIndex(hitTop + top, this.renderedVisibleItems)
            if (this.renderedVisibleItems[firstIndex] != undefined && this.renderedVisibleItems[firstIndex].isGroup)
                return null;

            if (this.renderedVisibleItems.length > 0) {
                var lastItem = this.renderedVisibleItems[this.renderedVisibleItems.length - 1];
                if (lastItem.height + lastItem.top < hitTop + top) {
                    return null;
                }
            }

            firstIndex = this._searchFirstVisibleIndex(hitTop + top)
            return this.visibleItems[firstIndex];

            return null;
        },

        _searchFirstVisibleIndex: function (value, collection) {
            if (value == undefined) {
                value = parseInt(this.vScrollInstance.value);
            }
            var min = 0;
            if (collection == undefined || collection == null) {
                collection = this.visibleItems;
            }

            var max = collection.length;
            while (min <= max) {
                var mid = parseInt((min + max) / 2)
                var item = collection[mid];
                if (item == undefined)
                    break;

                if (item.initialTop > value && item.initialTop + item.height > value) {
                    max = mid - 1;
                } else if (item.initialTop < value && item.initialTop + item.height <= value) {
                    min = mid + 1;
                } else {
                    return mid;
                    break;
                }
            }

            return 0;
        },

        _renderItems: function () {
            if (this.items == undefined || this.items.length == 0) {
                this.visibleItems = new Array();
                return;
            }

            if (this.updatingListBox == true)
                return;

            var touchDevice = this.isTouchDevice();
            var vScrollInstance = this.vScrollInstance;
            var hScrollInstance = this.hScrollInstance;
            var top = parseInt(vScrollInstance.value);
            var left = parseInt(hScrollInstance.value);
            if (this.rtl) {
                if (this.hScrollBar[0].style.visibility != 'hidden') {
                    left = hScrollInstance.max - left;
                }
            }

            var itemsLength = this.items.length;
            var hostWidth = this.host.width();
            var contentWidth = parseInt(this.content[0].style.width);
            var width = contentWidth + parseInt(hScrollInstance.max);
            var vScrollBarWidth = parseInt(this.vScrollBar[0].style.width) + 2;
            if (this.vScrollBar[0].style.visibility == 'hidden') {
                vScrollBarWidth = 0;
            }

            if (this.hScrollBar[0].style.visibility != 'visible') {
                width = contentWidth;
            }
            var virtualItemsCount = this._getVirtualItemsCount();
            var renderCollection = new Array();
            var y = 0;
            var hostHeight = parseInt(this.element.style.height) + 2;
            if (this.element.style.height.indexOf('%') != -1) {
                hostHeight = this.host.outerHeight();
            }

            if (isNaN(hostHeight)) {
                hostHeight = 0;
            }
            var maxWidth = 0;
            var visibleIndex = 0;
            var renderIndex = 0;

            if (vScrollInstance.value == 0 || this.visibleItems.length == 0) {
                for (var indx = 0; indx < this.items.length; indx++) {
                    var item = this.items[indx];
                    if (item.visible) {
                        item.top = -top;
                        item.initialTop = -top;
                        if (!item.isGroup && item.visible) {
                            this.visibleItems[visibleIndex++] = item;
                            item.visibleIndex = visibleIndex - 1;
                        }

                        this.renderedVisibleItems[renderIndex++] = item;

                        item.left = -left;
                        var bottom = item.top + item.height;
                        if (bottom >= 0 && item.top - item.height <= hostHeight) {
                            renderCollection[y++] = { index: indx, item: item };
                        }

                        top -= item.height;
                        top--;
                    }
                }
            }
            var firstIndex = top > 0 ? this._searchFirstVisibleIndex(this.vScrollInstance.value, this.renderedVisibleItems) : 0;
            var initialHeight = 0;
            y = 0;
            var scrollValue = this.vScrollInstance.value;
            var iterations = 0;
            while (initialHeight < 100 + hostHeight) {
                var item = this.renderedVisibleItems[firstIndex];
                if (item == undefined)
                    break;
                if (item.visible) {
                    item.left = -left;
                    var bottom = item.top + item.height - scrollValue;
                    if (bottom >= 0 && item.initialTop - scrollValue - item.height <= 2 * hostHeight) {
                        renderCollection[y++] = { index: firstIndex, item: item };
                    }
                }

                firstIndex++;
                if (item.visible) {
                    initialHeight += item.initialTop - scrollValue + item.height - initialHeight;
                }
                iterations++;
                if (iterations > this.items.length - 1)
                    break;
            }
            if (this._renderOnDemand) {
                return;
            }

            var listItemNormalClass = this.toThemeProperty('jqx-listitem-state-normal') + ' ' + this.toThemeProperty('jqx-item');
            var listItemGroupClass = this.toThemeProperty('jqx-listitem-state-group');
            var listItemDisabledClass = this.toThemeProperty('jqx-listitem-state-disabled') + ' ' + this.toThemeProperty('jqx-fill-state-disabled');

            if (this.checkboxes) {
                listItemNormalClass += ' ' + 'checkboxes';
            }

            var middle = 0;
            var me = this;
            for (var indx = 0; indx < this.visualItems.length; indx++) {
                var itemElement = this.visualItems[indx];
                var hideItem = function () {
                    var spanElement = itemElement[0].firstChild; // itemElement.find('#spanElement');
                    if (me.checkboxes) {
                        spanElement = itemElement[0].lastChild;
                    }

                    if (spanElement != null) {
                        spanElement.style.visibility = 'hidden';
                        spanElement.className = "";
                    }

                    if (me.checkboxes) {
                        var checkbox = itemElement[0].firstChild;
                        checkbox.style.visibility = "hidden";
                    }
                }

                if (indx < renderCollection.length) {
                    var item = renderCollection[indx].item;
                    if (item.initialTop - scrollValue >= hostHeight) {
                        hideItem();
                        continue;
                    }

                    var spanElement = $(itemElement[0].firstChild); // itemElement.find('#spanElement');
                    if (this.checkboxes) {
                        spanElement = $(itemElement[0].lastChild);
                    }

                    if (spanElement.length == 0)
                        continue;

                    if (spanElement[0] == null) continue;
                    spanElement[0].className = "";
                    spanElement[0].style.display = "block";
                    spanElement[0].style.visibility = "inherit";
                    var classNameBuilder = "";
                    //                    spanElement.css({ 'display': 'block', 'visibility': 'inherit' });

                    if (!item.isGroup && !this.selectedIndexes[item.index] >= 0) {
                        classNameBuilder = listItemNormalClass;
                        //spanElement.addClass(listItemNormalClass);
                    }
                    else {
                        classNameBuilder = listItemGroupClass;
                        //spanElement.addClass(listItemGroupClass);
                    }

                    if (item.disabled || this.disabled) {
                        classNameBuilder += " " + listItemDisabledClass;
                        //spanElement.addClass(listItemDisabledClass);
                    }

                    if (this.roundedcorners) {
                        classNameBuilder += " " + this.toThemeProperty('jqx-rc-all');
                        //spanElement.addClass(this.toThemeProperty('jqx-rc-all'));
                    }
                    if (touchDevice) {
                        classNameBuilder += " " + this.toThemeProperty('jqx-listitem-state-normal-touch');
                    }

                    spanElement[0].className = classNameBuilder;

                    if (this.renderer) {
                        if (!item.key) item.key = this.generatekey();
                        if (!this._cachedItemHtml) this._cachedItemHtml = new Array();
                        if (this._cachedItemHtml[item.key]) {
                            if (spanElement[0].innerHTML != this._cachedItemHtml[item.key]) {
                                spanElement[0].innerHTML = this._cachedItemHtml[item.key];
                            }
                        }
                        else {
                            var html = this.renderer(item.index, item.label, item.value);
                            spanElement[0].innerHTML = html;
                            this._cachedItemHtml[item.key] = spanElement[0].innerHTML;
                        }

                    }
                    else {
                        if (this.itemHeight !== -1) {
                            var paddingAndBorder = 2 + 2 * parseInt(spanElement.css('padding-top'));
                            spanElement[0].style.lineHeight = (item.height - paddingAndBorder) + 'px';
                            spanElement.css('vertical-align', 'middle');
                        }

                        if (item.html != null && item.html.toString().length > 0) {
                            spanElement[0].innerHTML = item.html;
                        }
                        else if (item.label != null || item.value != null) {
                            if (item.label != null) {
                                if (spanElement[0].innerHTML !== item.label) {
                                    spanElement[0].innerHTML = item.label;
                                }
                                if ($.trim(item.label) == "") {
                                    spanElement[0].innerHTML = this.emptyString;
                                    if (this.emptyString == "") {
                                        spanElement[0].style.height = (item.height - 8) + 'px';
                                    }
                                }
                                if (!this.incrementalSearch && !item.disabled) {
                                    if (this.searchString != undefined && this.searchString != "") {
                                        spanElement[0].innerHTML = this._highlight(item.label.toString(), this.searchString);
                                    }
                                }
                            }
                            else if (item.label === null) {
                                spanElement[0].innerHTML = this.emptyString;
                                if (this.emptyString == "") {
                                    spanElement[0].style.height = (item.height - 8) + 'px';
                                }
                            }
                            else {
                                if (spanElement[0].innerHTML !== item.value) {
                                    spanElement[0].innerHTML = item.value;
                                }
                                else if (item.label == "") {
                                    spanElement[0].innerHTML = " ";
                                }
                            }
                        }
                        else if (item.label == "" || item.label == null) {
                            spanElement[0].innerHTML = "";
                            spanElement[0].style.height = (item.height - 8) + 'px';
                        }
                    }

                    itemElement[0].style.left = item.left + 'px';
                    itemElement[0].style.top = item.initialTop - scrollValue + 'px';

                    item.element = spanElement[0];
                    if (this.isMaterialized() && !this.renderer) {
                        if (this._checkForHiddenParent) {
                            $(item.element).addClass('ripple');
                            $.jqx.ripple($(item.element));
                        }
                    }

                    //  $.data(spanElement[0], 'item', item);
                    if (item.title) {
                        spanElement[0].title = item.title;
                    }

                    if (this.equalItemsWidth && !item.isGroup) {
                        if (maxWidth == 0) {
                            var itemWidth = parseInt(width);
                            var diff = parseInt(spanElement.outerWidth()) - parseInt(spanElement.width());
                            itemWidth -= diff;
                            var borderSize = 1;
                            if (borderSize != null) {
                                borderSize = parseInt(borderSize);
                            }
                            else borderSize = 0;
                            if (this.host.css('box-sizing') === 'border-box') {
                                itemWidth -= 2;
                            }
                            //     itemWidth -= 2 * borderSize;
                            maxWidth = itemWidth;
                            if (this.checkboxes && this.hScrollBar[0].style.visibility == 'hidden') {
                                maxWidth -= this.checkboxSize + 13;
                            }
                        }
                        if (contentWidth > this.virtualSize.width) {
                            spanElement[0].style.width = maxWidth + 'px';
                            item.width = maxWidth;
                        }
                        else {
                            spanElement[0].style.width = -4 + this.virtualSize.width + 'px';
                            item.width = this.virtualSize.width - 4;
                        }
                    }
                    else {
                        if (spanElement.width() < this.host.width()) {
                            spanElement.width(this.host.width() - 2);
                        }
                    }

                    if (this.rtl) {
                        spanElement[0].style.textAlign = 'right';
                    }

                    if (this.autoItemsHeight) {
                        spanElement[0].style.whiteSpace = 'pre-line';
                        spanElement.width(maxWidth);
                        item.width = maxWidth;
                    }
                    middle = 0;
                    if (this.checkboxes && !item.isGroup) {
                        if (middle == 0) {
                            middle = (item.height - this.checkboxSize - 3) / 2;
                            middle = parseInt(middle);
                            middle++;
                        }
                        var checkbox = $(itemElement.children()[0]);
                        checkbox[0].item = item;

                        if (!this.rtl) {
                            var checkSize = (this.checkboxSize + 9);

                            if (spanElement[0].style.left != checkSize + 'px') {
                                spanElement[0].style.left = checkSize + 'px';
                            }
                        }
                        else {
                            if (spanElement[0].style.left != '0px') {
                                spanElement[0].style.left = '0px';
                            }
                        }
                        if (this.rtl) {
                            checkbox.css('left', 8 + item.width + 'px');
                        }
                        checkbox[0].style.top = middle + 'px';
                        checkbox[0].style.display = 'block';
                        checkbox[0].style.visibility = 'inherit';
                        var checked = item.checked;
                        var checkClass = item.checked ? " " + this.toThemeProperty("jqx-checkbox-check-checked") : "";
                        checkbox[0].setAttribute('checked', item.checked);
                        if (checkbox[0].firstChild && checkbox[0].firstChild.firstChild && checkbox[0].firstChild.firstChild.firstChild) {
                            if (checkbox[0].firstChild.firstChild) {
                                if (checked) {
                                    checkbox[0].firstChild.firstChild.firstChild.className = checkClass;
                                }
                                else if (checked === false) {
                                    checkbox[0].firstChild.firstChild.firstChild.className = "";
                                }
                                else if (checked === null) {
                                    checkbox[0].firstChild.firstChild.firstChild.className = this.toThemeProperty("jqx-checkbox-check-indeterminate");
                                }
                            }
                        }

                        if ($.jqx.ariaEnabled) {
                            if (checked) {
                                itemElement[0].setAttribute('aria-selected', true);
                            }
                            else {
                                itemElement[0].removeAttribute('aria-selected');
                            }
                        }

                    }
                    else if (this.checkboxes) {
                        var checkbox = $(itemElement.children()[0]);
                        checkbox.css({ 'display': 'none', 'visibility': 'inherit' });
                    }

                    if (!item.disabled && ((!this.filterable && this.selectedIndexes[item.visibleIndex] >= 0) || (item.selected && this.filterable))) {
                        spanElement.addClass(this.toThemeProperty('jqx-listitem-state-selected'));
                        spanElement.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                        if ($.jqx.ariaEnabled) {
                            itemElement[0].setAttribute('aria-selected', true);
                            this._activeElement = itemElement[0];
                        }
                    }
                    else if (!this.checkboxes) {
                        if ($.jqx.ariaEnabled) {
                            itemElement[0].removeAttribute('aria-selected');
                        }
                    }
                }
                else {
                    hideItem();
                }
            }
        },

        escapeHTML: function (value) {
            var entityMap = {
                '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;', '/': '&#x2F;', '`': '&#x60;', '=': '&#x3D;'
            };

            return String(value).replace(/[&<>"'`=\/]/g, function (s) { return entityMap[s] });
        },

        sanitizeHTML: function (value) {
            var that = this;
            var regExp = new RegExp('<\s*(applet|audio|base|bgsound|embed|form|iframe|isindex|keygen|layout|link|meta|object|script|svg|style|template|video)[^>]*>(.*?)<\s*/\s*(applet|audio|base|bgsound|embed|form|iframe|isindex|keygen|layout|link|meta|object|script|svg|style|template|video)>', 'ig');
            var result = String(value).replace(regExp, function (s) { return that.escapeHTML(s) });

            return result;
        },

        escape_HTML: function (html_str) {
            html_str = '' + html_str;
            if (html_str && (html_str.indexOf('onclick') >= 0 || html_str.indexOf('onload') >= 0 || html_str.indexOf('onerror') >= 0)) {
                return this.escapeHTML(html_str)
            }

            var sanitized = this.sanitizeHTML(html_str);

            return sanitized;
        },

        generatekey: function () {
            var S4 = function () {
                return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
            };
            return (S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4());
        },

        _calculateVirtualSize: function (ownerHeight) {
            if (this._renderOnDemand)
                return;

            var width = 0;
            var height = 2;
            var currentItem = 0;
            var spanElement = document.createElement('span');
            if (this.equalItemsWidth) {
                $(spanElement).css('float', 'left');
            }
            spanElement.style.whiteSpace = "pre";
            var itemsPerPage = 0;
            var hostHeight = undefined === ownerHeight ? this.host.outerHeight() : ownerHeight + 2;

            document.body.appendChild(spanElement);
            var length = this.items.length;
            var w = this.host.width();
            if (this.autoItemsHeight) {
                w -= 10;
                if (this.vScrollBar.css('visibility') != 'hidden') w -= 20;
            }

            if (this.autoItemsHeight || this.renderer || this.groups.length >= 1 || (length > 0 && this.items[0].html != null && this.items[0].html != "")) {
                for (var currentItem = 0; currentItem < length; currentItem++) {
                    var item = this.items[currentItem];

                    if (item.isGroup && (item.label == '' && item.html == '')) {
                        continue;
                    }

                    if (!item.visible)
                        continue;

                    var className = "";

                    if (!item.isGroup) {
                        className += this.toThemeProperty('jqx-widget jqx-listitem-state-normal jqx-rc-all');
                    }
                    else {
                        className += this.toThemeProperty('jqx-listitem-state-group jqx-rc-all');
                    }
                    className += " " + this.toThemeProperty('jqx-fill-state-normal');
                    if (this.isTouchDevice()) {
                        className += " " + this.toThemeProperty('jqx-touch');
                    }
                    spanElement.className = className;
                    if (this.autoItemsHeight) {
                        spanElement.style.whiteSpace = 'pre-line';
                        var checkSize = (this.checkboxSize + 9);

                        var checkWidth = this.checkboxes ? -checkSize : 0;
                        spanElement.style.width = (checkWidth + w) + 'px';
                    }

                    if (this.renderer) {
                        var html = this.renderer(item.index, item.label, item.value);
                        spanElement.innerHTML = html;
                    }
                    else {
                        if (item.html != null && item.html.toString().length > 0) {
                            spanElement.innerHTML = item.html;
                        }
                        else if (item.label != null || item.value != null) {
                            if (item.label != null) {
                                spanElement.innerHTML = this.escape_HTML(item.label);
                                if (item.label == "") spanElement.innerHTML = "Empty";
                            }
                            else spanElement.innerHTML = this.escape_HTML(item.value);
                        }
                    }

                    var spanHeight = spanElement.offsetHeight;
                    var spanWidth = spanElement.offsetWidth;

                    if (this.itemHeight > -1) {
                        spanHeight = this.itemHeight;
                    }

                    item.height = spanHeight;
                    item.width = spanWidth;
                    spanHeight++;
                    height += spanHeight;
                    width = Math.max(width, spanWidth);

                    if (height <= hostHeight) {
                        itemsPerPage++;
                    }
                }
            }
            else {
                var height = 0;
                var elementHeight = 0;
                var maxText = "";
                var maxTextLength = 0;
                var oldMaxTextLength = 0;
                var firstvisibleitem = -1;
                for (var currentItem = 0; currentItem < length; currentItem++) {
                    var item = this.items[currentItem];

                    if (item.isGroup && (item.label == '' && item.html == '')) {
                        continue;
                    }

                    if (!item.visible)
                        continue;
                    firstvisibleitem++;
                    var className = "";
                    if (firstvisibleitem == 0) {
                        className += this.toThemeProperty('jqx-listitem-state-normal jqx-rc-all');
                        className += " " + this.toThemeProperty('jqx-fill-state-normal');
                        className += " " + this.toThemeProperty('jqx-widget');
                        className += " " + this.toThemeProperty('jqx-listbox');
                        className += " " + this.toThemeProperty('jqx-widget-content');

                        if (this.isTouchDevice()) {
                            className += " " + this.toThemeProperty('jqx-touch');
                            className += " " + this.toThemeProperty('jqx-listitem-state-normal-touch');
                        }
                        spanElement.className = className;
                        if (this.autoItemsHeight) {
                            spanElement.style.whiteSpace = 'pre-line';
                            var checkSize = (this.checkboxSize + 9);
                            var checkWidth = this.checkboxes ? -checkSize : 0;
                            spanElement.style.width = (checkWidth + w) + 'px';
                        }

                        if (item.html == null || (item.label == "" || item.label == null)) {
                            spanElement.innerHTML = "Item";
                        }
                        else {
                            if (item.html != null && item.html.toString().length > 0) {
                                spanElement.innerHTML = item.html;
                            }
                            else if (item.label != null || item.value != null) {
                                if (item.label != null) {
                                    if (item.label.toString().match(new RegExp("\\w")) != null || item.label.toString().match(new RegExp("\\d")) != null) {
                                        spanElement.innerHTML = item.label;
                                    }
                                    else {
                                        spanElement.innerHTML = "Item";
                                    }
                                }
                                else spanElement.innerHTML = item.value;
                            }
                        }

                        var spanHeight = 1 + spanElement.offsetHeight;

                        if (this.itemHeight > -1) {
                            spanHeight = this.itemHeight;
                        }
                        elementHeight = spanHeight;
                    }

                    if (maxTextLength != undefined) {
                        oldMaxTextLength = maxTextLength;
                    }

                    if (item.html != null && item.html.toString().length > 0) {
                        maxTextLength = Math.max(maxTextLength, item.html.toString().length);
                        if (oldMaxTextLength != maxTextLength) {
                            maxText = item.html;
                        }
                    }
                    else if (item.label != null) {
                        maxTextLength = Math.max(maxTextLength, item.label.length);
                        if (oldMaxTextLength != maxTextLength) {
                            maxText = item.label;
                        }
                    }
                    else if (item.value != null) {
                        maxTextLength = Math.max(maxTextLength, item.value.length);
                        if (oldMaxTextLength != maxTextLength) {
                            maxText = item.value;
                        }
                    }

                    item.height = elementHeight;
                    height += elementHeight;
                    height++;
                    if (height <= hostHeight) {
                        itemsPerPage++;
                    }
                }
                spanElement.innerHTML = maxText;
                width = spanElement.offsetWidth;
            }

            height += 2;
            if (itemsPerPage < 10) itemsPerPage = 10;

            if (this.filterable) {
                height += this.filterHeight;
            }

            height -= 4;
            spanElement.parentNode.removeChild(spanElement);
            return { width: width, height: height, itemsPerPage: itemsPerPage };
        },

        _getVirtualItemsCount: function () {
            if (this.virtualItemsCount == 0) {
                var virtualItemsCount = parseInt(this.host.height()) / 5;
                if (virtualItemsCount > this.items.length) {
                    virtualItemsCount = this.items.length;
                }
                return virtualItemsCount;
            }
            else return this.virtualItemsCount;
        },

        _addItems: function (refreshUIItems) {
            if (this._renderOnDemand)
                return;

            var me = this;
            if (me.updatingListBox == true)
                return;

            if (me.items == undefined || me.items.length == 0) {
                me.virtualSize = { width: 0, height: 0, itemsPerPage: 0 };
                me._updatescrollbars();
                me.renderedVisibleItems = new Array();
                if (me.itemswrapper) {
                    me.itemswrapper.children().remove();
                }
                return;
            }
            var hostHeight = me.host.height();
            if (refreshUIItems == false) {
                var virtualSize = me._calculateVirtualSize(hostHeight);
                var virtualItemsCount = virtualSize.itemsPerPage * 2;
                if (me.autoHeight) {
                    virtualItemsCount = me.items.length;
                }

                me.virtualItemsCount = Math.min(virtualItemsCount, me.items.length);
                var virtualWidth = virtualSize.width;
                me.virtualSize = virtualSize;
                me._updatescrollbars();
                return;
            }
            var self = this;
            var top = 0;
            me.visibleItems = new Array();
            me.renderedVisibleItems = new Array();
            me._removeHandlers();
            if (me.allowDrag && me._enableDragDrop) {
                me.itemswrapper = null;
            }
            if (me.itemswrapper == null) {
                me.content[0].innerHTML = '';
                me.itemswrapper = $('<div style="outline: 0 none; overflow:hidden; width:100%; position: relative;"></div>');
                me.itemswrapper[0].style.height = (2 * hostHeight) + "px";
                me.content[0].appendChild(me.itemswrapper[0]);
            }

            var virtualSize = me._calculateVirtualSize(hostHeight);
            var virtualItemsCount = virtualSize.itemsPerPage * 2;
            if (me.autoHeight) {
                virtualItemsCount = me.items.length;
            }

            me.virtualItemsCount = Math.min(virtualItemsCount, me.items.length);
            var me = this;
            var virtualWidth = virtualSize.width;
            me.virtualSize = virtualSize;
            var wrapperWidth = Math.max(me.host.width(), 17 + virtualSize.width);
            me.itemswrapper[0].style.width = wrapperWidth + "px";
            var startIndex = 0;

            var html = "";
            var oldIE = $.jqx.browser.msie && $.jqx.browser.version < 9;
            var oldIEAttribute = oldIE ? ' unselectable="on"' : '';
            for (var virtualItemIndex = startIndex; virtualItemIndex < me.virtualItemsCount; virtualItemIndex++) {
                var item = me.items[virtualItemIndex];
                var id = 'listitem' + virtualItemIndex + me.element.id;
                if (me.theme != "") {
                    html += "<div" + oldIEAttribute + " role='option' id='" + id + "' class='jqx-listitem-element jqx-listitem-element-" + me.theme + "'>";
                }
                else {
                    html += "<div" + oldIEAttribute + " role='option' id='" + id + "' class='jqx-listitem-element'>";
                }
                if (me.checkboxes) {
                    var checkSize = this.checkboxSize + 8;

                    html += '<div style="background-color: transparent; padding: 0; margin: 0; overflow:hidden; position: absolute; float: left; width: ' + checkSize + 'px; height:  ' + checkSize + 'px;" class="' + me.toThemeProperty("jqx-checkbox") + ' ' + 'chkbox">';
                    var checkBoxContent = '<div class="' + me.toThemeProperty("jqx-checkbox-default") + ' ' + me.toThemeProperty("jqx-fill-state-normal") + ' ' + me.toThemeProperty("jqx-rc-all") + '"><div style="cursor: pointer; width:  ' + this.checkboxSize + 'px; height:  ' + this.checkboxSize + 'px;">';
                    var checkClass = item.checked ? " " + me.toThemeProperty("jqx-checkbox-check-checked") : "";
                    checkBoxContent += '<span style="width: ' + this.checkboxSize + 'px; height:  ' + this.checkboxSize + 'px;" class="checkBoxCheck' + checkClass + '"></span>';
                    checkBoxContent += '</div></div>';
                    html += checkBoxContent;
                    html += '</div>';
                }
                html += "<span" + oldIEAttribute + " style='white-space: pre; -ms-touch-action: none;'></span></div>"
            }

            if (self.WinJS) {
                me.itemswrapper.html(html);
            }
            else {
                me.itemswrapper[0].innerHTML = html;
            }

            var children = me.itemswrapper.children();
            for (var virtualItemIndex = startIndex; virtualItemIndex < me.virtualItemsCount; virtualItemIndex++) {
                var item = me.items[virtualItemIndex];
                var itemElement = $(children[virtualItemIndex]);

                if (me.allowDrag && me._enableDragDrop) {
                    itemElement.addClass('draggable');
                }

                if (me.checkboxes) {
                    var checkbox = $(itemElement.children()[0]);
                    itemElement.css('float', 'left');
                    var spanElement = $(itemElement[0].firstChild);
                    spanElement.css('float', 'left');
                }

                itemElement[0].style.height = item.height + 'px';
                itemElement[0].style.top = top + 'px';

                top += item.height + 1;
                me.visualItems[virtualItemIndex] = itemElement;
            };

            me._addHandlers();

            me._updatescrollbars();

            if (me.autoItemsHeight) {
                var virtualSize = me._calculateVirtualSize(hostHeight);
                var virtualItemsCount = virtualSize.itemsPerPage * 2;
                if (me.autoHeight) {
                    virtualItemsCount = me.items.length;
                }

                me.virtualItemsCount = Math.min(virtualItemsCount, me.items.length);
                var me = this;
                var virtualWidth = virtualSize.width;
                me.virtualSize = virtualSize;
                me._updatescrollbars();
            }

            if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                me.host.attr('hideFocus', true);
                me.host.find('div').attr('hideFocus', true);
            }
        },

        _updatescrollbars: function () {
            var me = this;
            if (!me.virtualSize) {
                return;
            }
            var virtualHeight = me.virtualSize.height;
            var virtualWidth = me.virtualSize.width;
            var vScrollInstance = me.vScrollInstance;
            var hScrollInstance = me.hScrollInstance;
            me._arrange(false);
            var hasChange = false;
            var outerWidth = me.host.outerWidth();
            var outerHeight = me.host.outerHeight();
            var hScrollOffset = 0;
            if (virtualWidth > outerWidth) {
                hScrollOffset = me.hScrollBar.outerHeight() + 2;
            }
            if (virtualHeight + hScrollOffset > outerHeight) {
                var oldmax = vScrollInstance.max;
                vScrollInstance.max = 2 + parseInt(virtualHeight) + hScrollOffset - parseInt(outerHeight - 2);
                if (me.vScrollBar[0].style.visibility != 'inherit') {
                    me.vScrollBar[0].style.visibility = 'inherit';
                    hasChange = true;
                }
                if (oldmax != vScrollInstance.max) {
                    vScrollInstance._arrange();
                }
            }
            else {
                if (me.vScrollBar[0].style.visibility != 'hidden') {
                    me.vScrollBar[0].style.visibility = 'hidden';
                    hasChange = true;
                    vScrollInstance.setPosition(0);
                }
            }

            var scrollOffset = 0;
            if (me.vScrollBar[0].style.visibility != 'hidden') {
                scrollOffset = me.scrollBarSize + 6;
            }

            var checkboxes = me.checkboxes ? (this.checkboxSize + 6) : 0;

            if (me.autoItemsHeight) {
                me.hScrollBar[0].style.visibility = 'hidden';
            }
            else {
                if (virtualWidth >= outerWidth - scrollOffset - checkboxes) {
                    var changedMax = hScrollInstance.max;
                    if (me.vScrollBar[0].style.visibility == 'inherit') {
                        hScrollInstance.max = checkboxes + scrollOffset + parseInt(virtualWidth) - me.host.width() + 2;
                    }
                    else {
                        hScrollInstance.max = checkboxes + parseInt(virtualWidth) - me.host.width() + 4;
                    }

                    if (me.hScrollBar[0].style.visibility != 'inherit') {
                        me.hScrollBar[0].style.visibility = 'inherit';
                        hasChange = true;
                    }
                    if (changedMax != hScrollInstance.max) {
                        hScrollInstance._arrange();
                    }
                    if (me.vScrollBar[0].style.visibility == 'inherit') {
                        vScrollInstance.max = 2 + parseInt(virtualHeight) + me.hScrollBar.outerHeight() + 2 - parseInt(me.host.height());
                    }
                }
                else {
                    if (me.hScrollBar[0].style.visibility != 'hidden') {
                        me.hScrollBar[0].style.visibility = 'hidden';
                        hasChange = true;
                    }
                }
            }

            hScrollInstance.setPosition(0);

            if (hasChange) {
                me._arrange();
            }

            if (me.itemswrapper) {
                me.itemswrapper[0].style.width = Math.max(0, Math.max(outerWidth - 2, 17 + virtualWidth)) + 'px';
                var wrapperWidth = Math.max(me.content.width(), 17 + me.virtualSize.width);
                me.itemswrapper[0].style.width = wrapperWidth + "px";

                me.itemswrapper[0].style.height = Math.max(0, 2 * outerHeight) + 'px';
            }

            var isTouchDevice = me.isTouchDevice();
            if (isTouchDevice) {
                if (me.vScrollBar.css('visibility') != 'visible' && me.hScrollBar.css('visibility') != 'visible') {
                    $.jqx.mobile.setTouchScroll(false, me.element.id);
                }
                else {
                    $.jqx.mobile.setTouchScroll(true, me.element.id);
                }
            }
        },

        clear: function () {
            this.source = null;
            this.visibleItems = new Array();
            this.renderedVisibleItems = new Array();
            this.itemsByValue = new Array();
            this.clearSelection();
            this.refresh();
        },

        // clears the selection.
        clearSelection: function (render) {
            for (var indx = 0; indx < this.selectedIndexes.length; indx++) {
                if (this.selectedIndexes[indx] && this.selectedIndexes[indx] != -1) {
                    this._raiseEvent('1', { index: indx, type: 'api', item: this.getVisibleItem(indx), originalEvent: null });
                }

                this.selectedIndexes[indx] = -1;
            }
            this.selectedIndex = -1;
            this.selectedValue = null;
            this.selectedValues = new Array();

            if (render != false) {
                this._renderItems();
            }
        },

        // unselects item by index.
        unselectIndex: function (index, render) {
            if (isNaN(index))
                return;

            this.selectedIndexes[index] = -1;

            var hasIndexes = false;
            for (var indx = 0; indx < this.selectedIndexes.length; indx++) {
                var sindex = this.selectedIndexes[indx];
                if (sindex != -1 && sindex != undefined) {
                    hasIndexes = true;
                }
            }
            if (!hasIndexes) {
                this.selectedValue = null;
                this.selectedIndex = -1;
                var visibleItem = this.getVisibleItem(index);
                if (visibleItem) {
                    if (this.selectedValues[visibleItem.value]) {
                        this.selectedValues[visibleItem.value] = null;
                    }
                }
            }

            if (render == undefined || render == true) {
                this._renderItems();
                this._raiseEvent('1', { index: index, type: 'api', item: this.getVisibleItem(index), originalEvent: null });
            }
            this._updateInputSelection();

            this._raiseEvent('2', { index: index, type: 'api', item: this.getItem(index) });
        },

        getInfo: function () {
            var that = this;
            var items = this.getItems();
            var visibleItems = this.getVisibleItems();
            var renderedItems = function () {
                var scrollValue = that.vScrollInstance.value;
                if (that.filterable)
                    scrollValue -= that.filterHeight;
                var rendered = new Array();
                for (var i = 0; i < visibleItems.length; i++) {
                    var item = visibleItems[i];
                    if (item) {
                        var itemTop = item.initialTop;
                        var itemHeight = item.height;
                        var visible = true;
                        if (itemTop + itemHeight - scrollValue < 0 || itemTop - scrollValue >= that.host.height()) {
                            visible = false;
                        }
                        if (visible) {
                            rendered.push(item);
                        }
                    }
                }
                return rendered;
            }();

            return { items: items, visibleItems: visibleItems, viewItems: renderedItems };
        },

        // gets item's instance.
        getItem: function (index) {
            if (index == -1 || isNaN(index) || typeof (index) === "string") {
                if (index === -1) {
                    return null;
                }
                return this.getItemByValue(index);
            }

            var result = null;
            var item = $.each(this.items, function () {
                if (this.index == index) {
                    result = this;
                    return false;
                }
            });

            return result;
        },

        getVisibleItem: function (index) {
            if (index == -1 || isNaN(index) || typeof (index) === "string") {
                if (index === -1) {
                    return null;
                }
                return this.getItemByValue(index);
            }
            return this.visibleItems[index];
        },

        getVisibleItems: function () {
            return this.visibleItems;
        },

        // checks a specific item by its index.
        checkIndex: function (index, render, raiseEvent) {
            if (!this.checkboxes) {
                return;
            }

            if (isNaN(index))
                return;

            if (index < 0 || index >= this.visibleItems.length)
                return;

            if (this.visibleItems[index] != null && this.visibleItems[index].disabled) {
                return;
            }

            if (this.disabled)
                return;

            var item = this.getItem(index);
            if (this.groups.length > 0 || this.filterable) {
                var item = this.getVisibleItem(index);
            }
            if (item != null) {
                var checkbox = $(item.checkBoxElement);
                item.checked = true;
                if (render == undefined || render == true) {
                    this._updateCheckedItems();
                }
            }

            if (raiseEvent == undefined || raiseEvent == true) {
                this._raiseEvent(3, { label: item.label, value: item.value, checked: true, item: item });
            }
        },

        getCheckedItems: function () {
            if (!this.checkboxes) {
                return null;
            }

            var checkedItems = new Array();
            if (this.items == undefined) return;

            $.each(this.items, function () {
                if (this.checked) {
                    checkedItems[checkedItems.length] = this;
                }
            });
            return checkedItems;
        },

        checkAll: function (raiseEvents) {
            if (!this.checkboxes) {
                return;
            }

            if (this.disabled)
                return;

            var me = this;
            $.each(this.items, function () {
                var item = this;
                var itemChecked = item.checked;

                this.checked = true;

                if (raiseEvents !== false && itemChecked !== true) {
                    me._raiseEvent(3, { label: item.label, value: item.value, checked: true, item: item });
                }
            });

            this._updateCheckedItems();
        },

        uncheckAll: function (raiseEvents) {
            if (!this.checkboxes) {
                return;
            }

            if (this.disabled)
                return;

            var me = this;
            $.each(this.items, function () {
                var item = this;
                var itemChecked = item.checked;

                this.checked = false;
                if (raiseEvents !== false && itemChecked !== false) {
                    this.checked = false;
                    me._raiseEvent(3, { label: item.label, value: item.value, checked: false, item: item });
                }
            });

            this._updateCheckedItems();
        },

        // unchecks a specific item by its index.
        uncheckIndex: function (index, render, raiseEvent) {
            if (!this.checkboxes) {
                return;
            }

            if (isNaN(index))
                return;

            if (index < 0 || index >= this.visibleItems.length)
                return;

            if (this.visibleItems[index] != null && this.visibleItems[index].disabled) {
                return;
            }

            if (this.disabled)
                return;

            var item = this.getItem(index);
            if (this.groups.length > 0 || this.filterable) {
                var item = this.getVisibleItem(index);
            }
            if (item != null) {
                var checkbox = $(item.checkBoxElement);
                item.checked = false;
                if (render == undefined || render == true) {
                    this._updateCheckedItems();
                }
            }
            if (raiseEvent == undefined || raiseEvent == true) {
                this._raiseEvent(3, { label: item.label, value: item.value, checked: false, item: item });
            }
        },

        // sets a specific item's checked property to null.
        indeterminateIndex: function (index, render, raiseEvent) {
            if (!this.checkboxes) {
                return;
            }

            if (isNaN(index))
                return;

            if (index < 0 || index >= this.visibleItems.length)
                return;

            if (this.visibleItems[index] != null && this.visibleItems[index].disabled) {
                return;
            }

            if (this.disabled)
                return;

            var item = this.getItem(index);
            if (this.groups.length > 0 || this.filterable) {
                var item = this.getVisibleItem(index);
            }
            if (item != null) {
                var checkbox = $(item.checkBoxElement);
                item.checked = null;
                if (render == undefined || render == true) {
                    this._updateCheckedItems();
                }
            }
            if (raiseEvent == undefined || raiseEvent == true) {
                this._raiseEvent(3, { checked: null });
            }
        },

        // gets the selected index.
        getSelectedIndex: function () {
            return this.selectedIndex;
        },

        // gets all selected items.
        getSelectedItems: function () {
            var visibleitems = this.getVisibleItems();
            var items = this.getItems();

            if (visibleitems && visibleitems.length !== items.length) {
                items = visibleitems;
            }

            var selectedIndexes = this.selectedIndexes;
            var selectedItems = [];
            // get selected items.
            for (var index in selectedIndexes) {
                if (selectedIndexes[index] != -1) {
                    selectedItems[selectedItems.length] = items[index];
                }
            }

            return selectedItems;
        },

        // gets the selected item.
        getSelectedItem: function () {
            var items = this.getSelectedItems();
            if (items && items.length > 0) {
                return items[0];
            }
            return null;
        },

        _updateCheckedItems: function () {
            var selectedIndex = this.selectedIndex;
            this.clearSelection(false);
            var items = this.getCheckedItems();
            this.selectedIndex = selectedIndex;

            this._renderItems();
            var selectedElement = $.data(this.element, 'hoveredItem');
            if (selectedElement != null) {
                $(selectedElement).addClass(this.toThemeProperty('jqx-listitem-state-hover'));
                $(selectedElement).addClass(this.toThemeProperty('jqx-fill-state-hover'));
            }

            this._updateInputSelection();
        },

        getItemByValue: function (value) {
            if (this.visibleItems == null) {
                return;
            }

            if (value && value.value) {
                value = value.value;
            }

            if (this.itemsByValue) {
                return this.itemsByValue[$.trim(value).split(" ").join("?")];
            }
            var items = this.visibleItems;

            for (var i = 0; i < items.length; i++) {
                if (items[i].value == value) {
                    return items[i];
                    break;
                }
            }
        },

        checkItem: function (item) {
            if (item != null) {
                var newItem = this._getItemByParam(item);
                return this.checkIndex(newItem.visibleIndex, true);
            }
            return false;
        },

        uncheckItem: function (item) {
            if (item != null) {
                var newItem = this._getItemByParam(item);
                return this.uncheckIndex(newItem.visibleIndex, true);
            }
            return false;
        },

        indeterminateItem: function (item) {
            if (item != null) {
                var newItem = this._getItemByParam(item);
                return this.indeterminateIndex(newItem.visibleIndex, true);
            }
            return false;
        },

        val: function (value) {
            if (!this.input)
                return;

            var isEmpty = function (obj) {
                for (var key in obj) {
                    if (obj.hasOwnProperty(key))
                        return false;
                }

                if (typeof value == "number")
                    return false;
                if (typeof value == "date")
                    return false;
                if (typeof value == "boolean")
                    return false;
                if (typeof value == "string")
                    return false;

                return true;
            }

            if (isEmpty(value) || arguments.length == 0) {
                return this.input.val();
            }

            var item = this.getItemByValue(value);
            if (item != null) {
                this.selectItem(item);
            }

            if (this.input) {
                return this.input.val();
            }
        },

        selectItem: function (item) {
            if (item != null) {
                if (item.index == undefined) {
                    var newItem = this.getItemByValue(item);
                    if (newItem) item = newItem;
                }
                return this.selectIndex(item.visibleIndex, true);
            }
            else this.clearSelection();
            return false;
        },

        unselectItem: function (item) {
            if (item != null) {
                if (item.index == undefined) {
                    var newItem = this.getItemByValue(item);
                    if (newItem) item = newItem;
                }
                return this.unselectIndex(item.visibleIndex, true);
            }
            return false;
        },

        // selects an item.
        selectIndex: function (index, ensureVisible, render, forceSelect, type, originalEvent) {
            if (isNaN(index))
                return;

            var tempSelectedIndex = this.selectedIndex;
            if (this.filterable) {
                this.selectedIndex = -1;
            }

            if (index < -1 || index >= this.visibleItems.length)
                return;

            if (this.visibleItems[index] != null && this.visibleItems[index].disabled) {
                return;
            }

            if (this.disabled)
                return;

            if (!this.multiple && !this.multipleextended && this.selectedIndex == index && !forceSelect && !this.checkboxes) {
                if (this.visibleItems && this.items && this.visibleItems.length != this.items.length) {
                    newItem = this.getVisibleItem(index);
                    if (newItem) {
                        this.selectedValue = newItem.value;
                        this.selectedValues[newItem.value] = newItem.value;
                    }
                }
                return;
            }
            if (this.checkboxes) {
                this._updateCheckedItems();
                var oldIndex = tempSelectedIndex;
                if (this.selectedIndex == index && !this.multiple) {
                    oldIndex = -1;
                }

                if (type == undefined) {
                    type = 'none';
                }

                var newItem = this.getItem(index);
                var oldItem = this.getItem(oldIndex);
                if (this.visibleItems && this.items && this.visibleItems.length != this.items.length) {
                    newItem = this.getVisibleItem(index);
                    oldItem = this.getVisibleItem(oldIndex);
                }

                this._raiseEvent('1', { index: oldIndex, type: type, item: oldItem, originalEvent: originalEvent });
                this.selectedIndex = index;
                this.selectedIndexes[oldIndex] = -1;
                this.selectedIndexes[index] = index;
                if (newItem) {
                    this.selectedValue = newItem.value;
                    this.selectedValues[newItem.value] = newItem.value;
                }
                this._raiseEvent('0', { index: index, type: type, item: newItem, originalEvent: originalEvent });
                this._renderItems();
                return;
            }

            this.focused = true;
            var newSelection = false;
            if (this.selectedIndex != index) newSelection = true;
            var oldIndex = tempSelectedIndex;
            if (this.selectedIndex == index && !this.multiple) {
                oldIndex = -1;
            }

            if (type == undefined) {
                type = 'none';
            }

            var newItem = this.getItem(index);
            var oldItem = this.getItem(oldIndex);
            if (this.visibleItems && this.items && this.visibleItems.length != this.items.length) {
                newItem = this.getVisibleItem(index);
                oldItem = this.getVisibleItem(oldIndex);
            }

            if (forceSelect != undefined && forceSelect) {
                this._raiseEvent('1', { index: oldIndex, type: type, item: oldItem, originalEvent: originalEvent });
                this.selectedIndex = index;
                this.selectedIndexes[oldIndex] = -1;
                this.selectedIndexes[index] = index;
                if (newItem) {
                    this.selectedValue = newItem.value;
                    this.selectedValues[newItem.value] = newItem.value;
                }
                this._raiseEvent('0', { index: index, type: type, item: newItem, originalEvent: originalEvent });
            }
            else {
                var me = this;
                var singleSelect = function (index, oldIndex, type, oldItem, newItem, originalEvent) {
                    me._raiseEvent('1', { index: oldIndex, type: type, item: oldItem, originalEvent: originalEvent });
                    me.selectedIndex = index;
                    me.selectedIndexes = [];
                    oldIndex = index;
                    me.selectedIndexes[index] = index;
                    me.selectedValues = new Array();
                    if (newItem) {
                        me.selectedValues[newItem.value] = newItem.value;
                    }

                    me._raiseEvent('0', { index: index, type: type, item: newItem, originalEvent: originalEvent });
                }
                var multipleSelect = function (index, oldIndex, type, oldItem, newItem, originalEvent) {
                    if (me.selectedIndexes[index] == undefined || me.selectedIndexes[index] == -1) {
                        me.selectedIndexes[index] = index;
                        me.selectedIndex = index;
                        if (newItem) {
                            me.selectedValues[newItem.value] = newItem.value;
                            me._raiseEvent('0', { index: index, type: type, item: newItem, originalEvent: originalEvent });
                        }
                    }
                    else {
                        oldIndex = me.selectedIndexes[index];
                        oldItem = me.getVisibleItem(oldIndex);
                        if (oldItem) {
                            me.selectedValues[oldItem.value] = null;
                        }

                        me.selectedIndexes[index] = -1;
                        me.selectedIndex = -1;
                        me._raiseEvent('1', { index: oldIndex, type: type, item: oldItem, originalEvent: originalEvent });
                    }
                }

                if (this.multipleextended) {
                    if (!this._shiftKey && !this._ctrlKey) {
                        if (type != 'keyboard' && type != 'mouse') {
                            multipleSelect(index, oldIndex, type, oldItem, newItem, originalEvent);
                            me._clickedIndex = index;
                        }
                        else {
                            this.clearSelection(false);
                            me._clickedIndex = index;
                            singleSelect(index, oldIndex, type, oldItem, newItem, originalEvent);
                        }
                    }
                    else if (this._ctrlKey) {
                        if (type == 'keyboard') {
                            this.clearSelection(false);
                            me._clickedIndex = index;
                        }
                        multipleSelect(index, oldIndex, type, oldItem, newItem, originalEvent);
                    }
                    else if (this._shiftKey) {
                        if (me._clickedIndex == undefined) me._clickedIndex = oldIndex;
                        var min = Math.min(me._clickedIndex, index);
                        var max = Math.max(me._clickedIndex, index);
                        this.clearSelection(false);
                        for (var i = min; i <= max; i++) {
                            me.selectedIndexes[i] = i;
                            me.selectedValues[me.getVisibleItem(i).value] = me.getVisibleItem(i).value;

                            me._raiseEvent('0', { index: i, type: type, item: this.getVisibleItem(i), originalEvent: originalEvent });
                        }
                        if (type != 'keyboard') {
                            me.selectedIndex = me._clickedIndex;
                        }
                        else {
                            me.selectedIndex = index;
                        }
                    }
                }
                else if (this.multiple) {
                    multipleSelect(index, oldIndex, type, oldItem, newItem, originalEvent);
                }
                else {
                    if (newItem) {
                        this.selectedValue = newItem.value;
                    }
                    singleSelect(index, oldIndex, type, oldItem, newItem, originalEvent);
                }
            }

            if (render == undefined || render == true) {
                this._renderItems();
            }

            if (ensureVisible != undefined && ensureVisible != null && ensureVisible == true) {
                this.ensureVisible(index);
            }

            this._raiseEvent('2', { index: index, item: newItem, oldItem: oldItem, type: type, originalEvent: originalEvent });
            this._updateInputSelection();

            return newSelection;
        },

        _updateInputSelection: function () {
            this._syncSelection();
            var selectedValues = new Array();
            if (this.input) {
                if (this.selectedIndex == -1) {
                    this.input.val("");
                }
                else {
                    if (this.items) {
                        if (this.items[this.selectedIndex] != undefined) {
                            this.input.val(this.items[this.selectedIndex].value);
                            selectedValues.push(this.items[this.selectedIndex].value);
                        }
                    }
                }
                if (this.multiple || this.multipleextended || this.checkboxes) {
                    var items = !this.checkboxes ? this.getSelectedItems() : this.getCheckedItems();
                    var str = "";
                    if (items) {
                        for (var i = 0; i < items.length; i++) {
                            if (undefined != items[i]) {
                                if (i == items.length - 1) {
                                    str += items[i].value;
                                }
                                else {
                                    str += items[i].value + ",";
                                }
                                selectedValues.push(items[i].value);
                            }
                        }
                        this.input.val(str);
                    }
                }
            }
            if (this.field && this.input) {
                if (this.field.nodeName.toLowerCase() == "select") {
                    $.each(this.field, function (index, value) {
                        $(this).removeAttr('selected');
                        this.selected = selectedValues.indexOf(this.value) >= 0;
                        if (this.selected) {
                            $(this).attr('selected', true);
                        }
                    });
                }
                else {
                    $.each(this.items, function (index, value) {
                        $(this.originalItem.originalItem).removeAttr('data-selected');
                        this.selected = selectedValues.indexOf(this.value) >= 0;
                        if (this.selected) {
                            $(this.originalItem.originalItem).attr('data-selected', true);
                        }
                    });
                }
            }
        },

        // checks whether an item is in the visible view.
        isIndexInView: function (index) {
            if (isNaN(index)) {
                return false;
            }

            if (!this.items)
                return false;

            if (index < 0 || index >= this.items.length) {
                return false;
            }

            var scrollValue = this.vScrollInstance.value;
            var filterHeight = 0;
            if (this.filterable)
                filterHeight = this.filterHeight;

            var item = this.visibleItems[index];
            if (item == undefined)
                return true;

            var itemTop = item.initialTop;
            var itemHeight = item.height;

            if (itemTop - scrollValue < filterHeight || itemTop - scrollValue + filterHeight + itemHeight >= this.host.outerHeight()) {
                return false;
            }

            return true;
        },

        //[optimize]
        _itemsInPage: function () {
            var itemsCount = 0;
            var me = this;

            if (this.items) {
                $.each(this.items, function () {
                    if ((this.initialTop + this.height) >= me.content.height()) {
                        return false;
                    }
                    itemsCount++;
                });
            }
            return itemsCount;
        },

        _firstItemIndex: function () {
            if (this.visibleItems != null) {
                if (this.visibleItems[0]) {
                    if (this.visibleItems[0].isGroup) {
                        return this._nextItemIndex(0);
                    }
                    else return 0;
                }
                else return 0;
            }

            return -1;
        },

        _lastItemIndex: function () {
            if (this.visibleItems != null) {
                if (this.visibleItems[this.visibleItems.length - 1]) {
                    if (this.visibleItems[this.visibleItems.length - 1].isGroup) {
                        return this._prevItemIndex(this.visibleItems.length - 1);
                    }
                    else return this.visibleItems.length - 1;
                }
                else return this.visibleItems.length - 1;
            }

            return -1;
        },

        _nextItemIndex: function (index) {
            for (var indx = index + 1; indx < this.visibleItems.length; indx++) {
                if (this.visibleItems[indx]) {
                    if (!this.visibleItems[indx].disabled && !this.visibleItems[indx].isGroup) {
                        return indx;
                    }
                }
            }

            return -1;
        },

        _prevItemIndex: function (index) {
            for (var indx = index - 1; indx >= 0; indx--) {
                if (this.visibleItems[indx]) {
                    if (!this.visibleItems[indx].disabled && !this.visibleItems[indx].isGroup) {
                        return indx;
                    }
                }
            }

            return -1;
        },

        clearFilter: function () {
            this.filterInput.val("");
            this._updateItemsVisibility("");
        },

        _search: function (event) {
            var that = this;
            var value = that.filterInput.val();

            if (event.keyCode == 9)
                return;

            if (that.searchMode == 'none' || that.searchMode == null || that.searchMode == 'undefined') {
                return;
            }

            if (event.keyCode == 16 || event.keyCode == 17 || event.keyCode == 20)
                return;

            if (event.keyCode == 37 || event.keyCode == 39)
                return false;

            if (event.altKey || event.keyCode == 18)
                return;

            if (event.keyCode >= 33 && event.keyCode <= 40) {
                return;
            }

            if (event.ctrlKey || event.metaKey || that.ctrlKey) {
                if (event.keyCode != 88 && event.keyCode != 86) {
                    return;
                }
            }

            if (value === that.searchString) {
                return;
            }

            that._updateItemsVisibility(value);
        },

        _updateItemsVisibility: function (value) {
            var items = this.getItems();
            if (items == undefined) {
                return { index: -1, matchItem: new Array() }
            }

            var me = this;
            var index = -1;
            var matchItems = new Array();
            var newItemsIndex = 0;

            $.each(items, function (i) {
                var itemValue = '';
                if (!this.isGroup) {
                    if (this.searchLabel) {
                        itemValue = this.searchLabel;
                    }
                    else if (this.label) {
                        itemValue = this.label;
                    }
                    else if (this.value) {
                        itemValue = this.value;
                    }
                    else if (this.title) {
                        itemValue = this.title;
                    }
                    else itemValue = 'jqxItem';
                    itemValue = itemValue.toString();
                    var matches = false;
                    switch (me.searchMode) {
                        case 'containsignorecase':
                            matches = $.jqx.string.containsIgnoreCase(itemValue, value);
                            break;
                        case 'contains':
                            matches = $.jqx.string.contains(itemValue, value);
                            break;
                        case 'equals':
                            matches = $.jqx.string.equals(itemValue, value);
                            break;
                        case 'equalsignorecase':
                            matches = $.jqx.string.equalsIgnoreCase(itemValue, value);
                            break;
                        case 'startswith':
                            matches = $.jqx.string.startsWith(itemValue, value);
                            break;
                        case 'startswithignorecase':
                            matches = $.jqx.string.startsWithIgnoreCase(itemValue, value);
                            break;
                        case 'endswith':
                            matches = $.jqx.string.endsWith(itemValue, value);
                            break;
                        case 'endswithignorecase':
                            matches = $.jqx.string.endsWithIgnoreCase(itemValue, value);
                            break;
                    }

                    if (!matches) {
                        this.visible = false;
                    }

                    if (matches) {
                        matchItems[newItemsIndex++] = this;
                        this.visible = true;
                        index = this.visibleIndex;
                    }

                    if (value == '') {
                        this.visible = true;
                        matches = false;
                    }
                }
            });

            me.renderedVisibleItems = new Array();
            me.visibleItems = new Array();
            me.vScrollInstance.setPosition(0, true);
            me._addItems(false);
            me._renderItems();
            for (var indx = 0; indx < me.items.length; indx++) {
                me.selectedIndexes[indx] = -1;
            }
            me.selectedIndex = -1;
            for (var selectedValue in me.selectedValues) {
                var value = me.selectedValues[selectedValue];
                var item = me.getItemByValue(value);
                if (item) {
                    if (item.visible) {
                        me.selectedIndex = item.visibleIndex;
                        me.selectedIndexes[item.visibleIndex] = item.visibleIndex;
                    }
                }
            }

            me._syncSelection();
            if (me.filterChange) {
                me.filterChange(value);
            }
        },

        // get all matches of a searched value.
        _getMatches: function (value, startindex) {
            if (value == undefined || value.length == 0)
                return -1;

            if (startindex == undefined) startindex = 0;

            var items = this.getItems();
            var me = this;
            var index = -1;
            var newItemsIndex = 0;

            $.each(items, function (i) {
                var itemValue = '';
                if (!this.isGroup) {
                    if (this.searchLabel) {
                        itemValue = this.searchLabel.toString();
                    }
                    else if (this.label) {
                        itemValue = this.label.toString();
                    }
                    else if (this.value) {
                        itemValue = this.value.toString();
                    }
                    else if (this.title) {
                        itemValue = this.title.toString();
                    }
                    else itemValue = 'jqxItem';

                    var mathes = false;
                    switch (me.searchMode) {
                        case 'containsignorecase':
                            mathes = $.jqx.string.containsIgnoreCase(itemValue, value);
                            break;
                        case 'contains':
                            mathes = $.jqx.string.contains(itemValue, value);
                            break;
                        case 'equals':
                            mathes = $.jqx.string.equals(itemValue, value);
                            break;
                        case 'equalsignorecase':
                            mathes = $.jqx.string.equalsIgnoreCase(itemValue, value);
                            break;
                        case 'startswith':
                            mathes = $.jqx.string.startsWith(itemValue, value);
                            break;
                        case 'startswithignorecase':
                            mathes = $.jqx.string.startsWithIgnoreCase(itemValue, value);
                            break;
                        case 'endswith':
                            mathes = $.jqx.string.endsWith(itemValue, value);
                            break;
                        case 'endswithignorecase':
                            mathes = $.jqx.string.endsWithIgnoreCase(itemValue, value);
                            break;
                    }

                    if (mathes && this.visibleIndex >= startindex) {
                        index = this.visibleIndex;
                        return false;
                    }
                }
            });

            return index;
        },

        // gets all items that match to a search value.
        findItems: function (value) {
            var items = this.getItems();
            var me = this;
            var index = 0;
            var matchItems = new Array();

            $.each(items, function (i) {
                var itemValue = '';
                if (!this.isGroup) {
                    if (this.label) {
                        itemValue = this.label;
                    }
                    else if (this.value) {
                        itemValue = this.value;
                    }
                    else if (this.title) {
                        itemValue = this.title;
                    }
                    else itemValue = 'jqxItem';

                    var mathes = false;
                    switch (me.searchMode) {
                        case 'containsignorecase':
                            mathes = $.jqx.string.containsIgnoreCase(itemValue, value);
                            break;
                        case 'contains':
                            mathes = $.jqx.string.contains(itemValue, value);
                            break;
                        case 'equals':
                            mathes = $.jqx.string.equals(itemValue, value);
                            break;
                        case 'equalsignorecase':
                            mathes = $.jqx.string.equalsIgnoreCase(itemValue, value);
                            break;
                        case 'startswith':
                            mathes = $.jqx.string.startsWith(itemValue, value);
                            break;
                        case 'startswithignorecase':
                            mathes = $.jqx.string.startsWithIgnoreCase(itemValue, value);
                            break;
                        case 'endswith':
                            mathes = $.jqx.string.endsWith(itemValue, value);
                            break;
                        case 'endswithignorecase':
                            mathes = $.jqx.string.endsWithIgnoreCase(itemValue, value);
                            break;
                    }

                    if (mathes) {
                        matchItems[index++] = this;
                    }
                }
            });

            return matchItems;
        },

        _syncSelection: function () {
            var that = this;
            if (that.filterable) {
                if (that.items) {
                    for (var i = 0; i < that.items.length; i++) {
                        var item = that.items[i];
                        item.selected = false;
                    }
                }
                for (var i = 0; i < that.visibleItems.length; i++) {
                    var item = that.visibleItems[i];
                    if (that.selectedIndexes && that.selectedIndexes[i] == item.visibleIndex) {
                        item.selected = true;
                    }
                }

                if (that.itemswrapper) {
                    that._renderItems();
                }
            }
        },

        _handleKeyDown: function (event) {
            var key = event.keyCode;
            var self = this;
            var index = self.selectedIndex;
            var selectedIndex = self.selectedIndex;
            var newSelection = false;

            if (!this.keyboardNavigation || !this.enableSelection)
                return;

            if (this.filterInput && event.target == this.filterInput[0]) {
                return;
            }

            if (event.target instanceof HTMLInputElement && $(event.target).ischildof(this.host)) {
                return;
            }

            var doClear = function () {
                if (self.multiple || self.checkboxes) {
                    self.clearSelection(false);
                }
            }

            if (event.altKey) key = -1;

            if (key == 32 && this.checkboxes) {
                var checkItem = this.getItem(index);
                if (checkItem != null) {
                    self._updateItemCheck(checkItem, index);
                    event.preventDefault();
                }
                self._searchString = "";
                self.selectIndex(checkItem.visibleIndex, false, true, true, 'keyboard', event);
                self._renderItems();
                return;
            }

            if (self.incrementalSearch) {
                var matchindex = -1;
                if (!self._searchString) {
                    self._searchString = "";
                }

                if ((key == 8 || key == 46) && self._searchString.length >= 1) {
                    self._searchString = self._searchString.substr(0, self._searchString.length - 1);
                }

                var letter = String.fromCharCode(key);

                if (event.key) {
                    letter = event.key;
                }

                var isDigit = (!isNaN(parseInt(letter)));
                var toReturn = false;
                if ((key >= 65 && key <= 97) || isDigit || key == 8 || key == 32 || key == 46) {
                    if (!event.shiftKey) {
                        letter = letter.toLocaleLowerCase();
                    }

                    var startIndex = 1 + self.selectedIndex;
                    if (key != 8 && key != 32 && key != 46) {
                        if (self._searchString.length > 0 && self._searchString.substr(0, 1) == letter) {
                            startIndex = 1 + self.selectedIndex;
                            self._searchString += letter;
                        }
                        else {
                            self._searchString += letter;
                        }
                    }

                    if (key == 32) {
                        self._searchString += " ";
                    }

                    var matches = this._getMatches(self._searchString, startIndex);
                    matchindex = matches;
                    if (matchindex == self._lastMatchIndex || matchindex == -1) {
                        var matches = this._getMatches(self._searchString, 0);
                        matchindex = matches;
                    }
                    self._lastMatchIndex = matchindex;

                    if (matchindex >= 0) {
                        var toSelect = function () {
                            doClear();
                            self.selectIndex(matchindex, false, false, false, 'keyboard', event);
                            var isInView = self.isIndexInView(matchindex);
                            if (!isInView) {
                                self.ensureVisible(matchindex);
                            }
                            else {
                                self._renderItems();
                            }
                        }
                        if (self._toSelectTimer) clearTimeout(self._toSelectTimer);
                        self._toSelectTimer = setTimeout(function () {
                            toSelect();
                        }, self.incrementalSearchKeyDownDelay);
                    }
                    toReturn = true;
                }

                if (self._searchTimer != undefined) {
                    clearTimeout(self._searchTimer);
                }

                if (key == 27 || key == 13) {
                    self._searchString = "";
                }

                self._searchTimer = setTimeout(function () {
                    self._searchString = "";
                    self._renderItems();
                }, self.incrementalSearchDelay);
                if (matchindex >= 0) {
                    return;
                }
                if (toReturn)
                    return false;
            }


            if (key == 33) {
                var itemsInPage = self._itemsInPage();
                if (self.selectedIndex - itemsInPage >= 0) {
                    doClear();
                    self.selectIndex(selectedIndex - itemsInPage, false, false, false, 'keyboard', event);
                }
                else {
                    doClear();
                    self.selectIndex(self._firstItemIndex(), false, false, false, 'keyboard', event);
                }
                self._searchString = "";
            }

            if (key == 32 && this.checkboxes) {
                var checkItem = this.getItem(index);
                if (checkItem != null) {
                    self._updateItemCheck(checkItem, index);
                    event.preventDefault();
                }
                self._searchString = "";
            }

            if (key == 36) {
                doClear();
                self.selectIndex(self._firstItemIndex(), false, false, false, 'keyboard', event);
                self._searchString = "";
            }

            if (key == 35) {
                doClear();
                self.selectIndex(self._lastItemIndex(), false, false, false, 'keyboard', event);
                self._searchString = "";
            }

            if (key == 34) {
                var itemsInPage = self._itemsInPage();
                if (self.selectedIndex + itemsInPage < self.visibleItems.length) {
                    doClear();
                    self.selectIndex(selectedIndex + itemsInPage, false, false, false, 'keyboard', event);
                }
                else {
                    doClear();
                    self.selectIndex(self._lastItemIndex(), false, false, false, 'keyboard', event);
                }
                self._searchString = "";
            }

            if (key == 38) {
                self._searchString = "";
                if (self.selectedIndex > 0) {
                    var newIndex = self._prevItemIndex(self.selectedIndex);
                    if (newIndex != self.selectedIndex && newIndex != -1) {
                        doClear();
                        self.selectIndex(newIndex, false, false, false, 'keyboard', event);
                    }
                    else return true;
                }
                else return false;
            }
            else if (key == 40) {
                self._searchString = "";
                if (self.selectedIndex + 1 < self.visibleItems.length) {
                    var newIndex = self._nextItemIndex(self.selectedIndex);
                    if (newIndex != self.selectedIndex && newIndex != -1) {
                        doClear();
                        self.selectIndex(newIndex, false, false, false, 'keyboard', event);
                    }
                    else return true;
                }
                else return false;
            }

            if (key == 35 || key == 36 || key == 38 || key == 40 || key == 34 || key == 33) {
                var isInView = self.isIndexInView(self.selectedIndex);
                if (!isInView) {
                    self.ensureVisible(self.selectedIndex);
                }
                else {
                    self._renderItems();
                }

                return false;
            }

            return true;
        },

        _updateItemCheck: function (checkItem, index) {
            if (this.disabled) return;

            if (checkItem.checked == true) {
                checkItem.checked = (checkItem.hasThreeStates && this.hasThreeStates) ? null : false;
            }
            else {
                checkItem.checked = checkItem.checked != null;
            }

            switch (checkItem.checked) {
                case true:
                    this.checkIndex(index);
                    break;
                case false:
                    this.uncheckIndex(index);
                    break;
                default:
                    this.indeterminateIndex(index);
                    break;
            }
        },

        // performs mouse wheel.
        wheel: function (event, self) {
            if (self.autoHeight || !self.enableMouseWheel) {
                event.returnValue = true;
                return true;
            }

            if (self.disabled) return true;

            var delta = 0;
            if (!event) /* For IE. */
                event = window.event;

            if (event.originalEvent && event.originalEvent.wheelDelta) {
                event.wheelDelta = event.originalEvent.wheelDelta;
            }

            if (event.wheelDelta) { /* IE/Opera. */
                delta = event.wheelDelta / 120;
            } else if (event.detail) { /** Mozilla case. */
                delta = -event.detail / 3;
            }
            if (delta) {
                var result = self._handleDelta(delta);
                if (result) {
                    if (event.preventDefault)
                        event.preventDefault();

                    if (event.originalEvent != null) {
                        event.originalEvent.mouseHandled = true;
                    }

                    if (event.stopPropagation != undefined) {
                        event.stopPropagation();
                    }
                }

                if (result) {
                    result = false;
                    event.returnValue = result;
                    return result;
                }
                else {
                    return false;
                }
            }

            if (event.preventDefault)
                event.preventDefault();
            event.returnValue = false;
        },

        _handleDelta: function (delta) {
            var oldvalue = this.vScrollInstance.value;
            if (delta < 0) {
                this.scrollDown();
            }
            else this.scrollUp();
            var newvalue = this.vScrollInstance.value;
            if (oldvalue != newvalue) {
                return true;
            }

            return false;
        },

        focus: function () {
            try {
                this.focused = true;
                this.host.focus();
                var me = this;
                setTimeout(function () {
                    me.host.focus();
                }, 25);
            }
            catch (error) {
            }
        },

        _removeHandlers: function () {
            var self = this;
            this.removeHandler($(document), 'keydown.listbox' + this.element.id);
            this.removeHandler($(document), 'keyup.listbox' + this.element.id);
            this.removeHandler(this.vScrollBar, 'valueChanged');
            this.removeHandler(this.hScrollBar, 'valueChanged');
            if (this._mousewheelfunc) {
                this.removeHandler(this.host, 'mousewheel', this._mousewheelfunc);
            }
            else {
                this.removeHandler(this.host, 'mousewheel');
            }

            this.removeHandler(this.host, 'keydown');
            this.removeHandler(this.content, 'mouseleave');
            this.removeHandler(this.content, 'focus');
            this.removeHandler(this.content, 'blur');
            this.removeHandler(this.host, 'focus');
            this.removeHandler(this.host, 'blur');
            this.removeHandler(this.content, 'mouseenter');
            this.removeHandler(this.content, 'mouseup');
            this.removeHandler(this.content, 'mousedown');
            this.removeHandler(this.content, 'touchend');

            if (this._mousemovefunc) {
                this.removeHandler(this.content, 'mousemove', this._mousemovefunc);
            }
            else {
                this.removeHandler(this.content, 'mousemove');
            }
            this.removeHandler(this.content, 'selectstart');
            if (this.overlayContent) {
                this.removeHandler(this.overlayContent, $.jqx.mobile.getTouchEventName('touchend'));
            }
        },

        _updateSize: function () {
            if (!this.virtualSize) {
                this._oldheight = null;
                this.virtualSize = this._calculateVirtualSize();
            }

            var self = this;
            self._arrange();
            if (self.host.height() != self._oldheight || self.host.width() != self._oldwidth) {
                var changedWidth = self.host.width() != self._oldwidth;

                if (self.autoItemsHeight) {
                    self._render(false);
                }
                else {
                    if (self.items) {
                        if (self.items.length > 0 && self.virtualItemsCount * self.items[0].height < self._oldheight - 2) {
                            self._render(false);
                        }
                        else {
                            var _oldScrollValue = self.vScrollInstance.value;
                            self._updatescrollbars();
                            self._renderItems();
                            if (_oldScrollValue < self.vScrollInstance.max) {
                                self.vScrollInstance.setPosition(_oldScrollValue);
                            }
                            else {
                                self.vScrollInstance.setPosition(self.vScrollInstance.max);
                            }
                        }
                    }
                }
                self._oldwidth = self.host.width();
                self._oldheight = self.host.height();
            }
        },

        _addHandlers: function () {
            var self = this;
            this.focused = false;
            var animating = false;
            var prevValue = 0;
            var object = null;
            var prevValue = 0;
            var newValue = 0;
            var lastScroll = new Date();
            var isTouchDevice = this.isTouchDevice();

            this.addHandler(this.vScrollBar, 'valueChanged', function (event) {
                if ($.jqx.browser.msie && $.jqx.browser.version > 9) {
                    setTimeout(function () {
                        self._renderItems();
                    }, 1);
                }
                else self._renderItems();
            });

            this.addHandler(this.hScrollBar, 'valueChanged', function () {
                self._renderItems();
            });

            if (this._mousewheelfunc) {
                this.removeHandler(this.host, 'mousewheel', this._mousewheelfunc);
            }

            this._mousewheelfunc = function (event) {
                self.wheel(event, self);
            };
            this.addHandler(this.host, 'mousewheel', this._mousewheelfunc);

            this.addHandler($(document), 'keydown.listbox' + this.element.id, function (event) {
                self._ctrlKey = event.ctrlKey || event.metaKey;
                self._shiftKey = event.shiftKey;
            });
            this.addHandler($(document), 'keyup.listbox' + this.element.id, function (event) {
                self._ctrlKey = event.ctrlKey || event.metaKey;
                self._shiftKey = event.shiftKey;
            });

            this.addHandler(this.host, 'keydown', function (event) {
                return self._handleKeyDown(event);
            });

            this.addHandler(this.content, 'mouseleave', function (event) {
                self.focused = false;
                var hoveredItem = $.data(self.element, 'hoveredItem');
                if (hoveredItem != null) {
                    $(hoveredItem).removeClass(self.toThemeProperty('jqx-listitem-state-hover'));
                    $(hoveredItem).removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                    $.data(self.element, 'hoveredItem', null);
                }
            });

            this.addHandler(this.content, 'focus', function (event) {
                if (!self.disabled) {
                    self.host.addClass(self.toThemeProperty('jqx-fill-state-focus'));
                    self.focused = true;
                }
            });

            this.addHandler(this.content, 'blur', function (event) {
                self.focused = false;
                self.host.removeClass(self.toThemeProperty('jqx-fill-state-focus'));
            });

            this.addHandler(this.host, 'focus', function (event) {
                if (!self.disabled) {
                    self.host.addClass(self.toThemeProperty('jqx-fill-state-focus'));
                    self.focused = true;
                }
            });

            this.addHandler(this.host, 'blur', function (event) {
                if ($.jqx.browser.msie && $.jqx.browser.version < 9 && self.focused) {
                    return;
                }

                self.host.removeClass(self.toThemeProperty('jqx-fill-state-focus'));
                self.focused = false;
            });

            this.addHandler(this.content, 'mouseenter', function (event) {
                self.focused = true;
            });
            var hasTransform = $.jqx.utilities.hasTransform(this.host);

            var isTouch = self.isTouchDevice() && this.touchMode !== true;
            var eventName = !isTouch ? 'mousedown' : 'touchend';
            var upEventName = !isTouch ? 'mouseup' : 'touchend';

            if (this.overlayContent) {
                this.addHandler(this.overlayContent, $.jqx.mobile.getTouchEventName('touchend'), function (event) {
                    if (!self.enableSelection) {
                        return true;
                    }

                    if (isTouch) {
                        self._newScroll = new Date();
                        if (self._newScroll - self._lastScroll < 500) {
                            return true;
                        }
                    }

                    var touches = $.jqx.mobile.getTouches(event);
                    var touch = touches[0];
                    if (touch != undefined) {
                        var selfOffset = self.host.offset();
                        var left = parseInt(touch.pageX);
                        var top = parseInt(touch.pageY);
                        if (self.touchMode == true) {
                            if (touch._pageX != undefined) {
                                left = parseInt(touch._pageX);
                                top = parseInt(touch._pageY);
                            }
                        }
                        left = left - selfOffset.left;
                        top = top - selfOffset.top;
                        var item = self._hitTest(left, top);
                        if (item != null && !item.isGroup) {
                            self._newScroll = new Date();
                            if (self._newScroll - self._lastScroll < 500) {
                                return false;
                            }
                            if (self.checkboxes) {
                                self._updateItemCheck(item, item.visibleIndex);
                                self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                return;
                            }


                            if (item.html.indexOf('href') != -1) {
                                setTimeout(function () {
                                    self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                    self.content.trigger('click');
                                    return false;
                                }, 100);
                            }
                            else {
                                self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                if (event.preventDefault) event.preventDefault();

                                self.content.trigger('click');
                                return false;
                            }
                        }
                    }
                });
            }
            else {
                var isMouseDown = false;

                this.addHandler(this.content, eventName, function (event) {
                    if (!self.enableSelection) {
                        return true;
                    }

                    isMouseDown = true;

                    if (isTouch) {
                        self._newScroll = new Date();
                        if (self._newScroll - self._lastScroll < 500) {
                            return false;
                        }
                    }

                    self.focused = true;
                    if (!self.isTouchDevice() && self.focusable) {
                        self.host.focus();
                    }
                    if (event.target.id != ('listBoxContent' + self.element.id) && self.itemswrapper[0] != event.target) {
                        var target = event.target;
                        var targetOffset = $(target).offset();
                        var selfOffset = self.host.offset();
                        if (hasTransform) {
                            var left = $.jqx.mobile.getLeftPos(target);
                            var top = $.jqx.mobile.getTopPos(target);
                            targetOffset.left = left; targetOffset.top = top;

                            left = $.jqx.mobile.getLeftPos(self.element);
                            top = $.jqx.mobile.getTopPos(self.element);
                            selfOffset.left = left; selfOffset.top = top;
                        }

                        var y = parseInt(targetOffset.top) - parseInt(selfOffset.top);
                        var x = parseInt(targetOffset.left) - parseInt(selfOffset.left);
                        var item = self._hitTest(x, y);
                        if (item != null && !item.isGroup) {
                            var doSelection = function (item, event) {
                                if (!self._shiftKey)
                                    self._clickedIndex = item.visibleIndex;
                                if (!self.checkboxes) {
                                    self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                } else {
                                    x = 20 + event.pageX - targetOffset.left;
                                    if (self.rtl) {
                                        var hscroll = self.hScrollBar.css('visibility') != 'hidden' ? self.hScrollInstance.max : self.host.width();
                                        if (x <= self.host.width() - 20) {
                                            if (!self.allowDrag) {
                                                self._updateItemCheck(item, item.visibleIndex);
                                                self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                            }
                                            else {
                                                setTimeout(function () {
                                                    if (!self._dragItem) {
                                                        if (!isMouseDown) {
                                                            self._updateItemCheck(item, item.visibleIndex);
                                                            self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                                        }
                                                    }
                                                }, 200);
                                            }
                                        }
                                    }
                                    else {
                                        if (x + self.hScrollInstance.value >= 20) {
                                            if (!self.allowDrag) {
                                                self._updateItemCheck(item, item.visibleIndex);
                                                self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                            }
                                            else {
                                                setTimeout(function () {
                                                    if (!self._dragItem) {
                                                        if (!isMouseDown) {
                                                            self._updateItemCheck(item, item.visibleIndex);
                                                            self.selectIndex(item.visibleIndex, false, true, false, 'mouse', event);
                                                        }
                                                    }
                                                }, 200);
                                            }
                                        }
                                    }
                                }
                            }

                            if (!item.disabled) {
                                if (item.html.indexOf('href') != -1) {
                                    setTimeout(function () {
                                        doSelection(item, event);
                                    }, 100);
                                }
                                else {
                                    doSelection(item, event);
                                }
                            }
                        }
                        if (eventName == 'mousedown') {
                            var rightclick = false;
                            if (event.which) rightclick = (event.which == 3);
                            else if (event.button) rightclick = (event.button == 2);
                            if (rightclick) return true;
                            //     return false;
                        }
                    }

                    return true;
                });
            }

            this.addHandler(this.content, 'mouseup', function (event) {
                self.vScrollInstance.handlemouseup(self, event);
                isMouseDown = false;
            });

            if ($.jqx.browser.msie) {
                this.addHandler(this.content, 'selectstart', function (event) {
                    return false;
                });
            }

            // hover behavior.
            var isTouchDevice = this.isTouchDevice();
            if (this.enableHover && !isTouchDevice) {
                this._mousemovefunc = function (event) {
                    if (isTouchDevice)
                        return true;

                    if (!self.enableHover)
                        return true;

                    var which = $.jqx.browser.msie == true && $.jqx.browser.version < 9 ? 0 : 1;
                    if (event.target == null)
                        return true;

                    if (self.disabled)
                        return true;

                    self.focused = true;
                    var scrolling = self.vScrollInstance.isScrolling();
                    if (!scrolling && event.target.id != ('listBoxContent' + self.element.id)) {
                        if (self.itemswrapper[0] != event.target) {
                            var target = event.target;
                            var targetOffset = $(target).offset();
                            var selfOffset = self.host.offset();
                            if (hasTransform) {
                                var left = $.jqx.mobile.getLeftPos(target);
                                var top = $.jqx.mobile.getTopPos(target);
                                targetOffset.left = left; targetOffset.top = top;

                                left = $.jqx.mobile.getLeftPos(self.element);
                                top = $.jqx.mobile.getTopPos(self.element);
                                selfOffset.left = left; selfOffset.top = top;
                            }
                            var y = parseInt(targetOffset.top) - parseInt(selfOffset.top);
                            var x = parseInt(targetOffset.left) - parseInt(selfOffset.left);
                            var item = self._hitTest(x, y);
                            if (item != null && !item.isGroup && !item.disabled) {
                                var selectedElement = $.data(self.element, 'hoveredItem');
                                if (selectedElement != null) {
                                    $(selectedElement).removeClass(self.toThemeProperty('jqx-listitem-state-hover'));
                                    $(selectedElement).removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                                }

                                $.data(self.element, 'hoveredItem', item.element);
                                var $element = $(item.element);
                                $element.addClass(self.toThemeProperty('jqx-listitem-state-hover'));
                                $element.addClass(self.toThemeProperty('jqx-fill-state-hover'));
                            }
                        }
                    }
                };

                this.addHandler(this.content, 'mousemove', this._mousemovefunc);
            }
        },

        _arrange: function (arrangeScrollbars) {
            if (arrangeScrollbars == undefined) arrangeScrollbars = true;

            var me = this;
            var width = null;
            var height = null;
            var filterHeight = me.filterable ? me.filterHeight : 0;
            var computedStyle = window.getComputedStyle(this.element);
            var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
            var boxSizing = computedStyle.boxSizing;

            if (this.element.offsetWidth === 0) {
                borderSize = 2;
            }

            if (boxSizing === 'border-box' || isNaN(borderSize)) {
                borderSize = 0;
            }

            var _setHostHeight = function (height) {
                height = me.host.height() - borderSize;
                if (height == 0) {
                    height = 200;
                    me.host.height(height);
                }
                return height;
            }

            if (me.width != null && me.width.toString().indexOf("px") != -1) {
                width = me.width;
            }
            else
                if (me.width != undefined && !isNaN(me.width)) {
                    width = me.width;
                };

            if (me.height != null && me.height.toString().indexOf("px") != -1) {
                height = me.height;
            }
            else if (me.height != undefined && !isNaN(me.height)) {
                height = me.height;
            };

            if (me.width != null && me.width.toString().indexOf("%") != -1) {
                me.host.css("width", me.width);
                width = me.host.width();
            }
            if (me.height != null && me.height.toString().indexOf("%") != -1) {
                me.host.css("height", me.height);
                height = _setHostHeight(height);
            }

            if (width != null) {
                width = parseInt(width) - borderSize;
                if (parseInt(me.element.style.width) != parseInt(me.width)) {
                    me.element.style.width = parseInt(width) + "px";
                }
            }

            if (!me.autoHeight) {
                if (height != null) {
                    height = parseInt(height);
                    if (parseInt(me.element.style.height) != parseInt(me.height)) {
                        me.host.height(me.height);
                        _setHostHeight(height);
                    }
                }
            }
            else {
                if (me.virtualSize) {
                    if (me.hScrollBar.css('visibility') != 'hidden') {
                        me.host.height(me.virtualSize.height + parseInt(me.scrollBarSize) + 3);
                        me.height = me.virtualSize.height + parseInt(me.scrollBarSize) + 3;
                        height = me.height;
                    }
                    else {
                        me.host.height(me.virtualSize.height);
                        me.height = me.virtualSize.height;
                        height = me.virtualSize.height;
                    }
                }
            }

            // scrollbar Size.
            var scrollSize = me.scrollBarSize;
            if (isNaN(scrollSize)) {
                scrollSize = parseInt(scrollSize);
                if (isNaN(scrollSize)) {
                    scrollSize = '17px';
                }
                else scrollSize = scrollSize + 'px';
            }

            scrollSize = parseInt(scrollSize);
            var scrollOffset = 4;
            var bottomSizeOffset = 2;
            var rightSizeOffset = 1;
            // right scroll offset.
            if (me.vScrollBar) {
                if (me.vScrollBar[0].style.visibility != 'hidden') {
                    rightSizeOffset = scrollSize + scrollOffset;
                }
                else {
                    rightSizeOffset = 0;
                    me.vScrollInstance.setPosition(0);
                }
            }
            else return;
            if (scrollSize == 0) {
                rightSizeOffset = 0;
                bottomSizeOffset = 0;
            }

            if (me.hScrollBar) {
                // bottom scroll offset.
                if (me.hScrollBar[0].style.visibility != 'hidden') {
                    bottomSizeOffset = scrollSize + scrollOffset;
                }
                else {
                    me.hScrollInstance.setPosition(0);
                    bottomSizeOffset = 0;
                }
            }
            else return;

            if (me.autoItemsHeight) {
                me.hScrollBar[0].style.visibility = 'hidden';
                bottomSizeOffset = 0;
            }

            if (height == null) height = 0;
            var hScrollTop = parseInt(height) - scrollOffset - scrollSize;
            if (hScrollTop < 0) hScrollTop = 0;

            if (parseInt(me.hScrollBar[0].style.height) != scrollSize) {
                if (parseInt(scrollSize) < 0) {
                    scrollSize = 0;
                }

                me.hScrollBar[0].style.height = parseInt(scrollSize) + 'px';
            }

            if (me.hScrollBar[0].style.top != hScrollTop + 'px') {
                me.hScrollBar[0].style.top = hScrollTop + 'px';
                me.hScrollBar[0].style.left = '0px';
            }

            var hscrollwidth = width - scrollSize - scrollOffset;
            if (hscrollwidth < 0) hscrollwidth = 0;
            var hScrollWidth = hscrollwidth + 'px';

            if (me.hScrollBar[0].style.width != hScrollWidth) {
                me.hScrollBar[0].style.width = hScrollWidth;
            }

            if (rightSizeOffset <= 1) {
                if (width >= 2) {
                    me.hScrollBar[0].style.width = parseInt(width - 2) + 'px';
                }
            }

            if (scrollSize != parseInt(me.vScrollBar[0].style.width)) {
                me.vScrollBar[0].style.width = parseInt(scrollSize) + 'px';
            }
            if ((parseInt(height) - bottomSizeOffset) != parseInt(me.vScrollBar[0].style.height)) {
                var scrollHeight = parseInt(height) - bottomSizeOffset;
                if (scrollHeight < 0) scrollHeight = 0;
                me.vScrollBar[0].style.height = scrollHeight + 'px';
            }

            if (width == null) width = 0;
            var vScrollLeft = parseInt(width) - parseInt(scrollSize) - scrollOffset + 'px';
            if (this.host.css('box-sizing') === "border-box") {
                vScrollLeft = parseInt(vScrollLeft) - 2 + 'px';
            }
            if (vScrollLeft != me.vScrollBar[0].style.left) {
                if (parseInt(vScrollLeft) >= 0) {
                    me.vScrollBar[0].style.left = vScrollLeft;
                }
                me.vScrollBar[0].style.top = '0px';
            }

            var vScrollInstance = me.vScrollInstance;
            vScrollInstance.disabled = me.disabled;
            if (arrangeScrollbars) {
                vScrollInstance._arrange();
            }

            var hScrollInstance = me.hScrollInstance;
            hScrollInstance.disabled = me.disabled;
            if (arrangeScrollbars) {
                hScrollInstance._arrange();
            }

            if ((me.vScrollBar[0].style.visibility != 'hidden') && (me.hScrollBar[0].style.visibility != 'hidden')) {
                me.bottomRight[0].style.visibility = 'inherit';
                me.bottomRight[0].style.left = 1 + parseInt(me.vScrollBar[0].style.left) + 'px';
                me.bottomRight[0].style.top = 1 + parseInt(me.hScrollBar[0].style.top) + 'px';
                if (me.rtl) {
                    me.bottomRight.css({ left: 0 });
                }
                me.bottomRight[0].style.width = parseInt(scrollSize) + 3 + 'px';
                me.bottomRight[0].style.height = parseInt(scrollSize) + 3 + 'px';
            }
            else {
                me.bottomRight[0].style.visibility = 'hidden';
            }


            if (parseInt(me.content[0].style.width) != (parseInt(width) - rightSizeOffset)) {
                var w = parseInt(width) - rightSizeOffset;
                if (w < 0) w = 0;
                me.content[0].style.width = w + 'px';
            }

            if (me.rtl) {
                me.vScrollBar.css({ left: 0 + 'px', top: '0px' });
                me.hScrollBar.css({ left: me.vScrollBar.width() + 2 + 'px' });
                if (me.vScrollBar[0].style.visibility != 'hidden') {
                    me.content.css('margin-left', 4 + me.vScrollBar.width());
                }
                else {
                    me.content.css('margin-left', 0);
                    me.hScrollBar.css({ left: '0px' });
                }
                if (me.filterable && me.filterInput) {
                    me.filterInput.css({ left: me.vScrollBar.width() + 6 + 'px' });
                }
            }

            if (parseInt(me.content[0].style.height) != (parseInt(height) - bottomSizeOffset)) {
                var h = parseInt(height) - bottomSizeOffset;
                if (h < 0) h = 0;
                me.content[0].style.height = h + 'px';
                me.content[0].style.top = '0px';
            }
            if (filterHeight > 0) {
                me.content[0].style.top = filterHeight + 'px';
                me.content[0].style.height = parseInt(me.content[0].style.height) - filterHeight + 'px';
            }

            if (me.filterable) {
                me.filterInput[0].style.height = (filterHeight - 6) + 'px';
                me.filterInput[0].style.top = '3px';
                if (!me.rtl) {
                    me.filterInput[0].style.left = parseInt(me.content.css('left')) + 3 + 'px';
                }
                me.filterInput[0].style.width = parseInt(me.content.css('width')) - 7 + 'px';
                me.filter[0].style.display = "block";
            }
            else {
                me.filter[0].style.display = "none";
            }

            if (me.overlayContent) {
                me.overlayContent.width(parseInt(width) - rightSizeOffset);
                me.overlayContent.height(parseInt(height) - bottomSizeOffset);
            }
        },

        // scrolls to a list box item.
        ensureVisible: function (index, topItem) {
            if (isNaN(index)) {
                var item = this.getItemByValue(index);
                if (item) {
                    index = item.index;
                }
            }

            var isInView = this.isIndexInView(index);
            if (!isInView) {
                if (index < 0)
                    return;
                if (this.autoHeight) {
                    var vScrollInstance = $.data(this.vScrollBar[0], 'jqxScrollBar').instance;
                    vScrollInstance.setPosition(0);
                }
                else {
                    for (var indx = 0; indx < this.visibleItems.length; indx++) {
                        var item = this.visibleItems[indx];
                        if (item.visibleIndex == index && !item.isGroup) {
                            var vScrollInstance = $.data(this.vScrollBar[0], 'jqxScrollBar').instance;
                            var value = vScrollInstance.value;
                            var filterHeight = !this.filterable ? 0 : this.filterHeight + 2;

                            var hScrollVisible = this.hScrollBar.css('visibility') === 'hidden';
                            var hScrollOffset = hScrollVisible ? 0 : this.scrollBarSize + 4;
                            if (item.initialTop < value) {
                                vScrollInstance.setPosition(item.initialTop);
                                if (indx == 0) {
                                    vScrollInstance.setPosition(0);
                                }
                            }
                            else if (item.initialTop + item.height > value + this.host.height() - filterHeight) {
                                var hostHeight = this.host.height();

                                if (this.filterable) {
                                    vScrollInstance.setPosition(this.filterHeight + 2 + item.initialTop + item.height + 2 - hostHeight + hScrollOffset);
                                }
                                else {
                                    vScrollInstance.setPosition(item.initialTop + item.height + 2 - hostHeight + hScrollOffset);
                                    if (indx === this.visibleItems.length - 1) {
                                        vScrollInstance.setPosition(vScrollInstance.max);
                                    }
                                }
                                if (topItem) {
                                    var value = vScrollInstance.value;
                                    var desiredItemPosition = item.initialTop;
                                    if (this.filterable) {
                                        desiredItemPosition = this.filterHeight + 2 + item.initialTop;
                                    }
                                    if (value + hostHeight < vScrollInstance.max) {
                                        vScrollInstance.setPosition(desiredItemPosition);
                                    }
                                }
                            }

                            break;
                        }
                    }
                }
            }
            else {
                if (topItem) {
                    for (var indx = 0; indx < this.visibleItems.length; indx++) {
                        var item = this.visibleItems[indx];
                        if (item.visibleIndex == index && !item.isGroup) {
                            var value = this.vScrollInstance.value;
                            var desiredItemPosition = item.initialTop;
                            if (this.filterable) {
                                desiredItemPosition = this.filterHeight + 2 + item.initialTop;
                            }
                            if (value + this.host.height() < this.vScrollInstance.max) {
                                this.vScrollInstance.setPosition(desiredItemPosition);
                            }
                        }
                    }
                }
            }

            this._renderItems();
        },

        scrollTo: function (left, top) {
            if (this.vScrollBar.css('visibility') != 'hidden') {
                this.vScrollInstance.setPosition(top);
            }
            if (this.hScrollBar.css('visibility') != 'hidden') {
                this.hScrollInstance.setPosition(left);
            }
        },

        // scrolls down.
        scrollDown: function () {
            if (this.vScrollBar.css('visibility') == 'hidden')
                return false;

            var vScrollInstance = this.vScrollInstance;
            if (vScrollInstance.value + vScrollInstance.largestep <= vScrollInstance.max) {
                vScrollInstance.setPosition(vScrollInstance.value + vScrollInstance.largestep);
                return true;
            }
            else {
                vScrollInstance.setPosition(vScrollInstance.max);
                return true;
            }

            return false;
        },

        // scrolls up.
        scrollUp: function () {
            if (this.vScrollBar.css('visibility') == 'hidden')
                return false;

            var vScrollInstance = this.vScrollInstance;
            if (vScrollInstance.value - vScrollInstance.largestep >= vScrollInstance.min) {
                vScrollInstance.setPosition(vScrollInstance.value - vScrollInstance.largestep);
                return true;
            }
            else {
                if (vScrollInstance.value != vScrollInstance.min) {
                    vScrollInstance.setPosition(vScrollInstance.min);
                    return true;
                }
            }
            return false;
        },

        databind: function (source, initialRefresh) {
            this.records = new Array();
            var isdataadapter = source._source ? true : false;
            var dataadapter = new $.jqx.dataAdapter(source,
                {
                    autoBind: false
                }
            );

            if (isdataadapter) {
                dataadapter = source;
                source = source._source;
            }

            var initadapter = function (me) {
                if (source.type != undefined) {
                    dataadapter._options.type = source.type;
                }
                if (source.formatdata != undefined) {
                    dataadapter._options.formatData = source.formatdata;
                }
                if (source.contenttype != undefined) {
                    dataadapter._options.contentType = source.contenttype;
                }
                if (source.async != undefined) {
                    dataadapter._options.async = source.async;
                }
            }

            var updatefromadapter = function (me, type) {
                var getItem = function (record) {
                    var search = null;

                    if (typeof record === 'string') {
                        var label = record;
                        var value = record;
                        var group = '';
                    }
                    else if (me.displayMember != undefined && me.displayMember != "") {
                        var value = record[me.valueMember];
                        var label = record[me.displayMember];
                    }
                    var group = '';

                    if (me.groupMember) {
                        group = record[me.groupMember];
                    }
                    else if (record && record.group != undefined) {
                        group = record.group;
                    }
                    if (me.searchMember) {
                        search = record[me.searchMember];
                    }
                    else if (record && record.searchLabel != undefined) {
                        search = record.searchLabel;
                    }

                    if (!me.valueMember && !me.displayMember) {
                        if ($.type(record) == "string") {
                            label = value = record.toString();
                        }
                    }

                    if (record && record.label != undefined) {
                        var label = record.label;
                    }
                    if (record && record.value != undefined) {
                        var value = record.value;
                    }
                    var checked = false;
                    if (record && record.checked != undefined) {
                        checked = record.checked;
                    }
                    var html = '';
                    if (record && record.html != undefined) {
                        html = record.html;
                    }
                    var visible = true;
                    if (record && record.visible != undefined) {
                        visible = record.visible;
                    }
                    var disabled = false;
                    if (record && record.disabled != undefined) {
                        disabled = record.disabled;
                    }
                    var hasThreeStates = false;
                    if (record && record.hasThreeStates != undefined) {
                        hasThreeStates = record.hasThreeStates;
                    }

                    var listBoxItem = {};
                    listBoxItem.label = label;
                    listBoxItem.value = value;
                    listBoxItem.searchLabel = search;
                    listBoxItem.html = html;
                    listBoxItem.visible = visible;
                    listBoxItem.originalItem = record;
                    listBoxItem.group = group;
                    listBoxItem.groupHtml = '';
                    listBoxItem.disabled = disabled;
                    listBoxItem.checked = checked;
                    listBoxItem.hasThreeStates = hasThreeStates;

                    return listBoxItem;
                }

                if (type != undefined) {
                    var dataItem = dataadapter._changedrecords[0];
                    if (dataItem) {
                        $.each(dataadapter._changedrecords, function () {
                            var index = this.index;
                            var item = this.record;
                            if (type != 'remove') {
                                var mapItem = getItem(item);
                            }

                            switch (type) {
                                case "update":
                                    me.updateAt(mapItem, index);
                                    break;
                                case "add":
                                    me.insertAt(mapItem, index);
                                    break;
                                case "remove":
                                    me.removeAt(index);
                                    break;
                            }
                        });
                        return;
                    }
                }

                me.records = dataadapter.records;
                var recordslength = me.records.length;
                var items = new Array();
                for (var i = 0; i < recordslength; i++) {
                    var record = me.records[i];
                    var listBoxItem = getItem(record);
                    listBoxItem.index = i;
                    items[i] = listBoxItem;
                }
                me.items = me.loadItems(items, true);
                me._render();
                me._raiseEvent('6');
            }

            initadapter(this);

            var me = this;
            switch (source.datatype) {
                case "local":
                case "array":
                default:
                    if (source.localdata != null || $.isArray(source)) {
                        dataadapter.unbindBindingUpdate(this.element.id);
                        if (this.autoBind || (!this.autoBind && !initialRefresh)) {
                            dataadapter.dataBind();
                        }
                        updatefromadapter(this);
                        dataadapter.bindBindingUpdate(this.element.id, function (updatetype) {
                            updatefromadapter(me, updatetype);
                        });
                    }
                    break;
                case "json":
                case "jsonp":
                case "xml":
                case "xhtml":
                case "script":
                case "text":
                case "csv":
                case "tab":
                    {
                        if (source.localdata != null) {
                            dataadapter.unbindBindingUpdate(this.element.id);
                            if (this.autoBind || (!this.autoBind && !initialRefresh)) {
                                dataadapter.dataBind();
                            }
                            updatefromadapter(this);
                            dataadapter.bindBindingUpdate(this.element.id, function () {
                                updatefromadapter(me);
                            });
                            return;
                        }

                        var postdata = {};
                        if (dataadapter._options.data) {
                            $.extend(dataadapter._options.data, postdata);
                        }
                        else {
                            if (source.data) {
                                $.extend(postdata, source.data);
                            }
                            dataadapter._options.data = postdata;
                        }
                        var updateFunc = function () {
                            updatefromadapter(me);
                        }

                        dataadapter.unbindDownloadComplete(me.element.id);
                        dataadapter.bindDownloadComplete(me.element.id, updateFunc);


                        if (this.autoBind || (!this.autoBind && !initialRefresh)) {
                            dataadapter.dataBind();
                        }
                    }
            }
        },

        loadItems: function (items, adapter) {
            if (items == null) {
                this.groups = new Array();
                this.items = new Array();
                this.visualItems = new Array();
                return;
            }

            var self = this;
            var index = 0;
            var length = 0;
            var itemIndex = 0;
            this.groups = new Array();
            this.items = new Array();
            this.visualItems = new Array();
            var listItems = new Array();
            this.itemsByValue = new Array();

            $.map(items, function (item) {
                if (item == undefined)
                    return null;

                var listBoxItem = new $.jqx._jqxListBox.item();
                var group = item.group;
                var groupHtml = item.groupHtml;
                var title = item.title;
                var search = null;

                if (self.searchMember) {
                    search = item[self.searchMember];
                }
                else if (item && item.searchLabel != undefined) {
                    search = item.searchLabel;
                }


                if (title == null || title == undefined) {
                    title = '';
                }

                if (group == null || group == undefined) {
                    group = '';
                }
                if (self.groupMember) {
                    group = item[self.groupMember];
                }
                if (groupHtml == null || groupHtml == undefined) {
                    groupHtml = '';
                }

                if (!self.groups[group]) {
                    self.groups[group] = { items: new Array(), index: -1, caption: group, captionHtml: groupHtml };
                    index++;

                    var groupID = index + 'jqxGroup';
                    self.groups[groupID] = self.groups[group];
                    length++;
                    self.groups.length = length;
                }

                var uniqueGroup = self.groups[group];
                uniqueGroup.index++;
                uniqueGroup.items[uniqueGroup.index] = listBoxItem;

                if (typeof item === "string") {
                    listBoxItem.label = item;
                    listBoxItem.value = item;
                    if (arguments.length > 1 && arguments[1] && $.type(arguments[1]) == "string") {
                        listBoxItem.label = item;
                        listBoxItem.value = arguments[1];
                    }
                }
                else if (item.label == null && item.value == null && item.html == null && item.group == null && item.groupHtml == null) {
                    listBoxItem.label = item.toString();
                    listBoxItem.value = item.toString();
                }
                else {
                    listBoxItem.label = item.label;
                    listBoxItem.value = item.value;

                    if (listBoxItem.label === undefined)
                        listBoxItem.label = item.value;
                    if (listBoxItem.value === undefined)
                        listBoxItem.value = item.label;
                }

                if (typeof item != "string") {
                    if (item.label === undefined) {
                        if (self.displayMember != "") {
                            if (item[self.displayMember] != undefined) {
                                listBoxItem.label = item[self.displayMember];
                            }
                            else listBoxItem.label = "";
                        }
                    }

                    if (item.value === undefined) {
                        if (self.valueMember != "") {
                            listBoxItem.value = item[self.valueMember];
                        }
                    }
                }

                listBoxItem.hasThreeStates = item.hasThreeStates != undefined ? item.hasThreeStates : true;
                listBoxItem.originalItem = item;
                if (adapter) {
                    listBoxItem.originalItem = item.originalItem;
                }

                listBoxItem.title = title;
                if (title && listBoxItem.value === undefined && listBoxItem.label === undefined) {
                    listBoxItem.value = listBoxItem.label = title;
                }
                listBoxItem.html = item.html || '';
                if (item.html && item.html != '') {
                    //     listBoxItem.label = listBoxItem.value = item.html;
                    if (title && title != '') {
                        //           listBoxItem.label = listBoxItem.value = title;
                    }
                }

                if (typeof listBoxItem.label === "string") {
                    //          listBoxItem.label = listBoxItem.label.replace(/</g, '&lt;');
                    //        listBoxItem.label = listBoxItem.label.replace(/>/g, '&gt;');
                }

                listBoxItem.group = group;
                listBoxItem.checked = item.checked || false;
                listBoxItem.groupHtml = item.groupHtml || '';
                listBoxItem.disabled = item.disabled || false;
                listBoxItem.visible = item.visible != undefined ? item.visible : true;
                listBoxItem.searchLabel = search;
                listBoxItem.index = itemIndex;
                listItems[itemIndex] = listBoxItem;
                itemIndex++;
                return listBoxItem;
            });

            var itemsArray = new Array();
            var uniqueItemIndex = 0;

            if (this.fromSelect == undefined || this.fromSelect == false) {
                for (var indx = 0; indx < length; indx++) {
                    var index = indx + 1;
                    var groupID = index + 'jqxGroup';
                    var group = this.groups[groupID];
                    if (group == undefined || group == null)
                        break;

                    if (indx == 0 && group.caption == '' && group.captionHtml == '' && length <= 1) {
                        for (var i = 0; i < group.items.length; i++) {
                            var key = group.items[i].value;
                            if (group.items[i].value == undefined || group.items[i].value == null) key = i;
                            this.itemsByValue[$.trim(key).split(" ").join("?")] = group.items[i];
                        }
                        return group.items;
                    }
                    else {
                        var listBoxItem = new $.jqx._jqxListBox.item();
                        listBoxItem.isGroup = true;
                        listBoxItem.label = group.caption;
                        if (group.caption == '' && group.captionHtml == '') {
                            group.caption = this.emptyGroupText;
                            listBoxItem.label = group.caption;
                        }

                        listBoxItem.html = group.captionHtml;
                        itemsArray[uniqueItemIndex] = listBoxItem;

                        uniqueItemIndex++;
                    }

                    for (var j = 0; j < group.items.length; j++) {
                        itemsArray[uniqueItemIndex] = group.items[j];
                        var key = group.items[j].value;
                        if (group.items[j].value == "" || group.items[j].value == null) key = uniqueItemIndex;
                        self.itemsByValue[$.trim(key).split(" ").join("?")] = group.items[j];

                        uniqueItemIndex++;

                    }
                }
            }
            else {
                var uniqueItemIndex = 0;
                var checkedGroups = new Array();

                $.each(listItems, function () {
                    if (!checkedGroups[this.group]) {
                        if (this.group != '') {
                            var listBoxItem = new $.jqx._jqxListBox.item();
                            listBoxItem.isGroup = true;
                            listBoxItem.label = this.group;
                            itemsArray[uniqueItemIndex] = listBoxItem;
                            uniqueItemIndex++;
                            checkedGroups[this.group] = true;
                        }
                    }

                    itemsArray[uniqueItemIndex] = this;
                    var key = this.value;
                    if (this.value == "" || this.value == null) key = uniqueItemIndex - 1;
                    self.itemsByValue[$.trim(key).split(" ").join("?")] = this;

                    uniqueItemIndex++;
                });
            }

            return itemsArray;
        },

        _mapItem: function (item) {
            var listBoxItem = new $.jqx._jqxListBox.item();
            if (this.displayMember) {
                if (item.label == undefined) {
                    item.label = item[this.displayMember];
                }
                if (item.value == undefined) {
                    item.value = item[this.valueMember];
                }
            }

            if (typeof item === "string") {
                listBoxItem.label = item;
                listBoxItem.value = item;
            }
            else if (typeof item === 'number') {
                listBoxItem.label = item.toString();
                listBoxItem.value = item.toString();
            }
            else {
                listBoxItem.label = item.label !== undefined ? item.label : item.value;
                listBoxItem.value = item.value !== undefined ? item.value : item.label;
            }
            if (listBoxItem.label == undefined && listBoxItem.value == undefined && listBoxItem.html == undefined) {
                listBoxItem.label = listBoxItem.value = item;
            }

            listBoxItem.html = item.html || '';
            listBoxItem.group = item.group || '';
            listBoxItem.checked = item.checked || false;
            listBoxItem.title = item.title || '';
            listBoxItem.groupHtml = item.groupHtml || '';
            listBoxItem.disabled = item.disabled || false;
            listBoxItem.visible = item.visible || true;
            return listBoxItem;
        },

        // adds a new item.
        addItem: function (item) {
            return this.insertAt(item, this.items ? this.items.length : 0);
        },

        _getItemByParam: function (item) {
            if (item != null) {
                if (item.index == undefined) {
                    var newItem = this.getItemByValue(item);
                    if (newItem) item = newItem;
                }
            }
            return item;
        },

        insertItem: function (item, index) {
            var newItem = this._getItemByParam(item);
            return this.insertAt(newItem, index);
        },

        updateItem: function (item, oldItem) {
            var oldItemIndx = this._getItemByParam(oldItem);
            if (oldItemIndx && oldItemIndx.index != undefined) {
                return this.updateAt(item, oldItemIndx.index);
            }
            return false;
        },

        updateAt: function (item, index) {
            if (item != null) {
                var listBoxItem = this._mapItem(item);
                this.itemsByValue[$.trim(listBoxItem.value).split(" ").join("?")] = this.items[index];

                this.items[index].value = listBoxItem.value;
                this.items[index].label = listBoxItem.label;
                this.items[index].html = listBoxItem.html;
                this.items[index].disabled = listBoxItem.disabled;
                this._raiseEvent('9', { item: this.items[index] });

            }
            this._cachedItemHtml = [];
            this._renderItems();
            if (this.rendered) {
                this.rendered();
            }
        },

        // inserts an item at a specific position.
        insertAt: function (item, index) {
            if (item == null)
                return false;

            this._cachedItemHtml = [];
            if (this.items == undefined || this.items.length == 0) {
                this.source = new Array();
                this.refresh();
                var listBoxItem = this._mapItem(item);
                listBoxItem.index = 0;
                this.items[this.items.length] = listBoxItem;
                this._addItems(true);
                this._renderItems();
                if (this.rendered) {
                    this.rendered();
                }
                if (this.allowDrag && this._enableDragDrop) {
                    this._enableDragDrop();
                }
                var key = listBoxItem.value;
                if (listBoxItem.value == "" || listBoxItem.value == null) key = index;
                this.itemsByValue[$.trim(key).split(" ").join("?")] = listBoxItem;

                return false;
            }

            var listBoxItem = this._mapItem(item);
            if (index == -1 || index == undefined || index == null || index >= this.items.length) {
                listBoxItem.index = this.items.length;
                this.items[this.items.length] = listBoxItem;
            }
            else {
                var itemsArray = new Array();
                var currentItemIndex = 0;
                var inserted = false;
                var visualItemIndex = 0;
                for (var itemIndex = 0; itemIndex < this.items.length; itemIndex++) {
                    if (this.items[itemIndex].isGroup == false) {
                        if (visualItemIndex >= index && !inserted) {
                            itemsArray[currentItemIndex++] = listBoxItem;
                            listBoxItem.index = index;
                            visualItemIndex++;
                            inserted = true;
                        }
                    }

                    itemsArray[currentItemIndex] = this.items[itemIndex];
                    if (!this.items[itemIndex].isGroup) {
                        itemsArray[currentItemIndex].index = visualItemIndex;
                        visualItemIndex++;
                    }
                    currentItemIndex++;
                }

                this.items = itemsArray;
            }

            var key = listBoxItem.value;
            if (listBoxItem.value == "" || listBoxItem.value == null) key = index;
            this.itemsByValue[$.trim(key).split(" ").join("?")] = listBoxItem;

            this.visibleItems = new Array();
            this.renderedVisibleItems = new Array();
            var vScrollInstance = $.data(this.vScrollBar[0], 'jqxScrollBar').instance;
            var value = vScrollInstance.value;
            vScrollInstance.setPosition(0);
            if ((this.allowDrag && this._enableDragDrop) || (this.virtualSize && this.virtualSize.height < 10 + this.host.height())) {
                this._addItems(true);
            }
            else {
                this._addItems(false);
            }

            if (this.groups.length > 1) {
            }

            this._renderItems();
            if (this.allowDrag && this._enableDragDrop) {
                this._enableDragDrop();
            }
            vScrollInstance.setPosition(value);

            this._raiseEvent('7', { item: listBoxItem });

            if (this.rendered) {
                this.rendered();
            }

            return true;
        },

        // removes an item from a specific position.
        removeAt: function (index) {
            if (index < 0 || index > this.items.length - 1)
                return false;
            if (index == undefined)
                return false;

            var itemHeight = this.items[index].height;
            var key = this.items[index].value;
            if (key == "" || key == null) key = index;
            this.itemsByValue[$.trim(key).split(" ").join("?")] = null;
            var listBoxItem = this.items[index];
            if (this.groups.length > 1) {
                var nonGroups = new Array();
                for (var itemIndex = 0; itemIndex < this.items.length; itemIndex++) {
                    if (!this.items[itemIndex].isGroup) {
                        nonGroups.push({ item: this.items[itemIndex], key: itemIndex });
                    }
                }
                if (nonGroups[index]) {
                    this.items.splice(nonGroups[index].key, 1);
                }
                else return false;
            }
            else {
                this.items.splice(index, 1);
            }

            var itemsInGroup = 0;
            var groupIndex = -1;
            for (var i = 0; i < this.items.length; i++) {
                var item = this.items[i];

                if (item.isGroup) {
                    itemsInGroup = 0;
                    groupIndex = i;
                }
                else if (groupIndex >= 0) {
                    itemsInGroup++;
                }
            }

            if (itemsInGroup === 0 && groupIndex >= 0) {
                this.items.splice(groupIndex, 1);
            }

            var itemsArray = new Array();
            var currentItemIndex = 0;
            var inserted = false;
            var visualItemIndex = 0;
            for (var itemIndex = 0; itemIndex < this.items.length; itemIndex++) {
                itemsArray[currentItemIndex] = this.items[itemIndex];
                if (!this.items[itemIndex].isGroup) {
                    itemsArray[currentItemIndex].index = visualItemIndex;
                    visualItemIndex++;
                }
                currentItemIndex++;
            }

            this.items = itemsArray;

            var vScrollInstance = $.data(this.vScrollBar[0], 'jqxScrollBar').instance;
            var vScrollInstance = $.data(this.vScrollBar[0], 'jqxScrollBar').instance;
            var value = vScrollInstance.value;
            vScrollInstance.setPosition(0);

            this.visibleItems = new Array();
            this.renderedVisibleItems = new Array();
            if (this.items.length > 0) {
                if (this.virtualSize) {
                    this.virtualSize.height -= itemHeight;
                    var virtualItemsCount = this.virtualSize.itemsPerPage * 2;
                    if (this.autoHeight) {
                        virtualItemsCount = this.items.length;
                    }

                    this.virtualItemsCount = Math.min(virtualItemsCount, this.items.length);
                }

                this._updatescrollbars();
            }
            else {
                this._addItems();
            }
            this._renderItems();
            if (this.allowDrag && this._enableDragDrop) {
                this._enableDragDrop();
            }
            if (this.vScrollBar.css('visibility') != 'hidden') {
                vScrollInstance.setPosition(value);
            }
            else {
                vScrollInstance.setPosition(0);
            }
            this.itemsByValue = new Array();
            for (var i = 0; i < this.items.length; i++) {
                var key = this.items[i].value;
                if (this.items[i].value == "" || this.items[i].value == null) key = i;
                this.itemsByValue[$.trim(key).split(" ").join("?")] = this.items[i];
            }
            this._raiseEvent('8', { item: listBoxItem });

            if (this.items.length === 0) {
                this.selectedIndex = -1;
                this.selectedValue = null;
                this._updateInputSelection();
            }
            if (this.rendered) {
                this.rendered();
            }

            return true;
        },

        removeItem: function (item, removed) {
            var newItem = this._getItemByParam(item);
            var index = -1;
            if (newItem && newItem.index != undefined && removed !== true) {
                for (var i = 0; i < this.items.length; i++) {
                    if (this.items[i].label == newItem.label && this.items[i].value == newItem.value) {
                        index = i;
                        break;
                    }
                }
                if (index != -1) {
                    return this.removeAt(index);
                }
            }
            if (index == -1) {
                return this.removeAt(newItem.index);
            }
        },

        // gets all items.
        getItems: function () {
            return this.items;
        },

        disableItem: function (item) {
            var newItem = this._getItemByParam(item);
            this.disableAt(newItem.index);
        },

        enableItem: function (item) {
            var newItem = this._getItemByParam(item);
            this.enableAt(newItem.index);
        },

        // disables an item at position.
        disableAt: function (index) {
            if (!this.items)
                return false;

            if (index < 0 || index > this.items.length - 1)
                return false;

            this.items[index].disabled = true;
            this._renderItems();
            return true;
        },

        // enables an item at position.
        enableAt: function (index) {
            if (!this.items)
                return false;

            if (index < 0 || index > this.items.length - 1)
                return false;

            this.items[index].disabled = false;
            this._renderItems();
            return true;
        },

        destroy: function () {
            if (this.source && this.source.unbindBindingUpdate) {
                this.source.unbindBindingUpdate(this.element.id);
            }

            this._removeHandlers();
            this.vScrollBar.jqxScrollBar('destroy');
            this.hScrollBar.jqxScrollBar('destroy');
            this.vScrollBar.remove();
            this.hScrollBar.remove();
            this.content.remove();
            $.jqx.utilities.resize(this.host, null, true);

            var vars = $.data(this.element, "jqxListBox");
            delete this.hScrollInstance;
            delete this.vScrollInstance;
            delete this.vScrollBar;
            delete this.hScrollBar;
            delete this.content;
            delete this.bottomRight;
            delete this.itemswrapper;
            delete this.visualItems;
            delete this.visibleItems;
            delete this.items;
            delete this.groups;
            delete this.renderedVisibleItems;
            delete this._mousewheelfunc;
            delete this._mousemovefunc;
            delete this._cachedItemHtml;
            delete this.itemsByValue;
            delete this._activeElement;
            delete this.source;
            delete this.events;

            if (this.input) {
                this.input.remove();
                delete this.input;
            }
            if (vars) {
                delete vars.instance;
            }
            this.host.removeData();
            this.host.removeClass();
            this.host.remove();
            this.element = null;
            delete this.element;
            this.host = null;
            delete this.set;
            delete this.get;
            delete this.call;
            delete this.host;
        },

        _raiseEvent: function (id, arg) {
            if (this._stopEvents == true)
                return true;

            if (arg == undefined)
                arg = { owner: null };

            var evt = this.events[id];
            var args = arg;
            args.owner = this;
            this._updateInputSelection();
            var event = new $.Event(evt);
            event.owner = this;
            event.args = args;
            if (this.host != null) {
                var result = this.host.trigger(event);
            }
            return result;
        }
    })
})(jqxBaseFramework);

(function ($) {
    $.jqx.parseSourceTag = function (field) {
        var items = new Array();
        var options = $(field).find('option');
        var groups = $(field).find('optgroup');
        var ul = false;
        if (options.length === 0) {
            options = $(field).find('li');
            if (options.length > 0) {
                ul = true;
            }
        }
        if (options.length === 0) {
            var data = [];

            // select rows.
            var rows = $(field).find("tr");
            // select columns.
            var columns = $(field).find("th");
            var rowOffset = 0;

            if (columns.length === 0 && rows.length > 0) {
                columns = $(rows[0]).find("td");
                rowOffset = 1;
            }


            var sourceColumns = [];
            var dataFields = [];

            var data = [];
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                var datarow = {};

                if (i === rowOffset + 1) {
                    dataFields = [];
                }

                for (var j = 0; j < columns.length; j++) {
                    // get column's title.
                    var columnName = $.trim($(columns[j]).text());
                    // select cell.
                    var cell = $(row).find('td:eq(' + j + ')');
                    datarow[columnName] = $.trim(cell.text());

                    if (i === rowOffset) {
                        sourceColumns.push({ text: columnName, dataField: columnName });
                        dataFields.push({ name: columnName });
                    }

                    if (i === rowOffset + 1) {
                        var type = typeof datarow[columnName];
                        var format = '';

                        if (type === "string") {
                            if (datarow[columnName] === "true" || datarow[columnName] === "false") {
                                type = "bool";
                            }
                            else if (!isNaN(parseFloat(datarow[columnName])) && datarow[columnName].indexOf('-') === -1 && datarow[columnName].indexOf('/') === -1) {
                                type = "number";

                                if (datarow[columnName].indexOf('.') >= 0) {
                                    format = "f";
                                }
                                else {
                                    format = "n";
                                }
                            }
                            else if (datarow[columnName].indexOf('$') >= 0 || datarow[columnName].indexOf('%') >= 0) {
                                type = "number";
                                if (datarow[columnName].indexOf('$') >= 0) {
                                    format = "c";
                                }
                                if (datarow[columnName].indexOf('%') >= 0) {
                                    format = "p";
                                }
                                datarow[columnName] = datarow[columnName].replace('%', '').replace('$', '');
                            }
                            else if (new Date(datarow[columnName]).toString() !== "Invalid Date") {
                                type = "date";
                                format = "d";
                            }
                        }
                        sourceColumns[j].cellsformat = format;
                        if (type === "number") {
                            sourceColumns[j].cellsalign = "right";
                            sourceColumns[j].align = "right";
                        }
                        dataFields.push({ name: columnName, type: type });
                    }
                }

                if (i >= 1) {
                    data[data.length] = datarow;
                }
            }

            var source = {
                localdata: data,
                datatype: "array",
                datafields: dataFields
            };

            return { source: new $.jqx.dataAdapter(source), columns: sourceColumns };
        }

        var selectedOption = null;
        var index = 0;
        var selectedOption = -1;
        var that = this;
        var groupsArray = new Array();

        $.each(options, function (index) {
            var hasGroup = groups.find(this).length > 0;
            var group = null;

            if (this.text != null && (this.label == null || this.label == '')) {
                this.label = this.text;
            }
            if (ul === true) {
                this.label = $(this).text().trim();
                this.selected = $(this).attr('data-selected');
                this.checked = this.selected;
                this.value = $(this).attr('data-value') || index;
                this.disabled = $(this).attr('disabled');
            }

            var item = { style: this.style.cssText, selected: this.selected, html: this.innerHTML.trim(), classes: this.className, disabled: this.disabled, value: this.value, label: this.label, title: this.title, originalItem: this };

            var ie7 = $.jqx.browser.msie && $.jqx.browser.version < 8;
            if (ie7 && !ul) {
                if (item.value == '' && this.text != null && this.text.length > 0) {
                    item.value = this.text;
                }
            }

            if (hasGroup) {
                group = groups.find(this).parent()[0].label;
                item.group = group;
                if (!groupsArray[group]) {
                    groupsArray[group] = new Array();
                    groupsArray.length++;
                }
                groupsArray[group].push(item);
            }

            if (this.selected) {
                selectedOption = index;
            }
            item.checked = this.selected;
            if (item.label !== undefined) {
                items.push(item);
            }
        });
        if (groupsArray.length > 0) {
            var groupItems = new Array();
            for (var obj in groupsArray) {
                if (obj === "indexOf") continue;

                var originalItem = null;
                for (var i = 0; i < groups.length; i++) {
                    if (obj === groups[i].label || groups[i].text) {
                        originalItem = groups[i];
                        break;
                    }
                }

                $.each(groupsArray[obj], function (index, value) {
                    if (this.label !== undefined) {
                        groupItems.push(this);
                    }
                });
            };
        }

        if (groupItems && groupItems.length > 0) {
            return { items: groupItems, index: selectedOption };
        }
        else {
            return { items: items, index: selectedOption };
        }
    }

    $.jqx._jqxListBox.item = function () {
        var result =
        {
            group: '',
            groupHtml: '',
            selected: false,
            isGroup: false,
            highlighted: false,
            value: null,
            label: '',
            html: null,
            visible: true,
            disabled: false,
            element: null,
            width: null,
            height: null,
            initialTop: null,
            top: null,
            left: null,
            title: '',
            index: -1,
            checkBoxElement: null,
            originalItem: null,
            checked: false,
            visibleIndex: -1
        }
        return result;
    }
})(jqxBaseFramework);
})();



/***/ }),

/***/ 1610:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {

    $.jqx.jqxWidget("jqxMenu", "", {});

    $.extend($.jqx._jqxMenu.prototype, {
        defineInstance: function () {
            var settings = {
                //Type: Array
                //Gets the menu's items.
                items: new Array(),
                //Type: String.
                //Default: 'horizontal'.
                //Gets or sets the menu's display mode.
                //Possible Values: 'horizontal', 'vertical', 'popup', 'simple'
                mode: 'horizontal',
                //Type: Number.
                //Default: null.
                //Sets the width.
                width: null,
                //Type: Number.
                //Default: null.
                //Sets the height.
                height: null,
                //Type: Number.
                //Default: 'auto'.
                //Sets the height.
                minimizeWidth: 'auto',
                //Type: String.
                //Default: easeInOutSine.
                //Gets or sets the animation's easing to one of the JQuery's supported easings.
                easing: 'easeInOutSine',
                //Type: Number.
                //Default: 500.
                //Gets or sets the duration of the show animation.
                animationShowDuration: 200,
                //Type: Number.
                //Default: 'fast'.
                //Gets or sets the duration of the hide animation.
                animationHideDuration: 200,
                // Type: Number
                // Default: 0
                // Gets or sets whether the menu is automatically closed after a period of time.
                autoCloseInterval: 0,
                //Type: Number.
                //Default: 500.
                //Gets or sets the delay before the start of the hide animation.
                animationHideDelay: 100,
                //Type: Number.
                //Default: 200.
                //Gets or sets the delay before the start of the show animation.
                animationShowDelay: 10,
                //Type: Array.
                menuElements: new Array(),
                //Type: Boolean.
                //Default: true.
                //Auto-Sizes the Menu's main items when the menu's mode is 'horizontal'.
                autoSizeMainItems: false,
                //Type: Boolean.
                //Default: true.
                //Automatically closes the opened popups after a click.
                autoCloseOnClick: true,
                //Type: Boolean.
                //Default: true.
                //Automatically closes the opened popups after mouse leave.
                autoCloseOnMouseLeave: true,
                //Type: Boolean.
                //Default: true.
                //Enables or disables the rounded corners.
                enableRoundedCorners: true,
                //Type: Boolean.
                //Default: true.
                //Enables or disables the Menu.
                disabled: false,
                //Type: Boolean.
                //Default: true.
                //Opens the Context Menu when the right-mouse button is pressed.
                //When this property is set to false, the Open and Close functions can be used to open and close
                //the Context Menu.
                autoOpenPopup: true,
                // Type: Boolean
                // Default: true
                // enables or disables the hover state.
                enableHover: true,
                // Type: Boolean
                // Default: true
                // opens the top level menu items when the user hovers them.
                autoOpen: true,
                // Type: Boolean
                // Default: false
                // When this property is true, the menu is auto generated using all of ul and li tags inside the host.
                autoGenerate: true,
                // Type: Boolean
                // Default: false
                // opens an item after a click by the user.
                clickToOpen: false,
                // Type: Boolean
                // Default: false
                // shows the top-level item arrows in the default horizontal menu mode.
                showTopLevelArrows: false,
                // Sets whether the menu is on touch device.
                touchMode: 'auto',
                // Sets menu's source.
                source: null,
                popupZIndex: 1000,
                rtl: false,
                keyboardNavigation: false,
                lockFocus: false,
                title: "",
                // Menu events.
                events:
                    [
                        'shown', 'closed', 'itemclick', 'initialized', 'open', 'close'
                    ]
            };
            if (this === $.jqx._jqxMenu.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        createInstance: function (args) {
            var self = this;
            this.host.attr('role', 'menubar');
            $.jqx.utilities.resize(this.host, function () {
                self.refresh();
            }, false, this.mode != "popup");
            if (this.minimizeWidth != "auto" && this.minimizeWidth != null && this.width && this.width.toString().indexOf('%') == -1) {
                $(window).resize(function () {
                    self.refresh();
                });
            }

            if (self.isMaterialized()) {
                var elementStyle = window.getComputedStyle(this.element);
                var animation = elementStyle.getPropertyValue('--jqx-dropdown-animation');

                if (animation) {
                    this.animationType = animation.trim();
                    if (this.animationType === "transform") {
                        this.animationShowDuration = 0;
                        this.animationHideDuration = 0;
                        this.animationShowDelay = 0;
                    }
                }
            }

            this.host.css('outline', 'none');

            if (this.source) {
                if (this.source != null) {
                    var html = this.loadItems(this.source);
                    this.element.innerHTML = html;
                }
            }

            this._tmpHTML = this.element.innerHTML;
            if (this.element.innerHTML.indexOf('UL')) {
                var innerElement = this.host.find('ul:first');
                if (innerElement.length > 0) {
                    this._createMenu(innerElement[0]);
                }
            }

            this.host.data('autoclose', {});

            this._render();
            this._setSize();
            if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                this.host.attr('hideFocus', true);
            }
        },

        focus: function () {
            try {
                if (this.mode === "popup" && this.keyboardNavigation) {
                    var $popupElementparent = this.host.closest('div.jqx-menu-wrapper');
                    $popupElementparent.focus();
                }
                if (this.keyboardNavigation) {
                    this.host.focus();
                    var that = this;
                    var setActiveItem = function () {
                        if (!$.jqx.isHidden($(that.items[0].element))) {
                            $(that.items[0].element).addClass(that.toThemeProperty('jqx-fill-state-focus'));
                            that.activeItem = that.items[0];
                        }
                        else {
                            var item = that._nextVisibleItem(that.items[0], 0);
                            if (item) {
                                $(item.element).addClass(that.toThemeProperty('jqx-fill-state-focus'));
                                that.activeItem = item;
                            }
                        }
                    }

                    if (!this.activeItem) {
                        setActiveItem();
                    }
                    else {
                        if (!$.jqx.isHidden($(this.activeItem.element))) {
                            $(this.activeItem.element).addClass(this.toThemeProperty('jqx-fill-state-focus'));
                        }
                        else {
                            $(this.activeItem.element).removeClass(this.toThemeProperty('jqx-fill-state-focus'));
                            setActiveItem();
                        }
                    }
                }
            }
            catch (error) {
            }
        },

        loadItems: function (items, subMenuWidth) {
            if (items == null) {
                return;
            }
            if (items.length == 0) return "";

            var self = this;
            this.items = new Array();
            var html = '<ul class="jqx-menu-ul">';
            if (subMenuWidth) {
                html = '<ul class="jqx-menu-ul" style="width:' + subMenuWidth + ';">';
            }

            $.map(items, function (item) {
                if (item == undefined)
                    return null;

                html += self._parseItem(item);
            });

            html += '</ul>';
            return html;
        },

        _parseItem: function (item) {
            var html = "";

            if (item == undefined)
                return null;

            var label = item.label;
            if (!item.label && item.html) {
                label = item.html;
            }
            if (!label) {
                label = "Item";
            }

            if (typeof item === 'string') {
                label = item;
            }

            var selected = false;
            if (item.selected != undefined && item.selected) {
                selected = true;
            }

            var disabled = false;
            if (item.disabled != undefined && item.disabled) {
                disabled = true;
            }

            html += '<li';

            if (disabled) {
                html += ' item-disabled="true" ';
            }

            if (item.label && !item.html) {
                html += ' item-label="' + label + '" ';
            }

            if (item.value != null) {
                html += ' item-value="' + item.value + '" ';
            }

            if (item.id != undefined) {
                html += ' id="' + item.id + '" ';
            }

            html += '>' + label;

            if (item.items) {
                if (item.subMenuWidth) {
                    html += this.loadItems(item.items, item.subMenuWidth);
                }
                else {
                    html += this.loadItems(item.items);
                }
            }

            html += '</li>';
            return html;
        },

        _setSize: function () {
            if (this.width != null && this.width.toString().indexOf("%") != -1) {
                this.host.width(this.width);
            }
            else if (this.width != null && this.width.toString().indexOf("px") != -1) {
                this.host.width(this.width);
            }
            else
                if (this.width != undefined && !isNaN(this.width)) {
                    this.host.width(this.width);
                };

            if (this.height != null && this.height.toString().indexOf("%") != -1) {
                this.host.height(this.height);
            }
            else if (this.height != null && this.height.toString().indexOf("px") != -1) {
                this.host.height(this.height);
            }
            else if (this.height != undefined && !isNaN(this.height)) {
                this.host.height(this.height);
            };
            if (this.height === null) {
                this.host.height('auto');
            }

            var me = this;
            if (this.minimizeWidth != null && this.mode != "popup") {
                var windowWidth = $(window).width();

                if (!$.jqx.response) {
                    var isDesktop = false;
                    if (navigator.userAgent.match(/Windows|Linux|MacOS/)) {
                        var isWP = navigator.userAgent.indexOf('Windows Phone') >= 0 || navigator.userAgent.indexOf('WPDesktop') >= 0 || navigator.userAgent.indexOf('IEMobile') >= 0 || navigator.userAgent.indexOf('ZuneWP7') >= 0;
                        if (!isWP) {
                            isDesktop = true;
                        }
                    }

                    var w = this.minimizeWidth;
                    if (isDesktop && this.minimizeWidth == 'auto') {
                        return;
                    }
                }

                if (this.minimizeWidth == 'auto' && $.jqx.response) {
                    var response = new $.jqx.response();
                    if (response.device.type == "Phone" || response.device.type == "Tablet") {
                        if (!this.minimized) {
                            this.minimize();
                        }
                    }
                }
                else {
                    if ((windowWidth < w) && !this.minimized) {
                        this.minimize();
                    }
                    else if (this.minimized && windowWidth >= w) {
                        this.restore()
                    }
                }
            }
        },

        minimize: function () {
            if (this.minimized) return;
            var me = this;
            this.host.addClass(this.toThemeProperty('jqx-menu-minimized'));
            this.minimized = true;
            this._tmpMode = this.mode;
            this.mode = "simple";
            var wrapper = this.host.closest('div.jqx-menu-wrapper');
            wrapper.remove();
            $("#menuWrapper" + this.element.id).remove();
            $.each(this.items, function () {
                var item = this;
                var $menuElement = $(item.element);
                var $submenu = $(item.subMenuElement);
                var $popupElement = $submenu.closest('div.jqx-menu-popup');
                $popupElement.remove();
            });

            if (this.source) {
                var html = this.loadItems(this.source);
                this.element.innerHTML = html;
                this._tmpHTML = this.element.innerHTML;
            }

            this.element.innerHTML = this._tmpHTML;
            if (this.element.innerHTML.indexOf('UL')) {
                var innerElement = this.host.find('ul:first');
                if (innerElement.length > 0) {
                    this._createMenu(innerElement[0]);
                }
            }


            this._render();
            var ul = this.host.find('ul:first');
            ul.wrap('<div class="jqx-menu-wrapper" style="z-index:' + this.popupZIndex + '; padding: 0px; display: none; margin: 0px; height: auto; width: auto; position: absolute; top: 0; left: 0; display: block; visibility: visible;"></div>')
            var wrapper = ul.closest('div.jqx-menu-wrapper');
            wrapper[0].id = "menuWrapper" + this.element.id;
            wrapper.detach();
            wrapper.appendTo($(document.body));
            wrapper.addClass(this.toThemeProperty('jqx-widget'));
            wrapper.addClass(this.toThemeProperty('jqx-menu'));
            wrapper.addClass(this.toThemeProperty('jqx-menu-minimized'));
            wrapper.addClass(this.toThemeProperty('jqx-widget-header'));

            ul.children().hide();
            wrapper.hide();
            wrapper.find('ul').addClass(this.toThemeProperty('jqx-menu-ul-minimized'));
            this.minimizedItem = $("<div></div>");
            this.minimizedItem.addClass(this.toThemeProperty('jqx-item'));
            this.minimizedItem.addClass(this.toThemeProperty('jqx-menu-item-top'));

            this.addHandler(wrapper, 'keydown', function (event) {
                return me.handleKeyDown(event);
            });

            this.minimizedItem.addClass(this.toThemeProperty('jqx-menu-minimized-button'));
            this.minimizedItem.prependTo(this.host);

            this.titleElement = $("<div>" + this.title + "</div>");
            this.titleElement.addClass(this.toThemeProperty('jqx-item'));
            this.titleElement.addClass(this.toThemeProperty('jqx-menu-title'));
            this.titleElement.prependTo(this.host);
            $("<div style='clear:both;'></div>").insertAfter(this.minimizedItem);
            me.minimizedHidden = true;
            var hideMenu = function (e) {
                me.minimizedHidden = true;
                me.minimizedItem.show();
                var fromRight = false;
                if (me.minimizedItem.css('float') == 'right') {
                    fromRight = true;
                }

                wrapper.animate({
                    left: !fromRight ? -wrapper.outerWidth() : me.host.coord().left + me.host.width() + wrapper.width(),
                    opacity: 0
                }, me.animationHideDuration, function () {
                    wrapper.find('ul:first').children().hide();
                    wrapper.hide();
                });
            }

            var toggleMenu = function (e) {
                if (me.minimizedHidden) {
                    wrapper.find('ul:first').children().show();
                    me.minimizedHidden = false;
                    wrapper.show();
                    wrapper.css('opacity', 0);
                    wrapper.css('left', -wrapper.outerWidth());
                    var fromRight = false;
                    var wrapperWidth = wrapper.width();
                    if (me.minimizedItem.css('float') == 'right') {
                        wrapper.css('left', me.host.coord().left + me.host.width() + wrapperWidth);
                        fromRight = true;
                    }
                    wrapper.css('top', me.host.coord().top + me.host.height());
                    wrapper.animate({
                        left: !fromRight ? me.host.coord().left : me.host.coord().left + me.host.width() - wrapperWidth,
                        opacity: 0.95
                    }, me.animationShowDuration, function () {
                    });
                }
                else {
                    hideMenu(e);
                }
                me._raiseEvent('2', { type: "mouse", item: me.minimizedItem[0], event: e });
                me._setSize();
            }
            this.addHandler($(window), 'orientationchange.jqxmenu' + this.element.id, function (e) {
                setTimeout(function () {
                    if (!me.minimizedHidden) {
                        var wrapperWidth = wrapper.width();
                        var fromRight = false;
                        var wrapperWidth = wrapper.width();
                        if (me.minimizedItem.css('float') == 'right') {
                            fromRight = true;
                        }
                        wrapper.css('top', me.host.coord().top + me.host.height());
                        wrapper.css({
                            left: !fromRight ? me.host.coord().left : me.host.coord().left + me.host.width() - wrapperWidth
                        });
                    }
                }, 25);
            });

            this.addHandler(this.minimizedItem, 'click', function (e) {
                toggleMenu(e);
            });
        },

        restore: function () {
            if (!this.minimized) return;

            this.host.find('ul').removeClass(this.toThemeProperty('jqx-menu-ul-minimized'));
            this.host.removeClass(this.toThemeProperty('jqx-menu-minimized'));

            this.minimized = false;
            this.mode = this._tmpMode;
            if (this.minimizedItem)
                this.minimizedItem.remove();

            var wrapper = $("#menuWrapper" + this.element.id);
            wrapper.remove();

            if (this.source) {
                var html = this.loadItems(this.source);
                this.element.innerHTML = html;
                this._tmpHTML = html;
            }

            this.element.innerHTML = this._tmpHTML;
            if (this.element.innerHTML.indexOf('UL')) {
                var innerElement = this.host.find('ul:first');
                if (innerElement.length > 0) {
                    this._createMenu(innerElement[0]);
                }
            }

            this._setSize();
            this._render();
        },

        isTouchDevice: function () {
            if (this._isTouchDevice != undefined) return this._isTouchDevice;
            var isTouchDevice = $.jqx.mobile.isTouchDevice();
            if (this.touchMode == true) {
                isTouchDevice = true;
            }
            else if (this.touchMode == false) {
                isTouchDevice = false;
            }
            if (isTouchDevice) {
                this.host.addClass(this.toThemeProperty('jqx-touch'));
                $(".jqx-menu-item").addClass(this.toThemeProperty('jqx-touch'));
            }
            this._isTouchDevice = isTouchDevice;
            return isTouchDevice;
        },

        refresh: function (initialRefresh) {
            if (!initialRefresh) {
                this._setSize();
            }
        },

        resize: function (width, height) {
            this.width = width;
            this.height = height;
            this.refresh();
        },

        _closeAll: function (e) {
            var me = e != null ? e.data : this;
            var items = me.items;
            $.each(items, function () {
                var item = this;
                if (item.hasItems == true) {
                    if (item.isOpen) {
                        me._closeItem(me, item);
                    }
                }
            });

            if (me.mode == 'popup') {
                if (e != null) {
                    var rightclick = me._isRightClick(e);
                    if (!rightclick) {
                        me.close();
                    }
                }
            }
        },

        // @param id
        // closes a menu item by id.
        closeItem: function (id) {
            if (id == null)
                return false;
            var theId = id;
            var element = document.getElementById(theId);
            var me = this;

            $.each(me.items, function () {
                var item = this;
                if (item.isOpen == true && item.element == element) {
                    me._closeItem(me, item);
                    if (item.parentId) {
                        //        me.closeItem(item.parentId);
                    }
                }
            });

            return true;
        },

        // @param id
        // opens a menu item by id.
        openItem: function (id) {
            if (id == null)
                return false;

            var theId = id;
            var element = document.getElementById(theId);
            var me = this;
            $.each(me.items, function () {
                var item = this;
                if (item.isOpen == false && item.element == element) {
                    me._openItem(me, item);
                    if (item.parentId) {
                        me.openItem(item.parentId);
                    }
                }
            });

            return true;
        },

        _getClosedSubMenuOffset: function (item) {
            var $submenu = $(item.subMenuElement);
            var top = -$submenu.outerHeight();
            var left = -$submenu.outerWidth();
            var isTopItem = item.level == 0 && this.mode == 'horizontal';
            if (isTopItem) {
                left = 0;
            }
            else {
                top = 0;
            }

            switch (item['openVerticalDirection']) {
                case 'up':
                case 'center':
                    top = $submenu.outerHeight();
                    break;
            }

            switch (item['openHorizontalDirection']) {
                case this._getDir('left'):
                    if (isTopItem) {
                        left = 0;
                    }
                    else {
                        left = $submenu.outerWidth();
                    }
                    break;
                case 'center':
                    if (isTopItem) {
                        left = 0;
                    }
                    else {
                        left = $submenu.outerWidth();
                    }
                    break;
            }
            return { left: left, top: top };
        },


        _closeItem: function (me, item, subs, force) {
            if (me == null || item == null)
                return false;


            var $submenu = $(item.subMenuElement);

            var isTopItem = item.level == 0 && this.mode == 'horizontal';
            var subMenuOffset = this._getClosedSubMenuOffset(item);
            var top = subMenuOffset.top;
            var left = subMenuOffset.left;

            var $menuElement = $(item.element);
            var $popupElement = $submenu.closest('div.jqx-menu-popup');
            if ($popupElement != null) {
                $popupElement.removeClass('show');
                var delay = me.animationHideDelay;
                if (force == true) {
                    //     clearTimeout($submenu.data('timer').hide);
                    delay = 0;
                }

                if ($submenu.data('timer') && $submenu.data('timer').show != null) {
                    clearTimeout($submenu.data('timer').show);
                    $submenu.data('timer').show = null;
                }

                var hideFunc = function () {
                    item.isOpen = false;

                    if (isTopItem) {
                        $submenu.stop().animate({ top: top }, me.animationHideDuration, function () {
                            $(item.element).removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                            $(item.element).removeClass(me.toThemeProperty('jqx-menu-item-top-selected'));

                            $(item.element).removeClass(me.toThemeProperty('jqx-rc-b-expanded'));
                            $popupElement.removeClass(me.toThemeProperty('jqx-rc-t-expanded'));
                            var $arrowSpan = $(item.arrow);
                            if ($arrowSpan.length > 0 && me.showTopLevelArrows) {
                                $arrowSpan.removeClass();
                                if (item.openVerticalDirection == 'down') {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-down'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-down'));
                                }
                                else {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-up'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-up'));
                                }
                            }
                            $.jqx.aria($(item.element), 'aria-expanded', false);

                            $popupElement.css({ display: 'none' });
                            if (me.animationHideDuration == 0) {
                                $submenu.css({ top: top });
                            }
                            me._raiseEvent('1', item);
                        })
                    }
                    else {
                        if (!$.jqx.browser.msie) {
                            //       $popupElement.stop().animate({ opacity: 0 }, me.animationHideDuration, function () {
                            //         });
                        }

                        $submenu.stop().animate({ left: left }, me.animationHideDuration, function () {
                            if (me.animationHideDuration == 0) {
                                $submenu.css({ left: left });
                            }

                            if (item.level > 0) {
                                $(item.element).removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                                $(item.element).removeClass(me.toThemeProperty('jqx-menu-item-selected'));
                                var $arrowSpan = $(item.arrow);
                                if ($arrowSpan.length > 0) {
                                    $arrowSpan.removeClass();
                                    if (item.openHorizontalDirection != 'left') {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right')));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                                    }
                                    else {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('left')));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('left')));
                                    }
                                }
                            }
                            else {
                                $(item.element).removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                                $(item.element).removeClass(me.toThemeProperty('jqx-menu-item-top-selected'));
                                var $arrowSpan = $(item.arrow);
                                if ($arrowSpan.length > 0) {
                                    $arrowSpan.removeClass();
                                    if (item.openHorizontalDirection != 'left') {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-top-' + me._getDir('right')));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                                    }
                                    else {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-top-' + me._getDir('left')));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('left')));
                                    }
                                }
                            }
                            $.jqx.aria($(item.element), 'aria-expanded', false);
                            $popupElement.css({ display: 'none' })
                            me._raiseEvent('1', item);
                        })
                    }
                }

                if (delay > 0) {
                    if ($submenu.data('timer')) {
                        $submenu.data('timer').hide = setTimeout(function () {
                            hideFunc();
                        }, delay);
                    }
                }
                else {
                    hideFunc();
                }

                if (subs != undefined && subs) {
                    var children = $submenu.children();// find('.' + me.toThemeProperty('jqx-menu-item'));
                    $.each(children, function () {
                        if (me.menuElements[this.id] && me.menuElements[this.id].isOpen) {
                            var $submenu = $(me.menuElements[this.id].subMenuElement);
                            me._closeItem(me, me.menuElements[this.id], true, true);
                        }
                    });
                }
            }
        },

        // @param id
        // @param array.
        // get menu item's sub items.
        getSubItems: function (id, array) {
            if (id == null)
                return false;

            var me = this;
            var subItems = new Array();
            if (array != null) {
                $.extend(subItems, array);
            }

            var theId = id;
            var item = this.menuElements[theId];
            var $submenu = $(item.subMenuElement);
            var children = $submenu.find('.jqx-menu-item');
            $.each(children, function () {
                subItems[this.id] = me.menuElements[this.id];
                var innerArray = me.getSubItems(this.id, subItems);
                $.extend(subItems, innerArray);
            });

            return subItems;
        },

        // disables a menu item.
        // @param id
        // @param Boolean
        disable: function (id, disable) {
            if (id == null)
                return;
            var theId = id;
            var me = this;
            if (this.menuElements[theId]) {
                var item = this.menuElements[theId];
                item.disabled = disable;
                var $element = $(item.element);
                item.element.disabled = disable;
                $.each($element.children(), function () {
                    this.disabled = disable;
                });

                if (disable) {
                    $element.addClass(me.toThemeProperty('jqx-menu-item-disabled'));
                    $element.addClass(me.toThemeProperty('jqx-fill-state-disabled'));
                }
                else {
                    $element.removeClass(me.toThemeProperty('jqx-menu-item-disabled'));
                    $element.removeClass(me.toThemeProperty('jqx-fill-state-disabled'));
                }
            }
        },

        getItem: function (id) {
            if (this.menuElements[id]) {
                var item = this.menuElements[id];
                return item;
            }
            return null;
        },

        disableItem: function (id) {
            this.disable(id, true);
        },

        hideItem: function (id) {
            if (this.menuElements[id]) {
                var item = this.menuElements[id];
                $(item.element).hide();
            }
        },

        showItem: function (id) {
            if (this.menuElements[id]) {
                var item = this.menuElements[id];
                $(item.element).show();
            }
        },


        enableItem: function (id) {
            this.disable(id, false);
        },

        _setItemProperty: function (id, propertyname, value) {
            if (id == null)
                return;

            var theId = id;
            var me = this;

            if (this.menuElements[theId]) {
                var item = this.menuElements[theId];
                if (item[propertyname]) {
                    item[propertyname] = value;
                }
            }
        },

        // sets the open direction of an item.
        // @param id
        // @param String
        // @param String
        setItemOpenDirection: function (id, horizontal, vertical) {
            if (id == null)
                return;
            var theId = id;
            var me = this;
            var ie7 = $.jqx.browser.msie && $.jqx.browser.version < 8;

            if (this.menuElements[theId]) {
                var item = this.menuElements[theId];
                if (horizontal != null) {
                    item['openHorizontalDirection'] = horizontal;
                    if (item.hasItems && item.level > 0) {
                        var $element = $(item.element);
                        if ($element != undefined) {
                            var $arrowSpan = $(item.arrow);
                            if (item.arrow == null) {
                                $arrowSpan = $('<span id="arrow' + $element[0].id + '"></span>');
                                if (!ie7) {
                                    $arrowSpan.prependTo($element);
                                }
                                else {
                                    $arrowSpan.appendTo($element);
                                }
                                item.arrow = $arrowSpan[0];
                            }
                            $arrowSpan.removeClass();
                            if (item.openHorizontalDirection == 'left') {
                                $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('left')));
                                $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('left')));
                            }
                            else {
                                $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right')));
                                $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                            }
                            $arrowSpan.css('visibility', 'inherit');

                            if (!ie7) {
                                $arrowSpan.css('display', 'block');
                                $arrowSpan.css('float', 'right');
                            }
                            else {
                                $arrowSpan.css('display', 'inline-block');
                                $arrowSpan.css('float', 'none');
                            }
                        }
                    }
                }
                if (vertical != null) {
                    item['openVerticalDirection'] = vertical;
                    var $arrowSpan = $(item.arrow);
                    var $element = $(item.element);
                    if (!me.showTopLevelArrows) {
                        return;
                    }

                    if ($element != undefined) {
                        if (item.arrow == null) {
                            $arrowSpan = $('<span id="arrow' + $element[0].id + '"></span>');
                            if (!ie7) {
                                $arrowSpan.prependTo($element);
                            }
                            else {
                                $arrowSpan.appendTo($element);
                            }
                            item.arrow = $arrowSpan[0];
                        }
                        $arrowSpan.removeClass();
                        if (item.openVerticalDirection == 'down') {
                            $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-down'));
                            $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-down'));
                        }
                        else {
                            $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-up'));
                            $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-up'));
                        }
                        $arrowSpan.css('visibility', 'inherit');
                        if (!ie7) {
                            $arrowSpan.css('display', 'block');
                            $arrowSpan.css('float', 'right');
                        }
                        else {
                            $arrowSpan.css('display', 'inline-block');
                            $arrowSpan.css('float', 'none');

                        }
                    }
                }
            }
        },


        _getSiblings: function (item) {
            var siblings = new Array();
            var index = 0;
            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i] == item)
                    continue;

                if (this.items[i].parentId == item.parentId && this.items[i].hasItems) {
                    siblings[index++] = this.items[i];
                }
            }
            return siblings;
        },


        _openItem: function (me, item, zIndex) {
            if (me == null || item == null)
                return false;

            if (item.isOpen)
                return false;

            if (item.disabled)
                return false;

            if (me.disabled)
                return false;
            var zIndx = me.popupZIndex;
            if (zIndex != undefined) {
                zIndx = zIndex;
            }

            var hideDuration = me.animationHideDuration;
            me.animationHideDuration = 0;
            me._closeItem(me, item, true, true);
            me.animationHideDuration = hideDuration;

            $(item.element).focus();

            //  this.host.focus();

            var popupElementoffset = [5, 5];
            var $submenu = $(item.subMenuElement);
            if ($submenu != null) {
                $submenu.stop();
            }
            // stop hiding process.
            if ($submenu.data('timer') && $submenu.data('timer').hide != null) {
                clearTimeout($submenu.data('timer').hide);
                //      $submenu.data('timer').hide = null;
            }
            var $popupElement = $submenu.closest('div.jqx-menu-popup');
            var $menuElement = $(item.element);
            var offset = item.level == 0 ? this._getOffset(item.element) : $menuElement.position()

            if (item.level > 0 && this.hasTransform) {
                var topTransform = parseInt($menuElement.coord().top) - parseInt(this._getOffset(item.element).top);
                offset.top += topTransform;
            }

            if (item.level == 0 && this.mode == 'popup') {
                offset = $menuElement.coord();
            }

            var isTopItem = item.level == 0 && this.mode == 'horizontal';

            var menuItemLeftOffset = isTopItem ? offset.left : this.menuElements[item.parentId] != null && this.menuElements[item.parentId].subMenuElement != null ? parseInt($($(this.menuElements[item.parentId].subMenuElement).closest('div.jqx-menu-popup')).outerWidth()) - popupElementoffset[0]
                : parseInt($submenu.outerWidth());

            $popupElement.css({ visibility: 'visible', display: 'block', left: menuItemLeftOffset, top: isTopItem ? offset.top + $menuElement.outerHeight() : offset.top, zIndex: zIndx })
            $submenu.css('display', 'block');

            if (this.mode != 'horizontal' && item.level == 0) {
                var hostOffset = this._getOffset(this.element)
                $popupElement.css('left', -1 + hostOffset.left + this.host.outerWidth());

                //          $popupElement.css('left', -2 + offset.left + this.host.width() - popupElementoffset[0]);
                $submenu.css('left', -$submenu.outerWidth());
            }
            else {
                var subMenuOffset = this._getClosedSubMenuOffset(item);
                $submenu.css('left', subMenuOffset.left);
                $submenu.css('top', subMenuOffset.top);
            }

            $popupElement.css({ height: parseInt($submenu.outerHeight()) + parseInt(popupElementoffset[1]) + 'px' });

            var top = 0;
            var left = 0;

            switch (item['openVerticalDirection']) {
                case 'up':
                    if (isTopItem) {
                        $submenu.css('top', $submenu.outerHeight());
                        top = popupElementoffset[1];
                        var paddingBottom = parseInt($submenu.parent().css('padding-bottom'));
                        if (isNaN(paddingBottom)) paddingBottom = 0;
                        if (paddingBottom > 0) {
                            $popupElement.addClass(this.toThemeProperty('jqx-menu-popup-clear'));
                        }

                        $submenu.css('top', $submenu.outerHeight() - paddingBottom);
                        $popupElement.css({ display: 'block', top: offset.top - $popupElement.outerHeight(), zIndex: zIndx })
                    }
                    else {
                        top = popupElementoffset[1];
                        $submenu.css('top', $submenu.outerHeight());
                        $popupElement.css({ display: 'block', top: offset.top - $popupElement.outerHeight() + popupElementoffset[1] + $menuElement.outerHeight(), zIndex: zIndx })
                    }
                    break;
                case 'center':
                    if (isTopItem) {
                        $submenu.css('top', 0);
                        $popupElement.css({ display: 'block', top: offset.top - $popupElement.outerHeight() / 2 + popupElementoffset[1], zIndex: zIndx })
                    }
                    else {
                        $submenu.css('top', 0);
                        $popupElement.css({ display: 'block', top: offset.top + $menuElement.outerHeight() / 2 - $popupElement.outerHeight() / 2 + popupElementoffset[1], zIndex: zIndx })
                    }

                    break;
            }

            switch (item['openHorizontalDirection']) {
                case this._getDir('left'):
                    if (isTopItem) {
                        $popupElement.css({ left: offset.left - ($popupElement.outerWidth() - $menuElement.outerWidth() - popupElementoffset[0]) });
                    }
                    else {
                        left = 0;
                        $submenu.css('left', $popupElement.outerWidth());
                        $popupElement.css({ left: offset.left - ($popupElement.outerWidth()) + 2 * item.level });
                    }
                    break;
                case 'center':
                    if (isTopItem) {
                        $popupElement.css({ left: offset.left - ($popupElement.outerWidth() / 2 - $menuElement.outerWidth() / 2 - popupElementoffset[0] / 2) });
                    }
                    else {
                        $popupElement.css({ left: offset.left - ($popupElement.outerWidth() / 2 - $menuElement.outerWidth() / 2 - popupElementoffset[0] / 2) });
                        $submenu.css('left', $popupElement.outerWidth());
                    }
                    break;
            }

            if (isTopItem) {
                if (parseInt($submenu.css('top')) == top) {
                    item.isOpen = true;
                    return;
                }
            }
            else if (parseInt($submenu.css('left')) == left) {
                item.isOpen == true;
                return;
            }

            $.each(me._getSiblings(item), function () {
                me._closeItem(me, this, true, true);
            });
            var hideDelay = $.data(me.element, 'animationHideDelay');
            me.animationHideDelay = hideDelay;


            if (this.autoCloseInterval > 0) {
                if (this.host.data('autoclose') != null && this.host.data('autoclose').close != null) {
                    clearTimeout(this.host.data('autoclose').close);
                }

                if (this.host.data('autoclose') != null) {
                    this.host.data('autoclose').close = setTimeout(function () {
                        me._closeAll();
                    }, this.autoCloseInterval);
                }
            }
            if ($submenu.data('timer')) {
                $submenu.data('timer').show = setTimeout(function () {
                    if ($popupElement != null) {
                        if (isTopItem) {
                            $submenu.stop();
                            $submenu.css('left', left);
                            if (!$.jqx.browser.msie) {
                                //      $popupElement.css('opacity', 0.0);
                            }

                            $menuElement.addClass(me.toThemeProperty('jqx-fill-state-pressed'));
                            $menuElement.addClass(me.toThemeProperty('jqx-menu-item-top-selected'));
                            if (item.openVerticalDirection == "down") {
                                $(item.element).addClass(me.toThemeProperty('jqx-rc-b-expanded'));
                                $popupElement.addClass(me.toThemeProperty('jqx-rc-t-expanded'));
                                $popupElement.addClass(me.toThemeProperty('show'));
                            }
                            else {
                                $(item.element).addClass(me.toThemeProperty('jqx-rc-t-expanded'));
                                $popupElement.addClass(me.toThemeProperty('jqx-rc-b-expanded'));
                                $popupElement.addClass(me.toThemeProperty('show'));
                            }

                            var $arrowSpan = $(item.arrow);
                            if ($arrowSpan.length > 0 && me.showTopLevelArrows) {
                                $arrowSpan.removeClass();
                                if (item.openVerticalDirection == 'down') {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-down-selected'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-down'));
                                }
                                else {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-up-selected'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-up'));
                                }
                            }

                            if (me.animationShowDuration == 0) {
                                $submenu.css({ top: top });
                                item.isOpen = true;
                                me._raiseEvent('0', item);
                                $.jqx.aria($(item.element), 'aria-expanded', true);
                            }
                            else {
                                $submenu.animate({ top: top }, me.animationShowDuration, me.easing,
                                    function () {
                                        item.isOpen = true;
                                        $.jqx.aria($(item.element), 'aria-expanded', true);
                                        me._raiseEvent('0', item);
                                    }) //animate submenu into view
                            }
                        }
                        else {
                            $submenu.stop();
                            $submenu.css('top', top);

                            $popupElement.addClass(me.toThemeProperty('show'));


                            if (!$.jqx.browser.msie) {
                                //     $popupElement.css('opacity', 0.0);
                            }

                            if (item.level > 0) {
                                $menuElement.addClass(me.toThemeProperty('jqx-fill-state-pressed'));
                                $menuElement.addClass(me.toThemeProperty('jqx-menu-item-selected'));
                                var $arrowSpan = $(item.arrow);
                                if ($arrowSpan.length > 0) {
                                    $arrowSpan.removeClass();
                                    if (item.openHorizontalDirection != 'left') {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right') + '-selected'));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                                    }
                                    else {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('left') + '-selected'));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('left')));
                                    }
                                }
                            }
                            else {
                                $menuElement.addClass(me.toThemeProperty('jqx-fill-state-pressed'));
                                $menuElement.addClass(me.toThemeProperty('jqx-menu-item-top-selected'));
                                var $arrowSpan = $(item.arrow);
                                if ($arrowSpan.length > 0) {
                                    $arrowSpan.removeClass();
                                    if (item.openHorizontalDirection != 'left') {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right') + '-selected'));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                                    }
                                    else {
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('left') + '-selected'));
                                        $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('left')));
                                    }
                                }
                            }
                            if (!$.jqx.browser.msie) {
                                //      $popupElement.animate({ opacity: 1 }, 2 * me.animationShowDuration, me.easing,
                                //   function () {

                                // })
                            }
                            if (me.animationShowDuration == 0) {
                                $submenu.css({ left: left });
                                me._raiseEvent('0', item);
                                item.isOpen = true;
                                $.jqx.aria($(item.element), 'aria-expanded', true);
                            }
                            else {
                                $submenu.animate({ left: left }, me.animationShowDuration, me.easing, function () {
                                    me._raiseEvent('0', item);
                                    item.isOpen = true;
                                    $.jqx.aria($(item.element), 'aria-expanded', true);
                                }) //animate submenu into view
                            }
                        }
                    }
                }, this.animationShowDelay);
            }
        },

        _getDir: function (dir) {
            switch (dir) {
                case 'left':
                    return !this.rtl ? 'left' : 'right';
                case 'right':
                    return this.rtl ? 'left' : 'right';
            }
            return 'left';
        },


        _applyOrientation: function (mode, oldmode) {
            var me = this;
            var maxHeight = 0;
            me.host.removeClass(me.toThemeProperty('jqx-menu-horizontal'));
            me.host.removeClass(me.toThemeProperty('jqx-menu-vertical'));
            me.host.removeClass(me.toThemeProperty('jqx-menu'));
            me.host.removeClass(me.toThemeProperty('jqx-widget'));
            me.host.addClass(me.toThemeProperty('jqx-widget'));
            me.host.addClass(me.toThemeProperty('jqx-menu'));

            if (mode != undefined && oldmode != undefined && oldmode == 'popup') {
                if (me.host.parent().length > 0 && me.host.parent().parent().length > 0 && me.host.parent().parent()[0] == document.body) {
                    var oldHost = $.data(document.body, 'jqxMenuOldHost' + me.element.id);
                    if (oldHost != null) {
                        var $popupElementparent = me.host.closest('div.jqx-menu-wrapper')
                        $popupElementparent.remove();
                        $popupElementparent.appendTo(oldHost);
                        me.host.css('display', 'block');
                        me.host.css('visibility', 'visible');
                        $popupElementparent.css('display', 'block');
                        $popupElementparent.css('visibility', 'visible');
                    }
                }
            }
            else if (mode == undefined && oldmode == undefined) {
                $.data(document.body, 'jqxMenuOldHost' + me.element.id, me.host.parent()[0]);
            }

            if (me.autoOpenPopup) {
                if (me.mode == 'popup') {
                    me.addHandler($(document), 'contextmenu.' + me.element.id, function (e) {
                        return false;
                    });

                    me.addHandler($(document), 'mousedown.menu' + me.element.id, function (event) {
                        me._openContextMenu(event);
                    });
                }
                else {
                    me.removeHandler($(document), 'contextmenu.' + me.element.id);
                    me.removeHandler($(document), 'mousedown.menu' + me.element.id);
                }
            }
            else {
                me.removeHandler($(document), 'contextmenu.' + me.element.id);
                me.removeHandler($(document), 'mousedown.menu' + me.element.id);
                me.addHandler($(document), 'contextmenu.' + me.element.id, function (e) {
                    if (e.target && e.target.className.indexOf && e.target.className.indexOf('jqx-menu') >= 0) {
                        return false;
                    }
                });
            }

            if (me.rtl) {
                me.host.addClass(me.toThemeProperty('jqx-rtl'));
            }

            switch (me.mode) {
                case 'horizontal':
                    me.host.addClass(me.toThemeProperty('jqx-widget-header'));
                    me.host.addClass(me.toThemeProperty('jqx-menu-horizontal'));

                    $.each(me.items, function () {
                        var item = this;
                        var $element = $(item.element);

                        var $arrowSpan = $(item.arrow);
                        $arrowSpan.removeClass();

                        if (item.hasItems && item.level > 0) {
                            var $arrowSpan = $('<span style="border: none; background-color: transparent;" id="arrow' + $element[0].id + '"></span>');
                            $arrowSpan.prependTo($element);
                            $arrowSpan.css('float', me._getDir('right'));
                            $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right')));
                            $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                            item.arrow = $arrowSpan[0];
                        }

                        if (item.level == 0) {
                            $(item.element).css('float', me._getDir('left'));
                            if (!item.ignoretheme && item.hasItems && me.showTopLevelArrows) {
                                var $arrowSpan = $('<span style="border: none; background-color: transparent;" id="arrow' + $element[0].id + '"></span>');
                                var ie7 = $.jqx.browser.msie && $.jqx.browser.version < 8;

                                if (item.arrow == null) {
                                    if (!ie7) {
                                        $arrowSpan.prependTo($element);
                                    }
                                    else {
                                        $arrowSpan.appendTo($element);
                                    }
                                } else {
                                    $arrowSpan = $(item.arrow);
                                }
                                if (item.openVerticalDirection == 'down') {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-down'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-down'));
                                }
                                else {
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-up'));
                                    $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-up'));
                                }

                                $arrowSpan.css('visibility', 'inherit');

                                if (!ie7) {
                                    $arrowSpan.css('display', 'block');
                                    $arrowSpan.css('float', 'right');
                                }
                                else {
                                    $arrowSpan.css('display', 'inline-block');
                                }

                                item.arrow = $arrowSpan[0];
                            }
                            else if (!item.ignoretheme && item.hasItems && !me.showTopLevelArrows) {
                                if (item.arrow != null) {
                                    var $arrowSpan = $(item.arrow);
                                    $arrowSpan.remove();
                                    item.arrow = null;
                                }
                            }
                            maxHeight = Math.max(maxHeight, $element.height());
                        }
                    });
                    break;
                case 'vertical':
                case 'popup':
                case 'simple':
                    me.host.addClass(me.toThemeProperty('jqx-menu-vertical'));

                    $.each(me.items, function () {
                        var item = this;
                        var $element = $(item.element);
                        if (item.hasItems && !item.ignoretheme) {
                            if (item.arrow) {
                                $(item.arrow).remove();
                            }
                            if (me.mode == 'simple') return true;

                            var $arrowSpan = $('<span style="border: none; background-color: transparent;" id="arrow' + $element[0].id + '"></span>');

                            $arrowSpan.prependTo($element);
                            $arrowSpan.css('float', 'right');

                            if (item.level == 0) {
                                $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-top-' + me._getDir('right')));
                                $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                            }
                            else {
                                $arrowSpan.addClass(me.toThemeProperty('jqx-menu-item-arrow-' + me._getDir('right')));
                                $arrowSpan.addClass(me.toThemeProperty('jqx-icon-arrow-' + me._getDir('right')));
                            }
                            item.arrow = $arrowSpan[0];
                        }
                        $element.css('float', 'none');
                    });

                    if (me.mode == 'popup') {
                        me.host.addClass(me.toThemeProperty('jqx-widget-content'));
                        me.host.wrap('<div tabindex=0 class="jqx-menu-wrapper" style="z-index:' + me.popupZIndex + '; border: none; background-color: transparent; padding: 0px; margin: 0px; position: absolute; top: 0; left: 0; display: block; visibility: visible;"></div>')
                        var $popupElementparent = me.host.closest('div.jqx-menu-wrapper')
                        me.host.addClass(me.toThemeProperty('jqx-popup'));
                        $popupElementparent[0].id = "menuWrapper" + me.element.id;
                        $popupElementparent.appendTo($(document.body));
                        me.addHandler($popupElementparent, 'keydown', function (event) {
                            return me.handleKeyDown(event);
                        });
                    }
                    else {
                        me.host.addClass(me.toThemeProperty('jqx-widget-header'));
                    }

                    if (me.mode == 'popup') {
                        var height = me.host.height();
                        me.host.css('position', 'absolute');
                        me.host.css('top', '0');
                        me.host.css('left', '0');
                        if (me.mode != "simple") {
                            me.host.height(height);
                            me.host.css('display', 'none');
                        }
                    }
                    break;
            }
            var isTouchDevice = me.isTouchDevice();
            if (me.autoCloseOnClick) {
                me.removeHandler($(document), 'mousedown.menu' + me.element.id, me._closeAfterClick);
                me.addHandler($(document), 'mousedown.menu' + me.element.id, me._closeAfterClick, me);
                if (isTouchDevice) {
                    me.removeHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.menu' + me.element.id, me._closeAfterClick, me);
                    me.addHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.menu' + me.element.id, me._closeAfterClick, me);
                }
            }
        },

        _getBodyOffset: function () {
            var top = 0;
            var left = 0;
            if ($('body').css('border-top-width') != '0px') {
                top = parseInt($('body').css('border-top-width'));
                if (isNaN(top)) top = 0;
            }
            if ($('body').css('border-left-width') != '0px') {
                left = parseInt($('body').css('border-left-width'));
                if (isNaN(left)) left = 0;
            }
            return { left: left, top: top };
        },

        _getOffset: function (object) {
            //       var scrollTop = $(window).scrollTop();
            //       var scrollLeft = $(window).scrollLeft();
            var isSafari = $.jqx.mobile.isSafariMobileBrowser();

            var offset = $(object).coord(true);
            var top = offset.top;
            var left = offset.left;

            if ($('body').css('border-top-width') != '0px') {
                top = parseInt(top) + this._getBodyOffset().top;
            }
            if ($('body').css('border-left-width') != '0px') {
                left = parseInt(left) + this._getBodyOffset().left;
            }

            var windowsPhone = $.jqx.mobile.isWindowsPhone();
            var touchDevice = $.jqx.mobile.isTouchDevice();

            if (this.hasTransform || (isSafari != null && isSafari) || windowsPhone || touchDevice) {
                var point = { left: $.jqx.mobile.getLeftPos(object), top: $.jqx.mobile.getTopPos(object) };
                return point;
            }
            else return { left: left, top: top };
        },

        _isRightClick: function (e) {
            var rightclick;
            if (!e) var e = window.event;
            if (e.which) rightclick = (e.which == 3);
            else if (e.button) rightclick = (e.button == 2);
            return rightclick;
        },

        _openContextMenu: function (e) {
            var me = this;
            var rightclick = me._isRightClick(e);

            if (rightclick) {
                me.open(parseInt(e.clientX) + 5, parseInt(e.clientY) + 5);
            }
        },

        // closes a context menu.
        close: function () {
            var me = this;
            if (!this.element) {
                return;
            }

            var opened = $.data(this.element, 'contextMenuOpened' + this.element.id);
            if (opened) {
                var host = this.host;
                me.host.removeClass('jqx-popup-show');

                $.each(me.items, function () {
                    var item = this;
                    if (item.hasItems) {
                        me._closeItem(me, item);
                    }
                });

                $.each(me.items, function () {
                    var item = this;
                    if (item.isOpen == true) {
                        var $submenu = $(item.subMenuElement);
                        var $popupElement = $submenu.closest('div.jqx-menu-popup')
                        $popupElement.hide(this.animationHideDuration);

                    }
                });

                this.host.hide(this.animationHideDuration);
                $.data(me.element, 'contextMenuOpened' + this.element.id, false);
                me._raiseEvent('1', me);
                me._raiseEvent('5');
            }
        },

        // @param String. Horizontal offset
        // @param String. Vertical Offset
        // opens a context menu.
        open: function (left, top) {
            if (this.mode == 'popup') {
                var duration = 0;
                if (this.host.css('display') == 'block') {
                    this.close();
                    duration = this.animationHideDuration;
                }

                var me = this;

                if (left == undefined || left == null) left = 0;
                if (top == undefined || top == null) top = 0;

                setTimeout(function () {
                    me.host.show(me.animationShowDuration);
                    me.host.css('visibility', 'visible');
                    me.host.addClass('jqx-popup-show');
                    $.data(me.element, 'contextMenuOpened' + me.element.id, true);
                    me._raiseEvent('0', me);
                    me._raiseEvent('4', { left: left, top: top });
                    me.host.css('z-index', me.popupZIndex);

                    if (left != undefined && top != undefined) {
                        me.host.css({ 'left': left, 'top': top });
                    }
                    me.focus();
                }, duration);
            }
        },

        _renderHover: function ($menuElement, item, isTouchDevice) {
            var me = this;
            if (!item.ignoretheme) {
                this.addHandler($menuElement, 'mouseenter', function () {
                    me.hoveredItem = item;
                    if (!item.disabled && !item.separator && me.enableHover && !me.disabled) {
                        if (item.level > 0) {
                            $menuElement.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                            $menuElement.addClass(me.toThemeProperty('jqx-menu-item-hover'));
                        }
                        else {
                            $menuElement.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                            $menuElement.addClass(me.toThemeProperty('jqx-menu-item-top-hover'));
                        }
                    }
                });
                this.addHandler($menuElement, 'mouseleave', function () {
                    if (!item.disabled && !item.separator && me.enableHover && !me.disabled) {
                        if (item.level > 0) {
                            $menuElement.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                            $menuElement.removeClass(me.toThemeProperty('jqx-menu-item-hover'));
                        }
                        else {
                            $menuElement.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                            $menuElement.removeClass(me.toThemeProperty('jqx-menu-item-top-hover'));
                        }
                    }
                });
            }
        },

        _closeAfterClick: function (event) {
            var me = event != null ? event.data : this;
            var matches = false;
            if (me.autoCloseOnClick) {
                $.each($(event.target).parents(), function () {
                    if (this.className.indexOf) {
                        if (this.className.indexOf('jqx-menu') != -1) {
                            matches = true;
                            return false;
                        }
                    }
                });

                if (!matches) {
                    event.data = me;
                    me._closeAll(event);
                }
            }
        },

        _autoSizeHorizontalMenuItems: function () {
            var me = this;
            if (me.autoSizeMainItems && this.mode == "horizontal") {
                var maxHeight = this.maxHeight;
                if (parseInt(maxHeight) > parseInt(this.host.height())) {
                    maxHeight = parseInt(this.host.height());
                }
                maxHeight = parseInt(this.host.height());

                // align vertically the items.
                $.each(this.items, function () {
                    var item = this;
                    var $element = $(item.element);
                    if (item.level == 0 && maxHeight > 0) {
                        var childrenHeight = $element.children().length > 0 ? parseInt($element.children().height()) : $element.height();
                        // vertically align content.
                        var $ul = me.host.find('ul:first');
                        var paddingOffset = parseInt($ul.css('padding-top'));
                        var marginOffset = parseInt($ul.css('margin-top'));
                        //   var borderOffset = parseInt(me.host.css('border-top-width'));
                        var height = maxHeight - 2 * (marginOffset + paddingOffset);
                        var newPadding = parseInt(height) / 2 - childrenHeight / 2;
                        var topPadding = parseInt(newPadding);
                        var bottomPadding = parseInt(newPadding);
                        $element.css('padding-top', topPadding);
                        $element.css('padding-bottom', bottomPadding);

                        if (parseInt($element.outerHeight()) > height) {
                            var offset = 1;
                            $element.css('padding-top', topPadding - offset);
                            topPadding = topPadding - offset;
                        }
                    }
                });
            }
            $.each(this.items, function () {
                var item = this;
                var $element = $(item.element);
                if (item.hasItems && item.level > 0) {
                    if (item.arrow) {
                        var $arrowSpan = $(item.arrow);
                        var height = $(item.element).height();
                        if (height > 15) {
                            $arrowSpan.css('margin-top', (height - 15) / 2);
                        }
                    }
                }
            });
        },

        _nextVisibleItem: function (item, level) {
            if (item == null || item == undefined)
                return null;

            var currentItem = item;
            while (currentItem != null) {
                currentItem = currentItem.nextItem;
                if (this._isVisible(currentItem) && !currentItem.disabled && currentItem.type !== "separator") {
                    if (this.minimized) {
                        return currentItem;
                    }

                    if (level != undefined) {
                        if (currentItem && currentItem.level != level)
                            continue;
                    }

                    return currentItem;
                }
            }

            return null;
        },

        _prevVisibleItem: function (item, level) {
            if (item == null || item == undefined)
                return null;

            var currentItem = item;
            while (currentItem != null) {
                currentItem = currentItem.prevItem;
                if (this._isVisible(currentItem) && !currentItem.disabled && currentItem.type !== "separator") {
                    if (this.minimized) {
                        return currentItem;
                    }

                    if (level != undefined) {
                        if (currentItem && currentItem.level != level)
                            continue;
                    }
                    return currentItem;
                }
            }

            return null;
        },

        _parentItem: function (item) {
            if (item == null || item == undefined)
                return null;

            var parent = item.parentElement;
            if (!parent) return null;
            var parentItem = null;

            $.each(this.items, function () {
                if (this.element == parent) {
                    parentItem = this;
                    return false;
                }
            });

            return parentItem;
        },

        _isElementVisible: function (element) {
            if (element == null)
                return false;

            if ($(element).css('display') != 'none' && $(element).css('visibility') != 'hidden') {
                return true;
            }

            return false;
        },

        _isVisible: function (item) {
            if (item == null || item == undefined)
                return false;

            if (!this._isElementVisible(item.element))
                return false;

            var currentItem = this._parentItem(item);

            if (currentItem == null)
                return true;

            if (this.minimized)
                return true;

            if (currentItem != null) {
                if (!this._isElementVisible(currentItem.element)) {
                    return false;
                }

                if (currentItem.isOpen || this.minimized) {
                    while (currentItem != null) {
                        currentItem = this._parentItem(currentItem);
                        if (currentItem != null && !this._isElementVisible(currentItem.element)) {
                            return false;
                        }

                        if (currentItem != null && !currentItem.isOpen)
                            return false;
                    }
                }
                else {
                    return false;
                }
            }

            return true;
        },

        _render: function (mode, oldMode) {
            if (this.disabled) {
                this.host.addClass(this.toThemeProperty('jqx-fill-state-disabled'));
                this.host.addClass(this.toThemeProperty('jqx-menu-disabled'));
            }
            if (this.host.attr('tabindex') == undefined) {
                this.host.attr('tabindex', 0);
            }
            var zIndex = this.popupZIndex;
            var popupElementoffset = [5, 5];
            var me = this;
            $.data(me.element, 'animationHideDelay', me.animationHideDelay);
            var isTouchDevice = this.isTouchDevice();

            var WP = isTouchDevice && ($.jqx.mobile.isWindowsPhone() || navigator.userAgent.indexOf('Touch') >= 0);
            var WPTablet = false;
            if (navigator.platform.toLowerCase().indexOf('win') != -1) {
                if (navigator.userAgent.indexOf('Windows Phone') >= 0 || navigator.userAgent.indexOf('WPDesktop') >= 0 || navigator.userAgent.indexOf('IEMobile') >= 0 || navigator.userAgent.indexOf('ZuneWP7') >= 0) {
                    this.touchDevice = true;
                }
                else {
                    if (navigator.userAgent.indexOf('Touch') >= 0) {
                        var supported = ('MSPointerDown' in window);
                        if (supported || $.jqx.mobile.isWindowsPhone() || navigator.userAgent.indexOf('ARM') >= 0) {
                            WPTablet = true;
                            WP = true;
                            me.clickToOpen = true;
                            me.autoCloseOnClick = false;
                            me.enableHover = false;
                        }
                    }
                }
            }
            $.data(document.body, 'menuel', this);

            this.hasTransform = $.jqx.utilities.hasTransform(this.host);

            this._applyOrientation(mode, oldMode);
            this.removeHandler(this.host, 'blur');
            this.removeHandler(this.host, 'focus');
            this.addHandler(this.host, 'blur', function (event) {
                if (me.keyboardNavigation) {
                    if (me.activeItem) {
                        if (me.mode === "popup") {
                            if (document.activeElement && document.activeElement.className.indexOf('jqx-menu-wrapper') >= 0) {
                                return;
                            }
                        }
                        $(me.activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                        me.activeItem = null;
                    }
                }
            });
            this.addHandler(this.host, 'focus', function (event) {
                if (me.keyboardNavigation) {
                    if (!me.activeItem) {
                        if (me.hoveredItem) {
                            $(me.hoveredItem.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                            me.activeItem = me.hoveredItem;
                        }
                        else {
                            var setActiveItem = function () {
                                if (!$.jqx.isHidden($(me.items[0].element))) {
                                    $(me.items[0].element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = me.items[0];
                                }
                                else {
                                    var item = me._nextVisibleItem(me.items[0], 0);
                                    if (item) {
                                        $(item.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                        me.activeItem = item;
                                    }
                                }
                            }

                            if (!me.activeItem) {
                                setActiveItem();
                            }
                            else {
                                if (!$.jqx.isHidden($(me.activeItem.element))) {
                                    $(me.activeItem.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                }
                                else {
                                    $(me.activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    setActiveItem();
                                }
                            }
                        }
                    }
                }
            });
            this.removeHandler(this.host, 'keydown.menu' + this.element.id);
            me.handleKeyDown = function (event) {
                if (me.keyboardNavigation) {
                    if (event.target.nodeName.toLowerCase() === "input") {
                        return true;
                    }

                    var activeItem = null;
                    var selectedItem = null;

                    $.each(me.items, function () {
                        var item = this;
                        if (this.disabled)
                            return true;

                        if (this.element.className.indexOf('pressed') >= 0) {
                            selectedItem = this;
                        }

                        if (this.element.className.indexOf('focus') >= 0) {
                            activeItem = this;
                            return false;
                        }
                    });


                    if (!activeItem && selectedItem) {
                        activeItem = selectedItem;
                        return false;
                    }
                    if (!activeItem) {
                        $(me.items[0].element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                        me.activeItem = me.items[0];
                        activeItem = me.activeItem;
                        return false;
                    }

                    var handled = false;
                    if (event.keyCode == 27) {
                        event.data = me;
                        me._closeAll(event);
                        if (activeItem) {
                            var item = activeItem;
                            while (item != null) {
                                if (item.parentItem) {
                                    item = item.parentItem;
                                }
                                else {
                                    $(me.activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = item;
                                    $(me.activeItem.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    item = item.parentItem;
                                }
                            }
                        }
                        handled = true;
                    }

                    if (event.keyCode == 13) {
                        if (activeItem) {
                            handled = true;
                            me._raiseEvent('2', { item: activeItem.element, event: event, type: "keyboard" });

                            var anchor = activeItem.anchor != null ? $(activeItem.anchor) : null;

                            if (anchor != null && anchor.length > 0) {
                                var href = anchor.attr('href');
                                var target = anchor.attr('target');
                                if (href != null) {
                                    if (target != null) {
                                        window.open(href, target);
                                    }
                                    else {
                                        window.location = href;
                                    }
                                }

                            }
                            event.preventDefault();
                            event.stopPropagation();
                            $(activeItem.element).focus();
                        }
                    }

                    var getSiblings = function (activeItem) {
                        if (activeItem == null)
                            return new Array();

                        var siblings = new Array();
                        var index = 0;
                        for (var i = 0; i < me.items.length; i++) {
                            if (me.items[i].parentId == activeItem.parentId) {
                                siblings[index++] = me.items[i];
                            }
                        }
                        return siblings;
                    }

                    var arrowKey = "";
                    switch (event.keyCode) {
                        case 40:
                            arrowKey = "down";
                            break;
                        case 38:
                            arrowKey = "up";
                            break;
                        case 39:
                            arrowKey = "right";
                            break;
                        case 37:
                            arrowKey = "left";
                            break;
                    }

                    if (activeItem && activeItem.openHorizontalDirection === "left" && arrowKey === "left") {
                        arrowKey = "right";
                    }
                    if (activeItem && activeItem.openHorizontalDirection === "left" && arrowKey === "right") {
                        arrowKey = "left";
                    }
                    if (activeItem && activeItem.openVerticalDirection === "top" && arrowKey === "top") {
                        arrowKey = "bottom";
                    }
                    if (activeItem && activeItem.openVerticalDirection === "top" && arrowKey === "bottom") {
                        arrowKey = "top";
                    }

                    if (me.rtl) {
                        if (arrowKey === "right")
                            arrowKey = "left";
                        else if (arrowKey === "left")
                            arrowKey = "right";
                    }


                    if (arrowKey === "right" && !me.minimized) {
                        if (event.altKey && (activeItem.level != 0 && activeItem.hasItems || me.mode != "horizontal")) {
                            me._openItem(me, activeItem);
                        }
                        else {
                            var itemToFocus = me._nextVisibleItem(activeItem, 0);
                            var subItem = me._nextVisibleItem(activeItem);
                            var siblings = getSiblings(subItem);

                            if (!itemToFocus) {
                                itemToFocus = subItem;
                            }

                            if (itemToFocus && ((itemToFocus.parentId === activeItem.parentId && itemToFocus.level == 0 && me.mode == "horizontal") || (subItem.id == siblings[0].id && subItem.level != 0))) {
                                if (subItem.id == siblings[0].id && ((activeItem.level != 0) || (activeItem.level == 0 && me.mode != "horizontal"))) {
                                    itemToFocus = subItem;
                                }

                                $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = itemToFocus;
                            }
                        }

                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (arrowKey === "left" && !me.minimized) {
                        if (event.altKey && ((activeItem.level != 0 && me.mode !== "horizontal") || (activeItem.level > 1 && me.mode === "horizontal") || (activeItem.level == 1 && activeItem.hasItems && me.mode === "horizontal"))) {
                            if (activeItem.hasItems) {
                                me._closeItem(me, activeItem);
                            }
                            else {
                                if (activeItem.parentItem) {
                                    me._closeItem(me, activeItem.parentItem);
                                    $(activeItem.parentItem.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = activeItem.parentItem;
                                }
                            }
                        }
                        else {
                            var itemToFocus = me._prevVisibleItem(activeItem, 0);
                            var currentItemToFocus = activeItem.parentItem;

                            if (itemToFocus && (itemToFocus.parentId === activeItem.parentId && itemToFocus.level == 0 && me.mode == "horizontal")) {
                                $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = itemToFocus;
                            }
                            else if (!(currentItemToFocus && currentItemToFocus.level == 0 && me.mode == "horizontal") && currentItemToFocus && currentItemToFocus.level == activeItem.level - 1) {
                                $(currentItemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = currentItemToFocus;
                            }

                        }
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (arrowKey === "down") {
                        if (event.altKey) {
                            if (activeItem.level == 0 && activeItem.hasItems) {
                                me._openItem(me, activeItem);
                            }
                            if (me.minimized) {
                                if (me.minimizedHidden) {
                                    me.minimizedItem.trigger('click');
                                }
                            }
                        }
                        else {
                            var itemToFocus = me._nextVisibleItem(activeItem, activeItem.level);
                            var siblings = getSiblings(itemToFocus);
                            if (me.minimized && itemToFocus) {
                                $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = itemToFocus;
                            }
                            else {
                                if (itemToFocus && (itemToFocus.parentId === activeItem.parentId || (itemToFocus.id == siblings[0].id && me.mode == "horizontal"))) {
                                    if (!(itemToFocus.level == 0 && me.mode == "horizontal")) {
                                        $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                        $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                        me.activeItem = itemToFocus;
                                    }
                                }
                                if (me.mode === "horizontal" && activeItem.level === 0 && activeItem.isOpen && activeItem.hasItems) {
                                    var itemToFocus = me._nextVisibleItem(activeItem);
                                    $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = itemToFocus;
                                }
                            }
                        }

                        event.preventDefault();
                        event.stopPropagation();
                    }
                    else if (arrowKey === "up") {
                        if (event.altKey) {
                            if (activeItem.parentItem && activeItem.parentItem.level == 0) {
                                me._closeItem(me, activeItem.parentItem);
                                $(activeItem.parentItem.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = activeItem.parentItem;
                            }
                            else if (activeItem.parentItem === null && activeItem.level === 0 && me.mode === "horizontal") {
                                me._closeItem(me, activeItem);
                            }
                            if (me.minimized) {
                                if (!me.minimizedHidden) {
                                    me.minimizedItem.trigger('click');
                                }
                            }
                        }
                        else {
                            var itemToFocus = me._prevVisibleItem(activeItem, activeItem.level);
                            var siblings = getSiblings(activeItem);

                            if (me.minimized && itemToFocus) {
                                $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                me.activeItem = itemToFocus;
                            }
                            else {
                                if (itemToFocus && (itemToFocus.parentId === activeItem.parentId || (itemToFocus.id == activeItem.parentId && itemToFocus.level == 0 && me.mode == "horizontal"))) {
                                    if (!(itemToFocus.level == 0 && me.mode === "horizontal" && activeItem.level === 0)) {
                                        $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                        $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                        me.activeItem = itemToFocus;
                                    }
                                }
                                else if (activeItem && activeItem.id == siblings[0].id && activeItem.parentItem && activeItem.parentItem.level === 0 && me.mode === "horizontal") {
                                    var itemToFocus = activeItem.parentItem;
                                    $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = itemToFocus;
                                }
                            }
                        }
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (event.keyCode == 9) {
                        var itemToFocus = event.shiftKey ? me._prevVisibleItem(activeItem) : me._nextVisibleItem(activeItem);

                        if (itemToFocus) {
                            $(itemToFocus.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                            $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                            me.activeItem = itemToFocus;
                            event.preventDefault();
                            event.stopPropagation();
                        }
                        else if (me.lockFocus) {
                            var siblings = new Array();
                            var index = 0;
                            for (var i = 0; i < me.items.length; i++) {
                                if (me.items[i] == activeItem)
                                    continue;

                                if (me.items[i].parentId == activeItem.parentId) {
                                    siblings[index++] = me.items[i];
                                }
                            }

                            if (siblings.length > 0) {
                                if (event.shiftKey) {
                                    $(siblings[siblings.length - 1].element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = siblings[siblings.length - 1];
                                }
                                else {
                                    $(siblings[0].element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                                    me.activeItem = siblings[0];
                                }
                                $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                            }
                            event.preventDefault();
                            event.stopPropagation();
                        }
                        else if (activeItem) {
                            $(activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                            me.activeItem = null;
                        }
                    }
                }
                else {
                    return true;
                }
            }
            this.addHandler(this.host, 'keydown.menu' + this.element.id, function (event) {
                me.handleKeyDown(event);
            });

            if (me.enableRoundedCorners) {
                this.host.addClass(me.toThemeProperty('jqx-rc-all'));
            }

            $.each(this.items, function () {
                var item = this;
                var $menuElement = $(item.element);
                $menuElement.attr('role', 'menuitem');
                if (me.enableRoundedCorners) {
                    $menuElement.addClass(me.toThemeProperty('jqx-rc-all'));
                }

                me.removeHandler($menuElement, 'click');
                me.addHandler($menuElement, 'click', function (e) {
                    if (item.disabled)
                        return;

                    if (me.disabled)
                        return;

                    if (me.keyboardNavigation) {
                        if (me.activeItem) {
                            $(me.activeItem.element).removeClass(me.toThemeProperty('jqx-fill-state-focus'));
                        }
                        me.activeItem = item;
                        $(item.element).addClass(me.toThemeProperty('jqx-fill-state-focus'));
                        if (me.minimized) {
                            e.stopPropagation();
                        }
                    }

                    me._raiseEvent('2', { type: "mouse", item: item.element, event: e });

                    if (!me.autoOpen) {
                        if (item.level > 0) {
                            if (me.autoCloseOnClick && !isTouchDevice && !me.clickToOpen) {
                                e.data = me;
                                me._closeAll(e);
                            }
                        }
                    }
                    else if (me.autoCloseOnClick && !isTouchDevice && !me.clickToOpen) {
                        if (item.closeOnClick) {
                            e.data = me;
                            me._closeAll(e);
                        }
                    }
                    if (isTouchDevice && me.autoCloseOnClick) {
                        e.data = me;
                        if (!item.hasItems) {
                            me._closeAll(e);
                        }
                    }

                    if (e.target.tagName != 'A' && e.target.tagName != 'a') {
                        var anchor = item.anchor != null ? $(item.anchor) : null;

                        if (anchor != null && anchor.length > 0) {
                            var href = anchor.attr('href');
                            var target = anchor.attr('target');
                            if (href != null) {
                                if (target != null) {
                                    window.open(href, target);
                                }
                                else {
                                    window.location = href;
                                }
                            }
                        }
                    }
                });

                me.removeHandler($menuElement, 'mouseenter');
                me.removeHandler($menuElement, 'mouseleave');

                if (!WP && me.mode != 'simple') {
                    me._renderHover($menuElement, item, isTouchDevice);
                }
                if (item.subMenuElement != null) {
                    var $submenu = $(item.subMenuElement);
                    if (me.mode == 'simple') {
                        $submenu.show();
                        return true;
                    }
                    $submenu.wrap('<div class="jqx-menu-popup ' + me.toThemeProperty('jqx-menu-popup') + '" style="border: none; background-color: transparent; z-index:' + zIndex + '; padding: 0px; margin: 0px; position: absolute; top: 0; left: 0; display: block; visibility: hidden;"><div style="background-color: transparent; border: none; position:absolute; overflow:hidden; left: 0; top: 0; right: 0; width: 100%; height: 100%;"></div></div>')
                    $submenu.css({ overflow: 'hidden', position: 'absolute', left: 0, display: 'inherit', top: -$submenu.outerHeight() })
                    $submenu.data('timer', {});
                    if (item.level > 0) {
                        $submenu.css('left', -$submenu.outerWidth());
                    }
                    else if (me.mode == 'horizontal') {
                        $submenu.css('left', 0);
                    }

                    zIndex++;
                    var $popupElement = $(item.subMenuElement).closest('div.jqx-menu-popup').css({ width: parseInt($(item.subMenuElement).outerWidth()) + parseInt(popupElementoffset[0]) + 'px', height: parseInt($(item.subMenuElement).outerHeight()) + parseInt(popupElementoffset[1]) + 'px' })
                    var $popupElementparent = $menuElement.closest('div.jqx-menu-popup')

                    if ($popupElementparent.length > 0) {
                        var oldsubleftmargin = $submenu.css('margin-left');
                        var oldsubrightmargin = $submenu.css('margin-right');
                        var oldsubleftpadding = $submenu.css('padding-left');
                        var oldsubrightpadding = $submenu.css('padding-right');

                        $popupElement.addClass('horizontal');
                        $popupElement.appendTo($popupElementparent)

                        $submenu.css('margin-left', oldsubleftmargin);
                        $submenu.css('margin-right', oldsubrightmargin);
                        $submenu.css('padding-left', oldsubleftpadding);
                        $submenu.css('padding-right', oldsubrightpadding);
                    }
                    else {
                        var oldsubleftmargin = $submenu.css('margin-left');
                        var oldsubrightmargin = $submenu.css('margin-right');
                        var oldsubleftpadding = $submenu.css('padding-left');
                        var oldsubrightpadding = $submenu.css('padding-right');

                        if (me.mode === 'horizontal') {
                            $popupElement.addClass('top');
                        }
                        else {
                            $popupElement.addClass('horizontal');
                        }
                        $popupElement.appendTo($(document.body));
                        $submenu.css('margin-left', oldsubleftmargin);
                        $submenu.css('margin-right', oldsubrightmargin);
                        $submenu.css('padding-left', oldsubleftpadding);
                        $submenu.css('padding-right', oldsubrightpadding);
                    }

                    if (!me.clickToOpen) {
                        if (isTouchDevice || WP) {
                            me.removeHandler($menuElement, $.jqx.mobile.getTouchEventName('touchstart'));
                            me.addHandler($menuElement, $.jqx.mobile.getTouchEventName('touchstart'), function (event) {
                                clearTimeout($submenu.data('timer').hide)
                                if ($submenu != null) {
                                    $submenu.stop();
                                }

                                if (item.level == 0 && !item.isOpen && me.mode != "popup") {
                                    event.data = me;
                                    me._closeAll(event);
                                }

                                if (!item.isOpen) {
                                    me._openItem(me, item);
                                }
                                else {
                                    me._closeItem(me, item, true);
                                }
                                return false;
                            });
                        }

                        if (!WP) {
                            me.addHandler($menuElement, 'mouseenter', function () {
                                if (me.autoOpen || (item.level > 0 && !me.autoOpen)) {
                                    clearTimeout($submenu.data('timer').hide)
                                }

                                if (item.parentId && item.parentId != 0) {
                                    if (me.menuElements[item.parentId]) {
                                        var openedStateOfParent = me.menuElements[item.parentId].isOpen;
                                        if (!openedStateOfParent) {
                                            return;
                                        }
                                    }
                                }

                                if (me.autoOpen || (item.level > 0 && !me.autoOpen)) {
                                    me._openItem(me, item);
                                }
                                return false;
                            });

                            me.addHandler($menuElement, 'mousedown', function () {
                                if (!me.autoOpen && item.level == 0) {
                                    clearTimeout($submenu.data('timer').hide)
                                    if ($submenu != null) {
                                        $submenu.stop();
                                    }

                                    if (!item.isOpen) {
                                        me._openItem(me, item);
                                    }
                                    else {
                                        me._closeItem(me, item, true);
                                    }
                                }
                            });

                            me.addHandler($menuElement, 'mouseleave', function (event) {
                                if (me.autoCloseOnMouseLeave) {
                                    clearTimeout($submenu.data('timer').hide)
                                    var $subMenu = $(item.subMenuElement);
                                    var position = { left: parseInt(event.pageX), top: parseInt(event.pageY) };
                                    var subMenuBounds = {
                                        left: parseInt($subMenu.coord().left), top: parseInt($subMenu.coord().top),
                                        width: parseInt($subMenu.outerWidth()), height: parseInt($subMenu.outerHeight())
                                    };

                                    var closeItem = true;
                                    if (subMenuBounds.left - 5 <= position.left && position.left <= subMenuBounds.left + subMenuBounds.width + 5) {
                                        if (subMenuBounds.top <= position.top && position.top <= subMenuBounds.top + subMenuBounds.height) {
                                            closeItem = false;
                                        }
                                    }

                                    if (closeItem) {
                                        me._closeItem(me, item, true);
                                    }
                                }
                            });

                            me.removeHandler($popupElement, 'mouseenter');
                            me.addHandler($popupElement, 'mouseenter', function () {
                                clearTimeout($submenu.data('timer').hide)
                            });

                            me.removeHandler($popupElement, 'mouseleave');
                            me.addHandler($popupElement, 'mouseleave', function (e) {
                                if (me.autoCloseOnMouseLeave) {
                                    clearTimeout($submenu.data('timer').hide)
                                    clearTimeout($submenu.data('timer').show);
                                    if ($submenu != null) {
                                        $submenu.stop();
                                    }
                                    me._closeItem(me, item, true);
                                }
                            });
                        }
                    }
                    else {
                        me.removeHandler($menuElement, 'mousedown');
                        me.addHandler($menuElement, 'mousedown', function (event) {

                            clearTimeout($submenu.data('timer').hide)
                            if ($submenu != null) {
                                $submenu.stop();
                            }

                            if (item.level == 0 && !item.isOpen) {
                                event.data = me;
                                me._closeAll(event);
                            }

                            if (!item.isOpen) {
                                me._openItem(me, item);
                            }
                            else {
                                me._closeItem(me, item, true);
                            }
                        });
                    }
                }
            });

            if (this.mode == "simple") {
                this._renderSimpleMode()
            }

            this._autoSizeHorizontalMenuItems();
            this._raiseEvent('3', this);
        },

        _renderSimpleMode: function () {
            this.host.show();
        },

        createID: function () {
            var id = Math.random() + '';
            id = id.replace('.', '');
            id = '99' + id;
            id = id / 1;
            while (this.items[id]) {
                id = Math.random() + '';
                id = id.replace('.', '');
                id = id / 1;
            }
            return 'menuItem' + id;
        },

        _createMenu: function (uiObject, refresh) {
            if (uiObject == null)
                return;

            if (refresh == undefined) {
                refresh = true;
            }
            if (refresh == null) {
                refresh = true;
            }

            var self = this;

            $(uiObject).addClass('jqx-menu-ul');

            var liTags = $(uiObject).find('li');
            var k = 0;
            this.itemMapping = new Array();

            for (var index = 0; index < liTags.length; index++) {
                var listItem = liTags[index];
                var $listItem = $(listItem);

                if (listItem.className.indexOf('jqx-menu') == -1 && this.autoGenerate == false)
                    continue;

                var id = listItem.id;
                if (!id) {
                    id = this.createID();
                }

                if (refresh) {
                    listItem.id = id;
                    this.items[k] = new $.jqx._jqxMenu.jqxMenuItem();
                    this.menuElements[id] = this.items[k];
                }

                k += 1;
                var parentId = 0;
                var me = this;
                var children = $listItem.children();
                children.each(function () {
                    if (!refresh) {
                        this.className = "";

                        if (me.autoGenerate) {
                            $(me.items[k - 1].subMenuElement)[0].className = "";
                            if (!me.minimized) {
                                $(me.items[k - 1].subMenuElement).addClass(me.toThemeProperty('jqx-widget-content'));
                            }
                            $(me.items[k - 1].subMenuElement).addClass(me.toThemeProperty('jqx-menu-dropdown'));
                            $(me.items[k - 1].subMenuElement).addClass(me.toThemeProperty('jqx-popup'));
                        }
                    }

                    if (this.className.indexOf('jqx-menu-dropdown') != -1) {
                        if (refresh) {
                            me.items[k - 1].subMenuElement = this;
                        }
                        return false;
                    }
                    else if (me.autoGenerate && (this.tagName == 'ul' || this.tagName == 'UL')) {
                        if (refresh) {
                            me.items[k - 1].subMenuElement = this;
                        }
                        this.className = "";
                        if (!me.minimized) {
                            $(this).addClass(me.toThemeProperty('jqx-widget-content'));
                        }
                        $(this).addClass(me.toThemeProperty('jqx-menu-dropdown'));
                        $(this).addClass(me.toThemeProperty('jqx-popup'));
                        $(this).attr('role', 'menu');
                        if (me.rtl) {
                            $(this).addClass(me.toThemeProperty('jqx-rc-l'));
                        }
                        else {
                            $(this).addClass(me.toThemeProperty('jqx-rc-r'));
                        }
                        $(this).addClass(me.toThemeProperty('jqx-rc-b'));

                        return false;
                    }
                });

                var parents = $listItem.parents();
                parents.each(function () {
                    if (this.className.indexOf('jqx-menu-item') != -1) {
                        parentId = this.id;
                        return false;
                    }
                    else if (me.autoGenerate && (this.tagName == 'li' || this.tagName == 'LI')) {
                        parentId = this.id;
                        return false;
                    }

                });

                var separator = false;
                var type = listItem.getAttribute('type');
                var ignoretheme = listItem.getAttribute('ignoretheme') || listItem.getAttribute('data-ignoretheme');

                if (ignoretheme) {
                    if (ignoretheme == 'true' || ignoretheme == true) {
                        ignoretheme = true;
                    }
                }
                else ignoretheme = false;

                if (!type) {
                    type = listItem.type;
                }
                else {
                    if (type == 'separator') {
                        var separator = true;
                    }
                }

                if (!separator) {
                    if (parentId) {
                        type = 'sub';
                    }
                    else type = 'top';
                }

                var menuItem = this.items[k - 1];
                if (refresh) {
                    menuItem.id = id;
                    menuItem.parentId = parentId;
                    menuItem.type = type;
                    menuItem.separator = separator;
                    menuItem.element = liTags[index];
                    var anchor = $listItem.children('a');
                    menuItem.disabled = listItem.getAttribute('item-disabled') == "true" ? true : false;

                    menuItem.level = $listItem.parents('li').length;
                    menuItem.anchor = anchor.length > 0 ? anchor : null;
                    if (menuItem.anchor) {
                        $(menuItem.anchor).attr('tabindex', -1);
                    }
                }
                menuItem.ignoretheme = ignoretheme;

                var parentItem = this.menuElements[parentId];
                if (parentItem != null) {
                    if (parentItem.ignoretheme) {
                        menuItem.ignoretheme = parentItem.ignoretheme;
                        ignoretheme = parentItem.ignoretheme;
                    }
                    menuItem.parentItem = parentItem;
                    menuItem.parentElement = parentItem.element;
                }

                if (this.autoGenerate) {
                    if (type == 'separator') {
                        $listItem.removeClass();
                        $listItem.addClass(this.toThemeProperty('jqx-menu-item-separator'));
                        $listItem.attr('role', 'separator');
                    }
                    else {
                        if (!ignoretheme) {
                            if ($listItem[0].className.indexOf("jqx-grid-menu-item-touch") >= 0) {
                                $listItem[0].className = this.toThemeProperty('jqx-grid-menu-item-touch');
                            }
                            else {
                                $listItem[0].className = "";
                            }

                            if (this.rtl) {
                                $listItem.addClass(this.toThemeProperty('jqx-rtl'));
                            }
                            if (menuItem.level > 0 && !me.minimized) {
                                $listItem.addClass(this.toThemeProperty('jqx-item'));
                                $listItem.addClass(this.toThemeProperty('jqx-menu-item'));
                            }
                            else {
                                $listItem.addClass(this.toThemeProperty('jqx-item'));
                                $listItem.addClass(this.toThemeProperty('jqx-menu-item-top'));
                            }
                        }
                    }
                }
                if (menuItem.disabled) {
                    $listItem.addClass(me.toThemeProperty('jqx-menu-item-disabled'));
                    $listItem.addClass(me.toThemeProperty('jqx-fill-state-disabled'));
                }

                this.itemMapping[index] = { element: liTags[index], item: menuItem };
                this.itemMapping["id" + liTags[index].id] = this.itemMapping[index];

                if (refresh && !ignoretheme) {
                    menuItem.hasItems = $listItem.find('li').length > 0;
                    if (menuItem.hasItems) {
                        if (menuItem.element) {
                            $.jqx.aria($(menuItem.element), "aria-haspopup", true);
                            if (!menuItem.subMenuElement.id) menuItem.subMenuElement.id = $.jqx.utilities.createId();
                            $.jqx.aria($(menuItem.element), "aria-owns", menuItem.subMenuElement.id);
                        }
                    }
                }
            }

            for (var i = 0; i < liTags.length; i++) {
                var listTag = liTags[i];
                if (this.itemMapping["id" + listTag.id]) {
                    var menuItem = this.itemMapping["id" + listTag.id].item;
                    if (!menuItem)
                        continue;

                    menuItem.prevItem = null;
                    menuItem.nextItem = null;
                    if (i > 0) {
                        if (this.itemMapping["id" + liTags[i - 1].id]) {
                            menuItem.prevItem = this.itemMapping["id" + liTags[i - 1].id].item;
                        }
                    }

                    if (i < liTags.length - 1) {
                        if (this.itemMapping["id" + liTags[i + 1].id]) {
                            menuItem.nextItem = this.itemMapping["id" + liTags[i + 1].id].item;
                        }
                    }
                }
            }
        },

        destroy: function () {
            var me = this;
            $.jqx.utilities.resize(me.host, null, true);
            var wrapper = me.host.closest('div.jqx-menu-wrapper');
            me.removeHandler(wrapper, 'keydown');
            wrapper.remove();
            me.removeHandler($("#menuWrapper" + me.element.id), 'keydown');
            $("#menuWrapper" + me.element.id).remove();
            me.removeHandler(me.host, 'keydown');
            me.removeHandler(me.host, 'focus');
            me.removeHandler(me.host, 'blur');
            me.removeHandler($(document), 'mousedown.menu' + me.element.id, me._closeAfterClick);
            me.removeHandler($(document), 'mouseup.menu' + me.element.id, me._closeAfterClick);
            me.removeHandler($(document), 'contextmenu.' + me.element.id);
            me.removeHandler(me.host, 'contextmenu.' + me.element.id);

            $.data(document.body, 'jqxMenuOldHost' + me.element.id, null);
            if (me.isTouchDevice()) {
                me.removeHandler($(document), $.jqx.mobile.getTouchEventName('touchstart') + '.menu' + me.element.id, me._closeAfterClick, this);
            }

            if ($(window).off) {
                $(window).off('resize.menu' + me.element.id);
            }
            $.each(me.items, function () {
                var item = this;
                var $menuElement = $(item.element);
                me.removeHandler($menuElement, 'click');
                me.removeHandler($menuElement, 'selectstart');
                me.removeHandler($menuElement, 'mouseenter');
                me.removeHandler($menuElement, 'mouseleave');
                me.removeHandler($menuElement, 'mousedown');
                me.removeHandler($menuElement, 'mouseleave');
                var $submenu = $(item.subMenuElement);
                var $popupElement = $submenu.closest('div.jqx-menu-popup');
                $popupElement.remove();
                delete this.subMenuElement;
                delete this.element;
            });
            $.data(document.body, 'menuel', null);
            delete me.menuElements;
            me.items = new Array();
            delete me.items;
            var vars = $.data(me.element, "jqxMenu");
            if (vars) {
                delete vars.instance;
            }

            me.host.removeClass();
            me.host.remove();
            delete me.host;
            delete me.element;
        },

        _raiseEvent: function (id, arg) {
            if (arg == undefined)
                arg = { owner: null };

            var evt = this.events[id];
            var args = arg;
            args.owner = this;

            var event = new $.Event(evt);
            if (id == '2') {
                args = arg.item;
                args.owner = this;
                args.clickType = arg.type;
                $.extend(event, arg.event);
                event.type = 'itemclick';
            }

            event.owner = this;
            event.args = args;
            var result = this.host.trigger(event);
            return result;
        },

        propertiesChangedHandler: function (object, key, value) {
            if (value.width && value.height && Object.keys(value).length == 2) {
                object._setSize();
                if (object.mode === "popup") {
                    var $popupElementparent = this.host.closest('div.jqx-menu-wrapper');
                    $popupElementparent[key](value);
                    var id = this.host[0].id;
                    $("#" + id)[key](value);
                }
            }
        },

        propertyChangedHandler: function (object, key, oldvalue, value) {
            if (this.isInitialized == undefined || this.isInitialized == false)
                return;

            if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                return;
            }

            if (key == "disabled") {
                if (object.disabled) {
                    object.host.addClass(object.toThemeProperty('jqx-fill-state-disabled'));
                    object.host.addClass(object.toThemeProperty('jqx-menu-disabled'));
                }
                else {
                    object.host.removeClass(object.toThemeProperty('jqx-fill-state-disabled'));
                    object.host.removeClass(object.toThemeProperty('jqx-menu-disabled'));
                }
            }

            if (value == oldvalue)
                return;

            if (key == 'touchMode') {
                this._isTouchDevice = null;
                object._render(value, oldvalue);
            }

            if (key === "width" || key === "height") {
                object._setSize();
                if (object.mode === "popup") {
                    var $popupElementparent = this.host.closest('div.jqx-menu-wrapper');
                    $popupElementparent[key](value);
                    var id = this.host[0].id;
                    $("#" + id)[key](value);
                }
                return;
            }
            if (key == 'source') {
                if (object.source != null) {
                    var html = object.loadItems(object.source);
                    object.element.innerHTML = html;
                    var innerElement = object.host.find('ul:first');
                    if (innerElement.length > 0) {
                        object.refresh();
                        object._createMenu(innerElement[0]);
                        object._render();
                    }
                }
            }

            if (key == 'autoCloseOnClick') {
                if (value == false) {
                    object.removeHandler($(document), 'mousedown.menu' + this.element.id, object._closeAll);
                }
                else {
                    object.addHandler($(document), 'mousedown.menu' + this.element.id, object, object._closeAll);
                }
            }
            else if (key == 'mode' || key == 'width' || key == 'height' || key == 'showTopLevelArrows') {
                object.refresh();

                if (key == 'mode') {
                    object._render(value, oldvalue);
                }
                else object._applyOrientation();
            }
            else if (key == 'theme') {
                $.jqx.utilities.setTheme(oldvalue, value, object.host);
            }
        }
    });
})(jqxBaseFramework);

(function ($) {
    $.jqx._jqxMenu.jqxMenuItem = function (id, parentId, type) {
        var menuItem =
        {
            // gets the id.
            id: id,
            // gets the parent id.
            parentId: parentId,
            // gets the parent item instance.
            parentItem: null,
            // gets the anchor element.
            anchor: null,
            // gets the type
            type: type,
            // gets whether the item is disabled.
            disabled: false,
            // gets the item's level.
            level: 0,
            // gets a value whether the item is opened.
            isOpen: false,
            // has sub elements.
            hasItems: false,
            // li element
            element: null,
            subMenuElement: null,
            // arrow element.
            arrow: null,
            // left, right, center
            openHorizontalDirection: 'right',
            // up, down, center
            openVerticalDirection: 'down',
            closeOnClick: true
        }
        return menuItem;
    }; //
})(jqxBaseFramework);
})();



/***/ }),

/***/ 7995:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {

    $.jqx.jqxWidget("jqxNumberInput", "", {});

    $.extend($.jqx._jqxNumberInput.prototype, {

        defineInstance: function () {
            var settings = {
                // Type: Number
                // Default: null
                // Gets or sets the input's value.
                value: 0,
                // Type: Number
                // Default: 0
                // Gets or sets the input's number.
                decimal: 0,
                // Type: Number
                // Default= 0
                // Gets or sets the input's minimum value.
                min: -99999999,
                // Type: Number
                // Default: 0
                // Gets or sets the input's maximum value.
                max: 99999999,
                //Type: Number.
                //Default: 0.
                //Sets width of the input in pixels. Only positive values have effect.
                width: 200,
                //Type: String,
                //Default: Invalid value.
                validationMessage: "Invalid value",
                //Type: Number.
                //Default: 0.
                //Sets height of the input in pixels.
                height: 25,
                // Sets the alignment.
                textAlign: "right",
                // Type: Bool
                // Default: false
                // Sets the readOnly state of the input.
                readOnly: false,
                // Type: Char
                // Default: "_"
                // Sets the prompt char displayed when an editable char is empty.
                // Possible Values: "_", "?", "#".
                promptChar: "_",
                // Type: Number
                // Default: 2
                // Indicates the number of decimal places to use in numeric values.
                decimalDigits: 2,
                // Type= Char
                // Default: '.'
                // Gets or sets the char to use as the decimal separator in numeric values.
                decimalSeparator: ".",
                // Type= Char
                // Default: ","
                // Gets or sets the string that separates groups of digits to the left of the
                // decimal in numeric values.
                groupSeparator: ",",
                // Type: Number
                // Default: '3'
                // Gets or sets the number of digits in each group to the left of the decimal in numeric values.
                groupSize: 3,
                // Type: String
                // Default: empty
                // Gets or sets the string to use as currency or percentage symbol.
                symbol: '',
                // Type: Bool
                // Default: "left"
                // Gets or sets the position of the symbol in the input.
                symbolPosition: "left",
                // Type: Number
                // Default: 8
                // Gets or sets the digits in the input
                digits: 8,
                // Type: Bool
                // Default: false
                // Gets or sets whether the decimal is negative.
                negative: false,
                // Type: Bool
                // Default: false
                // Gets or sets the string to use as negative symbol.
                negativeSymbol: '-',
                // Type: Bool
                // Default: false
                // Gets or sets whether the widget is disabled.
                disabled: false,
                // Type: String
                // Default: advanced
                // Gets or sets the input mode. When the mode is simple, the text is formatted after editing. When the mode is advanced, the text is formatted while the user is in edit mode.
                // Available values: [simple, advanced]
                inputMode: 'advanced',
                // Type: Boolean
                // Default: false
                // shows the spin buttons.
                spinButtons: false,
                // Type: Number
                // Default: 18
                // Sets the spin buttons width
                spinButtonsWidth: 18,
                // Type: Number
                // Default: 1
                // sets the spin button step.
                spinButtonsStep: 1,
                // validates the value to be in the min-max range when the user leaves the input.
                autoValidate: true,
                // none, advanced or simple
                spinMode: 'advanced',
                enableMouseWheel: true,
                touchMode: "auto",
                allowNull: true,
                placeHolder: "",
                changeType: null,
                template: "",
                rtl: false,
                hint: true,
                // NumberInput events.
                events:
                    [
                        'valueChanged',
                        'textchanged',
                        'mousedown',
                        'mouseup',
                        'keydown',
                        'keyup',
                        'keypress',
                        'change'
                    ],
                aria:
                {
                    "aria-valuenow": { name: "decimal", type: "number" },
                    "aria-valuemin": { name: "min", type: "number" },
                    "aria-valuemax": { name: "max", type: "number" },
                    "aria-disabled": { name: "disabled", type: "boolean" }
                },
                invalidArgumentExceptions:
                    [
                        'invalid argument exception'
                    ]
            };
            if (this === $.jqx._jqxNumberInput.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        // creates the number input's instance.
        createInstance: function (args) {
            if (this.promptChar === "") {
                this.promptChar = " ";
            }
            var _val = this.host.attr('value');
            if (_val != undefined) {
                this.decimal = _val;
            }

            if (this.decimal === 0) {
                if (this.value != null) {
                    this.decimal = this.value;
                }
                else if (this.value === null && this.decimal !== 0) {
                    this.value = this.decimal;
                }
            }

            var that = this;
            that._createFromInput("jqxNumberInput");

            this.render();
        },

        _updateHint: function () {
            var that = this;

            if (!that.hint) {
                return;
            }

            if (that.isMaterialized()) {
                setTimeout(function () {
                    if (that.numberInput[0].value.length === 0) {
                        that.element.removeAttribute('hint');
                        if (that.label && that.label[0]) {
                            that.label[0].innerHTML = that.placeHolder;
                        }
                    }
                    else {
                        that.element.setAttribute('hint', true);
                    }
                });
            }
        },

        _createFromInput: function (name) {
            var that = this;
            if (that.element.nodeName.toLowerCase() == "input") {
                that.field = that.element;
                if (that.field.className) {
                    that._className = that.field.className;
                }

                var properties = {
                    'title': that.field.title
                };

                if (that.field.value) {
                    that.decimal = parseFloat(that.field.value);
                }
                if (that.field.getAttribute('min')) {
                    var min = (that.field.getAttribute('min'));
                    that.min = parseFloat(min);
                }
                if (that.field.getAttribute('step')) {
                    var step = (that.field.getAttribute('step'));
                    that.spinButtonsStep = parseFloat(step);
                }
                if (that.field.getAttribute('max')) {
                    var max = (that.field.getAttribute('max'));
                    that.max = parseFloat(max);
                }
                if (that.field.id.length) {
                    properties.id = that.field.id.replace(/[^\w]/g, '_') + "_" + name;
                }
                else {
                    properties.id = $.jqx.utilities.createId() + "_" + name;
                }

                var wrapper = $("<div></div>", properties);
                wrapper[0].style.cssText = that.field.style.cssText;
                if (!that.width) {
                    that.width = $(that.field).width();
                }
                if (!that.height) {
                    that.height = $(that.field).outerHeight();
                }
                $(that.field).hide().after(wrapper);
                var data = that.host.data();
                that.host = wrapper;
                that.host.data(data);
                that.element = wrapper[0];
                that.element.id = that.field.id;
                that.field.id = properties.id;
                if (that._className) {
                    that.host.addClass(that._className);
                    $(that.field).removeClass(that._className);
                }

                if (that.field.tabIndex) {
                    var tabIndex = that.field.tabIndex;
                    that.field.tabIndex = -1;
                    that.element.tabIndex = tabIndex;
                }
            }
        },

        _doTouchHandling: function () {
            var me = this;
            var savedValue = me.savedValue;
            if (!me.parsing) me.parsing = true;
            if (me.parsing) {
                if (me.numberInput.val() && me.numberInput.val().indexOf('-') == 0) {
                    me.setvalue('negative', true);
                }
                else {
                    me.setvalue('negative', false);
                }
                var value = me.numberInput.val();
                for (var i = 0; i < value.length - 1; i++) {
                    var ch = value.substring(i, i + 1);
                    if (isNaN(parseFloat(ch)) && me.symbol.toString().indexOf(ch) === -1 && ch != "%" && ch != "$" && ch != '.' && ch != ',' && ch != '-') {
                        me.numberInput[0].value = savedValue;
                        me.parsing = false;
                        return;
                    }
                }

                me.ValueString = me.GetValueString(me.numberInput.val(), me.decimalSeparator, me.decimalSeparator != '');
                //me.ValueString = new Number(me.ValueString).toFixed(me.decimalDigits);
                me._parseDecimalInSimpleMode();
                me.decimal = me.ValueString;
                var isNegative = me.getvalue('negative');
                if (isNegative) {
                    me.decimal = "-" + me.ValueString;
                }

                me.parsing = false;
            }
        },

        render: function () {
            this.host
                .attr({
                    role: "spinbutton"
                });
            this.host.attr('data-role', 'input');
            $.jqx.aria(this);
            $.jqx.aria(this, "aria-multiline", false);

            var me = this;

            if (this.officeMode || (this.theme && this.theme.indexOf('office') != -1)) {
                if (this.spinButtonsWidth == 18) this.spinButtonsWidth = 15;
            }

            if ($.jqx.mobile.isTouchDevice() || this.touchMode === true) {
                this.inputMode = 'textbox';
                this.spinMode = 'simple';

            }

            if (this.decimalSeparator == '') this.decimalSeparator = ' ';
            this.host.addClass(this.toThemeProperty('jqx-input'));
            this.host.addClass(this.toThemeProperty('jqx-rc-all'));
            this.host.addClass(this.toThemeProperty('jqx-widget'));
            this.host.addClass(this.toThemeProperty('jqx-widget-content'));
            this.host.addClass(this.toThemeProperty('jqx-numberinput'));

            if (this.spinButtons) {
                this._spinButtons();
            }
            else {
                this.numberInput = $("<input style='border:none;' autocomplete='off' type='textarea'/>").appendTo(this.host);
                this.numberInput.addClass(this.toThemeProperty('jqx-input-content'));
                this.numberInput.addClass(this.toThemeProperty('jqx-widget-content'));
            }

            if ($.jqx.mobile.isTouchDevice() || this.touchMode === true) {
                this.numberInput.attr('inputmode', 'decimal');
            }

            if (!this.isMaterialized()) {
                this.numberInput.attr('placeholder', this.placeHolder);
            }

            var name = this.host.attr('name');
            if (name) {
                this.numberInput.attr('name', name);
            }
            if (this.host.attr('tabindex')) {
                this.numberInput.attr('tabindex', this.host.attr('tabindex'));
                this.host.removeAttr('tabindex');
            }

            if ($.jqx.mobile.isTouchDevice() || this.touchMode === true || this.inputMode == 'textbox') {
                var me = this;
                me.savedValue = "";

                //    this.numberInput.attr('type', 'number');
                this.addHandler(this.numberInput, 'focus', function () {
                    me.savedValue = me.numberInput[0].value;
                });

                this.addHandler(this.numberInput, 'change', function () {
                    me._doTouchHandling();
                });
            }

            var vars = $.data(this.host[0], 'jqxNumberInput');
            vars.jqxNumberInput = this;
            var me = this;

            if (this.host.parents('form').length > 0) {
                this.addHandler(this.host.parents('form'), 'reset', function () {
                    setTimeout(function () {
                        me.setDecimal(0);
                    }, 10);
                });
            }

            this.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                if (value) {
                    instance.numberInput.addClass(self.toThemeProperty('jqx-input-disabled'));
                    instance.numberInput.attr("disabled", true);
                }
                else {
                    instance.host.removeClass(self.toThemeProperty('jqx-input-disabled'));
                    instance.numberInput.attr("disabled", false);
                }

                if (instance.spinButtons && instance.host.jqxRepeatButton) {
                    instance.upbutton.jqxRepeatButton({ disabled: value });
                    instance.downbutton.jqxRepeatButton({ disabled: value });
                }
            }

            if (this.disabled) {
                this.numberInput.addClass(this.toThemeProperty('jqx-input-disabled'));
                this.numberInput.attr("disabled", true);
                this.host.addClass(this.toThemeProperty('jqx-fill-state-disabled'));
            }

            this.selectedText = "";
            this.decimalSeparatorPosition = -1;

            var id = this.element.id;
            var el = this.element;
            var self = this;

            this.oldValue = this._value();

            this.items = new Array();
            var value = this.value;
            var decimal = this.decimal;
            this._initializeLiterals();
            this._render();

            this.setDecimal(value !== null ? decimal : null);
            var me = this;
            setTimeout(function () {
                //           me._render(false);
            }
                , 100);

            this._addHandlers();
            $.jqx.utilities.resize(this.host, function () {
                me._render();
            });
        },

        refresh: function (initialRefresh) {
            if (!initialRefresh) {
                this._render();
            }
        },

        wheel: function (event, self) {
            if (!self.enableMouseWheel) {
                return;
            }
            self.changeType = "mouse";
            var delta = 0;
            if (!event) /* For IE. */
                event = window.event;

            if (event.originalEvent && event.originalEvent.wheelDelta) {
                event.wheelDelta = event.originalEvent.wheelDelta;
            }

            if (event.wheelDelta) { /* IE/Opera. */
                delta = event.wheelDelta / 120;
            } else if (event.detail) { /** Mozilla case. */
                delta = -event.detail / 3;
            }

            if (delta) {
                var result = self._handleDelta(delta);
                if (event.preventDefault)
                    event.preventDefault();

                if (event.originalEvent != null) {
                    event.originalEvent.mouseHandled = true;
                }

                if (event.stopPropagation != undefined) {
                    event.stopPropagation();
                }

                if (result) {
                    result = false;
                    event.returnValue = result;
                    return result;
                }
                else {
                    return false;
                }
            }

            if (event.preventDefault)
                event.preventDefault();
            event.returnValue = false;
        },

        _handleDelta: function (delta) {
            if (delta < 0) {
                this.spinDown();
            }
            else this.spinUp();
            return true;
        },

        _addHandlers: function () {
            var self = this;
            this.addHandler(this.numberInput, 'paste',
                function (e) {
                    var selection = self._selection();
                    e.preventDefault();
                    if (e.originalEvent.clipboardData) {
                        var content = (e.originalEvent || e).clipboardData.getData('text/plain');
                    }
                    else if (window.clipboardData) {
                        var content = window.clipboardData.getData('Text');
                    }
                    this.selectedText = content;
                    $.data(document.body, "jqxSelection", this.selectedText);
                    if (self.inputMode != "simple") {
                        self._pasteSelectedText();
                    }
                    else self.val(content);
                    setTimeout(function () {
                        self._setSelectionStart(selection.start);
                    });
                });
            this.addHandler(this.numberInput, 'mousedown',
                function (event) {
                    return self._raiseEvent(2, event)
                });

            this._mousewheelfunc = this._mousewheelfunc || function (event) {
                if (!self.editcell) {
                    self.wheel(event, self);
                    return false;
                }
            };

            this.removeHandler(this.host, 'mousewheel', this._mousewheelfunc);
            this.addHandler(this.host, 'mousewheel', this._mousewheelfunc);
            var oldval = "";

            this.addHandler(this.numberInput, 'focus',
                function (event) {
                    $.data(self.numberInput, "selectionstart", self._selection().start);
                    self.host.addClass(self.toThemeProperty('jqx-fill-state-focus'));
                    if (self.spincontainer) {
                        self.spincontainer.addClass(self.toThemeProperty('jqx-numberinput-focus'));
                    }
                    oldval = self.numberInput.val();
                    self._savedValue = self.decimal;
                });

            this.addHandler(this.numberInput, 'blur',
                function (event) {
                    if (self.inputMode == 'simple') {
                        self._exitSimpleInputMode(event, self, false, oldval);
                    }
                    if (self.autoValidate) {
                        var val = parseFloat(self.decimal);
                        var isNegative = self.getvalue('negative');
                        if (isNegative && self.decimal > 0) {
                            val = -parseFloat(self.decimal);
                        }

                        if (val > self.max) {
                            self._disableSetSelection = true;
                            self.setDecimal(self.max);
                            self._disableSetSelection = false;
                        }
                        if (val < self.min) {
                            self._disableSetSelection = true;
                            self.setDecimal(self.min);
                            self._disableSetSelection = false;
                        }
                    }

                    self.host.removeClass(self.toThemeProperty('jqx-fill-state-focus'));
                    if (self.spincontainer) {
                        self.spincontainer.removeClass(self.toThemeProperty('jqx-numberinput-focus'));
                    }
                    if (self.numberInput.val() != oldval) {
                        self._raiseEvent(7, event);
                        $.jqx.aria(self, "aria-valuenow", self.decimal);
                        self.element.value = self.decimal;
                    }
                    return true;
                });

            this.addHandler(this.numberInput, 'mouseup',
                function (event) {
                    return self._raiseEvent(3, event)
                });

            this.addHandler(this.numberInput, 'keydown',
                function (event) {
                    self.changeType = "keyboard";

                    return self._raiseEvent(4, event)
                });

            this.addHandler(this.numberInput, 'keyup',
                function (event) {
                    return self._raiseEvent(5, event)
                });

            this.addHandler(this.numberInput, 'keypress',
                function (event) {
                    return self._raiseEvent(6, event)
                });
        },

        focus: function () {
            try {
                this.numberInput.focus();
            }
            catch (error) {
            }
        },

        blur: function () {
            try {
                this.numberInput.blur();
            }
            catch (error) {
            }
        },

        _removeHandlers: function () {
            var self = this;
            this.removeHandler(this.numberInput, 'mousedown');
            var isOperaMini = $.jqx.mobile.isOperaMiniMobileBrowser();
            if (isOperaMini) {
                this.removeHandler($(document), 'click.' + this.element.id, self._exitSimpleInputMode, self);
            }

            this.removeHandler(this.numberInput, 'paste');
            this.removeHandler(this.numberInput, 'focus');
            this.removeHandler(this.numberInput, 'blur');
            this.removeHandler(this.numberInput, 'mouseup');
            this.removeHandler(this.numberInput, 'keydown');
            this.removeHandler(this.numberInput, 'keyup');
            this.removeHandler(this.numberInput, 'keypress');
        },

        //[optimize]
        _spinButtons: function () {
            if (this.host.jqxRepeatButton) {
                if (!this.numberInput) {
                    this.numberInput = $("<input autocomplete='off' style='border: none; position: relative; float: left;' type='textarea'/>");
                    this.numberInput.appendTo(this.host);
                    this.numberInput.addClass(this.toThemeProperty('jqx-input-content'));
                    this.numberInput.addClass(this.toThemeProperty('jqx-widget-content'));
                }
                else {
                    this.numberInput.css('float', 'left');
                }

                if (this.spincontainer) {
                    if (this.upbutton) {
                        this.upbutton.jqxRepeatButton('destroy');
                    }
                    if (this.downbutton) {
                        this.downbutton.jqxRepeatButton('destroy');
                    }

                    this.spincontainer.remove();
                }

                this.spincontainer = $('<div style="float: right; height: 100%; overflow: hidden; position: relative;"></div>');
                if (this.rtl) {
                    this.spincontainer.css('float', 'right');
                    this.numberInput.css('float', 'right');
                    this.spincontainer.css('left', '-1px');
                }
                this.host.append(this.spincontainer);
                this.upbutton = $('<div style="overflow: hidden; padding: 0px; margin-left: -1px; position: relative;"><div></div></div>');
                this.spincontainer.append(this.upbutton);
                this.upbutton.jqxRepeatButton({ overrideTheme: true, disabled: this.disabled, roundedCorners: 'top-right' });
                this.downbutton = $('<div style="overflow: hidden; padding: 0px; margin-left: -1px; position: relative;"><div></div></div>');
                this.spincontainer.append(this.downbutton);
                this.downbutton.jqxRepeatButton({ overrideTheme: true, disabled: this.disabled, roundedCorners: 'bottom-right' });

                if (this.template) {
                    this.upbutton.addClass(this.toThemeProperty("jqx-" + this.template))
                    this.downbutton.addClass(this.toThemeProperty("jqx-" + this.template))
                }

                var me = this;

                this.downbutton.addClass(this.toThemeProperty('jqx-fill-state-normal jqx-action-button'));
                this.upbutton.addClass(this.toThemeProperty('jqx-fill-state-normal jqx-action-button'));
                this.upbutton.addClass(this.toThemeProperty('jqx-rc-tr'));
                this.downbutton.addClass(this.toThemeProperty('jqx-rc-br'));

                this.addHandler(this.downbutton, 'mouseup', function (event) {
                    if (!me.disabled) {
                        me.downbutton.removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                        me._downArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-down-selected'));
                    }
                });

                this.addHandler(this.upbutton, 'mouseup', function (event) {
                    if (!me.disabled) {
                        me.upbutton.removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                        me._upArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-up-selected'));
                    }
                });

                this.removeHandler($(document), 'mouseup.' + this.element.id);
                this.addHandler($(document), 'mouseup.' + this.element.id, function (event) {
                    me.upbutton.removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                    me._upArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-up-selected'));
                    me.downbutton.removeClass(me.toThemeProperty('jqx-fill-state-pressed'));
                    me._downArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-down-selected'));
                });

                this.addHandler(this.downbutton, 'mousedown', function (event) {
                    if (!me.disabled) {
                        if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                            me._inputSelection = me._selection();
                        }

                        me.downbutton.addClass(me.toThemeProperty('jqx-fill-state-pressed'));
                        me._downArrow.addClass(me.toThemeProperty('jqx-icon-arrow-down-selected'));
                        event.preventDefault();
                        event.stopPropagation();
                        return false;
                    }
                });

                this.addHandler(this.upbutton, 'mousedown', function (event) {
                    if (!me.disabled) {
                        if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                            me._inputSelection = me._selection();
                        }

                        me.upbutton.addClass(me.toThemeProperty('jqx-fill-state-pressed'));
                        me._upArrow.addClass(me.toThemeProperty('jqx-icon-arrow-up-selected'));
                        event.preventDefault();
                        event.stopPropagation();
                        return false;
                    }
                });

                this.addHandler(this.upbutton, 'mouseenter', function (event) {
                    me.upbutton.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                    me._upArrow.addClass(me.toThemeProperty('jqx-icon-arrow-up-hover'));
                });
                this.addHandler(this.upbutton, 'mouseleave', function (event) {
                    me.upbutton.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                    me._upArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-up-hover'));
                });

                this.addHandler(this.downbutton, 'mouseenter', function (event) {
                    me.downbutton.addClass(me.toThemeProperty('jqx-fill-state-hover'));
                    me._downArrow.addClass(me.toThemeProperty('jqx-icon-arrow-down-hover'));
                });
                this.addHandler(this.downbutton, 'mouseleave', function (event) {
                    me.downbutton.removeClass(me.toThemeProperty('jqx-fill-state-hover'));
                    me._downArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-down-hover'));
                });

                this.upbutton.css('border-width', '0px');
                this.downbutton.css('border-width', '0px');

                if (this.disabled) {
                    this.upbutton[0].disabled = true;
                    this.downbutton[0].disabled = true;
                }
                else {
                    this.upbutton[0].disabled = false;
                    this.downbutton[0].disabled = false;
                }

                this.spincontainer.addClass(this.toThemeProperty('jqx-input'));
                this.spincontainer.addClass(this.toThemeProperty('jqx-rc-r'));
                this.spincontainer.css('border-width', '0px');
                if (!this.rtl) {
                    this.spincontainer.css('border-left-width', '1px');
                }
                else {
                    this.spincontainer.css('border-right-width', '1px');
                }

                this._upArrow = this.upbutton.find('div');
                this._downArrow = this.downbutton.find('div');

                this._upArrow.addClass(this.toThemeProperty('jqx-icon-arrow-up'));
                this._downArrow.addClass(this.toThemeProperty('jqx-icon-arrow-down'));
                this._upArrow.addClass(this.toThemeProperty('jqx-input-icon'));
                this._downArrow.addClass(this.toThemeProperty('jqx-input-icon'));
                var me = this;
                this._upArrow.hover(function () {
                    if (!me.disabled) {
                        me._upArrow.addClass(me.toThemeProperty('jqx-icon-arrow-up-hover'));
                    }
                }, function () {
                    me._upArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-up-hover'));
                });
                this._downArrow.hover(function () {
                    if (!me.disabled) {
                        me._downArrow.addClass(me.toThemeProperty('jqx-icon-arrow-down-hover'));
                    }
                }, function () {
                    me._downArrow.removeClass(me.toThemeProperty('jqx-icon-arrow-down-hover'));
                });


                var isTouchDevice = $.jqx.mobile.isTouchDevice();
                var eventname = 'click';
                if (isTouchDevice) {
                    eventname = $.jqx.mobile.getTouchEventName('touchstart');
                }

                if (isTouchDevice) {
                    this.addHandler(this.downbutton, 'click', function (event) {
                        me.spinDown();
                    });
                    this.addHandler(this.upbutton, 'click', function (event) {
                        me.spinUp();
                    });
                }

                this.addHandler(this.downbutton, eventname, function (event) {
                    if (!isTouchDevice) {
                        if (me._selection().start == 0) {
                            me._setSelectionStart(me.numberInput.val().length);
                        }

                        if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                            me._setSelectionStart(me._inputSelection.start);
                        }
                    }
                    else {
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    me.spinDown();
                    return false;
                });
                this.addHandler(this.upbutton, eventname, function (event) {
                    if (!isTouchDevice) {
                        if (me._selection().start == 0) {
                            me._setSelectionStart(me.numberInput.val().length);
                        }
                        if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                            me._setSelectionStart(me._inputSelection.start);
                        }
                    }
                    else {
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    me.spinUp();
                    return false;
                });
            } else {
                throw new Error("jqxNumberInput: Missing reference to jqxbuttons.js.");
            }
        },

        spinDown: function () {
            var me = this;

            var oldDecimal = this.decimal;

            if (me.spinMode == 'none')
                return;

            if (this.decimal == null) {
                this.setDecimal(0);
                return;
            }

            var isNegative = this.getvalue('negative');
            var negativeOffset = isNegative ? -1 : 0;

            if ($.jqx.mobile.isTouchDevice() || this.inputMode == 'textbox') {
                me._doTouchHandling();
            }

            if (!me.disabled) {
                var selection = this._selection();
                var olddecimal = this.decimal;

                var decimal = this.getDecimal();
                if (decimal < this.min) {
                    decimal = this.min;
                    this.setDecimal(this.min);
                    this._setSelectionStart(selection.start);
                    this.spinDown();
                    return;
                }
                else if (decimal > this.max) {
                    decimal = this.max;
                    this.setDecimal(this.max);
                    this._setSelectionStart(selection.start);
                    this.spinDown();
                    return;
                }

                if (me.spinButtonsStep < 0) me.spinButtonsStep = 1;

                var dec = parseInt(me.decimal) - me.spinButtonsStep;
                dec = dec.toString().length;
                var validvalue = negativeOffset + dec <= me.digits + me.decimalDigits;

                if (me.spinMode != 'advanced' || me.decimalDigits === 0) {
                    if (decimal - me.spinButtonsStep >= me.min && validvalue) {
                        var multiple = 1;
                        for (i = 0; i < me.decimalDigits; i++) {
                            multiple = multiple * 10;
                        }

                        var newvalue = (multiple * decimal) - (multiple * me.spinButtonsStep);
                        newvalue = newvalue / multiple;
                        newvalue = this._parseDecimalValueToEditorValue(newvalue);
                        me.setDecimal(newvalue);
                    }
                }
                else {
                    var values = this._getspindecimal();
                    var separator = this._getSeparatorPosition();

                    var decimal = parseFloat(values.decimal);
                    if (me.spinButtonsStep < 0) me.spinButtonsStep = 1;

                    var dec = parseInt(decimal) - me.spinButtonsStep;
                    dec = dec.toString().length;
                    var validvalue = negativeOffset + dec <= me.digits;
                    var multiple = 1;

                    var separatorindex = values.decimal.indexOf(".");
                    if (separatorindex != -1) {
                        var divide = values.decimal.length - separatorindex - 1;
                        var multiple = 1;
                        for (var i = 0; i < divide; i++) {
                            multiple = multiple * 10;
                        }
                        decimal -= new Number(me.spinButtonsStep / multiple);
                        decimal = decimal.toFixed(divide);
                        var separatorindex = decimal.toString().indexOf(".");
                        if (separatorindex == -1) {
                            decimal = decimal.toString() + '.';
                        }
                        var result = decimal.toString() + values.afterdecimal;
                        result = new Number(result);
                        result = result.toFixed(me.decimalDigits);
                        if (result >= me.min) {
                            result = this._parseDecimalValueToEditorValue(result);
                            me.setDecimal(result);
                        }
                    }
                    else {
                        if (decimal - me.spinButtonsStep >= me.min && validvalue) {
                            var newvalue = (multiple * decimal) - (multiple * me.spinButtonsStep);
                            newvalue = newvalue / multiple;
                            var result = newvalue.toString() + values.afterdecimal;
                            if (result >= me.min) {
                                result = this._parseDecimalValueToEditorValue(result);
                                me.setDecimal(result);
                            }
                        }
                    }
                }

                if (result == undefined || this.inputMode != 'simple') {
                    var isNegative = this.getvalue('negative');
                    if (negativeOffset == 0 && isNegative) {
                        this._setSelectionStart(selection.start + 1);
                    }
                    else {
                        this._setSelectionStart(selection.start);
                    }

                    me.savedValue = me.numberInput[0].value;
                    if (oldDecimal != this.decimal) {
                        if ($.jqx.mobile.isTouchDevice()) {
                            this._raiseEvent(0, {});
                        }
                        this._raiseEvent(7, {});
                    }

                    $.jqx.aria(this, "aria-valuenow", this.decimal);
                    return;
                }

                result = this.decimal.toString();
                var isNegative = this.getvalue('negative');
                if (negativeOffset == 0 && isNegative) {
                    this._setSelectionStart(selection.start + 1);
                }
                else {
                    if ((result != undefined && (olddecimal == undefined || olddecimal.toString().length == result.length))) {
                        this._setSelectionStart(selection.start);
                    }
                    else {
                        if (isNegative) {
                            this._setSelectionStart(selection.start + 1);
                        }
                        else {
                            this._setSelectionStart(selection.start - 1);
                        }
                    }
                }
                if (oldDecimal != this.decimal) {
                    if ($.jqx.mobile.isTouchDevice()) {
                        this._raiseEvent(0, {});
                    }
                    this._raiseEvent(7, {});
                }
                $.jqx.aria(this, "aria-valuenow", this.decimal);
            }
        },

        _getspindecimal: function () {
            var selection = this._selection();
            var decimalString = "";
            var separatorPosition = this._getSeparatorPosition();
            var visibleItems = this._getVisibleItems();
            var prefix = this._getHiddenPrefixCount();
            var text = this.numberInput.val();

            if (this.numberInput.val().length == selection.start && selection.length == 0) {
                this._setSelection(selection.start, selection.start + 1);
                selection = this._selection();
            }

            var issimple = this.inputMode != 'advanced';
            var selectionStart = selection.start;

            if (selectionStart === 0) {
                selectionStart++;
            }

            if (selectionStart === 1 && this.symbolPosition === "left" && this.symbol !== "") {
                selectionStart += this.symbol.length;
            }

            for (var i = 0; i < selectionStart; i++) {
                if (issimple) {
                    var literal = text.substring(i, i + 1);
                    var isDigit = (!isNaN(parseInt(literal)));
                    if (isDigit) {
                        decimalString += literal;
                    }
                    if (literal == this.decimalSeparator) {
                        decimalString += literal;
                    }
                    continue;
                }

                if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                    decimalString += visibleItems[i].character;
                }
                else if (!visibleItems[i].canEdit && this.decimalSeparatorPosition != -1 && visibleItems[i] == visibleItems[this.decimalSeparatorPosition - prefix]) {
                    if (decimalString.length == 0) {
                        decimalString = "0";
                    }

                    decimalString += visibleItems[i].character;
                }

            }

            var afterdecimal = "";
            for (var i = selectionStart; i < visibleItems.length; i++) {
                if (issimple) {
                    var literal = text.substring(i, i + 1);
                    var isDigit = (!isNaN(parseInt(literal)));
                    if (isDigit) {
                        afterdecimal += literal;
                    }
                    if (literal == this.decimalSeparator) {
                        afterdecimal += literal;
                    }
                    continue;
                }

                if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                    afterdecimal += visibleItems[i].character;
                }
                else if (!visibleItems[i].canEdit && this.decimalSeparatorPosition != -1 && visibleItems[i] == visibleItems[this.decimalSeparatorPosition - prefix]) {
                    afterdecimal += visibleItems[i].character;
                }
            }
            var isNegative = this.getvalue('negative');
            var d = isNegative ? "-" + this._parseDecimalValue(decimalString).toString() : this._parseDecimalValue(decimalString).toString();
            return { decimal: d, afterdecimal: this._parseDecimalValue(afterdecimal) };
        },

        _parseDecimalValue: function (number) {
            if (this.decimalSeparator != '.') {
                var start = number.toString().indexOf(this.decimalSeparator);
                if (start >= 0) {
                    var result = number.toString().substring(0, start) + '.' + number.toString().substring(start + 1);
                    return result;
                }
            }
            return number;
        },

        _parseDecimalValueToEditorValue: function (number) {
            if (this.decimalSeparator != '.') {
                var start = number.toString().indexOf(".");
                if (start >= 0) {
                    var result = number.toString().substring(0, start) + this.decimalSeparator + number.toString().substring(start + 1);
                    return result;
                }
            }
            return number;
        },

        spinUp: function () {
            var me = this;
            var oldDecimal = this.decimal;
            if (me.spinMode == 'none')
                return;

            if (this.decimal == null) {
                this.setDecimal(0);
                return;
            }

            if ($.jqx.mobile.isTouchDevice() || this.inputMode == 'textbox') {
                me._doTouchHandling();
            }

            var isNegative = this.getvalue('negative');
            var negativeOffset = isNegative ? -1 : 0;

            if (!me.disabled) {
                var selection = this._selection();
                var olddecimal = me.decimal;
                var decimal = me.getDecimal();
                if (decimal < this.min) {
                    decimal = this.min;
                    this.setDecimal(this.min);
                    this._setSelectionStart(selection.start);
                    this.spinUp();
                    return;
                }
                else if (decimal > this.max) {
                    decimal = this.max;
                    this.setDecimal(this.max);
                    this._setSelectionStart(selection.start);
                    this.spinUp();
                    return;
                }
                if (me.spinButtonsStep < 0) me.spinButtonsStep = 1;

                var dec = parseInt(me.decimal) + me.spinButtonsStep;
                dec = dec.toString().length;
                var validvalue = negativeOffset + dec <= me.digits + me.decimalDigits;

                if (me.spinMode != 'advanced' || me.decimalDigits === 0) {
                    if (decimal + me.spinButtonsStep <= me.max && validvalue) {
                        var multiple = 1;
                        for (var i = 0; i < me.decimalDigits; i++) {
                            multiple = multiple * 10;
                        }

                        var newvalue = (multiple * decimal) + (multiple * me.spinButtonsStep);
                        newvalue = newvalue / multiple;
                        newvalue = this._parseDecimalValueToEditorValue(newvalue);
                        me.setDecimal(newvalue);
                    }
                }
                else {
                    var values = this._getspindecimal();
                    var separator = this._getSeparatorPosition();

                    var decimal = parseFloat(values.decimal);
                    if (me.spinButtonsStep < 0) me.spinButtonsStep = 1;

                    var dec = parseInt(decimal) + me.spinButtonsStep;
                    dec = dec.toString().length;
                    var validvalue = negativeOffset + dec <= me.digits;
                    var multiple = 1;

                    var separatorindex = values.decimal.indexOf(".");
                    if (separatorindex != -1) {
                        var divide = values.decimal.length - separatorindex - 1;
                        var multiple = 1;
                        for (var i = 0; i < divide; i++) {
                            multiple = multiple * 10;
                        }
                        decimal += new Number(me.spinButtonsStep / multiple);
                        decimal = decimal.toFixed(divide);
                        var separatorindex = decimal.toString().indexOf(".");
                        if (separatorindex == -1) {
                            decimal = decimal.toString() + '.';
                        }
                        var result = decimal.toString() + values.afterdecimal;
                        result = new Number(result);
                        result = result.toFixed(me.decimalDigits);
                        var number = new Number(result).toFixed(me.decimalDigits);

                        if (number <= me.max) {
                            result = this._parseDecimalValueToEditorValue(result);
                            me.setDecimal(result);
                        }
                        else result = undefined;
                    }
                    else {
                        if (decimal + me.spinButtonsStep <= me.max && validvalue) {
                            var newvalue = (multiple * decimal) + (multiple * me.spinButtonsStep);

                            newvalue = newvalue / multiple;
                            var result = newvalue.toString() + values.afterdecimal;
                            var number = new Number(result).toFixed(me.decimalDigits);
                            if (number <= me.max) {
                                result = this._parseDecimalValueToEditorValue(result);
                                if (isNegative && result.indexOf('-') == -1) {
                                    if (values.decimal != '-0') {
                                        result = '-' + result;
                                    }
                                }
                                me.setDecimal(result);
                            }
                            else {
                                result = undefined;
                            }
                        }
                    }
                }

                if (result == undefined || this.inputMode != 'simple') {
                    this._setSelectionStart(selection.start);
                    me.savedValue = me.numberInput[0].value;
                    if (oldDecimal != this.decimal) {
                        if ($.jqx.mobile.isTouchDevice()) {
                            this._raiseEvent(0, {});
                        }
                        this._raiseEvent(7, {});
                    }
                    $.jqx.aria(this, "aria-valuenow", this.decimal);
                    return;
                }

                result = this.decimal.toString();
                var isNegative = this.getvalue('negative');
                if (negativeOffset == -1 && !isNegative) {
                    this._setSelectionStart(-1 + selection.start);
                }
                else {
                    if ((result != undefined && (olddecimal == undefined || olddecimal.toString().length == result.length))) {
                        this._setSelectionStart(selection.start);
                    }
                    else {
                        if (isNegative) {
                            this._setSelectionStart(selection.start);
                        }
                        else {
                            this._setSelectionStart(1 + selection.start);
                        }
                    }
                }
                if (oldDecimal != this.decimal) {
                    if ($.jqx.mobile.isTouchDevice()) {
                        this._raiseEvent(0, {});
                    }
                    this._raiseEvent(7, {});
                }
                $.jqx.aria(this, "aria-valuenow", this.decimal);
            }
        },

        _exitSimpleInputMode: function (event, self, checkbounds, oldvalue) {
            if (self == undefined) {
                self = event.data;
            }

            if (self == null) return;

            if (checkbounds == undefined) {
                if (event.target != null && self.element != null) {
                    if ((event.target.id != undefined && event.target.id.toString().length > 0 && self.host.find('#' + event.target.id).length > 0) || event.target == self.element) {
                        return;
                    }
                }

                var offset = self.host.offset();
                var left = offset.left;
                var top = offset.top;
                var width = self.host.width();
                var height = self.host.height();

                var targetOffset = $(event.target).offset();
                if (targetOffset.left >= left && targetOffset.left <= left + width)
                    if (targetOffset.top >= top && targetOffset.top <= top + height) {
                        return;
                    }
            }

            if ($.jqx.mobile.isOperaMiniBrowser()) {
                self.numberInput.attr("readonly", true);
            }

            if (self.disabled || self.readOnly)
                return;

            var enteredMode = $.data(self.numberInput, "simpleInputMode");
            if (enteredMode == null) return;

            $.data(self.numberInput, "simpleInputMode", null);
            this._parseDecimalInSimpleMode();
            return false;
        },

        _getDecimalInSimpleMode: function () {
            var val = this.decimal;
            if (this.decimalSeparator != '.') {
                var indx = val.toString().indexOf(this.decimalSeparator);
                if (indx > 0) {
                    var prefix = val.toString().substring(0, indx);
                    var val = prefix + "." + val.toString().substring(indx + 1);
                }
            }
            return val;
        },

        _parseDecimalInSimpleMode: function (refreshValue) {
            var self = this;
            var isNegative = self.getvalue('negative');
            var decimal = this.ValueString;
            if (decimal == undefined) {
                decimal = this.GetValueString(this.numberInput.val(), this.decimalSeparator, this.decimalSeparator != "");
            }
            if (this.decimalSeparator != '.') {
                var indx = decimal.toString().indexOf(".");
                if (indx > 0) {
                    var prefix = decimal.toString().substring(0, indx);
                    var val = prefix + this.decimalSeparator + decimal.toString().substring(indx + 1);
                    decimal = val;
                }
            }

            var string = isNegative ? "-" : '';
            if (this.symbolPosition == 'left') {
                string += this.symbol;
            }
            var leadingDigitsCount = this.digits % this.groupSize;
            if (leadingDigitsCount == 0) {
                leadingDigitsCount = this.groupSize;
            }

            var decimalString = decimal.toString();
            if (decimalString.indexOf('-') >= 0) {
                decimalString = decimalString.substring(decimalString.indexOf('-') + 1);
            }

            string += decimalString;

            if (this.symbolPosition == 'right') {
                string += this.symbol;
            }

            if (refreshValue != false) {
                self.numberInput.val(string);
            }
        },

        //[optimize]
        _enterSimpleInputMode: function (event, self) {
            if (self == undefined) {
                self = event.data;
            }

            var selection = this._selection();

            if (self == null) return;
            var isNegative = self.getvalue('negative');

            var decimal = self.decimal;
            if (isNegative) {
                if (decimal > 0)
                    decimal = -decimal;
            }

            self.numberInput.val(decimal);
            $.data(self.numberInput, "simpleInputMode", true);

            if ($.jqx.mobile.isOperaMiniBrowser()) {
                self.numberInput.attr("readonly", false);
            }
            this._parseDecimalInSimpleMode();
            this._setSelectionStart(selection.start);
        },

        setvalue: function (name, value) {
            if (this[name] !== undefined) {
                if (name == 'decimal') {
                    this._setDecimal(value);
                }
                else {
                    this[name] = value;
                    this.propertyChangedHandler(this, name, value, value);
                }
            }
        },

        getvalue: function (name) {
            if (name == 'decimal') {
                if (this.negative != undefined && this.negative == true) {
                    if (this.decimal.toString().indexOf(',')) {
                        return -Math.abs(this.decimal.toString().replace(/,/, '.'));
                    }

                    return -Math.abs(this[name]);
                }
            }

            if (name in this) {
                return this[name]
            }

            return null;
        },

        // gets the intput's value.
        _getString: function () {
            var s = "";
            for (var i = 0; i < this.items.length; i++) {
                var character = this.items[i].character;
                s += character;
            }

            return s;
        },

        //[optimize]
        _literal: function (letter, regExpression, editable, separator) {
            return { character: letter, regex: regExpression, canEdit: editable, isSeparator: separator };
        },

        //[optimize]
        _initializeLiterals: function () {
            if (this.inputMode == 'textbox') return;
            // add the negative symbol.
            var index = 0;
            var negativeSymbolLength = this.negativeSymbol.length;
            for (var i = 0; i < negativeSymbolLength; i++) {
                var character = this.negativeSymbol.substring(i, i + 1);
                var regex = "";
                var canEdit = false;
                var literal = null;
                if (this.negative) {
                    literal = this._literal(character, regex, canEdit, false);
                }
                else {
                    literal = this._literal('', regex, canEdit, false);
                }

                this.items[index] = literal;
                index++;
            }

            // add the currency or percentage symbol.
            var symbolLength = this.symbol.length;
            if (this.symbolPosition == 'left') {
                for (i = 0; i < symbolLength; i++) {
                    var character = this.symbol.substring(i, i + 1);
                    var regex = "";
                    var canEdit = false;
                    var literal = this._literal(character, regex, canEdit, false);
                    this.items[index] = literal;
                    index++;
                }
            }

            var leadingDigitsCount = this.digits % this.groupSize;
            if (leadingDigitsCount == 0) {
                leadingDigitsCount = this.groupSize;
            }

            // add the digits and group separators.
            for (var i = 0; i < this.digits; i++) {
                var character = this.promptChar;
                var regex = "\\d";
                var canEdit = true;

                var literal = this._literal(character, regex, canEdit, false);
                this.items[index] = literal;
                index++;

                if (i < this.digits - 1 && this.groupSeparator != undefined && this.groupSeparator.length > 0) {
                    leadingDigitsCount--;
                    if (leadingDigitsCount == 0) {
                        leadingDigitsCount = this.groupSize;
                        var separatorLiteral = this._literal(this.groupSeparator, "", false, false);
                        this.items[index] = separatorLiteral;
                        index++;
                    }
                }
                else if (i == this.digits - 1) {
                    literal.character = 0;
                }
            }
            this.decimalSeparatorPosition = -1;

            // add the digits decimal separator and the decimal digits.
            if (this.decimalDigits != undefined && this.decimalDigits > 0) {
                var character = this.decimalSeparator;
                if (character.length == 0) {
                    character = ".";
                }

                var literal = this._literal(character, "", false, true);
                this.items[index] = literal;
                this.decimalSeparatorPosition = index;
                index++;

                for (var i = 0; i < this.decimalDigits; i++) {
                    var decimalCharacter = 0;
                    var regex = "\\d";
                    var decimalDigit = this._literal(decimalCharacter, regex, true, false);
                    this.items[index] = decimalDigit;
                    index++;
                }
            }

            // add the currency or percentage symbol.
            if (this.symbolPosition == 'right') {
                for (var i = 0; i < symbolLength; i++) {
                    var character = this.symbol.substring(i, i + 1);
                    var regex = "";
                    var canEdit = false;
                    var literal = this._literal(character, regex, canEdit);
                    this.items[index] = literal;
                    index++;
                }
            }
        },

        //[optimize]
        _match: function (character, regex) {
            var regExpr = new RegExp(regex, "i");
            return regExpr.test(character);
        },

        //[optimize]
        _raiseEvent: function (id, arg) {
            var evt = this.events[id];
            var args = {};
            args.owner = this;
            if (this.host.css('display') == 'none') {
                return true;
            }

            var key = arg.charCode ? arg.charCode : arg.keyCode ? arg.keyCode : 0;
            var result = true;
            var isreadOnly = this.readOnly;
            var me = this;

            if (id == 3 || id == 2) {
                if (!this.disabled) {
                    if (this.inputMode != 'simple' && this.inputMode != 'textbox') {
                        this._handleMouse(arg);
                    }
                    else {
                        //       this._enterSimpleInputMode(null, me);
                        return true;
                    }
                }
            }

            if (id == 0) {
                var decimalValue = this.getvalue('decimal');
                if ((this.max < decimalValue) || (this.min > decimalValue)) {
                    this.host.addClass(this.toThemeProperty("jqx-input-invalid"));
                }
                else {
                    this.host.removeClass(this.toThemeProperty("jqx-input-invalid"));
                    this.host.addClass(this.toThemeProperty("jqx-input"));
                    this.host.addClass(this.toThemeProperty("jqx-rc-all"));
                }
            }

            var event = new $.Event(evt);
            event.owner = this;
            args.value = this.getvalue('decimal');
            args.text = this.numberInput.val();

            event.args = args;
            if (id == 7) {
                args.type = this.changeType;
                this.changeType = null;
            }
            if (evt != undefined) {
                if (id != 4 && id != 5 && id != 6) {
                    result = this.host.trigger(event);
                }
            }
            var me = this;
            // key down
            if (this.inputMode == 'textbox')
                return result;

            if (this.inputMode != 'simple') {
                if (id == 4) {
                    if (isreadOnly || this.disabled) {
                        return false;
                    }

                    result = me._handleKeyDown(arg, key);
                }
                // key up
                else if (id == 5) {
                    if (isreadOnly || this.disabled) {
                        result = false;
                    }
                }
                else if (id == 6) {
                    if (isreadOnly || this.disabled) {
                        return false;
                    }
                    result = me._handleKeyPress(arg, key);
                }
            }
            else {
                if (id == 4 || id == 5 || id == 6) {
                    if ($.jqx.mobile.isTouchDevice() || this.touchMode === true) {
                        return true;
                    }

                    if (isreadOnly || this.disabled) {
                        return false;
                    }

                    var letter = String.fromCharCode(key);
                    var digit = parseInt(letter);
                    var allowInput = true;
                    if (!arg.ctrlKey && !arg.shiftKey && !arg.metaKey) {
                        if (key >= 65 && key <= 90) {
                            allowInput = false;
                        }
                    }

                    if (id == 6 && $.jqx.browser.opera != undefined) {
                        if (key == 8)
                            return false;
                    }
                    if (allowInput) {
                        if (id == 4) {
                            allowInput = me._handleSimpleKeyDown(arg, key);
                        }

                        if (key == 107) {
                            var isNegative = me.getvalue('negative');

                            if (isNegative) {
                                me.setvalue('negative', false);
                                me.decimal = me.ValueString;
                                me._parseDecimalInSimpleMode();
                                me._setSelectionStart(selection.start + 1);
                                me._raiseEvent(0, me.value);
                                me._raiseEvent(1, me.numberInput.val());
                            }
                        }

                        if (key == 189 || key == 45 || key == 109 || key == 173) {
                            var selection = me._selection();
                            if (id == 4) {
                                var isNegative = me.getvalue('negative');
                                if (isNegative == false) {
                                    me.setvalue('negative', true);
                                }
                                else {
                                    me.setvalue('negative', false);
                                }
                                me.decimal = me.ValueString;
                                me._parseDecimalInSimpleMode();
                                if (!isNegative) {
                                    me._setSelectionStart(selection.start + 1);
                                }
                                else {
                                    me._setSelectionStart(selection.start - 1);
                                }
                                allowInput = false;
                                me._raiseEvent(0, me.value);
                                me._raiseEvent(1, me.numberInput.val());
                            }
                        }

                        var ctrlKey = args.ctrlKey || args.metaKey;
                        if (!$.jqx.browser.msie) {
                            var e = arg;
                            if ((ctrlKey && key == 99 /* firefox */) || (ctrlKey && key == 67) /* opera */ ||
                                (ctrlKey && key == 122 /* firefox */) || (ctrlKey && key == 90) /* opera */ ||
                                (ctrlKey && key == 118 /* firefox */) || (ctrlKey && key == 86) /* opera */ || (e.shiftKey && key == 45)) {
                                if ($.jqx.browser.webkit || $.jqx.browser.chrome) {
                                    me._handleSimpleKeyDown(arg, key);
                                }
                                if (key == 67)
                                    return true;
                                return false;
                            }
                        }

                        if ((ctrlKey && key == 97 /* firefox */) || (ctrlKey && key == 65) /* opera */) {
                            return true;
                        }

                        if (id == 6 && allowInput) {
                            var specialKey = this._isSpecialKey(key);
                            return specialKey;
                        }
                    }

                    return allowInput;
                }
            }

            return result;
        },

        GetSelectionInValue: function (selectionPosition, text, separator, hasSeparator) {
            var selectionInValue = 0;

            for (var i = 0; i < text.length; i++) {
                if (i >= selectionPosition)
                    break;

                var literal = text.substring(i, i + 1);
                var isDigit = (!isNaN(parseInt(literal)));

                if (isDigit || (hasSeparator && text.substring(i, i + 1) == separator)) {
                    selectionInValue++;
                }
            }

            return selectionInValue;
        },

        GetSelectionLengthInValue: function (selectionPosition, selectionLength, text, separator) {
            var selectionInValue = 0;

            for (var i = 0; i < text.length; i++) {
                if (i >= selectionPosition + selectionLength)
                    break;

                var literal = text.substring(i, i + 1);
                var isDigit = (!isNaN(parseInt(literal)));

                if (selectionLength > 0 && i >= selectionPosition && isDigit || (i >= selectionPosition && text[i].toString() == separator)) {
                    selectionInValue++;
                }
            }

            return selectionInValue;
        },

        GetInsertTypeByPositionInValue: function (positionInValue, separator, text, hasSeparator) {
            var insertType = "before";
            var valueString = this.GetValueString(text, separator, hasSeparator);
            var digitsToSeparator = this.GetDigitsToSeparator(0, valueString, separator);

            if (positionInValue > digitsToSeparator) {
                insertType = 'after';
            }

            return insertType;
        },

        RemoveRange: function (start, length, text, separatorChar, updateText, insert) {
            var decimalPossibleChars = this.digits;
            var selectionStart = start;
            var selectionLength = length;
            var removedDigits = 0;
            var value = this.decimal;
            var selection = this._selection();
            //   var text = this.numberInput.val();
            var separatorChar = this.decimalSeparator;
            var hasSeparator = separatorChar != '';

            if (selectionLength == 0 && this.ValueString.length < this.decimalPossibleChars - 1)
                return removedDigits;

            var separatorPosition = this.GetSeparatorPositionInText(separatorChar, text);

            if (!updateText) {
                separatorPosition = this.GetSeparatorPositionInText(separatorChar, text);
            }

            if (separatorPosition < 0 && !hasSeparator && text.length > 1) {
                separatorPosition = text.length;
            }

            if (separatorPosition == -1)
                separatorPosition = text.length;

            var separatorOffset = hasSeparator ? 1 : 0;

            if (length < 2 && insert == true) {
                var valueDigits = this.ValueString.length - this.decimalDigits - separatorOffset;
                if ((valueDigits) == decimalPossibleChars && start + length < separatorPosition) {
                    selectionLength++;
                }
            }


            var newTextString = "";
            for (var i = 0; i < text.length; i++) {
                if (i < selectionStart || i >= selectionStart + selectionLength) {
                    newTextString += text.substring(i, i + 1);
                    continue;
                }
                else {
                    var literal = text.substring(i, i + 1);
                    if (literal == separatorChar) {
                        newTextString += separatorChar;
                        continue;
                    }
                    else {
                        var literal = text.substring(i, i + 1);
                        if (this.symbol && this.symbol != "" && this.symbol.indexOf(literal) >= 0)
                            continue;

                        if (i > separatorPosition) {
                            newTextString += "0";
                            continue;
                        }
                    }
                }

                var literal = text.substring(i, i + 1);
                var isDigit = (!isNaN(parseInt(literal)));

                if (isDigit) {
                    removedDigits++;
                }
            }

            if (newTextString.length == 0) {
                newTextString = "0";
            }

            if (updateText) {
                this.numberInput.val(newTextString);
            }
            else {
                this.ValueString = newTextString;
            }

            var ch = newTextString.substring(0, 1);
            if (ch == separatorChar && isNaN(parseInt(ch))) {
                var res = '0' + newTextString;
                newTextString = res;
            }

            this.ValueString = this.GetValueString(newTextString, separatorChar, hasSeparator);

            this.decimal = this.ValueString;
            this._parseDecimalInSimpleMode();

            this._setSelectionStart(selectionStart);
            return removedDigits;
        },

        InsertDigit: function (digit, position) {
            if (typeof this.digits != 'number') {
                this.digits = parseInt(this.digits);
            }

            if (typeof this.decimalDigits != 'number') {
                this.decimalDigits = parseInt(this.decimalDigits);
            }

            var decimalPossibleChars = 1 + this.digits;

            var selection = this._selection();
            var isNegative = this.getvalue('negative');
            var increased = false;

            if (selection.start == 0 && this.symbol != '' && this.symbolPosition == 'left') {
                this._setSelectionStart(selection.start + 1);
                selection = this._selection();
                increased = true;
            }

            if ((isNegative && increased) || (isNegative && !increased && selection.start == 0)) {
                this._setSelectionStart(selection.start + 1);
                selection = this._selection();
            }

            var selectionChar = this.numberInput.val().substring(selection.start, selection.start + 1);
            var text = this.numberInput.val();
            var separatorChar = this.decimalSeparator;
            var hasSeparator = separatorChar != '' && this.decimalDigits > 0;

            if (selectionChar == this.symbol && this.symbolPosition == 'right') {
                if (this.decimalDigits == 0) {
                    this.ValueString = this.GetValueString(text, separatorChar, hasSeparator);
                    if (this.ValueString.length >= decimalPossibleChars)
                        return;
                }
                else {
                    return;
                }
            }

            this.ValueString = this.GetValueString(text, separatorChar, hasSeparator);
            if (this.ValueString == "") {
                this.ValueString = new Number(0).toFixed(this.decimalDigits);
            }

            var value = this.ValueString;

            if (this.decimalDigits > 0 && position >= value.length) {
                position = value.length - 1;
            }

            var valueChar = '';
            if (position < value.length) {
                valueChar = value.substring(position, position + 1);
            }

            var shouldReplace = false;
            var decrementedPosition = false;

            var type = this.GetInsertTypeByPositionInValue(position, separatorChar, text, hasSeparator);

            if (type == 'after') {
                shouldReplace = true;
            }

            var separatorOffset = hasSeparator ? 1 : 0;

            if (valueChar != separatorChar && (this.ValueString.length - this.decimalDigits - separatorOffset) >= decimalPossibleChars - 1) {
                shouldReplace = true;
            }
            if (valueChar === "0" && this.ValueString.length === 1 && this.decimalDigits === 0) {
                shouldReplace = true;
            }

            var isdecimal = false;

            var separatoroffset = hasSeparator ? 1 : 0;

            if (!shouldReplace && this.ValueString && this.ValueString.length >= this.digits + this.decimalDigits + separatoroffset) {
                return;
            }

            if (shouldReplace && valueChar != separatorChar) {
                if (isdecimal)
                    position++;

                var before = value.substring(0, position);
                if (before.length == value.length) {
                    if (this.ValueString.length >= this.digits + this.decimalDigits + separatoroffset)
                        return;
                }

                var current = digit;
                var after = "";

                if (position + 1 < value.length) {
                    after = value.substring(position + 1);
                }

                var result = before + current + after;
                this.ValueString = result;
            }
            else {
                var before = value.substring(0, position);
                var current = digit;
                var after = value.substring(position);
                var result = before + current + after;

                if (value.substring(0, 1) == '0' && value.substring(1, 2) == separatorChar) {
                    result = current + value.substring(1);
                    if (valueChar == separatorChar) {
                        this._setSelectionStart(selection.start - 1);
                        selection = this._selection();
                    }
                }
                this.ValueString = result;
            }

            if (isNegative) {
                this.decimal = "-" + this.ValueString;
            }
            else this.decimal = this.ValueString;

            this._parseDecimalInSimpleMode();
            var start = selection.start;
            start += 1;

            this._setSelectionStart(start);

            this.value = this.decimal;

            this._raiseEvent(0, this.value);
            this._raiseEvent(1, this.numberInput.val());
        },

        GetStringToSeparator: function (text, separator, hasSeparator) {
            var res = "";
            var pointSeparator = separator;
            var separatorInText = this.GetSeparatorPositionInText(separator, text);
            var newString = text.subString(0, separatorInText);
            res = this.GetValueString(newString, separator, hasSeparator);

            return res;
        },

        GetSeparatorPositionInText: function (separator, text) {
            var decimalPointPos = -1;

            for (var i = 0; i < text.length; i++) {
                if (text.substring(i, i + 1) == separator) {
                    decimalPointPos = i;
                    break;
                }
            }
            return decimalPointPos;
        },

        GetValueString: function (text, separator, hasSeparator) {
            var res = "";

            for (var i = 0; i < text.length; i++) {
                var literal = text.substring(i, i + 1);
                var isDigit = (!isNaN(parseInt(literal)));
                if (isDigit) {
                    res += literal;
                }
                if (literal == separator) {
                    res += separator;
                }
            }

            return res;
        },

        Backspace: function () {
            var selection = this._selection();
            var initialselection = this._selection();
            var text = this.numberInput.val();

            if (selection.start == 0 && selection.length == 0)
                return;

            this.isBackSpace = true;

            var literal = text.substring[selection.start, selection.start + 1];
            var isDigit = (!isNaN(parseInt(literal)));
            if (selection.start > 0 && selection.length == 0) {
                this._setSelectionStart(selection.start - 1);
                var selection = this._selection();
            }

            this.Delete();
            this._setSelectionStart(initialselection.start - 1);
            this.isBackSpace = false;
        },

        Delete: function (deleteWithoutSelection) {
            var selection = this._selection();
            var text = this.numberInput.val();
            if (selection.start === 0 && text.substring(0, 1) == "-") {
                this.setvalue('negative', false);
                var selection = this._selection();
                var text = this.numberInput.val();
            }

            var selectionStart = selection.start;

            if (selection.start > 0 && text.substring(0, 1) == "-") {
                selectionStart--;
                selection.start = selectionStart;
            }

            var selectionLength = selection.length;
            selectionLength = Math.max(selectionLength, 1);

            this.ValueString = this.GetValueString(text, this.decimalSeparator, this.decimalSeparator != '');
            if (selectionStart > this.ValueString.indexOf(this.decimalSeparator) && this.decimalDigits > 0) {
                selectionStart++;
            }
            var offset = 0;
            if (this.symbol) {
                if (this.symbolPosition == "left") {
                    offset--;
                }
                if (this.negative)
                    offset--;
            }
            this.RemoveRange(selection.start + offset, selectionLength, this.ValueString, ".", false);
            var literal = this.ValueString.substring(0, 1);
            var isDigit = (!isNaN(parseInt(literal)));
            if (!isDigit) {
                this.ValueString = '0' + this.ValueString;
            }
            this.decimal = this.ValueString;
            this._parseDecimalInSimpleMode();
            this._setSelectionStart(selectionStart);
            this.value = this.decimal;
            this._raiseEvent(0, this.value);
            this._raiseEvent(1, this.numberInput.val());
        },

        insertsimple: function (insertion) {
            var selection = this._selection();
            var text = this.numberInput.val();

            if (selection.start == text.length && this.decimal != null && this.decimalDigits > 0)
                return;

            var oldValue = this.decimal;

            var separatorChar = this.decimalSeparator;
            this.ValueString = this.GetValueString(text, separatorChar, separatorChar != '');

            var positionInValue = this.GetSelectionInValue(selection.start, text, separatorChar, separatorChar != '');
            var lengthInValue = this.GetSelectionLengthInValue(selection.start, selection.length, text, separatorChar);

            var digitsToSeparator = this.GetDigitsToSeparator(0, this.ValueString, separatorChar);
            var decrementPositionInValue = false;

            if (this.decimalDigits > 0 && positionInValue >= this.ValueString.length) {
                positionInValue--;
            }

            if (this.ValueString == "") {
                this.ValueString = new Number(0).toFixed(this.decimalDigits);
                this.ValueString = this.ValueString.replace(".", separatorChar);
                this.RemoveRange(selection.start, lengthInValue, this.ValueString, separatorChar, false, true);
                this.InsertDigit(insertion, 0, selection);
                return;
            }

            this.RemoveRange(selection.start, lengthInValue, this.ValueString, separatorChar, false, true);
            this.InsertDigit(insertion, positionInValue, selection);
        },

        GetDigitsToSeparator: function (digitsToSeparator, valueString, separator) {
            if (separator == undefined) separator = '.';

            if (valueString.indexOf(separator) < 0) {
                return valueString.length;
            }

            for (var i = 0; i < valueString.length; i++) {
                if (valueString.substring(i, i + 1) == separator) {
                    digitsToSeparator = i;
                    break;
                }
            }
            return digitsToSeparator;
        },

        _handleSimpleKeyDown: function (e, key) {
            var selection = this._selection();
            var ctrlKey = e.ctrlKey || e.metaKey;

            if ((key == 8 || key == 46) && ctrlKey) {
                this.setDecimal(null);
                return false;
            }

            if (selection.start >= 0 && selection.start < this.items.length) {
                var letter = String.fromCharCode(key);
            }

            if (key === 27) {
                this.setDecimal(this._savedValue);
                var position = this.GetSeparatorPositionInText(this.decimalSeparator, this.numberInput.val());
                if (position != -1) {
                    this._setSelectionStart(position);
                }

                e.preventDefault();
            }

            if (this.rtl && key == 37) {
                var shift = e.shiftKey;
                var offset = shift ? 1 : 0;
                if (shift) {
                    this._setSelection(selection.start + 1 - offset, selection.start + selection.length + 1);
                }
                else {
                    this._setSelection(selection.start + 1 - offset, selection.start + 1);
                }

                return false;
            }
            else if (this.rtl && key == 39) {
                var shift = e.shiftKey;
                var offset = shift ? 1 : 0;
                if (shift) {
                    this._setSelection(selection.start - 1, selection.length + offset + selection.start - 1);
                }
                else {
                    this._setSelection(selection.start - 1, selection.start - 1);
                }
                return false;
            }

            // handle backspace.
            if (key == 8) {
                this.Backspace();
                return false;
            }

            if (key == 190 || key == 110) {
                var position = this.GetSeparatorPositionInText(this.decimalSeparator, this.numberInput.val());
                if (position != -1) {
                    this._setSelectionStart(position + 1);
                }
                return false;
            }

            if (key == 188 && this.groupSeparator === ',') {
                var value = this.numberInput.val();
                for (i = selection.start; i < value.length; i++) {
                    if (value[i] == this.groupSeparator) {
                        this._setSelectionStart(1 + i);
                        break;
                    }
                }

                return false;
            }

            // allow Ctrl+C (copy)
            var ctrlKey = e.ctrlKey || e.metaKey;
            if ((ctrlKey && key == 99 /* firefox */) || (ctrlKey && key == 67) /* opera */) {
                var selection = this._selection();
                var text = "";
                var input = this.numberInput.val();
                if (selection.start > 0 || selection.length > 0) {
                    for (var i = selection.start; i < selection.end; i++) {
                        text += input.substring(i, i + 1);
                    }
                }
                $.data(document.body, "jqxSelection", text);
                if ($.jqx.browser.msie) {
                    window.clipboardData.setData("Text", text);
                }
                else {
                    var me = this;
                    var copyFrom = $('<textarea style="position: absolute; left: -1000px; top: -1000px;"/>');
                    copyFrom.val(text);
                    $('body').append(copyFrom);
                    copyFrom.select();
                    setTimeout(function () {
                        document.designMode = 'off';
                        copyFrom.select();
                        copyFrom.remove();
                        me.focus();
                    }, 100);
                }
                this.savedText = text;
                return true;
            }
            // allow Ctrl+Z (undo)
            if ((ctrlKey && key == 122 /* firefox */) || (ctrlKey && key == 90) /* opera */) return false;
            // allow or deny Ctrl+V (paste), Shift+Ins
            if ((ctrlKey && key == 118 /* firefox */) || (ctrlKey && key == 86) /* opera */
                || (e.shiftKey && key == 45)) {
                if ($.jqx.browser.msie && !this.savedText) {
                    this.savedText = window.clipboardData.getData("Text");
                }
                if (this.savedText != null && this.savedText.length > 0) {
                    this.val(this.savedText);
                    //for (var i = 0; i < this.savedText.length; i++) {
                    //    var digit = parseInt(this.savedText.substring(i, i + 1));
                    //    if (!isNaN(digit)) {
                    //        this.insertsimple(digit);
                    //    }
                    //}
                }
                else {
                    this.val($.data(document.body, "jqxSelection"));
                }
                return false;
            }

            var letter = String.fromCharCode(key);
            var digit = parseInt(letter);
            if (key >= 96 && key <= 105) {
                digit = key - 96;
                key = key - 48;
            }

            if (!isNaN(digit)) {
                var me = this;
                this.insertsimple(digit);

                return false;
            }


            // handle del.
            if (key == 46) {
                this.Delete();
                return false;
            }

            if (key == 38) {
                this.spinUp();
                return false;
            }
            else if (key == 40) {
                this.spinDown();
                return false;
            }

            var specialKey = this._isSpecialKey(key);

            if (!$.jqx.browser.mozilla)
                return true;

            return specialKey;
        },

        //[optimize]
        _getEditRange: function () {
            var start = 0;
            var end = 0;

            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].canEdit) {
                    start = i;
                    break;
                }
            }

            for (i = this.items.length - 1; i >= 0; i--) {
                if (this.items[i].canEdit) {
                    end = i;
                    break;
                }
            }

            return { start: start, end: end }
        },

        //[optimize]
        _getVisibleItems: function () {
            var visibleItems = new Array();
            var k = 0;
            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].character.toString().length > 0) {
                    visibleItems[k] = this.items[i];
                    k++;
                }
            }

            return visibleItems;
        },

        //[optimize]
        _hasEmptyVisibleItems: function () {
            var visibleItems = this._getVisibleItems();
            for (var i = 0; i < visibleItems.length; i++) {
                if (visibleItems[i].canEdit && visibleItems[i].character == this.promptChar) {
                    return true;
                }
            }

            return false;
        },

        //[optimize]
        _getFirstVisibleNonEmptyIndex: function () {
            var visibleItems = this._getVisibleItems();
            for (var i = 0; i < visibleItems.length; i++) {
                if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                    return i;
                }
            }
        },

        //[optimize]
        _handleMouse: function (e, args) {
            var selection = this._selection();
            if (selection.length <= 1) {
                var firstItemIndex = this._getFirstVisibleNonEmptyIndex();
                if (selection.start < firstItemIndex) {
                    this._setSelectionStart(firstItemIndex);
                }
            }
        },

        _insertKey: function (key) {
            this.numberInput[0].focus();
            var letter = String.fromCharCode(key);
            var charDigit = parseInt(letter);
            if (isNaN(charDigit))
                return;

            var emptyDigits = 0;
            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].character.length == 0) {
                    emptyDigits++;
                }
            }

            var selection = this._selection();

            var rootElement = this;
            if (selection.start >= 0 && selection.start <= this.items.length) {
                var selectedTextDeleted = false
                var firstItemIndex = this._getFirstVisibleNonEmptyIndex();
                if (selection.start < firstItemIndex && selection.length == 0) {
                    if (!isNaN(letter) || letter == ' ') {
                        this._setSelectionStart(firstItemIndex);
                        selection = this._selection();
                    }
                }

                var firstEditableIndex = this._getFirstEditableItemIndex();
                var lastEditableIndex = this._getLastEditableItemIndex();

                if (this.value === null) {
                    firstEditableIndex = lastEditableIndex = 0;
                }

                var visibleItems = this._getVisibleItems();
                $.each(visibleItems, function (i, value) {
                    if (selection.start > i && i != visibleItems.length - 1)
                        return;

                    var item = visibleItems[i];
                    if (i > lastEditableIndex) {
                        item = visibleItems[lastEditableIndex];
                    }

                    if (isNaN(letter) || letter == ' ' || letter == '' || !item)
                        return;

                    if (!item.canEdit) {
                        return;
                    }
                    var separatorPosition = rootElement._getSeparatorPosition();

                    if (rootElement._match(letter, item.regex)) {
                        if (!selectedTextDeleted && selection.length > 0) {
                            for (var j = selection.start + emptyDigits; j < selection.end + emptyDigits; j++) {
                                if (rootElement.items[j].canEdit) {
                                    if (j > separatorPosition) {
                                        rootElement.items[j].character = '0';
                                    }
                                    else {
                                        rootElement.items[j].character = rootElement.promptChar;
                                    }
                                }
                            }

                            var text = rootElement._getString();
                            //           rootElement.inputValue(text);
                            selectedTextDeleted = true;
                        }

                        var separatorPosition = rootElement._getSeparatorPosition();
                        var hasEmptyItems = rootElement._hasEmptyVisibleItems();
                        if (rootElement.decimal == null) {
                            selection.start = separatorPosition - 1;
                            if (selection.start < 0)
                                selection.start = 0;
                            selection.end = selection.start;
                        }

                        if (selection.start <= separatorPosition && hasEmptyItems) {
                            var limit = i;
                            if (rootElement.decimalSeparatorPosition == -1 && selection.start == separatorPosition) {
                                limit = i + 1;
                            }
                            if (rootElement.decimal == null) {
                                limit = selection.start;
                            }

                            var numberString = "";
                            for (var p = 0; p < limit; p++) {
                                if (visibleItems[p].canEdit && visibleItems[p].character != rootElement.promptChar) {
                                    numberString += visibleItems[p].character;
                                }
                            }

                            numberString += letter;
                            var offset = rootElement.decimal < 1 ? 1 : 0;

                            if (selection.start == separatorPosition && rootElement.decimalSeparatorPosition != -1) {
                                numberString += rootElement.decimalSeparator;
                                offset = 0;
                            }


                            for (var p = limit + offset; p < visibleItems.length; p++) {
                                if (visibleItems[p].character == rootElement.decimalSeparator && visibleItems[p].isSeparator) {
                                    numberString += visibleItems[p].character;
                                }
                                else if (visibleItems[p].canEdit && visibleItems[p].character != rootElement.promptChar) {
                                    numberString += visibleItems[p].character;
                                }
                            }

                            if (rootElement.decimalSeparator != '.') {
                                numberString = rootElement._parseDecimalValue(numberString);
                            }

                            numberString = parseFloat(numberString).toString();
                            numberString = new Number(numberString);
                            numberString = numberString.toFixed(rootElement.decimalDigits);
                            if (rootElement.decimalSeparator != '.') {
                                numberString = rootElement._parseDecimalValueToEditorValue(numberString);
                            }

                            rootElement.setvalue('decimal', numberString);

                            var text = rootElement._getString();

                            if (selection.end < separatorPosition) {
                                rootElement._setSelectionStart(selection.end + offset);
                            }
                            else {
                                rootElement._setSelectionStart(selection.end);
                            }

                            if (selection.length >= 1) {
                                rootElement._setSelectionStart(selection.end);
                            }

                            if (selection.length == rootElement.numberInput.val().length) {
                                var selectBeforeSeparator = rootElement._moveCaretToDecimalSeparator();
                                var separatorOffset = rootElement.decimalSeparatorPosition >= 0 ? 1 : 0;
                                rootElement._setSelectionStart(selectBeforeSeparator - separatorOffset);
                            }
                        }
                        else {
                            if (selection.start < separatorPosition || selection.start > separatorPosition) {
                                if (rootElement.numberInput.val().length == selection.start && rootElement.decimalSeparatorPosition != -1) {
                                    return false;
                                }
                                else if (rootElement.numberInput.val().length == selection.start && rootElement.decimalSeparatorPosition == -1 && !hasEmptyItems) {
                                    return false;
                                }

                                var numberString = "";
                                var addedSeparator = false;
                                for (var p = 0; p < i; p++) {
                                    if (visibleItems[p].canEdit && visibleItems[p].character != rootElement.promptChar) {
                                        numberString += visibleItems[p].character;
                                    }
                                    if (visibleItems[p].character == rootElement.decimalSeparator && visibleItems[p].isSeparator) {
                                        numberString += visibleItems[p].character;
                                        addedSeparator = true;
                                    }
                                }

                                numberString += letter;
                                var offset = rootElement.decimal < 1 ? 1 : 0;

                                if (!addedSeparator && selection.start == separatorPosition - 1) {
                                    numberString += rootElement.decimalSeparator;
                                    addedSeparator = true;
                                }

                                for (var p = i + 1; p < visibleItems.length; p++) {
                                    if (!addedSeparator && visibleItems[p].character == rootElement.decimalSeparator && visibleItems[p].isSeparator) {
                                        numberString += visibleItems[p].character;
                                    }
                                    else if (visibleItems[p].canEdit && visibleItems[p].character != rootElement.promptChar) {
                                        numberString += visibleItems[p].character;
                                    }
                                }

                                rootElement.setvalue('decimal', numberString);

                                var text = rootElement._getString();

                                if (rootElement.decimalSeparatorPosition < 0 && item == visibleItems[lastEditableIndex]) {
                                    rootElement._setSelectionStart(i);

                                    return false;
                                }

                                var symbolstartposition = text.indexOf(rootElement.symbol);
                                var sel = !rootElement.getvalue('negative') ? 0 : 1;
                                if (symbolstartposition <= sel) symbolstartposition = text.length;

                                // Do not move caret, if it's after the symbol.
                                if (selection.start < symbolstartposition) {
                                    rootElement._setSelectionStart(i + 1);
                                }
                                else rootElement._setSelectionStart(i);

                                if (selection.length >= 1) {
                                    //             rootElement._setSelectionStart(selection.end);
                                }

                                if (selection.length == rootElement.numberInput.val().length) {
                                    var selectBeforeSeparator = rootElement._moveCaretToDecimalSeparator();
                                    rootElement._setSelectionStart(selectBeforeSeparator - 1);
                                }
                            }
                        }
                        return false;
                    }
                });
            }
        },

        //[optimize]
        _handleKeyPress: function (e, key) {
            var selection = this._selection();
            var rootElement = this;
            var ctrlKey = e.ctrlKey || e.metaKey;
            if ((ctrlKey && key == 97 /* firefox */) || (ctrlKey && key == 65) /* opera */) {
                return true;
            }

            if (key == 8) {
                if (selection.start > 0) {
                    rootElement._setSelectionStart(selection.start);
                }
                return false;
            }

            if (key == 46) {
                if (selection.start < this.items.length) {
                    rootElement._setSelectionStart(selection.start);
                }

                return false;
            }

            if (!$.jqx.browser.mozilla) {
                if (key == 45 || key == 173 || key == 109 || key == 189) {
                    var isNegative = this.getvalue('negative');
                    if (isNegative == false) {
                        this.setvalue('negative', true);
                    }
                    else {
                        this.setvalue('negative', false);
                    }
                }
            }

            if ($.jqx.browser.msie) {
                this._insertKey(key);
            }

            var specialKey = this._isSpecialKey(key);
            return specialKey;
        },

        //[optimize]
        _deleteSelectedText: function () {
            var selection = this._selection();
            var decimalString = "";
            var separatorPosition = this._getSeparatorPosition();
            var visibleItems = this._getVisibleItems();
            var prefix = this._getHiddenPrefixCount();

            if (this.numberInput.val().length == selection.start && selection.length == 0) {
                this._setSelection(selection.start, selection.start + 1);
                selection = this._selection();
            }

            for (var i = 0; i < selection.start; i++) {
                if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                    decimalString += visibleItems[i].character;
                }
                else if (!visibleItems[i].canEdit && this.decimalSeparatorPosition != -1 && visibleItems[i] == visibleItems[this.decimalSeparatorPosition - prefix]) {
                    if (decimalString.length == 0) {
                        decimalString = "0";
                    }

                    decimalString += visibleItems[i].character;
                }
            }

            for (var i = selection.start; i < selection.end; i++) {
                if (i > separatorPosition && this.decimalSeparatorPosition != -1) {
                    if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                        decimalString += "0";
                    }
                }
                else if (!visibleItems[i].canEdit && this.decimalSeparatorPosition != -1 && visibleItems[i] == visibleItems[this.decimalSeparatorPosition - prefix]) {
                    if (decimalString.length == 0) {
                        decimalString = "0";
                    }

                    decimalString += visibleItems[i].character;
                }
            }

            for (var i = selection.end; i < visibleItems.length; i++) {
                if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                    decimalString += visibleItems[i].character;
                }
                else if (!visibleItems[i].canEdit && this.decimalSeparatorPosition != -1 && visibleItems[i] == visibleItems[this.decimalSeparatorPosition - prefix]) {
                    if (decimalString.length == 0) {
                        decimalString = "0";
                    }

                    decimalString += visibleItems[i].character;
                }
            }

            this.setvalue('decimal', decimalString);
            return selection.length > 0;
        },

        _restoreInitialState: function () {
            var suffix = parseInt(this.decimalDigits);

            // add the first digit + the decimal separator.
            if (suffix > 0) {
                suffix += 2;
            }

            for (var k = this.items.length - 1; k > this.items.length - 1 - suffix; k--) {
                if (!this.items[k]) {
                    break;
                }

                if (this.items[k].canEdit && this.items[k].character == this.promptChar) {
                    this.items[k].character = 0;
                }
            }
        },

        clear: function () {
            this.setDecimal(0);
        },

        // clears the decimal value.
        clearDecimal: function () {
            if (this.inputMode == 'textbox') {
                this.numberInput.val();
                return;
            }

            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].canEdit) {
                    this.items[i].character = this.promptChar;
                }
            }

            this._restoreInitialState();
        },

        //[optimize]
        _saveSelectedText: function () {
            var selection = this._selection();
            var text = "";
            var visibleItems = this._getVisibleItems();

            if (selection.start > 0 || selection.length > 0) {
                for (var i = selection.start; i < selection.end; i++) {
                    if (visibleItems[i].canEdit && visibleItems[i].character != this.promptChar) {
                        text += visibleItems[i].character;
                    }
                    else if (visibleItems[i].isSeparator) {
                        text += visibleItems[i].character;
                    }
                }
            }
            if ($.jqx.browser.msie) {
                window.clipboardData.setData("Text", text);
            }

            return text;
        },

        _pasteSelectedText: function () {
            var selection = this._selection();
            var text = "";
            var k = 0;

            this.selectedText = $.data(document.body, "jqxSelection");
            if (window.clipboardData) {
                var clipboardText = window.clipboardData.getData("Text");
                if (clipboardText != this.selectedText && clipboardText.length > 0) {
                    this.selectedText = window.clipboardData.getData("Text");
                    if (this.selectedText == null || this.selectedText == undefined)
                        return;
                }
            }
            var newSelection = selection.start;
            var visibleItems = this._getVisibleItems();
            if (this.selectedText != null) {
                for (var t = 0; t < this.selectedText.length; t++) {
                    var number = parseInt(this.selectedText[t]);
                    if (!isNaN(number)) {
                        var numberCode = 48 + number;
                        this._insertKey(numberCode);
                    }
                }
            }
        },

        _getHiddenPrefixCount: function () {
            var length = 0;

            if (!this.negative) {
                length++;
            }

            if (this.symbolPosition == "left") {
                for (var i = 0; i < this.symbol.length; i++) {
                    if (this.symbol.substring(i, i + 1) == '') {
                        length++;
                    }
                }
            }
            return length;
        },

        //[optimize]
        _getEditableItem: function () {
            var selection = this._selection();

            for (var i = 0; i < this.items.length; i++) {
                if (i < selection.start) {
                    if (this.items[i].canEdit && this.items[i].character != this.promptChar) {
                        return this.items[i];
                    }
                }
            }

            return null;
        },

        //[optimize]
        _getEditableItems: function () {
            var editableItems = new Array();
            var k = 0;

            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i].canEdit) {
                    editableItems[k] = this.items[i];
                    k++;
                }
            }

            return editableItems;
        },

        //[optimize]
        _getValidSelectionStart: function (selectionStart) {
            for (var i = this.items.length - 1; i >= 0; i--) {
                if (this.items[i].canEdit && this.items[i].character != this.promptChar) {
                    return i;
                }
            }

            return -1;
        },

        //[optimize]
        _getEditableItemIndex: function (afterCaret) {
            var selection = this._selection();
            var prefix = this._getHiddenPrefixCount();
            var visibleItems = this._getVisibleItems();

            var index = selection.start;
            var editableIndex = -1;
            for (var i = 0; i < index; i++) {
                if (i < visibleItems.length && visibleItems[i].canEdit) {
                    editableIndex = i + prefix;
                }
            }

            if (editableIndex == -1 && selection.length > 0) {
                index = selection.end;
                for (i = 0; i < index; i++) {
                    if (i < visibleItems.length && visibleItems[i].canEdit) {
                        editableIndex = i + prefix;
                        break;
                    }
                }
            }

            return editableIndex;
        },

        //[optimize]
        _getEditableItemByIndex: function (index) {
            for (var k = 0; k < this.items.length; k++) {
                if (k > index) {
                    if (this.items[k].canEdit && this.items[k].character != this.promptChar) {
                        return k;
                    }
                }
            }

            return -1;
        },

        //[optimize]
        _getFirstEditableItemIndex: function () {
            var visibleItems = this._getVisibleItems();
            for (var m = 0; m < visibleItems.length; m++) {
                if (visibleItems[m].character != this.promptChar && visibleItems[m].canEdit && visibleItems[m].character != '0')
                    return m;
            }

            return -1;
        },

        //[optimize]
        _getLastEditableItemIndex: function () {
            var visibleItems = this._getVisibleItems();
            for (var m = visibleItems.length - 1; m >= 0; m--) {
                if (visibleItems[m].character != this.promptChar && visibleItems[m].canEdit)
                    return m;
            }

            return -1;
        },

        //[optimize]
        _moveCaretToDecimalSeparator: function () {
            for (var i = this.items.length - 1; i >= 0; i--) {
                if (this.items[i].character == this.decimalSeparator && this.items[i].isSeparator) {
                    if (!this.negative) {
                        this._setSelectionStart(i);
                        return i;
                    }
                    else {
                        this._setSelectionStart(i + 1);
                        return i;
                    }
                    break;
                }
            }

            return this.numberInput.val().length;
        },

        //[optimize]
        _handleBackspace: function () {
            var selection = this._selection();
            var prefix = this._getHiddenPrefixCount();
            var editableItemIndex = this._getEditableItemIndex() - prefix;
            var firstItemIndex = this._getFirstVisibleNonEmptyIndex();
            var negative = false;
            if (this.negative) {
                negative = true;
                if (firstItemIndex >= editableItemIndex + 1 || selection.start == 0) {
                    this.setvalue("negative", false);
                    if (selection.length == 0) {
                        this._setSelectionStart(selection.start - 1);
                        var selection = this._selection();
                    }
                }
            }

            if (editableItemIndex >= 0) {
                if (selection.length == 0 && editableItemIndex != -1) {
                    this._setSelection(editableItemIndex, editableItemIndex + 1);
                }

                var deleteAfterSeparator = selection.start > this._getSeparatorPosition() + 1 && this.decimalSeparatorPosition > 0;
                if (deleteAfterSeparator) {
                    selection = this._selection();
                }

                var deletedText = this._deleteSelectedText();
                if (selection.length < 1 || deleteAfterSeparator) {
                    this._setSelectionStart(selection.start);
                }
                else if (selection.length >= 1) {
                    this._setSelectionStart(selection.end);
                }

                if (selection.length == this.numberInput.val().length || negative) {
                    var selectBeforeSeparator = this._moveCaretToDecimalSeparator();
                    this._setSelectionStart(selectBeforeSeparator - 1);
                    if (negative) {
                        this._setSelectionStart(selection.start);
                    }
                }
            }
            else {
                this._setSelectionStart(selection.start);
            }
        },

        //[optimize]
        _handleKeyDown: function (e, key) {
            var selection = this._selection();
            var ctrlKey = e.ctrlKey || e.metaKey;

            if ((key == 8 || key == 46) && ctrlKey) {
                this.setDecimal(null);
                return false;
            }

            if (this.rtl && key == 37) {
                var shift = e.shiftKey;
                var offset = shift ? 1 : 0;
                if (shift) {
                    this._setSelection(selection.start + 1 - offset, selection.start + selection.length + 1);
                }
                else {
                    this._setSelection(selection.start + 1 - offset, selection.start + 1);
                }

                return false;
            }
            else if (this.rtl && key == 39) {
                var shift = e.shiftKey;
                var offset = shift ? 1 : 0;
                if (shift) {
                    this._setSelection(selection.start - 1, selection.length + offset + selection.start - 1);
                }
                else {
                    this._setSelection(selection.start - 1, selection.start - 1);
                }
                return false;
            }

            if ((ctrlKey && key == 97 /* firefox */) || (ctrlKey && key == 65) /* opera */) {
                return true;
            } // allow Ctrl+X (cut)
            if ((ctrlKey && key == 120 /* firefox */) || (ctrlKey && key == 88) /* opera */) {
                this.selectedText = this._saveSelectedText(e);
                $.data(document.body, "jqxSelection", this.selectedText);
                this._handleBackspace();
                return false;
            }
            // allow Ctrl+C (copy)
            if ((ctrlKey && key == 99 /* firefox */) || (ctrlKey && key == 67) /* opera */) {
                this.selectedText = this._saveSelectedText(e);
                $.data(document.body, "jqxSelection", this.selectedText);
                return false;
            }
            // allow Ctrl+Z (undo)
            if ((ctrlKey && key == 122 /* firefox */) || (ctrlKey && key == 90) /* opera */) return false;
            // allow or deny Ctrl+V (paste), Shift+Ins
            if ((ctrlKey && key == 118 /* firefox */) || (ctrlKey && key == 86) /* opera */
                || (e.shiftKey && key == 45)) {
                this._pasteSelectedText();
                return false;
            }
            if (selection.start >= 0 && selection.start < this.items.length) {
                var letter = String.fromCharCode(key);
                var item = this.items[selection.start];
            }

            // handle backspace.
            if (key == 8) {
                this._handleBackspace();
                return false;
            }

            if (key == 190 || key == 110) {
                this._moveCaretToDecimalSeparator();
                return false;
            }

            if (key === 188 && this.decimalSeparator === ',') {
                this._moveCaretToDecimalSeparator();
                return false;
            }

            if (key == 188 && this.groupSeparator === ',') {
                var value = this.numberInput.val();
                for (var i = selection.start; i < value.length; i++) {
                    if (value[i] == this.groupSeparator) {
                        this._setSelectionStart(1 + i);
                        break;
                    }
                }

                return false;
            }

            if ($.jqx.browser.msie == null) {
                var letter = String.fromCharCode(key);
                var digit = parseInt(letter);
                if (key >= 96 && key <= 105) {
                    digit = key - 96;
                    key = key - 48;
                }

                if (!isNaN(digit)) {
                    var me = this;
                    me._insertKey(key);
                    return false;
                }
            }

            // handle del.
            if (key == 46) {
                var visibleItems = this._getVisibleItems();
                if (selection.start < visibleItems.length) {
                    var offset = visibleItems[selection.start].canEdit == false ? 2 : 1;
                    if (selection.start == 0) {
                        if (this.negative) {
                            this.setvalue("negative", false);
                            if (selection.length == 0) {
                                this._setSelectionStart(0);
                            }
                            var selection = this._selection();
                            if (selection.length == 0) {
                                return false;
                            }
                        }
                    }

                    if (selection.length == 0) {
                        this._setSelection(selection.start + offset, selection.start + offset + selection.length);
                    }

                    this._handleBackspace();

                    if (new Number(this.decimal) < 1 || selection.start > this._getSeparatorPosition()) {
                        this._setSelectionStart(selection.end + offset);
                    }
                    else if (selection.start + 1 < this.decimalSeparatorPosition) {
                        this._setSelectionStart(selection.end + offset);
                    }
                }
                return false;
            }

            if (key == 38) {
                this.spinUp();
                return false;
            }
            else if (key == 40) {
                this.spinDown();
                return false;
            }

            if (key === 27) {
                this.setDecimal(this._savedValue);
                this._setSelectionStart(selection.end);

                e.preventDefault();
            }

            var specialKey = this._isSpecialKey(key);

            if ($.jqx.browser.mozilla) {
                if (key == 45 || key == 173 || key == 109 || key == 189) {
                    var isNegative = this.getvalue('negative');
                    if (isNegative == false) {
                        this.setvalue('negative', true);
                    }
                    else {
                        this.setvalue('negative', false);
                    }
                }
            }

            if (!$.jqx.browser.mozilla)
                return true;

            return specialKey;
        },

        _isSpecialKey: function (key) {
            if (key != 8 /* backspace */ &&
                key != 9 /* tab */ &&
                key != 13 /* enter */ &&
                key != 35 /* end */ &&
                key != 36 /* home */ &&
                key != 37 /* left */ &&
                key != 39 /* right */ &&
                key != 27 /* right */ &&
                key != 46 /* del */
            ) {
                return false;
            }

            return true;
        },

        //[optimize]
        _selection: function () {
            try {
                if ('selectionStart' in this.numberInput[0]) {
                    var e = this.numberInput[0];
                    var selectionLength = e.selectionEnd - e.selectionStart;
                    return { start: e.selectionStart, end: e.selectionEnd, length: selectionLength, text: e.value };
                }
                else {
                    var r = document.selection.createRange();
                    if (r == null) {
                        return { start: 0, end: e.value.length, length: 0 }
                    }

                    var re = this.numberInput[0].createTextRange();
                    var rc = re.duplicate();
                    re.moveToBookmark(r.getBookmark());
                    rc.setEndPoint('EndToStart', re);
                    var selectionLength = r.text.length;

                    return { start: rc.text.length, end: rc.text.length + r.text.length, length: selectionLength, text: r.text };
                }
            }
            catch (error) {
                return { start: 0, end: 0, length: 0 };
            }
        },

        selectAll: function () {
            var textbox = this.numberInput;
            setTimeout(function () {
                if ('selectionStart' in textbox[0]) {
                    textbox[0].focus();
                    textbox[0].setSelectionRange(0, textbox[0].value.length);
                }
                else {
                    var range = textbox[0].createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', textbox[0].value.length);
                    range.moveStart('character', 0);
                    range.select();
                }
            }, 10);
        },

        _setSelection: function (start, end) {
            if (this._disableSetSelection == true) return;
            var isTouchDevice = $.jqx.mobile.isTouchDevice();
            if (isTouchDevice || this.touchMode == true)
                return;

            try {
                if ('selectionStart' in this.numberInput[0]) {
                    this.numberInput[0].focus();
                    this.numberInput[0].setSelectionRange(start, end);
                }
                else {
                    var range = this.numberInput[0].createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', end);
                    range.moveStart('character', start);
                    range.select();
                }
            }
            catch (error) {
            }
        },

        _setSelectionStart: function (start) {
            this._setSelection(start, start);
            $.data(this.numberInput, "selectionstart", start);
        },

        resize: function (width, height) {
            this.width = width;
            this.height = height;
            this._render(false);
        },

        _render: function (refreshValue) {
            var leftBorder = parseInt(this.host.css("border-left-width"));
            var rightBorder = parseInt(this.host.css("border-left-width"));
            var topBorder = parseInt(this.host.css("border-left-width"));
            var bottomBorder = parseInt(this.host.css("border-left-width"));
            this.numberInput.css("padding-top", '0px');
            this.numberInput.css("padding-bottom", '0px');

            var computedStyle = window.getComputedStyle(this.element);
            var borderSize = parseInt(computedStyle.borderLeftWidth) * 2;
            var boxSizing = computedStyle.boxSizing;

            if (boxSizing === 'border-box' || isNaN(borderSize)) {
                borderSize = 0;
            }

            if (this.width != null && this.width.toString().indexOf("px") != -1) {
                this.element.style.width = parseInt(this.width) - borderSize + 'px';
            }
            else if (this.width != undefined && !isNaN(this.width)) {
                this.element.style.width = parseInt(this.width) - borderSize + 'px';
            }

            if (this.height != null && this.height.toString().indexOf("px") != -1) {
                this.element.style.height = parseInt(this.height) - borderSize + 'px';
            }
            else if (this.height != undefined && !isNaN(this.height)) {
                this.element.style.height = parseInt(this.height) - borderSize + 'px';
            };

            var width = this.host.width();
            var height = this.host.height();

            this.numberInput.css({
                "border-left-width": 0,
                "border-right-width": 0,
                "border-bottom-width": 0,
                "border-top-width": 0
            });
            if (isNaN(topBorder))
                topBorder = 1;
            if (isNaN(rightBorder))
                rightBorder = 1;
            if (isNaN(bottomBorder))
                bottomBorder = 1;
            if (isNaN(leftBorder))
                leftBorder = 1;

            this.numberInput.css("text-align", this.textAlign);
            var fontSize = this.numberInput.css("font-size");
            if ("" == fontSize) fontSize = 13;
            this.numberInput.css('height', parseInt(fontSize) + 4 + 'px');
            this.numberInput.css('width', width - 2);

            var top = height - 2 * topBorder - parseInt(fontSize) - 2;
            if (isNaN(top)) top = 0;
            if (top < 0) top = 0;
            if (this.spinButtons && this.spincontainer) {
                width -= parseInt(this.spinButtonsWidth - 2);
                var touchDevice = $.jqx.mobile.isTouchDevice();
                if (!touchDevice && this.touchMode !== true) {
                    this.spincontainer.width(this.spinButtonsWidth);
                    this.upbutton.width(this.spinButtonsWidth + 2);
                    this.downbutton.width(this.spinButtonsWidth + 2);
                    this.upbutton.height('50%');
                    this.downbutton.height('50%');
                    this.spincontainer.width(this.spinButtonsWidth);
                }
                else {
                    this.spincontainer.width(2 * (this.spinButtonsWidth));
                    width -= this.spinButtonsWidth;
                    this.upbutton.height('100%');
                    this.downbutton.height('100%');
                    this.downbutton.css('float', 'left');
                    this.upbutton.css('float', 'right');
                    this.upbutton.width(this.spinButtonsWidth);
                    this.downbutton.width(1 + this.spinButtonsWidth);
                }

                this._upArrow.height('100%');
                this._downArrow.height('100%');
                this.numberInput.css('width', width - 6);
                this.numberInput.css('margin-right', '2px');
            }

            var topPadding = top / 2;

            // fix for MSIE 6 and 7. These browsers double the top padding for some reason...
            if ($.jqx.browser.msie && $.jqx.browser.version < 8) {
                topPadding = top / 4;
            }

            this.numberInput.css("padding-left", '0px');
            this.numberInput.css("padding-right", '0px');
            this.numberInput.css("padding-top", Math.round(topPadding) + 'px');
            this.numberInput.css("padding-bottom", Math.round(topPadding) + 'px');

            if (refreshValue == undefined || refreshValue == true) {
                this.numberInput.val(this._getString())
                if (this.inputMode != 'advanced') {
                    this._parseDecimalInSimpleMode();
                }
            }

            this._addBarAndLabel(this.numberInput);
            this._updateHint();
        },

        _addBarAndLabel: function (host) {
            var that = this;

            if (that.bar !== null || that.label !== null) {
                return;
            }

            var label = $("<label></label");

            if (this.hint) {
                label[0].innerHTML = this.placeHolder;
            }

            label.addClass(that.toThemeProperty('jqx-input-label'));
            host.after(label);
            that.label = label;

            var bar = $("<span></span>");
            host.after(bar);
            bar.addClass(that.toThemeProperty('jqx-input-bar'));

            if (that.spinButtons) {
                bar.css('top', that.host.height());
            }
            else {
                bar.css('top', '0px');
            }
            that.bar = bar;

            if (that.template) {
                that.bar.addClass(that.toThemeProperty("jqx-" + that.template));
                that.label.addClass(that.toThemeProperty("jqx-" + that.template));
            }

        },

        destroy: function () {
            this._removeHandlers();
            this.host.remove();
        },

        // gets or sets the input's text value including the formatting characters.
        inputValue: function (newValue) {
            if (newValue === undefined) {
                return this._value();
            }

            this.propertyChangedHandler(this, "value", this._value, newValue);
            this._refreshValue();
            return this;
        },

        // gets the input's value.
        _value: function () {
            var value = this.numberInput.val();
            return value;
        },

        val: function (decimal) {
            if (decimal !== undefined && typeof decimal != 'object' || decimal === null) {
                if (decimal === null) {
                    this.setDecimal(null);
                    return;
                }
                else {
                    var value = decimal;

                    if (value < 0) {
                        this.setDecimal(value);
                        return;
                    }
                    else {
                        this.setvalue('negative', false);
                    }

                    value = value.toString();
                    if (value.indexOf(this.symbol) > -1) {
                        // remove currency symbol
                        value = value.replace(this.symbol, "");
                    }

                    var replaceAll = function (text, stringToFind, stringToReplace) {
                        var temp = text;
                        if (stringToFind == stringToReplace) return text;

                        var index = temp.indexOf(stringToFind);
                        while (index != -1) {
                            temp = temp.replace(stringToFind, stringToReplace);
                            index = temp.indexOf(stringToFind)
                        }

                        return temp;
                    }

                    value = value.replace(this.decimalSeparator, ".");
                    value = replaceAll(value, this.groupSeparator, "");

                    var val = "";
                    for (var t = 0; t < value.length; t++) {
                        var ch = value.substring(t, t + 1);
                        if (ch === "-") val += "-";
                        if (ch === ".") val += ".";
                        if (ch.match(/^[0-9]+$/) != null) {
                            val += ch;
                        }
                    }

                    value = val;
                    value = value.replace(/ /g, "");
                    value = value.replace('.', this.decimalSeparator);

                    this._setDecimal(value);
                }
            }
            else return this.getDecimal();
        },

        getDecimal: function () {
            if (this.decimal == null)
                return null;

            if (this.inputMode == 'simple') {
                this._parseDecimalInSimpleMode(false);
                this.decimal = this._getDecimalInSimpleMode(this.decimal);
            }

            if (this.decimal == "") return 0;

            var isNegative = this.getvalue('negative');
            if (isNegative && this.decimal > 0) {
                return -parseFloat(this.decimal);
            }

            return parseFloat(this.decimal);
        },

        setDecimal: function (value) {
            var currentValue = value;
            if (this.decimalSeparator != '.') {
                if (value === null) {
                    this._setDecimal(value);
                }
                else {
                    var decimalValue = value;
                    if (typeof (value) != "number") {
                        value = value.toString();
                        var separatorIndex = value.indexOf('.');
                        if (separatorIndex != -1) {
                            var prefix = value.substring(0, separatorIndex);
                            var suffix = value.substring(separatorIndex + 1);
                            decimalValue = prefix + "." + suffix;
                            if (prefix.indexOf('-') != -1)
                                prefix = prefix.substring(1);

                            if (this.inputMode != "advanced")
                                value = prefix + "." + suffix;
                            else
                                value = prefix + this.decimalSeparator + suffix;
                        }
                        else {
                            var separatorIndex = value.indexOf(this.decimalSeparator);
                            if (separatorIndex != -1) {
                                var prefix = value.substring(0, separatorIndex);
                                var suffix = value.substring(separatorIndex + 1);
                                decimalValue = prefix + "." + suffix;
                                if (prefix.indexOf('-') != -1)
                                    prefix = prefix.substring(1);
                                if (this.inputMode != "advanced")
                                    value = prefix + "." + suffix;
                                else
                                    value = prefix + this.decimalSeparator + suffix;
                            }
                        }
                    }

                    if (decimalValue < 0)
                        this.setvalue('negative', true);
                    else {
                        this.setvalue('negative', false);
                    }

                    if (value === null) {
                        this._setDecimal(value);
                    }
                    else {
                        this._setDecimal(Math.abs(value));
                    }
                }
            }
            else {
                if (value < 0)
                    this.setvalue('negative', true);
                else {
                    this.setvalue('negative', false);
                }
                if (value === null) {
                    this._setDecimal(value);
                }
                else {
                    this._setDecimal(Math.abs(value));
                }
            }

            if (currentValue == null) {
                this.numberInput.val("");
            }

            this._updateHint();
        },

        // sets the input's decimal value.
        _setDecimal: function (value) {
            if (!this.allowNull && value == null) {
                this.decimal = 0;
                value = 0;
            }

            if (value == null) {
                this.decimal = null;
                this.value = null;
                this.clearDecimal();
                this._refreshValue();
                this.decimal = null;
                this.value = null;
                this.ValueString = "";
                return;
            }

            if (value.toString().indexOf('e') != -1) {
                value = new Number(value).toFixed(this.decimalDigits).toString();
            }

            this.clearDecimal();
            var decimalString = value.toString();
            var numberPartString = "";
            var decimalPartString = "";
            var addToNumberPart = true;

            if (decimalString.length == 0) {
                decimalString = "0";
            }

            for (var i = 0; i < decimalString.length; i++) {
                if (typeof (value) == "number") {
                    if (decimalString.substring(i, i + 1) == ".") {
                        addToNumberPart = false;
                        continue;
                    }
                }
                else {
                    if (decimalString.substring(i, i + 1) == this.decimalSeparator) {
                        addToNumberPart = false;
                        continue;
                    }
                }
                if (addToNumberPart) {
                    numberPartString += decimalString.substring(i, i + 1);
                }
                else {
                    decimalPartString += decimalString.substring(i, i + 1);
                }
            }

            if (numberPartString.length > 0) {
                numberPartString = parseFloat(numberPartString).toString();
            }

            var digitsBeforeSeparator = this.digits;
            if (digitsBeforeSeparator < numberPartString.length) {
                numberPartString = numberPartString.substr(0, digitsBeforeSeparator);
            }

            var k = 0;
            var separatorPosition = this._getSeparatorPosition();
            var hiddenTextLength = this._getHiddenPrefixCount();
            separatorPosition = separatorPosition + hiddenTextLength;

            for (var i = separatorPosition; i >= 0; i--) {
                if (i < this.items.length && this.items[i].canEdit) {
                    if (k < numberPartString.length) {
                        this.items[i].character = numberPartString.substring(numberPartString.length - k - 1, numberPartString.length - k);
                        k++;
                    }
                }
            }

            k = 0;
            for (var i = separatorPosition; i < this.items.length; i++) {
                if (this.items[i].canEdit) {
                    if (k < decimalPartString.length) {
                        this.items[i].character = decimalPartString.substring(k, k + 1);
                        k++;
                    }
                }
            }

            this._refreshValue();

            if (this.decimalSeparator == '.') {
                this.ValueString = new Number(value).toFixed(this.decimalDigits);
            }
            else {
                var indx = value.toString().indexOf(this.decimalSeparator);
                if (indx > 0) {
                    var prefix = value.toString().substring(0, indx);
                    var val = prefix + "." + value.toString().substring(indx + 1);
                    this.ValueString = new Number(val).toFixed(this.decimalDigits);
                }
                else {
                    this.ValueString = new Number(value).toFixed(this.decimalDigits);
                }
            }

            if (this.inputMode != 'advanced') {
                this._parseDecimalInSimpleMode();
                this._raiseEvent(1, this.ValueString);
            }
            if (this.inputMode == 'textbox') {
                this.decimal = this.ValueString;
                var isNegative = this.getvalue('negative');
                if (isNegative) {
                    this.decimal = "-" + this.ValueString;
                }
            }

            var value = this.val();
            if (value < this.min || value > this.max) {
                this.host.addClass('jqx-input-invalid');
            }
            else {
                this.host.removeClass('jqx-input-invalid');
            }
            this._updateHint();
        },

        //[optimize]
        _getSeparatorPosition: function () {
            var hiddenTextLength = this._getHiddenPrefixCount();
            if (this.decimalSeparatorPosition > 0)
                return this.decimalSeparatorPosition - hiddenTextLength;

            return this.items.length - hiddenTextLength;
        },

        _setTheme: function () {
            this.host.removeClass();
            this.host.addClass(this.toThemeProperty('jqx-input'));
            this.host.addClass(this.toThemeProperty('jqx-rc-all'));
            this.host.addClass(this.toThemeProperty('jqx-widget'));
            this.host.addClass(this.toThemeProperty('jqx-widget-content'));
            this.host.addClass(this.toThemeProperty('jqx-numberinput'));

            if (this.spinButtons) {
                this.downbutton.removeClass();
                this.upbutton.removeClass();
                this.downbutton.addClass(this.toThemeProperty('jqx-scrollbar-button-state-normal'));
                this.upbutton.addClass(this.toThemeProperty('jqx-scrollbar-button-state-normal'));
                this._upArrow.removeClass();
                this._downArrow.removeClass();
                this._upArrow.addClass(this.toThemeProperty('jqx-icon-arrow-up'));
                this._downArrow.addClass(this.toThemeProperty('jqx-icon-arrow-down'));

            }
            this.numberInput.removeClass();
            this.numberInput.addClass(this.toThemeProperty('jqx-input-content'));
        },

        propertiesChangedHandler: function (object, oldValues, newValues) {
            if (newValues && newValues.width && newValues.height && Object.keys(newValues).length == 2) {
                object._render();
            }
        },

        // sets a property.
        propertyChangedHandler: function (object, key, oldvalue, value) {


            if (object.batchUpdate && object.batchUpdate.width && object.batchUpdate.height && Object.keys(object.batchUpdate).length == 2) {
                return;
            }

            if (key == "template") {
                object.upbutton.removeClass(object.toThemeProperty("jqx-" + object.template))
                object.downbutton.removeClass(object.toThemeProperty("jqx-" + object.template))
                object.upbutton.addClass(object.toThemeProperty("jqx-" + object.template))
                object.downbutton.addClass(object.toThemeProperty("jqx-" + object.template))
            }

            if (key == 'digits' || key == 'groupSize' || key == 'decimalDigits') {
                if (value < 0) {
                    throw new Exception(this.invalidArgumentExceptions[0]);
                }
            }

            if (key == "placeHolder") {
                if (!object.isMaterialized()) {
                    object.numberInput.attr('placeholder', object.placeHolder);
                }
                else if (object.hint) {
                    object.label[0].innerHTML = object.placeHolder;
                }
            }

            if (key === 'theme') {
                $.jqx.utilities.setTheme(oldvalue, value, object.host);
            }

            if (key == "digits") {
                if (value != oldvalue) {
                    object.digits = parseInt(value);
                }
            }

            if (key == "min" || key == "max") {
                $.jqx.aria(object, "aria-value" + key, value.toString());
                object._refreshValue();
            }

            if (key == "decimalDigits") {
                if (value != oldvalue) {
                    object.decimalDigits = parseInt(value);
                }
            }

            if (key == "decimalSeparator" || key == "digits" || key == "symbol" || key == "symbolPosition" || key == "groupSize" || key == "groupSeparator" || key == "decimalDigits" || key == "negativeSymbol") {
                var decimal = object.decimal;

                if (key == 'decimalSeparator' && value == '') {
                    value = ' ';
                }

                if (oldvalue != value) {
                    var selection = object._selection();
                    object.items = new Array();
                    object._initializeLiterals();
                    object.value = object._getString();
                    object._refreshValue();
                    object._setDecimal(decimal);
                }
            }
            if (key == "rtl") {
                if (object.rtl) {
                    if (object.spincontainer) {
                        object.spincontainer.css('float', 'right');
                        object.spincontainer.css('border-right-width', '1px');
                    }
                    object.numberInput.css('float', 'right');
                }
                else {
                    if (object.spincontainer) {
                        object.spincontainer.css('float', 'right');
                        object.spincontainer.css('border-right-width', '1px');
                    }
                    object.numberInput.css('float', 'left');
                }
            }
            if (key == "spinButtons") {
                if (object.spincontainer) {
                    if (!value) {
                        object.spincontainer.css('display', 'none');
                    }
                    else {
                        object.spincontainer.css('display', 'block');
                    }
                    object._render();
                }
                else {
                    object._spinButtons();
                }
            }
            if (key === "touchMode") {
                object.inputMode = 'textbox';
                object.spinMode = 'simple';

                object.render();
            }
            if (key == "negative" && object.inputMode == 'advanced') {
                var selection = object._selection();
                var offset = 0;

                if (value) {
                    object.items[0].character = object.negativeSymbol[0];
                    offset = 1;
                }
                else {
                    object.items[0].character = "";
                    offset = -1;
                }

                object._refreshValue();
                if (object.isInitialized) {
                    object._setSelection(selection.start + offset, selection.end + offset);
                }
            }

            if (key == "decimal") {
                object.value = value;
                object.setDecimal(value);
            }

            if (key === "value") {
                object.value = value;
                object.setDecimal(value);
                object._raiseEvent(1, value);
            }

            if (key == "textAlign") {
                object.textAlign = value;
                object._render();
            }

            if (key == "disabled") {
                object.numberInput.attr("disabled", value);
                if (object.disabled) {
                    object.host.addClass(object.toThemeProperty('jqx-fill-state-disabled'));
                }
                else {
                    object.host.removeClass(object.toThemeProperty('jqx-fill-state-disabled'));
                }
                $.jqx.aria(object, "aria-disabled", value.toString());
            }

            if (key == "readOnly") {
                object.readOnly = value;
            }

            if (key == "promptChar") {
                for (var i = 0; i < object.items.length; i++) {
                    if (object.items[i].character == object.promptChar) {
                        object.items[i].character = value;
                    }
                }

                object.promptChar = value;
            }

            if (key == "width") {
                object.width = value;
                object._render();
            }
            else if (key == "height") {
                object.height = value;
                object._render();
            }
        },

        _value: function () {
            var val = this.value;
            return val;
        },

        _refreshValue: function () {
            var value = this.value;
            var k = 0;

            if (this.inputMode === 'textbox') {
                return;
            }

            this.value = this._getString();
            value = this.value;

            var decimalValue = "";
            for (var i = 0; i < this.items.length; i++) {
                var item = this.items[i];

                if (item.canEdit && item.character != this.promptChar) {
                    decimalValue += item.character;
                }

                if (i == this.decimalSeparatorPosition) {
                    decimalValue += ".";
                }
            }

            this.decimal = decimalValue;

            var hasChange = false;

            if (this.oldValue !== value) {
                this.oldValue = value;
                this._raiseEvent(0, value);
                hasChange = true;
            }

            if (this.inputMode != 'simple') {
                this.numberInput.val(value);
                if (hasChange) {
                    this._raiseEvent(1, value);
                }
            }

            if (value == null) {
                this.numberInput.val("");
            }
        }
    });
})(jqxBaseFramework);
})();



/***/ }),

/***/ 4240:
/***/ (() => {

/* tslint:disable */
/* eslint-disable */
(function(){
	if (typeof document === 'undefined') { 
		return;
	}

(function ($) {
    $.jqx.jqxWidget("jqxScrollBar", "", {});

    $.extend($.jqx._jqxScrollBar.prototype, {

        defineInstance: function () {
            var settings = {
                // Type: Number
                // Default: null
                // Sets the scrollbar height.
                height: null,
                // Type: Number
                // Default: null
                // Sets the scrollbar width.
                width: null,
                // Type: Number
                // Default: false. This means that the scrollbar is horizontally oriented by default.
                // Sets the scrollbar orientation.
                vertical: false,
                // Type: Number
                // Default: 0
                // Sets the minimum scroll value.
                min: 0,
                // Type: Number
                // Default: 0
                // Sets the maximum scroll value.
                max: 1000,
                // Type: Number
                // Default: 0
                // Sets the scroll value. The value can be between min and max.
                value: 0,
                // Type: Number
                // Default: 0
                // Sets the scroll step when any arrow button is clicked.
                step: 10,
                // Type: Number
                // Default: 0
                // Sets the scroll step when the user clicks on the empty scroll space between arrow button and thumb.
                largestep: 50,
                // Type: Number
                // Default: 10
                // sets the thumb's minimum size.
                thumbMinSize: 10,
                // Type: Number
                // Default: 0
                // sets the thumb's size.
                thumbSize: 0,
                // Type: Number or 'auto'
                // Default: 'auto'
                // sets the thumb's drag step.
                thumbStep: 'auto',
                // Type: String
                // Default: 'all'
                // sets the rounded corners string.
                roundedCorners: 'all',
                // Type: Boolean
                // Default: true
                // Sets whether the scroll buttons are visible.
                showButtons: true,
                // Type: Boolean
                // Default: false
                // Sets whether the scrollbar is disabled or not.
                disabled: false,
                // Sets whether the scrollbar is on touch device.
                touchMode: 'auto',
                touchModeStyle: 'auto',
                thumbTouchSize: 0,
                // disable jquery trigger function. It is very slow if you call it on mouse move. This could improve performance.
                _triggervaluechanged: true,
                rtl: false,
                areaDownCapture: false,
                areaUpCapture: false,
                _initialLayout: false,
                offset: 0, reference: 0, velocity: 0, frame: 0, timestamp: 0, ticker: null, amplitude: 0, target: 0

            };
            if (this === $.jqx._jqxScrollBar.prototype) {
                return settings;
            }
            $.extend(true, this, settings);
            return settings;
        },

        createInstance: function (args) {
            this.render();
        }, // createInstance

        render: function () {
            this._mouseup = new Date();
            var self = this;
            var html = "<div id='jqxScrollOuterWrap' style='box-sizing: content-box; width:100%; height: 100%; align:left; border: 0px; valign:top; position: relative;'>" +
                "<div id='jqxScrollWrap' style='box-sizing: content-box; width:100%; height: 100%; left: 0px; top: 0px; align:left; valign:top; position: absolute;'>" +
                "<div id='jqxScrollBtnUp' style='box-sizing: content-box; align:left; valign:top; left: 0px; top: 0px; position: absolute;'><div></div></div>" +
                "<div id='jqxScrollAreaUp' style='box-sizing: content-box; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='jqxScrollThumb' style='box-sizing: content-box; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='jqxScrollAreaDown' style='box-sizing: content-box; align:left; valign:top; left: 0px; top: 0px; position: absolute;'></div>" +
                "<div id='jqxScrollBtnDown' style='box-sizing: content-box; align:left; valign:top; left: 0px; top: 0px; position: absolute;'><div></div></div>" +
                "</div>" +
                "</div>";

            if ($.jqx.utilities && $.jqx.utilities.scrollBarButtonsVisibility == "hidden") {
                this.showButtons = false;
            }

            if (self.WinJS) {
                MSApp.execUnsafeLocalFunction(function () {
                    self.host.html(html);
                });
            }
            else {
                this.element.innerHTML = html;
            }

            if (this.width != undefined && parseInt(this.width) > 0) {
                this.host.width(parseInt(this.width));
            }

            if (this.height != undefined && parseInt(this.height) > 0) {
                this.host.height(parseInt(this.height));
            }
            this.isPercentage = false;
            if (this.width != null && this.width.toString().indexOf("%") != -1) {
                this.host.width(this.width);
                this.isPercentage = true;
            }

            if (this.height != null && this.height.toString().indexOf("%") != -1) {
                this.host.height(this.height);
                this.isPercentage = true;
            }
            if (this.isPercentage) {
                var that = this;
                $.jqx.utilities.resize(this.host, function () {
                    that._arrange();
                }, false);
            }
            this.thumbCapture = false;
            this.scrollOuterWrap = $(this.element.firstChild);
            this.scrollWrap = $(this.scrollOuterWrap[0].firstChild);
            this.btnUp = $(this.scrollWrap[0].firstChild);
            this.areaUp = $(this.btnUp[0].nextSibling);
            this.btnThumb = $(this.areaUp[0].nextSibling);
            this.arrowUp = $(this.btnUp[0].firstChild);
            this.areaDown = $(this.btnThumb[0].nextSibling);
            this.btnDown = $(this.areaDown[0].nextSibling);
            this.arrowDown = $(this.btnDown[0].firstChild);

            var elID = this.element.id;
            this.btnUp[0].id = "jqxScrollBtnUp" + elID;
            this.btnDown[0].id = "jqxScrollBtnDown" + elID;
            this.btnThumb[0].id = "jqxScrollThumb" + elID;
            this.areaUp[0].id = "jqxScrollAreaUp" + elID;
            this.areaDown[0].id = "jqxScrollAreaDown" + elID;
            this.scrollWrap[0].id = "jqxScrollWrap" + elID;
            this.scrollOuterWrap[0].id = "jqxScrollOuterWrap" + elID;

            if (!this.host.jqxRepeatButton) {
                throw new Error('jqxScrollBar: Missing reference to jqxbuttons.js.');
                return;
            }

            this.btnUp.jqxRepeatButton({ _ariaDisabled: true, overrideTheme: true, disabled: this.disabled });
            this.btnDown.jqxRepeatButton({ _ariaDisabled: true, overrideTheme: true, disabled: this.disabled });
            this.btnDownInstance = $.data(this.btnDown[0], 'jqxRepeatButton').instance;
            this.btnUpInstance = $.data(this.btnUp[0], 'jqxRepeatButton').instance;

            this.areaUp.jqxRepeatButton({ _scrollAreaButton: true, _ariaDisabled: true, overrideTheme: true });
            this.areaDown.jqxRepeatButton({ _scrollAreaButton: true, _ariaDisabled: true, overrideTheme: true });
            this.btnThumb.jqxButton({ _ariaDisabled: true, overrideTheme: true, disabled: this.disabled });
            this.propertyChangeMap['value'] = function (instance, key, oldVal, value) {
                if (!(isNaN(value))) {
                    if (oldVal != value) {
                        instance.setPosition(parseFloat(value), true);
                    }
                }
            }

            this.propertyChangeMap['width'] = function (instance, key, oldVal, value) {
                if (instance.width != undefined && parseInt(instance.width) > 0) {
                    instance.host.width(parseInt(instance.width));
                    instance._arrange();
                }
            }

            this.propertyChangeMap['height'] = function (instance, key, oldVal, value) {
                if (instance.height != undefined && parseInt(instance.height) > 0) {
                    instance.host.height(parseInt(instance.height));
                    instance._arrange();
                }
            }

            this.propertyChangeMap['theme'] = function (instance, key, oldVal, value) {
                instance.setTheme();
            }

            this.propertyChangeMap['max'] = function (instance, key, oldVal, value) {
                if (!(isNaN(value))) {
                    if (oldVal != value) {
                        instance.max = parseInt(value);
                        if (instance.min > instance.max)
                            instance.max = instance.min + 1;

                        instance._arrange();
                        instance.setPosition(instance.value);
                    }
                }
            }

            this.propertyChangeMap['min'] = function (instance, key, oldVal, value) {
                if (!(isNaN(value))) {
                    if (oldVal != value) {
                        instance.min = parseInt(value);
                        if (instance.min > instance.max)
                            instance.max = instance.min + 1;

                        instance._arrange();
                        instance.setPosition(instance.value);
                    }
                }
            }

            this.propertyChangeMap['disabled'] = function (instance, key, oldVal, value) {
                if (oldVal != value) {
                    if (value) {
                        instance.host.addClass(instance.toThemeProperty('jqx-fill-state-disabled'));
                    }
                    else {
                        instance.host.removeClass(instance.toThemeProperty('jqx-fill-state-disabled'));
                    }
                    instance.btnUp.jqxRepeatButton('disabled', instance.disabled);
                    instance.btnDown.jqxRepeatButton('disabled', instance.disabled);
                    instance.btnThumb.jqxButton('disabled', instance.disabled);
                }
            }

            this.propertyChangeMap['touchMode'] = function (instance, key, oldVal, value) {
                if (oldVal != value) {
                    instance._updateTouchBehavior();
                    if (value === true) {
                        instance.showButtons = false;
                        instance.refresh();
                    }
                    else if (value === false) {
                        instance.showButtons = true;
                        instance.refresh();
                    }
                }
            }

            this.propertyChangeMap['rtl'] = function (instance, key, oldVal, value) {
                if (oldVal != value) {
                    instance.refresh();
                }
            }

            this.buttonUpCapture = false;
            this.buttonDownCapture = false;
            this._updateTouchBehavior();
            this.setPosition(this.value);
            this._addHandlers();
            this.setTheme();
        },

        resize: function (width, height) {
            this.width = width;
            this.height = height;
            this._arrange();
        },

        _updateTouchBehavior: function () {
            this.isTouchDevice = $.jqx.mobile.isTouchDevice();
            if (this.touchMode == true) {
                if ($.jqx.browser.msie && $.jqx.browser.version < 9) {
                    this.setTheme();
                    return;
                }

                this.isTouchDevice = true;
                $.jqx.mobile.setMobileSimulator(this.btnThumb[0]);
                this._removeHandlers();
                this._addHandlers();
                this.setTheme();
            }
            else if (this.touchMode == false) {
                this.isTouchDevice = false;
            }
        },

        _addHandlers: function () {
            var self = this;

            var touchSupport = false;
            try {
                if (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
                    touchSupport = true;
                    this._touchSupport = true;
                }
            }
            catch (err) {
            }

            if (self.isTouchDevice || touchSupport) {
                this.addHandler(this.btnThumb, $.jqx.mobile.getTouchEventName('touchend'), function (event) {
                    var btnThumbPressedClass = self.vertical ? self.toThemeProperty('jqx-scrollbar-thumb-state-pressed') : self.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal');
                    var btnThumbPressedFillClass = self.toThemeProperty('jqx-fill-state-pressed');
                    self.btnThumb.removeClass(btnThumbPressedClass);
                    self.btnThumb.removeClass(btnThumbPressedFillClass);
                    if (!self.disabled) self.handlemouseup(self, event);
                    return false;
                });

                this.addHandler(this.btnThumb, $.jqx.mobile.getTouchEventName('touchstart'), function (event) {
                    if (!self.disabled) {
                        if (self.touchMode == true) {
                            event.clientX = event.originalEvent.clientX;
                            event.clientY = event.originalEvent.clientY;
                        }
                        else {
                            var e = event;
                            if (e.originalEvent.touches && e.originalEvent.touches.length) {
                                event.clientX = e.originalEvent.touches[0].clientX;
                                event.clientY = e.originalEvent.touches[0].clientY;
                            }
                            else {
                                event.clientX = event.originalEvent.clientX;
                                event.clientY = event.originalEvent.clientY;
                            }
                        }

                        self.handlemousedown(event);
                        if (event.preventDefault) {
                            event.preventDefault();
                        }
                    }
                });

                $.jqx.mobile.touchScroll(this.element, self.max, function (left, top, dx, dy, event) {
                    if (self.host.css('visibility') == 'visible') {
                        if (event) {
                            if (self.touchMode == true) {
                                event.clientX = event.originalEvent.clientX;
                                event.clientY = event.originalEvent.clientY;
                            }
                            else {
                                var e = event;
                                if (e.originalEvent.touches && e.originalEvent.touches.length) {
                                    event.clientX = e.originalEvent.touches[0].clientX;
                                    event.clientY = e.originalEvent.touches[0].clientY;
                                }
                                else {
                                    event.clientX = event.originalEvent.clientX;
                                    event.clientY = event.originalEvent.clientY;
                                }
                            }
                        }

                        var btnThumbPressedClass = self.vertical ? self.toThemeProperty('jqx-scrollbar-thumb-state-pressed') : self.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal');
                        self.btnThumb.addClass(btnThumbPressedClass);
                        self.btnThumb.addClass(self.toThemeProperty('jqx-fill-state-pressed'));
                        self.thumbCapture = true;
                        self.element.setAttribute('touched', '');
                        self.handlemousemove(event);
                    }
                }, self.element.id, self.host, self.host);
            }


            if (!this.isTouchDevice) {
                try {
                    if (document.referrer != "" || window.frameElement) {
                        if (window.top != null && window.top != window.self) {
                            var parentLocation = null;
                            if (window.parent && document.referrer) {
                                parentLocation = document.referrer;
                            }

                            if (parentLocation && parentLocation.indexOf(document.location.host) != -1) {
                                var eventHandle = function (event) {
                                    if (!self.disabled) self.handlemouseup(self, event);
                                };

                                if (window.top.document.addEventListener) {
                                    window.top.document.addEventListener('mouseup', eventHandle, false);

                                } else if (window.top.document.attachEvent) {
                                    window.top.document.attachEvent("on" + 'mouseup', eventHandle);
                                }
                            }
                        }
                    }
                }
                catch (error) {
                }
                var eventNames = 'click mouseup mousedown';

                this.addHandler(this.btnDown, eventNames, function (event) {
                    var step = self.step;

                    if (Math.abs(self.max - self.min) <= step)
                        step = 1;

                    if (self.rtl && !self.vertical)
                        step = -self.step;

                    switch (event.type) {
                        case 'click':

                            if (self.buttonDownCapture && !self.isTouchDevice) {
                                if (!self.disabled)
                                    self.setPosition(self.value + step)
                            }
                            else if (!self.disabled && self.isTouchDevice) {
                                self.setPosition(self.value + step);
                            }
                            break;
                        case 'mouseup':
                            if (!self.btnDownInstance.base.disabled && self.buttonDownCapture) {
                                self.buttonDownCapture = false;
                                self.btnDown.removeClass(self.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                                self.btnDown.removeClass(self.toThemeProperty('jqx-fill-state-pressed'));
                                self._removeArrowClasses('pressed', 'down');
                                self.handlemouseup(self, event);

                                self.setPosition(self.value + step)
                                return false;
                            }
                            break;
                        case 'mousedown':
                            if (!self.btnDownInstance.base.disabled) {
                                self.buttonDownCapture = true;
                                self.btnDown.addClass(self.toThemeProperty('jqx-fill-state-pressed'));
                                self.btnDown.addClass(self.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                                self._addArrowClasses('pressed', 'down');
                                return false;
                            }
                            break;
                    }
                });

                this.addHandler(this.btnUp, eventNames, function (event) {
                    var step = self.step;

                    if (Math.abs(self.max - self.min) <= step)
                        step = 1;

                    if (self.rtl && !self.vertical)
                        step = -self.step;

                    switch (event.type) {
                        case 'click':
                            if (self.buttonUpCapture && !self.isTouchDevice) {
                                if (!self.disabled) {
                                    self.setPosition(self.value - step);
                                }
                            }
                            else if (!self.disabled && self.isTouchDevice) {
                                self.setPosition(self.value - step);
                            }
                            break;
                        case 'mouseup':
                            if (!self.btnUpInstance.base.disabled && self.buttonUpCapture) {
                                self.buttonUpCapture = false;
                                self.btnUp.removeClass(self.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                                self.btnUp.removeClass(self.toThemeProperty('jqx-fill-state-pressed'));
                                self._removeArrowClasses('pressed', 'up');
                                self.handlemouseup(self, event);

                                self.setPosition(self.value - step)
                                return false;
                            }
                            break;
                        case 'mousedown':
                            if (!self.btnUpInstance.base.disabled) {
                                self.buttonUpCapture = true;
                                self.btnUp.addClass(self.toThemeProperty('jqx-fill-state-pressed'));
                                self.btnUp.addClass(self.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                                self._addArrowClasses('pressed', 'up');
                                return false;
                            }
                            break;
                    }
                });
            }

            var eventName = 'click';
            if (this.isTouchDevice) {
                eventName = $.jqx.mobile.getTouchEventName('touchend');
            }

            this.addHandler(this.areaUp, eventName, function (event) {
                if (!self.disabled) {
                    var step = self.largestep;
                    if (self.rtl && !self.vertical) {
                        step = -self.largestep;
                    }

                    var canSetPosition = true;
                    var thumbOffset = self.btnThumb.offset();
                    if (!self.vertical) {
                        if (self.areaClickOffset.x >= thumbOffset.left) {
                            canSetPosition = false;
                        }
                    }
                    else {
                        if (self.areaClickOffset.y >= thumbOffset.top) {
                            canSetPosition = false;
                        }
                    }

                    if (canSetPosition) {
                        self.setPosition(self.value - step);
                    }
                    return false;
                }
            });
            this.addHandler(this.areaDown, eventName, function (event) {
                if (!self.disabled) {
                    var step = self.largestep;
                    if (self.rtl && !self.vertical) {
                        step = -self.largestep;
                    }

                    var canSetPosition = true;
                    var thumbOffset = self.btnThumb.offset();
                    if (!self.vertical) {
                        if (self.areaClickOffset.x <= thumbOffset.left) {
                            canSetPosition = false;
                        }
                    }
                    else {
                        if (self.areaClickOffset.y <= thumbOffset.top) {
                            canSetPosition = false;
                        }
                    }

                    if (canSetPosition) {
                        self.setPosition(self.value + step);
                    }
                    return false;
                }
            });
            this.addHandler(this.areaUp, 'mousedown', function (event) {
                if (!self.disabled) {
                    self.areaUpCapture = true;
                    self.areaClickOffset = { x: event.pageX, y: event.pageY };
                    return false;
                }
            });
            this.addHandler(this.areaDown, 'mousedown', function (event) {
                if (!self.disabled) {
                    self.areaDownCapture = true;
                    self.areaClickOffset = { x: event.pageX, y: event.pageY };
                    return false;
                }
            });

            this.addHandler(this.btnThumb, 'mousedown dragstart', function (event) {
                if (event.type === "dragstart")
                    return false;

                if (!self.disabled) {
                    self.handlemousedown(event);
                }
                if (event.preventDefault) {
                    event.preventDefault();
                }
            });

            this.addHandler($(document), 'mouseup.' + this.element.id, function (event) {
                if (!self.disabled) self.handlemouseup(self, event);
            });

            if (!this.isTouchDevice) {
                this.mousemoveFunc = function (event) {
                    if (!self.disabled) {
                        self.handlemousemove(event);
                    }
                }

                this.addHandler($(document), 'mousemove.' + this.element.id, this.mousemoveFunc);
                this.addHandler($(document), 'mouseleave.' + this.element.id, function (event) { if (!self.disabled) self.handlemouseleave(event); });
                this.addHandler($(document), 'mouseenter.' + this.element.id, function (event) { if (!self.disabled) self.handlemouseenter(event); });

                if (!self.disabled) {
                    this.addHandler(this.btnUp, 'mouseenter mouseleave', function (event) {
                        if (event.type === "mouseenter") {
                            if (!self.disabled && !self.btnUpInstance.base.disabled && self.touchMode != true) {
                                self.btnUp.addClass(self.toThemeProperty('jqx-scrollbar-button-state-hover'));
                                self.btnUp.addClass(self.toThemeProperty('jqx-fill-state-hover'));
                                self._addArrowClasses('hover', 'up');
                            }
                        }
                        else {
                            if (!self.disabled && !self.btnUpInstance.base.disabled && self.touchMode != true) {
                                self.btnUp.removeClass(self.toThemeProperty('jqx-scrollbar-button-state-hover'));
                                self.btnUp.removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                                self._removeArrowClasses('hover', 'up');
                            }
                        }
                    });

                    var thumbHoverClass = self.toThemeProperty('jqx-scrollbar-thumb-state-hover');
                    if (!self.vertical) {
                        thumbHoverClass = self.toThemeProperty('jqx-scrollbar-thumb-state-hover-horizontal');
                    }

                    this.addHandler(this.btnThumb, 'mouseenter mouseleave', function (event) {
                        if (event.type === "mouseenter") {
                            if (!self.disabled && self.touchMode != true) {
                                self.btnThumb.addClass(thumbHoverClass);
                                self.btnThumb.addClass(self.toThemeProperty('jqx-fill-state-hover'));
                            }
                        }
                        else {
                            if (!self.disabled && self.touchMode != true) {
                                self.btnThumb.removeClass(thumbHoverClass);
                                self.btnThumb.removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                            }
                        }
                    });

                    this.addHandler(this.btnDown, 'mouseenter mouseleave', function (event) {
                        if (event.type === "mouseenter") {
                            if (!self.disabled && !self.btnDownInstance.base.disabled && self.touchMode != true) {
                                self.btnDown.addClass(self.toThemeProperty('jqx-scrollbar-button-state-hover'));
                                self.btnDown.addClass(self.toThemeProperty('jqx-fill-state-hover'));
                                self._addArrowClasses('hover', 'down');
                            }
                        }
                        else {
                            if (!self.disabled && !self.btnDownInstance.base.disabled && self.touchMode != true) {
                                self.btnDown.removeClass(self.toThemeProperty('jqx-scrollbar-button-state-hover'));
                                self.btnDown.removeClass(self.toThemeProperty('jqx-fill-state-hover'));
                                self._removeArrowClasses('hover', 'down');
                            }
                        }
                    });
                }
            }
        },

        destroy: function () {
            var btnUp = this.btnUp;
            var btnDown = this.btnDown;
            var btnThumb = this.btnThumb;
            var elWrap = this.scrollWrap;
            var areaUp = this.areaUp;
            var areaDown = this.areaDown;

            this.arrowUp.remove();
            delete this.arrowUp;
            this.arrowDown.remove();
            delete this.arrowDown;

            areaDown.removeClass();
            areaUp.removeClass();
            btnDown.removeClass();
            btnUp.removeClass();
            btnThumb.removeClass();

            btnUp.jqxRepeatButton('destroy');
            btnDown.jqxRepeatButton('destroy');
            areaUp.jqxRepeatButton('destroy');
            areaDown.jqxRepeatButton('destroy');
            btnThumb.jqxButton('destroy');
            var vars = $.data(this.element, "jqxScrollBar");

            this._removeHandlers();
            this.btnUp = null;
            this.btnDown = null;
            this.scrollWrap = null;
            this.areaUp = null;
            this.areaDown = null;
            this.scrollOuterWrap = null;
            delete this.mousemoveFunc;
            delete this.btnDownInstance;
            delete this.btnUpInstance;
            delete this.scrollOuterWrap;
            delete this.scrollWrap;
            delete this.btnDown;
            delete this.areaDown;
            delete this.areaUp;
            delete this.btnDown;
            delete this.btnUp;
            delete this.btnThumb;
            delete this.propertyChangeMap['value'];
            delete this.propertyChangeMap['min'];
            delete this.propertyChangeMap['max'];
            delete this.propertyChangeMap['touchMode'];
            delete this.propertyChangeMap['disabled'];
            delete this.propertyChangeMap['theme'];
            delete this.propertyChangeMap;
            if (vars) {
                delete vars.instance;
            }
            this.host.removeData();
            this.host.remove();
            delete this.host;
            delete this.set;
            delete this.get;
            delete this.call;
            delete this.element;
        },

        _removeHandlers: function () {
            this.removeHandler(this.btnUp, 'mouseenter');
            this.removeHandler(this.btnDown, 'mouseenter');
            this.removeHandler(this.btnThumb, 'mouseenter');
            this.removeHandler(this.btnUp, 'mouseleave');
            this.removeHandler(this.btnDown, 'mouseleave');
            this.removeHandler(this.btnThumb, 'mouseleave');
            this.removeHandler(this.btnUp, 'click');
            this.removeHandler(this.btnDown, 'click');
            this.removeHandler(this.btnDown, 'mouseup');
            this.removeHandler(this.btnUp, 'mouseup');
            this.removeHandler(this.btnDown, 'mousedown');
            this.removeHandler(this.btnUp, 'mousedown');
            this.removeHandler(this.areaUp, 'mousedown');
            this.removeHandler(this.areaDown, 'mousedown');
            this.removeHandler(this.areaUp, 'click');
            this.removeHandler(this.areaDown, 'click');
            this.removeHandler(this.btnThumb, 'mousedown');
            this.removeHandler(this.btnThumb, 'dragstart');
            this.removeHandler($(document), 'mouseup.' + this.element.id);
            if (!this.mousemoveFunc) {
                this.removeHandler($(document), 'mousemove.' + this.element.id);
            }
            else {
                this.removeHandler($(document), 'mousemove.' + this.element.id, this.mousemoveFunc);
            }

            this.removeHandler($(document), 'mouseleave.' + this.element.id);
            this.removeHandler($(document), 'mouseenter.' + this.element.id);
            var self = this;
        },

        _addArrowClasses: function (state, button) {
            if (state == 'pressed') state = 'selected';
            if (state != '') {
                state = '-' + state;
            }

            if (this.vertical) {
                if (button == 'up' || button == undefined) {
                    this.arrowUp.addClass(this.toThemeProperty("jqx-icon-arrow-up" + state));
                }

                if (button == 'down' || button == undefined) {
                    this.arrowDown.addClass(this.toThemeProperty("jqx-icon-arrow-down" + state));
                }
            }
            else {
                if (button == 'up' || button == undefined) {
                    this.arrowUp.addClass(this.toThemeProperty("jqx-icon-arrow-left" + state));
                }

                if (button == 'down' || button == undefined) {
                    this.arrowDown.addClass(this.toThemeProperty("jqx-icon-arrow-right" + state));
                }
            }
        },

        _removeArrowClasses: function (state, button) {
            if (state == 'pressed') state = 'selected';
            if (state != '') {
                state = '-' + state;
            }

            if (this.vertical) {
                if (button == 'up' || button == undefined) {
                    this.arrowUp.removeClass(this.toThemeProperty("jqx-icon-arrow-up" + state));
                }

                if (button == 'down' || button == undefined) {
                    this.arrowDown.removeClass(this.toThemeProperty("jqx-icon-arrow-down" + state));
                }
            }
            else {
                if (button == 'up' || button == undefined) {
                    this.arrowUp.removeClass(this.toThemeProperty("jqx-icon-arrow-left" + state));
                }

                if (button == 'down' || button == undefined) {
                    this.arrowDown.removeClass(this.toThemeProperty("jqx-icon-arrow-right" + state));
                }
            }
        },

        setTheme: function () {
            var btnUp = this.btnUp;
            var btnDown = this.btnDown;
            var btnThumb = this.btnThumb;
            var elWrap = this.scrollWrap;
            var areaUp = this.areaUp;
            var areaDown = this.areaDown;
            var arrowUp = this.arrowUp;
            var arrowDown = this.arrowDown;

            this.scrollWrap[0].className = this.toThemeProperty('jqx-reset');
            this.scrollOuterWrap[0].className = this.toThemeProperty('jqx-reset');

            var areaClassName = this.toThemeProperty('jqx-reset');
            this.areaDown[0].className = areaClassName;
            this.areaUp[0].className = areaClassName;

            var hostClass = this.toThemeProperty('jqx-scrollbar') + " " + this.toThemeProperty('jqx-widget') + " " + this.toThemeProperty('jqx-widget-content');
            this.host.addClass(hostClass);
            if (this.isTouchDevice) {
                this.host.addClass(this.toThemeProperty('jqx-scrollbar-mobile'));
            }

            btnDown[0].className = this.toThemeProperty('jqx-scrollbar-button-state-normal');
            btnUp[0].className = this.toThemeProperty('jqx-scrollbar-button-state-normal');

            var thumbClass = "";
            if (this.vertical) {
                arrowUp[0].className = areaClassName + " " + this.toThemeProperty("jqx-icon-arrow-up");
                arrowDown[0].className = areaClassName + " " + this.toThemeProperty("jqx-icon-arrow-down");
                thumbClass = this.toThemeProperty('jqx-scrollbar-thumb-state-normal');
            }
            else {
                arrowUp[0].className = areaClassName + " " + this.toThemeProperty("jqx-icon-arrow-left");
                arrowDown[0].className = areaClassName + " " + this.toThemeProperty("jqx-icon-arrow-right");
                thumbClass = this.toThemeProperty('jqx-scrollbar-thumb-state-normal-horizontal');
            }
            thumbClass += " " + this.toThemeProperty('jqx-fill-state-normal');

            btnThumb[0].className = thumbClass;

            if (this.disabled) {
                elWrap.addClass(this.toThemeProperty('jqx-fill-state-disabled'));
                elWrap.removeClass(this.toThemeProperty('jqx-scrollbar-state-normal'));
            }
            else {
                elWrap.addClass(this.toThemeProperty('jqx-scrollbar-state-normal'));
                elWrap.removeClass(this.toThemeProperty('jqx-fill-state-disabled'));
            }

            if (this.roundedCorners == 'all') {
                this.host.addClass(this.toThemeProperty('jqx-rc-all'));
                if (this.vertical) {
                    var rct = $.jqx.cssroundedcorners('top');
                    rct = this.toThemeProperty(rct);
                    btnUp.addClass(rct);

                    var rcb = $.jqx.cssroundedcorners('bottom');
                    rcb = this.toThemeProperty(rcb);
                    btnDown.addClass(rcb);

                }
                else {
                    var rcl = $.jqx.cssroundedcorners('left');
                    rcl = this.toThemeProperty(rcl);
                    btnUp.addClass(rcl);

                    var rcr = $.jqx.cssroundedcorners('right');
                    rcr = this.toThemeProperty(rcr);
                    btnDown.addClass(rcr);
                }
            }
            else {
                var rc = $.jqx.cssroundedcorners(this.roundedCorners);
                rc = this.toThemeProperty(rc);
                btnUp.addClass(rc);
                btnDown.addClass(rc);
            }

            var rc = $.jqx.cssroundedcorners(this.roundedCorners);
            rc = this.toThemeProperty(rc);
            if (!btnThumb.hasClass(rc)) {
                btnThumb.addClass(rc);
            }
            if (btnUp.css('display') === 'none') {
                this.showButtons = false;
                this.touchModeStyle = true;
                btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-normal-touch'));
            }

            if (this.isTouchDevice && this.touchModeStyle != false) {
                this.showButtons = false;
                btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-normal-touch'));
            }
        },

        // returns true, if the user is dragging the thumb or the increase or decrease button is pressed.
        isScrolling: function () {
            if (this.thumbCapture == undefined || this.buttonDownCapture == undefined || this.buttonUpCapture == undefined || this.areaDownCapture == undefined || this.areaUpCapture == undefined)
                return false;

            return this.thumbCapture || this.buttonDownCapture || this.buttonUpCapture || this.areaDownCapture || this.areaUpCapture;
        },

        track: function () {
            var now, elapsed, delta, v;

            now = Date.now();
            elapsed = now - this.timestamp;
            this.timestamp = now;
            delta = this.offset - this.frame;
            this.frame = this.offset;
            v = 1000 * delta / (1 + elapsed);
            this.velocity = 0.2 * v + 0.2 * this.velocity;
        },

        handlemousedown: function (event) {
            if (this.thumbCapture == undefined || this.thumbCapture == false) {
                this.thumbCapture = true;
                var btnThumb = this.btnThumb;
                if (btnThumb != null) {
                    btnThumb.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                    if (this.vertical) {
                        btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-pressed'));
                    }
                    else {
                        btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal'));
                    }
                    this.element.setAttribute('touched', '');
                }
            }

            var that = this;
            function tap(e) {
                that.reference = parseInt(that.btnThumb[0].style.top);
                that.offset = parseInt(that.btnThumb[0].style.top);
                if (!that.vertical) {
                    that.reference = parseInt(that.btnThumb[0].style.left);
                    that.offset = parseInt(that.btnThumb[0].style.left);
                }

                that.velocity = that.amplitude = 0;
                that.frame = that.offset;
                that.timestamp = Date.now();
                clearInterval(that.ticker);
                that.ticker = setInterval(function () {
                    that.track();
                }, 100);
            }
            if (this.thumbCapture && $.jqx.scrollAnimation) {
                tap(event);
            }
            this.dragStartX = event.clientX;
            this.dragStartY = event.clientY;
            this.dragStartValue = this.value;
        },

        toggleHover: function (event, element) {
            //element.toggleClass('jqx-fill-state-hover');
        },

        refresh: function () {
            this._arrange();
        },

        _setElementPosition: function (element, x, y) {
            if (!isNaN(x)) {
                if (parseInt(element[0].style.left) != parseInt(x)) {
                    element[0].style.left = x + 'px';
                }
            }
            if (!isNaN(y)) {
                if (parseInt(element[0].style.top) != parseInt(y)) {
                    element[0].style.top = y + 'px';
                }
            }
        },

        _setElementTopPosition: function (element, y) {
            if (!isNaN(y)) {
                element[0].style.top = y + 'px';
            }
        },

        _setElementLeftPosition: function (element, x) {
            if (!isNaN(x)) {
                element[0].style.left = x + 'px';
            }
        },

        handlemouseleave: function (event) {
            var btnUp = this.btnUp;
            var btnDown = this.btnDown;

            if (this.buttonDownCapture || this.buttonUpCapture) {
                btnUp.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                btnDown.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                this._removeArrowClasses('pressed');
            }

            if (this.thumbCapture != true)
                return;

            var btnThumb = this.btnThumb;
            var btnThumbPressedClass = this.vertical ? this.toThemeProperty('jqx-scrollbar-thumb-state-pressed') : this.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal');
            btnThumb.removeClass(btnThumbPressedClass);
            btnThumb.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
            this.element.removeAttribute('touched');
        },

        handlemouseenter: function (event) {
            var btnUp = this.btnUp;
            var btnDown = this.btnDown;

            if (this.buttonUpCapture) {
                btnUp.addClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                btnUp.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this._addArrowClasses('pressed', 'up');
                this.element.setAttribute('touched', '');
            }

            if (this.buttonDownCapture) {
                btnDown.addClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                btnDown.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this._addArrowClasses('pressed', 'down');
                this.element.setAttribute('touched', '');
            }

            if (this.thumbCapture != true)
                return;

            var btnThumb = this.btnThumb;
            if (this.vertical) {
                btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-pressed'));
            }
            else {
                btnThumb.addClass(this.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal'));
            }
            btnThumb.addClass(this.toThemeProperty('jqx-fill-state-pressed'));
            this.element.setAttribute('touched', '');
        },

        handlemousemove: function (event) {
            var btnUp = this.btnUp;
            var btnDown = this.btnDown;
            var which = 0;

            if (btnDown == null || btnUp == null)
                return;

            if (btnUp != null && btnDown != null && this.buttonDownCapture != undefined && this.buttonUpCapture != undefined) {
                if (this.buttonDownCapture && event.which == which) {
                    btnDown.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                    btnDown.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                    this._removeArrowClasses('pressed', 'down');

                    this.buttonDownCapture = false;
                }
                else if (this.buttonUpCapture && event.which == which) {
                    btnUp.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                    btnUp.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                    this._removeArrowClasses('pressed', 'up');
                    this.buttonUpCapture = false;
                }
            }

            if (this.thumbCapture != true)
                return false;

            var btnThumb = this.btnThumb;

            if (event.which == which && !this.isTouchDevice && !this._touchSupport) {
                this.thumbCapture = false;
                this._arrange();
                var btnThumbPressedClass = this.vertical ? this.toThemeProperty('jqx-scrollbar-thumb-state-pressed') : this.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal');
                btnThumb.removeClass(btnThumbPressedClass);
                btnThumb.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                return true;
            }

            if (event.preventDefault != undefined) {
                event.preventDefault();
            }

            if (event.originalEvent != null) {
                event.originalEvent.mouseHandled = true;
            }

            if (event.stopPropagation != undefined) {
                event.stopPropagation();
            }

            var diff = 0;

            try {
                if (!this.vertical) {
                    diff = event.clientX - this.dragStartX;
                }
                else {
                    diff = event.clientY - this.dragStartY;
                }

                var btnAndThumbSize = this._btnAndThumbSize;
                if (!this._btnAndThumbSize) {
                    btnAndThumbSize = (this.vertical) ?
                        btnUp.height() + btnDown.height() + btnThumb.height() :
                        btnUp.width() + btnDown.width() + btnThumb.width();
                }

                var ratio = (this.max - this.min) / (this.scrollBarSize - btnAndThumbSize);
                if (this.thumbStep == 'auto') {
                    diff *= ratio;
                }
                else {
                    diff *= ratio;
                    if (Math.abs(this.dragStartValue + diff - this.value) >= parseInt(this.thumbStep)) {
                        var step = Math.round(parseInt(diff) / this.thumbStep) * this.thumbStep;
                        if (this.rtl && !this.vertical) {
                            this.setPosition(this.dragStartValue - step);
                        }
                        else {
                            this.setPosition(this.dragStartValue + step);
                        }
                        return false;
                    }
                    else {
                        return false;
                    }
                }

                var step = diff;
                if (this.rtl && !this.vertical) {
                    step = -diff;
                }

                this.setPosition(this.dragStartValue + step);
                this.offset = parseInt(btnThumb[0].style.left);
                if (this.vertical) {
                    this.offset = parseInt(btnThumb[0].style.top);
                }
            }
            catch (error) {
                alert(error);
            }

            return false;
        },

        handlemouseup: function (self, event) {
            var prevent = false;

            if (this.thumbCapture) {
                this.thumbCapture = false;

                var btnThumb = this.btnThumb;
                var btnThumbPressedClass = this.vertical ? this.toThemeProperty('jqx-scrollbar-thumb-state-pressed') : this.toThemeProperty('jqx-scrollbar-thumb-state-pressed-horizontal');
                btnThumb.removeClass(btnThumbPressedClass);
                btnThumb.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this.element.removeAttribute('touched');

                prevent = true;
                this._mouseup = new Date();
                if ($.jqx.scrollAnimation) {
                    var that = this;
                    function autoScroll() {
                        var elapsed, delta;
                        if (that.amplitude) {
                            elapsed = Date.now() - that.timestamp;
                            delta = -that.amplitude * Math.exp(-elapsed / 325);
                            if (delta > 0.5 || delta < -0.5) {
                                var ratio = (that.max - that.min) / (that.scrollBarSize - that._btnAndThumbSize);
                                var newValue = ratio * (that.target + delta)
                                var step = newValue;
                                if (that.rtl && !that.vertical) {
                                    step = -newValue;
                                }

                                that.setPosition(that.dragStartValue + step);
                                requestAnimationFrame(autoScroll);
                            } else {
                                var ratio = (that.max - that.min) / (that.scrollBarSize - that._btnAndThumbSize);
                                var newValue = ratio * (that.target + delta)
                                var step = newValue;
                                if (that.rtl && !that.vertical) {
                                    step = -newValue;
                                }

                                that.setPosition(that.dragStartValue + step);
                            }
                        }
                    }
                    clearInterval(this.ticker);
                    if (this.velocity > 25 || this.velocity < -25) {
                        this.amplitude = 0.8 * this.velocity;
                        this.target = Math.round(this.offset + this.amplitude);
                        if (!this.vertical) {
                            this.target -= this.reference;
                        }
                        else {
                            this.target -= this.reference;
                        }

                        this.timestamp = Date.now();
                        requestAnimationFrame(autoScroll);
                    }
                }
            }

            this.areaDownCapture = this.areaUpCapture = false;
            if (this.buttonUpCapture || this.buttonDownCapture) {
                var btnUp = this.btnUp;
                var btnDown = this.btnDown;

                this.buttonUpCapture = false;
                this.buttonDownCapture = false;
                btnUp.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                btnDown.removeClass(this.toThemeProperty('jqx-scrollbar-button-state-pressed'));
                btnUp.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                btnDown.removeClass(this.toThemeProperty('jqx-fill-state-pressed'));
                this._removeArrowClasses('pressed');
                this.element.removeAttribute('touched');

                prevent = true;
                this._mouseup = new Date();
            }

            if (prevent) {
                if (event.preventDefault != undefined) {
                    event.preventDefault();
                }

                if (event.originalEvent != null) {
                    event.originalEvent.mouseHandled = true;
                }

                if (event.stopPropagation != undefined) {
                    event.stopPropagation();
                }
            }
        },

        // sets the value.
        // @param Number. Sets the ScrollBar's value.
        setPosition: function (position, update) {
            var element = this.element;

            if (position == undefined || position == NaN)
                position = this.min;

            if (position >= this.max) {
                position = this.max;
            }

            if (position < this.min) {
                position = this.min;
            }

            if (this.value !== position || update == true) {
                if (position == this.max) {
                    var completeEvent = new $.Event('complete');
                    this.host.trigger(completeEvent);
                }
                var oldvalue = this.value;
                if (this._triggervaluechanged) {
                    var event = new $.Event('valueChanged');
                    event.previousValue = this.value;
                    event.currentValue = position;
                }

                this.value = position;
                this._positionelements();
                //this._arrange();

                if (this._triggervaluechanged) {
                    this.host.trigger(event);
                }

                if (this.valueChanged) {
                    this.valueChanged({ currentValue: this.value, previousvalue: oldvalue });
                }
            }

            return position;
        },

        val: function (value) {
            var isEmpty = function (obj) {
                for (var key in obj) {
                    if (obj.hasOwnProperty(key))
                        return false;
                }
                if (typeof value == "number")
                    return false;
                if (typeof value == "date")
                    return false;
                if (typeof value == "boolean")
                    return false;
                if (typeof value == "string")
                    return false;

                return true;
            }
            if (isEmpty(value) || arguments.length == 0) {
                return this.value;
            }
            else {
                this.setPosition(value);
                return value;
            }
        },

        _getThumbSize: function (scrollAreaSize) {
            var positions = this.max - this.min;

            var size = 0;
            if (positions > 1) {
                size = (scrollAreaSize / (positions + scrollAreaSize) * scrollAreaSize);
            }
            else if (positions == 1) {
                size = scrollAreaSize - 1;
            }
            else if (positions == 0)
                size = scrollAreaSize;

            if (this.thumbSize > 0) {
                size = this.thumbSize;
            }

            if (size < this.thumbMinSize)
                size = this.thumbMinSize;

            return Math.min(size, scrollAreaSize);
        },

        _positionelements: function () {
            var element = this.element;
            var elAreaUp = this.areaUp;
            var elAreaDown = this.areaDown;
            var elBtnUp = this.btnUp;
            var elBtnDown = this.btnDown;
            var elThumb = this.btnThumb;
            var elWrap = this.scrollWrap;

            var height = this._height ? this._height : this.host.height();
            var width = this._width ? this._width : this.host.width();

            var btnSize = (!this.vertical) ? height : width;
            if (!this.showButtons) {
                btnSize = 0;
            }

            var scrollBarSize = (!this.vertical) ? width : height;
            this.scrollBarSize = scrollBarSize;
            var thumbSize = this._getThumbSize(scrollBarSize - 2 * btnSize);
            thumbSize = Math.floor(thumbSize);

            if (thumbSize < this.thumbMinSize)
                thumbSize = this.thumbMinSize;

            if (height == NaN || height < 10)
                height = 10;

            if (width == NaN || width < 10)
                width = 10;

            btnSize += 2;
            this.btnSize = btnSize;

            var btnAndThumbSize = this._btnAndThumbSize;

            if (!this._btnAndThumbSize) {
                var btnAndThumbSize = (this.vertical) ?
                    2 * this.btnSize + elThumb.outerHeight() :
                    2 * this.btnSize + elThumb.outerWidth();

                btnAndThumbSize = Math.round(btnAndThumbSize);
            }

            var upAreaSize = (scrollBarSize - btnAndThumbSize) / (this.max - this.min) * (this.value - this.min);
            if (this.rtl && !this.vertical) {
                upAreaSize = (scrollBarSize - btnAndThumbSize) / (this.max - this.min) * (this.max - this.value - this.min);
            }

            upAreaSize = Math.round(upAreaSize);
            if (upAreaSize < 0) {
                upAreaSize = 0;
            }
            if (this.vertical) {
                var newDownSize = scrollBarSize - upAreaSize - btnAndThumbSize;
                if (newDownSize < 0) newDownSize = 0;
                elAreaDown[0].style.height = newDownSize + 'px';
                elAreaUp[0].style.height = upAreaSize + 'px';

                this._setElementTopPosition(elAreaUp, btnSize);
                this._setElementTopPosition(elThumb, btnSize + upAreaSize);
                this._setElementTopPosition(elAreaDown, btnSize + upAreaSize + thumbSize);
            }
            else {
                elAreaUp[0].style.width = upAreaSize + 'px';
                if (scrollBarSize - upAreaSize - btnAndThumbSize >= 0) {
                    elAreaDown[0].style.width = scrollBarSize - upAreaSize - btnAndThumbSize + 'px';
                }
                else {
                    elAreaDown[0].style.width = '0px';
                }

                this._setElementLeftPosition(elAreaUp, btnSize);
                this._setElementLeftPosition(elThumb, btnSize + upAreaSize);
                this._setElementLeftPosition(elAreaDown, 2 + btnSize + upAreaSize + thumbSize);
            }
        },

        _arrange: function () {
            var self = this;
            if (self._initialLayout) {
                self._initialLayout = false;
                return;
            }

            if (self.min > self.max) {
                var tmp = self.min;
                self.min = self.max;
                self.max = tmp;
            }

            if (self.min < 0) {
                var diff = self.max - self.min;
                self.min = 0;
                self.max = diff;
            }

            var element = self.element;
            var elAreaUp = self.areaUp;
            var elAreaDown = self.areaDown;
            var elBtnUp = self.btnUp;
            var elBtnDown = self.btnDown;
            var elThumb = self.btnThumb;
            var elWrap = self.scrollWrap;

            var height = parseInt(self.element.style.height);
            var width = parseInt(self.element.style.width);
            if (self.isPercentage) {
                var height = self.host.height();
                var width = self.host.width();
            }

            if (isNaN(height)) height = 0;
            if (isNaN(width)) width = 0;

            self._width = width;
            self._height = height;
            var btnSize = (!self.vertical) ? height : width;
            if (!self.showButtons) {
                btnSize = 0;
            }

            elBtnUp[0].style.width = btnSize + 'px';
            elBtnUp[0].style.height = btnSize + 'px';
            elBtnDown[0].style.width = btnSize + 'px';
            elBtnDown[0].style.height = btnSize + 'px';

            if (self.vertical) {
                elWrap[0].style.width = width + 2 + 'px';
            }
            else {
                elWrap[0].style.height = height + 2 + 'px';
            }

            // position the up button
            self._setElementPosition(elBtnUp, 0, 0);

            var btnSizeAndBorder = btnSize + 2;

            // position the down button
            if (self.vertical) {
                self._setElementPosition(elBtnDown, 0, height - btnSizeAndBorder);
            }
            else {
                self._setElementPosition(elBtnDown, width - btnSizeAndBorder, 0);
            }

            var scrollBarSize = (!self.vertical) ? width : height;
            self.scrollBarSize = scrollBarSize;
            var thumbSize = self._getThumbSize(scrollBarSize - 2 * btnSizeAndBorder);
            thumbSize = Math.floor(thumbSize - 2);

            if (thumbSize < self.thumbMinSize)
                thumbSize = self.thumbMinSize;

            var touchStyle = false;
            if (self.isTouchDevice && self.touchModeStyle != false) {
                touchStyle = true;
            }

            if (!self.vertical) {
                elThumb[0].style.width = thumbSize + 'px';
                elThumb[0].style.height = height + 'px';
                if (touchStyle && self.thumbTouchSize !== 0) {
                    elThumb.css({ height: self.thumbTouchSize + 'px' });
                    elThumb.css('margin-top', (self.host.height() - self.thumbTouchSize) / 2);
                }
            }
            else {
                elThumb[0].style.width = width + 'px';
                elThumb[0].style.height = thumbSize + 'px';

                if (touchStyle && self.thumbTouchSize !== 0) {
                    elThumb.css({ width: self.thumbTouchSize + 'px' });
                    elThumb.css('margin-left', (self.host.width() - self.thumbTouchSize) / 2);
                }
            }

            if (height == NaN || height < 10)
                height = 10;

            if (width == NaN || width < 10)
                width = 10;

            //btnSize += 2;
            self.btnSize = btnSize;

            var btnAndThumbSize = (self.vertical) ?
                2 * btnSizeAndBorder + (2 + parseInt(elThumb[0].style.height)) :
                2 * btnSizeAndBorder + (2 + parseInt(elThumb[0].style.width));

            btnAndThumbSize = Math.round(btnAndThumbSize);
            self._btnAndThumbSize = btnAndThumbSize;

            var upAreaSize = (scrollBarSize - btnAndThumbSize) / (self.max - self.min) * (self.value - self.min);
            if (self.rtl && !self.vertical)
                upAreaSize = (scrollBarSize - btnAndThumbSize) / (self.max - self.min) * (self.max - self.value - self.min);

            upAreaSize = Math.round(upAreaSize);

            if (isNaN(upAreaSize) || upAreaSize < 0 || upAreaSize === -Infinity || upAreaSize === Infinity)
                upAreaSize = 0;

            if (self.vertical) {
                var newAreaHeight = (scrollBarSize - upAreaSize - btnAndThumbSize);
                if (newAreaHeight < 0)
                    newAreaHeight = 0;

                elAreaDown[0].style.height = newAreaHeight + 'px';
                elAreaDown[0].style.width = width + 'px';
                elAreaUp[0].style.height = upAreaSize + 'px';
                elAreaUp[0].style.width = width + 'px';

                var hostHeight = parseInt(self.element.style.height);
                if (self.isPercentage)
                    hostHeight = self.host.height();

                elThumb[0].style.visibility = 'inherit';

                if (hostHeight - 3 * parseInt(btnSize) < 0 || hostHeight < btnAndThumbSize)
                    elThumb[0].style.visibility = 'hidden';

                self._setElementPosition(elAreaUp, 0, btnSizeAndBorder);
                self._setElementPosition(elThumb, 0, btnSizeAndBorder + upAreaSize);
                self._setElementPosition(elAreaDown, 0, btnSizeAndBorder + upAreaSize + thumbSize);
            }
            else {
                if (upAreaSize > 0) {
                    elAreaUp[0].style.width = upAreaSize + 'px';
                }
                if (height > 0) {
                    elAreaUp[0].style.height = height + 'px';
                }

                var newAreaWidth = (scrollBarSize - upAreaSize - btnAndThumbSize);
                if (newAreaWidth < 0)
                    newAreaWidth = 0;

                elAreaDown[0].style.width = newAreaWidth + 'px';
                elAreaDown[0].style.height = height + 'px';

                var hostWidth = parseInt(self.element.style.width);
                if (self.isPercentage)
                    hostWidth = self.host.width();

                elThumb[0].style.visibility = 'inherit';
                if ((hostWidth - 3 * parseInt(btnSize) < 0) || (hostWidth < btnAndThumbSize))
                    elThumb[0].style.visibility = 'hidden';

                self._setElementPosition(elAreaUp, btnSizeAndBorder, 0);
                self._setElementPosition(elThumb, btnSizeAndBorder + upAreaSize, 0);
                self._setElementPosition(elAreaDown, btnSizeAndBorder + upAreaSize + thumbSize, 0);
            }
        }
    }); // jqxScrollBar
})(jqxBaseFramework);
})();




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_4237866__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_4237866__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__nested_webpack_require_4237866__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_4237866__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__nested_webpack_require_4237866__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_4237866__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_4237866__.o(definition, key) && !__nested_webpack_require_4237866__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nested_webpack_require_4237866__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/* harmony import */ var _jqxcore__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4237866__(5459);
/* harmony import */ var _jqxcore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxcore__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jqxdata__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_4237866__(4198);
/* harmony import */ var _jqxdata__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxdata__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jqxdata_export__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_4237866__(3907);
/* harmony import */ var _jqxdata_export__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxdata_export__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jqxexport__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_4237866__(714);
/* harmony import */ var _jqxexport__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxexport__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jqxbuttons__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_4237866__(7351);
/* harmony import */ var _jqxbuttons__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxbuttons__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _jqxbuttongroup__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_4237866__(7196);
/* harmony import */ var _jqxbuttongroup__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxbuttongroup__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _jqxscrollbar__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_4237866__(4240);
/* harmony import */ var _jqxscrollbar__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxscrollbar__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _jqxmenu__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_4237866__(1610);
/* harmony import */ var _jqxmenu__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxmenu__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _jqxlistbox__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_4237866__(1062);
/* harmony import */ var _jqxlistbox__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxlistbox__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _jqxdropdownlist__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_4237866__(5868);
/* harmony import */ var _jqxdropdownlist__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxdropdownlist__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _jqxcombobox__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_4237866__(4720);
/* harmony import */ var _jqxcombobox__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxcombobox__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _jqxnumberinput__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_4237866__(7995);
/* harmony import */ var _jqxnumberinput__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxnumberinput__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _jqxcheckbox__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_4237866__(4545);
/* harmony import */ var _jqxcheckbox__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxcheckbox__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _globalization_globalize__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_4237866__(2497);
/* harmony import */ var _globalization_globalize__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_globalization_globalize__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _jqxcalendar__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_4237866__(5725);
/* harmony import */ var _jqxcalendar__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxcalendar__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _jqxdatetimeinput__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_4237866__(4993);
/* harmony import */ var _jqxdatetimeinput__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxdatetimeinput__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _jqxgrid__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_4237866__(4007);
/* harmony import */ var _jqxgrid__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _jqxgrid_edit__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_4237866__(5574);
/* harmony import */ var _jqxgrid_edit__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_edit__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _jqxgrid_pager__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_4237866__(5911);
/* harmony import */ var _jqxgrid_pager__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_pager__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var _jqxgrid_selection__WEBPACK_IMPORTED_MODULE_19__ = __nested_webpack_require_4237866__(9041);
/* harmony import */ var _jqxgrid_selection__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_selection__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var _jqxgrid_filter__WEBPACK_IMPORTED_MODULE_20__ = __nested_webpack_require_4237866__(8690);
/* harmony import */ var _jqxgrid_filter__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_filter__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _jqxgrid_sort__WEBPACK_IMPORTED_MODULE_21__ = __nested_webpack_require_4237866__(4687);
/* harmony import */ var _jqxgrid_sort__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_sort__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _jqxgrid_storage__WEBPACK_IMPORTED_MODULE_22__ = __nested_webpack_require_4237866__(9701);
/* harmony import */ var _jqxgrid_storage__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_storage__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var _jqxgrid_grouping__WEBPACK_IMPORTED_MODULE_23__ = __nested_webpack_require_4237866__(3066);
/* harmony import */ var _jqxgrid_grouping__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_grouping__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var _jqxgrid_export__WEBPACK_IMPORTED_MODULE_24__ = __nested_webpack_require_4237866__(469);
/* harmony import */ var _jqxgrid_export__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_export__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var _jqxgrid_columnsresize__WEBPACK_IMPORTED_MODULE_25__ = __nested_webpack_require_4237866__(4854);
/* harmony import */ var _jqxgrid_columnsresize__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_columnsresize__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var _jqxgrid_columnsreorder__WEBPACK_IMPORTED_MODULE_26__ = __nested_webpack_require_4237866__(2421);
/* harmony import */ var _jqxgrid_columnsreorder__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_columnsreorder__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var _jqxgrid_aggregates__WEBPACK_IMPORTED_MODULE_27__ = __nested_webpack_require_4237866__(3189);
/* harmony import */ var _jqxgrid_aggregates__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_aggregates__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _jqxgrid_chart__WEBPACK_IMPORTED_MODULE_28__ = __nested_webpack_require_4237866__(2465);
/* harmony import */ var _jqxgrid_chart__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__nested_webpack_require_4237866__.n(_jqxgrid_chart__WEBPACK_IMPORTED_MODULE_28__);





























})();

/******/ })()
;
/******/ })()
;